/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "46a83330eb1d9a521b97"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(106);
	module.exports = __webpack_require__(162);


/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(111);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 3 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.3.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(45)('wks')
	  , uid        = __webpack_require__(29)
	  , Symbol     = __webpack_require__(5).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 5 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(16);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(6)
	  , IE8_DOM_DEFINE = __webpack_require__(62)
	  , toPrimitive    = __webpack_require__(49)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(21)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(5)
	  , core      = __webpack_require__(3)
	  , ctx       = __webpack_require__(15)
	  , hide      = __webpack_require__(11)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 10 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(7)
	  , createDesc = __webpack_require__(22);
	module.exports = __webpack_require__(8) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(133)
	  , defined = __webpack_require__(39);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 队列Queue
	 *
	 * 队列是一种先进先出（first in first out, FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。
	 * 允许插入的一端叫队尾（rear），允许删除的一端叫队头（front）。
	 */
	
	// 链队列
	
	var Queue = function () {
	    function Queue() {
	        (0, _classCallCheck3.default)(this, Queue);
	
	        this.rear = this.front = null;
	        this.size = 0;
	    }
	
	    (0, _createClass3.default)(Queue, [{
	        key: "isEmpty",
	        value: function isEmpty() {
	            return this.rear === null;
	        }
	    }, {
	        key: "clear",
	        value: function clear() {
	            this.rear = this.front = null;
	            this.size = 0;
	        }
	    }, {
	        key: "getHead",
	        value: function getHead() {
	            return this.front ? this.front.data : null;
	        }
	    }, {
	        key: "enQueue",
	        value: function enQueue(elem) {
	            if (this.front === null) {
	                this.rear = this.front = { data: elem, next: null };
	            } else {
	                var p = { data: elem, next: null };
	                this.rear.next = p;
	                this.rear = p;
	            }
	            this.size++;
	        }
	    }, {
	        key: "deQueue",
	        value: function deQueue() {
	            if (this.front) {
	                var elem = this.front.data;
	                this.front = this.front.next;
	                if (this.front === null) {
	                    this.rear = null;
	                }
	                this.size--;
	                return elem;
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: "queueTraverse",
	        value: function queueTraverse(iterator) {
	            var current = this.front;
	            while (current) {
	                if (iterator(current.data)) break;
	                current = current.next;
	            }
	        }
	    }, {
	        key: "peekAt",
	        value: function peekAt() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	            if (index < this.size) {
	                var current = this.front;
	                for (var i = 0; i < index; i++) {
	                    current = current.next;
	                }
	                return current.data;
	            }
	
	            return null;
	        }
	    }, {
	        key: "toString",
	        value: function toString() {
	            if (this.front === null) {
	                return null;
	            }
	
	            var arr = [];
	            var current = this.front;
	
	            for (var i = 0, len = this.size; i < len; i++) {
	                arr[i] = current.data;
	                current = current.next;
	            }
	
	            return arr;
	        }
	    }]);
	    return Queue;
	}();
	
	exports.default = Queue;
	
	
	var queue = new Queue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));
	console.log(queue.peekAt(3));
	console.log(queue.toString().join());
	
	// 类似广度优先遍历
	function repaintColor(matrix, i, j, color) {
	    var old = matrix[i][j];
	    var queue = new Queue();
	    var m = matrix.length - 1;
	    var n = matrix[0].length - 1;
	
	    queue.enQueue({ x: i, y: j });
	
	    while (queue.rear) {
	        var a = queue.deQueue();
	        var x = a.x;
	        var y = a.y;
	
	        if (x >= 1) setColor(x - 1, y);
	        if (y >= 1) setColor(x, y - 1);
	        if (x < m) setColor(x + 1, y);
	        if (y < n) setColor(x, y + 1);
	    }
	
	    function setColor(x, y) {
	        if (matrix[x][y] === old) {
	            matrix[x][y] = color;
	            queue.enQueue({ x: x, y: y });
	        }
	    }
	}
	
	var matrix = [];
	
	for (var i = 0; i < 8; i++) {
	    matrix[i] = [];
	    for (var j = 0; j < 8; j++) {
	        matrix[i][j] = 0;
	    }
	}
	
	repaintColor(matrix, 4, 5, 1);
	console.log(matrix);

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(125), __esModule: true };

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(37);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ChildSiblingTree = exports.ChildTree = exports.ParentTree = exports.BinaryTree = undefined;
	
	var _getIterator2 = __webpack_require__(25);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _regenerator = __webpack_require__(53);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator2 = __webpack_require__(14);
	
	var _iterator3 = _interopRequireDefault(_iterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _index = __webpack_require__(19);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(13);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 树的一些概念
	 *
	 * 树（Tree）是n（n>=0）个结点的有限集。在任意一棵非空树中：
	 * （1）有且仅有一个特定的称为根（Root）的结点；
	 * （2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,T3,...Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。
	 *
	 * 例如，（a）是只有一个根结点的树；
	 * （b）是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。
	 *
	 * 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。例如，（b）中A的度为3，C的度为1，F的度为0.度为0的结点称为叶子（Leaf）或者终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。（b）的树的度为3.结点的子树的根称为该结点的孩子（Child）。相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。
	 * 结点的层次（Level）从根开始定义起，根为第一层，跟的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。例如，结点G与E，F,H,I,J互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。（b）的树的深度为4。
	 *
	 * 如果将树中结点的各子树看成从左至右是有次序的（即不能交换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
	 * 森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
	 *
	 *
	 */
	
	/**
	 * 二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）
	 *
	 * 二叉树的性质
	 * 1.在二叉树的第i层上至多有2的i-1次方个结点(i>=1)。
	 * 2.深度为k的二叉树至多有2的k次方-1个结点，(k>=1)。
	 * 3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1;
	 *      一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树。
	 *      深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。
	 * 下面是完全二叉树的两个特性
	 * 4.具有n个结点的完全二叉树的深度为Math.floor(log 2 n) + 1
	 * 5.如果对一棵有n个结点的完全二叉树（其深度为Math.floor(log 2 n) + 1）的结点按层序编号（从第1层到第Math.floor(2 n) + 1，每层从左到右），则对任一结点（1<=i<=n）有：
	 *     (1)如果i=1，则结点i、是二叉树的根，无双亲；如果i>1，则其双亲parent(i)是结点Math.floor(i/2)。
	 *     (2)如果2i > n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LChild(i)是结点2i.
	 *     (3)如果2i + 1 > n，则结点i无右孩子；否则其右孩子RChild(i)是结点2i + 1;
	 */
	
	/*
	 二叉树的存储结构
	
	 1.顺序存储结构
	 用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，即将二叉树上编号为i的结点元素存储在加上定义的一维数组中下标为i-1的分量中。“0”表示不存在此结点。这种顺序存储结构仅适用于完全二叉树。
	 因为，在最坏情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为2的n次方-1的一维数组。
	
	 2.链式存储结构
	 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左右指针域。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结构所得的二叉树的存储结构分别称之为二叉链表和三叉链表。
	 在含有n个结点的二叉链表中有n+1个空链域，我们可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构---线索链表。
	
	 先（根）序遍历：根左右
	 中（根）序遍历：左根右
	 后（根）序遍历：左右根
	
	 */
	
	// 顺序存储结构
	(function () {
	    // 顺序存储结构的遍历
	    var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	
	    console.log('preOrder:');
	    void function preOrderRecursive(x, visit) {
	        visit(tree[x]);
	        if (tree[2 * x + 1]) preOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) preOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('inOrder:');
	    void function inOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) inOrderRecursive(2 * x + 1, visit);
	        visit(tree[x]);
	        if (tree[2 * x + 2]) inOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('postOrder:');
	    void function postOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) postOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) postOrderRecursive(2 * x + 2, visit);
	        visit(tree[x]);
	    }(0, function (value) {
	        console.log(value);
	    });
	})();
	
	// 链式存储结构
	
	var BinaryTree = exports.BinaryTree = function () {
	    function BinaryTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var leftChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var rightChild = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, BinaryTree);
	
	        this.data = data;
	        // 左右孩子结点
	        this.leftChild = leftChild;
	        this.rightChild = rightChild;
	    }
	
	    // 判断两棵树是否相似
	
	
	    (0, _createClass3.default)(BinaryTree, [{
	        key: 'isSimilar',
	        value: function isSimilar(tree) {
	            return !!(tree && (this.leftChild && this.leftChild.isSimilar(tree.leftChild) || !this.leftChild && !tree.leftChild) && (this.rightChild && this.rightChild.isSimilar(tree.rightChild) || !this.rightChild && !tree.rightChild));
	        }
	    }, {
	        key: 'createBinaryTree',
	        value: function createBinaryTree(tree) {
	            void function preOrderRecursive(node, x, visit) {
	                visit(node, tree[x]);
	
	                var p = void 0;
	                if (tree[2 * x + 1]) {
	                    p = node.leftChild = new BinaryTree();
	                    preOrderRecursive(p, 2 * x + 1, visit);
	                }
	                if (tree[2 * x + 2]) {
	                    p = node.rightChild = new BinaryTree();
	                    preOrderRecursive(p, 2 * x + 2, visit);
	                }
	
	                if (p) p.parentNode = node;
	            }(this, 0, function (node, value) {
	                node.data = value;
	            });
	        }
	
	        /** Prefix iteration */
	
	    }, {
	        key: _iterator3.default,
	        value: _regenerator2.default.mark(function value() {
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return this.data;
	
	                        case 2:
	                            if (!this.leftChild) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            return _context.delegateYield(this.leftChild, 't0', 4);
	
	                        case 4:
	                            if (!this.rightChild) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            return _context.delegateYield(this.rightChild, 't1', 6);
	
	                        case 6:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	
	        // 先序遍历二叉树的非递归算法
	
	    }, {
	        key: 'preOrderNonRecursive',
	        value: function preOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            var p = this;
	
	            while (p || stack.length) {
	                // 向左走到尽头
	                if (p) {
	                    stack.push(p);
	                    p.data && visit(p.data);
	                    p = p.leftChild;
	                } else {
	                    p = stack.pop();
	                    p = p.rightChild;
	                }
	            }
	        }
	
	        // 中序非递归遍历
	
	    }, {
	        key: 'inOrderNonRecursive',
	        value: function inOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            var p = this;
	
	            while (p || stack.length) {
	                if (p) {
	                    stack.push(p);
	                    p = p.leftChild;
	                } else {
	                    p = stack.pop();
	                    p.data && visit(p.data);
	                    p = p.rightChild;
	                }
	            }
	        }
	
	        // 为了区分两次过栈的不同处理方式，在堆栈中增加一个mark域，
	        // mark=0表示刚刚访问此结点，mark=1表示左子树处理结束返回，
	        // mark=2表示右子树处理结束返回。每次根据栈顶的mark域决定做何动作
	
	    }, {
	        key: 'postOrderNonRecursive',
	        value: function postOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            stack.push([this, 0]);
	
	            while (stack.length) {
	                var a = stack.pop();
	                var node = a[0];
	
	                switch (a[1]) {
	                    case 0:
	                        stack.push([node, 1]); // 修改mark域
	                        if (node.leftChild) stack.push([node.leftChild, 0]); // 访问左子树
	                        break;
	                    case 1:
	                        stack.push([node, 2]);
	                        if (node.rightChild) stack.push([node.rightChild, 0]);
	                        break;
	                    case 2:
	                        node.data && visit(node.data);
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	    }, {
	        key: 'preOrderRecursive',
	        value: function preOrderRecursive(visit) {
	            visit(this.data);
	            if (this.leftChild) this.leftChild.preOrderRecursive(visit);
	            if (this.rightChild) this.rightChild.preOrderRecursive(visit);
	        }
	    }, {
	        key: 'inOrderRecursive',
	        value: function inOrderRecursive(visit) {
	            if (this.leftChild) this.leftChild.inOrderRecursive(visit);
	            visit(this.data);
	            if (this.rightChild) this.rightChild.inOrderRecursive(visit);
	        }
	    }, {
	        key: 'postOrderRecursive',
	        value: function postOrderRecursive(visit) {
	            if (this.leftChild) this.leftChild.postOrderRecursive(visit);
	            if (this.rightChild) this.rightChild.postOrderRecursive(visit);
	            visit(this.data);
	        }
	    }, {
	        key: 'levelOrderTraverse',
	        value: function levelOrderTraverse(visit) {
	            var queue = new _Queue2.default();
	            queue.enQueue(this);
	
	            while (queue.rear) {
	                var p = queue.deQueue();
	                p.data && visit(p.data);
	                p.leftChild && queue.enQueue(p.leftChild);
	                p.rightChild && queue.enQueue(p.rightChild);
	            }
	        }
	
	        // 求先序序列为k的结点的值
	
	    }, {
	        key: 'getPreSequence',
	        value: function getPreSequence(k) {
	            var count = 0;
	            var data = null;
	
	            void function recurse(node) {
	                if (node) {
	                    if (++count === k) data = node.data;else {
	                        recurse(node.leftChild);
	                        recurse(node.rightChild);
	                    }
	                }
	            }(this);
	
	            return data;
	        }
	
	        // 求二叉树中叶子结点的数目
	
	    }, {
	        key: 'countLeaves',
	        value: function countLeaves() {
	            return function recurse(node) {
	                if (!node) return 0;else if (!node.leftChild && !node.rightChild) return 1;else return recurse(node.leftChild) + recurse(node.rightChild);
	            }(this);
	        }
	
	        // 交换所有结点的左右子树
	
	    }, {
	        key: 'revoluteBinaryTree',
	        value: function revoluteBinaryTree() {
	            var _ref = [this.rightChild, this.leftChild];
	            this.leftChild = _ref[0];
	            this.rightChild = _ref[1];
	
	
	            if (this.leftChild) this.leftChild.revoluteBinaryTree();
	            if (this.rightChild) this.rightChild.revoluteBinaryTree();
	        }
	    }, {
	        key: 'revoluteNonRecursive',
	        value: function revoluteNonRecursive() {
	            var stack = [];
	            stack.push(this);
	
	            while (stack.length) {
	                var node = stack.pop();
	                var _ref2 = [node.rightChild, node.leftChild];
	                node.leftChild = _ref2[0];
	                node.rightChild = _ref2[1];
	
	
	                if (node.leftChild) stack.push(node.leftChild);
	                if (node.rightChild) stack.push(node.rightChild);
	            }
	        }
	
	        // 求二叉树中以值为x的结点为根的子树深度
	
	    }, {
	        key: 'getSubDepth',
	        value: function getSubDepth(x) {
	            var count = 0;
	            var stack = new _index2.default();
	            stack.push(this);
	
	            while (stack.length) {
	                var node = stack.pop();
	
	                if (node.data === x) {
	                    count = node.getDepth();
	                    break;
	                } else {
	                    if (node.leftChild) stack.push(node.leftChild);
	                    if (node.rightChild) stack.push(node.rightChild);
	                }
	            }
	
	            return count;
	        }
	    }, {
	        key: 'getDepth',
	        value: function getDepth() {
	            var m = this.leftChild && this.leftChild.getDepth() || 0;
	            var n = this.rightChild && this.rightChild.getDepth() || 0;
	            return (m > n ? m : n) + 1;
	        }
	
	        // 删除所有以元素x为根的子树
	
	    }, {
	        key: 'delSubX',
	        value: function delSubX(x) {
	            if (this.data === x) {
	                this.leftChild = null;
	                this.rightChild = null;
	            } else {
	                if (this.leftChild) this.leftChild.delSubX(x);
	                if (this.rightChild) this.rightChild.delSubX(x);
	            }
	        }
	
	        /**
	         * 非递归复制二叉树
	         * @param {Function} cb 拷贝过程中会执行的回调，可以用来拷贝其它自定义属性
	         * @returns {Cstr} 返回新的实例
	         */
	
	    }, {
	        key: 'copy',
	        value: function copy() {
	            var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
	
	            // 用来存放本体结点的栈
	            var stack1 = new _index2.default();
	            // 用来存放新二叉树结点的栈
	            var stack2 = new _index2.default();
	            stack1.push(this);
	            var Cstr = this.constructor;
	            var newTree = new Cstr();
	            var q = newTree;
	            stack2.push(newTree);
	            var p = void 0;
	
	            while (stack1.length) {
	                // 向左走到尽头
	                while (p = stack1.peek()) {
	                    if (p.leftChild) q.leftChild = new Cstr();
	                    q = q.leftChild;
	                    stack1.push(p.leftChild);
	                    stack2.push(q);
	                }
	
	                p = stack1.pop();
	                q = stack2.pop();
	
	                if (stack1.length) {
	                    p = stack1.pop();
	                    q = stack2.pop();
	                    if (p.rightChild) q.rightChild = new Cstr();
	                    q.data = p.data;
	                    cb(q, p);
	                    q = q.rightChild;
	                    stack1.push(p.rightChild); // 向右一步
	                    stack2.push(q);
	                }
	            }
	
	            return newTree;
	        }
	
	        // 求二叉树中结点p和q的最近祖先
	
	    }, {
	        key: 'findNearAncient',
	        value: function findNearAncient(pNode, qNode) {
	            var pathP = findPath(this, pNode, 0);
	            var pathQ = findPath(this, qNode, 0);
	
	            for (var i = 0; pathP[i] == pathQ[i] && pathP[i]; i++) {}
	            return pathP[--i];
	        }
	
	        // todo
	
	    }, {
	        key: 'toString',
	        value: function toString() {}
	
	        // 求一棵二叉树的繁茂度
	
	    }, {
	        key: 'lushDegree',
	        value: function lushDegree() {
	            var countArr = [];
	            var queue = new _Queue2.default();
	            queue.enQueue({
	                node: this,
	                layer: 0
	            });
	            // 利用层序遍历来统计各层的结点数
	            var r = void 0;
	            while (queue.rear) {
	                r = queue.deQueue();
	                countArr[r.layer] = (countArr[r.layer] || 0) + 1;
	
	                if (r.node.leftChild) queue.enQueue({
	                    node: r.node.leftChild,
	                    layer: r.layer + 1
	                });
	                if (r.node.rightChild) queue.enQueue({
	                    node: r.node.rightChild,
	                    layer: r.layer + 1
	                });
	            }
	
	            // 最后一个队列元素所在层就是树的高度
	            var height = r.layer;
	            var max = countArr[0];
	            for (var i = 1; countArr[i]; i++) {
	                // 求层最大结点数
	                if (countArr[i] > max) max = countArr[i];
	            }return height * max;
	        }
	
	        // 求树结点的子孙总数填入descNum域中，并返回
	
	    }, {
	        key: 'descNum',
	        value: function descNum() {
	            return function recurse(node) {
	                var d = void 0;
	                if (!node) return -1;else d = recurse(node.leftChild) + recurse(node.rightChild) + 2;
	
	                node.descNum = d;
	
	                return d;
	            }(this);
	        }
	
	        // 判断二叉树是否完全二叉树
	
	    }], [{
	        key: 'isFullBinaryTree',
	        value: function isFullBinaryTree(tree) {
	            var queue = new _Queue2.default();
	            var flag = 0;
	            queue.enQueue(tree);
	
	            while (queue.rear) {
	                var p = queue.deQueue();
	
	                if (!p) flag = 1;else if (flag) return false;else {
	                    queue.enQueue(p.leftChild);
	                    queue.enQueue(p.rightChild);
	                }
	            }
	
	            return true;
	        }
	    }]);
	    return BinaryTree;
	}();
	
	// 求从tree到node结点路径的递归算法
	
	
	function findPath(tree, node) {
	    var i = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    var path = [];
	    var found = false;
	
	    void function recurse(tree, i) {
	        if (tree == node) {
	            found = true;
	            return;
	        }
	
	        path[i] = tree;
	        if (tree.leftChild) recurse(tree.leftChild, i + 1);
	        if (tree.rightChild && !found) recurse(tree.rightChild, i + 1);
	        if (!found) path[i] = null;
	    }(tree, i);
	
	    return path;
	}
	
	var global = Function('return this;')();
	
	// 求深度等于树的高度减一的最靠左的结点
	function printPath_maxDepthS1(tree) {
	    var maxh = tree.getDepth();
	    var path = [];
	
	    if (maxh < 2) return false;
	    find_h(tree, 1);
	
	    function find_h(tree, h) {
	        path[h] = tree;
	
	        if (h == maxh - 1) {
	            var s = ' ';
	            for (var i = 1; path[i]; i++) {
	                s += path[i].data + (path[i + 1] ? ' -> ' : '');
	            }console.log(s);
	            return;
	        } else {
	            if (tree.leftChild) find_h(tree.leftChild, h + 1);
	            if (tree.rightChild) find_h(tree.rightChild, h + 1);
	        }
	
	        path[h] = null;
	    }
	}
	
	var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	var test = new BinaryTree();
	test.createBinaryTree(tree);
	
	console.log('iterator: ');
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;
	
	try {
	    for (var _iterator = (0, _getIterator3.default)(test), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var x = _step.value;
	
	        console.log(x);
	    }
	
	    /**
	     * 树的3种常用链表结构
	     */
	
	    // 1.双亲表示法
	    // 优点：parent(tree, x)操作可以在常量时间内实现
	    // 缺点：求结点的孩子时需要遍历整个结构
	} catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	        }
	    } finally {
	        if (_didIteratorError) {
	            throw _iteratorError;
	        }
	    }
	}
	
	var ParentTree = exports.ParentTree = function () {
	    function ParentTree() {
	        (0, _classCallCheck3.default)(this, ParentTree);
	
	        this.nodes = [];
	    }
	
	    (0, _createClass3.default)(ParentTree, [{
	        key: 'getDepth',
	        value: function getDepth() {
	            var maxDepth = 0;
	
	            for (var i = 0; i < this.nodes.length; i++) {
	                var dep = 0;
	                for (var j = i; j >= 0; j = this.nodes[i].parent) {
	                    dep++;
	                }if (dep > maxDepth) maxDepth = dep;
	            }
	
	            return maxDepth;
	        }
	    }]);
	    return ParentTree;
	}();
	
	var ParentTreeNode = function ParentTreeNode() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var parent = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    (0, _classCallCheck3.default)(this, ParentTreeNode);
	
	    // type: ParentTree
	    this.data = data;
	    // 双亲位置域 {Number}
	    this.parent = parent;
	};
	
	var pt = new ParentTree();
	pt.nodes.push(new ParentTreeNode('R', -1));
	pt.nodes.push(new ParentTreeNode('A', 0));
	pt.nodes.push(new ParentTreeNode('B', 0));
	pt.nodes.push(new ParentTreeNode('C', 0));
	pt.nodes.push(new ParentTreeNode('D', 1));
	pt.nodes.push(new ParentTreeNode('E', 1));
	pt.nodes.push(new ParentTreeNode('F', 3));
	pt.nodes.push(new ParentTreeNode('G', 6));
	pt.nodes.push(new ParentTreeNode('H', 6));
	pt.nodes.push(new ParentTreeNode('I', 6));
	
	// 孩子表示法
	
	var ChildTree = exports.ChildTree = function () {
	    function ChildTree() {
	        (0, _classCallCheck3.default)(this, ChildTree);
	
	        this.nodes = [];
	    }
	
	    (0, _createClass3.default)(ChildTree, [{
	        key: 'getDepth',
	        value: function getDepth() {
	            var self = this;
	            return function subDepth(rootIndex) {
	                if (!self.nodes[rootIndex]) return 1;
	
	                var sd = 1;
	                for (var p = self.nodes[rootIndex]; p; p = p.next) {
	                    var d = subDepth(p.child);
	                    if (d > sd) sd = d;
	                }
	
	                return sd + 1;
	            }(this.data[0]);
	        }
	    }]);
	    return ChildTree;
	}();
	/**
	 *
	 * @param {*} data
	 * @param {ChildTreeNode} firstChild 孩子链表头指针
	 * @constructor
	 */
	
	
	var ChildTreeBox = function ChildTreeBox() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeBox);
	
	    this.data = data;
	    this.firstChild = firstChild;
	};
	
	/**
	 * 孩子结点
	 *
	 * @param {Number} child
	 * @param {ChildTreeNode} next
	 * @constructor
	 */
	
	
	var ChildTreeNode = function ChildTreeNode() {
	    var child = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeNode);
	
	    this.child = child;
	    this.next = next;
	};
	
	/*
	 孩子表示法便于涉及孩子的操作的实现，但不适用于parent操作。
	 我们可以把双亲表示法和孩子表示法结合起来。
	 */
	
	// 孩子兄弟表示法(二叉树表示法)
	// 可增设一个parent域实现parent操作
	
	
	var ChildSiblingTree = exports.ChildSiblingTree = function () {
	    function ChildSiblingTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var nextSibling = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, ChildSiblingTree);
	
	        this.data = data;
	        this.firstChild = firstChild;
	        this.nextSibling = nextSibling;
	    }
	
	    // 输出孩子兄弟链表表示的树的各边
	
	
	    (0, _createClass3.default)(ChildSiblingTree, [{
	        key: 'print',
	        value: function print() {
	            for (var child = this.firstChild; child; child = child.nextSibling) {
	                console.log('%c %c', this.data, child.data);
	                child.print();
	            }
	        }
	
	        // 求孩子兄弟链表表示的树的叶子数目
	
	    }, {
	        key: 'leafCount',
	        value: function leafCount() {
	            if (!this.firstChild) return 1;else {
	                var count = 0;
	                for (var child = this.firstChild; child; child = child.nextSibling) {
	                    count += child.leafCount();
	                }
	                return count;
	            }
	        }
	
	        // 求树的度
	
	    }, {
	        key: 'getDegree',
	        value: function getDegree() {
	            if (!this.firstChild) return 0;else {
	                var degree = 0;
	                for (var p = this.firstChild; p; p = p.nextSibling) {
	                    degree++;
	                }for (var _p = this.firstChild; _p; _p = _p.nextSibling) {
	                    var d = _p.getDegree();
	                    if (d > degree) degree = d;
	                }
	
	                return degree;
	            }
	        }
	    }, {
	        key: 'getDepth',
	        value: function getDepth() {
	            if (this === global) return 0;else {
	                var maxd = 0;
	                for (var p = this.firstChild; p; p = p.nextSibling) {
	                    var d = p.getDepth();
	                    if (d > maxd) maxd = d;
	                }
	
	                return maxd + 1;
	            }
	        }
	    }]);
	    return ChildSiblingTree;
	}();

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 栈
	 *
	 * 是限定仅在表尾进行插入或删除操作的线性表。表尾为栈顶（top），表头为栈底（bottom），不含元素的空表为空栈。
	 * 栈又称为后进先出（last in first out）的线性表。
	 */
	
	/**
	 * 顺序栈
	 * 栈的顺序存储结构是利用一组地址连续的存储单元依次存放至栈底到栈顶的元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
	 *
	 */
	
	// 栈的链式表示
	
	var Stack = function () {
	    function Stack() {
	        (0, _classCallCheck3.default)(this, Stack);
	
	        this.top = null;
	        this.length = 0;
	    }
	
	    (0, _createClass3.default)(Stack, [{
	        key: 'isEmpty',
	        value: function isEmpty() {
	            return this.length === 0;
	        }
	    }, {
	        key: 'push',
	        value: function push(data) {
	            var node = {
	                data: data,
	                next: null
	            };
	
	            node.next = this.top;
	            this.top = node;
	            this.length++;
	        }
	    }, {
	        key: 'peek',
	        value: function peek() {
	            return this.top === null ? null : this.top.data;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            if (this.top === null) return null;
	
	            var out = this.top;
	            this.top = this.top.next;
	
	            if (this.length > 0) this.length--;
	
	            return out.data;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.top = null;
	            this.length = 0;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            if (this.top === null) return null;
	
	            var arr = [];
	            var current = this.top;
	
	            for (var i = 0, len = this.size; i < len; i++) {
	                arr[i] = current.data;
	                current = current.next;
	            }
	
	            return arr;
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.length;
	        }
	    }]);
	    return Stack;
	}();
	
	exports.default = Stack;
	
	
	var stack = new Stack();
	
	stack.push(1);
	stack.push('asd');
	
	stack.pop();
	stack.push({ a: 1 });
	console.log(stack);
	
	/**
	 * 这里用字符串train表示火车，H表示硬席，S表示软席
	 * @param {String} train
	 */
	function trainArrange(train) {
	    var stack = new Stack();
	    var q = [];
	    var i = 0;
	    var j = 0;
	
	    while (train[i]) {
	        if (train[i] === 'H') stack.push(train[i]);else q[j++] = train[i];
	        i++;
	    }
	
	    while (stack.length) {
	        var c = stack.pop();
	        q[j++] = c;
	    }
	
	    return q + '';
	}
	
	console.log('trainArrange: ' + trainArrange('HSSHSSSHHHHHS')); // trainArrange: S,S,S,S,S,S,H,H,H,H,H,H,H
	
	// 判断字符串中“&”前和“&”后部分是否为逆串，"@"表示结束符，是则返回true，否则返回false
	function isReverse(str) {
	    var stack = new Stack();
	    var i = 0;
	
	    while (str[i] !== '&') {
	        if (str[i] === '@') return false;
	        stack.push(str[i]);
	        i++;
	    }
	
	    i++;
	
	    while (str[i] !== '@') {
	        if (!stack.length) return false;
	
	        var s = stack.pop();
	        if (s !== str[i]) return false;
	        i++;
	    }
	
	    return !stack.length;
	}
	
	console.log('isReverse: ' + isReverse('abcd&dcba@a')); // true
	
	// 数值进制转换
	// 公式： N = (N / d) * d + N % d
	// N：十进制数值， d：需要转换的进制数
	function numTransform(number, rad) {
	    var s = new Stack();
	
	    while (number) {
	        s.push(number % rad);
	        number = parseInt(number / 8, 10);
	    }
	
	    var arr = [];
	    while (s.top) {
	        arr.push(s.pop());
	    }
	    console.log(arr.join(''));
	}
	
	numTransform(1348, 8);
	numTransform(1348, 2);
	
	// 括号匹配检查
	function bracketsMatch(str) {
	    var stack = new Stack();
	    var text = '';
	
	    for (var i = 0, len = str.length; i < len; i++) {
	        var c = str[i];
	        if (c === '[') {
	            stack.push(c);
	        } else if (c === ']') {
	            if (!stack.length || stack.pop() !== '[') throw new Error('unexpected brackets:' + c);
	        } else {
	            text += c;
	        }
	    }
	    console.log(text);
	}
	
	console.log(bracketsMatch('[asd]'));
	
	function Matcher(left, right) {
	    this.left = left;
	    this.right = right;
	    this.stack = new Stack();
	}
	Matcher.prototype = {
	    match: function match(str) {
	        var text = '';
	
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            if (c === this.left) {
	                this.stack.push(c);
	            } else if (c === this.right) {
	                if (!this.stack.length || this.stack.pop() !== this.left) {
	                    throw new Error('unexpected brackets:' + c);
	                } else {
	                    text += ',';
	                }
	            } else {
	                text += c;
	            }
	        }
	        console.log(text);
	        return text;
	    }
	};
	var m = new Matcher('{', '}');
	m.match('[{123}123');
	
	function LineEditor(str) {
	    this.stack = new Stack();
	    this.str = str || '';
	}
	LineEditor.prototype = {
	    getResult: function getResult() {
	        var stack = this.stack;
	        var str = this.str;
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            switch (c) {
	                case '#':
	                    stack.pop();
	                    break;
	                case '@':
	                    stack.clear();
	                    break;
	                default:
	                    stack.push(c);
	                    break;
	            }
	        }
	
	        var result = '';
	        var current = stack.length;
	        while (current) {
	            result = current.data + result;
	            current = current.next;
	        }
	
	        return result;
	    }
	};
	
	var le = new LineEditor('whli##ilr#e(s#*s)\
	    \noutcha@putchar(*s=#++)');
	console.log(le.getResult());
	
	var prioty = {
	    "+": 1,
	    "-": 1,
	    "%": 2,
	    "*": 2,
	    "/": 2,
	    "^": 3,
	    "(": 0,
	    ")": 0,
	    "`": -1
	};
	
	function doop(op, opn1, opn2) {
	    switch (op) {
	        case "+":
	            return opn1 + opn2;
	        case "-":
	            return opn1 - opn2;
	        case "*":
	            return opn1 * opn2;
	        case "/":
	            return opn1 / opn2;
	        case "%":
	            return opn1 % opn2;
	        case "^":
	            return Math.pow(opn1, opn2);
	        default:
	            return 0;
	    }
	}
	
	function opcomp(a, b) {
	    return prioty[a] - prioty[b];
	}
	
	function calInfixExpression(exp) {
	    var cs = [];
	    var ns = [];
	    exp = exp.replace(/\s/g, "");
	    exp += '`';
	    if (exp[0] === '-') {
	        exp = "0" + exp;
	    }
	    var c = void 0;
	    var op = void 0;
	    var opn1 = void 0;
	    var opn2 = void 0;
	    for (var i = 0; i < exp.length; ++i) {
	        c = exp[i];
	        // 如果是操作符
	        if (c in prioty) {
	            // 如果右边不是左括号且操作符栈的栈顶元素优先权比右边大
	            // 循环遍历进行连续运算
	            while (c != '(' && cs.length && opcomp(cs[cs.length - 1], c) >= 0) {
	                // 出栈的操作符
	                op = cs.pop();
	                // 如果不是左括号或者右括号，说明是运算符
	                if (op != '(' && op != ')') {
	                    // 出栈保存数字的栈的两个元素
	                    opn2 = ns.pop();
	                    opn1 = ns.pop();
	                    // 将与操作符运算后的结果保存到栈顶
	                    ns.push(doop(op, opn1, opn2));
	                }
	            }
	            // 如果右边不是右括号，保存到操作符栈中
	            if (c != ')') cs.push(c);
	        } else {
	            // 多位数的数字的情况
	            while (!(exp[i] in prioty)) {
	                i++;
	                c += exp[i];
	            }
	            ns.push(parseFloat(c));
	            i--;
	        }
	    }
	    return ns.length ? ns[0] : NaN;
	}
	
	var exp1 = calInfixExpression('5+3*4/2-2^3+5%2');
	console.log(exp1);

/***/ },
/* 20 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(146)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(65)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 24 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Created by ldp on 2015/4/12.
	 */
	
	module.exports = function defaultCompare(a, b) {
	  return a - b;
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(116), __esModule: true };

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(71)
	  , enumBugKeys = __webpack_require__(41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(7).f
	  , has = __webpack_require__(10)
	  , TAG = __webpack_require__(4)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(151);
	var global        = __webpack_require__(5)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(17)
	  , TO_STRING_TAG = __webpack_require__(4)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(119), __esModule: true };

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(121), __esModule: true };

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(124), __esModule: true };

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(60);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(31);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(36);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(36);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(14);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(33);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(20)
	  , TAG = __webpack_require__(4)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(16)
	  , document = __webpack_require__(5).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(6)
	  , dPs         = __webpack_require__(140)
	  , enumBugKeys = __webpack_require__(41)
	  , IE_PROTO    = __webpack_require__(44)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(40)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(61).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(45)('keys')
	  , uid    = __webpack_require__(29);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 46 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(46)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(39);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(16);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(5)
	  , core           = __webpack_require__(3)
	  , LIBRARY        = __webpack_require__(26)
	  , wksExt         = __webpack_require__(51)
	  , defineProperty = __webpack_require__(7).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(4);

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(38)
	  , ITERATOR  = __webpack_require__(4)('iterator')
	  , Iterators = __webpack_require__(17);
	module.exports = __webpack_require__(3).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(160);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	module.exports = { "default": module.exports, __esModule: true };
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _regenerator = __webpack_require__(53);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator3 = __webpack_require__(14);
	
	var _iterator4 = _interopRequireDefault(_iterator3);
	
	var _getIterator2 = __webpack_require__(25);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 循环链表（circular linked list）
	 * 是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个表形成一个环。
	 * 循环链表的操作和线性链表基本一致，仅有细微差别。
	 */
	
	/**
	 * 双向链表
	 *
	 * 双向链表是为了克服单链表这种单向性的缺点。
	 * 双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋。
	 *
	 * 双向链表也可以有循环表。
	 */
	
	var Node = function Node(data) {
	    var prev = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var next = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.prev = prev;
	    this.next = next;
	};
	
	function defaultCompare(a, b) {
	    return a === b;
	}
	
	var DoubleLinkedList = function () {
	    function DoubleLinkedList(sqList) {
	        var compare = arguments.length <= 1 || arguments[1] === undefined ? defaultCompare : arguments[1];
	        (0, _classCallCheck3.default)(this, DoubleLinkedList);
	
	        this.head = null;
	        this.tail = null;
	        this.size = 0;
	        this.compare = compare;
	
	        if (sqList && sqList.length) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = (0, _getIterator3.default)(sqList), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var item = _step.value;
	
	                    this.push(item);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        }
	    }
	
	    (0, _createClass3.default)(DoubleLinkedList, [{
	        key: _iterator4.default,
	        value: _regenerator2.default.mark(function value() {
	            var current;
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            current = this.head;
	
	                        case 1:
	                            if (!current) {
	                                _context.next = 7;
	                                break;
	                            }
	
	                            _context.next = 4;
	                            return current.data;
	
	                        case 4:
	
	                            current = current.next;
	                            _context.next = 1;
	                            break;
	
	                        case 7:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.head = null;
	            this.tail = null;
	            this.size = 0;
	
	            return true;
	        }
	    }, {
	        key: 'push',
	        value: function push(data) {
	            if (typeof data === 'undefined') throw new Error('data argument required');
	
	            ++this.size;
	
	            if (!this.head) {
	                this.head = this.tail = new Node(data);
	            } else {
	                var node = new Node(data, this.tail, null);
	                this.tail.next = node;
	                this.tail = node;
	            }
	
	            return data;
	        }
	    }, {
	        key: 'unshift',
	        value: function unshift(data) {
	            if (typeof data === 'undefined') throw new Error('data argument required');
	
	            ++this.size;
	
	            if (!this.head) {
	                this.head = this.tail = new Node(data);
	            } else {
	                var node = new Node(data, null, this.head);
	                this.head.prev = node;
	                this.head = node;
	            }
	
	            return data;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            if (!this.tail) {
	                this.head = this.tail = null;
	                return;
	            }
	
	            --this.size;
	
	            this.tail.prev.next = null;
	            this.tail = this.tail.prev;
	        }
	    }, {
	        key: 'shift',
	        value: function shift() {
	            if (!this.head) {
	                this.head = this.tail = null;
	                return;
	            }
	
	            --this.size;
	
	            this.head.next.prev = null;
	            this.head = this.head.next;
	        }
	    }, {
	        key: 'update',
	        value: function update(index, data) {
	            var node = this.findByIndex(index, true);
	            node.data = data;
	            return this;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(data) {
	            if (typeof data === 'function') throw new Error('data argument required');
	
	            var current = this.head;
	
	            while (current) {
	                if (this.compare(data, current.data)) {
	                    --this.size;
	
	                    if (current === this.head) {
	                        this.head = this.head.next;
	
	                        if (this.head) {
	                            this.head.prev = null;
	                        } else {
	                            this.head = this.tail = null;
	                        }
	                    } else if (current === this.tail) {
	                        this.tail = this.tail.prev;
	
	                        if (this.tail) {
	                            this.tail.prev.next = null;
	                        } else {
	                            this.head = this.tail = null;
	                        }
	                    } else {
	                        current.prev.next = current.next;
	                        current.next.prev = current.prev;
	                    }
	
	                    return current.data;
	                }
	
	                current = current.next;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(data) {
	            var current = this.head;
	            var index = -1;
	
	            while (current) {
	                ++index;
	                if (this.compare(data, current.data)) return index;
	
	                current = current.next;
	            }
	
	            return -1;
	        }
	    }, {
	        key: 'findByIndex',
	        value: function findByIndex() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            var returnNode = arguments[1];
	
	            var current = this.head;
	            var j = 0;
	
	            while (current) {
	                if (j++ === index) break;
	
	                current = current.next;
	            }
	
	            return returnNode ? current : current.data;
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach() {
	            var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	            if (typeof cb !== 'function') throw new Error('argument should be a function');
	
	            var current = this.head;
	
	            while (current) {
	                cb(current.data);
	
	                current = current.next;
	            }
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            var list = [];
	            var current = this.head;
	
	            while (current) {
	                list.push(current.data);
	
	                current = current.next;
	            }
	
	            return list;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.toJSON() + '';
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this.size;
	        }
	    }]);
	    return DoubleLinkedList;
	}();
	
	exports.default = DoubleLinkedList;
	
	
	var a = new DoubleLinkedList([2, 3]);
	a.unshift(1);
	a.push(4);
	console.log(a.indexOf(4));
	console.log(a.findByIndex(2));
	
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;
	
	try {
	    for (var _iterator2 = (0, _getIterator3.default)(a), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var item = _step2.value;
	
	        console.log(item);
	    }
	} catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	        }
	    } finally {
	        if (_didIteratorError2) {
	            throw _iteratorError2;
	        }
	    }
	}
	
	a.pop();
	a.shift();
	a.remove(2);
	a.remove(32);
	a.remove(3);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(110);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _regenerator = __webpack_require__(53);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator = __webpack_require__(14);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 由于链表在空间的合理利用上和插入，删除时不需要移动等的有点，因此在很多场合下，它是线性表的首选存储结构。然而，它也存在着实现某些基本操作，如求线性表长度时不如顺序存储结构的缺点；另一方面，由于在链表中，结点之间的关系使用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际出发重新定义线性链表及其基本操作
	 */
	
	var Node = function Node() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.next = next;
	};
	
	var LinkedList = function () {
	    function LinkedList(sqList) {
	        (0, _classCallCheck3.default)(this, LinkedList);
	
	        this.head = null;
	        this.tail = null;
	
	        if (sqList) {
	            for (var i = 0, len = sqList.length; i < len; ++i) {
	                this.push(sqList[i]);
	            }
	        }
	    }
	
	    (0, _createClass3.default)(LinkedList, [{
	        key: 'shift',
	
	
	        // delete first element and return it
	        value: function shift() {
	            var head = this.head;
	            this.head = this.head.next;
	            head.next = null;
	
	            if (this.head === null) this.tail = null;
	            return head;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            var current = this.head;
	            var previous = this.head;
	            var elem = void 0;
	
	            while (current !== null) {
	                if (this.tail === current) {
	                    if (current === this.head) {
	                        elem = this.tail.data;
	                        this.head = null;
	                        break;
	                    }
	
	                    this.tail = previous;
	
	                    previous.next = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                previous = current;
	                current = current.next;
	            }
	
	            if (this.head === null) this.tail = null;
	
	            return elem ? elem : false;
	        }
	
	        // append node
	
	    }, {
	        key: 'append',
	        value: function append(node) {
	            if (this.head !== null) {
	                this.tail.next = node;
	                this.tail = this.tail.next;
	            } else {
	                this.head = node;
	                this.tail = node;
	            }
	        }
	
	        // add data
	
	    }, {
	        key: 'push',
	        value: function push(data) {
	            if (this.head === null) {
	                this.head = new Node(data);
	                this.tail = this.head;
	            } else {
	                this.tail.next = new Node(data);
	                this.tail = this.tail.next;
	            }
	
	            this.tail.data = data;
	        }
	
	        // remove data
	
	    }, {
	        key: 'remove',
	        value: function remove(data) {
	            var current = this.head;
	            var previous = this.head;
	            var elem = void 0;
	
	            while (current !== null) {
	                if (data === current.data) {
	                    if (current === this.head) {
	                        this.head = current.next;
	                        elem = current.data;
	                        break;
	                    }
	
	                    if (current === this.tail) this.tail = previous;
	
	                    previous.next = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                previous = current;
	                current = current.next;
	            }
	
	            if (this.head === null) this.tail = null;
	
	            return elem ? elem : false;
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(data) {
	            var current = this.head;
	            var index = -1;
	            while (current !== null) {
	                ++index;
	                if (current.data === data) {
	                    return index;
	                }
	
	                current = current.next;
	            }
	
	            return index;
	        }
	    }, {
	        key: 'unshift',
	        value: function unshift(data) {
	            var temp = new Node(data);
	            temp.next = this.head;
	            this.head = temp;
	        }
	    }, {
	        key: 'insertAfter',
	        value: function insertAfter(target, data) {
	            var current = this.head;
	            while (current !== null) {
	                if (current.data === target) {
	                    var temp = new Node(data);
	                    temp.next = current.next;
	
	                    if (current === this.tail) this.tail = temp;
	
	                    current.next = temp;
	                    return;
	                }
	
	                current = current.next;
	            }
	        }
	    }, {
	        key: 'item',
	        value: function item(index) {
	            var current = this.head;
	
	            while (current !== null) {
	                if (--index === 0) return current;
	
	                current = current.next;
	            }
	
	            return null;
	        }
	    }, {
	        key: 'each',
	        value: function each(callback) {
	            if (typeof callback !== 'function') return;
	
	            for (var current = this.head; current; current = current.next) {
	                if (callback(current)) break;
	            }
	        }
	    }, {
	        key: _iterator2.default,
	        value: _regenerator2.default.mark(function value() {
	            var current;
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            current = this.head;
	
	                        case 1:
	                            if (!current) {
	                                _context.next = 7;
	                                break;
	                            }
	
	                            _context.next = 4;
	                            return current.data;
	
	                        case 4:
	                            current = current.next;
	                            _context.next = 1;
	                            break;
	
	                        case 7:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	    }, {
	        key: 'size',
	        value: function size() {
	            var current = this.head;
	            var size = 0;
	
	            while (current !== null) {
	                ++size;
	                current = current.next;
	            }
	
	            return size;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	
	            this.each(function (node) {
	                str += node.data + (node.next ? ',' : '');
	            });
	
	            return str;
	        }
	    }, {
	        key: 'orderInsert',
	        value: function orderInsert(data, cmp) {
	            cmp = typeof cmp === 'function' ? cmp : function (a, b) {
	                if (a > b) return 1;else if (a === b) return 0;else return -1;
	            };
	            var previous = this.head;
	            var current = this.head;
	
	            if (current === null) {
	                this.head = this.tail = new Node(data);
	                return;
	            }
	
	            var me = this;
	            while (current) {
	                var ret = cmp(data, current.data);
	                // 如果插入元素大于当前元素，准备下次遍历
	                if (ret > 0) {
	                    previous = current;
	                    current = current.next;
	
	                    // 如果等于，直接插入到后面
	                } else if (ret === 0) {
	                        return insertBetween(data, previous, current);
	
	                        // 如果小于则插入到前节点和当前节点中
	                        // 因为已经是排序了，所以不需要多余判断了
	                    } else {
	                            if (this.head === previous && previous === current) return this.unshift(data);else return insertBetween(data, previous, current);
	                        }
	            }
	
	            // 插入到最后一个结点
	            previous.next = new Node(data);
	            this.tail = previous.next;
	
	            function insertBetween(data, a, b) {
	                if (a == b) {
	                    if (a == me.head) return me.unshift(data);
	                } else {
	                    var temp = new Node(data);
	                    temp.next = b;
	                    a.next = temp;
	                    return true;
	                }
	            }
	        }
	
	        // 删除元素递增排列的链表中值大于min，且小于max的所有元素
	
	    }, {
	        key: 'delete_between',
	        value: function delete_between(min, max) {
	            var p = this.head;
	
	            // p是最后一个不大于min的元素
	            while (p.next && p.next.data <= min) {
	                p = p.next;
	            } // 如果还有比min更大的元素
	            var q = void 0;
	            if (p.next) {
	                q = p.next;
	                // q是第一个不小于max的元素
	                while (q && q.data < max) {
	                    q = q.next;
	                }p.next = q;
	            }
	
	            var last = q || p;
	            while (last.next) {
	                last = last.next;
	            }this.tail = last;
	        }
	
	        // 删除元素递增排列的链表的重复元素
	
	    }, {
	        key: 'delete_equal',
	        value: function delete_equal() {
	            var p = this.head;
	            var q = p.next;
	
	            while (p.next) {
	                // 当相邻两元素不相等时，p,q都向后移
	                if (p.data !== q.data) {
	                    p = p.next;
	                    q = p.next;
	                } else {
	                    while (q.data === p.data) {
	                        q = q.next;
	                    } // 删除
	                    p.next = q;
	                    p = q;
	                    q = p.next;
	                }
	            }
	        }
	    }, {
	        key: 'reverse',
	        value: function reverse() {
	            var p = this.head;
	            var q = p.next;
	            var s = q.next;
	            p.next = null;
	
	            while (s.next) {
	                q.next = p;
	                p = q;
	                q = s;
	                s = s.next;
	            }
	
	            q.next = p;
	            s.next = q;
	            this.head = s;
	        }
	    }], [{
	        key: 'mergeList',
	        value: function mergeList(a, b) {
	            var compare = arguments.length <= 2 || arguments[2] === undefined ? compFn : arguments[2];
	
	            var ha = a.head;
	            var hb = b.head;
	            var pa = ha;
	            var pb = hb;
	            var c = new LinkedList();
	            var q = void 0;
	
	            while (pa && pb) {
	                var data1 = pa.data;
	                var data2 = pb.data;
	
	                if (!compare(data1, data2)) {
	                    // delete head node
	                    q = a.shift();
	                    // append the node to c linkedList
	                    c.append(q);
	                    pa = a.head;
	                } else {
	                    q = b.shift();
	                    c.append(q);
	                    pb = b.head;
	                }
	            }
	
	            if (pa) c.append(pa);else c.append(pb);
	
	            return c;
	        }
	    }]);
	    return LinkedList;
	}();
	
	exports.default = LinkedList;
	
	
	function compFn(a, b) {
	    return a - b;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(list, bList) {
	    var cList = new LinkedList();
	
	    var p = list.head;
	    var q = bList.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (q.data > q.data) q = q.next;else {
	            cList.push(q.data);
	            p = p.next;
	            q = q.next;
	        }
	    }
	
	    return cList;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(list, bList) {
	    var p = list.head;
	    var q = bList.head;
	    var pc = list.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            pc.data = p.data;
	            p = p.next;
	            q = q.next;
	
	            if (!p || !q) {
	                pc.next = null;
	                list.tail = pc;
	            } else pc = pc.next;
	        }
	    }
	
	    pc.next = null;
	    list.tail = pc;
	}
	
	// a，b，c的元素均是非递减排列
	// 求a链表中非b链表和c链表的交集的元素。
	function intersect_delete(list, b, c) {
	    var p = b.head;
	    var q = c.head;
	    var r = list.head;
	
	    while (p && q && r) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            // 确定待删除元素
	            var elem = p.data;
	
	            if (r.data === elem && r === list.head) {
	                list.head = list.head.next;
	            } else {
	                // 确定最后一个小于elem的元素指针
	                while (r.next && r.next.data < elem) {
	                    r = r.next;
	                }if (r.next.data === elem) {
	                    var s = r.next;
	
	                    // 确定第一个大于elem的元素指针
	                    while (s && s.data === elem) {
	                        s = s.next;
	                    } // 删除r和s之间的元素
	                    r.next = s;
	                }
	            }
	
	            while (p && p.data === elem) {
	                p = p.next;
	            }while (q && q.data === elem) {
	                q = q.next;
	            }
	        }
	    }
	
	    list.tail = r;
	}
	
	var list = new LinkedList();
	list.push('b');
	list.unshift('a');
	list.insertAfter('b', 'c');
	console.log(list.item(2));
	console.log((0, _stringify2.default)(list));
	list.each(function (node) {
	    if (node.data === 'b') {
	        console.log('get b in each');
	    }
	});
	list.remove('c');
	list.remove('a');
	console.log(list);
	
	var list2 = new LinkedList();
	list2.push('c');
	list2.unshift('d');
	list2.insertAfter('d', 'b');
	console.log((0, _stringify2.default)(list2));
	
	var list3 = LinkedList.mergeList(list, list2);
	console.log(list3);
	
	var list = new LinkedList();
	
	list.orderInsert(5);
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	list.orderInsert(4);
	list.orderInsert(4);
	list.orderInsert(6);
	list.orderInsert(6);
	list.orderInsert(7);
	
	list.delete_between(5, 8);
	console.log('delete-between:  ');
	console.log(list);
	
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	
	list.delete_equal();
	console.log(list);
	
	list.reverse();
	console.log(list);
	
	var a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var b = new LinkedList();
	b.orderInsert(1);
	b.orderInsert(5);
	b.orderInsert(9);
	b.orderInsert(13);
	b.orderInsert(17);
	console.log(intersect(a, b));
	
	console.log(intersect_true(a, b));
	
	a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var test = new LinkedList();
	test.orderInsert(1);
	test.orderInsert(2);
	test.orderInsert(3);
	test.orderInsert(4);
	test.orderInsert(5);
	test.orderInsert(6);
	test.orderInsert(9);
	
	intersect_delete(test, a, b);
	console.log(test);
	
	var popTest = new LinkedList();
	popTest.push(1);
	popTest.push(2);
	popTest.pop();
	popTest.pop();

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 静态单链表
	/*
	 有时可借用一维数组来描述线性链表，这就是线性表的静态单链表存储结构。
	 在静态链表中，数组的一个分量表示一个结点，同时用游标（cur）代替指针指示结点在数组中的相对位置。
	 数组的第0分量可看成头结点，其指针域指示链表的第一个结点。
	 这种存储结构需要预先分配一个较大的空间，但在线性表的插入和删除操作时不需移动元素，
	 仅需要修改指针，故仍具有链式存储结构的主要优点
	 */
	
	var StaticLinkedList = function () {
	    function StaticLinkedList(MAXSIZE) {
	        (0, _classCallCheck3.default)(this, StaticLinkedList);
	
	        this[-1] = { cur: 0 };
	        this.length = 0;
	        this.MAXSIZE = MAXSIZE + 1 || 1000;
	    }
	
	    /**
	     * 在静态单链线性表L中查找第1个值为e的元素，
	     * 若找到，则返回它在L中的位序
	     * @param data
	     */
	
	
	    (0, _createClass3.default)(StaticLinkedList, [{
	        key: 'find',
	        value: function find(data) {
	            var i = this[0].cur;
	            while (i && this[i].data !== data) {
	                i = this[i].cur;
	            }
	            return i;
	        }
	        /**
	         * 将一维数组中各分量链成一个备用链表
	         * this[0].cur为头指针
	         */
	
	    }, {
	        key: 'init',
	        value: function init(len) {
	            len = len ? len + 1 : this.MAXSIZE;
	            for (var i = 0; i < len - 1; ++i) {
	                this[i] = this[i] || { data: null, cur: null };
	                this[i].cur = i + 1;
	            }
	
	            this[len - 1] = this[len - 1] || {};
	            this[len - 1].cur = 0;
	        }
	        /**
	         * 若备用链表非空，则返回分配的结点下标，反则返回0
	         * @returns {*}
	         */
	
	    }, {
	        key: 'malloc',
	        value: function malloc() {
	            var i = this[-1].cur;
	            if (typeof this[-1].cur !== 'undefined') this[-1].cur = this[i].cur;
	            return i;
	        }
	        /**
	         * 将下标为k的空闲结点回收到备用链表
	         * @param k
	         */
	
	    }, {
	        key: 'free',
	        value: function free(k) {
	            this[k].cur = this[0].cur;
	            this[0].cur = k;
	        }
	    }, {
	        key: 'create',
	        value: function create(sqList) {
	            // 初始化备用空间
	            this.init(sqList.length);
	            // 生成s的头结点
	            var s = this.malloc();
	            // r指向s的当前最后结点
	            var r = s;
	            var m = sqList.length;
	
	            // 建立集合A的链表
	            for (var j = 0; j < m; ++j) {
	                //分配结点
	                var i = this.malloc();
	                // 输入A元素的值
	                this[i].data = sqList[j];
	                // 插入到表尾
	                this[r].cur = i;
	                ++this.length;
	                r = i;
	            }
	            // 尾结点的指针为空
	            this[r].cur = 0;
	        }
	
	        // todo
	
	    }, {
	        key: 'add',
	        value: function add(index, elem) {}
	    }, {
	        key: 'remove',
	        value: function remove(index) {}
	    }]);
	    return StaticLinkedList;
	}();
	
	/**
	 * 在一维数组中建立表示集合(A-B)U(B-A)
	 * 的静态链表，s为其头指针。
	 * @returns {*}
	 */
	
	
	exports.default = StaticLinkedList;
	function difference(sllist, arr1, arr2) {
	    // 初始化备用空间
	    sllist.init();
	    // 生成s的头结点
	    var s = sllist.malloc();
	    // r指向s的当前最后结点
	    var r = s;
	    // 删除A和B的元素个数
	    var m = arr1.length;
	    var n = arr2.length;
	
	    // 建立集合A的链表
	    for (var j = 0; j < m; ++j) {
	        //分配结点
	        var i = sllist.malloc();
	        // 输入A元素的值
	        sllist[i].data = arr1[j];
	        // 插入到表尾
	        sllist[r].cur = i;
	        r = i;
	    }
	    // 尾结点的指针为空
	    sllist[r].cur = 0;
	
	    // 依次输入B的元素，若不在当前表中，则插入，
	    // 否则删除
	    for (var _j = 0; _j < n; ++_j) {
	        var b = arr2[_j];
	        var p = s;
	        // k指向集合中的第一个结点
	        var k = sllist[s].cur;
	        // 在当前表中查找
	        while (k !== sllist[r].cur && sllist[k].data !== b) {
	            p = k;
	            k = sllist[k].cur;
	        }
	        // 当前表中不存在该元素，插入在r所指结点之后，且r的位置不变
	        if (k === sllist[r].cur) {
	            var _i = sllist.malloc();
	            sllist[_i].data = b;
	            sllist[_i].cur = sllist[r].cur;
	            sllist[r].cur = _i;
	
	            // 该元素已在表中，删除之
	        } else {
	                sllist[p].cur = sllist[k].cur;
	                sllist.free(k);
	                // 若删除的是r所指结点，则需修改尾指针
	                if (r === k) r = p;
	            }
	    }
	}
	
	var sl = new StaticLinkedList(10);
	var ret = difference(sl, [1, 2, 3], [3, 4, 5]);
	console.log(sl);
	
	var test = new StaticLinkedList(10);
	test.create([49, 38, 65, 97, 76, 13, 27, 49]);
	console.log(test);

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(32);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(35);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(34);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinaryTree2 = __webpack_require__(18);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BSTNode = function (_BinaryTree) {
	    (0, _inherits3.default)(BSTNode, _BinaryTree);
	
	    function BSTNode() {
	        var _Object$getPrototypeO;
	
	        (0, _classCallCheck3.default)(this, BSTNode);
	
	        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
	            arg[_key] = arguments[_key];
	        }
	
	        return (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(BSTNode)).call.apply(_Object$getPrototypeO, [this].concat(arg)));
	    }
	
	    /**
	     * BST树的查找（递归）
	     * @param {*} key
	     * @returns {*}
	     */
	
	
	    (0, _createClass3.default)(BSTNode, [{
	        key: 'search',
	        value: function search(key) {
	            if (this.data != null) {
	                if (this.data === key) return this;else if (key < this.data) {
	                    if (this.leftChild) return this.leftChild.search(key);
	                } else {
	                    if (this.rightChild) return this.rightChild.search(key);
	                }
	            }
	
	            return null;
	        }
	
	        /**
	         * BST树的查找（非递归）
	         * @param {*} key
	         * @returns {*}
	         */
	
	    }, {
	        key: 'searchNonRecursive',
	        value: function searchNonRecursive(key) {
	            if (this.data == null) return null;
	
	            var p = this;
	            while (p && p.data !== key) {
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            if (!p || key !== p.data) return null;else return p;
	        }
	
	        /**
	         * BST树的插入（递归）
	         * @param {*} key
	         */
	
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            if (this.data == null) {
	                this.data = key;
	                return;
	            }
	            if (key === this.data) return;
	
	            var node = new BSTNode(key);
	            if (key < this.data) {
	                if (!this.leftChild) this.leftChild = node;
	                this.leftChild.insert(key);
	            } else {
	                if (!this.rightChild) this.rightChild = node;
	                this.rightChild.insert(key);
	            }
	        }
	
	        /**
	         * BST树的插入（非递归）
	         * @param {*} key
	         */
	
	    }, {
	        key: 'insertNonRecursive',
	        value: function insertNonRecursive(key) {
	            if (this.data == null) {
	                this.data = key;
	                return;
	            }
	
	            var p = this;
	            var q = void 0;
	            while (p) {
	                if (p.data === key) return;
	                // q作为p的父节点
	                q = p;
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            var node = new BSTNode(key);
	            if (key < q.data) q.leftChild = node;else q.rightChild = node;
	        }
	
	        /**
	         * 利用BST树的插入操作建立一棵BST树
	         * @param {Array} arr
	         * @param {Boolean|undefined} useNonRecursive 是否使用非递归
	         */
	
	    }, {
	        key: 'createBST',
	        value: function createBST(arr, useNonRecursive) {
	            var i = void 0;
	            if (useNonRecursive) {
	                for (i = 0; i < arr.length; ++i) {
	                    this.insertNonRecursive(arr[i]);
	                }
	            } else {
	                for (i = 0; i < arr.length; ++i) {
	                    this.insert(arr[i]);
	                }
	            }
	
	            return this;
	        }
	
	        /**
	         * 使用递归的方法删除与关键字符合的结点
	         * @param {*} key 需要查找的关键字
	         * @param {BSTNode} parent 父节点，内部调用需要用到
	         * @returns {Boolean}
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key, parent) {
	            // 空结点的情况
	            if (this.data == null) return false;
	
	            // 找到关键字
	            if (this.data === key) return deleteNode(this, parent);
	            // 查找左子树，如果有的话
	            else if (key < this.data) {
	                    if (this.leftChild) return this.leftChild.remove(key, this);
	                }
	                // 查找右子树，如果有的话
	                else {
	                        if (this.rightChild) return this.rightChild.remove(key, this);
	                    }
	
	            // 未找到
	            return false;
	        }
	
	        /**
	         * 非递归删除与关键字符合的结点
	         * @param {*} key 需要查找的关键字
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'removeNonRecursive',
	        value: function removeNonRecursive(key) {
	            var p = this;
	            var f = void 0;
	
	            while (p && p.data !== key) {
	                f = p;
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            // 没有要删除的结点
	            if (!p) return false;
	
	            // 找到了要删除的结点p
	            var s = p;
	            var q = void 0;
	            // 如果有左右子树
	            if (p.leftChild && p.rightChild) {
	                f = p;
	                s = p.leftChild;
	
	                // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                while (s.rightChild) {
	                    f = s;
	                    s = s.rightChild;
	                }
	
	                p.data = s.data;
	            }
	
	            // 若s有左子树，右子树为空
	            if (s.leftChild) q = s.leftChild;else q = s.rightChild;
	
	            // 只有一个根结点的情况
	            if (!f) this.data = null;else if (f.leftChild == s) f.leftChild = q;else f.rightChild = q;
	
	            return true;
	        }
	
	        /**
	         * 找到小于x的最大元素和大于x的最小元素
	         * @param {String|Number} x
	         * @returns {Array} [min, max]
	         */
	
	    }, {
	        key: 'findNeighborElem',
	        value: function findNeighborElem(x) {
	            var last = typeof this.data === 'number' ? -Infinity : 'a';
	            var ret = [];
	
	            void function recurse(tree, x) {
	                if (tree.leftChild) recurse(tree.leftChild, x);
	                if (last < x && tree.data >= x) ret[0] = last;
	                if (last <= x && tree.data > x) ret[1] = tree.data;
	                last = tree.data;
	                if (tree.rightChild) recurse(tree.rightChild, x);
	            }(this, x);
	
	            return ret;
	        }
	
	        /**
	         * 把二叉排序树bst合并到该树中
	         * @param {BSTNode} bst
	         */
	
	    }, {
	        key: 'merge',
	        value: function merge(bst) {
	            if (bst.leftChild) this.merge(bst.leftChild);
	            if (bst.rightChild) this.merge(bst.rightChild);
	            this.insert(bst.data);
	        }
	
	        /**
	         * 把结点插入到合适位置
	         * @param {BSTNode} node 待插入的结点
	         */
	
	    }, {
	        key: 'insertNode',
	        value: function insertNode(node) {
	            if (this.data == null) {
	                this.data = node.data;
	            } else {
	                if (node.data > this.data) {
	                    if (!this.rightChild) this.rightChild = node;else this.rightChild.insertNode(node);
	                } else if (node.data < this.data) {
	                    if (!this.leftChild) this.leftChild = node;else this.leftChild.insertNode(node);
	                }
	            }
	
	            node.leftChild = node.rightChild = null;
	        }
	
	        /**
	         * 分裂为两棵二叉排序树
	         * @param {*} x
	         * @returns {BSTNode[a, b]} a的元素全部小于等于x，b的元素全部大于x
	         */
	
	    }, {
	        key: 'split',
	        value: function split(x) {
	            var a = new BSTNode();
	            var b = new BSTNode();
	
	            void function split(tree, x) {
	                if (tree.leftChild) split(tree.leftChild, x);
	                if (tree.rightChild) split(tree.rightChild, x);
	                if (tree.data <= x) a.insertNode(tree);else b.insertNode(tree);
	            }(this, x);
	
	            return [a, b];
	        }
	
	        /**
	         * 判断tree是否是二叉排序树
	         * @param tree
	         */
	
	    }], [{
	        key: 'isBSTTree',
	        value: function isBSTTree(tree) {
	            var last = typeof tree.data === 'number' ? -Infinity : 'a';
	            var flag = true;
	
	            void function isBSTTree(tree) {
	                if (tree.leftChild && flag) isBSTTree(tree.leftChild);
	                if (tree.data < last) flag = false;
	                last = tree.data;
	                if (tree.rightChild && flag) isBSTTree(tree.rightChild);
	            }(tree);
	
	            return flag;
	        }
	    }]);
	    return BSTNode;
	}(_BinaryTree2.BinaryTree);
	
	/**
	 * 删除结点
	 * @param {BSTNode} p 要删除的结点
	 * @param {BSTNode} parent 要删除的结点的父节点
	 * @returns {boolean} 返回删除成功
	 */
	/*
	 动态查找
	
	 当查找表以线性表的形式组织时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。
	 利用树的形式组织查找表，可以对查找表进行动态高效的查找。
	
	
	 二叉排序树(BST)的定义
	
	 二叉排序树(Binary Sort Tree或Binary Search Tree) 的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。
	 (1) ：若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；
	 (2) ：若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；
	 (3) ：左、右子树都分别是二叉排序树。
	 结论：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。
	
	
	 BST树的查找
	 1  查找思想
	 首先将给定的K值与二叉排序树的根结点的关键字进行比较：若相等： 则查找成功；
	 ① 给定的K值小于BST的根结点的关键字：继续在该结点的左子树上进行查找；
	 ② 给定的K值大于BST的根结点的关键字：继续在该结点的右子树上进行查找。
	
	 在随机情况下，二叉排序树的平均查找长度ASL和㏒(n)(树的深度)是等数量级的。
	
	
	 BST树的插入
	
	 在BST树中插入一个新结点，要保证插入后仍满足BST的性质。
	
	 1 插入思想
	 在BST树中插入一个新结点x时，若BST树为空，则令新结点x为插入后BST树的根结点；否则，将结点x的关键字与根结点T的关键字进行比较：
	 ① 若相等： 不需要插入；
	 ②  若x.key<T->key：结点x插入到T的左子树中；
	 ③  若x.key>T->key：结点x插入到T的右子树中。
	
	 由结论知，对于一个无序序列可以通过构造一棵BST树而变成一个有序序列。
	 由算法知，每次插入的新结点都是BST树的叶子结点，即在插入时不必移动其它结点，仅需修改某个结点的指针。
	
	
	 BST树的删除
	
	 1  删除操作过程分析
	 从BST树上删除一个结点，仍然要保证删除后满足BST的性质。设被删除结点为p，其父结点为f ，删除情况如下：
	 ①  若p是叶子结点： 直接删除p。
	 ②  若p只有一棵子树(左子树或右子树)：直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树。
	 ③ 若p既有左子树又有右子树 ：处理方法有以下两种，可以任选其中一种。
	 ◆  用p的直接前驱结点代替p。即从p的左子树中选择值最大的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的左子树中的最右边的结点且没有右子树，对s的删除同②。
	 ◆ 用p的直接后继结点代替p。即从p的右子树中选择值最小的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的右子树中的最左边的结点且没有左子树，对s的删除同②。
	
	 */
	
	exports.default = BSTNode;
	function deleteNode(p, parent) {
	    // 叶子结点或只有一个结点
	    if (!p.leftChild && !p.rightChild) {
	        // 当前结点是其父结点的左子树还是右子树
	        var pos = parent && parent.leftChild == p ? 'leftChild' : 'rightChild';
	        if (parent) parent[pos] = null;
	        // 只有一个结点的情况
	        else p.data = null;
	    }
	    // 只有左子树
	    else if (!p.rightChild) {
	            p.data = p.leftChild.data;
	            p.leftChild = p.leftChild.leftChild;
	        }
	        // 只有右子树
	        else if (!p.leftChild) {
	                p.data = p.rightChild.data;
	                p.rightChild = p.rightChild.rightChild;
	            }
	            // 左右子树都有
	            else {
	                    var s = p.leftChild;
	                    // q为父结点
	                    var q = p;
	                    // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                    while (s.rightChild) {
	                        q = s;
	                        s = s.rightChild;
	                    }
	
	                    p.data = s.data;
	                    if (q != p) q.rightChild = s.leftChild;else q.leftChild = s.leftChild;
	                }
	
	    return true;
	}
	
	var bst = new BSTNode();
	bst.createBST([45, 24, 53, 12, 24, 90]);
	console.log(bst.search(12));
	console.log(bst.search(13));
	
	var bst2 = new BSTNode();
	bst2.createBST([45, 24, 53, 12, 24, 90], true);
	console.log(bst2.searchNonRecursive(12));
	console.log(bst2.searchNonRecursive(13));
	
	console.log('\nfindSiblingElem: ');
	console.log(bst.findNeighborElem(12) + '');
	console.log(bst.findNeighborElem(90) + '');
	console.log(bst.findNeighborElem(45) + '');
	
	console.log(bst.remove(45));
	console.log(bst.remove(1));
	console.log(bst.remove(53));
	console.log(bst.remove(12));
	console.log(bst.remove(90));
	console.log(bst.remove(24));
	console.log(bst.remove(2));
	
	//console.log(bst2.removeNonRecursive(45));
	//console.log(bst2.removeNonRecursive(1));
	//console.log(bst2.removeNonRecursive(53));
	//console.log(bst2.removeNonRecursive(12));
	//console.log(bst2.removeNonRecursive(90));
	//console.log(bst2.removeNonRecursive(24));
	//console.log(bst2.removeNonRecursive(2));
	
	console.log('\nisBSTTree: ');
	console.log(BSTNode.isBSTTree(bst));
	//console.log(BSTNode.isBSTTree(sosTree));
	
	/**
	 * 从大到小输出二叉排序树中所有不小于x的元素
	 * @param bst
	 * @param x
	 */
	function printNotLessThan(bst, x) {
	    if (bst.rightChild) printNotLessThan(bst.rightChild, x);
	    if (bst.data < x) return;
	    console.log(bst.data);
	    if (bst.leftChild) printNotLessThan(bst.leftChild, x);
	}
	
	console.log('\nprintNotLessThan: ');
	printNotLessThan(bst2, 90);
	console.log('\n');
	printNotLessThan(bst2, 12);
	
	bst.merge(bst2);
	
	var a1 = new BSTNode(5);
	var a2 = new BSTNode(91);
	bst2.insertNode(a1);
	bst2.insertNode(a2);
	
	bst2.split(45);

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Created by Luke on 2015/2/2.
	 */
	
	var defaultCompare = __webpack_require__(24);
	
	/*
	 交换排序
	
	 是一类基于交换的排序，系统地交换反序的记录的偶对，直到不再有这样的偶对为止。其中最基本的是冒泡排序(Bubble Sort)。
	
	 冒泡排序
	 1  排序思想
	 依次比较相邻的两个记录的关键字，若两个记录是反序的(即前一个记录的关键字大于后前一个记录的关键字)，则进行交换，直到没有反序的记录为止。
	     ① 首先将L->R[1]与L->R[2]的关键字进行比较，若为反序(L->R[1]的关键字大于L->R[2]的关键字)，则交换两个记录；然后比较L->R[2]与L->R[3]的关键字，依此类推，直到L->R[n-1]与L->R[n]的关键字比较后为止，称为一趟冒泡排序，L->R[n]为关键字最大的记录。
	     ②  然后进行第二趟冒泡排序，对前n-1个记录进行同样的操作。
	 一般地，第i趟冒泡排序是对L->R[1 … n-i+1]中的记录进行的，因此，若待排序的记录有n个，则要经过n-1趟冒泡排序才能使所有的记录有序。
	
	 2  排序示例
	 设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41
	
	 初始关键字序列:  23    38     22     45     23     67     31     15    41
	 第一趟排序后:    23    22     38     23     45     31     15     41    67
	 第二趟排序后:    22    23     23     38     31     15     41     45    67
	 第三趟排序后:    22    23     23     31     15     38     41     45    67
	 第四趟排序后:    22    23     23     15     31     38     41     45    67
	 第五趟排序后:    22    23     15     23     31     38     41     45    67
	 第六趟排序后:    22    15     23     23     31     38     41     45    67
	 第七趟排序后:    15    22     23     23     31     38     41     45    67
	
	3.算法分析
	 时间复杂度
	 ◆  最好情况(正序)：比较次数：n-1；移动次数：0；
	 ◆  最坏情况(逆序)：
	 比较次数： n * (n - 1) / 2
	 移动次数： 3*n*(n - 1) / 2
	
	 故时间复杂度：T(n)=O(n²)
	 空间复杂度：S(n)=O(1)
	
	 */
	
	function bubbleSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var change = 0;
	
	        for (var j = 0; j <= len - i; ++j) {
	            if (comp(sqList[j + 1], sqList[j]) < 0) {
	                change = 1;
	                var temp = sqList[j];
	                sqList[j] = sqList[j + 1];
	                sqList[j + 1] = temp;
	            }
	        }
	
	        if (!change) break;
	    }
	}
	exports.bubbleSort = bubbleSort;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort(arr);
	console.log('bubbleSort:\n' + arr + '');
	
	// 冒泡改进1
	function bubbleSort2(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var len = sqList.length;
	    var change = len - 1;
	
	    while (change) {
	        for (var c = 0, i = 0; i < change; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                // c指示这一趟冒泡中发生交换的元素
	                c = i + 1;
	            }
	        }
	
	        change = c;
	    }
	}
	exports.bubbleSort2 = bubbleSort2;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort2(arr);
	console.log('bubbleSort2:\n' + arr + '');
	
	// 相邻两趟反方向起泡的冒泡排序算法
	function cockTailSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var len = sqList.length;
	    // 冒泡上下界
	    var low = 0,
	        high = len - 1;
	    var change = 1;
	    var temp;
	
	    while (low < high && change) {
	        change = 0;
	
	        // 从上向下起泡
	        for (var i = low; i < high; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改上界
	        --high;
	
	        // 从下向上起泡
	        for (i = high; i > low; --i) {
	            if (comp(sqList[i], sqList[i - 1]) < 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i - 1];
	                sqList[i - 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改下界
	        ++low;
	    }
	}
	exports.cockTailSort = cockTailSort;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort(arr);
	console.log('cockTailSort:\n' + arr + '');
	
	// 改进3
	function cockTailSort2(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var b = {};
	    var len = sqList.length;
	    // d为冒泡方向标识， 1为向上，-1为向下
	    var d = 1;
	    // b[0]为冒泡上界，b[2]为冒泡上界，b[1]无用
	    b[0] = 0;
	    b[2] = len - 1;
	    var change = 1;
	
	    while (b[0] < b[2] && change) {
	        change = 0;
	
	        // 统一的冒泡算法
	        for (var i = b[1 - d]; i !== b[1 + d]; i += d) {
	            // 注意这个交换条件
	            if (comp(sqList[i], sqList[i + d]) * d > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + d];
	                sqList[i + d] = temp;
	                change = 1;
	            }
	        }
	
	        // 修改边界
	        b[1 + d] -= d;
	        // 换个方向
	        d *= -1;
	    }
	}
	exports.cockTailSort2 = cockTailSort2;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort2(arr);
	console.log('cockTailSort2:\n' + arr + '');
	
	/*
	 快速排序
	
	 1  排序思想
	 通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录进行下一趟排序，以达到整个序列有序。
	
	 2  排序过程
	 设待排序的记录序列是R[s…t] ，在记录序列中任取一个记录(一般取R[s])作为参照(又称为基准或枢轴)，以R[s].key为基准重新排列其余的所有记录，方法是：
	     ◆ 所有关键字比基准小的放R[s]之前；
	     ◆ 所有关键字比基准大的放R[s]之后。
	 以R[s].key最后所在位置i作为分界，将序列R[s…t]分割成两个子序列，称为一趟快速排序。
	
	 3  一趟快速排序方法
	 从序列的两端交替扫描各个记录，将关键字小于基准关键字的记录依次放置到序列的前边；而将关键字大于基准关键字的记录从序列的最后端起，依次放置到序列的后边，直到扫描完所有的记录。
	
	 设置指针low，high，初值为第1个和最后一个记录的位置。
	 设两个变量i，j，初始时令i=low，j=high，以R[low].key作为基准(将R[low]保存在temp中) 。
	 ① 从j所指位置向前搜索：将temp与R[j].key进行比较：
	    ◆ 若temp≤R[j].key ：令j=j-1，然后继续进行比较， 直到i=j或temp>R[j].key为止；
	    ◆ 若temp>R[j].key ：R[j]R[i]，腾空R[j]的位置， 且令i=i+1；
	 ② 从i所指位置起向后搜索：将temp与R[i].key进行比较：
	    ◆ 若temp≥R[i].key ：令i=i+1，然后继续进行比较， 直到i=j或temp<R[i].key为止；
	    ◆ 若temp<R[i].key ：R[i]R[j]，腾空R[i]的位置， 且令j=j-1；
	 ③ 重复①、②，直至i=j为止，i就是temp(基准)所应放置的位置。
	
	 算法分析
	 快速排序的主要时间是花费在划分上，对长度为k的记录序列进行划分时关键字的比较次数是k-1 。设长度为n的记录序列进行排序的比较次数为C(n)，则C(n)=n-1+C(k)+C(n-k-1) 。
	 ◆  最好情况：每次划分得到的子序列大致相等，则
	 C(n)<=h×n+2h×C(n/2h) ，当n/2h=1时排序结束。
	 即C(n)≤O(n×㏒2n) ；
	 ◆  最坏情况：每次划分得到的子序列中有一个为空，另一个子序列的长度为n-1。即每次划分所选择的基准是当前待排序序列中的最小(或最大)关键字。
	 比较次数：:  即C(n)=O(n2)
	 ◆  一般情况： 对n个记录进行快速排序所需的时间T(n)组成是：
	     ① 对n个记录进行一趟划分所需的时间是：n×C ，C是常数；
	     ② 对所得到的两个子序列进行快速排序的时间：
	        Tavg(n)=C(n)+Tavg(k-1)+Tavg(n-k)          ……
	
	 快速排序的平均时间复杂度是：T(n)=O(n㏒2n)
	 从所需要的附加空间来看，快速排序算法是递归调用，系统内用堆栈保存递归参数，当每次划分比较均匀时，栈的最大深度为[㏒2n]+1 。
	
	 快速排序的空间复杂度是：S(n)=O(㏒2n)
	 从排序的稳定性来看，快速排序是不稳定的。
	
	 */
	
	function partition1(sqList, low, high) {
	    var temp = sqList[low];
	
	    while (low < high) {
	        while (low < high && sqList[high] >= temp) {
	            --high;
	        }sqList[low] = sqList[high];
	        while (low < high && sqList[low] <= temp) {
	            ++low;
	        }sqList[high] = sqList[low];
	    }
	
	    sqList[low] = temp;
	
	    return low;
	}
	
	// 优化一趟快速排序方法： 随机化partition
	// 最坏情况效率大幅提升，时间复杂度T(n)=O(n㏒2n)
	function partition2(sqList, low, high) {
	    var temp;
	    var n = high - low + 1;
	    var rand = Math.floor(Math.random() * n) + low;
	
	    //var rand = (low + high) >> 1;
	    temp = sqList[high];
	    sqList[high] = sqList[rand];
	    sqList[rand] = temp;
	
	    var i = low - 1;
	    var pivot = sqList[high];
	
	    for (var j = low; j < high; ++j) {
	        if (sqList[j] <= pivot) {
	            ++i;
	            temp = sqList[i];
	            sqList[i] = sqList[j];
	            sqList[j] = temp;
	        }
	    }
	
	    ++i;
	    sqList[high] = sqList[i];
	    sqList[i] = pivot;
	
	    return i;
	}
	
	function partition(sqList, low, high, comp) {
	    var temp;
	    var i = low;
	    var j = high + 1;
	    var rand = Math.floor(Math.random() * (high - low)) + low + 1;
	    //var rand = (low + high) >> 1;
	
	    temp = sqList[low];
	    sqList[low] = sqList[rand];
	    sqList[rand] = temp;
	
	    var x = sqList[low];
	
	    while (1) {
	        while (comp(sqList[++i], x) < 0 && i < high) {}
	        while (comp(sqList[--j], x) > 0) {}
	        if (i >= j) break;
	        temp = sqList[i];
	        sqList[i] = sqList[j];
	        sqList[j] = temp;
	    }
	
	    sqList[low] = sqList[j];
	    sqList[j] = x;
	
	    return j;
	}
	
	function quickSortRecursive(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	
	    if (low >= high) return;
	
	    var k = partition(sqList, low, high, comp);
	    quickSortRecursive(sqList, low, k - 1, comp);
	    quickSortRecursive(sqList, k + 1, high, comp);
	}
	exports.quickSortRecursive = quickSortRecursive;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive(arr);
	console.log('quickSortRecursive:\n' + arr + '');
	
	/*
	快排递归算法优化，在最坏情况下堆栈深度为O(logn)
	 */
	function quickSortRecursive2(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	
	    while (low < high) {
	        var k = partition(sqList, low, high, comp);
	
	        // 对两个子数组中较小的一个子数组进行递归调用。
	        // 较小子数组的大小最多为原数组大小一半，
	        // 由于每次递归调用的数组大小至少减少一半，所以递归调用的次数
	        // 最多为O(logn)
	        if (k - low + 1 < high - k) {
	            quickSortRecursive2(sqList, low, k - 1, comp);
	            low = k + 1;
	        } else {
	            quickSortRecursive2(sqList, k + 1, high, comp);
	            high = k - 1;
	        }
	    }
	}
	exports.quickSortRecursive2 = quickSortRecursive2;
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive2(arr);
	console.log('quickSortRecursive2:\n' + arr + '');
	
	function quickSortNonRecursive(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	    var stack = [];
	    var k;
	
	    do {
	        while (low < high) {
	            k = partition(sqList, low, high, comp);
	            // 第二个子序列的上,下界分别入栈
	            stack.push(high, k + 1);
	            //stack.push(k + 1);
	            high = k - 1;
	        }
	
	        if (!stack.length) return;
	
	        low = stack.pop();
	        high = stack.pop();
	    } while (1);
	}
	exports.quickSortNonRecursive = quickSortNonRecursive;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortNonRecursive(arr);
	console.log('quickSortNonRecursive:\n' + arr + '');
	
	// 优化版本
	function quickSort(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	    var stack = [];
	    var pivot;
	
	    do {
	        // 如果当前子序列长度大于3且尚未排好序
	        if (high - low > 2) {
	            // 进行一趟划分
	            pivot = partition(sqList, low, high, comp);
	
	            // 吧长的子序列边界入栈，
	            // 短的子序列留待下次排序
	            if (high - pivot > pivot - low) {
	                stack.push(high, pivot + 1);
	                //stack.push();
	                high = pivot - 1;
	            } else {
	                stack.push(pivot - 1, low);
	                //stack.push();
	                low = pivot + 1;
	            }
	        }
	        // 如果当前子序列长度小于3，且尚未排好序，
	        // 直接进行比较排序买当前子序列标志为已排好序
	        else if (low < high && high - low < 3) {
	                easySort(sqList, low, high, comp);
	                low = high;
	            }
	            // 如果当前子序列已排好序但栈中还有未排序的子序列
	            // 从栈中取出一个子序列
	            else {
	                    if (!stack.length) return;
	
	                    low = stack.pop();
	                    high = stack.pop();
	                }
	    } while (1);
	}
	exports.quickSort = quickSort;
	
	function easySort(sqList, low, high, comp) {
	    var temp;
	
	    if (high - low === 1) {
	        if (comp(sqList[low], sqList[high]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[high];
	            sqList[high] = temp;
	        }
	    } else {
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	        if (comp(sqList[low + 1], sqList[high]) > 0) {
	            temp = sqList[low + 1];
	            sqList[low + 1] = sqList[high];
	            sqList[high] = temp;
	        }
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSort(arr);
	console.log('quickSort:\n' + arr + '');
	
	// 奇偶交换排序
	function oddEvenSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var change = 1;
	    var temp;
	    var len = sqList.length;
	
	    while (change) {
	        change = 0;
	        // 对所有奇数进行一趟比较
	        for (var i = 1; i < len - 1; i += 2) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	
	                change = 1;
	            }
	        }
	
	        // 对所有偶数进行一趟比较
	        for (i = 0; i < len - 1; i += 2) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	
	                change = 1;
	            }
	        }
	    }
	}
	exports.oddEvenSort = oddEvenSort;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	oddEvenSort(arr);
	console.log('oddEvenSort:\n' + arr + '');
	
	/*
	把由三种颜色组成的序列重排为按照红白蓝的顺序排列，
	思路：
	设立三个指针，其中j表示当前元素；i以前的元素全部为红色；k以后的颜色全为蓝色。这样就可以根据j的颜色把其交换到序列的前面或者后面。
	 */
	var RED = 0;
	var WHITE = 1;
	var BLUE = 2;
	
	function flagArrange(colors) {
	    var i = 0;
	    var j = 0;
	    var k = colors.length - 1;
	    var temp;
	
	    while (j <= k) {
	        switch (colors[j]) {
	            case RED:
	                temp = colors[i];
	                colors[i] = colors[j];
	                colors[j] = temp;
	                ++i;
	                ++j;
	                break;
	            case WHITE:
	                ++j;
	                break;
	            case BLUE:
	                temp = colors[j];
	                colors[j] = colors[k];
	                colors[k] = temp;
	                --k;
	                break;
	            default:
	                break;
	        }
	    }
	}
	
	var arr = [2, 1, 0, 2, 1, 1, 0, 2, 0, 2, 1];
	flagArrange(arr);
	console.log(arr + '');

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(122), __esModule: true };

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5).document && document.documentElement;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(8) && !__webpack_require__(21)(function(){
	  return Object.defineProperty(__webpack_require__(40)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(17)
	  , ITERATOR   = __webpack_require__(4)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(6);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(26)
	  , $export        = __webpack_require__(9)
	  , redefine       = __webpack_require__(72)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(10)
	  , Iterators      = __webpack_require__(17)
	  , $iterCreate    = __webpack_require__(135)
	  , setToStringTag = __webpack_require__(28)
	  , getPrototypeOf = __webpack_require__(70)
	  , ITERATOR       = __webpack_require__(4)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(4)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(43)
	  , createDesc     = __webpack_require__(22)
	  , toIObject      = __webpack_require__(12)
	  , toPrimitive    = __webpack_require__(49)
	  , has            = __webpack_require__(10)
	  , IE8_DOM_DEFINE = __webpack_require__(62)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(71)
	  , hiddenKeys = __webpack_require__(41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 69 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(10)
	  , toObject    = __webpack_require__(48)
	  , IE_PROTO    = __webpack_require__(44)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(10)
	  , toIObject    = __webpack_require__(12)
	  , arrayIndexOf = __webpack_require__(128)(false)
	  , IE_PROTO     = __webpack_require__(44)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(16)
	  , anObject = __webpack_require__(6);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(15)(Function.call, __webpack_require__(67).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(15)
	  , invoke             = __webpack_require__(132)
	  , html               = __webpack_require__(61)
	  , cel                = __webpack_require__(40)
	  , global             = __webpack_require__(5)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(20)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 75 */
/***/ function(module, exports) {



/***/ },
/* 76 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _slicedToArray2 = __webpack_require__(113);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _toConsumableArray2 = __webpack_require__(114);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 十字链表
	 *
	 * 当矩阵的非零个数和位置在操作过程中变化大时，就不宜采用顺序存储结构来表示三元组的线性表。例如，在作“将矩阵B加到矩阵A上”的操作时，由于非零元的插入或删除将会引起A.data中元素的移动。为此，对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。
	 *
	 * 在链表中，每个非零元可用一个含5个域的结点表示，其中i，j和e这3个域分别表示该非零元所在的行，列和非零元的值，向右域right用以链接同一行中下一个非零元，向下域down用以链接同一列中下一个非零元。同一行的非零元通过right域链接成一个线性表，同一列中的非零元通常down域链接成一个线性链表，每一个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表。
	 *
	 * 可用两个分别存储行链表的头指针和列链表的头指针的一维数组来表示。
	 */
	
	// 稀疏矩阵的十字链表存储表示
	
	var OLNode = function OLNode() {
	    var i = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var j = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var e = arguments[2];
	    (0, _classCallCheck3.default)(this, OLNode);
	
	    // 该非零元的行和列下标
	    this.i = i;
	    this.j = j;
	    this.e = e;
	    // 该非零元所在行表和列表的后继链域
	    this.right = null; // type: OLNode
	    this.down = null; // type: OLNode
	};
	
	var CrossList = function () {
	    function CrossList() {
	        (0, _classCallCheck3.default)(this, CrossList);
	
	        // 行和列链表头指针向量基址由CreateSMatrix分配
	        this.rhead = [];
	        this.chead = [];
	        // 稀疏矩阵的行数，列数
	        this.mu = 0;
	        this.nu = 0;
	        this.tu = 0;
	    }
	
	    /**
	     * 矩阵初始化
	     * @param m
	     * @param n
	     * @param t
	     * @param {Array} list 二维数组，每行的元素分别是[i, j, e]
	     */
	
	
	    (0, _createClass3.default)(CrossList, [{
	        key: "createSMatrix",
	        value: function createSMatrix(m, n, t, list) {
	            this.mu = m;
	            this.nu = n;
	            this.tu = t;
	
	            for (var row = 0; row < list.length; row++) {
	                var p = new (Function.prototype.bind.apply(OLNode, [null].concat((0, _toConsumableArray3.default)(list[row]))))();
	
	                var _list$row = (0, _slicedToArray3.default)(list[row], 2);
	
	                var i = _list$row[0];
	                var j = _list$row[1];
	
	                var q = void 0;
	
	                if (this.rhead[i] == null || this.rhead[i].j > j) {
	                    p.right = this.rhead[i];
	                    this.rhead[i] = p;
	                } else {
	                    // 查询在行表中的插入位置
	                    for (q = this.rhead[i]; q.right && q.right.j < j; q = q.right) {}
	                    p.right = q.right;
	                    q.right = p;
	                }
	
	                if (this.chead[j] == null || this.chead[j].i > i) {
	                    p.down = this.chead[j];
	                    this.chead[j] = p;
	                } else {
	                    for (q = this.chead[j]; q.down && q.down.i < i; q = q.down) {}
	                    p.down = q.down;
	                    q.down = p;
	                }
	            }
	        }
	
	        // 矩阵相加
	
	    }, {
	        key: "addMatrix",
	        value: function addMatrix(crossList) {
	            var hl = [];
	            //hl初始化
	            for (var j = 0; j <= this.nu; j++) {
	                hl[j] = this.chead[j];
	            }for (var i = 0; i <= this.mu; i++) {
	                //pa和pb指向每一行的第一个非0元结点，直至最后一行
	                var pa = this.rhead[i];
	                var pb = crossList.rhead[i];
	                var pre = null;
	
	                //处理B的一行，直至本行中无非0元素的结点
	                while (pb) {
	                    var p = void 0,
	                        q = void 0;
	                    // 新插入一个结点到pa的左侧
	                    if (!pa || pa.j > pb.j) {
	                        p = new OLNode(pb.i, pb.j, pb.e);
	
	                        //行表的指针变化
	                        if (!pre) this.rhead[p.i] = p;else pre.right = p;
	
	                        p.right = pa;
	                        pre = p;
	
	                        //列表的指针变化
	                        if (hl[p.j]) {
	                            // 从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                            for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                hl[p.j] = q;
	                            }
	                        }
	
	                        //在列表中插入新结点，根据行数判断插入前面还是后面
	                        if (!this.chead[p.j] || this.chead[p.j].i > p.i) {
	                            p.down = this.chead[p.j];
	                            this.chead[p.j] = p;
	                        } else {
	                            p.down = hl[p.j].down;
	                            hl[p.j].down = p;
	                        }
	
	                        hl[p.j] = p;
	                        pb = pb.right;
	                    } else if (pa.j < pb.j) {
	                        pre = pa;
	                        pa = pa.right;
	                    } else {
	                        //当pa.j === pb.j时，将B中当前结点的值加到A中当前结点上
	                        pa.e += pb.e;
	
	                        //当pa.e === 0时，删除该结点
	                        if (pa.e === 0) {
	                            // 若无前驱结点，将第一个非0元结点置为当前结点的后继结点，
	                            // 否则前驱结点的后继结点为当前结点的后继结点
	                            if (!pre) this.rhead[pa.i] = pa.right;else pre.right = pa.right;
	
	                            p = pa;
	                            pa = pa.right;
	
	                            //列表的指针变化
	                            if (hl[p.j]) {
	                                //从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                                for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                    hl[p.j] = q;
	                                }
	                            }
	
	                            if (this.chead[p.j] == p) this.chead[p.j] = hl[p.j] = p.down;else hl[p.j].down = p.down;
	                        }
	
	                        pb = pb.right;
	                    }
	                }
	            }
	        }
	    }]);
	    return CrossList;
	}();
	
	exports.default = CrossList;
	
	
	var lists = [[1, 4, 5], [2, 2, -1], [1, 1, 3], [3, 1, 2]];
	var a = new CrossList();
	a.createSMatrix(4, 4, 4, lists);
	console.log(a);
	
	var lists2 = [[1, 4, -5], [2, 3, 1], [1, 1, 3], [3, 2, 2]];
	var b = new CrossList();
	b.createSMatrix(4, 4, 4, lists2);
	console.log(b);
	
	a.addMatrix(b);
	console.log(a);

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.RLSMatrix = exports.TSMatrix = undefined;
	
	var _getPrototypeOf = __webpack_require__(32);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(35);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(34);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 系数矩阵的三元组顺序表存储表示
	 */
	
	var Triple = function Triple(i, j, elem) {
	    (0, _classCallCheck3.default)(this, Triple);
	
	    // 该非零元的行下标和列下标
	    this.i = i || 0;
	    this.j = j || 0;
	    this.e = elem || null;
	};
	
	var TSMatrix = exports.TSMatrix = function () {
	    function TSMatrix(mu, nu) {
	        (0, _classCallCheck3.default)(this, TSMatrix);
	
	        // 非零元三元组表
	        this.data = [];
	        // 矩阵的行数，列数
	        this.mu = mu || 0;
	        this.nu = nu || 0;
	    }
	
	    (0, _createClass3.default)(TSMatrix, [{
	        key: 'addTriple',
	        value: function addTriple(triple) {
	            if (triple instanceof Triple) {
	                if (triple.i >= this.mu) this.mu = triple.i + 1;
	                if (triple.j >= this.nu) this.nu = triple.j + 1;
	
	                this.data.push(triple);
	                return true;
	            }
	            return false;
	        }
	        // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	        // 按照b.data中三元组的次序依次在a.data中找到相应的三元组进行转置
	
	    }, {
	        key: 'transposeSMatrix',
	        value: function transposeSMatrix() {
	            var t = new TSMatrix();
	            t.mu = this.nu;
	            t.nu = this.mu;
	
	            if (this.data.length) {
	                var q = 0;
	                for (var col = 0; col < this.nu; col++) {
	                    for (var p = 0; p < this.data.length; p++) {
	                        if (this.data[p].j === col) t.data[q++] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                    }
	                }
	            }
	
	            return t;
	        }
	        // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	        /*
	         按照a.data中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置。
	         如果能预先确定矩阵M中每一列（即T中每一行）的第一个非零元在b.data中应有的位置，
	         那么在对a.data中的三元组依次做转置时，便可直接放到b.data中恰当的位置上去。
	         为了其额定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在b.data中应有的位置。
	         在此，需要设num和cpot两个变量。num[col]表示矩阵M中第col列中非零元的个数，
	         cpot[col]指示M中第col列的第一个非零元在b.data中的恰当位置。显然有：
	         cpot[0] = 1;
	         cpot[col] = cpot[col - 1] + num[col - 1]    2 <= col <= a.nu
	         */
	
	    }, {
	        key: 'fastTransposeSMatrix',
	        value: function fastTransposeSMatrix() {
	            var t = new TSMatrix();
	            t.mu = this.nu;
	            t.nu = this.mu;
	
	            if (this.data.length) {
	                var num = [];
	                for (var col = 0; col < this.nu; col++) {
	                    num[col] = 0;
	                }for (var i = 0; i < this.data.length; i++) {
	                    ++num[this.data[i].j];
	                } // 求矩阵中每一列含非零元个数
	                // 求第col列中第一个非零元在b.data中的序号
	                var cpot = [0];
	                for (var _col = 1; _col < this.nu; _col++) {
	                    // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                    cpot[_col] = cpot[_col - 1] + num[_col - 1];
	                }for (var p = 0; p < this.data.length; p++) {
	                    var _col2 = this.data[p].j;
	                    var q = cpot[_col2];
	                    t.data[q] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                    // 给该列的序号+1，用作相同列数的情况
	                    ++cpot[_col2];
	                }
	            }
	
	            return t;
	        }
	    }]);
	    return TSMatrix;
	}();
	
	var a1 = new Triple(1, 2, 12);
	var a2 = new Triple(1, 3, 9);
	var a3 = new Triple(3, 1, -3);
	var a4 = new Triple(3, 6, 14);
	var a5 = new Triple(4, 3, 24);
	var a6 = new Triple(5, 2, 18);
	var a7 = new Triple(6, 1, 15);
	var a8 = new Triple(6, 4, -7);
	
	var matrix = new TSMatrix();
	matrix.addTriple(a1);
	matrix.addTriple(a2);
	matrix.addTriple(a3);
	matrix.addTriple(a4);
	matrix.addTriple(a5);
	matrix.addTriple(a6);
	matrix.addTriple(a7);
	matrix.addTriple(a8);
	
	console.log(matrix.transposeSMatrix());
	console.log(matrix.fastTransposeSMatrix());
	
	/*
	 三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。
	 然而，若需按行号存取某一行的非零元，则从头开始进行查找。
	 */
	
	/**
	 * 行逻辑链接的顺序表
	 *
	 * 为了便于随机存取任意一行的非零元，则需知道每一行的第一个非零元在三元组表中的位置。
	 * 为此可将快速转置矩阵的算法中创建的，指示“行”信息的辅助数组cpot固定在稀疏矩阵的存储结构中。
	 * 称这种“带行链接信息”的三元组表为行逻辑链接的顺序表
	 */
	
	var RLSMatrix = exports.RLSMatrix = function (_TSMatrix) {
	    (0, _inherits3.default)(RLSMatrix, _TSMatrix);
	
	    function RLSMatrix() {
	        (0, _classCallCheck3.default)(this, RLSMatrix);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RLSMatrix).apply(this, arguments));
	
	        _this.rpos = [0];
	        return _this;
	    }
	    /**
	     * 求矩阵乘积Q = M * N，采用行逻辑链接存储表示
	     * @param nMatrix
	     * @returns {RLSMatrix}
	     */
	
	
	    (0, _createClass3.default)(RLSMatrix, [{
	        key: 'multSMatrix',
	        value: function multSMatrix(nMatrix) {
	            if (this.nu !== nMatrix.mu) throw Error('nu is not equivalent to mu');
	
	            // 初始化Q
	            var qMatrix = new RLSMatrix(this.mu, nMatrix.nu);
	            // Q是非零矩阵
	            if (this.data.length * nMatrix.data.length !== 0) {
	                // 处理M的每一行
	                for (var arow = 0; arow < this.mu; arow++) {
	                    // 当前行各元素累加器清零
	                    var ctemp = [];
	                    qMatrix.rpos[arow] = qMatrix.data.length + 1;
	                    var tp = void 0,
	                        ccol = void 0;
	
	                    if (arow < this.mu) tp = this.rpos[arow + 1];else tp = this.data.length + 1;
	
	                    //对当前行中每一个非零元找到对应元在N中的行号
	                    for (var p = this.rpos[arow]; p < tp; p++) {
	                        var brow = this.data[p].j;
	                        var t = void 0;
	                        if (brow < nMatrix.mu) t = nMatrix.rpos[brow + 1];else t = nMatrix.data.length + 1;
	
	                        for (var q = nMatrix.rpos[brow]; q < t; q++) {
	                            // 乘积元素在Q中的序号
	                            ccol = nMatrix.data[q].j;
	                            ctemp[ccol] = (ctemp[ccol] || 0) + this.data[p].e * nMatrix.data[q].e;
	                        }
	                    }
	
	                    // 压缩存储该行非零元
	                    for (ccol = 1; ccol < qMatrix.nu; ccol++) {
	                        if (ctemp[ccol]) {
	                            if (++qMatrix.data.length > RLSMatrix.MAXSIZE) throw Error('overflow');
	                            qMatrix.data[qMatrix.data.length - 1] = new Triple(arow, ccol, ctemp[ccol]);
	                        }
	                    }
	                }
	            }
	
	            return qMatrix;
	        }
	    }, {
	        key: '_calcPos',
	        value: function _calcPos() {
	            var num = [];
	            for (var col = 0; col < this.nu; col++) {
	                num[col] = 0;
	            }for (var i = 0; i < this.data.length; i++) {
	                ++num[this.data[i].j];
	            } // 求矩阵中每一列含非零元个数
	            // 求第col列中第一个非零元在b.data中的序号
	            for (var _col3 = 1; _col3 < this.nu; _col3++) {
	                // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                this.rpos[_col3] = this.rpos[_col3 - 1] + num[_col3 - 1];
	            }
	        }
	    }]);
	    return RLSMatrix;
	}(TSMatrix);
	
	RLSMatrix.MAXSIZE = 100;
	
	var b1 = new Triple(1, 1, 3);
	var b2 = new Triple(1, 3, 5);
	var b3 = new Triple(2, 2, -1);
	var b4 = new Triple(3, 1, 2);
	
	var t1 = new RLSMatrix();
	t1.addTriple(b1);
	t1.addTriple(b2);
	t1.addTriple(b3);
	t1.addTriple(b4);
	t1._calcPos();
	
	var c1 = new Triple(1, 2, 2);
	var c2 = new Triple(2, 1, 1);
	var c3 = new Triple(3, 1, -2);
	var c4 = new Triple(3, 2, 4);
	
	var t2 = new RLSMatrix();
	t2.addTriple(c1);
	t2.addTriple(c2);
	t2.addTriple(c3);
	t2.addTriple(c4);
	t2._calcPos();
	
	t1.multSMatrix(t2);

/***/ },
/* 79 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.huffManCoding = huffManCoding;
	/**
	 * 赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树，有着广泛应用。
	 *
	 * 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
	 * 树的路径长度是从树根到每一个结点的路径之和。
	 * 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。
	 *
	 * 构造赫夫曼树的步骤：
	 * （1）根据给定的n个权值{w1,w2,...wn}构成n棵二叉树的集合F = {T1,T2,...Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
	 * （2）在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
	 * （3）在F中删除这两棵树，同时将新得到的二叉树加入F中。
	 * （4）重复（2）和（3），直到F只含一棵树为止。这棵树便是赫夫曼树。
	 */
	/*
	赫夫曼编码
	http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81
	
	假设电报需传送的电文为“A B A C C D A”，它只有4种字符只需两个字符串便可分辨。假设A,B,C,D的编码分别为00,01,10和11，则上述7个字符的电文便为“00010010101100”，对方接收时，可按二位一分进行译码。
	在传送电文时，希望总长尽可能地短。如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便可减少。
	如果涉及A,B,C,D的编码分别为0,00,1和01，则上述7个字符的电文可转换成总长为9的字符串“000011010”。但是，这样的电文无法翻译，因为可有多种译法。
	因此，若要设计长短不等的编码，则必须是任意个字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码。
	可利用二叉树来设计二进制的前缀编码。假设有一棵二叉树，其4个叶子结点分别表示A,B,C,D这4个字符，且约定左分支表示字符“0”，右分支表示字符“1”，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。所得二进制前缀编码分别为0,10,110,111.
	设计电文总长最短的二进制前缀编码即以n种字符出现的频率作权。
	 */
	
	// 赫夫曼树和赫夫曼编码的存储结构
	function HuffmanNode(weight, parent, leftChild, rightChild) {
	    this.weight = weight || 0;
	    this.parent = parent || 0;
	    this.leftChild = leftChild || 0;
	    this.rightChild = rightChild || 0;
	}
	function huffManCoding(weights) {
	    var n = weights.length;
	    if (n < 1) return;
	
	    var huffmanTree = buildHuffmanTree(weights, n);
	
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = calcHuffmanCode(huffmanTree, n);
	
	    return [huffmanTree, hc];
	}
	
	function calcHuffmanCode(huffmanTree, n) {
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = [];
	    var cd = [];
	    for (var i = 0; i < n; i++) {
	        var start = n - 1;
	        for (var c = i, f = huffmanTree[i].parent; f != 0; c = f, f = huffmanTree[f].parent) {
	            if (huffmanTree[f].leftChild == c) cd[--start] = '0';else cd[--start] = '1';
	        }
	
	        hc[i] = strCopy(cd, start);
	    }
	
	    return hc;
	}
	
	// 创建一棵叶子结点数为n的Huffman树
	function buildHuffmanTree(weights, n) {
	    n = n || weights.length;
	    var m = 2 * n - 1;
	    var huffmanTree = [];
	
	    // 初始化
	    var i = void 0;
	    for (i = 0; i < n; i++) {
	        huffmanTree[i] = new HuffmanNode(weights[i], 0, 0, 0);
	    }for (; i < m; i++) {
	        huffmanTree[i] = new HuffmanNode(0, 0, 0, 0);
	    }for (var _i = n; _i < m; _i++) {
	        // 在HT[1..i-1]选择parent为0且weight最小的两个结点，返回其序号为[s1, s2]
	        var ret = select(huffmanTree, _i);
	        var s1 = ret[0];
	        var s2 = ret[1];
	        huffmanTree[s1].parent = _i;
	        huffmanTree[s2].parent = _i;
	        huffmanTree[_i].leftChild = s1;
	        huffmanTree[_i].rightChild = s2;
	        huffmanTree[_i].weight = huffmanTree[s1].weight + huffmanTree[s2].weight;
	    }
	
	    return huffmanTree;
	}
	
	function strCopy(str, start) {
	    var s = '';
	    for (; str[start]; start++) {
	        s += str[start];
	    }
	    return s;
	}
	
	function select(huffmanTree, len) {
	    var ret = [];
	    for (var i = 0; i < len; i++) {
	        var node = huffmanTree[i];
	        if (node.parent !== 0) continue;
	
	        if (ret.length < 2) {
	            ret.push(i);
	        } else {
	            var index = huffmanTree[ret[0]].weight > huffmanTree[ret[1]].weight ? 0 : 1;
	
	            if (node.weight < huffmanTree[ret[index]].weight) ret[index] = i;
	        }
	    }
	
	    if (ret[0] > ret[1]) {
	        var temp = ret[0];
	        ret[0] = ret[1];
	        ret[1] = temp;
	    }
	
	    return ret;
	}
	
	console.log('-------huffman coding 1:------');
	console.log(huffManCoding([5, 29, 7, 8, 14, 23, 3, 11]));

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(33);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _Queue = __webpack_require__(13);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 广义表
	 *
	 * 广义表是线性表的推广。广泛用于人工智能的表处理语言Lisp，把广义表作为基本的数据结构。
	 * 广义表一般记作：
	 *      LS = (a1, a2, ..., an)
	 * LS是广义表的名称，n是它的长度，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头，称其余元素组成的表(a2, a3, ..., an)是LS的表尾。
	 *
	 * 下面列举一些广义表的例子：
	 * 1.A = () ---- A是一个空表，它的长度为0。
	 * 2.B = (e) ---- 列表B只有一个原子e，B的长度为1。
	 * 3.C = (a, (b, c, d)) ---- 列表C的长度为2，两个元素分别为原子a和子表(b, c, d)。
	 * 4.D = (A, B, C) ---- 列表D的长度为3,3个元素都是列表。显示，将子表的值代入后，则有D = ((), (e), (a, (b, c, d)))。
	 * 5.E = (a, E) ---- 这是一个递归的表，它的长度为2.E相当于一个无限的列表E = (a, (a, (a, ...)))。
	 *
	 * 1）列表的元素可以是子表，而子表的元素还可以是子表。由此，列表是一个多层次的结构，可以用图形象地表示。
	 * 2)列表可为其它列表所共享。列表A，B和C为D的子表，则在D中可以不必列出子表的值。
	 * 3）列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如列表E。
	 *
	 * 任何一个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。
	 *
	 */
	
	/*
	 广义表的递归算法
	
	 递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。
	
	 由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，应注意：
	 （1）首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的字问题，只要接口一致，便可进行递归调用。
	 （2）对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。
	 */
	
	/*
	 求广义表的深度
	
	 广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。
	 设非空广义表为:
	 LS = (a1, a2, ..., an)
	
	 其中ai(i = 1, 2, ..., n)或为原子或为LS的子表，则求LS的深度可分解为n个子问题，每个子问题为求ai的深度，若ai是原子，则由定义其深度为零，若ai是广义表，则递归处理，而LS的深度为各ai(i = 1, 2, ..., n)的深度最大值加1.空表也是广义表，且深度为1.
	
	 广义表的深度DEPTH(LS)的递归定义为：
	 基本项：    DEPTH(LS) = 1   当LS为空表时
	 DEPTH(LS) = 0   当LS为原子时
	 归纳项：    DEPTH(LS) = 1 + MAX{DEPTH(ai)}  1 <= i <= n
	 */
	
	var ATOM = (0, _symbol2.default)();
	var LIST = (0, _symbol2.default)();
	
	var global = Function('return this')();
	// 使用链队列
	
	
	// 广义表的头尾链表存储表示
	
	var GLNode = function () {
	    function GLNode() {
	        (0, _classCallCheck3.default)(this, GLNode);
	
	        // 公共部分，用于区分原子结点和表结点
	        this.tag = undefined;
	
	        // atom是原子结点的值域
	        this.atom = null;
	        // ptr是表结点的指针域
	        this.ptr = {
	            // ptr.hp和ptr.tp分别指向表头和表尾
	            hp: null,
	            tp: null
	        };
	    }
	
	    // 采用头尾链表存储结构，求广义表的深度
	
	
	    (0, _createClass3.default)(GLNode, [{
	        key: 'depth',
	        value: function depth() {
	            return getDepth(this);
	        }
	
	        // 复制广义表
	
	    }, {
	        key: 'copyList',
	        value: function copyList(gList) {
	            gList.tag = this.tag;
	
	            if (this.tag === ATOM) {
	                gList.atom = this.atom;
	            } else {
	                if (this.ptr.hp) {
	                    gList.ptr.hp = new GLNode();
	                    this.ptr.hp.copyList(gList.ptr.hp);
	                }
	                if (this.ptr.tp) {
	                    gList.ptr.tp = new GLNode();
	                    this.ptr.tp.copyList(gList.ptr.tp);
	                }
	            }
	        }
	
	        // 采用头尾链表存储结构，由广义表的书写形式串创建广义表
	
	    }, {
	        key: 'createGList',
	        value: function createGList(string) {
	            string = string.trim();
	
	            // 创建单原子广义表
	            var q = void 0;
	            if (isWord(string)) {
	                this.tag = ATOM;
	                this.atom = string;
	            } else {
	                this.tag = LIST;
	                var p = this;
	
	                // 脱外层括号
	                var sub = string.substr(1, string.length - 2);
	
	                do {
	                    var hsub = void 0;
	                    var n = sub.length;
	                    var i = 0;
	                    var k = 0;
	                    var ch = void 0;
	
	                    do {
	                        ch = sub[i++];
	                        if (ch == '(') ++k;else if (ch == ')') --k;
	                    } while (i < n && (ch != ',' || k != 0));
	
	                    // i为第一个逗号分隔索引
	                    if (i < n) {
	                        hsub = sub.substr(0, i - 1);
	                        sub = sub.substr(i, n - i);
	
	                        // 最后一组
	                    } else {
	                            hsub = sub;
	                            sub = '';
	                        }
	
	                    if (hsub === '()') p.ptr.hp = null;
	                    // 创建表头结点
	                    else {
	                            p.ptr.hp = new GLNode();
	                            p.ptr.hp.createGList(hsub);
	                        }
	
	                    q = p;
	
	                    // 创建表尾结点
	                    if (sub) {
	                        p = new GLNode();
	                        p.tag = LIST;
	                        q.ptr.tp = p;
	                    }
	                } while (sub);
	
	                q.ptr.tp = null;
	            }
	        }
	    }, {
	        key: 'reverse',
	
	
	        // 递归逆转广义表
	        value: function reverse() {
	            var ptr = [];
	            // 当A不为原子且表尾非空时才需逆转
	            if (this.tag === LIST && this.ptr.tp) {
	                var i = 0;
	                for (var p = this; p; p = p.ptr.tp, i++) {
	                    // 逆转各子表
	                    if (p.ptr.hp) p.ptr.hp.reverse();
	
	                    ptr[i] = p.ptr.hp;
	                }
	
	                // 重新按逆序排列各子表的顺序
	                for (var _p = this; _p; _p = _p.ptr.tp) {
	                    _p.ptr.hp = ptr[--i];
	                }
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	            if (this == global || this == null) str = '()';else if (this.tag === ATOM) str = this.atom; // 原子
	            else {
	                    str += '(';
	
	                    for (var p = this; p; p = p.ptr.tp) {
	                        str += this.toString.call(p.ptr.hp);
	                        if (p.ptr.tp) str += ', ';
	                    }
	                    str += ')';
	                }
	
	            return str;
	        }
	
	        // 按层序输出广义表
	        // 层序遍历的问题，一般都是借助队列来完成的，每次从队头
	        // 取出一个元素的同时把它下一层的孩子插入队尾，这是层序遍历的基本思想
	
	    }, {
	        key: 'orderPrint',
	        value: function orderPrint() {
	            var queue = [];
	            for (var p = this; p; p = p.ptr.tp) {
	                queue.push(p);
	            }while (queue.length) {
	                var r = queue.shift();
	                if (r.tag === ATOM) console.log(r.atom);else {
	                    for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                        queue.push(r);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'orderPrint2',
	        value: function orderPrint2() {
	            var queue = new _Queue2.default();
	
	            for (var p = this; p; p = p.ptr.tp) {
	                queue.enQueue(p);
	            }while (queue.size) {
	                var r = queue.deQueue();
	                if (r.tag === ATOM) console.log(r.atom);else {
	                    for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                        queue.enQueue(r);
	                    }
	                }
	            }
	        }
	    }], [{
	        key: 'equal',
	        value: function equal(gList1, gList2) {
	            // 空表时相等的
	            if (!gList1 && !gList2) return true;
	            if (gList1.tag === ATOM && gList2.tag === ATOM && gList1.atom === gList2.atom) return true;
	
	            if (gList1.tag === LIST && gList2.tag === LIST) {
	                // 表头表尾都相等
	                if (this.equal(gList1.ptr.hp, gList2.ptr.hp) && this.equal(gList1.ptr.tp, gList2.ptr.tp)) return true;
	            }
	
	            return false;
	        }
	    }]);
	    return GLNode;
	}();
	
	// 广义表的扩展线性链表存储表示
	
	
	exports.default = GLNode;
	
	var GLNode2 = function GLNode2() {
	    (0, _classCallCheck3.default)(this, GLNode2);
	
	    // 公共部分，用于区分原子结点和表结点
	    this.tag = undefined;
	
	    // 原子结点的值域
	    this.atom = null;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性链表的next，指向下一个元素结点
	    this.tp = null;
	};
	
	function getDepth(gList) {
	    if (!gList) return 1;else if (gList.tag === ATOM) return 0;
	
	    var m = getDepth(gList.ptr.hp) + 1;
	    var n = getDepth(gList.ptr.tp);
	
	    return m > n ? m : n;
	}
	
	function isWord(str) {
	    return (/^[\w-]+$/.test(str)
	    );
	}
	
	/*
	 m元多项式表示
	
	 如果用线性表来表示,则每个数据元素需要m+1个数据项，以存储一个系数和m个指数值，这将产生两个问题。
	 一是无论多项式中各项的变元数是多是少，若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便。二是对m值不同的多项式，线性表中的结点大小也不同，这同样引起存储管理的不便。
	 故不适于用线性表表示。
	
	 例如三元多项式：
	 P(x, y, z) = x(10)y(3)z(2) + 2x(6)y(3)z(2) + 3x(5)y(2)z(2) + x(4)y(4)z + 2yz + 15
	
	 如若改写为：
	 P(x, y, z) = ((x(10) + 2x(6))y(3) + 3x(5)y(2))z(2) + ((x(4) + 6x(3))y(4) + 2y)z + 15
	
	 用广义表表示：
	 P = z((A, 2), (B, 1), (15, 0))
	 A = y((C, 3), (D, 2))
	 B = y((E, 4), (F, 1))
	 C = x((1, 10), (2, 6))
	 D = x((3, 5))
	 E = x((1, 4), (6, 3))
	 F = x((2, 0))
	
	
	 */
	
	function MPNode() {
	    // 区分原子结点和表结点
	    this.tag = undefined;
	    // 指数域
	    this.exp = 0;
	
	    // 系数域
	    this.coef = 0;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性表的next，指向下一个元素结点
	    this.tp = null;
	}

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 邻接多重表
	
	 邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。
	
	 邻接表是无向图的一种有效的存储结构，在无向图的邻接表中，一条边(v,w)的两个表结点分别初选在以v和w为头结点的链表中，很容易求得顶点和边的信息，但在涉及到边的操作会带来不便。
	
	 邻接多重表的结构和十字链表类似，每条边用一个结点表示；邻接多重表中的顶点结点结构与邻接表中的完全相同，而表结点包括六个域。
	
	 ◆  Data域：存储和顶点相关的信息；
	 ◆ 指针域firstedge：指向依附于该顶点的第一条边所对应的表结点；
	 ◆ 标志域mark：用以标识该条边是否被访问过；
	 ◆ ivex和jvex域：分别保存该边所依附的两个顶点在图中的位置；
	 ◆ info域：保存该边的相关信息；
	 ◆ 指针域ilink：指向下一条依附于顶点ivex的边；
	 ◆ 指针域jlink：指向下一条依附于顶点jvex的边；
	
	 邻接多重表与邻接表的区别：
	 后者的同一条边用两个表结点表示，而前者只用一个表结点表示；除标志域外，邻接多重表与邻接表表达的信息是相同的，因此，操作的实现也基本相似。
	
	 */
	
	var UNVISITED = 0;
	var VISITED = 1;
	
	var EBox =
	/**
	 * 边的结点表示
	 * @param {Number} mark 访问标记 0 -- 未访问  1 == 已访问
	 * @param {Number} ivex 该边依附的两个顶点的位置
	 * @param {Number} jvex 该边依附的两个顶点的位置
	 * @param {EBox} ilink 分别指向依附这两个顶点的下一条边
	 * @param {EBox} jlink 分别指向依附这两个顶点的下一条边
	 * @param {*} info 该边信息
	 * @constructor
	 */
	function EBox(mark, ivex, jvex, ilink, jlink, info) {
	    (0, _classCallCheck3.default)(this, EBox);
	
	    this.mark = mark || UNVISITED;
	    this.ivex = ivex || 0;
	    this.jvex = jvex || 0;
	    this.ilink = ilink || null;
	    this.jlink = jlink || null;
	    this.info = info || null;
	};
	
	var AMLVexBox =
	/**
	 * 顶点的结点表示
	 * @param {*} data
	 * @param {EBox} firstEdge 指向第一条依附该顶点的边
	 * @constructor
	 */
	function AMLVexBox(data, firstEdge) {
	    (0, _classCallCheck3.default)(this, AMLVexBox);
	
	    this.data = data || null;
	    this.firstEdge = firstEdge || null;
	};
	
	var AMLGraph = function () {
	    /**
	     *
	     * @param {Array | AMLVexBox} adjMulist
	     * @param {Number} vexnum
	     * @param {Number} edgenum
	     * @constructor
	     */
	
	    function AMLGraph(adjMulist, vexnum, edgenum) {
	        (0, _classCallCheck3.default)(this, AMLGraph);
	
	        this.adjMulist = adjMulist || [];
	        this.vexnum = vexnum || 0;
	        this.edgenum = edgenum || 0;
	    }
	
	    (0, _createClass3.default)(AMLGraph, [{
	        key: 'locateVex',
	        value: function locateVex(v) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.adjMulist[i].data === v) return i;
	            }
	            return -1;
	        }
	    }, {
	        key: 'deleteArc',
	        value: function deleteArc(v, w) {
	            var i = this.locateVex(v);
	            var j = this.locateVex(w);
	
	            if (i < 0 || j < 0) throw new Error('Vertex not found!');
	
	            var p;
	            // 在i链表中删除该边
	            if (this.adjMulist[i].firstEdge.jvex === j) {
	                this.adjMulist[i].firstEdge = this.adjMulist[i].firstEdge.ilink;
	            } else {
	                for (p = this.adjMulist[i].firstEdge; p && p.ilink.jvex !== j; p = p.ilink) {}
	                if (!p) throw new Error('edge not found!');
	                p.ilink = p.ilink.ilink;
	            }
	
	            // 在j链表中删除该边
	            if (this.adjMulist[j].firstEdge.ivex === i) {
	                this.adjMulist[j].firstEdge = this.adjMulist[j].firstEdge.jlink;
	            } else {
	                for (p = this.adjMulist[j].firstEdge; p && p.jlink.ivex !== i; p = p.jlink) {}
	                if (!p) throw new Error('edge not found!');
	                p.jlink = p.jlink.jlink;
	            }
	
	            this.edgenum--;
	            return true;
	        }
	    }, {
	        key: 'createGraph',
	        value: function createGraph() {
	            var vexnum = +prompt('vexnum: ');
	            this.vexnum = vexnum;
	            var edgenum = +prompt('edgenum: ');
	            this.edgenum = edgenum;
	
	            for (var m = 0; m < vexnum; ++m) {
	                this.adjMulist[m] = new AMLVexBox(prompt('data: '), null);
	            }
	
	            for (m = 0; m < edgenum; ++m) {
	                var t = prompt('tailVex: ');
	                var h = prompt('headVex: ');
	                var i = this.locateVex(t);
	                var j = this.locateVex(h);
	
	                if (i < 0 || j < 0) {
	                    console.error('vertex not found! Try again:');
	                    m--;
	                    continue;
	                }
	
	                var p = new EBox(0, i, j, null, null);
	                var q, r;
	
	                // 插入i链表尾部
	                if (!this.adjMulist[i].firstEdge) {
	                    this.adjMulist[i].firstEdge = p;
	                } else {
	                    q = this.adjMulist[i].firstEdge;
	                    while (q) {
	                        r = q;
	                        if (q.ivex === i) q = q.ilink;else q = q.jlink;
	                    }
	                    if (r.ivex === i) r.ilink = p;else r.jlink = p;
	                }
	
	                // 插入j链表尾部
	                if (!this.adjMulist[j].firstEdge) {
	                    this.adjMulist[j].firstEdge = p;
	                } else {
	                    q = this.adjMulist[j].firstEdge;
	                    while (q) {
	                        r = q;
	                        if (q.jvex === j) q = q.jlink;else q = q.ilink;
	                    }
	                    if (r.jvex === j) r.jlink = p;else r.ilink = p;
	                }
	            }
	        }
	    }]);
	    return AMLGraph;
	}();
	
	//var g = new AMLGraph();
	//g.createGraph();
	//console.log(g);
	
	
	exports.default = AMLGraph;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(19);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(13);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(18);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* Create By Luke */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	/*
	 邻接链表法
	
	 基本思想：对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。
	
	 第i个单链表表示依附于顶点Vi的边(对有向图是以顶点Vi为头或尾的弧)。
	
	 1  结点结构与邻接链表示例
	
	 链表中的结点称为表结点，每个结点由三个域组成。其中邻接点域(adjvex)指示与顶点Vi邻接的顶点在图中的位置(顶点编号)，链域(nextarc)指向下一个与顶点Vi邻接的表结点，数据域(info)存储和边或弧相关的信息，如权值等。对于无权图，如果没有与边相关的其他信息，可省略此域。
	
	 每个链表设一个表头结点(称为顶点结点)，由两个域组成。链域(firstarc)指向链表中的第一个结点，数据域(data) 存储顶点名或其他信息。
	
	 在图的邻接链表表示中，所有顶点结点用一个向量 以顺序结构形式存储，可以随机访问任意顶点的链表，该向量称为表头向量，向量的下标指示顶点的序号。
	
	 用邻接链表存储图时，对无向图，其邻接链表是唯一的；对有向图，其邻接链表有两种形式。
	
	
	 2  邻接表法的特点
	
	 ◆ 表头向量中每个分量就是一个单链表的头结点，分量个数就是图中的顶点数目；
	 ◆ 在边或弧稀疏的条件下，用邻接表表示比用邻接矩阵表示节省存储空间；
	 ◆ 在无向图，顶点Vi的度是第i个链表的结点数；
	 ◆ 对有向图可以建立正邻接表或逆邻接表。正邻接表是以顶点Vi为出度(即为弧的起点)而建立的邻接表；逆邻接表是以顶点Vi为入度(即为弧的终点)而建立的邻接表；
	 ◆ 在有向图中，第i个链表中的结点数是顶点Vi的出 (或入)度；求入 (或出)度，须遍历整个邻接表；
	 ◆ 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点；
	
	 */
	
	var ArcNode =
	/**
	 *
	 * @param {Number} adjVex
	 * @param {ArcNode} nextArc
	 * @param {*} info
	 * @constructor
	 */
	function ArcNode() {
	    var adjVex = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var nextArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, ArcNode);
	
	    // 该弧所指向的顶点的位置
	    this.adjVex = adjVex;
	    // 指向下一条弧的指针
	    this.nextArc = nextArc;
	    // 该弧相关信息的指针
	    this.info = info;
	};
	
	var VexNode =
	/**
	 *
	 * @param {*} data
	 * @param {ArcNode} firstArc
	 * @param {Number} indegree
	 * @constructor
	 */
	function VexNode(data) {
	    var firstArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var indegree = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    (0, _classCallCheck3.default)(this, VexNode);
	
	    // 顶点信息
	    this.data = data;
	    // 指向第一条依附该顶点的弧的指针
	    this.firstArc = firstArc;
	    //  顶点的度, 有向图是入度或出度或没有
	    this.indegree = indegree;
	};
	
	var AdjacencyListGraph = function () {
	    /**
	     *
	     * @param {Array | VexNode} vertices
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	
	    function AdjacencyListGraph() {
	        var vertices = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var vexnum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var arcnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var kind = arguments.length <= 3 || arguments[3] === undefined ? DG : arguments[3];
	        (0, _classCallCheck3.default)(this, AdjacencyListGraph);
	
	        this.vertices = vertices;
	        // 图的当前顶点数和弧数
	        this.vexnum = vexnum;
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    // 查找顶点位置
	
	
	    (0, _createClass3.default)(AdjacencyListGraph, [{
	        key: 'locateVex',
	        value: function locateVex(vp) {
	            for (var _i = 0; _i < this.vexnum; ++_i) {
	                if (this.vertices[_i].data === vp) return _i;
	            }
	
	            return -1;
	        }
	
	        // 添加顶点
	
	    }, {
	        key: 'addVertex',
	        value: function addVertex(vp) {
	            if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	            this.vertices[this.vexnum++] = new VexNode(vp, null, 0);
	            return this.vexnum;
	        }
	
	        /**
	         * 添加弧
	         * 如果是无向图或者无向网,arc1和arc2无顺序要求
	         * 如果是有向图或者有向网，只会添加arc1，因此正邻接表和逆邻接表的顺序需要注意
	         * @param {String} arc1
	         * @param {String} arc2
	         * @param {*} info
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'addArc',
	        value: function addArc(arc1, arc2, info) {
	            var k = this.locateVex(arc1);
	            var j = this.locateVex(arc2);
	
	            if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	            // 边的起始表结点赋值
	            var p = new ArcNode(k, null, info);
	            // 边的末尾表结点赋值
	            var q = new ArcNode(j, null, info);
	
	            // 是无向图，用头插入法插入到两个单链表
	            if (this.kind === UDG || this.kind === UDN) {
	                q.nextArc = this.vertices[k].firstArc;
	                this.vertices[k].firstArc = q;
	                p.nextArc = this.vertices[j].firstArc;
	                this.vertices[j].firstArc = p;
	            }
	            // 建立有向图的邻接链表，用头插入法
	            else {
	                    p.nextArc = this.vertices[j].firstArc;
	                    this.vertices[j].firstArc = p;
	                }
	
	            ++this.arcnum;
	
	            return true;
	        }
	
	        // TODO 其他图类型的创建暂时没弄
	
	    }, {
	        key: 'createGraph',
	        value: function createGraph() {
	            this.vexnum = +prompt('vexnum: ');
	            this.arcnum = +prompt('arcnum: ');
	            // incInfo为0则各弧不含其他信息
	            var incInfo = +prompt('incInfo: ');
	
	            for (var _m = 0; _m < this.vexnum; ++_m) {
	                this.vertices[_m] = new VexNode();
	                this.vertices[_m].data = prompt('vertex: ');
	            }
	
	            for (m = 0; m < this.arcnum; ++m) {
	                var h = prompt('弧头: ');
	                var t = prompt('弧尾: ');
	                var _i2 = this.locateVex(t);
	                var j = this.locateVex(h);
	
	                if (_i2 < 0 || j < 0) {
	                    alert('顶点为找到，请重新输入！');
	                    m--;
	                    continue;
	                }
	
	                var p = new ArcNode(j, null, incInfo && prompt('info: '));
	
	                if (!this.vertices[_i2].firstArc) this.vertices[_i2].firstArc = p;else {
	                    for (var _q = this.vertices[_i2].firstArc; _q.nextArc; _q = _q.nextArc) {}
	                    q.nextArc = p;
	                }
	            }
	        }
	
	        // 判断一个邻接表存储的有向图是否可传递
	
	    }, {
	        key: 'isPass',
	        value: function isPass() {
	            if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	            for (var x = 0; x < this.vexnum; ++x) {
	                for (var p = this.vertices[x].firstArc; p; p = p.nextArc) {
	                    var y = p.adjVex;
	                    for (var _q2 = this.vertices[y].firstArc; _q2; _q2 = _q2.nextArc) {
	                        var z = _q2.adjVex;
	                        if (z !== x && this.isAdj(x, z)) return false;
	                    }
	                }
	            }
	
	            return true;
	        }
	
	        // 判断有向图是否存在边(m,n)
	
	    }, {
	        key: 'isAdj',
	        value: function isAdj(m, n) {
	            for (var p = this.vertices[m].firstArc; p; p = p.nextArc) {
	                if (p.adjVex === n) return true;
	            }
	            return false;
	        }
	
	        /**
	         * 深度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	         * @param {String} i
	         * @param {String} j
	         */
	
	    }, {
	        key: 'exist_path_DFS',
	        value: function exist_path_DFS(i, j) {
	            var visited = [];
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	
	            if (i < 0 || j < 0) throw new Error('vertex not found!');
	
	            return exist_path(this, i, j);
	
	            function exist_path(graph, i, j) {
	                if (i === j) return true;
	
	                visited[i] = true;
	                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (!visited[k] && exist_path(graph, k, j)) return true;
	                }
	
	                return false;
	            }
	        }
	
	        /**
	         * 广度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	         * @param {String} i
	         * @param {String} j
	         */
	
	    }, {
	        key: 'exist_path_BFS',
	        value: function exist_path_BFS(i, j) {
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	            var visited = [];
	            var queue = new _Queue2.default();
	            queue.enQueue(i);
	
	            while (queue.rear) {
	                var u = queue.deQueue();
	                visited[u] = 1;
	
	                for (var p = this.vertices[i].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (k === j) return true;
	                    if (!visited[k]) queue.enQueue(k);
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * 判断邻接表方式存储的有向图的顶点i到j是否存在长度为k的简单路径
	         * @param {String} i
	         * @param {String} j
	         * @param {Number} k
	         */
	
	    }, {
	        key: 'exist_path_len',
	        value: function exist_path_len(i, j, k) {
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	            var visited = [];
	
	            return function recurse(graph, i, j, k) {
	                // 找到了一条路径，且长度符合
	                if (i === j && k === 0) return true;else if (k > 0) {
	                    visited[i] = 1;
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        if (!visited[l]) {
	                            // 剩余路径长度减一
	                            if (recurse(graph, l, j, k - 1)) return true;
	                        }
	                    }
	                    // 允许曾经被访问过的结点出现在另一条路径上
	                    visited[i] = 0;
	                }
	
	                return false;
	            }(this, i, j, k);
	        }
	
	        /**
	         * 求有向图中顶点u到v之间的所有简单路径，k为当前路径长度
	         * @param {String} u
	         * @param {String} v
	         * @param {Number} k
	         *
	         * @example
	         *  graph.find_all_path('v1', 'v2', 0);
	         */
	
	    }, {
	        key: 'find_all_path',
	        value: function find_all_path(u, v, k) {
	            u = this.locateVex(u);
	            v = this.locateVex(v);
	            var path = [];
	            var visited = [];
	
	            findPath(this, u, v, k);
	
	            function findPath(graph, u, v, k) {
	                // 加入当前路径中
	                path[k] = u;
	                visited[u] = 1;
	
	                // 找到一条简单路径
	                if (u === v) {
	                    console.log('Found one path!');
	                    for (var _i3 = 0; path[_i3]; ++_i3) {
	                        console.log(path[_i3]);
	                    }
	                } else {
	                    for (var p = graph.vertices[u].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        // 继续寻找
	                        if (!visited[l]) findPath(graph, l, v, k + 1);
	                    }
	                }
	
	                visited[u] = 0;
	                // 回溯
	                path[k] = 0;
	            }
	        }
	
	        /**
	         * 求有向图的顶点之间长度为len的简单路径条数
	         * @param {String} i
	         * @param {String} j
	         * @param {Number} len
	         */
	
	    }, {
	        key: 'getPathNum_len',
	        value: function getPathNum_len(i, j, len) {
	            var visited = [];
	
	            return function recurse(graph, i, j, len) {
	                if (i === j && len === 0) return 1;else if (len > 0) {
	                    var sum = 0;
	                    visited[i] = 1;
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        if (!visited[l]) sum += recurse(l, j, len - 1);
	                    }
	                    visited[i] = 0;
	                    return sum;
	                }
	            }(this, i, j, len);
	        }
	
	        /**
	         * 求有向无环图的根
	         */
	
	    }, {
	        key: 'getRoot',
	        value: function getRoot() {
	            var visited = [];
	
	            for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                // 每次都要将访问数组清零
	                for (var _w = 0; _w < this.vexnum; ++_w) {
	                    visited[_w] = false;
	                } // 从顶点i出发进行深度优先遍历
	                dfs(this, _i4);
	
	                var flag = true;
	                for (w = 0; w < this.vexnum; ++w) {
	                    // 如果i是根，则深度优先遍历可以访问到所有结点
	                    if (!visited[w]) flag = false;
	                }
	
	                if (flag) console.log('Found a root vertex: %d', _i4);
	            }
	
	            function dfs(graph, v) {
	                visited[v] = true;
	
	                for (var p = graph.vertices[v].firstArc; p; p = p.nextArc) {
	                    var _w2 = p.adjVex;
	                    if (!visited[_w2]) dfs(graph, _w2);
	                }
	            }
	        }
	
	        /**
	         * 求一个有向无环图中最长的路径
	         */
	
	    }, {
	        key: 'getLongestPath',
	        value: function getLongestPath() {
	            var mlp = [];
	            var path = [];
	            var visited = [];
	            var maxLen = 0;
	
	            this.countIndegree();
	
	            for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                for (var j = 0; j < this.vexnum; ++j) {
	                    visited[j] = false;
	                } // 从每一个零入度结点开始深度优先遍历
	                if (this.vertices[_i5].indegree === 0) dfs(this, _i5, 0);
	            }
	
	            console.log('Longest Path:');
	            // 输出最长路径
	            for (i = 0; mlp[i]; ++i) {
	                console.log(mlp.join(','));
	            }function dfs(graph, i, len) {
	                visited[i] = true;
	                path[len] = i;
	
	                // 新的最长路径
	                if (len > maxLen && !graph.vertices[i].firstArc) {
	                    // 保存下来
	                    for (var _j = 0; _j <= len; ++_j) {
	                        mlp[_j] = path[_j];
	                    }maxLen = len;
	                } else {
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var _w3 = p.adjVex;
	                        if (!visited[_w3]) dfs(graph, _w3, len + 1);
	                    }
	                }
	
	                path[i] = 0;
	                visited[i] = false;
	            }
	        }
	
	        // 邻接表的递归式深度优先遍历
	
	    }, {
	        key: 'DFSTraverse',
	        value: function DFSTraverse(visitFn) {
	            var visited = [];
	            for (var _i6 = 0; _i6 < this.vexnum; ++_i6) {
	                visited[_i6] = false;
	            }for (var _i7 = 0; _i7 < this.vexnum; ++_i7) {
	                if (!visited[_i7]) dfs(this, _i7);
	            }
	
	            function dfs(graph, v) {
	                visited[v] = true;
	                visitFn.call(graph, v);
	
	                var p = graph.vertices[v].firstArc;
	                while (p) {
	                    if (!visited[p.adjVex]) dfs(graph, p.adjVex);
	
	                    p = p.nextArc;
	                }
	            }
	        }
	
	        // 邻接表的非递归深度优先搜索
	
	    }, {
	        key: 'DFSTraverse_NonRecurse',
	        value: function DFSTraverse_NonRecurse(visitFn) {
	            var visited = [];
	            var stack = new _index2.default();
	            for (var _i8 = 0; _i8 < this.vexnum; ++_i8) {
	                visited[_i8] = false;
	            }for (var _i9 = 0; _i9 < this.vexnum; ++_i9) {
	                if (!visited[_i9]) {
	                    stack.push(_i9);
	                    visited[_i9] = true;
	                    visitFn.call(this, _i9);
	
	                    var v = void 0;
	                    while ((v = stack.peek()) != null) {
	                        var p = this.vertices[v].firstArc;
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                visitFn.call(this, p.adjVex);
	                                stack.push(p.adjVex);
	                            } else stack.pop();
	
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	        }
	
	        // 邻接表的广度优先搜索
	
	    }, {
	        key: 'BFSTraverse',
	        value: function BFSTraverse(visitFn) {
	            var queue = new _Queue2.default();
	            var visited = [];
	            for (var _i10 = 0; _i10 < this.vexnum; ++_i10) {
	                visited[_i10] = false;
	            }for (var _i11 = 0; _i11 < this.vexnum; ++_i11) {
	                if (!visited[_i11]) {
	                    queue.enQueue(_i11);
	                    visited[_i11] = true;
	                    visitFn.call(this, _i11);
	
	                    while (queue.rear) {
	                        var _w4 = queue.deQueue();
	                        var p = this.vertices[_w4].firstArc;
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                visitFn.call(this, p.adjVex);
	                                queue.enQueue(p.adjVex);
	                            }
	
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	        }
	
	        // 建立无向图的深度优先生成森林的孩子兄弟链表树
	
	    }, {
	        key: 'createDFSForest',
	        value: function createDFSForest() {
	            var tree = null;
	            var visited = [];
	            for (var _i12 = 0; _i12 < this.vexnum; ++_i12) {
	                visited[_i12] = false;
	            }var q = void 0;
	            for (var _i13 = 0; _i13 < this.vexnum; ++_i13) {
	                if (!visited[_i13]) {
	                    // 新的生成树的根结点
	                    var p = new _BinaryTree.ChildSiblingTree(this.vertices[_i13].data);
	
	                    // 第一棵生成树的根
	                    if (!tree) tree = p;
	                    // 其它生成树的根
	                    else q.nextSibling = p;
	
	                    // q为当前生成树的根
	                    q = p;
	                    // 建立以p为根的生成树
	                    DFSTree(this, _i13, p);
	                }
	            }
	
	            return tree;
	
	            // 以第v个顶点触发深度优先遍历图，建立以tree为根的生成树
	            function DFSTree(graph, v, tree) {
	                visited[v] = true;
	                var first = true;
	                var w = graph.vertices[v].firstArc;
	                var q = void 0;
	
	                while (w) {
	                    if (!visited[w.adjVex]) {
	                        visited[w.adjVex] = true;
	                        var _p = new _BinaryTree.ChildSiblingTree(graph.vertices[w.adjVex].data);
	
	                        // w是v的第一个未被访问的邻接结点
	                        if (first) {
	                            tree.firstChild = _p;
	                            first = false;
	                        }
	                        // w是v的其它未被访问的邻接顶点
	                        else q.nextSibling = _p;
	
	                        q = _p;
	
	                        DFSTree(graph, w.adjVex, q);
	                    }
	
	                    w = w.nextArc;
	                }
	            }
	        }
	    }, {
	        key: 'createBFSForest',
	        value: function createBFSForest() {
	            var tree = null;
	            var visited = [];
	            var queue = new _Queue2.default();
	            for (var _i14 = 0; _i14 < this.vexnum; ++_i14) {
	                visited[_i14] = false;
	            }var q = void 0;
	            for (var _i15 = 0; _i15 < this.vexnum; ++_i15) {
	                if (!visited[_i15]) {
	                    visited[_i15] = true;
	                    queue.enQueue(_i15);
	
	                    var node = new _BinaryTree.ChildSiblingTree(this.vertices[_i15].data);
	                    if (!tree) tree = node;else q.nextSibling = node;
	
	                    q = node;
	
	                    while (queue.rear) {
	                        var _w5 = queue.deQueue();
	                        var p = this.vertices[_w5].firstArc;
	                        var first = true;
	                        var pre = void 0;
	
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                queue.enQueue(p.adjVex);
	
	                                var node2 = new _BinaryTree.ChildSiblingTree(this.vertices[p.adjVex].data);
	
	                                if (first) {
	                                    node.firstChild = node2;
	                                    first = false;
	                                } else pre.nextSibling = node2;
	
	                                pre = node2;
	                            }
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	
	            return tree;
	        }
	    }, {
	        key: 'findArticul',
	        value: function findArticul() {
	            var visited = [];
	            var count = 1;
	            var low = [];
	            low[0] = count;
	            visited[0] = 1;
	            for (var _i16 = 1; _i16 < this.vexnum; ++_i16) {
	                visited[_i16] = 0;
	            }var p = this.vertices[0].firstArc;
	            var v = p.adjVex;
	
	            DFSArticul(this, v);
	            if (count < this.vexnum) {
	                console.log(0 + '  ' + this.vertices[0].data);
	                while (p.nextArc) {
	                    p = p.nextArc;
	                    v = p.adjVex;
	                    if (visited[v] === 0) DFSArticul(this, v);
	                }
	            }
	
	            function DFSArticul(graph, v0) {
	                var min = visited[v0] = ++count;
	                for (var _p2 = graph.vertices[v0].firstArc; _p2; _p2 = _p2.nextArc) {
	                    var _w6 = _p2.adjVex;
	                    if (visited[_w6] === 0) {
	                        DFSArticul(graph, _w6);
	                        if (low[_w6] < min) min = low[_w6];
	                        if (low[_w6] >= visited[v0]) console.log(v0 + '  ' + graph.vertices[v0].data);
	                    } else if (visited[_w6] < min) min = visited[_w6];
	                }
	                low[v0] = min;
	            }
	        }
	
	        // 统计各顶点入度的函数
	
	    }, {
	        key: 'countIndegree',
	        value: function countIndegree() {
	            for (var k = 0; k < this.vexnum; ++k) {
	                this.vertices[k].indegree = 0;
	            }for (var _k = 0; _k < this.vexnum; ++_k) {
	                for (var p = this.vertices[_k].firstArc; p; p = p.nextArc) {
	                    ++this.vertices[p.adjVex].indegree;
	                }
	            }
	        }
	
	        // 拓扑排序算法
	
	    }, {
	        key: 'topologicSort',
	        value: function topologicSort() {
	            var stack = new _index2.default();
	            this.topologicalOrder = [];
	            this.countIndegree();
	
	            for (var _i17 = 0; _i17 < this.vexnum; ++_i17) {
	                if (this.vertices[_i17].indegree === 0) stack.push(_i17);
	            }
	
	            var count = 0;
	            while (stack.length) {
	                var _i18 = stack.pop();
	                this.topologicalOrder.push(_i18);
	                console.log(this.vertices[_i18].data);
	                ++count;
	                for (var p = this.vertices[_i18].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (--this.vertices[k].indegree === 0) stack.push(k);
	                }
	            }
	
	            return count >= this.vexnum;
	        }
	
	        // 输出有向图的各项关键活动
	
	    }, {
	        key: 'criticalPath',
	        value: function criticalPath() {
	            if (!this.topologicSort()) throw new Error('AOE网中存在回路！');
	
	            var ve = [];
	            // 事件最早发生时间初始化
	            for (var j = 0; j < this.vexnum; ++j) {
	                ve[j] = 0;
	            } // 计算每个事件的最早发生时间ve值
	            for (var _m2 = 0; _m2 < this.vexnum; ++_m2) {
	                var _j2 = this.topologicalOrder[_m2];
	                for (var p = this.vertices[_j2].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (ve[_j2] + p.info > ve[k]) ve[k] = ve[_j2] + p.info;
	                }
	            }
	            var vl = [];
	            // 事件最晚发生时间初始化
	            for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	                vl[_j3] = ve[this.vexnum - 1];
	            } // 计算每个事件的最晚发生时间vl的值
	            for (var _m3 = this.vexnum - 1; _m3 >= 0; --_m3) {
	                var _j4 = this.topologicalOrder[_m3];
	                for (var _p3 = this.vertices[_j4].firstArc; _p3; _p3 = _p3.nextArc) {
	                    var _k2 = _p3.adjVex;
	                    if (vl[_k2] - _p3.info < vl[_j4]) vl[_j4] = vl[_k2] - _p3.info;
	                }
	            }
	            // 输出所有关键活动
	            for (var _m4 = 0; _m4 < this.vexnum; ++_m4) {
	                for (var _p4 = this.vertices[_m4].firstArc; _p4; _p4 = _p4.nextArc) {
	                    var _k3 = _p4.adjVex;
	                    if (ve[_m4] + _p4.info === vl[_k3]) console.log('<%d, %d>', _m4, _k3);
	                }
	            }
	        }
	    }, {
	        key: 'shortestPath_Dijkstra',
	        value: function shortestPath_Dijkstra(v0) {
	            var dist = [];
	            var pre = [];
	            var final = [];
	            var w = void 0;
	
	            for (var _v = 0; _v < this.vexnum; ++_v) {
	                dist[_v] = Infinity;
	            }for (var p = this.vertices[v0].firstArc; p; p = p.nextArc) {
	                dist[p.adjVex] = p.info;
	            }var v = void 0;
	            for (v = 0; v < this.vexnum; ++v) {
	                final[v] = false;
	                pre[v] = pre[v] || [];
	                for (w = 0; w < this.vexnum; ++w) {
	                    pre[v][w] = false;
	                }if (dist[v] < Infinity) {
	                    pre[v][v0] = true;
	                    pre[v][v] = true;
	                }
	            }
	
	            dist[v0] = 0;
	            final[v0] = true;
	
	            for (var _i19 = 1; _i19 < this.vexnum; ++_i19) {
	                var min = Infinity;
	                for (w = 0; w < this.vexnum; ++w) {
	                    if (!final[w] && dist[w] < min) {
	                        v = w;
	                        min = dist[w];
	                    }
	                }
	
	                final[v] = true;
	
	                for (var _p5 = this.vertices[v].firstArc; _p5; _p5 = _p5.nextArc) {
	                    w = _p5.adjVex;
	                    if (!final[w] && min + _p5.info < dist[w]) {
	                        dist[w] = min + _p5.info;
	                        pre[w] = pre[v];
	                        pre[w][w] = true;
	                    }
	                }
	            }
	
	            console.log(final);
	            console.log(pre);
	            console.log(dist);
	
	            return {
	                final: final,
	                pre: pre,
	                dist: dist
	            };
	        }
	    }]);
	    return AdjacencyListGraph;
	}();
	
	// 无向图的邻接表
	
	
	exports.default = AdjacencyListGraph;
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v1', 'v2');
	adjListGraph.addArc('v1', 'v3');
	adjListGraph.addArc('v1', 'v4');
	adjListGraph.addArc('v2', 'v3');
	adjListGraph.addArc('v3', 'v4');
	adjListGraph.addArc('v3', 'v5');
	adjListGraph.addArc('v4', 'v5');
	
	console.log(adjListGraph);
	
	// 有向图的逆邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v1', 'v2');
	g.addArc('v1', 'v4');
	g.addArc('v3', 'v2');
	g.addArc('v3', 'v1');
	g.addArc('v4', 'v3');
	g.addArc('v3', 'v5');
	g.addArc('v5', 'v4');
	
	console.log(g);
	
	// 有向图的正邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v2', 'v1');
	g.addArc('v4', 'v1');
	g.addArc('v2', 'v3');
	g.addArc('v1', 'v3');
	g.addArc('v3', 'v4');
	g.addArc('v5', 'v3');
	g.addArc('v4', 'v5');
	
	console.log(g);
	
	console.log('adjListGraph DFSTraverse: ');
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v5', 'v4');
	adjListGraph.addArc('v3', 'v2');
	adjListGraph.addArc('v2', 'v1');
	adjListGraph.addArc('v3', 'v1');
	
	adjListGraph.DFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph DFSTraverse_NonRecurse: ');
	adjListGraph.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph BFSTraverse: ');
	var g2 = new AdjacencyListGraph([], 0, 0, DG);
	g2.addVertex('v1');
	g2.addVertex('v2');
	g2.addVertex('v3');
	g2.addVertex('v4');
	g2.addVertex('v5');
	
	g2.addArc('v4', 'v1');
	g2.addArc('v2', 'v1');
	g2.addArc('v5', 'v3');
	g2.addArc('v2', 'v3');
	g2.addArc('v1', 'v3');
	g2.addArc('v3', 'v4');
	g2.addArc('v4', 'v5');
	
	g2.BFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('DFS: expect false: ' + adjListGraph.exist_path_DFS('v1', 'v4'));
	console.log('DFS: expect true: ' + adjListGraph.exist_path_DFS('v1', 'v2'));
	
	console.log('BFS : expect false: ' + adjListGraph.exist_path_BFS('v1', 'v4'));
	console.log('BFS :expect true: ' + adjListGraph.exist_path_BFS('v1', 'v2'));
	
	/*
	 图的连通性问题
	
	 无向图的连通分量与生成树
	
	 1 无向图的连通分量和生成树
	 对于无向图，对其进行遍历时：
	 ◆ 若是连通图：仅需从图中任一顶点出发，就能访问图中的所有顶点；
	 ◆ 若是非连通图：需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集；
	
	 ⑴ 若G=(V,E)是无向连通图， 顶点集和边集分别是V(G) ，E(G) 。若从G中任意点出发遍历时， E(G)被分成两个互不相交的集合：
	 T(G) ：遍历过程中所经过的边的集合；
	 B(G) ：遍历过程中未经过的边的集合；
	 显然： E(G)=T(G)∪B(G) ，T(G)∩B(G)=Ø
	 显然，图G’=(V, T(G))是G的极小连通子图，且G’是一棵树。G’称为图G的一棵生成树。
	 从任意点出发按DFS算法得到生成树G’称为深度优先生成树；按BFS算法得到的G’称为广度优先生成树。
	
	 ⑵  若G=(V,E)是无向非连通图，对图进行遍历时得到若干个连通分量的顶点集：V1(G) ,V2(G) ,…,Vn(G)和相应所经过的边集：T1(G) ,T2(G) , …,Tn(G) 。
	 则对应的顶点集和边集的二元组：Gi=(Vi(G),Ti(G))
	 (1≦i≦n)是对应分量的生成树，所有这些生成树构成了原来非连通图的生成森林。
	
	 说明：当给定无向图要求画出其对应的生成树或生成森林时，必须先给出相应的邻接表，然后才能根据邻接表画出其对应的生成树或生成森林。
	
	
	 2  图的生成树和生成森林算法
	
	 对图的深度优先搜索遍历DFS(或BFS)算法稍作修改，就可得到构造图的DFS生成树算法。
	 在算法中，树的存储结构采用孩子—兄弟表示法。首先建立从某个顶点V出发，建立一个树结点，然后再分别以V的邻接点为起始点，建立相应的子生成树，并将其作为V 结点的子树链接到V结点上。显然，算法是一个递归算法。
	
	 */
	
	console.log(adjListGraph.createDFSForest());
	
	console.log(adjListGraph.createBFSForest());
	
	/*
	 在某图中，若删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。一个没有关节点的连通图称为重连通图。
	 在重连通图中，任意一对顶点之间至少存在两条路径，则再删去某个顶点即相关各边后也不破坏图的连通性。若在图的连通图上删去k个节点才能破坏图的连通性，则称K为此图的连通度。
	 他们常常在通信网络的图或航空网中应用，K越大，系统越稳定，反之，战争中若要摧毁敌方的运输线，只须破坏其运输网中的关节点即可。
	 */
	
	var articulTest = new AdjacencyListGraph([], 0, 0, UDG);
	articulTest.addVertex('A');
	articulTest.addVertex('B');
	articulTest.addVertex('C');
	articulTest.addVertex('D');
	articulTest.addVertex('E');
	articulTest.addVertex('F');
	articulTest.addVertex('G');
	articulTest.addVertex('H');
	articulTest.addVertex('I');
	articulTest.addVertex('J');
	articulTest.addVertex('K');
	articulTest.addVertex('L');
	articulTest.addVertex('M');
	
	articulTest.addArc('A', 'B');
	articulTest.addArc('A', 'C');
	articulTest.addArc('A', 'F');
	articulTest.addArc('A', 'L');
	articulTest.addArc('C', 'B');
	articulTest.addArc('D', 'B');
	articulTest.addArc('G', 'B');
	articulTest.addArc('H', 'B');
	articulTest.addArc('M', 'B');
	articulTest.addArc('D', 'E');
	articulTest.addArc('G', 'H');
	articulTest.addArc('G', 'I');
	articulTest.addArc('G', 'K');
	articulTest.addArc('H', 'K');
	articulTest.addArc('J', 'L');
	articulTest.addArc('J', 'M');
	articulTest.addArc('L', 'M');
	
	articulTest.findArticul();
	
	/*
	 有向无环图及其应用
	
	 有向无环图(Directed Acycling Graph)：是图中没有回路(环)的有向图。是一类具有代表性的图，主要用于研究工程项目的工序问题、工程时间进度问题等。
	
	 一个工程(project)都可分为若干个称为活动(active)的子工程(或工序)，各个子工程受到一定的条件约束：某个子工程必须开始于另一个子工程完成之后；整个工程有一个开始点(起点)和一个终点。人们关心：
	 ◆ 工程能否顺利完成?影响工程的关键活动是什么?
	 ◆ 估算整个工程完成所必须的最短时间是多少?
	
	 对工程的活动加以抽象：图中顶点表示活动，有向边表示活动之间的优先关系，这样的有向图称为顶点表示活动的网(Activity On Vertex Network ，AOV网) 。
	
	
	 拓扑排序
	
	 1 定义
	 拓扑排序(Topological Sort) ：由某个集合上的一个偏序得到该集合上的一个全序的操作。
	
	 ◆ 集合上的关系：集合A上的关系是从A到A的关系(AA) 。
	 ◆ 关系的自反性：若a∈A有(a，a)∈R，称集合A上的关系R是自反的。
	 ◆ 关系的对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。
	 ◆ 关系的对称性与反对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。如果对于a，b∈A ，仅当a=b时有(a，b)∈R和(b，a)∈R ，称集合A上的关系R是反对称的。
	 ◆ 关系的传递性：若a，b，c∈A，若(a，b)∈R，并且(b，c)∈R ，则(a，c)∈R ，称集合A上的关系R是传递的。
	 ◆ 偏序：若集合A上的关系R是自反的，反对称的和传递的，则称R是集合A上的偏序关系。
	 ◆ 全序：设R是集合A上的偏序关系，a，b∈A，必有aRb或bRa， 则称R是集合A上的全序关系。
	
	 即偏序是指集合中仅有部分元素之间可以比较，而全序是指集合中任意两个元素之间都可以比较。
	 在AOV网中，若有有向边<i, j>，则i是j的直接前驱，j是i的直接后继；推而广之，若从顶点i到顶点j有有向路径，则i是j的前驱，j是i的后继。
	 在AOV网中，不能有环，否则，某项活动能否进行是以自身的完成作为前提条件。
	 检查方法：对有向图的顶点进行拓扑排序，若所有顶点都在其拓扑有序序列中，则无环。
	 有向图的拓扑排序：构造AOV网中顶点的一个拓扑线性序列(v’1,v’2, ⋯,v’n)，使得该线性序列不仅保持原来有向图中顶点之间的优先关系，而且对原图中没有优先关系的顶点之间也建立一种(人为的)优先关系。
	
	 2 拓扑排序算法
	 算法思想
	
	 ① 在AOV网中选择一个没有前驱的顶点且输出；
	 ② 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧)所有有向弧(边) ；
	 ③ 重复①、②，直到图中全部顶点都已输出(图中无环)或图中不存在无前驱的顶点(图中必有环)。
	
	 3  算法实现说明
	 ◆ 采用正邻接链作为AOV网的存储结构；
	 ◆ 设立堆栈，用来暂存入度为0的顶点；
	 ◆ 删除顶点以它为尾的弧：弧头顶点的入度减1。
	
	 整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var topologicTest = new AdjacencyListGraph([], 0, 0, DG);
	topologicTest.addVertex('v1');
	topologicTest.addVertex('v2');
	topologicTest.addVertex('v3');
	topologicTest.addVertex('v4');
	topologicTest.addVertex('v5');
	topologicTest.addVertex('v6');
	
	topologicTest.addArc('v2', 'v1');
	topologicTest.addArc('v4', 'v1');
	topologicTest.addArc('v3', 'v1');
	topologicTest.addArc('v2', 'v3');
	topologicTest.addArc('v5', 'v3');
	topologicTest.addArc('v4', 'v6');
	topologicTest.addArc('v5', 'v4');
	topologicTest.addArc('v5', 'v6');
	
	console.log('topologicSort: ');
	console.log(topologicTest.topologicSort());
	
	/*
	 关键路径(Critical Path)
	
	 与AOV网相对应的是AOE(Activity On Edge) ，是边表示活动的有向无环图，如图7-24所示。图中顶点表示事件(Event)，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的时间或费用。
	
	 1 与AOE有关的研究问题
	 ◆ 完成整个工程至少需要多少时间?
	 ◆ 哪些活动是影响工程进度(费用)的关键?
	 工程完成最短时间：从起点到终点的最长路径长度(路径上各活动持续时间之和) 。长度最长的路径称为关键路径，关键路径上的活动称为关键活动。关键活动是影响整个工程的关键。
	 设v0是起点，从v0到vi的最长路径长度称为事件vi的最早发生时间，即是以vi为尾的所有活动的最早发生时间。
	 若活动ai是弧<j, k>，持续时间是dut(<j, k>)，设：
	 ◆ e(i)：表示活动ai的最早开始时间；
	 ◆ l(i)：在不影响进度的前提下，表示活动ai的最晚开始时间； 则l(i)-e(i)表示活动ai的时间余量，若l(i)-e(i)=0，表示活动ai是关键活动。
	 ◆ ve(i)：表示事件vi的最早发生时间，即从起点到顶点vi的最长路径长度；
	 ◆ vl(i)：表示事件vi的最晚发生时间。则有以下关系：
	 e(i)=ve(j)
	 l(i)= vl(k)-dut(<j, k>)
	 0    j=0，表示vj是起点
	 ve(j)=
	 Max{ve(i)+dut(<i, j>)|<vi, vj>是网中的弧}
	
	 含义是：源点事件的最早发生时间设为0；除源点外，只有进入顶点vj的所有弧所代表的活动全部结束后，事件vj才能发生。即只有vj的所有前驱事件vi的最早发生时间ve(i)计算出来后，才能计算ve(j) 。
	 方法是：对所有事件进行拓扑排序，然后依次按拓扑顺序计算每个事件的最早发生时间。
	 ve(n-1)    j=n-1，表示vj是终点
	 vl(j)=
	 Min{vl(k)-dut(<j, k>)|<vj, vk>是网中的弧}
	 含义是：只有vj的所有后继事件vk的最晚发生时间vl(k)计算出来后，才能计算vl(j) 。
	 方法是：按拓扑排序的逆顺序，依次计算每个事件的最晚发生时间。
	
	
	 2 求AOE中关键路径和关键活动
	 ⑴ 算法思想
	 ① 利用拓扑排序求出AOE网的一个拓扑序列；
	 ②  从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个事件的最早发生时间ve(i) ；
	 ③  从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；
	
	 设AOE网有n个事件，e个活动，则算法的主要执行是：
	 ◆ 进行拓扑排序：时间复杂度是O(n+e) ；
	 ◆ 求每个事件的ve值和vl值：时间复杂度是O(n+e) ；
	 ◆ 根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；
	 因此，整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var criticalPathTest = new AdjacencyListGraph([], 0, 0, DG);
	criticalPathTest.addVertex('v0');
	criticalPathTest.addVertex('v1');
	criticalPathTest.addVertex('v2');
	criticalPathTest.addVertex('v3');
	criticalPathTest.addVertex('v4');
	criticalPathTest.addVertex('v5');
	criticalPathTest.addVertex('v6');
	criticalPathTest.addVertex('v7');
	criticalPathTest.addVertex('v8');
	
	criticalPathTest.addArc('v1', 'v0', 3);
	criticalPathTest.addArc('v2', 'v0', 10);
	criticalPathTest.addArc('v4', 'v1', 13);
	criticalPathTest.addArc('v4', 'v2', 12);
	criticalPathTest.addArc('v3', 'v1', 9);
	criticalPathTest.addArc('v5', 'v2', 7);
	criticalPathTest.addArc('v7', 'v4', 6);
	criticalPathTest.addArc('v7', 'v3', 4);
	criticalPathTest.addArc('v7', 'v5', 11);
	criticalPathTest.addArc('v6', 'v3', 8);
	criticalPathTest.addArc('v8', 'v7', 5);
	criticalPathTest.addArc('v8', 'v6', 2);
	
	criticalPathTest.criticalPath();
	
	var dijTest = new AdjacencyListGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('1', '0', 20);
	dijTest.addArc('4', '0', 10);
	dijTest.addArc('2', '0', 60);
	dijTest.addArc('5', '0', 65);
	dijTest.addArc('2', '1', 30);
	dijTest.addArc('3', '2', 40);
	dijTest.addArc('2', '5', 15);
	dijTest.addArc('5', '4', 20);
	dijTest.addArc('4', '3', 35);
	dijTest.addArc('3', '1', 70);
	
	dijTest.shortestPath_Dijkstra(0);
	
	(function () {
	    /**
	     * 输出有向无环图形式表示的逆波兰式
	     */
	    function niBoLan_DAG(graph) {
	        graph.countIndegree();
	        for (var _i20 = 0; _i20 < graph.vexnum; ++_i20) {
	            // 找到有向无环图的根
	            if (graph.vertices[_i20].indegree === 0) {
	                printNiBoLan(graph, _i20);
	                break;
	            }
	        }
	
	        return false;
	    }
	
	    function printNiBoLan(graph, i) {
	        var c = graph.vertices[i].data;
	        var p = graph.vertices[i].firstArc;
	
	        // 子表达式
	        if (p) {
	            printNiBoLan(graph, p.adjVex);
	            printNiBoLan(graph, p.nextArc.adjVex);
	        }
	
	        console.log(c + '');
	    }
	
	    /**
	     * 给有向无环图表示的表达式求值
	     */
	    function evaluate_DAG(graph) {
	        graph.countIndegree();
	        for (var _i21 = 0; _i21 < graph.vexnum; ++_i21) {
	            if (!graph.vertices[_i21].indegree) return evaluate_imp(graph, _i21);
	        }
	    }
	
	    function evaluate_imp(g, i) {
	        if (/^\d+$/.test(g.vertices[i].data)) return g.vertices[i].data;else {
	            var p = g.vertices[i].firstArc;
	            var v1 = evaluate_imp(g, p.adjVex);
	            var v2 = evaluate_imp(g, p.nextArc.adjVex);
	            return calculate(v1, g.vertices[i].data, v2);
	        }
	    }
	
	    function calculate(a, operation, b) {
	        // 偷一下懒..
	        return eval(a + operation + b);
	    }
	
	    // ((1 + 2) * (2 * (3 + 4)) + (3 + 4) * 5) * ((3 + 4) * 5)
	    var dag = new AdjacencyListGraph([], 0, 0, DG);
	
	    var a1 = new String('*');
	    var a2 = new String('+');
	    var a3 = new String('*');
	    var a4 = new String('*');
	    var a5 = new String('+');
	    var a6 = new String('*');
	    var a7 = new String('+');
	
	    // 12
	    dag.addVertex(a1);
	    dag.addVertex(a2);
	    dag.addVertex(a3);
	    dag.addVertex(a4);
	    dag.addVertex(a5);
	    dag.addVertex(a6);
	    dag.addVertex(a7);
	    dag.addVertex(1);
	    dag.addVertex(2);
	    dag.addVertex(3);
	    dag.addVertex(4);
	    dag.addVertex(5);
	
	    // 14
	    dag.addArc(a2, a1);
	    dag.addArc(a4, a1);
	    dag.addArc(a3, a2);
	    dag.addArc(a4, a2);
	    dag.addArc(a5, a3);
	    dag.addArc(a6, a3);
	    dag.addArc(a7, a6);
	    dag.addArc(a7, a4);
	    dag.addArc(5, a4);
	    dag.addArc(1, a5);
	    dag.addArc(2, a5);
	    dag.addArc(2, a6);
	    dag.addArc(3, a7);
	    dag.addArc(4, a7);
	
	    console.log('niBoLan_DAG: ');
	    niBoLan_DAG(dag);
	    console.log('evaluate_DAG: ' + evaluate_DAG(dag)); // 2695
	})();

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(19);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(13);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(18);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* create by Luke */
	/**
	 * 图(Graph)
	 *
	 * 图(Graph)是一种比线性表和树更为复杂的数据结构。
	 *
	 * 线性结构：是研究数据元素之间的一对一关系。在这种结构中，除第一个和最后一个元素外，任何一个元素都有唯一的一个直接前驱和直接后继。
	 *
	 * 树结构：是研究数据元素之间的一对多的关系。在这种结构中，每个元素对下(层)可以有0个或多个元素相联系，对上(层)只有唯一的一个元素相关，数据元素之间有明显的层次关系。
	 *
	 * 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。
	 *
	 * 图的应用极为广泛，已渗入到诸如语言学、逻辑学、物理、化学、电讯、计算机科学以及数学的其它分支。
	 *
	 * 图的基本概念
	 *
	 * 一个图(G)定义为一个偶对(V,E) ，记为G=(V,E) 。其中： V是顶点(Vertex)的非空有限集合，记为V(G)；E是无序集V&V的一个子集，记为E(G) ，其元素是图的弧(Arc)。
	 * 将顶点集合为空的图称为空图。其形式化定义为：
	 G=(V ，E)
	 V={v|v∈data object}
	 E={<v,w>| v,w∈V∧p(v,w)}
	 P(v,w)表示从顶点v到顶点w有一条直接通路。
	 *
	 * 弧(Arc) ：表示两个顶点v和w之间存在一个关系，用顶点偶对<v,w>表示。通常根据图的顶点偶对将图分为有向图和无向图。
	 * 有向图(Digraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是有序的，称图G是有向图。
	 *   在有向图中，若 <v,w>∈E(G) ，表示从顶点v到顶点w有一条弧。 其中：v称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) 。
	 * 无向图(Undigraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是无序的，称图G是无向图。
	 *   在无向图中，若<v,w>∈E(G) ，有<w,v>∈E(G) ，即E(G)是对称，则用无序对(v,w) 表示v和w之间的一条边(Edge)，因此(v,w) 和(w,v)代表的是同一条边。
	 *
	 * 例1：设有有向图G1和无向图G2，形式化定义分别是：
	 G1=(V1 ，E1)
	 V1={a,b,c,d,e}
	 E1={<a,b>,<a,c>, <a,e>,<c,d>,<c,e> ,<d,a>,<d,b>,<e,d>}
	 G2=(V2 ，E2)
	 V2={a,b,c,d}
	 E2={(a,b), (a,c), (a,d), (b,d), (b,c), (c,d)}
	 *
	 * 完全无向图：对于无向图，若图中顶点数为n ，用e表示边的数目，则e ∈[0，n(n-1)/2] 。具有n(n-1)/2条边的无向图称为完全无向图。
	 完全无向图另外的定义是：
	 * 对于无向图G=(V，E)，若vi，vj ∈V ，当vi≠vj时，有(vi ,vj)∈E，即图中任意两个不同的顶点间都有一条无向边，这样的无向图称为完全无向图。
	 *
	 * 完全有向图：对于有向图，若图中顶点数为n ，用e表示弧的数目，则e∈[0，n(n-1)] 。具有n(n-1)条边的有向图称为完全有向图。
	 完全有向图另外的定义是：
	 * 对于有向图G=(V，E)，若vi，vj∈V ，当vi ≠vj时，有<vi ,vj>∈E∧<vj , vi >∈E ，即图中任意两个不同的顶点间都有一条弧，这样的有向图称为完全有向图。
	 *
	 * 有很少边或弧的图（e<n㏒n）的图称为稀疏图，反之称为稠密图。
	 * 权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。
	 *
	 * 子图和生成子图：设有图G=(V，E)和G’=(V’，E’)，若V’∈V且E’∈E ，则称图G’是G的子图；若V’=V且E’∈E，则称图G’是G的一个生成子图。
	 * 顶点的邻接(Adjacent)：对于无向图G=(V，E)，若边(v,w)∈E，则称顶点v和w 互为邻接点，即v和w相邻接。边(v,w)依附(incident)与顶点v和w 。
	 * 对于有向图G=(V ，E)，若有向弧<v,w>∈E，则称顶点v “邻接到”顶点w，顶点w “邻接自”顶点v ，弧<v,w> 与顶点v和w “相关联” 。
	 *
	 * 顶点的度、入度、出度：对于无向图G=(V，E)， vi∈V，图G中依附于vi的边的数目称为顶点vi的度(degree)，记为TD(vi)。
	 显然，在无向图中，所有顶点度的和是图中边的2倍。 即   ∑TD(vi)=2e      i=1, 2, …, n ，e为图的边数。
	 对有向图G=(V，E)，若vi ∈V ，图G中以vi作为起点的有向边(弧)的数目称为顶点vi的出度(Outdegree)，记为OD(vi) ；以vi作为终点的有向边(弧)的数目称为顶点vi的入度(Indegree)，记为ID(vi) 。顶点vi的出度与入度之和称为vi的度，记为TD(vi) 。即
	 TD(vi)=OD(vi)+ID(vi)
	 *
	 * 路径(Path)、路径长度、回路(Cycle) ：对无向图G=(V，E)，若从顶点vi经过若干条边能到达vj，称顶点vi和vj是连通的，又称顶点vi到vj有路径。
	 对有向图G=(V，E)，从顶点vi到vj有有向路径，指的是从顶点vi经过若干条有向边(弧)能到达vj。
	 或路径是图G中连接两顶点之间所经过的顶点序列。即
	 Path=vi0vi1…vim ，vij∈V且(vij-1, vij)∈E   j=1,2, …,m
	 或
	 Path=vi0vi1 …vim ，vij∈V且<vij-1, vij>∈E  j=1,2, …,m
	 路径上边或有向边(弧)的数目称为该路径的长度。
	 在一条路径中，若没有重复相同的顶点，该路径称为简单路径；第一个顶点和最后一个顶点相同的路径称为回路(环)；在一个回路中，若除第一个与最后一个顶点外，其余顶点不重复出现的回路称为简单回路(简单环)。
	 *
	 * 连通图、图的连通分量：对无向图G=(V，E)，若vi ，vj ∈V，vi和vj都是连通的，则称图G是连通图，否则称为非连通图。若G是非连通图，则极大的连通子图称为G的连通分量。
	 对有向图G=(V，E)，若vi ，vj ∈V，都有以vi为起点， vj 为终点以及以vj为起点，vi为终点的有向路径，称图G是强连通图，否则称为非强连通图。若G是非强连通图，则极大的强连通子图称为G的强连通分量。
	 “极大”的含义：指的是对子图再增加图G中的其它顶点，子图就不再连通。
	 生成树、生成森林：一个连通图(无向图)的生成树是一个极小连通子图，它含有图中全部n个顶点和只有足以构成一棵树的n-1条边，称为图的生成树。
	 关于无向图的生成树的几个结论：
	 ◆ 一棵有n个顶点的生成树有且仅有n-1条边；
	 ◆ 如果一个图有n个顶点和小于n-1条边，则是非连通图；
	 ◆ 如果多于n-1条边，则一定有环；
	 ◆ 有n-1条边的图不一定是生成树。
	
	 有向图的生成森林是这样一个子图，由若干棵有向树组成，含有图中全部顶点。
	 有向树是只有一个顶点的入度为0 ，其余顶点的入度均为1的有向图。
	
	 *
	 * 网：每个边(或弧)都附加一个权值的图，称为带权图。带权的连通图(包括弱连通的有向图)称为网或网络。网络是工程上常用的一个概念，用来表示一个工程或某种流程
	 */
	
	/**
	 * 图的存储结构
	 *
	 图的存储结构比较复杂，其复杂性主要表现在：
	 ◆ 任意顶点之间可能存在联系，无法以数据元素在存储区中的物理位置来表示元素之间的关系。
	 ◆ 图中顶点的度不一样，有的可能相差很大，若按度数最大的顶点设计结构，则会浪费很多存储单元，反之按每个顶点自己的度设计不同的结构，又会影响操作。
	 图的常用的存储结构有：邻接矩阵、邻接链表、十字链表、邻接多重表和边表。
	 */
	
	/*
	 邻接矩阵(数组)表示法
	
	 基本思想：对于有n个顶点的图，用一维数组vexs[n]存储顶点信息，用二维数组A[n][n]存储顶点之间关系的信息。该二维数组称为邻接矩阵。在邻接矩阵中，以顶点在vexs数组中的下标代表顶点，邻接矩阵中的元素A[i][j]存放的是顶点i到顶点j之间关系的信息。
	
	 1  无向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 无向无权图G=(V，E)有n(n≧1)个顶点，其邻接矩阵是n阶对称方阵。其元素的定义如下：
	            -- 1   若(vi , vj)∈E，即vi , vj邻接
	 A[i][j]=
	             -- 0   若(vi , vj)∉E，即vi , vj不邻接
	
	 (2)  带权图的邻接矩阵
	 无向带权图G=(V，E) 的邻接矩阵。其元素的定义如下：
	            -- Wij    若(vi , vj)∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	
	            -- ∞   若(vi , vj)∉E，即vi , vj不邻接时
	
	 (3)  无向图邻接矩阵的特性
	 ◆ 邻接矩阵是对称方阵
	 ◆ 对于顶点vi，其度数是第i行的非0元素的个数；
	 ◆ 无向图的边数是上(或下)三角形矩阵中非0元素个数。
	
	 2  有向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 若有向无权图G=(V，E)有n(n≧1)个顶点，则其邻接矩阵是n阶对称方阵。元素定义如下：
	            -- 1   若<vi, vj>∈E，从vi到vj有弧
	 A[i][j]=
	            -- 0   若<vi , vj>∉E  从vi到vj 没有弧
	
	 (2)  带权图的邻接矩阵
	 有向带权图G=(V，E)的邻接矩阵。其元素的定义如下：
	            -- wij    若<vi,vj>∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	            ∞   若<vi,vj>∉E，即vi , vj不邻接时
	
	 ⑶ 有向图邻接矩阵的特性
	 ◆ 对于顶点vi，第i行的非0元素的个数是其出度OD(vi)；第i列的非0元素的个数是其入度ID(vi) 。
	 ◆ 邻接矩阵中非0元素的个数就是图的弧的数目。
	
	 3  图的邻接矩阵的操作
	
	 图的邻接矩阵的实现比较容易，定义两个数组分别存储顶点信息(数据元素)和边或弧的信息(数据元素之间的关系) 。
	
	 */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	var ArcCell =
	/**
	 *
	 * @param {Number} adj
	 * @param {*} info
	 * @constructor
	 */
	function ArcCell(adj) {
	    var info = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ArcCell);
	
	    // 顶点类型。对于无权图，用1或0表示相邻否；对带权图，则为权值类型
	    this.adj = typeof adj === 'number' ? adj : Infinity;
	    // 该弧相关信息
	    this.info = info;
	};
	
	var AdjacencyMatrixGraph = function () {
	    /**
	     *
	     * @param {Array} vexs 顶点向量
	     * @param {Array | ArcCell} arcs 邻接矩阵
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	
	    function AdjacencyMatrixGraph() {
	        var vexs = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var arcs = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	        var vexnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var arcnum = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	        var kind = arguments.length <= 4 || arguments[4] === undefined ? DG : arguments[4];
	        (0, _classCallCheck3.default)(this, AdjacencyMatrixGraph);
	
	        // 顶点向量
	        this.vexs = vexs;
	        // 邻接矩阵
	        this.arcs = arcs;
	        // 图的当前顶点数
	        this.vexnum = vexnum;
	        // 图的当前弧数
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    (0, _createClass3.default)(AdjacencyMatrixGraph, [{
	        key: 'createGraph',
	        value: function createGraph() {
	            switch (this.kind) {
	                case DG:
	                    return createDG(this); // 构造有向图
	                case DN:
	                    return createDN(this); // 构造有向网
	                case UDG:
	                    return createUDG(this); // 构造无向图
	                case UDN:
	                    return createUDN(this); // 构造无向网
	                default:
	                    throw new Error('非有效的图类型');
	            }
	        }
	
	        /**
	         * 查找顶点
	         * @param {*} vp 顶点向量
	         * @returns {number}
	         */
	
	    }, {
	        key: 'locateVex',
	        value: function locateVex(vp) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.vexs[i] === vp) return i;
	            }
	
	            return -1;
	        }
	
	        /**
	         * 向图中增加顶点
	         * @param {*} vp 顶点向量
	         */
	
	    }, {
	        key: 'addVertex',
	        value: function addVertex(vp) {
	            if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	            var k = this.vexnum;
	            this.vexs[this.vexnum++] = vp;
	
	            var value = this.kind === DG || this.kind === UDG ? 0 : Infinity;
	            for (var j = 0; j < this.vexnum; ++j) {
	                this.arcs[j] = this.arcs[j] || [];
	                this.arcs[k] = this.arcs[k] || [];
	                this.arcs[j][k] = this.arcs[j][k] || new ArcCell();
	                this.arcs[k][j] = this.arcs[k][j] || new ArcCell();
	                this.arcs[j][k].adj = this.arcs[k][j].adj = value;
	            }
	        }
	
	        /**
	         * 向图中增加一条弧
	         * @param {*} vex1 顶点1向量
	         * @param {*} vex2 顶点2向量
	         * @param {ArcCell} arc
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'addArc',
	        value: function addArc(vex1, vex2, arc) {
	            arc = arc || new ArcCell(this.kind === DG || this.kind === UDG ? 1 : 'weight');
	            var k = this.locateVex(vex1);
	            var j = this.locateVex(vex2);
	
	            if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	            this.arcs[k][j].adj = arc.adj;
	            this.arcs[k][j].info = arc.info;
	            // 无向图或无向网
	            if (this.kind === UDG || this.kind === UDN) {
	                this.arcs[j][k].adj = arc.adj;
	                this.arcs[j][k].info = arc.info;
	            }
	
	            ++this.arcnum;
	
	            return true;
	        }
	
	        /**
	         * 删除顶点
	         * @param {String} vex 要删除的顶点
	         */
	
	    }, {
	        key: 'deleteVex',
	        value: function deleteVex(vex) {
	            var n = this.vexnum - 1;
	            var m = this.locateVex(vex);
	
	            if (m < 0) return false;
	
	            // 将待删除顶点交换到最后一个顶点
	            var temp = this.vexs[m];
	            this.vexs[m] = this.vexs[n];
	            this.vexs[n] = temp;
	
	            // 将边的关系随之交换
	            for (var i = 0; i <= n; ++i) {
	                this.arcs[i][m] = this.arcs[i][n];
	                this.arcs[m][i] = this.arcs[n][i];
	            }
	
	            this.arcs[m][m].adj = 0;
	            this.vexs.length = --this.vexnum;
	            return true;
	        }
	
	        /**
	         * 删除边(v, w)
	         * @param {String} v
	         * @param {String} w
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'deleteArc',
	        value: function deleteArc(v, w) {
	            var i = this.locateVex(v);
	            var j = this.locateVex(w);
	
	            if (i < 0 || j < 0) return false;
	
	            if (this.arcs[i][j].adj) {
	                this.arcs[i][j].adj = 0;
	                this.arcnum--;
	            }
	
	            return true;
	        }
	
	        // 判断一个邻接矩阵存储的有向图是否可传递
	
	    }, {
	        key: 'isPass',
	        value: function isPass() {
	            if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	            for (var x = 0; x < this.vexnum; ++x) {
	                for (var y = 0; y < this.vexnum; ++y) {
	                    if (this.arcs[x][y]) {
	                        for (var z = 0; z < this.vexnum; ++z) {
	                            if (z !== x && this.arcs[y][z] && !this.arcs[x][z]) return false;
	                        }
	                    }
	                }
	            }
	
	            return true;
	        }
	    }, {
	        key: 'firstAdjVex',
	        value: function firstAdjVex(v) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	            }
	
	            return -1;
	        }
	    }, {
	        key: 'nextAdjVex',
	        value: function nextAdjVex(v, w) {
	            for (var i = w + 1; i < this.vexnum; ++i) {
	                if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	            }
	
	            return -1;
	        }
	
	        // 对邻接矩阵图作递归式深度优先遍历
	
	    }, {
	        key: 'DFSTraverse',
	        value: function DFSTraverse(visitFn) {
	            var visited = [];
	            // 访问标志数组初始化
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i = 0; _i < this.vexnum; ++_i) {
	                if (!visited[_i]) dfs(this, _i);
	            }
	
	            function dfs(graph, vertex) {
	                visited[vertex] = true;
	                visitFn.call(graph, vertex);
	
	                for (var j = 0; j < graph.vexnum; ++j) {
	                    if (graph.arcs[vertex][j].adj !== 0 && graph.arcs[vertex][j].adj !== Infinity && !visited[j]) dfs(graph, j);
	                }
	            }
	        }
	
	        // 非递归
	
	    }, {
	        key: 'DFSTraverse_NonRecurse',
	        value: function DFSTraverse_NonRecurse(visitFn) {
	            var visited = [];
	            var stack = new _index2.default();
	            var me = this;
	            // 访问标志数组初始化
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i2 = 0; _i2 < this.vexnum; ++_i2) {
	                if (!visited[_i2]) {
	                    stack.push(_i2);
	                    visited[_i2] = true;
	                    visitFn.call(me, _i2);
	
	                    var vertex = void 0;
	                    while ((vertex = stack.peek()) != null) {
	                        for (var j = 0; j < this.vexnum; ++j) {
	                            if (this.arcs[vertex][j].adj !== 0 && this.arcs[vertex][j].adj !== Infinity && !visited[j]) {
	                                visitFn.call(me, j);
	                                visited[j] = true;
	                                stack.push(j);
	                            } else stack.pop();
	                        }
	                    }
	                }
	            }
	        }
	
	        // 对邻接矩阵图作广度优先遍历
	
	    }, {
	        key: 'BFSTraverse',
	        value: function BFSTraverse(visitFn) {
	            var visited = [];
	            var queue = new _Queue2.default();
	
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i3 = 0; _i3 < this.vexnum; ++_i3) {
	                if (!visited[_i3]) {
	                    visited[_i3] = true;
	                    visitFn.call(this, _i3);
	                    queue.enQueue(_i3);
	
	                    while (queue.rear) {
	                        var u = queue.deQueue();
	
	                        for (var j = 0; j < this.vexnum; ++j) {
	                            if (this.arcs[u][j].adj !== 0 && this.arcs[u][j].adj !== Infinity && !visited[j]) {
	                                visited[j] = true;
	                                visitFn.call(this, j);
	                                queue.enQueue(j);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'minSpanTree_PRIM',
	        value: function minSpanTree_PRIM(u) {
	            var closedge = [];
	
	            // 初始化
	            for (var j = 0; j < this.vexnum; ++j) {
	                closedge[j] = { adjvex: u, lowcost: +this.arcs[j][u].adj };
	            }
	            closedge[u].lowcost = 0;
	
	            var te = [];
	            // 选择其余this.vexnum - 1个顶点
	            for (var _j = 0; _j < this.vexnum - 1; ++_j) {
	                var min = Infinity;
	                var k = void 0;
	                for (var v = 0; v < this.vexnum; ++v) {
	                    if (closedge[v].lowcost !== 0 && closedge[v].lowcost < min) {
	                        min = closedge[v].lowcost;
	                        k = v;
	                    }
	                }
	
	                te[_j] = {
	                    vex1: closedge[k].adjvex,
	                    vex2: k,
	                    weight: closedge[k].lowcost
	                };
	                closedge[k].lowcost = 0;
	                for (var _v = 0; _v < this.vexnum; ++_v) {
	                    if (this.arcs[_v][k].adj < closedge[_v].lowcost) {
	                        closedge[_v].lowcost = this.arcs[_v][k].adj;
	                        closedge[_v].adjvex = k;
	                    }
	                }
	            }
	
	            return te;
	        }
	    }, {
	        key: 'minSpanTree_Kruskal',
	        value: function minSpanTree_Kruskal() {
	            var set = [];
	            var te = [];
	
	            for (var i = 0; i < this.vexnum; ++i) {
	                set[i] = i;
	            }var k = 0;
	            var min = Infinity;
	            var a = 0;
	            var b = 0;
	            while (k < this.vexnum - 1) {
	                for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                    for (var j = _i4 + 1; j < this.vexnum; ++j) {
	                        if (this.arcs[_i4][j].adj < min) {
	                            min = this.arcs[_i4][j].adj;
	                            a = _i4;
	                            b = j;
	                        }
	                    }
	                }
	
	                if (set[a] !== set[b]) {
	                    te[k++] = {
	                        vex1: a,
	                        vex2: b,
	                        weight: this.arcs[a][b].adj
	                    };
	
	                    for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                        if (set[_i5] === set[b] && _i5 !== b) set[_i5] = set[a];
	                    }
	                    set[b] = set[a];
	                }
	
	                min = this.arcs[a][b].adj = Infinity;
	            }
	
	            return te;
	        }
	
	        /**
	         * 用Dijkstra算法求有向网的v0顶点到其余顶点v的最短路径pre[v]及其带权长度dist[v]。
	         * 若pre[v][w]为true，则w是从v0到v当前求得最短路径上的顶点。
	         * final[v]为true当且仅当v∈S，即已经求得v0到v的最短路径
	         * @param v0
	         */
	
	    }, {
	        key: 'shortestPath_Dijkstra',
	        value: function shortestPath_Dijkstra(v0) {
	            var pre = [];
	            var dist = [];
	            var final = [];
	            var w = void 0,
	                v = void 0;
	
	            for (var _v2 = 0; _v2 < this.vexnum; ++_v2) {
	                final[_v2] = false;
	                dist[_v2] = this.arcs[v0][_v2].adj;
	                pre[_v2] = pre[_v2] || [];
	                // 设空路径
	                for (w = 0; w < this.vexnum; ++w) {
	                    pre[_v2][w] = false;
	                }if (dist[_v2] < Infinity) {
	                    pre[_v2][v0] = true;
	                    pre[_v2][_v2] = true;
	                }
	            }
	
	            // 初始化，v0顶点属于S集
	            dist[v0] = 0;
	            final[v0] = true;
	
	            // 开始主循环，每次求得v0到某个v顶点的最短路径，并加v到S集
	
	            // 其余的顶点
	            for (var i = 1; i < this.vexnum; ++i) {
	                var min = Infinity;
	                // 当前所指离v0顶点的最近距离
	                for (w = 0; w < this.vexnum; ++w) {
	                    // w顶点在V - S中
	                    // 且w顶点离v0顶点更近
	                    if (!final[w] && dist[w] < min) {
	                        v = w;
	                        min = dist[w];
	                    }
	                }
	
	                // 离v0顶点最近的v加入S集
	                final[v] = true;
	                // 更新当前最短路径及距离
	                for (w = 0; w < this.vexnum; ++w) {
	                    if (!final[w] && min + this.arcs[v][w].adj < dist[w]) {
	                        dist[w] = min + this.arcs[v][w].adj;
	                        pre[w] = pre[v];
	                        pre[w][w] = true;
	                    }
	                }
	            }
	
	            console.log(final);
	            console.log(pre);
	            console.log(dist);
	
	            return {
	                final: final,
	                pre: pre,
	                dist: dist
	            };
	        }
	    }, {
	        key: 'shortestPath_FLOYD',
	        value: function shortestPath_FLOYD() {
	            var a = [];
	            var path = [];
	
	            for (var j = 0; j < this.vexnum; ++j) {
	                a[j] = a[j] || [];
	                path[j] = path[j] || [];
	                for (var k = 0; k < this.vexnum; ++k) {
	                    if (j === k) a[j][k] = 0;else a[j][k] = this.arcs[j][k].adj;
	                    path[j][k] = -1;
	                }
	            }
	
	            for (var m = 0; m < this.vexnum; ++m) {
	                for (var _j2 = 0; _j2 < this.vexnum; ++_j2) {
	                    for (var _k = 0; _k < this.vexnum; ++_k) {
	                        if (a[_j2][m] + a[m][_k] < a[_j2][_k]) {
	                            a[_j2][_k] = a[_j2][m] + a[m][_k];
	                            path[_j2][_k] = m;
	                        }
	                    }
	                }
	            }
	
	            for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	                for (var _k2 = 0; _k2 < this.vexnum; ++_k2) {
	                    if (_j3 !== _k2) {
	                        console.log('%d到%d的最短路径为：', _j3, _k2);
	                        console.log('%d ', _j3);prn_pass(_j3, _k2);
	                        console.log('%d ', _k2);
	                        console.log('最短路径长度为： %d', a[_j3][_k2]);
	                    }
	                }
	            }
	
	            function prn_pass(j, k) {
	                if (path[j][k] !== -1) {
	                    prn_pass(j, path[j][k]);
	                    console.log(', %d', path[j][k]);
	                    prn_pass(path[j][k], k);
	                }
	            }
	        }
	    }]);
	    return AdjacencyMatrixGraph;
	}();
	
	exports.default = AdjacencyMatrixGraph;
	
	
	var createDG = createGraph(DG);
	var createDN = createGraph(DN);
	var createUDG = createGraph(UDG);
	var createUDN = createGraph(UDN);
	
	function createGraph(kind) {
	    var adj = void 0;
	    var setMatrixValue = void 0;
	
	    if (kind === 2 || kind === 4) {
	        adj = Infinity;
	        setMatrixValue = function setMatrixValue() {
	            return prompt('weight: ');
	        };
	    } else {
	        adj = 0;
	        setMatrixValue = function setMatrixValue() {
	            return 1;
	        };
	    }
	
	    return function (AdjacencyMatrixGraph) {
	        AdjacencyMatrixGraph.vexnum = parseInt(prompt('vexnum: '), 10);
	        AdjacencyMatrixGraph.arcnum = parseInt(prompt('arcnum: '), 10);
	        // incInfo为0则各弧不含其他信息
	        var incInfo = parseInt(prompt('incInfo: '), 10);
	
	        // 构造顶点向量
	        var i = void 0,
	            j = void 0;
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            AdjacencyMatrixGraph.vexs[i] = prompt('顶点向量vex: ');
	        } // 初始化邻接矩阵
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            for (j = 0; j < AdjacencyMatrixGraph.vexnum; ++j) {
	                AdjacencyMatrixGraph.arcs[i] = AdjacencyMatrixGraph.arcs[i] || [];
	                AdjacencyMatrixGraph.arcs[i][j] = new ArcCell(adj, null);
	            }
	        }
	
	        // 构造邻接矩阵
	        for (var k = 0; k < AdjacencyMatrixGraph.arcnum; ++k) {
	            // 输入一条边依附的顶点及权值
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            // 确定v1，v2在G中的位置
	            i = AdjacencyMatrixGraph.locateVex(v1);
	            j = AdjacencyMatrixGraph.locateVex(v2);
	
	            var w = setMatrixValue();
	            // 弧<v1, v2>的权值
	            AdjacencyMatrixGraph.arcs[i][j].adj = w;
	            if (incInfo) AdjacencyMatrixGraph.arcs[i][j].info = prompt('info: ');
	            if (kind === 3 || kind === 4) AdjacencyMatrixGraph.arcs[j][i] = AdjacencyMatrixGraph.arcs[i][j];
	        }
	    };
	}
	
	// 第一种创建图方法
	var vexs = ['a', 'b', 'c', 'd', 'e'];
	var arcs = [[{ "adj": Infinity, "info": null }, { "adj": "6", "info": null }, { "adj": "2", "info": null }, { "adj": Infinity, "info": null }, { "adj": Infinity, "info": null }], [{ "adj": "6", "info": null }, { "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": "4", "info": null }, { "adj": "3", "info": null }], [{ "adj": "2", "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "4", "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }, { "adj": Infinity, "info": null }]];
	var udn = new AdjacencyMatrixGraph(vexs, arcs, 5, 7, 4);
	
	// 第二种创建图方法
	var dn = new AdjacencyMatrixGraph([], [], 0, 0, 2);
	dn.addVertex('a');
	dn.addVertex('b');
	dn.addVertex('c');
	dn.addVertex('d');
	dn.addVertex('e');
	
	dn.addArc('a', 'b', {
	    adj: 6
	});
	dn.addArc('a', 'c', {
	    adj: 2
	});
	dn.addArc('c', 'b', {
	    adj: 3
	});
	dn.addArc('c', 'd', {
	    adj: 1
	});
	dn.addArc('d', 'b', {
	    adj: 4
	});
	dn.addArc('b', 'e', {
	    adj: 3
	});
	dn.addArc('d', 'e', {
	    adj: 5
	});
	
	console.log(dn);
	
	/*
	
	 // 第三种创建图方法
	 let g = new AdjacencyMatrixGraph();
	 g.kind = DN;
	 g.createGraph();
	 console.log(g);
	
	 */
	
	/*
	 图的遍历
	
	 图的遍历(Travering Graph)：从图的某一顶点出发，访遍图中的其余顶点，且每个顶点仅被访问一次。图的遍历算法是各种图的操作的基础。
	
	 ◆ 复杂性：图的任意顶点可能和其余的顶点相邻接，可能在访问了某个顶点后，沿某条路径搜索后又回到原顶点。
	 ◆ 解决办法：在遍历过程中记下已被访问过的顶点。设置一个辅助向量Visited[1…n](n为顶点数)，其初值为0，一旦访问了顶点vi后，使Visited[i]为1或为访问的次序号。
	 图的遍历算法有深度优先搜索算法和广度优先搜索算法。
	
	 深度优先搜索(Depth First Search--DFS)遍历类似树的先序遍历，是树的先序遍历的推广。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；然后找到vi的一个邻接顶点vi1 ；
	 ⑵：从vi1出发，深度优先搜索访问和vi1相邻接且未被访问的所有顶点；
	 ⑶：转⑴ ，直到和vi相邻接的所有顶点都被访问为止
	 ⑷ ：继续选取图中未被访问顶点vj作为起始顶点，转(1)，直到图中所有顶点都被访问为止。
	
	
	 广度优先搜索(Breadth First Search--BFS)遍历类似树的按层次遍历的过程。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；
	 ⑵：访问vi的所有相邻接且未被访问的所有顶点vi1，vi2，…，vim；
	 ⑶：以vi1，vi2， …，vim的次序，以vij(1≦j≦m)依此作为vi ，转⑴；
	 ⑷ ：继续选取图中未被访问顶点vk作为起始顶点，转⑴，直到图中所有顶点都被访问为止。
	
	 用广度优先搜索算法遍历图与深度优先搜索算法遍历图的唯一区别是邻接点搜索次序不同.
	 */
	
	console.log('DFSTraverse: udn');
	
	var g1 = new AdjacencyMatrixGraph([], [], 0, 0, UDG);
	g1.addVertex('v1');
	g1.addVertex('v3');
	g1.addVertex('v2');
	g1.addVertex('v4');
	g1.addVertex('v5');
	
	g1.addArc('v5', 'v4');
	g1.addArc('v3', 'v1');
	g1.addArc('v2', 'v1');
	g1.addArc('v3', 'v2');
	
	g1.DFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('DFSTraverse_NonRecurse: udn');
	g1.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('BFSTraverse: ');
	var bsfG = new AdjacencyMatrixGraph([], [], 0, 0, DG);
	bsfG.addVertex('v1');
	bsfG.addVertex('v2');
	bsfG.addVertex('v3');
	bsfG.addVertex('v4');
	bsfG.addVertex('v5');
	
	bsfG.addArc('v1', 'v4');
	bsfG.addArc('v1', 'v2');
	bsfG.addArc('v3', 'v5');
	bsfG.addArc('v3', 'v2');
	bsfG.addArc('v3', 'v1');
	bsfG.addArc('v4', 'v3');
	bsfG.addArc('v5', 'v4');
	
	bsfG.BFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	/*
	 最小生成树
	
	 如果连通图是一个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。
	
	 最小生成树(Minimum Spanning Tree) ：带权连通图中代价最小的生成树称为最小生成树。
	
	 最小生成树在实际中具有重要用途，如设计通信网。设图的顶点表示城市，边表示两个城市之间的通信线路，边的权值表示建造通信线路的费用。n个城市之间最多可以建n(n-1)/2条线路，如何选择其中的n-1条，使总的建造费用最低?
	
	 构造最小生成树的算法有许多，基本原则是：
	 ◆ 尽可能选取权值最小的边，但不能构成回路；
	 ◆ 选择n-1条边构成最小生成树。
	 以上的基本原则是基于MST的如下性质：
	 设G=(V，E)是一个带权连通图，U是顶点集V的一个非空子集。若u∈U ，v∈V-U，且(u, v)是U中顶点到V-U中顶点之间权值最小的边，则必存在一棵包含边(u, v)的最小生成树。
	
	 证明： 用反证法证明。
	 设图G的任何一棵最小生成树都不包含边(u,v)。设T是G的一棵生成树，则T是连通的，从u到v必有一条路径(u,…,v)，当将边(u,v)加入到T中时就构成了回路。则路径(u, …,v)中必有一条边(u’,v’) ，满足u’∈U ，v’∈V-U 。删去边(u’,v’) 便可消除回路，同时得到另一棵生成树T’。
	 由于(u,v)是U中顶点到V-U中顶点之间权值最小的边，故(u,v)的权值不会高于(u’,v’)的权值，T’的代价也不会高于T， T’是包含(u,v) 的一棵最小生成树，与假设矛盾。
	
	 */
	
	/*
	 普里姆(Prim)算法
	
	 适合边稠密的网
	
	 从连通网N=(U，E)中找最小生成树T=(U，TE) 。
	
	 1 算法思想
	 ⑴  若从顶点v0出发构造，U={v0}，TE={}；
	 ⑵ 先找权值最小的边(u，v)，其中u∈U且v∈V-U，并且子图不构成环，则U= U∪{v}，TE=TE∪{(u，v)} ；
	 ⑶ 重复⑵ ，直到U=V为止。则TE中必有n-1条边， T=(U，TE)就是最小生成树。
	
	 2.算法实现说明
	 为便于算法实现，设置一个一维数组closedge[n]，用来保存V- U中各顶点到U中顶点具有权值最小的边。
	 closedge[j].adjvex=k，表明边(vj, vk)是V-U中顶点vj到U中权值最小的边，而顶点vk是该边所依附的U中的顶点。 closedge[j].lowcost存放该边的权值。
	 假设从顶点vs开始构造最小生成树。初始时令：
	 Closedge[s].lowcost=0 ：表明顶点vs首先加入到U中；
	 Closedge[k].adjvex=s ，Closedge[k].lowcost=cost(k, s)
	 表示V-U中的各顶点到U中权值最小的边(k≠s) ，cost(k, s)表示边(vk, vs) 权值。
	
	 3.算法步骤
	 ⑴  从closedge中选择一条权值(不为0)最小的边(vk, vj) ，然后做：
	 ① 置closedge[k].lowcost为0 ，表示vk已加入到U中。
	 ②  根据新加入vk的更新closedge中每个元素：
	 vi∈V-U ，若cost(i, k)≦colsedge[i].lowcost，表明在U中新加入顶点vk后， (vi, vk)成为vi到U中权值最小的边，置：
	 Closedge[i].lowcost=cost(i, k)
	 Closedge[i].adjvex=k
	 ⑵  重复⑴n-1次就得到最小生成树。
	
	 算法分析：
	 设带权连通图有n个顶点，则算法的主要执行是二重循环： 求closedge中权值最小的边，频度为n-1； 修改closedge数组，频度为n 。因此，整个算法的时间复杂度是O(n2)，与边的数目无关。
	
	 */
	
	udn = new AdjacencyMatrixGraph([], [], 0, 0, 4);
	udn.addVertex('v1');
	udn.addVertex('v2');
	udn.addVertex('v3');
	udn.addVertex('v4');
	udn.addVertex('v5');
	udn.addVertex('v6');
	
	udn.addArc('v1', 'v2', { adj: 6 });
	udn.addArc('v1', 'v3', { adj: 1 });
	udn.addArc('v1', 'v4', { adj: 5 });
	udn.addArc('v2', 'v3', { adj: 5 });
	udn.addArc('v2', 'v5', { adj: 3 });
	udn.addArc('v3', 'v4', { adj: 5 });
	udn.addArc('v3', 'v5', { adj: 6 });
	udn.addArc('v3', 'v6', { adj: 4 });
	udn.addArc('v4', 'v6', { adj: 2 });
	udn.addArc('v5', 'v6', { adj: 6 });
	
	console.log('minSpanTree_PRIM: ');
	console.log(udn.minSpanTree_PRIM(0));
	
	/*
	 克鲁斯卡尔(Kruskal)算法
	
	 适合边稀疏的网
	
	 1 算法思想
	 设G=(V, E)是具有n个顶点的连通网，T=(U, TE)是其最小生成树。初值：U=V，TE={} 。
	 对G中的边按权值大小从小到大依次选取。
	 ⑴   选取权值最小的边(vi，vj)，若边(vi，vj)加入到TE后形成回路，则舍弃该边(边(vi，vj) ；否则，将该边并入到TE中，即TE=TE∪{(vi，vj)} 。
	 ⑵ 重复⑴ ，直到TE中包含有n-1条边为止。
	 如图7-22所提示。
	
	 2 算法实现说明
	 Kruskal算法实现的关键是：当一条边加入到TE的集合后，如何判断是否构成回路?
	 简单的解决方法是：定义一个一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。
	 ◆ 初值：Vset[i]=i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。
	 ◆ 当往T中增加一条边(vi，vj) 时，先检查Vset[i]和Vset[j]值：
	 ☆ 若Vset[i]=Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路；
	 ☆ 若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。
	 ◆ 加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号。
	
	 */
	
	console.log('minSpanTree_Kruskal: ');
	console.log(udn.minSpanTree_Kruskal());
	
	/*
	 最短路径
	
	 若用带权图表示交通网，图中顶点表示地点，边代表两地之间有直接道路，边上的权值表示路程(或所花费用或时间) 。从一个地方到另一个地方的路径长度表示该路径上各边的权值之和。问题：
	 ◆ 两地之间是否有通路?
	 ◆ 在有多条通路的情况下，哪条最短?
	 考虑到交通网的有向性，直接讨论的是带权有向图的最短路径问题，但解决问题的算法也适用于无向图。
	 将一个路径的起始顶点称为源点，最后一个顶点称为终点。
	
	
	 单源点最短路径
	
	 对于给定的有向图G=(V，E)及单个源点Vs，求Vs到G的其余各顶点的最短路径。
	 针对单源点的最短路径问题，Dijkstra提出了一种按路径长度递增次序产生最短路径的算法，即迪杰斯特拉(Dijkstra)算法。
	
	 1 基本思想
	 从图的给定源点到其它各个顶点之间客观上应存在一条最短路径，在这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。
	 即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，依此类推，直到求出长度最长的最短路径。
	
	 2 算法思想说明
	 设给定源点为Vs，S为已求得最短路径的终点集，开始时令S={Vs} 。当求得第一条最短路径(Vs ，Vi)后，S为{Vs，Vi} 。根据以下结论可求下一条最短路径。
	 设下一条最短路径终点为Vj ，则Vj只有：
	 ◆  源点到终点有直接的弧<Vs，Vj>；
	 ◆ 从Vs 出发到Vj 的这条最短路径所经过的所有中间顶点必定在S中。即只有这条最短路径的最后一条弧才是从S内某个顶点连接到S外的顶点Vj 。
	 若定义一个数组dist[n]，其每个dist[i]分量保存从Vs 出发中间只经过集合S中的顶点而到达Vi的所有路径中长度最小的路径长度值，则下一条最短路径的终点Vj必定是不在S中且值最小的顶点，即：
	 dist[i]=Min{ dist[k]| Vk∈V-S }
	 利用上述公式就可以依次找出下一条最短路径。
	
	 3  算法步骤
	 ① 令S={Vs} ，用带权的邻接矩阵表示有向图，对图中每个顶点Vi按以下原则置初值：
	 0    i =s
	 dist[i] =   Wsi     i≠s且<vs,vi>∈E， wsi为弧上的权值
	 ∞   i≠s且<vs,vi>不属于E
	 ② 选择一个顶点Vj ，使得：
	 dist[j]=Min{ dist[k]| Vk∈V-S }
	 Vj就是求得的下一条最短路径终点，将Vj 并入到S中，即S=S∪{Vj} 。
	 ③ 对V-S中的每个顶点Vk ，修改dist[k]，方法是：
	 若dist[j]+Wjk<dist[k]，则修改为：
	 dist[k]=dist[j]+Wjk (Vk∈V-S )
	 ④ 重复②，③，直到S=V为止。
	
	 4 算法实现
	 用带权的邻接矩阵表示有向图， 对Prim算法略加改动就成了Dijkstra算法，将Prim算法中求每个顶点Vk的lowcost值用dist[k]代替即可。
	 ◆  设数组pre[n]保存从Vs到其它顶点的最短路径。若pre[i]=k，表示从Vs 到Vi的最短路径中，Vi的前一个顶点是Vk，即最短路径序列是(Vs , …, Vk  , Vi) 。
	 ◆ 设数组final[n]，标识一个顶点是否已加入S中。
	
	 5  算法分析
	 Dijkstra算法的主要执行是：
	 ◆ 数组变量的初始化：时间复杂度是O(n) ；
	 ◆ 求最短路径的二重循环：时间复杂度是O(n2) ；
	 因此，整个算法的时间复杂度是O(n2) 。
	
	 */
	
	var dijTest = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('0', '1', { adj: 20 });
	dijTest.addArc('0', '4', { adj: 10 });
	dijTest.addArc('0', '2', { adj: 60 });
	dijTest.addArc('0', '5', { adj: 65 });
	dijTest.addArc('1', '2', { adj: 30 });
	dijTest.addArc('2', '3', { adj: 40 });
	dijTest.addArc('5', '2', { adj: 15 });
	dijTest.addArc('4', '5', { adj: 20 });
	dijTest.addArc('3', '4', { adj: 35 });
	dijTest.addArc('1', '3', { adj: 70 });
	
	dijTest.shortestPath_Dijkstra(0);
	
	/*
	 每一对顶点间的最短路径
	
	 用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。方法是：每次以一个不同的顶点为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，时间复杂度是O(n3) 。
	
	 弗罗伊德(Floyd)提出了另一个算法，其时间复杂度仍是O(n3) ， 但算法形式更为简明。
	
	 1 算法思想
	
	 设顶点集S(初值为空)，用数组A的每个元素A[i][j]保存从Vi只经过S中的顶点到达Vj的最短路径长度，其思想是：
	 ① 初始时令S={ } ， A[i][j]的赋初值方式是：
	 0    i =j时
	 A[i][j]=    Wij     i≠j且<vi,vj>∈E， wij为弧上的权值
	 ∞   i≠j且<vi,vj>不属于E
	 ② 将图中一个顶点Vk 加入到S中，修改A[i][j]的值，修改方法是：
	 A[i][j]=Min{A[i][j] , (A[i][k]+A[k][j]) }
	 原因： 从Vj只经过S中的顶点(Vk)到达Vj的路径长度可能比原来不经过Vk的路径更短。
	 ③ 重复②，直到G的所有顶点都加入到S中为止。
	
	 2 算法实现
	
	 ◆  定义二维数组Path[n][n](n为图的顶点数) ，元素Path[i][j]保存从Vi到Vj的最短路径所经过的顶点。
	 ◆ 若Path[i][j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径子序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i][k]和Path[k][j]的值再找到该路径上所经过的其它顶点，…依此类推。
	 ◆ 初始化为Path[i][j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i][j]变小时，令Path[i][j]=k。
	
	
	 */
	
	var floyd = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	floyd.addVertex('v0');
	floyd.addVertex('v1');
	floyd.addVertex('v2');
	floyd.addArc('v0', 'v2', { adj: 8 });
	floyd.addArc('v0', 'v1', { adj: 2 });
	floyd.addArc('v1', 'v2', { adj: 4 });
	floyd.addArc('v2', 'v0', { adj: 5 });
	
	floyd.shortestPath_FLOYD();
	
	// http://blog.csdn.net/hguisu/article/details/7719428
	// 添加《图的应用详解-数据结构》

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 十字链表法
	
	 十字链表(Orthogonal List)是有向图的另一种链式存储结构，是将有向图的正邻接表和逆邻接表结合起来得到的一种链表。
	
	 在这种结构中，每条弧的弧头结点和弧尾结点都存放在链表中，并将弧结点分别组织到以弧尾结点为头(顶点)结点和以弧头结点为头(顶点)结点的链表中。
	
	 ◆  data域：存储和顶点相关的信息；
	 ◆ 指针域firstin：指向以该顶点为弧头的第一条弧所对应的弧结点；
	 ◆ 指针域firstout：指向以该顶点为弧尾的第一条弧所对应的弧结点；
	 ◆ 尾域tailvex：指示弧尾顶点在图中的位置；
	 ◆ 头域headvex：指示弧头顶点在图中的位置；
	 ◆ 指针域hlink：指向弧头相同的下一条弧；
	 ◆ 指针域tlink：指向弧尾相同的下一条弧；
	 ◆ Info域：指向该弧的相关信息；
	
	 从这种存储结构图可以看出，从一个顶点结点的firstout出发，沿表结点的tlink指针构成了正邻接表的链表结构，而从一个顶点结点的firstin出发，沿表结点的hlink指针构成了逆邻接表的链表结构。
	
	 */
	
	/**
	 *
	 * @param {Number} headVex 弧的头顶点的位置
	 * @param {Number} tailVex 弧的尾顶点位置
	 * @param {ArcBox} hLink 弧头相同的弧的链域
	 * @param {ArcBox} tLink 弧尾相同的弧的链域
	 * @param {*} info
	 * @constructor
	 */
	function ArcBox(tailVex, headVex, hLink, tLink, info) {
	    this.headVex = headVex || 0;
	    this.tailVex = tailVex || 0;
	    this.hLink = hLink || null;
	    this.tLink = tLink || null;
	    this.info = info || null;
	}
	
	/**
	 *
	 * @param {*} data
	 * @param {ArcBox} firstIn 该顶点第一条入弧
	 * @param {ArcBox} firstOut 该顶点第一条出弧
	 * @constructor
	 */
	function OLVexNode(data, firstIn, firstOut) {
	    this.data = data || null;
	    this.firstIn = firstIn || null;
	    this.firstOut = firstOut || null;
	}
	
	/**
	 *
	 * @param {Array | OLVexNode} xList 表头向量
	 * @param {Number} vexnum 有向图的当前顶点数
	 * @param {Number} arcnum 有向图的当前弧数
	 * @constructor
	 */
	function OLGraph(xList, vexnum, arcnum) {
	    this.xList = xList || [];
	    this.vexnum = vexnum || 0;
	    this.arcnum = arcnum || 0;
	}
	exports.OLGraph = OLGraph;
	OLGraph.prototype = {
	    constructor: OLGraph,
	
	    locateVex: function locateVex(vp) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.xList[i].data === vp) return i;
	        }
	
	        return -1;
	    },
	
	    // 删除顶点
	    deleteVertex: function deleteVertex(v) {
	        var m = this.locateVex(v);
	
	        if (m < 0) throw new Error('vertex not found!');
	
	        var n = this.vexnum;
	        var q, i, p;
	        // 删除所有以v为头的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是头链上的第一个结点
	            if (this.xList[i].firstIn.tailVex === m) {
	                q = this.xList[i].firstIn;
	                this.xList[i].firstIn = q.hLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstIn; p && p.hLink.tailVex !== m; p = p.hLink) {}
	                if (p) {
	                    q = p.hLink;
	                    p.hLink = q.hLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 删除所有以v为尾的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是尾链上的第一个结点
	            if (this.xList[i].firstOut.headVex === m) {
	                q = this.xList[i].firstOut;
	                this.xList[i].firstOut = q.tLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstOut; p && p.tLink.headVex !== m; p = p.tLink) {}
	                if (p) {
	                    q = p.tLink;
	                    p.tLink = q.tLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 顺次用结点m之后的顶点取代前一个顶点
	        for (i = m; i < n; ++i) {
	            // 修改表头向量
	            this.xList[i] = this.xList[i + 1];
	            for (p = this.xList[i].firstIn; p; p = p.hLink) {
	                p.headVex--;
	            }for (p = this.xList[i].firstOut; p; p = p.tLink) {
	                p.tailVex--;
	            }
	        }
	
	        this.vexnum--;
	        return true;
	    },
	
	    createDG: function createDG() {
	        this.vexnum = prompt('Vexnum: ');
	        this.arcnum = prompt('Arcnum: ');
	        // IncInfo为0则各弧不含其他信息
	        var incInfo = +prompt('IncInfo: ');
	
	        // 输入顶点值
	        for (var i = 0; i < this.vexnum; ++i) {
	            this.xList[i] = new OLVexNode(prompt('data: '), null, null);
	        }
	
	        for (var k = 0; k < this.arcnum; ++k) {
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            i = this.locateVex(v1);
	            var j = this.locateVex(v2);
	
	            if (i === -1 || j === -1) {
	                alert('无此顶点，请重新输入!');
	                k--;
	                continue;
	            }
	
	            var p = new ArcBox(i, j, this.xList[j].firstIn, this.xList[i].firstOut, incInfo && prompt('info: '));
	            this.xList[j].firstIn = this.xList[i].firstOut = p;
	        }
	    },
	
	    /**
	     * 求有向图的强连通分量
	     */
	    getSGraph: function getSGraph() {
	        var visited = [];
	        var finished = [];
	        var count = 0;
	
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第一次深度优先遍历建立finished数组
	        for (i = 0; i < this.vexnum; ++i) {
	            if (!visited[i]) dfs1(this, i);
	        }
	        // 清空visited数组
	        for (i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第二次逆向的深度优先遍历
	        for (var len = this.vexnum - 1; len >= 0; --len) {
	            i = finished[i];
	            if (!visited[i]) dfs2(this, i);
	        }
	
	        function dfs1(graph, v) {
	            visited[v] = true;
	            for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	                var w = p.headVex;
	                if (!visited[w]) dfs1(graph, w);
	            }
	            finished[++count] = v;
	        }
	
	        function dfs2(graph, v) {
	            visited[v] = true;
	            console.log('%d', v);
	            for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	                var w = p.tailVex;
	                if (!visited[w]) dfs2(graph, w);
	            }
	        }
	    }
	};
	
	//var g = new OLGraph();
	//g.createDG();
	//console.log(g);
	
	/*
	 有向图的强连通分量
	
	 对于有向图，在其每一个强连通分量中，任何两个顶点都是可达的。 V∈G，与V可相互到达的所有顶点就是包含V的强连通分量的所有顶点。
	
	 设从V可到达 (以V为起点的所有有向路径的终点)的顶点集合为T1(G)，而到达V (以V为终点的所有有向路径的起点)的顶点集合为T2(G)，则包含V的强连通分量的顶点集合是： T1(G)∩T2(G) 。
	
	 求有向图G的强连通分量的基本步骤是：
	 ⑴ 对G进行深度优先遍历，生成G的深度优先生成森林T。
	 ⑵  对森林T的顶点按中序遍历顺序进行编号。
	 ⑶  改变G中每一条弧的方向，构成一个新的有向图G’。
	 ⑷  按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。
	 ⑸  重复步骤⑷ ，直到G’中的所有顶点都被访问。
	
	 在算法实现时，建立一个数组in_order[n]存放深度优先生成森林的中序遍历序列。对每个顶点v，在调用DFS函数结束时，将顶点依次存放在数组in_order[n]中。图采用十字链表作为存储结构最合适。
	
	 */
	
	// todo to be tested
	OLGraph.prototype.connected_DG = function () {
	    var visited = [];
	    var in_order = [];
	    var count = 0;
	
	    for (var i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图正向遍历
	    for (i = 0; i < this.vexnum; ++i) {
	        if (!visited[i]) {
	            dfs(this, i, in_order);
	        }
	    }
	
	    for (i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图逆向遍历
	    var k = 1;
	    for (var j = this.vexnum - 1; j >= 0; --j) {
	        var v = in_order[j];
	        if (!visited[v]) {
	            console.log('第' + k++ + '个连通分量顶点');
	            rev_dfs(this, v);
	        }
	    }
	
	    function dfs(graph, v) {
	        visited[v] = true;
	
	        for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	            if (!visited[p.headVex]) {
	                dfs(graph, p.headVex);
	            }
	        }
	
	        in_order[count++] = v;
	    }
	
	    function rev_dfs(graph, v) {
	        visited[v] = true;
	        console.log('顶点：' + v);
	
	        for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	            if (!visited[p.tailVex]) {
	                rev_dfs(graph, p.tailVex);
	            }
	        }
	    }
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(25);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _iterator2 = __webpack_require__(14);
	
	var _iterator3 = _interopRequireDefault(_iterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _DoubleLinkedList = __webpack_require__(55);
	
	var _DoubleLinkedList2 = _interopRequireDefault(_DoubleLinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIMIT = 20; /**
	                 * LRU( Least recently used )
	                 */
	
	var LRUCache = function () {
	    function LRUCache(sqList) {
	        var limit = arguments.length <= 1 || arguments[1] === undefined ? LIMIT : arguments[1];
	        (0, _classCallCheck3.default)(this, LRUCache);
	
	        this.limit = limit;
	        sqList = sqList && sqList.length ? sqList && sqList.length.slice(0, this.limit) : [];
	        this.__cache = new _DoubleLinkedList2.default(sqList, function (a, b) {
	            return a.key === b.key;
	        });
	    }
	
	    (0, _createClass3.default)(LRUCache, [{
	        key: _iterator3.default,
	        value: function value() {
	            return (0, _getIterator3.default)(this.__cache);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            return this.__cache.remove({ key: key });
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            return this.___cache.clear();
	        }
	    }, {
	        key: 'get',
	        value: function get(key) {
	            var index = this.__cache.indexOf({ key: key });
	
	            if (index >= 0) {
	                var data = this.__cache.findByIndex(index);
	                this.__cache.remove(data);
	                this.__cache.unshift(data);
	
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'add',
	        value: function add(key, value) {
	            var data = this.get(key);
	            if (data) {
	                data.value = value;
	            } else {
	                if (this.size === this.limit) {
	                    this.__cache.pop();
	                }
	
	                this.__cache.unshift({
	                    key: key,
	                    value: value
	                });
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var arr = [];
	            this.__cache.forEach(function (data) {
	                arr.push(data.key + ':' + data.value);
	            });
	
	            return arr.join(' > ');
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            return this.__cache.toJSON();
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.__cache.size;
	        }
	    }]);
	    return LRUCache;
	}();
	
	exports.default = LRUCache;
	
	
	console.log('LRUCache');
	
	var a = new LRUCache([], 3);
	a.add('adam', 29);
	a.add('john', 26);
	a.add('angela', 24);
	console.log(a + '');
	a.get('john');
	console.log(a + '');
	a.add('zorro', 141);
	console.log(a + '');
	console.log(a.toJSON());
	
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;
	
	try {
	    for (var _iterator = (0, _getIterator3.default)(a), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var item = _step.value;
	
	        console.log(item);
	    }
	} catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	        }
	    } finally {
	        if (_didIteratorError) {
	            throw _iteratorError;
	        }
	    }
	}
	
	a.remove('zorro');
	a.remove('john');
	a.remove('angela');
	console.log(a + '');
	
	console.log('LRUCacheEnd');

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.union = union;
	exports.mergeList = mergeList;
	exports.insert = insert;
	exports.del = del;
	exports.listComp = listComp;
	exports.reverse = reverse;
	exports.intersect = intersect;
	exports.intersect_true = intersect_true;
	exports.intersect_delete = intersect_delete;
	/**
	 * 线性表
	 */
	
	// 线性表的类型定义
	// 将所有在数组b中但不在数组a的数据元素插入到a中
	
	var a = [1, 2, 3, 4, 5];
	var b = [1, 3, 5, 7, 9];
	
	function union(a, b) {
	    var elem, equal;
	
	    for (var i = 0, bLen = b.length; i < bLen; i++) {
	        elem = b[i];
	        equal = false;
	
	        for (var j = 0, aLen = a.length; j < aLen; j++) {
	            if (elem === a[j]) {
	                equal = true;
	                break;
	            }
	        }
	
	        if (!equal) a.push(elem);
	    }
	}
	
	union(a, b);
	console.log(a);
	// [1, 2, 3, 4, 5, 7, 9]
	
	// 时间复杂度：O(aLen * bLen)
	
	// 已知数组a和数组b中的数据元素按值非递减排列
	// 归并a和b得到新的数组c，c的数据元素也按值非递减排列
	var a = [3, 5, 8, 11];
	var b = [2, 6, 8, 9, 11, 15, 20];
	
	function mergeList(a, b) {
	    var c = [],
	        aElem,
	        bElem;
	    var i = 0,
	        j = 0,
	        k = 0;
	    var aLen = a.length;
	    var bLen = b.length;
	
	    while (i < aLen && j < bLen) {
	        aElem = a[i];
	        bElem = b[j];
	
	        if (aElem < bElem) {
	            c[k++] = aElem;
	            i++;
	        } else {
	            c[k++] = bElem;
	            j++;
	        }
	    }
	
	    while (i < aLen) {
	        c[k++] = a[i++];
	    }
	
	    while (j < bLen) {
	        c[k++] = b[j++];
	    }
	
	    return c;
	}
	
	var c = mergeList(a, b);
	console.log(c);
	// [2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20]
	
	// 时间复杂度： O(aLen + bLen)
	
	// 线性表的顺序表示和实现
	// 使用伪数组模拟线性表插入操作的前后数据元素在存储空间中的位置变化
	var a = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 };
	a.length = 6;
	
	function insert(a, i, elem) {
	    if (!elem) return;
	
	    var len = a.length;
	    if (i >= len) {
	        while (len < i) {
	            a[len++] = undefined;
	            a.length++;
	        }
	        a[i] = elem;
	    } else {
	        while (len > i) {
	            a[len--] = a[len];
	        }
	        a[i] = elem;
	    }
	    a.length++;
	}
	
	insert(a, 3, 8);
	insert(a, 10, 10);
	console.log(a);
	
	// 使用伪数组模拟线性表删除操作的前后数据元素在存储空间中的位置变化
	
	function del(a, i) {
	    var temp = a[i];
	    var j = i + 1;
	    var len = a.length;
	
	    while (j < len) {
	        a[j - 1] = a[j++];
	    }
	    a.length--;
	    delete a[len - 1];
	
	    return temp;
	}
	
	del(a, 3);
	console.log(a);
	del(a, 10);
	console.log(a);
	
	// 时间复杂度： O(a.length)
	
	// 比较字符表A和B，并用返回值表示结果，值为1，表示A>B，值为-1，表示A<B，值为0，表示A=B
	function listComp(aList, bList) {
	    for (var i = 0; i < aList.length && i < bList.length; i++) {
	        if (aList[i] !== bList[i]) return aList[i] > bList[i] ? 1 : -1;
	    }
	
	    if (aList.length == bList.length) return 0;
	
	    return aList.length > bList.length ? 1 : -1;
	}
	
	function reverse(list) {
	    for (var i = 0, j = list.length - 1; i <= j; i++, j--) {
	        var temp = list[i];
	        list[i] = list[j];
	        list[j] = temp;
	    }
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(aList, bList) {
	    var cList = [];
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (aList[i] && bList[j]) {
	        if (aList[i] < bList[j]) i++;else if (aList[i] > bList[j]) j++;else {
	            cList[k++] = aList[i];
	            i++;
	            j++;
	        }
	    }
	
	    return cList;
	}
	
	console.log(intersect([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(a, b) {
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (a[i] && b[j]) {
	        if (a[i] < b[j]) i++;else if (a[i] > b[j]) j++;else {
	            a[k++] = a[i];
	            i++;
	            j++;
	        }
	    }
	
	    while (a[k]) {
	        a.splice(k, 1);
	    }return a;
	}
	
	console.log(intersect_true([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// a，b，c的元素均是非递减排列
	// 求a数组中非b数组和c数组的交集的元素。
	function intersect_delete(a, b, c) {
	    var i = 0,
	        j = 0,
	        k = 0,
	        m = 0;
	
	    while (i < a.length && j < b.length && k < c.length) {
	        if (b[j] < c[k]) j++;else if (b[j] > c[k]) k++;else {
	            // 找到了相同元素same
	            var same = b[j];
	
	            // j，k后移到新的元素
	            while (b[j] === same) {
	                j++;
	            }while (c[k] === same) {
	                k++;
	            } // 需保留的元素移动到新位置
	            while (i < a.length && a[i] < same) {
	                a[m++] = a[i++];
	            } // 跳过相同的元素
	            while (i < a.length && a[i] === same) {
	                i++;
	            }
	        }
	    }
	
	    // a的剩余元素重新存储
	    while (i < a.length) {
	        a[m++] = a[i++];
	    }a.length = m;
	
	    return a;
	}
	
	console.log(intersect_delete([1, 2, 3, 4, 5, 6, 9], [1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by ldp on 2015/1/19.
	 */
	
	// 循环队列
	
	var CycleQueue = function () {
	    function CycleQueue() {
	        var maxsize = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
	        (0, _classCallCheck3.default)(this, CycleQueue);
	
	        this.base = {};
	        this.front = this.rear = 0;
	        this.MAXQSIZE = maxsize;
	    }
	
	    (0, _createClass3.default)(CycleQueue, [{
	        key: 'enQueue',
	        value: function enQueue(data) {
	            if ((this.rear + 1) % this.MAXQSIZE === 0) throw new Error('cycleQueue is already full!');
	
	            this.base[this.rear] = data;
	            this.rear = (this.rear + 1) % this.MAXQSIZE;
	        }
	    }, {
	        key: 'deQueue',
	        value: function deQueue() {
	            if (this.front === this.rear) throw new Error('cycleQueue is already empty');
	
	            var elem = this.base[this.front];
	            this.front = (this.front + 1) % this.MAXQSIZE;
	
	            return elem;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.base = {};
	            this.front = this.rear = 0;
	        }
	    }, {
	        key: 'peekAt',
	        value: function peekAt() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	            index = (index + this.MAXQSIZE) % this.MAXQSIZE;
	
	            return this.base[index + this.front] || null;
	        }
	    }, {
	        key: 'getHead',
	        value: function getHead() {
	            var elem = this.base[this.front];
	            return elem ? elem : null;
	        }
	    }, {
	        key: 'queueTraverse',
	        value: function queueTraverse(iterator) {
	            for (var i = this.front, len = this.rear = this.front; i < len; i++) {
	                if (iterator(this.base[i], i)) break;
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var base = [].slice.call(this.base);
	
	            return base.slice(this.front, this.rear - this.front);
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return (this.rear - this.front + this.MAXQSIZE) % this.MAXQSIZE;
	        }
	    }]);
	    return CycleQueue;
	}();
	
	exports.default = CycleQueue;
	
	
	var queue = new CycleQueue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/2/26.
	 */
	
	/*
	优先队列(priority queue)
	
	普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。
	
	优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.
	
	
	入队操作
	①：完全二叉树的构建操作是“从上到下，从左到右”的形式，所以入队的节点是放在数组的最后，也就是树中叶子层的有序最右边空位。
	②：当节点插入到最后时，有可能破坏了堆的性质，此时我们要进行“上滤操作”，当然时间复杂度为O(lgN)。
	
	出队操作
	出队操作时，我们采取的方案是：弹出堆顶元素，然后将叶子层中的最右子节点赋给堆顶，同样这时也会可能存在破坏堆的性质，最后我们要被迫进行下滤操作。
	 */
	
	// 用堆实现优先队列
	
	var PriorityQueue = function () {
	    function PriorityQueue() {
	        (0, _classCallCheck3.default)(this, PriorityQueue);
	
	        this.heap = [];
	    }
	
	    (0, _createClass3.default)(PriorityQueue, [{
	        key: 'enQueue',
	        value: function enQueue(value) {
	            var priority = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	            if (typeof value === 'undefined') throw new Error('argument required');
	
	            // 将当前节点追加到堆尾
	            this.heap.push({
	                value: value,
	                priority: priority
	            });
	
	            // 如果只有一个节点，则不需要进行筛选操作
	            if (this.heap.length === 1) return;
	
	            // 获取最后一个非叶子节点，并进行堆调整
	            upHeapAdjust(this.heap, (this.heap.length >> 1) - 1);
	        }
	    }, {
	        key: 'deQueue',
	        value: function deQueue() {
	            if (!this.heap.length) return null;
	
	            var heap = this.heap;
	            // 出队列操作，弹出数据头元素
	            var data = heap[0];
	            // 用尾元素填充头元素
	            heap[0] = heap[heap.length - 1];
	            // 删除尾节点
	            heap.pop();
	
	            //然后从根节点下滤堆
	            downHeapAdjust(heap, 0);
	
	            return data;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.heap = [];
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.heap.length;
	        }
	    }]);
	    return PriorityQueue;
	}();
	
	// 对堆进行上滤操作，使得满足堆性质
	
	
	exports.default = PriorityQueue;
	function upHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (parent >= 0) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        // 如果parent节点小于它的某个子节点的话，此时筛选操作
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            // 继续进行更上一层的过滤
	            parent = Math.ceil(parent / 2) - 1;
	        } else break;
	    }
	}
	
	// 对堆进行下滤操作，使得满足堆性质
	function downHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (2 * parent + 1 < len) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            parent = max;
	        } else break;
	    }
	}
	
	var test = new PriorityQueue();
	test.enQueue(8, 5);
	test.enQueue(7, 2);
	test.enQueue(6, 1);
	test.enQueue(5, 4);
	test.enQueue(4, 7);
	test.enQueue(3, 3);
	test.enQueue(2, 8);
	test.enQueue(1, 10);
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());

/***/ },
/* 89 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * AVL TREE Class
	 *
	 * @author Brice Chevalier
	 *
	 *
	 * @desc
	 *
	 *    Method                Time Complexity
	 *    ___________________________________
	 *
	 *    add                    O(log2(n))
	 *    remove                O(log2(n))
	 *    getFirst            O(1)
	 *    getLast                O(1)
	 *    getCount            O(1)
	 *    apply                O(n)
	 *    clear                O(n)
	 *
	 *    Memory Complexity in O(n)
	 */
	
	function Node(obj) {
	    this.object = obj;
	    this.height = 1;
	    this.left = null;
	    this.right = null;
	    this.previous = null;
	    this.next = null;
	    this.parent = null;
	}
	
	function AvlTree() {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	}
	AvlTree.cmp = function (a, b) {
	    if (a > b) return 1;else if (a < b) return -1;else return 0;
	};
	
	AvlTree.prototype._addLeft = function (node, parent) {
	    node.previous = parent.previous;
	    node.next = parent;
	    node.parent = parent;
	
	    parent.left = node;
	    parent.previous = node;
	
	    if (node.previous) {
	        node.previous.next = node;
	    }
	
	    if (parent === this.first) {
	        this.first = node;
	    }
	};
	
	AvlTree.prototype._addRight = function (node, parent) {
	    node.previous = parent;
	    node.next = parent.next;
	    node.parent = parent;
	
	    parent.right = node;
	    parent.next = node;
	
	    if (node.next) {
	        node.next.previous = node;
	    }
	
	    if (parent === this.last) {
	        this.last = node;
	    }
	};
	
	AvlTree.prototype.add = function (obj) {
	    this.count += 1;
	    var newNode = new Node(obj);
	
	    if (this.root === null) {
	        this.root = newNode;
	        this.first = this.root;
	        this.last = this.root;
	        return newNode;
	    }
	
	    var current = this.root;
	
	    while (true) {
	
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            // Adding to the left
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else {
	                current = current.left;
	            }
	        } else if (cmp > 0) {
	            // Adding to the right
	            if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                current = current.right;
	            }
	        } else {
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                if (current.right.height < current.left.height) {
	                    current = current.right;
	                } else {
	                    current = current.left;
	                }
	            }
	        }
	    }
	
	    this._balance(newNode.parent);
	
	    return newNode;
	};
	
	AvlTree.prototype._balanceLeftRight = function (node) {
	    var left = node.left;
	    var a = left.left;
	    var b = left.right.left;
	
	    left.right.left = left;
	    node.left = left.right;
	    left = node.left;
	    left.parent = node;
	
	    var leftLeft = left.left;
	    leftLeft.parent = left;
	    leftLeft.left = a;
	    leftLeft.right = b;
	    if (a !== null) {
	        a.parent = leftLeft;
	    }
	    if (b !== null) {
	        b.parent = leftLeft;
	    }
	
	    left.height = leftLeft.height + 1;
	};
	
	AvlTree.prototype._balanceLeftLeft = function (node) {
	    var left = node.left;
	    var c = left.right;
	
	    if (node === this.root) {
	        this.root = left;
	    } else {
	        if (node.parent.right === node) {
	            node.parent.right = left;
	        } else {
	            node.parent.left = left;
	        }
	    }
	
	    left.right = node;
	    left.parent = node.parent;
	    node.parent = left;
	    node.left = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balanceRightLeft = function (node) {
	    var right = node.right;
	    var a = right.right;
	    var b = right.left.right;
	
	    right.left.right = right;
	    node.right = right.left;
	    right = node.right;
	    right.parent = node;
	
	    var rightRight = right.right;
	    rightRight.parent = right;
	    rightRight.right = a;
	    rightRight.left = b;
	    if (a !== null) {
	        a.parent = rightRight;
	    }
	    if (b !== null) {
	        b.parent = rightRight;
	    }
	
	    node.right.height = rightRight.height + 1;
	};
	
	AvlTree.prototype._balanceRightRight = function (node) {
	    var right = node.right;
	    var c = right.left;
	
	    if (node === this.root) {
	        this.root = right;
	    } else {
	        if (node.parent.left === node) {
	            node.parent.left = right;
	        } else {
	            node.parent.right = right;
	        }
	    }
	
	    right.left = node;
	    right.parent = node.parent;
	    node.parent = right;
	    node.right = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balance = function (node) {
	    // Balancing the tree
	    var current = node;
	    while (current !== null) {
	        var leftHeight = current.left === null ? 0 : current.left.height;
	        var rightHeight = current.right === null ? 0 : current.right.height;
	        var newHeight = 1 + Math.max(leftHeight, rightHeight);
	
	        if (newHeight > current.height) {
	            current.height = newHeight;
	            if (leftHeight - rightHeight > 1) {
	
	                // Left case
	                if (current.left.right !== null && (current.left.left === null || current.left.left.height < current.left.right.height)) {
	                    // Left Right Case
	                    this._balanceLeftRight(current);
	                }
	
	                // Left Left Case
	                this._balanceLeftLeft(current);
	
	                // The tree has been balanced
	                break;
	            } else if (rightHeight - leftHeight > 1) {
	
	                // Right case
	                if (current.right.left !== null && (current.right.right === null || current.right.right.height < current.right.left.height)) {
	                    // Right Left Case
	                    this._balanceRightLeft(current);
	                }
	
	                // Right Right Case
	                this._balanceRightRight(current);
	
	                // The tree has been balanced
	                break;
	            } else {
	                // Node is balanced
	                current = current.parent;
	            }
	        } else {
	            break;
	        }
	    }
	};
	
	AvlTree.prototype.remove = function (obj) {
	    this._remove(obj, this.root);
	};
	
	AvlTree.prototype._remove = function (obj, node) {
	    var current = node;
	
	    while (current !== null) {
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            current = current.left;
	        } else if (cmp > 0) {
	            current = current.right;
	        } else {
	            if (obj === current.object) {
	
	                // Node removal
	                this.count -= 1;
	
	                if (current.previous === null) {
	                    this.first = current.next;
	                } else {
	                    current.previous.next = current.next;
	                }
	                if (current.next === null) {
	                    this.last = current.previous;
	                } else {
	                    current.next.previous = current.previous;
	                }
	
	                // Replacing the node by the smallest element greater than it
	                var parent = current.parent;
	                var left = current.left;
	                var right = current.right;
	
	                if (current.right === null) {
	                    if (parent === null) {
	                        this.root = left;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = left;
	                        } else {
	                            parent.left = left;
	                        }
	                    }
	
	                    if (left !== null) {
	                        left.parent = parent;
	                    }
	
	                    this._balance(parent);
	                    return 1;
	                }
	
	                var replacement = current.right;
	                var balanceFrom;
	
	                if (replacement.left === null) {
	                    balanceFrom = replacement;
	
	                    if (left !== null) {
	                        left.parent = replacement;
	                    }
	                    replacement.left = left;
	
	                    if (parent === null) {
	                        this.root = replacement;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = replacement;
	                        } else {
	                            parent.left = replacement;
	                        }
	                    }
	                    replacement.parent = parent;
	
	                    this._balance(balanceFrom);
	
	                    return 1;
	                }
	
	                replacement = replacement.left;
	                while (replacement.left !== null) {
	                    replacement = replacement.left;
	                }
	
	                if (replacement.right !== null) {
	                    replacement.right.parent = replacement.parent;
	                }
	                replacement.parent.left = replacement.right;
	
	                if (right !== null) {
	                    right.parent = replacement;
	                }
	                replacement.right = right;
	
	                balanceFrom = replacement.parent;
	
	                if (left !== null) {
	                    left.parent = replacement;
	                }
	                replacement.left = left;
	
	                if (parent === null) {
	                    this.root = replacement;
	                } else {
	                    if (parent.right === current) {
	                        parent.right = replacement;
	                    } else {
	                        parent.left = replacement;
	                    }
	                }
	                replacement.parent = parent;
	
	                this._balance(balanceFrom);
	
	                return 1;
	            } else {
	                if (!this._remove(obj, current.left)) {
	                    this._remove(obj, current.right);
	                }
	            }
	        }
	    }
	
	    return 0;
	};
	
	AvlTree.prototype.removeByRef = function (node) {
	    // Node removal
	    this.count -= 1;
	
	    if (node.previous === null) {
	        this.first = node.next;
	    } else {
	        node.previous.next = node.next;
	    }
	    if (node.next === null) {
	        this.last = node.previous;
	    } else {
	        node.next.previous = node.previous;
	    }
	
	    // Replacing the node by the smallest element greater than it
	    var parent = node.parent;
	    var left = node.left;
	    var right = node.right;
	
	    if (node.right === null) {
	        if (parent === null) {
	            this.root = left;
	        } else {
	            if (parent.right === node) {
	                parent.right = left;
	            } else {
	                parent.left = left;
	            }
	        }
	
	        if (left !== null) {
	            left.parent = parent;
	        }
	
	        this._balance(parent);
	        return 1;
	    }
	
	    var replacement = node.right;
	    var balanceFrom;
	
	    if (replacement.left === null) {
	        balanceFrom = replacement;
	
	        if (left !== null) {
	            left.parent = replacement;
	        }
	        replacement.left = left;
	
	        if (parent === null) {
	            this.root = replacement;
	        } else {
	            if (parent.right === node) {
	                parent.right = replacement;
	            } else {
	                parent.left = replacement;
	            }
	        }
	        replacement.parent = parent;
	
	        this._balance(balanceFrom);
	
	        return 1;
	    }
	
	    replacement = replacement.left;
	    while (replacement.left !== null) {
	        replacement = replacement.left;
	    }
	
	    if (replacement.right !== null) {
	        replacement.right.parent = replacement.parent;
	    }
	    replacement.parent.left = replacement.right;
	
	    if (right !== null) {
	        right.parent = replacement;
	    }
	    replacement.right = right;
	
	    balanceFrom = replacement.parent;
	
	    if (left !== null) {
	        left.parent = replacement;
	    }
	    replacement.left = left;
	
	    if (parent === null) {
	        this.root = replacement;
	    } else {
	        if (parent.right === node) {
	            parent.right = replacement;
	        } else {
	            parent.left = replacement;
	        }
	    }
	    replacement.parent = parent;
	
	    this._balance(balanceFrom);
	
	    return 1;
	};
	
	AvlTree.prototype.getFirst = function () {
	    return this.first;
	};
	
	AvlTree.prototype.getLast = function () {
	    return this.last;
	};
	
	AvlTree.prototype.getHeight = function () {
	    return this.root.height;
	};
	
	AvlTree.prototype.getRoot = function () {
	    return this.root;
	};
	
	AvlTree.prototype.getCount = function () {
	    return this.count;
	};
	
	AvlTree.prototype.forEach = function (processingFunc, params) {
	    for (var current = this.first; current; current = current.next) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.forEachReverse = function (processingFunc, params) {
	    for (var current = this.last; current; current = current.previous) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.clear = function () {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	};
	
	module.exports = AvlTree;
	
	console.log('\nAVL tree insert2: ');
	var test = new AvlTree();
	test.add(3);
	test.add(14);
	test.add(25);
	test.add(81);
	test.add(44);
	
	/*
	 14
	 /    \
	 3       44
	 /   \
	 25     81
	 */
	
	console.log('remove_Recursive 2:');
	
	test.remove(81);
	test.remove(3);
	test.remove(14);
	test.remove(25);
	test.remove(44);
	
	var str = 'cknobfjtlpqaegrmdhs';
	//var str = 'ckbfjlaegmdh';
	
	test = new AvlTree();
	for (var i = 0; i < str.length; ++i) {
	    test.add(str[i]);
	}
	
	test.remove('e');
	test.remove('h');
	test.remove('b');
	test.remove('l');
	test.remove('f');
	test.remove('j');
	test.remove('g');
	test.remove('d');
	test.remove('k');
	test.remove('a');
	test.remove('m');
	test.remove('n');
	test.remove('o');
	test.remove('p');
	test.remove('q');
	test.remove('r');
	test.remove('s');
	test.remove('t');
	test.remove('c');

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	var _create = __webpack_require__(31);
	
	var _create2 = _interopRequireDefault(_create);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 MIT License
	 Copyright (c) 2012 Santanu Basu
	 Copyright (c) 2013 Daniel Wirtz
	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:
	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.
	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	// Based on Santanu Basu's BPlusJS
	// https://github.com/santanubasu/BPlusJS
	// Modified for stand-alone use
	
	/**
	 * @license BTree.js
	 * Released under the MIT License
	 * see: https://github.com/dcodeIO/BTree.js for details
	 */
	(function (global) {
	
	    function isDefined(v) {
	        return typeof v != 'undefined';
	    }
	
	    var Node = function Node(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.data = [];
	    };
	
	    Node.prototype.getLeftPeer = function () {
	        return this.leftPeer;
	    };
	
	    Node.prototype.setLeftPeer = function (leftPeer) {
	        this.leftPeer = leftPeer;
	    };
	
	    Node.prototype.getRightPeer = function () {
	        return this.rightPeer;
	    };
	
	    Node.prototype.setRightPeer = function (rightPeer) {
	        this.rightPeer = rightPeer;
	    };
	
	    Node.prototype.getData = function () {
	        return this.data;
	    };
	
	    Node.prototype.getSurplus = function () {
	        return Math.max(0, Math.floor((this.data.length - this.mergeThreshold) / 2));
	    };
	
	    Node.prototype.getRightSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(this.data.length - surplus);
	    };
	
	    Node.prototype.getLeftSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(0, surplus);
	    };
	
	    var InternalNode = function InternalNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    InternalNode.prototype = (0, _create2.default)(Node.prototype);
	
	    InternalNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        var left = 0;
	        var right = data.length - 1;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left < right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return right;
	        }
	    };
	
	    InternalNode.prototype.findChild = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        if (element.key <= key) {
	            child = element.right;
	        } else {
	            child = element.left;
	        }
	        return child;
	    };
	
	    InternalNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        var newNodes, leftElement, rightElement;
	        if (element.key <= key) {
	            child = element.right;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: element.key,
	                    left: element.left,
	                    right: newNodes[0]
	                };
	                rightElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        } else {
	            child = element.left;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                rightElement = {
	                    key: element.key,
	                    left: newNodes[2],
	                    right: element.right
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        }
	        return newNodes;
	    };
	
	    InternalNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new InternalNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new InternalNode({
	            data: this.data.slice(splitIndex + 1, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    InternalNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var mergeIndex = -1;
	        var child;
	        var retval;
	        if (element.key <= key) {
	            child = element.right;
	            retval = child.remove(key, element.left, index < this.data.length - 1 ? child.getRightPeer() : undefined);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index + 1;
	                } else {
	                    mergeIndex = index;
	                }
	            }
	        } else {
	            child = element.left;
	            retval = child.remove(key, index > 0 ? child.getLeftPeer() : undefined, element.right);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index;
	                } else {
	                    mergeIndex = index - 1;
	                }
	            }
	        }
	        if (mergeIndex >= 0) {
	            var mergeElement = this.data[mergeIndex];
	            if (retval.length == 5) {
	                mergeElement.key = retval[3];
	                return [retval[0]];
	            } else {
	                if (mergeIndex > 0) {
	                    this.data[mergeIndex - 1].right = retval[3];
	                }
	                if (mergeIndex < this.data.length - 1) {
	                    this.data[mergeIndex + 1].left = retval[3];
	                }
	                this.data.splice(mergeIndex, 1);
	                return [retval[0]].concat(this.merge(leftMergeOption, rightMergeOption));
	            }
	        } else {
	            return [retval[0]];
	        }
	    };
	
	    InternalNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.slice(1).concat([{
	                key: this.data[0].left.getData()[0].key,
	                left: leftSurplusData[leftSurplusData.length - 1].right,
	                right: this.data[0].left
	            }], this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = leftSurplusData[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat([{
	                key: rightSurplusData[0].left.getData()[0].key,
	                left: this.data[this.data.length - 1].right,
	                right: rightSurplusData[0].left
	            }], rightSurplusData.slice(0, rightSurplusData.length - 1));
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightSurplusData[rightSurplusData.length - 1].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedInternalNode;
	            if (!isDefined(leftData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    InternalNode.prototype.find = function (key) {
	        return this.findChild(key).find(key);
	    };
	
	    InternalNode.prototype.range = function (start, end) {
	        return this.findChild(start).range(start, end);
	    };
	
	    InternalNode.prototype.toString = function (indent) {
	        return this.data.map(function (element) {
	            return [indent + "[key=" + element.key, "\n" + indent + "    LEFT\n" + element.left.toString(indent + "    "), "\n" + indent + "    RIGHT\n" + element.right.toString(indent + "    ") + "\n" + indent + "]"];
	        }).join(",\n");
	    };
	
	    var LeafNode = function LeafNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    LeafNode.prototype = (0, _create2.default)(Node.prototype);
	
	    LeafNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        if (data.length == 0) {
	            return 0;
	        }
	        var left = 0;
	        var right = data.length;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left !== right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return left;
	        }
	    };
	
	    LeafNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index == this.data.length) {
	            this.data.push({
	                key: key,
	                value: value
	            });
	        } else if (element.key === key) {
	            if (clobber) {
	                element.value = value;
	            } else {
	                return [element.value];
	            }
	            // This condition may never occur, given the way findIndex is written
	        } else if (element.key < key) {
	                this.data.splice(index + 1, 0, {
	                    key: key,
	                    value: value
	                });
	            } else {
	                this.data.splice(index, 0, {
	                    key: key,
	                    value: value
	                });
	            }
	        return this.split();
	    };
	
	    LeafNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new LeafNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new LeafNode({
	            data: this.data.slice(splitIndex, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    LeafNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            this.data.splice(index, 1);
	            return [element.value].concat(this.merge(leftMergeOption, rightMergeOption));
	        } else {
	            return [undefined];
	        }
	    };
	
	    LeafNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.concat(this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = this.data[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat(rightSurplusData);
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightMergeOption.getData()[0].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedLeafNode;
	            if (!isDefined(leftData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    LeafNode.prototype.find = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            return element.value;
	        }
	    };
	
	    LeafNode.prototype.range = function (start, end) {
	        var node = this;
	        var range = [];
	        while (isDefined(node)) {
	            var startIndex = node.findIndex(start);
	            var endIndex = node.findIndex(end);
	            var nodeData = node.getData();
	            if (startIndex < nodeData.length) {
	                for (var i = startIndex; i < endIndex; i++) {
	                    range.push(nodeData[i].value);
	                }
	            }
	            if (endIndex == nodeData.length) {
	                node = node.getRightPeer();
	            } else {
	                break;
	            }
	        }
	        return range;
	    };
	
	    LeafNode.prototype.toString = function (indent) {
	        return indent + "[" + this.data.map(function (element) {
	            return element.key;
	        }).toString() + "]";
	    };
	
	    var Tree = function Tree(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.root = new LeafNode({
	            order: this.order,
	            mergeThreshold: this.mergeThreshold,
	            data: []
	        });
	    };
	
	    Tree.prototype.toString = function () {
	        return this.root.toString("");
	    };
	
	    Tree.prototype.insert = function (key, value, clobber) {
	        var newNodes = this.root.insert(key, value, clobber);
	        if (newNodes.length == 3) {
	            this.root = new InternalNode({
	                order: this.order,
	                mergeThreshold: this.mergeThreshold,
	                data: [{
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                }]
	            });
	        } else if (newNodes.length == 1) {
	            return newNodes[0];
	        }
	        return value;
	    };
	
	    Tree.prototype.remove = function (key) {
	        var retval = this.root.remove(key);
	        if (retval.length == 2) {
	            this.root = retval[1];
	        }
	        return retval[0];
	    };
	
	    Tree.prototype.find = function (key) {
	        return this.root.find(key);
	    };
	
	    Tree.prototype.range = function (start, end) {
	        return this.root.range(start, end);
	    };
	
	    // Expose all types on top
	    Tree.Node = Node;
	    Tree.InternalNode = InternalNode;
	    Tree.LeafNode = LeafNode;
	
	    // Enable module loading if available
	    if (typeof module != 'undefined' && module["exports"]) {
	        // CommonJS
	        module["exports"] = Tree;
	    } else if ("function" != 'undefined' && __webpack_require__(161)["amd"]) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Tree;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Shim
	        if (!global["dcodeIO"]) {
	            global["dcodeIO"] = {};
	        }
	        global["dcodeIO"]["BPlusTree"] = Tree;
	    }
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)(module)))

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	/*
	 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	 http://www.apache.org/licenses/LICENSE-2.0
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: http://github.com/dcodeIO/btree.js for details
	 */
	(function (module, console) {
	    'use strict';
	
	    /**
	     * Concatenates multiple arrays into a new one.
	     * @param {...[Array]} var_args
	     * @returns {Array}
	     * @private
	     */
	
	    function concat(var_args) {
	        // Array#concat behaves strangely for empty arrays, so...
	        var a = [];
	        for (var i = 0; i < arguments.length; i++) {
	            Array.prototype.push.apply(a, arguments[i]);
	        }
	        return a;
	    }
	
	    /**
	     * Searches an array for the specified value.
	     * @param {Array} a
	     * @param {*} v
	     * @returns {number} Index or -1 if not found
	     * @private
	     */
	    function asearch(a, v) {
	        // This is faster than Array#indexOf because it's raw. However, we
	        // cannot use binary search because nodes do not have a comparable
	        // key. If the compiler is smart, it will inline this.
	        for (var i = 0; i < a.length; i++) {
	            if (a[i] === v) return i;
	        }
	        return -i;
	    }
	
	    /**
	     * btree namespace.
	     * @type {Object.<string,*>}
	     */
	    var btree = {};
	
	    /**
	     * Strictly compares two strings, character by character. No locales, no number extension.
	     * @param {string} a
	     * @param {string} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.strcmp = function strcmp(a, b) {
	        /** @type {number} */
	        var ac;
	        /** @type {number} */
	        var bc;
	        for (var i = 0; i < a.length; i++) {
	            if (i >= b.length) {
	                return 1;
	            }
	            if ((ac = a.charCodeAt(i)) < (bc = b.charCodeAt(i))) {
	                return -1;
	            } else if (ac > bc) {
	                return 1;
	            }
	            // If same, continue
	        }
	        return a.length == b.length ? 0 : -1;
	    };
	
	    /**
	     * Compares two numbers.
	     * @param {number} a
	     * @param {number} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.numcmp = function intcmp(a, b) {
	        return a < b ? -1 : a > b ? 1 : 0;
	    };
	
	    /**
	     * Creates a BTree class using the given order.
	     * Note that this method returns a class, not an instance.
	     * @param {number=} order Defaults to 2
	     * @param {function(?, ?):number=} compare Compare implementation to use on keys
	     * @returns {Function}
	     * @expose
	     */
	    btree.create = function (order, compare) {
	
	        // Validate order
	        if (typeof order == 'undefined') {
	            order = 52; // Benchmarks proofed that this is close to the optimum
	        } else if (typeof order == 'number') {
	                order = Math.floor(order);
	            } else {
	                order = parseInt(order, 10);
	            }
	        if (order < 1) order = 1;
	        var minOrder = order > 1 ? Math.floor(order / 2) : 1;
	
	        // Use numcmp by default
	        if (typeof compare != 'function') {
	            compare = btree.numcmp;
	        }
	
	        /**
	         * Validates a node and prints debugging info if something went wrong.
	         * @param {!TreeNode|!Tree} node
	         * @private
	         */
	        function validate(node) {
	            // This function will be stripped by the compiler
	            if (node instanceof Tree) return;
	            if (node.leaves.length + 1 != node.nodes.length) {
	                console.log("ERROR: Illegal leaf/node count in " + node + ": " + node.leaves.length + "/" + node.nodes.length);
	            }
	            for (var i = 0; i < node.leaves.length; i++) {
	                if (!node.leaves[i]) {
	                    console.log("ERROR: Illegal leaf in " + node + " at " + i + ": " + node.leaves[i]);
	                }
	            }
	            for (i = 0; i < node.nodes.length; i++) {
	                if (typeof node.nodes[i] == 'undefined') {
	                    console.log("ERROR: Illegal node in " + node + " at " + i + ": undefined");
	                }
	            }
	        }
	
	        /**
	         * Constructs a new TreeNode.
	         * @class A TreeNode.
	         * @param {!(TreeNode|Tree)} parent Parent node
	         * @param {Array.<!Leaf>=} leaves Leaf nodes
	         * @param {Array.<TreeNode>=} nodes Child nodes
	         * @constructor
	         */
	        var TreeNode = function TreeNode(parent, leaves, nodes) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode|!Tree}
	             */
	            this.parent = parent;
	
	            /**
	             * Leaf nodes (max. order).
	             * @type {!Array.<!Leaf>}
	             */
	            this.leaves = leaves || [];
	            this.leaves.forEach(function (leaf) {
	                leaf.parent = this;
	            }, this);
	
	            /**
	             * Child nodes (max. order+1).
	             * @type {!Array.<TreeNode>}
	             */
	            this.nodes = nodes || [null];
	            this.nodes.forEach(function (node) {
	                if (node !== null) node.parent = this;
	            }, this);
	        };
	
	        /**
	         * Searches for the node that would contain the specified key.
	         * @param {!*} key
	         * @returns {{leaf: !Leaf, index: number}|{node: !TreeNode, index: number}} Leaf if the key exists, else the insertion node
	         */
	        TreeNode.prototype.search = function (key) {
	            if (this.leaves.length > 0) {
	                var a = this.leaves[0];
	                if (compare(a.key, key) == 0) return { leaf: a, index: 0 };
	                if (compare(key, a.key) < 0) {
	                    if (this.nodes[0] !== null) {
	                        return this.nodes[0].search(key); // Left
	                    }
	                    return { node: this, index: 0 };
	                }
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(b.key, key) == 0) return { leaf: b, index: i };
	                    if (compare(key, b.key) < 0) {
	                        if (this.nodes[i] !== null) {
	                            return this.nodes[i].search(key); // Inner
	                        }
	                        return { node: this, index: i };
	                    }
	                    a = b;
	                }
	                if (this.nodes[i] !== null) {
	                    return this.nodes[i].search(key); // Right
	                }
	                return { node: this, index: i };
	            }
	            return { node: this, index: 0 };
	        };
	
	        /**
	         * Gets the value for the given key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         */
	        TreeNode.prototype.get = function (key) {
	            var result = this.search(key);
	            if (result.leaf) return result.leaf.value;
	            return undefined;
	        };
	
	        /**
	         * Inserts a key/value pair into this node.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if successfully set, false if already present and overwrite is `false`
	         */
	        TreeNode.prototype.put = function (key, value, overwrite) {
	            var result = this.search(key);
	            if (result.leaf) {
	                if (typeof overwrite !== 'undefined' && !overwrite) {
	                    return false;
	                }
	                result.leaf.value = value;
	                return true;
	            } // Key already exists
	            var node = result.node,
	                index = result.index;
	            node.leaves.splice(index, 0, new Leaf(node, key, value));
	            node.nodes.splice(index + 1, 0, null);
	            if (node.leaves.length > order) {
	                // Rebalance
	                node.split();
	            }
	            return true;
	        };
	
	        /**
	         * Deletes a key from this node.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         */
	        TreeNode.prototype.del = function (key) {
	            var result = this.search(key);
	            if (!result.leaf) return false;
	            var leaf = result.leaf,
	                node = leaf.parent,
	                index = result.index,
	                left = node.nodes[index];
	            if (left === null) {
	                node.leaves.splice(index, 1);
	                node.nodes.splice(index, 1);
	                node.balance();
	            } else {
	                var max = left.leaves[left.leaves.length - 1];
	                left.del(max.key);
	                max.parent = node;
	                node.leaves.splice(index, 1, max);
	            }
	            return true;
	        };
	
	        /**
	         * Balances this node to fulfill all conditions.
	         */
	        TreeNode.prototype.balance = function () {
	            if (this.parent instanceof Tree) {
	                // Special case: Root has just a single child and no leaves
	                if (this.leaves.length == 0 && this.nodes[0] !== null) {
	                    this.parent.root = this.nodes[0];
	                    this.parent.root.parent = this.parent;
	                }
	                return;
	            }
	            if (this.leaves.length >= minOrder) {
	                return;
	            }
	            var index = asearch(this.parent.nodes, this),
	                left = index > 0 ? this.parent.nodes[index - 1] : null,
	                right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null;
	            var sep, leaf, rest;
	            if (right !== null && right.leaves.length > minOrder) {
	                // Append the seperator from parent to this
	                sep = this.parent.leaves[index];
	                sep.parent = this;
	                this.leaves.push(sep);
	                // Replace the blank with the first right leaf
	                leaf = right.leaves.shift();
	                leaf.parent = this.parent;
	                this.parent.leaves[index] = leaf;
	                // Append the right rest to this
	                rest = right.nodes.shift();
	                if (rest !== null) rest.parent = this;
	                this.nodes.push(rest);
	            } else if (left !== null && left.leaves.length > minOrder) {
	                // Prepend the seperator from parent to this
	                sep = this.parent.leaves[index - 1];
	                sep.parent = this;
	                this.leaves.unshift(sep);
	                // Replace the blank with the last left leaf
	                leaf = left.leaves.pop();
	                leaf.parent = this.parent;
	                this.parent.leaves[index - 1] = leaf;
	                // Prepend the left rest to this
	                rest = left.nodes.pop();
	                if (rest !== null) rest.parent = this;
	                this.nodes.unshift(rest);
	            } else {
	                var subst;
	                if (right !== null) {
	                    // Combine this + seperator from the parent + right
	                    sep = this.parent.leaves[index];
	                    subst = new TreeNode(this.parent, concat(this.leaves, [sep], right.leaves), concat(this.nodes, right.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index, 2, subst);
	                } else if (left !== null) {
	                    // Combine left + seperator from parent + this
	                    sep = this.parent.leaves[index - 1];
	                    subst = new TreeNode(this.parent, concat(left.leaves, [sep], this.leaves), concat(left.nodes, this.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index - 1, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index - 1, 2, subst);
	                } else {
	                    // We should never end here
	                    throw new Error("Internal error: " + this.toString(true) + " has neither a left nor a right sibling");
	                }
	                this.parent.balance();
	            }
	            // validate(this);
	            // validate(this.parent);
	        };
	
	        /**
	         * Unsplits a child.
	         * @param {!Leaf} leaf
	         * @param {!TreeNode} rest
	         */
	        TreeNode.prototype.unsplit = function (leaf, rest) {
	            leaf.parent = this;
	            rest.parent = this;
	            var a = this.leaves[0];
	            if (compare(leaf.key, a.key) < 0) {
	                this.leaves.unshift(leaf);
	                this.nodes.splice(1, 0, rest);
	            } else {
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(leaf.key, b.key) < 0) {
	                        this.leaves.splice(i, 0, leaf);
	                        this.nodes.splice(i + 1, 0, rest);
	                        break;
	                    }
	                }
	                if (i == this.leaves.length) {
	                    this.leaves.push(leaf);
	                    this.nodes.push(rest);
	                }
	            }
	            if (this.leaves.length > order) {
	                this.split();
	            }
	        };
	
	        /**
	         * Splits this node.
	         */
	        TreeNode.prototype.split = function () {
	            var index = Math.floor(this.leaves.length / 2);
	            if (this.parent instanceof Tree) {
	                this.nodes = [new TreeNode(this, this.leaves.slice(0, index), this.nodes.slice(0, index + 1)), new TreeNode(this, this.leaves.slice(index + 1), this.nodes.slice(index + 1))];
	                this.leaves = [this.leaves[index]];
	            } else {
	                var leaf = this.leaves[index];
	                var rest = new TreeNode(this.parent, this.leaves.slice(index + 1), this.nodes.slice(index + 1));
	                this.leaves = this.leaves.slice(0, index);
	                this.nodes = this.nodes.slice(0, index + 1);
	                this.parent.unsplit(leaf, rest);
	            }
	        };
	
	        /**
	         * Returns a string representation of this node.
	         * @param {boolean=} includeNodes Whether to include sub-nodes or not
	         * @returns {string}
	         */
	        TreeNode.prototype.toString = function (includeNodes) {
	            var val = [];
	            for (var i = 0; i < this.leaves.length; i++) {
	                val.push(this.leaves[i].key);
	            }
	            var s = "[" + val.toString() + "]" + (this.parent instanceof Tree ? ":*" : ":" + this.parent);
	            if (includeNodes) {
	                for (i = 0; i < this.nodes.length; i++) {
	                    s += " -> " + this.nodes[i];
	                }
	            }
	            return s;
	        };
	
	        /**
	         * Prints out the nodes leaves and nodes.
	         * @param {number} indent
	         */
	        TreeNode.prototype.print = function (indent) {
	            var space = "";
	            for (var i = 0; i < indent; i++) {
	                space += " ";
	            }for (i = this.leaves.length - 1; i >= 0; i--) {
	                if (this.nodes[i + 1] !== null) this.nodes[i + 1].print(indent + 2);
	                console.log(space + this.leaves[i].key + (this.parent instanceof Tree ? "*" : ""));
	            }
	            if (this.nodes[0] !== null) this.nodes[0].print(indent + 2);
	        };
	
	        /**
	         * Constructs a new Leaf containing a value.
	         * @class A Leaf.
	         * @param {!TreeNode} parent
	         * @param {!*} key
	         * @param {*} value
	         * @constructor
	         */
	        var Leaf = function Leaf(parent, key, value) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode}
	             */
	            this.parent = parent;
	
	            /**
	             * Key.
	             * @type {!*}
	             */
	            this.key = key;
	
	            /**
	             * Value.
	             * @type {*}
	             */
	            this.value = value;
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Leaf.prototype.toString = function () {
	            return "" + this.key;
	        };
	
	        /**
	         * Constructs a new Tree.
	         * @class A Tree.
	         * @constructor
	         */
	        function Tree() {
	            this.root = new TreeNode(this);
	        }
	
	        /**
	         * Inserts a key/value pair into the tree.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if set, false if already present and overwrite is `false`
	         * @throws {Error} If the key is undefined or null or the value is undefined
	         * @expose
	         */
	        Tree.prototype.put = function (key, value, overwrite) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            if (typeof value === 'undefined') throw new Error("Illegal value: " + value);
	            return this.root.put(key, value, overwrite);
	        };
	
	        /**
	         * Gets the value of the specified key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         * @throws {Error} If the key is undefined or null
	         * @expose
	         */
	        Tree.prototype.get = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.get(key);
	        };
	
	        /**
	         * Deletes a key from the tree.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         * @expose
	         */
	        Tree.prototype.del = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.del(key);
	        };
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in ascending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkAsc = function (minKey, maxKey, callback) {
	            if (this.root.leaves.length == 0) {
	                return;
	            }
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (minKey === null) {
	                // If there is no minimum limit
	                ptr = this.root; // set ptr to the outer left node
	                while (ptr.nodes[0] !== null) {
	                    ptr = ptr.nodes[0];
	                }
	                index = 0; // and start at its first leaf
	            } else {
	                    // Else lookup
	                    var result = this.root.search(minKey);
	                    if (result.leaf) {
	                        // If the minimum key itself exists
	                        ptr = result.leaf.parent; // set ptr to the containing node
	                        index = asearch(ptr.leaves, result.leaf); // and start at its index
	                    } else {
	                            // If the key does not exist
	                            ptr = result.node; // set ptr to the insertion node
	                            index = result.index; // and start at the insertion index (key > minKey)
	                            if (index >= ptr.leaves.length) {
	                                // on overrun, begin at the separator in the parent
	                                if (ptr.parent instanceof Tree) {
	                                    return; // empty range
	                                }
	                                index = asearch(ptr.parent.nodes, ptr);
	                                if (index >= ptr.parent.leaves.length) {
	                                    return; // empty range
	                                }
	                                ptr = ptr.parent;
	                            }
	                        }
	                }
	            // ptr/index now points at our first result
	            while (true) {
	                if (maxKey !== null && compare(ptr.leaves[index].key, maxKey) > 0) {
	                    break; // if there are no more keys less than maxKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index + 1] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index + 1];
	                    index = 0;
	                    while (ptr.nodes[0] !== null) {
	                        ptr = ptr.nodes[0];
	                    }
	                } else if (ptr.leaves.length > index + 1) {
	                    // Next
	                    index++;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr);
	                        ptr = ptr.parent;
	                    } while (index >= ptr.leaves.length);
	                }
	            }
	        };
	
	        /**
	         * Alias of {@link Tree#walkAsc}.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|(function(*, *):(boolean|undefined)))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walk = Tree.prototype.walkAsc;
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in descending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or null, walks till the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or null, starts at the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkDesc = function (minKey, maxKey, callback) {
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (maxKey === null) {
	                // If there is no maximum limit
	                ptr = this.root; // set ptr to the outer right node
	                while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                    ptr = ptr.nodes[ptr.nodes.length - 1];
	                }
	                index = ptr.leaves.length - 1; // and start at its last leaf
	            } else {
	                    // Else lookup
	                    var result = this.root.search(maxKey);
	                    if (result.leaf) {
	                        // If the maximum key itself exists
	                        ptr = result.leaf.parent; // set ptr to the containing node
	                        index = asearch(ptr.leaves, result.leaf); // and start at its index
	                    } else {
	                            // If the key does not exist
	                            ptr = result.node; // set ptr to the insertion node
	                            index = result.index - 1; // and start at the insertion index-1 (key < maxKey)
	                            while (index < 0) {
	                                // on underrun, begin at the separator in the parent
	                                if (ptr.parent instanceof Tree) {
	                                    return; // empty range
	                                }
	                                index = asearch(ptr.parent.nodes, ptr) - 1;
	                                if (index < 0) {
	                                    return; // empty range
	                                }
	                                ptr = ptr.parent;
	                            }
	                        }
	                }
	            // ptr/index now points at our first result
	            while (true) {
	                if (minKey !== null && compare(ptr.leaves[index].key, minKey) < 0) {
	                    break; // if there are no more keys bigger than minKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index];
	                    while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                        ptr = ptr.nodes[ptr.nodes.length - 1];
	                    }
	                    index = ptr.leaves.length - 1;
	                } else if (index > 0) {
	                    // Next
	                    index--;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr) - 1;
	                        ptr = ptr.parent;
	                    } while (index < 0);
	                }
	            }
	        };
	
	        /**
	         * Counts the number of keys between minKey and maxKey (both inclusive).
	         * @param {*=} minKey If omitted, counts from the start
	         * @param {*=} maxKey If omitted, counts till the end
	         * @returns {number}
	         * @expose
	         */
	        Tree.prototype.count = function (minKey, maxKey) {
	            var n = 0;
	            this.walk(typeof minKey != 'undefined' ? minKey : null, typeof maxKey != 'undefined' ? maxKey : null, function (key, value) {
	                n++;
	            });
	            return n;
	        };
	
	        /**
	         * Prints out all nodes in the tree.
	         * @expose
	         */
	        Tree.prototype.print = function () {
	            this.root.print(0);
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Tree.prototype.toString = function () {
	            return "Tree(" + order + ") " + this.root.toString();
	        };
	
	        return Tree;
	    };
	
	    module.exports = btree;
	})(module, console);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)(module)))

/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 折半查找(Binary Search)
	
	 折半查找又称为二分查找，是一种效率较高的查找方法。
	 前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。
	 查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。
	
	 1  查找思想
	 用Low、High和Mid表示待查找区间的下界、上界和中间位置指针，初值为Low=0，High=n - 1。
	 ⑴  取中间位置Mid：Mid=Math.floor((Low+High)/2)；
	 ⑵  比较中间位置记录的关键字与给定的K值：
	 ①  相等： 查找成功；
	 ②  大于：待查记录在区间的前半段，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段，修改下界指针：Low=Mid+1，转⑴ ；
	 直到越界(Low>High)，查找失败。
	
	 2  算法分析
	 ①  查找时每经过一次比较，查找范围就缩小一半，该过程可用一棵二叉树表示：
	 ◆ 根结点就是第一次进行比较的中间位置的记录；
	 ◆ 排在中间位置前面的作为左子树的结点；
	 ◆ 排在中间位置后面的作为右子树的结点；
	 对各子树来说都是相同的。这样所得到的二叉树称为判定树(Decision Tree)。
	 ②  将二叉判定树的第Math.floor(Math.log(2, n))+1层上的结点补齐就成为一棵满二叉树，深度不变，h= Math.floor(Math.log(2, n + 1)) 。
	 ③  由满二叉树性质知，第i 层上的结点数为Math.pow(2, i-1)(i<=h) ，设表中每个记录的查找概率相等，即Pi=1/n，查找成功时的平均查找长度ASL：
	 (n+1)/n*Math.log(2,n+1)-1
	 当n很大 (n>50)时， ASL≈ Math.log(2,n+1)-1。
	
	
	 时间复杂度O(logn)
	 */
	
	// 非递归式
	function binarySearch(sTable, key) {
	    var low = 0;
	    var high = sTable.length - 1;
	
	    while (low <= high) {
	        var mid = low + high >> 1;
	        var elem = sTable[mid];
	
	        if (elem === key) return mid;else if (elem < key) low = mid + 1;else high = mid - 1;
	    }
	
	    return -1;
	}
	
	console.log('binarySearch: ');
	console.log(binarySearch([1, 2, 3, 4, 5], 1)); // 0
	
	// 递归式
	function binarySearchRecursive(sTable, key) {
	    var low = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var high = arguments.length <= 3 || arguments[3] === undefined ? sTable.length - 1 : arguments[3];
	
	    if (low > high) return -1;
	
	    var mid = low + high >> 1;
	    var elem = sTable[mid];
	
	    if (elem === key) return mid;else if (elem < key) return binarySearchRecursive(sTable, key, mid + 1, high);else return binarySearchRecursive(sTable, key, low, mid - 1);
	}
	
	console.log('binarySearchRecursive: ');
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 1)); // 0
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TrieTree = exports.DoubleLinkedTree = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/1/11.
	 */
	
	/*
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，也叫字典树，来表示这样的字符串的集合。
	
	 概念
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。键树又称为数字查找树（Digital Search Tree)或Trie树(trie为retrieve中间4个字符)，其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A,B,C,....Z的单词所在页,再对各部分标出第二字母为A,B,C,...Z的单词所在的页, ....等等。
	
	 键树是一种特殊的查找树，它的某个节点不是包含一个或多个关键字，而是只包含组成关键字的一部分（字符或数字），比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。
	
	 根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。事实上，还可以赋予“字符串”更广泛的含义，它可以是任何类型的对象组成的串。
	
	
	 键树的存储
	 1）双链树表示
	 2) 多重链表表示
	
	
	 键树的应用场景
	
	 Trie是一种非常简单高效的数据结构，但有大量的应用实例。
	 （1） 字符串检索
	 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
	 举例：
	 @  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
	 @  给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。
	
	 （2）字符串最长公共前缀
	 Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
	 举例：
	 @ 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？
	 解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
	 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
	 1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
	 2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；
	 （关于并查集，Tarjan算法，RMQ问题，网上有很多资料。）
	
	 （3）排序
	 Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
	 举例：
	 @ 给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。
	
	 （4） 作为其他数据结构和算法的辅助结构
	 如后缀树，AC自动机等
	 */
	
	/*
	 双链树表示
	
	 以树的孩子兄弟链表来表示键树，则每个分支结点包括三个域：
	 symbol域：存储关键字的一个字符；
	 first域：存储指向第一棵子树根的指针；
	 next域：存储指向右兄弟的指针。
	
	 同时，叶子结点不含first域，它的infoptr域存储指向该关键字记录的指针。
	 此时的键树又称双链树。
	 在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。
	 结点的结构中可以设置一个枚举变量表示结点的类型，叶子结点和分支结点。
	 叶子结点和分支结点都有symbol域和next域。不同的一个域可以用联合表示，叶子结点包含infoptr指向记录，而分支结点是first域指向其第一棵子树。
	
	
	 双链树的查找
	
	 假设给定值为K.ch(0..num-1), 其中K.ch[0]至 K.ch[num-2]表示待查关键字中num-1个字符， K.ch[num-1]为结束符$。
	 从双链树的根指针出发，顺first指针找到第一棵子树的根结点，以K.ch[0]和此结点的symbol域比较，若相等，则顺first域再比较下一字符，否则沿next域顺序查找。
	 若直至空仍比较不等，则查找不成功。
	
	 // 相关资料
	 http://www.cnblogs.com/rollenholt/archive/2012/04/24/2468932.html
	 http://blog.csdn.net/v_july_v/article/details/6897097
	 http://www.raychase.net/1783
	 */
	
	var LEAF = 'leaf';
	var BRANCH = 'branch';
	var TERMINAL = new String('$');
	
	var DoubleLinkedTree = exports.DoubleLinkedTree = function () {
	    function DoubleLinkedTree() {
	        var symbol = arguments.length <= 0 || arguments[0] === undefined ? 'root' : arguments[0];
	        var kind = arguments.length <= 1 || arguments[1] === undefined ? BRANCH : arguments[1];
	        var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, DoubleLinkedTree);
	
	        this.symbol = symbol;
	        this.next = null;
	        this.kind = kind;
	        this.info = info;
	        this.first = null;
	    }
	
	    (0, _createClass3.default)(DoubleLinkedTree, [{
	        key: 'synoSearch',
	        value: function synoSearch(key) {
	            var p = this.first;
	
	            for (var i = 0; p && i < key.length; ++i) {
	                if (p && p.kind === LEAF) break;
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) p = p.first;else p = null;
	            }
	
	            return p && p.kind === LEAF ? p.info : null;
	        }
	    }, {
	        key: 'search',
	        value: function search(key) {
	            var p = this.first;
	
	            for (var i = 0; p && i < key.length; ++i) {
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) p = p.first;else p = null;
	            }
	
	            return p && p.kind === LEAF ? p.info : null;
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key, value) {
	            key += '';
	            var cur = this;
	
	            for (var i = 0; i < key.length; ++i) {
	                var c = key[i];
	                var p = cur;
	                cur = cur.first;
	                var node = new DoubleLinkedTree(c, BRANCH);
	
	                // 如果没有子结点则将新结点作为子结点
	                if (!cur) {
	                    p.first = node;
	                    node.parent = p;
	                    cur = node;
	                } else {
	                    // 在兄弟结点中找到对应结点
	                    if (c < cur.symbol) {
	                        node.parent = cur.parent;
	                        node.next = cur;
	                        node.parent.first = node;
	                        cur = node;
	                    } else if (c > cur.symbol) {
	                        var b = void 0;
	                        while (cur) {
	                            // 如果相等，退出该循环查找下一字符
	                            if (c === cur.symbol) break;
	                            // 如果小于当前字符，则插入到当前结点前面
	                            else if (c < cur.symbol) {
	                                    node.parent = cur.parent;
	                                    node.next = cur;
	                                    b.next = node;
	                                    cur = node;
	                                    break;
	                                } else {
	                                    b = cur;
	                                    cur = cur.next;
	                                }
	                        }
	
	                        // 如果没有兄弟结点则插入到兄弟结点
	                        if (!cur) {
	                            b.next = node;
	                            node.parent = b.parent;
	                            cur = node;
	                        }
	                    }
	                }
	            }
	
	            // 生成叶子结点
	            var success = false;
	            if (cur.kind === BRANCH) {
	                var child = cur.first;
	
	                // 如果不存在关键字则说明插入成功，否则插入失败
	                if (!(child && child.symbol === TERMINAL)) {
	                    cur.first = new DoubleLinkedTree(TERMINAL, LEAF, value != null ? value : key);
	                    cur.first.parent = cur;
	                    cur.first.next = child;
	                    success = true;
	                }
	            }
	
	            return success;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            var p = this.first;
	            var i = 0;
	
	            while (p && i < key.length) {
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) {
	                    p = p.first;
	                    ++i;
	                } else return false;
	            }
	
	            var data = p.info;
	            while (!p.next && p.parent) {
	                p = p.parent;
	            }var top = p;
	
	            if (top == this) {
	                this.first = null;
	                return data;
	            }
	
	            p = top.parent;
	            if (p) {
	                p = p.first;
	                while (p) {
	                    var pre = void 0;
	                    if (p == top) {
	                        // 删除在first域上的子树结点
	                        if (!pre) top.parent.first = top.parent.first.next;
	                        // 删除在next域的兄弟结点
	                        else pre.next = pre.next.next;
	
	                        return data;
	                    } else {
	                        pre = p;
	                        p = p.next;
	                    }
	                }
	            }
	
	            return false;
	        }
	    }]);
	    return DoubleLinkedTree;
	}();
	
	var test = new DoubleLinkedTree();
	test.insert('CAI');
	test.insert('LAN');
	test.insert('CAO');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CHAO');
	test.insert('CHEN');
	test.insert('LI');
	test.insert('LIU');
	test.insert('ZHAO');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('CAI'));
	console.log(test.search('CHA'));
	console.log(test.search('CHANG'));
	console.log(test.search('ZHAOx'));
	
	console.log('\nremove:');
	console.log(test.remove('CAI'));
	console.log(test.remove('CAI'));
	console.log(test.remove('LAN'));
	console.log(test.remove('CAO'));
	console.log(test.remove('CHA'));
	console.log(test.remove('CHANG'));
	console.log(test.remove('CHAO'));
	console.log(test.remove('CHEN'));
	console.log(test.remove('LI'));
	console.log(test.remove('LIU'));
	console.log(test.remove('ZHAO'));
	
	/*
	 多重链表表示
	
	 若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树。
	 （Trie是从检索retrieve中取中间四个字符的，读音同try）。
	 若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。
	 在Trie树中有两种结点：
	 分支结点：含有d个指针域和一个指示该结点中非空指针域的个数的整数域。在分支结点中不设数据域，每个分支结点所表示的字符均有其父结点中指向该结点的指针所在位置决定。
	 叶子结点：含有关键字域和指向记录的指针域。
	
	
	 在Trie树上进行查找
	
	 从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功，若分支结点中和给定值相应的指针为空，或叶子结点中的关键字和给定值不相等，则查找不成功。
	
	
	 优化Trie树的深度
	
	 我们可对关键字集选择一种合适的分割。先按首字符不通分成多个子集之后，然后按最后一个字符不同分割每个子集，再按第二个字符。。。前后交叉分割。一缩减Trie树的深度
	 */
	// 求字符在字母表中的序号
	function order(c) {
	    return c ? c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1 : 0;
	}
	
	// 通过回溯法清理Trie树的函数
	function removeNode(trieNode, order, clear) {
	    trieNode.branch.nodes[order] = null;
	    --trieNode.branch.num;
	
	    if (!clear) return;
	
	    var nodes = trieNode.branch.nodes;
	    var parent = trieNode.parent;
	    var pre = trieNode;
	
	    while (parent) {
	        for (var i in nodes) {
	            if (nodes.hasOwnProperty(i) && nodes[i]) return;
	        }
	
	        var index = void 0;
	        var parentNodes = parent.branch.nodes;
	        for (var _i in parentNodes) {
	            if (parentNodes.hasOwnProperty(_i) && parentNodes[_i] && parentNodes[_i] == pre) index = _i;
	        }
	        parent.branch.nodes[index] = null;
	        --parent.branch.num;
	
	        pre = parent;
	        nodes = parent.branch.nodes;
	        parent = parent.parent;
	    }
	}
	
	var TrieTree = exports.TrieTree = function () {
	    function TrieTree(kind) {
	        (0, _classCallCheck3.default)(this, TrieTree);
	
	        this.kind = kind || BRANCH;
	        this.parent = null;
	
	        if (kind === LEAF) {
	            this.leaf = {
	                key: null,
	                info: null
	            };
	        } else {
	            this.branch = {
	                // “$”为第一个字符，后续为26个字母
	                nodes: new Array(27),
	                num: 0
	            };
	        }
	    }
	
	    (0, _createClass3.default)(TrieTree, [{
	        key: 'search',
	        value: function search(key) {
	            var p = this,
	                i = 0;
	            for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {}
	
	            if (p) {
	                if (p.kind === LEAF && p.leaf.key === key) return p.leaf.info;
	                // 同义词
	                else if (p.kind === BRANCH) {
	                        p = p.branch.nodes[0];
	                        if (p && p.leaf.key === key) return p.leaf.info;
	                    }
	            }
	
	            return null;
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key, value) {
	            // 建叶子结点
	            var q = new TrieTree(LEAF);
	            q.leaf.key = key;
	            q.leaf.info = value;
	
	            // 自上而下查找
	            var last = void 0;
	            var p = this,
	                i = 0;
	            for (; p && p.kind === BRANCH && i < key.length && p.branch.nodes[order(key[i])]; p = p.branch.nodes[order(key[i])], ++i) {
	                last = p;
	            } // 如果最后落到分支结点（无同义词）
	            // 直接连上叶子
	            if (p.kind === BRANCH) {
	                p.branch.nodes[order(key[i])] = q;
	                q.parent = p;
	                ++p.branch.num;
	            }
	            // 如果最后落到叶子结点（有同义词）
	            else {
	                    if (p.leaf.key === key) return false;
	
	                    // 建立新的分支结点
	                    var r = new TrieTree(BRANCH);
	                    // 用新的分支结点取代老叶子结点和上一层的联系
	                    last.branch.nodes[order(key[i - 1])] = r;
	                    r.parent = last;
	                    r.branch.num = 2;
	                    r.branch.nodes[order(key[i])] = q;
	                    q.parent = r;
	                    // 新分支结点与新老两个叶子结点相连
	                    r.branch.nodes[order(p.leaf.key[i])] = p;
	                    p.parent = r;
	                }
	
	            return true;
	        }
	
	        /**
	         *
	         * @param key
	         * @param {Boolean} clear 是否需要清理结点
	         * @returns {*} 如果删除成功返回info数据否则返回false
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key, clear) {
	            var last = void 0;
	            var p = this,
	                i = 0;
	            // 查找待删除元素
	            for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {
	                last = p;
	            }if (!p) return false;
	
	            clear = typeof clear !== 'undefined' ? clear : true;
	            var data = null;
	
	            if (p.kind === LEAF && p.leaf.key === key) {
	                data = p.leaf.info;
	                removeNode(last, order(key[i - 1]), clear);
	                return data;
	            } else if (p.kind === BRANCH) {
	                p = p.branch.nodes[0];
	                if (p && p.leaf.key === key) {
	                    data = p.leaf.info;
	                    removeNode(p.parent, 0, clear);
	                    return data;
	                }
	            }
	
	            return false;
	        }
	    }]);
	    return TrieTree;
	}();
	
	var test = new TrieTree();
	
	test.insert('CHA');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CAI');
	test.insert('CHEN');
	test.insert('CAO');
	test.insert('CHAO');
	test.insert('LONG');
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');
	test.insert('WANG');
	test.insert('WEN');
	test.insert('WU');
	test.insert('YANG');
	test.insert('YUN');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('YUN'));
	console.log(test.search('ZHAO'));
	console.log(test.search('CHA'));
	
	test.remove('LAN');
	test.remove('LIU');
	test.remove('WANG');
	test.remove('WEN');
	test.remove('WU');
	test.remove('YANG');
	test.remove('YUN');
	test.remove('ZHAO');
	test.remove('CHA');
	test.remove('CHANG');
	test.remove('CAI');
	test.remove('CHEN');
	test.remove('CAO');
	test.remove('CHAO');
	test.remove('LONG');
	test.remove('LI');
	
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');
	
	/*
	 关于字典树的优化的数据结构有Patricia Tree，Suffix Tree
	 todo 有空再实现

	 相关资料：
	 http://blog.csdn.net/ljsspace/article/details/6571414
	 */

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LinkedListHashTable = exports.HashTable = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LinkedList = __webpack_require__(56);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hashSize = buildHashSize(977, 20); /**
	                                        * HashTable
	                                        * Created by Luke on 2014/12/30.
	                                        */
	
	/**
	哈希(散列)查找
	
	基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。
	
	基本概念
	
	哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数。
	哈希函数是一种映象，是从关键字空间到存储地址空间的一种映象。可写成：addr(ai)=H(ki) ，其中i是表中一个元素，addr(ai)是ai的地址， ki是ai的关键字。
	
	哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表。
	
	哈希查找(又叫散列查找)：利用哈希函数进行查找的过程叫哈希查找。
	
	冲突：对于不同的关键字ki、kj，若kikj，但H(ki)=H(kj)的现象叫冲突(collision) 。
	
	同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。
	哈希函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；当冲突发生时，应该有处理冲突的方法。设计一个散列表应包括：
	①  散列表的空间范围，即确定散列函数的值域；
	②  构造合适的散列函数，使得对于所有可能的元素(记录的关键字)，函数值均在散列表的地址空间范围内，且出现冲突的可能尽量小；
	③  处理冲突的方法。即当冲突出现时如何解决。
	
	
	哈希函数的构造
	
	哈希函数是一种映象，其设定很灵活，只要使任何关键字的哈希函数值都落在表长允许的范围之内即可。哈希函数“好坏”的主要评价因素有：
	◆ 散列函数的构造简单；
	◆ 能“均匀”地将散列表中的关键字映射到地址空间。所谓“均匀”(uniform)是指发生冲突的可能性尽可能最少。
	
	1  直接定址法
	取关键字或关键字的某个线性函数作哈希地址，即H(key)=key    或   H(key)=a·key+b(a,b为常数)
	特点：直接定址法所得地址集合与关键字集合大小相等，不会发生冲突，但实际中很少使用。
	
	2  数字分析法
	对关键字进行分析，取关键字的若干位或组合作为哈希地址。
	适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。
	例： 设有80个记录，关键字为8位十进制数，哈希地址为2位十进制数。
	           
	8  1  3  4  6  5  3  2
	8  1  3  7  2  2  4  2
	8  1  3  8  7  4  2  2
	8  1  3  0  1  3  6  7
	8  1  3  2  2  8  1  7
	8  1  3  3  8  9  6  7
	8  1  3  6  8  5  3  7
	8  1  4  1  9  3  5  5
	分析：  只取8
	       只取1
	       只取3、4
	       只取2、7、5
	      数字分布近乎随机
	所以：取任意两位或两位与另两位的叠加作哈希地址
	
	3  平方取中法
	将关键字平方后取中间几位作为哈希地址。
	一个数平方后中间几位和数的每一位都有关，则由随机分布的关键字得到的散列地址也是随机的。散列函数所取的位数由散列表的长度决定。这种方法适于不知道全部关键字情况，是一种较为常用的方法。
	
	4  折叠法
	将关键字分割成位数相同的几部分(最后一部分可以不同)，然后取这几部分的叠加和作为哈希地址。
	数位叠加有移位叠加和间界叠加两种。
	◆ 移位叠加：将分割后的几部分低位对齐相加。
	◆ 间界叠加：从一端到另一端沿分割界来回折迭，然后对齐相加。
	适于关键字位数很多，且每一位上数字分布大致均匀情况。
	例： 设关键字为0442205864，哈希地址位数为4 。两种不同的地址计算方法如下：
	    5864                        5864
	    4220                        0224
	      04       移位叠加            04           间界叠加
	 ---------                  -------------
	   10088                        6091
	
	5  除留余数法
	取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p     (p<=m)
	是一种简单、常用的哈希函数构造方法。
	利用这种方法的关键是p的选取，p选的不好，容易产生同义词。p的选取的分析：
	◆  选取p=2i(p<=m)：运算便于用移位来实现，但等于将关键字的高位忽略而仅留下低位二进制数。高位不同而低位相同的关键字是同义词。
	◆ 选取p=q*f(q、f都是质因数，p<=m)：则所有含有q或f因子的关键字的散列地址均是q或f的倍数。
	◆ 选取p为素数或p=q*f(q、f是质数且均大于20，p<=m)：常用的选取方法，能减少冲突出现的可能性。
	
	6  随机数法
	取关键字的随机函数值作哈希地址，即H(key)=random(key)
	当散列表中关键字长度不等时，该方法比较合适。
	
	
	
	选取哈希函数，考虑以下因素
	◆ 计算哈希函数所需时间；
	◆ 关键字的长度；
	◆ 哈希表长度（哈希地址范围）；
	◆ 关键字分布情况；
	◆ 记录的查找频率。
	
	
	
	冲突处理的方法
	冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。
	
	1  开放定址法
	基本方法：当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。散列地址的计算公式是：
	Hi(key)=(H(key)+di)  MOD m，i=1, 2, …, k(k<=m-1)
	
	其中：H(key)：哈希函数；m：散列表长度；
	di：第i次探测时的增量序列；
	Hi(key) ：经第i次探测后得到的散列地址。
	
	⑴  线性探测法
	将散列表T[0 …m-1]看成循环向量。当发生冲突时，从初次发生冲突的位置依次向后探测其他的地址。
	增量序列为：di=1, 2, 3, …, m-1
	设初次发生冲突的地址是h，则依次探测T[h+1]，T[h+2]…，直到T[m-1]时又循环到表头，再次探测T[0]，T[1]…，直到T[h-1]。探测过程终止的情况是：
	◆ 探测到的地址为空：表中没有记录。若是查找则失败；若是插入则将记录写入到该地址；
	◆ 探测到的地址有给定的关键字：若是查找则成功；若是插入则失败；
	◆ 直到T[h]：仍未探测到空地址或给定的关键字，散列表满。
	
	例1 ：设散列表长为7，记录关键字组为：15, 14, 28, 26, 56, 23，散列函数：H(key)=key   MOD  7，冲突处理采用线性探测法。
	H(15)=15  MOD 7=1
	H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0  冲突   H1(28)=1  又冲突
	H2(28)=2           H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=2   又冲突    H3(56)=3
	H(23)=23  MOD 7=2     冲突      H1(23)=3     又冲突
	H3(23)=4
	
	0     1      2      3      4       5     6
	14    15     28     56     23      26
	
	线性探测法的特点
	◆ 优点：只要散列表未满，总能找到一个不冲突的散列地址；
	◆ 缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而又增加了更多的冲突机会(这种现象称为冲突的“聚集”)。
	
	⑵  二次探测法
	增量序列为：di=1²,-1²,2²,-2²,3²,……±k²  (k<=⌊m/2⌋)
	
	上述例题若采用二次探测法进行冲突处理，则：
	H(15)=15  MOD 7=1         H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0     冲突      H1(28)=1     又冲突
	H2(28)=4
	H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=0   又冲突    H3(56)=4    又冲突
	H4(56)=2
	H(23)=23  MOD 7=2      冲突
	H1(23)=3
	
	二次探测法的特点
	◆ 优点：探测序列跳跃式地散列到整个表中，不易产生冲突的“聚集”现象；
	◆ 缺点：不能保证探测到散列表的所有地址。
	
	⑶   伪随机探测法
	增量序列使用一个伪随机函数来产生一个落在闭区间[1，m-1]的随机序列。
	
	例2 ： 表长为11的哈希表中已填有关键字为17，60，29的记录，散列函数为H(key)=key  MOD  11 。 现有第4个记录，其关键字为38，按三种处理冲突的方法，将它填入表中。
	
	(1)  H(38)=38 MOD 11=5    冲突
	     H1=(5+1) MOD 11=6    冲突
	     H2=(5+2) MOD 11=7    冲突
	     H3=(5+3) MOD 11=8    不冲突
	(2)  H(38)=38 MOD 11=5      冲突
	     H1=(5+1²) MOD 11=6    冲突
	     H2=(5-1²) MOD 11=4     不冲突
	(3)  H(38)=38 MOD 11=5    冲突
	     设伪随机数序列为9，则H1=(5+9) MOD 11=3 不冲突
	
	
	2  再哈希法
	构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即：Hi=RHi(key)     i=1, 2, …, k
	RHi ：一组不同的哈希函数。第一次发生冲突时，用RH1计算，第二次发生冲突时，用RH2计算…依此类推知道得到某个Hi不再冲突为止。
	◆  优点：不易产生冲突的“聚集”现象；
	◆  缺点：计算时间增加。
	
	
	3  链地址法
	方法：将所有关键字为同义词(散列地址相同)的记录存储在一个单链表中，并用一维数组存放链表的头指针。
	设散列表长为m，定义一个一维指针数组：
	RecNode *linkhash[m]，其中RecNode是结点类型，每个分量的初值为空。凡散列地址为k的记录都插入到以linkhash[k]为头指针的链表中，插入位置可以在表头或表尾或按关键字排序插入。
	
	例： 已知一组关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79) ，哈希函数为：H(key)=key MOD 13，用链地址法处理冲突:
	
	 0
	 1  --> 14 -> 1 -> 27 -> 79
	 2
	 3  --> 68 -> 55
	 4
	 5
	 6  --> 19 -> 84
	 7  --> 20
	 8
	 9
	 10 --> 23 -> 10
	 11 --> 11
	 12
	
	 优点：不易产生冲突的“聚集”；删除记录也很简单。
	
	
	 4  建立公共溢出区
	 方法：在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。
	 设散列表长为m，设立基本散列表hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。
	
	 例： 已知一组关键字(15, 4, 18, 7, 37, 47) ，散列表长度为7 ，哈希函数为：H(key)=key MOD 7，用建立公共溢出区法处理冲突。得到的基本表和溢出表如下：
	                    散列地址    0     1     2     3     4     5     6
	 Hashtable表：
	                    关键字     7     15    37          4     47
	
	                    溢出地址    0     1     2     3     4     5     6
	 overtable表：
	                     关键字    18
	
	
	
	
	 哈希查找过程及分析
	
	 1   哈希查找过程
	 哈希表的主要目的是用于快速查找，且插入和删除操作都要用到查找。由于散列表的特殊组织形式，其查找有特殊的方法。
	
	 给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定关键字相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直到哈希表中某个位置为空或者表中所填记录的关键字等于给定值时为止。
	
	
	
	 哈希查找分析
	
	 从哈希查找过程可见：尽管散列表在关键字与记录的存储地址之间建立了直接映象，但由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用ASL。
	 哈希查找时关键字与给定值比较的次数取决于：
	 ◆ 哈希函数；
	 ◆ 处理冲突的方法；
	 ◆ 哈希表的填满因子α 。填满因子α的定义是：
	
	 α = 表中填入的记录数 / 哈希表长度
	
	
	 各种散列函数所构造的散列表的ASL如下：
	
	 ⑴   线性探测法的平均查找长度是：
	 S成功 约等于 1 / 2 * (1 + 1 / (1 - α))
	 S失败 约等于 1 / 2 * (1 + 1 / (1 - α) * (1 - α))
	
	 ⑵   二次探测、伪随机探测、再哈希法的平均查找长度是：
	 S成功 约等于 -1 / α * ln(1 - α)
	 S失败 约等于 1 / (1 - α)
	
	 ⑶   用链地址法解决冲突的平均查找长度是：
	 S成功 约等于 1 + α / 2
	 S失败 约等于 α + e的-α次幂
	
	
	 */
	
	var HashTable = exports.HashTable = function () {
	    function HashTable() {
	        (0, _classCallCheck3.default)(this, HashTable);
	
	        this.data = [];
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	    }
	
	    // 使用线性探测法解决冲突
	
	
	    (0, _createClass3.default)(HashTable, [{
	        key: 'search',
	        value: function search(key) {
	            var max = hashSize[this.sizeIndex];
	            var p = hash(key, max);
	            var c = 0;
	
	            while (p < max && this.data[p] != null && key !== this.data[p]) {
	                p = collision(key, ++c, max);
	            }
	
	            return {
	                success: key === this.data[p],
	                collisionTimes: c,
	                index: p
	            };
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            var max = hashSize[this.sizeIndex];
	            if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	            var ret = this.search(key);
	            var p = ret.index;
	            var c = ret.collisionTimes;
	
	            if (ret.success) return false;else if (c < hashSize[this.sizeIndex] / 2) {
	                this.data[p] = key;
	                ++this.count;
	                return true;
	            } else {
	                this.recreateHashTable();
	                return false;
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            if (!this.count) return false;
	
	            var max = hashSize[this.sizeIndex];
	            var p = hash(key, max);
	            var c = 0;
	
	            while (key !== this.data[p]) {
	                p = collision(key, ++c, max);
	            }if (key === this.data[p]) {
	                var data = this.data[p];
	                this.data.splice(p, 1);
	                --this.count;
	
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'recreateHashTable',
	        value: function recreateHashTable() {
	            return ++this.sizeIndex < hashSize.length;
	        }
	    }]);
	    return HashTable;
	}();
	
	;
	
	// ELFhash字符串散列函数
	function hash(str, max) {
	    var hash = 0;
	    for (var i = 0; i < str.length; i++) {
	        hash = (hash << 5) + hash + str.charCodeAt(i);
	        hash = hash & hash; // Convert to 32bit integer
	        hash = Math.abs(hash);
	    }
	    return hash % max;
	}
	
	function collision(key, times, max) {
	    // 线性探测法
	    return (hash(key, max) + times) % max;
	}
	
	function isPrime(n) {
	    if (n <= 3) return n > 1;
	    if (n % 2 === 0 || n % 3 === 0) return false;
	    for (var i = 5; i * i <= n; i += 6) {
	        if (n % i === 0 || n % (i + 2) === 0) return false;
	    }
	
	    return true;
	}
	
	function buildHashSize(begin, length) {
	    var hashSize = [];
	
	    while (1) {
	        if (hashSize.length >= length) break;
	        if (isPrime(begin)) hashSize.push(begin);
	        ++begin;
	    }
	
	    return hashSize;
	}
	
	// 开放定址法
	//hashSize = [5, 7]; // for test. will be deleted
	var test = new HashTable();
	test.insert('17');
	test.insert('60');
	test.insert('29');
	test.insert('38');
	test.insert('39');
	test.insert('40');
	
	test.remove('17');
	test.remove('60');
	test.remove('29');
	test.remove('38');
	test.remove('39');
	test.remove('40');
	
	// 使用链地址法解决冲突的哈希表
	
	var LinkedListHashTable = exports.LinkedListHashTable = function () {
	    function LinkedListHashTable() {
	        (0, _classCallCheck3.default)(this, LinkedListHashTable);
	
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	        this.hNodes = [];
	    }
	
	    (0, _createClass3.default)(LinkedListHashTable, [{
	        key: 'search',
	        value: function search(key) {
	            var max = hashSize[this.sizeIndex];
	            var i = hash(key, max);
	            var t = this.hNodes;
	
	            if (t[i] == null) return { success: false, index: i };
	
	            var p = t[i];
	            var data = null;
	
	            p.each(function (node) {
	                if (node.data === key) {
	                    data = node.data;
	                    return true;
	                }
	            });
	
	            return { success: data === key, index: i };
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            var max = hashSize[this.sizeIndex];
	            if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	            var ret = this.search(key);
	            var index = ret.index;
	
	            if (ret.success) return false;
	
	            if (!this.hNodes[index]) this.hNodes[index] = new _LinkedList2.default();
	
	            if (this.hNodes[index].size() < hashSize[this.sizeIndex] / 2) {
	                this.hNodes[index].orderInsert(key);
	                ++this.count;
	                return true;
	            } else {
	                this.recreateHashTable();
	                return false;
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            if (!this.count) return false;
	
	            var ret = this.search(key);
	
	            if (ret.success) {
	                var index = ret.index;
	                var data = ret.data;
	                this.hNodes[index]['remove'](key);
	                --this.count;
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'recreateHashTable',
	        value: function recreateHashTable() {
	            return ++this.sizeIndex < hashSize.length;
	        }
	    }]);
	    return LinkedListHashTable;
	}();
	
	;
	
	var test2 = new LinkedListHashTable();
	test2.insert('17');
	test2.insert('60');
	test2.insert('29');
	test2.insert('38');
	test2.insert('39');
	test2.insert('40');
	
	test2.remove('17');
	test2.remove('60');
	test2.remove('29');
	test2.remove('38');
	test2.remove('39');
	test2.remove('40');

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.RedBlackNode = undefined;
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _getPrototypeOf = __webpack_require__(32);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(35);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(34);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinarySortedTree = __webpack_require__(58);
	
	var _BinarySortedTree2 = _interopRequireDefault(_BinarySortedTree);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RED = 'red'; /**
	                  * Red Black Tree
	                  * Created by Luke on 2014/12/30.
	                  */
	/*
	 http://blog.csdn.net/v_july_v/article/details/6105630
	
	 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
	 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
	
	 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。
	
	 红黑树的5个性质：
	 1.每个结点要么是红的要么是黑的。
	 2.根结点是黑的。
	 3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
	 4.如果一个结点是红的，那么它的两个儿子都是黑的。
	 5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
	
	 正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。
	
	
	 树的旋转
	
	当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。
	
	树的旋转分为左旋和右旋
	
	树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。
	
	
	红黑树的插入
	
	如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。
	但当遇到下述3种情况时又该如何调整呢？
	● 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况
	对此，我们的解决策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	于是，插入修复情况1转换成了插入修复情况2
	
	● 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	从而插入修复情况2转换成了插入修复情况3。
	
	● 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。
	
	经过上面情况3、情况4、情况5等3种插入修复情况的操作示意图，读者自会发现，后面的情况4、情况5都是针对情况3插入节点4以后，进行的一系列插入修复情况操作，不过，指向当前节点N指针一直在变化。所以，你可以想当然的认为：整个下来，情况3、4、5就是一个完整的插入修复情况的操作流程
	
	
	红黑树的删除
	
	在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。
	
	上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。
	
	 如果是以下情况，恢复比较简单：
	 a)当前节点是红+黑色
	 解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
	 b)当前节点是黑+黑且是根节点， 解法：什么都不做，结束。
	
	 但如果是以下情况呢？：
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
	 此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。
	
	 下面，咱们便来分别处理这4种删除修复情况。
	
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。
	
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变）
	
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持
	
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	
	
	 最后值得一提的是上述删除修复的情况1~4都只是树的局部，并非树的整体全部，且删除修复情况3、4在经过上面的调整后，调整还没结束,还得继续调整直至重新恢复平衡
	*/
	
	var BLACK = 'black';
	
	var RedBlackNode = exports.RedBlackNode = function (_BSTNode) {
	    (0, _inherits3.default)(RedBlackNode, _BSTNode);
	
	    function RedBlackNode() {
	        var _Object$getPrototypeO;
	
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        (0, _classCallCheck3.default)(this, RedBlackNode);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(RedBlackNode)).call.apply(_Object$getPrototypeO, [this, data].concat(rest)));
	
	        _this.leftChild = null;
	        _this.rightChild = null;
	        _this.parent = null;
	
	        _this.color = RED;
	        _this.data = data;
	        return _this;
	    }
	
	    return RedBlackNode;
	}(_BinarySortedTree2.default);
	
	var RedBlackLeaf = function RedBlackLeaf() {
	    (0, _classCallCheck3.default)(this, RedBlackLeaf);
	
	    this.color = BLACK;
	    this.leftChild = this;
	    this.rightChild = this;
	};
	
	var RedBlackTree = function () {
	    function RedBlackTree() {
	        (0, _classCallCheck3.default)(this, RedBlackTree);
	
	        // 哨兵
	        this.nil = new RedBlackLeaf();
	        this.root = this.nil;
	    }
	
	    /**
	     * 红黑树的递归查找算法
	     * @param data
	     */
	
	
	    (0, _createClass3.default)(RedBlackTree, [{
	        key: 'find',
	        value: function find(data) {
	            var z = this.root;
	            var me = this;
	
	            return function find(z, data) {
	                if (z == me.nil || data === z.data) return z;
	
	                if (data < z.data) return find(z.leftChild, data);else return find(z.rightChild, data);
	            }(z, data);
	        }
	
	        /**
	         * 红黑树的插入
	         * @param {*} data
	         */
	
	    }, {
	        key: 'add',
	        value: function add(data) {
	            var z = new RedBlackNode(data);
	            z.leftChild = this.nil;
	            z.rightChild = this.nil;
	            var y = this.nil;
	            var x = this.root;
	
	            // 找到要插入位置的结点y
	            while (x != this.nil) {
	                y = x;
	
	                if (z.data < x.data) x = x.leftChild;else x = x.rightChild;
	            }
	
	            z.parent = y;
	
	            // 如果y不是根结点，根据大小插入到左或右子树
	            if (y != this.nil) {
	                if (z.data < y.data) y.leftChild = z;else y.rightChild = z;
	            }
	            // 否则插入到根结点
	            else this.root = z == this.nil ? null : z;
	
	            // 插入修复操作
	            this._addFixup(z);
	        }
	
	        /**
	         * 插入算法修复
	         * @param {RedBlackNode} z 待插入的结点
	         * @private
	         */
	
	    }, {
	        key: '_addFixup',
	        value: function _addFixup(z) {
	
	            while (z != this.root && z.parent.color === RED) {
	                if (z.parent == z.parent.parent.leftChild) leftAddFixup(this, z);else rightAddFixup(this, z);
	            }
	
	            // 最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡
	            this.root.color = BLACK;
	        }
	
	        /**
	         * 红黑树的删除算法
	         * @param {RedBlackNode} z 待删除结点
	         */
	
	    }, {
	        key: 'removeNode',
	        value: function removeNode(z) {
	            var x = void 0,
	                y = void 0;
	
	            // 找到待删除结点的父结点或相邻待替换结点
	            if (z.leftChild == this.nil || z.rightChild == this.nil) y = z;else y = this.successor(z);
	
	            if (y.leftChild != this.nil) x = y.leftChild;else x = y.rightChild;
	
	            x.parent = y.parent;
	
	            // 删除操作
	            if (y.parent == this.nil) this.root = x;else if (y == y.parent.leftChild) y.parent.leftChild = x;else y.parent.rightChild = x;
	
	            if (y != z) z.data = y.data;
	
	            // 删除修复
	            if (y.color === BLACK) this._removeFixup(x);
	        }
	
	        // 算法导论上的删除结点
	
	    }, {
	        key: 'removeNode2',
	        value: function removeNode2(z) {
	            var y = z;
	            var originalYColor = y.color;
	            var x = void 0;
	
	            if (z.leftChild == this.nil) {
	                x = z.rightChild;
	                this._transplant(z, z.rightChild);
	            } else if (z.rightChild == this.nil) {
	                x = z.leftChild;
	                this._transplant(z, z.leftChild);
	            } else {
	                y = this.min(z.rightChild);
	                originalYColor = y.color;
	                x = y.rightChild;
	
	                if (y.parent == z) x.parent = y;else {
	                    this._transplant(y, y.rightChild);
	                    y.rightChild = z.rightChild;
	                    y.rightChild.parent = y;
	                }
	
	                this._transplant(z, y);
	                y.leftChild = z.leftChild;
	                y.leftChild.parent = y;
	                y.color = z.color;
	            }
	
	            if (originalYColor === BLACK) this._removeFixup(x);
	        }
	    }, {
	        key: '_transplant',
	        value: function _transplant(u, v) {
	            if (u.parent == this.nil) this.root = v;else if (u == u.parent.leftChild) u.parent.leftChild = v;else u.parent.rightChild = v;
	
	            v.parent = u.parent;
	        }
	
	        /**
	         * 删除修复
	         * @param {RedBlackNode} z
	         * @private
	         */
	
	    }, {
	        key: '_removeFixup',
	        value: function _removeFixup(z) {
	            while (z !== this.root && z.color === BLACK) {
	                if (z == z.parent.leftChild) leftRemoveFixup(this, z);else rightRemoveFixup(this, z);
	            }
	
	            z.color = BLACK;
	        }
	    }, {
	        key: 'successor',
	        value: function successor(z) {
	            if (z.rightChild != this.nil) return this.min(z.rightChild);
	
	            var y = z.parent;
	
	            while (y != this.nil && z == y.rightChild) {
	                z = y;
	                y = y.parent;
	            }
	
	            return y;
	        }
	    }, {
	        key: 'min',
	        value: function min(z) {
	            while (z.leftChild != this.nil) {
	                z = z.leftChild;
	            }
	
	            return z;
	        }
	
	        /**
	         * 根据key值删除结点
	         * @param {*} key
	         * @returns {*}
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            var z = this.find(key);
	
	            if (z == this.nil) return false;
	
	            return this.removeNode(z);
	        }
	    }]);
	    return RedBlackTree;
	}();
	
	RedBlackTree.prototype._rotateLeft = rotate('left');
	RedBlackTree.prototype._rotateRight = rotate('right');
	
	function rotate(dir) {
	    var c1 = void 0,
	        c2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	    }
	
	    return function (x) {
	        var y = x[c1];
	        x[c1] = y[c2];
	
	        if (y[c2] != this.nil) y[c2].parent = x;
	        y.parent = x.parent;
	
	        if (x.parent == this.nil) this.root = y;else if (x == x.parent[c2]) x.parent[c2] = y;else x.parent[c1] = y;
	
	        y[c2] = x;
	        x.parent = y;
	    };
	}
	
	function addFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        rotate1 = void 0,
	        rotate2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        rotate1 = '_rotateLeft';
	        rotate2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        rotate1 = '_rotateRight';
	        rotate2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var y = z.parent.parent[c1];
	
	        // 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	        // 将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	        if (y.color === RED) {
	            z.parent.color = BLACK;
	            y.color = BLACK;
	            z.parent.parent.color = RED;
	            z = z.parent.parent;
	        } else {
	            // 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	            // 解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	            // 从而插入修复情况2转换成了插入修复情况3。
	            if (z === z.parent[c1]) {
	                z = z.parent;
	                tree[rotate1](z);
	            }
	
	            // 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	            // 解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	            z.parent.color = BLACK;
	            z.parent.parent.color = RED;
	            tree[rotate2](z.parent.parent);
	        }
	    };
	}
	
	var leftAddFixup = addFixup('left');
	var rightAddFixup = addFixup('right');
	var leftRemoveFixup = removeFixup('left');
	var rightRemoveFixup = removeFixup('right');
	
	function removeFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        r1 = void 0,
	        r2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        r1 = '_rotateLeft';
	        r2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        r1 = '_rotateRight';
	        r2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var w = z.parent[c1];
	
	        // 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	        // 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法
	        if (w.color === RED) {
	            w.color = BLACK;
	            z.parent.color = RED;
	            tree[r1](z.parent);
	            w = z.parent[c1];
	        }
	
	        // 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	        // 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。
	        if (w[c2].color === BLACK && w[c1].color === BLACK) {
	            w.color = RED;
	            z = z.parent;
	        } else {
	            // 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	            // 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。
	            if (w[c1].color === BLACK) {
	                w[c2].color = BLACK;
	                w.color = RED;
	                tree[r2](w);
	                w = z.parent[c1];
	            }
	
	            // 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	            // 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	            w.color = z.parent.color;
	            z.parent.color = BLACK;
	            w[c1].color = BLACK;
	            tree[r1](z.parent);
	            z = tree.root;
	        }
	    };
	}
	
	var test = new RedBlackTree();
	test.add(13);
	test.add(8);
	test.add(17);
	test.add(1);
	test.add(6);
	test.add(11);
	test.add(15);
	test.add(22);
	test.add(25);
	test.add(27);
	
	test.remove(13);
	test.remove(8);
	test.remove(17);
	test.remove(1);
	test.remove(6);
	test.remove(11);
	test.remove(15);
	test.remove(22);
	test.remove(25);
	test.remove(27);

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _BinaryTree = __webpack_require__(18);
	
	/**
	 * 由有序表sTable[low..high]及其累计权值表weights递归构造次优查找树
	 * @param {BinaryTree} tree
	 * @param {Array} sTable
	 * @param {Array} sWeights
	 * @param {Number} low
	 * @param {Number} high
	 */
	function secondOptimal(tree, sTable, sWeights, low, high) {
	    var i = low;
	    var min = Math.abs(sWeights[high] - sWeights[low]);
	    var dw = sWeights[high] + (sWeights[low - 1] || 0);
	
	    // 选择最小的△Pi值
	    for (var j = low + 1; j <= high; ++j) {
	        var t = Math.abs(dw - sWeights[j] - sWeights[j - 1]);
	        if (t < min) {
	            i = j;
	            min = t;
	        }
	    }
	
	    // 调整树根权，选择邻近权值较大的关键字
	    var a = 0,
	        b = void 0,
	        c = 0;
	    if (i - 1 >= low) b = sWeights[i] - sWeights[i - 1];
	    if (i - 2 >= low) a = sWeights[i - 1] - sWeights[i - 2];
	    if (i + 1 < high) c = sWeights[i + 1] - sWeights[i];
	    if (typeof b === 'number') {
	        if (a > c && a > b) --i;else if (a < c && c > b) ++i;
	    }
	
	    tree.data = sTable[i];
	    //左子树
	    if (i === low) tree.leftChild = null;else {
	        tree.leftChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.leftChild, sTable, sWeights, low, i - 1);
	    }
	    // 右子树
	    if (i === high) tree.rightChild = null;else {
	        tree.rightChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.rightChild, sTable, sWeights, i + 1, high);
	    }
	} /*
	   静态次优查找树
	  
	   适合各记录的查找概率不等的情况
	  
	   查找效率最高即平均查找长度最小，我们可以给出有序表在非等概率情况下应遵循的两个原则：
	   1、最先访问的结点应是访问概率最大的结点；
	   2、每次访问应使结点两边尚未访问的结点的被访概率之和尽可能相等。
	  
	  
	   这两个原则可用一句话来表示，即判定树为带权内路径长度之和最小的二叉树，亦即：PH = ∑wihi  最小，其中 n 为有序表长度，hi 为第 i 个结点在判定树上的层次数，wi = cpi，c 为某个常数，pi 为第 i 个结点的查找概率。
	  
	  
	   这样的树称为静态最优查找树（static optimal search tree），构造这样一棵树的时间代价太大，亦即时间复杂度很大，因此我们通常是构造次优查找树（nearly optimal search tree），构造它的时间代价远远低于构造最优查找树，但查找性能只比最优查找树差1%~2%，很少差3%以上。
	  
	   次优查找树的构造：
	  
	   设有序表每个记录的权值为 wl,wl+1,…,wh，第一个应访问的结点号为 i ，则有：
	   Δpi =   ∑wj - ∑wj   最小，即 Δpi = Min {Δpj }
	   再分别对 {rl,rl+1,…,ri-1} 和 {ri+1,ri+2,…,rh} 分别构造次优查找树
	   */
	
	
	var tree = new _BinaryTree.BinaryTree();
	secondOptimal(tree, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'], [1, 2, 4, 9, 12, 16, 20, 23, 28], 0, 8);
	console.log(tree);
	
	/**
	 * 由有序表构造一棵次优查找树
	 * @param {Object} obj 有序表，数据元素含有权域weight
	 */
	function createSOSTree(obj) {
	    var tree = void 0;
	    if (obj.elems.length === 0) tree = null;else {
	        // 求累计权值表
	        var sw = findSW(obj.weights);
	        tree = new _BinaryTree.BinaryTree();
	        secondOptimal(tree, obj.elems, sw, 0, obj.elems.length - 1);
	    }
	
	    return tree;
	}
	
	function findSW(sTable) {
	    var sw = [sTable[0]];
	
	    for (var i = 1; i < sTable.length; ++i) {
	        sw[i] = sw[i - 1] + sTable[i];
	    }
	
	    return sw;
	}
	
	var sosTree = createSOSTree({
	    elems: ['A', 'B', 'C', 'D', 'E'],
	    weights: [1, 30, 2, 29, 3]
	});
	sosTree.inOrderRecursive(function (value) {
	    console.log('inOrder: ' + value);
	});

/***/ },
/* 97 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 Fibonacci查找
	
	 Fibonacci查找方法是根据Fibonacci数列的特点对查找表进行分割。Fibonacci数列的定义是：
	 F(0)=0，F(1)=1，F(j)=F(j-1)+F(j-2) 。
	
	 1  查找思想
	 设查找表中的记录数比某个Fibonacci数小1，即设n=F(j)-1。用Low、High和Mid表示待查找区间的下界、上界和分割位置，初值为Low=0，High=n - 1。
	 ⑴   取分割位置Mid：Mid=F(j-1) ；
	 ⑵   比较分割位置记录的关键字与给定的K值：
	 ① 相等： 查找成功；
	 ②  大于：待查记录在区间的前半段(区间长度为F(j-1)-1)，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段(区间长度为F(j-2)-1)，修改下界指针：Low=Mid+1，转⑴ ；直到越界(Low>High)，查找失败。
	
	 2  算法实现
	 在算法实现时，为了避免频繁计算Fibonacci数，可用两个变量f1和f2保存当前相邻的两个Fibonacci数，这样在以后的计算中可以依次递推计算出。
	
	 3  算法分析
	 由算法知，Fibonacci查找在最坏情况下性能比折半查找差，但平均搜索次数少于折半查找，而且折半查找要求记录按关键字有序；Fibonacci查找的优点是分割时只需进行加、减运算。
	
	 */
	
	function fib(n) {
	    if (n === 0) return 0;
	    if (n === 1) return 1;
	    var f = void 0;
	    var f0 = 0;
	    var f1 = 1;
	    for (var i = 2; i <= n; ++i) {
	        f = f0 + f1;
	        f0 = f1;
	        f1 = f;
	    }
	    return f;
	}
	
	/**
	 * 在有序表ST中用Fibonacci方法查找关键字为key的记录
	 * @param sTable
	 * @param key
	 * @param n
	 */
	function fibonacciSearch(sTable, key) {
	    var n = arguments.length <= 2 || arguments[2] === undefined ? sTable.length : arguments[2];
	
	    var low = 0;
	    var high = n - 1;
	    var f1 = fib(n);
	    var f2 = fib(n - 1);
	
	    while (low <= high) {
	        var mid = low + f1 - 1;
	        if (sTable[mid] === key) return mid;else if (key < sTable[mid]) {
	            high = mid - 1;
	            f2 = f1 - f2;
	            f1 = f1 - f2;
	        } else {
	            low = mid + 1;
	            f1 = f1 - f2;
	            f2 = f2 - f1;
	        }
	    }
	    return -1;
	}
	
	console.log('fibonacciSearch: ');
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 5)); // 4
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 98 */
/***/ function(module, exports) {

	"use strict";
	
	/*
	 静态查找
	
	 线性表是查找表最简单的一种组织方式
	
	 顺序查找(Sequential Search)
	 1  查找思想
	 从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。
	
	 2  算法分析
	 不失一般性，设查找每个记录成功的概率相等，即Pi=1/n；查找第i个元素成功的比较次数Ci=n-i；
	 ◆ 查找成功时的平均查找长度ASL：(n+1)/2
	 ◆ 包含查找不成功时：查找失败的比较次数为n，若成功与不成功的概率相等，对每个记录的查找概率为Pi=1/(2n)，则平均查找长度ASL：3（n+1）/4
	 */
	
	function sequentialSearch(sTable, key) {
	  for (var i = sTable.length - 1; i >= 0 && sTable[i] !== key; --i) {}
	  return i;
	}
	
	console.log(sequentialSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Created by ldp on 2015/2/18.
	 */
	
	/*
	 计数排序
	
	 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。
	
	 计数排序的特征
	
	 当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
	 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
	 通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：
	 1.找出待排序的数组中最大和最小的元素
	 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项
	 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
	 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
	 
	 简要分析：
	 1.计数排序仅适合于小范围的数据进行排序
	 2.不能对浮点数进行排序
	 3.时间复杂度为 O(n)
	 4.计数排序是稳定的（排序后值相同的元素相对于原先的位置是不会发生变化的）
	 */
	
	function maxElem(arr) {
	    var max = arr[0];
	
	    for (var i = 1, len = arr.length; i < len; ++i) {
	        if (max < arr[i]) max = arr[i];
	    }return max;
	}
	
	/**
	 *
	 * @param {Array} sqList 要排序的数组
	 * @param {Number} k 数组中最大的元素值
	 * @returns {Array}
	 */
	function countSort(sqList, k) {
	    if (k == null) k = maxElem(sqList);
	    var len = sqList.length;
	    var c = [];
	    var b = [];
	
	    // 初始化辅助数组
	    for (var i = 0; i <= k; ++i) {
	        c[i] = 0;
	    } // 计数数组A中值等于C数组下标的个数
	    for (i = 0; i < len; ++i) {
	        c[sqList[i]]++;
	    } // 计数数组A中值小于等于C数组下标的个数
	    for (i = 1; i <= k; ++i) {
	        c[i] += c[i - 1];
	    }for (i = len - 1; i >= 0; --i) {
	        b[c[sqList[i]] - 1] = sqList[i];
	        --c[sqList[i]];
	    }
	
	    for (i = 0; i < len; ++i) {
	        sqList[i] = b[i];
	    }
	}
	exports.countSort = countSort;
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	countSort(arr, 100);
	console.log(arr + '');
	
	/*
	 基数排序
	
	 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。
	 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
	 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。
	
	 效率
	
	 基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，k的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。
	 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k = logB(N)，N是待排序数据类型全集的势。虽然有B个不同的数字，需要B个不同的桶，但在每一轮处理中，判断每个待排序数据项只需要一次计算确定对应数位的值，因此在每一轮处理的时候都需要平均n次操作来把整数放到合适的桶中去，所以就有：
	 k约等于logB(N)
	 所以，基数排序的平均时间T就是：
	 T～= logB(N)·n
	 其中前一项是一个与输入数据无关的常数，当然该项不一定小于logn
	 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且在适当选择的B之下，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。
	
	 假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。
	
	 基数排序的简单描述就是将数字拆分为个位十位百位，每个位依次排序。因为这对算法稳定要求高，所以我们对数位排序用到上一个排序方法计数排序。因为基数排序要经过d (数据长度)次排序， 每次使用计数排序， 计数排序的复杂度为 On),  d 相当于常量和N无关，所以基数排序也是 O(n)。基数排序虽然是线性复杂度， 即对n个数字处理了n次，但是每一次代价都比较高， 而且使用计数排序的基数排序不能进行原地排序，需要更多的内存， 并且快速排序可能更好地利用硬件的缓存， 所以比较起来，像快速排序这些原地排序算法更可取。对于一个位数有限的十进制数，我们可以把它看作一个多元组，从高位到低位关键字重要程度依次递减。可以使用基数排序对一些位数有限的十进制数排序。
	 */
	
	// 求数据的最大位数
	function maxBit(arr) {
	    var d = 1;
	    var p = 10;
	
	    for (var i = 0, n = arr.length; i < n; ++i) {
	        while (arr[i] >= p) {
	            p *= 10;
	            ++d;
	        }
	    }
	
	    return d;
	}
	
	function radixSort(arr, d) {
	    d = d || maxBit(arr);
	    var n = arr.length;
	    var temp = [];
	    // 计数器
	    var count = [];
	    var radix = 1;
	
	    // 进行d次排序
	    for (var i = 1; i <= d; ++i) {
	        // 每次分配前清空计数器
	        for (var j = 0; j < 10; ++j) {
	            count[j] = 0;
	        } // 统计每个桶中的记录数
	        for (j = 0; j < n; ++j) {
	            var k = Math.floor(arr[j] / radix) % 10;
	            ++count[k];
	        }
	        for (j = 1; j < 10; ++j) {
	            count[j] += count[j - 1];
	        } // 将所有桶中记录依次收集到tmp中
	        for (j = n - 1; j >= 0; --j) {
	            k = Math.floor(arr[j] / radix) % 10;
	            temp[--count[k]] = arr[j];
	        }
	        //将临时数组的内容复制到arr中
	        for (j = 0; j < n; ++j) {
	            arr[j] = temp[j];
	        }radix *= 10;
	    }
	}
	exports.radixSort = radixSort;
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	radixSort(arr, 100);
	console.log(arr + '');
	
	/*
	 桶排序
	
	 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。
	
	 基本思想
	
	 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
	 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。
	
	 分析
	
	 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
	 对N个关键字进行桶排序的时间复杂度分为两个部分：
	     (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
	     (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。
	 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
	     (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
	     (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。
	
	 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
	 O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
	 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。
	
	 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
	 */
	
	var BUCKETSNUM = 10;
	var quickSort = __webpack_require__(59).quickSort;
	
	function bucketSort(sqList) {
	    var n = sqList.length;
	    var bucketA = [];
	    var b = [];
	
	    // 初始化桶
	    for (var i = 0; i < BUCKETSNUM; ++i) {
	        b[i] = [];
	        bucketA[i] = 0;
	
	        for (var j = 0; j < n; ++j) {
	            b[i][j] = Infinity;
	        }
	    }
	
	    // 给桶填装数据
	    for (i = 0; i < n; ++i) {
	        var data = sqList[i];
	        // noto: 这里的映射函数是针对1-100之间的实数
	        var bucket = Math.floor(data / BUCKETSNUM);
	        b[bucket][bucketA[bucket]] = data;
	        ++bucketA[bucket];
	    }
	
	    // 针对每个桶进行快速排序
	    for (i = 0; i < BUCKETSNUM; ++i) {
	        if (bucketA[i] !== 0) {
	            quickSort(b[i], 0, bucketA[i] - 1);
	            //for(j = 1; j < bucketA[i]; ++j){
	            //    var p = b[i][j];
	            //    for(var k = j - 1; k >= 0 && p < b[i][k]; --k){
	            //        b[i][k + 1] = b[i][k];
	            //    }
	            //    b[i][k + 1] = p;
	            //}
	        }
	    }
	
	    //console.log(b);
	    //console.log(bucketA);
	
	    // 复制回去
	    var num = 0;
	    for (i = 0; i < BUCKETSNUM; ++i) {
	        if (bucketA[i] !== 0) {
	            for (j = 0; j < bucketA[i]; ++j) {
	                sqList[num++] = b[i][j];
	            }
	        }
	    }
	}
	exports.bucketSort = bucketSort;
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95];
	bucketSort(arr);
	console.log(arr + '');
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95, Infinity, Infinity, Infinity];
	quickSort(arr);
	console.log(arr + '');
	
	/*
	 性能分析
	 很明显，基数排序的性能比桶排序要略差。每一次关键字的桶分配都需要O(N)的时间复杂度，而且分配之后得到新的关键字序列又需要O(N)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2N) ，当然d要远远小于N，因此基本上还是线性级别的。基数排序的空间复杂度为O(N+M)，其中M为桶的数量。一般来说N>>M，因此额外空间需要大概N个左右。
	 但是，对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，基数排序的应用范围更加广泛。
	 */

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _StaticLinkedList = __webpack_require__(57);
	
	var _StaticLinkedList2 = _interopRequireDefault(_StaticLinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultCompare = __webpack_require__(24);
	
	/*
	 插入排序
	
	 采用的是以 “玩桥牌者”的方法为基础的。即在考察记录Ri之前，设以前的所有记录R1, R2 ,…., Ri-1已排好序，然后将Ri插入到已排好序的诸记录的适当位置
	
	 最基本的插入排序是直接插入排序(Straight Insertion Sort) 。
	
	
	 直接插入排序
	
	 1  排序思想
	 将待排序的记录Ri，插入到已排好序的记录表R1, R2 ,…., Ri-1中，得到一个新的、记录数增加1的有序表。 直到所有的记录都插入完为止。
	 设待排序的记录顺序存放在数组R[1…n]中，在排序的某一时刻，将记录序列分成两部分：
	 ◆ R[1…i-1]：已排好序的有序部分；
	 ◆ R[i…n]：未排好序的无序部分。
	 显然，在刚开始排序时，R[1]是已经排好序的。
	
	 2.算法实现
	
	 3.算法分析
	 ⑴ 最好情况：若待排序记录按关键字从小到大排列(正序)，算法中的内循环无须执行，则一趟排序时：关键字比较次数1次，记录移动次数2次(R[i]→R[0], R[0]→R[j+1])。
	 则整个排序的关键字比较次数和记录移动次数分别是：
	 比较次数：n - 1          移动次数： 2 * (n - 1)
	
	 ⑵ 最坏情况：若待排序记录按关键字从大到小排列(逆序)，则一趟排序时：算法中的内循环体执行i-1，关键字比较次数i次，记录移动次数i+1。
	 则就整个排序而言：
	 比较次数： (n - 1) * (n + 1) / 2     移动次数: (n - 1) * (n + 4) / 2
	
	 一般地，认为待排序的记录可能出现的各种排列的概率相同，则取以上两种情况的平均值，作为排序的关键字比较次数和记录移动次数，约为n2/4，则复杂度为O(n2) 。
	
	
	 */
	
	/**
	 * Created by Luke on 2015/2/2.
	 */
	
	function straightInsertSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        // 设置哨兵, 当设置sqList[-1] = sqList[i]时，经测试效率更慢
	        // 因为js里面的变量作用域在函数内的
	        var temp = sqList[i];
	        // 查找插入位置，并将记录后移
	        for (var j = i - 1; j >= 0 && comp(temp, sqList[j]) < 0; --j) {
	            sqList[j + 1] = sqList[j];
	        } // 插入到正确位置
	        sqList[j + 1] = temp;
	    }
	}
	exports.straightInsertSort = straightInsertSort;
	
	var a = [7, 4, -2, 19, 13, 6];
	straightInsertSort(a);
	console.log(a + '');
	
	/*
	 其它插入排序
	
	 1  折半插入排序
	 当将待排序的记录R[i] 插入到已排好序的记录子表R[1…i-1]中时，由于R1, R2 ,…, Ri-1已排好序，则查找插入位置可以用“折半查找”实现，则直接插入排序就变成为折半插入排序。
	
	 从时间上比较，折半插入排序仅仅减少了关键字的比较次数，却没有减少记录的移动次数，故时间复杂度仍然为O(n2) 。
	
	
	 */
	
	function binaryInsertSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        var low = 0;
	        var high = i - 1;
	
	        while (low <= high) {
	            var mid = low + high >> 1;
	
	            if (comp(temp, sqList[mid]) < 0) high = mid - 1;else low = mid + 1;
	        }
	
	        for (var j = i - 1; j >= high + 1; --j) {
	            sqList[j + 1] = sqList[j];
	        }
	
	        sqList[high + 1] = temp;
	    }
	}
	exports.binaryInsertSort = binaryInsertSort;
	
	var b = [30, 13, 70, 85, 39, 42, 6, 20];
	binaryInsertSort(b);
	console.log(b + '');
	
	/*
	 2-路插入排序
	
	 是对折半插入排序的改进，以减少排序过程中移动记录的次数。附加n个记录的辅助空间，方法是：
	 ①  另设一个数组d，L[1]赋给d[1]，将d[1]看成是排好序的序列中中间位置的记录；
	 ②  分别将L[ ]中的第i个记录依次插入到d[1]之前或之后的有序序列中，具体方法：
	 ◆  L[i].key<d[1].key： L[i]插入到d[1]之前的有序表中；
	 ◆ L[i].key≥d[1].key： L[i]插入到d[1]之后的有序表中；
	 关键点：实现时将向量d看成是循环向量，并设两个指针first和final分别指示排序过程中得到的有序序列中的第一个和最后一个记录。
	
	 在2-路插入排序中，移动记录的次数约为n2/8 。但当L[1]是待排序记录中关键字最大或最小的记录时，2-路插入排序就完全失去了优越性。
	 */
	
	function path2InsertSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var d = [sqList[0]];
	    // first、final分别指示d中排好序的记录的第1个和最后1个记录的位置。
	    var first = 0;
	    var final = 0;
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var item = sqList[i];
	
	        // 待插入记录小于d中最小值，插入到d[first]之前（不需移动d数组的元素）。
	        if (comp(item, d[first]) < 0) {
	            first = (first - 1) % len;
	            d[first] = item;
	        }
	        // 待插入记录大于d中最小值，插入到d[final]之后（不需移动d数组的元素）。
	        else if (comp(item, d[final]) > 0) {
	                d[++final] = item;
	            }
	            // 待插入记录大于d中最小值，小于d中最大值，插入到d的中间（需要移动d数组的元素）。
	            else {
	                    // 移动d尾部元素以便按序插入记录。
	                    var j = final++;
	                    while (comp(item, d[j]) < 0) {
	                        d[(j + 1) % len] = d[j];
	                        j = (j - 1) % len;
	                    }
	                    d[(j + 1) % len] = item;
	                }
	    }
	
	    // 循环把d赋给sqList
	    for (i = 0; i < len; ++i) {
	        sqList[i] = d[(i + first) % len];
	    }
	}
	exports.path2InsertSort = path2InsertSort;
	
	var c = [49, 38, 65, 13, 97, 27, 76, 5, 100, 78, 15, 15, 20];
	path2InsertSort(c);
	console.log(c + '');
	
	/*
	表插入排序
	
	前面的插入排序不可避免地要移动记录，若不移动记录就需要改变数据结构。
	初始化：下标值为0的分量作为表头结点，关键字取为最大值，各分量的指针值为空；
	①  将静态链表中数组下标值为1的分量(结点)与表头结点构成一个循环链表；
	② i=2 ，将分量R[i]按关键字递减插入到循环链表；
	③  增加i ，重复②，直到全部分量插入到循环链表。
	
	和直接插入排序相比，不同的是修改2n次指针值以代替移动记录，而关键字的比较次数相同，故时间复杂度为O(n2)。
	
	表插入排序得到一个有序链表，对其可以方便地进行顺序查找，但不能实现随机查找。为了能实现有序表的折半查找根据需要，可以对记录进行重排.
	
	重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。
	
	例子中，链表中第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记录应移至数组的第一个分量，则将list[1]和list[6]互换，并为了不中断静态链表中的链，即在继续顺链表扫描时仍能找到互换之前在list[1]中的结点，令互换之后的list[1]中的游标改为6
	
	推广至一般情况，若第i个最小关键字的结点是数组中下标为p且p > i的分量，则互换list[i]和list[p]，且令list[i]中的游标改为p；
	由于此时数组中所有小于i的分量中已是到位记录，则当p<i时，应顺链继续查找直到p>=i为止。
	 */
	
	// 表插入排序
	function staticLinkedListInsertSort(sllist, comp) {
	    if (comp == null) comp = defaultCompare;
	    // 构成循环链表
	    sllist[0].cur = 1;
	    sllist[1].cur = 0;
	
	    var p, q;
	    for (var i = 2, len = sllist.length; i <= len; ++i) {
	        p = 0;
	        var x = sllist[i].data;
	
	        while (sllist[p].cur && comp(sllist[sllist[p].cur].data, x) < 0) {
	            p = sllist[p].cur;
	        } // 当遇到大于当前关键字的下标时，插入到其前驱和后继的中间
	        q = sllist[p].cur;
	        sllist[p].cur = i;
	        sllist[i].cur = q;
	    }
	}
	exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
	
	// 重排静态链表，静态链表下标已排好序
	function arrange(sllist) {
	    var p = sllist[0].cur;
	
	    for (var i = 1, len = sllist.length; i < len; ++i) {
	        // 第i个记录在list中的当前位置应不小于i
	        // 找到第i个记录，并用p指示其在list中当前位置
	        while (p < i) {
	            p = sllist[p].cur;
	        } // q指向尚未调整的表尾
	        var q = sllist[p].cur;
	
	        if (p !== i) {
	            // 交换记录，使第i个记录到位
	            var temp = sllist[p];
	            sllist[p] = sllist[i];
	            sllist[i] = temp;
	            // 指向被移走的记录，使得以后可有while循环找到
	            sllist[i].cur = p;
	        }
	
	        // p指向尚未调整的表尾
	        p = q;
	    }
	}
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 52];
	var d = new _StaticLinkedList2.default();
	d.create(arr);
	staticLinkedListInsertSort(d);
	console.log(d);
	arrange(d);
	console.log(d);
	
	/*
	希尔排序
	
	希尔排序(Shell Sort，又称缩小增量法)是一种分组插入排序方法。
	
	1  排序思想
	①   先取一个正整数d1(d1<n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；
	②   取新的增量d2<d1，重复①的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。
	
	2  排序示例
	设有10个待排序的记录，关键字分别为9, 13, 8, 2, 5, 13, 7, 1, 15, 11，增量序列是5, 3, 1，希尔排序的过程:
	初始关键字序列:    9     13     8      2      5      13      7      1      15      11
	第一趟排序后:      9     7      1      2      5      13      13     8      15      11
	第二趟排序后:      2     5      1      9      7      13      11     8      15      13
	第三趟排序后:      1     2      5      7      8      9      11     13      13      15
	
	
	希尔排序的分析比较复杂，涉及一些数学上的问题，其时间是所取的“增量”序列的函数。
	
	希尔排序特点
	子序列的构成不是简单的“逐段分割”，而是将相隔某个增量的记录组成一个子序列。
	希尔排序可提高排序速度，原因是：
	◆ 分组后n值减小，n²更小，而T(n)=O(n²),所以T(n)从总体上看是减小了；
	◆ 关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序。
	
	增量序列取法
	◆ 无除1以外的公因子；
	◆ 最后一个增量值必须为1。
	
	相关资料： http://wenku.baidu.com/link?url=q7kzOxXqc0BLaGUVDY43FQOh2aX1UqBHkkYd3VMwJhJo6rv4SiU686RW3kQCSqGEKytl12S8fBOpwhq-runhX_pbZcg6BeD-miYMPgDhXxK
	 */
	
	function shellInsert(sqList, dk, comp) {
	    for (var i = dk, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        if (comp(temp, sqList[i - dk]) < 0) {
	            for (var j = i - dk; j >= 0 && comp(temp, sqList[j]) < 0; j -= dk) {
	                sqList[j + dk] = sqList[j];
	            }sqList[j + dk] = temp;
	        }
	    }
	}
	
	function shellSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var delta = createDelta(sqList.length);
	    //console.log(delta);
	    for (var k = 0, t = delta.length; k < t; ++k) {
	        shellInsert(sqList, delta[k], comp);
	    }
	}
	exports.shellSort = shellSort;
	
	function createDelta(n) {
	    var arr = [];
	    var t = Math.log(n - 1) / Math.log(2) | 0; // Math.log(n - 1) / Math.log(2), Math.log(n + 1) / Math.log(2)
	    for (var k = 0; k <= t; ++k) {
	        arr[k] = Math.pow(2, t - k) + 1;
	    } // Math.pow(2, t - i + 1) - 1, Math.pow(2, t - i) + 1
	
	    arr[arr.length] = 1;
	
	    return arr;
	}
	
	console.log('\n\nShell Sort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	shellSort(arr);
	console.log(arr + '');

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _LinkedList = __webpack_require__(56);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	var _Queue = __webpack_require__(13);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by ldp on 2015/2/7.
	 */
	
	var defaultCompare = __webpack_require__(24);
	
	/*
	 归并排序
	
	 归并(Merging) ：是指将两个或两个以上的有序序列合并成一个有序序列。若采用线性表(无论是那种存储结构)易于实现，其时间复杂度为O(m+n) 。
	 归并思想实例：两堆扑克牌，都已从小到大排好序，要将两堆合并为一堆且要求从小到大排序。
	 ◆  将两堆最上面的抽出(设为C1，C2)比较大小，将小者置于一边作为新的一堆(不妨设C1<C2)；再从第一堆中抽出一张继续与C2进行比较，将较小的放置在新堆的最下面；
	 ◆ 重复上述过程，直到某一堆已抽完，然后将剩下一堆中的所有牌转移到新堆中。
	
	 1   排序思想
	 ①  初始时，将每个记录看成一个单独的有序序列，则n个待排序记录就是n个长度为1的有序子序列；
	 ②  对所有有序子序列进行两两归并，得到n/2个长度为2或1的有序子序列——一趟归并；
	 ③  重复② ，直到得到长度为n的有序序列为止。
	
	 上述排序过程中，子序列总是两两归并，称为2-路归并排序。其核心是如何将相邻的两个子序列归并成一个子序列。设相邻的两个子序列分别为：
	 {R[k], R[k+1], …, R[m]}和{R[m+1], R[m+2],…, R[h]}，将它们归并为一个有序的子序列：
	 {DR[l], DR[l+1], …, DR[m], DR[m+1], …, DR[h] }
	
	 例：设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41，归并排序的过程。
	 初始关键字: [23]   [38]   [22]   [45]   [23]   [67]   [31]   [15]   [41]
	              |      |      |      |      |      |      |      |
	              --------      --------      --------      --------
	 一趟归并后: [23    38]    [22     45]    [23     67]    [15     31]   [41]
	                 |              |             |              |
	                 ---------------               ---------------
	 二趟归并后: [22     23      38     45]    [15     23     31     67]    [41]
	                        |                              |
	                        --------------------------------
	 三趟归并后: [15     22      23     23     31     38     45     67]    [41]
	                                       |                                |
	                                       ----------------------------------
	 四趟归并后: [15     22      23     23     31     38     41     45     67
	
	
	 2  一趟归并排序
	 一趟归并排序都是从前到后，依次将相邻的两个有序子序列归并为一个，且除最后一个子序列外，其余每个子序列的长度都相同。设这些子序列的长度为d，则一趟归并排序的过程是：
	 从j=0开始，依次将相邻的两个有序子序列
	 R[j…j+d-1]和R[j+d…j+2d-1]进行归并；每次归并两个子序列后，j后移动2d个位置，即
	 j=j+2d；若剩下的元素不足两个子序列时，分以下两种情况处理：
	 ①  剩下的元素个数>d：再调用一次上述过程，将一个长度为d的子序列和不足d的子序列进行归并；
	 ②  剩下的元素个数≤d：将剩下的元素依次复制到归并后的序列中。
	
	
	 3.算法分析
	具有n个待排序记录的归并次数是㏒2n，而一趟归并的时间复杂度为O(n)，则整个归并排序的时间复杂度无论是最好还是最坏情况均为O(n㏒2n)。在排序过程中，使用了辅助向量DR，大小与待排序记录空间相同，则空间复杂度为O(n)。归并排序是稳定的。
	
	 */
	
	var nCount = 0;
	var nonRecursiveCount = 0;
	var recursiveCount = 0;
	
	/**
	 * 将有序的sr[s1..e1]和sr[s2..e2]归并为有序的tr[s1..e2]
	 * @param sr
	 * @param s1
	 * @param e1
	 * @param e2
	 */
	function merge(sr, s1, e1, e2, comp) {
	    var temp = [];
	    var i = s1;
	    var j = e1 + 1;
	    var k = 0;
	
	    while (i <= e1 && j <= e2) {
	        if (comp(sr[i], sr[j]) < 0) temp[k++] = sr[i++];else temp[k++] = sr[j++];
	    }
	    while (i <= e1) {
	        temp[k++] = sr[i++];
	    }while (j <= e2) {
	        temp[k++] = sr[j++];
	    } // 复制回去
	    for (i = s1, k = 0; i <= e2; ++i, ++k) {
	        sr[i] = temp[k];
	    }
	}
	
	/**
	 * 2-路归并排序递归算法
	 * @param {Array} sr
	 * @param {Number} s
	 * @param {Number} t
	 */
	function mergeSortRecursive(sr, s, t, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (s == null) s = 0;
	    if (t == null) t = sr.length - 1;
	
	    if (s >= t) return;
	
	    // 将sr[s..t]平分为sr[s..m]和sr[m+1..t]
	    var m = s + t >> 1;
	    // 递归地将sr[s..m]归并为有序的sr[s..m]
	    mergeSortRecursive(sr, s, m, comp);
	    // 递归地将sr[m+1..t]归并为有序的sr[m+1..t]
	    mergeSortRecursive(sr, m + 1, t, comp);
	    // 将sr[s..m]和sr[m+1..t]归并到sr[s..t];
	    merge(sr, s, m, t, comp);
	}
	exports.mergeSortRecursive = mergeSortRecursive;
	
	console.log('\n\nmergeSortRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortRecursive(arr);
	console.log(arr + '');
	
	function mergeSortNonRecursive(sr, comp) {
	    if (comp == null) comp = defaultCompare;
	    var j, k;
	    for (var d = 1, n = sr.length - 1; d < n; d *= 2) {
	        // 一趟归并排序算法
	        j = 0;
	
	        // 子序列两两归并
	        while ((k = j + 2 * d - 1) < n) {
	            merge(sr, j, j + d - 1, k, comp);
	            j = k + 1;
	        }
	
	        // 剩余元素个数超过一个子序列长度
	        if (j + d - 1 < n) merge(sr, j, j + d - 1, n, comp);
	        // 剩余子序列复制
	        else merge(sr, j, n, n, comp);
	    }
	}
	exports.mergeSortNonRecursive = mergeSortNonRecursive;
	
	console.log('\nmergeSortNonRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortNonRecursive(arr);
	console.log(arr + '');
	
	// 自然合并排序
	// http://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html
	// http://www.cnblogs.com/lanke/archive/2013/01/15/2860487.html
	/*
	自然归并是归并排序的一个变形，效率更高一些，可以在归并排序非递归实现的基础上进行修改.对于已经一个已经给定数组a,通常存在多个长度大于1的已经自然排好的子数组段,因此用一次对数组a的线性扫描就可以找出所有这些排好序的子数组段,然后再对这些子数组段俩俩合并.
	 */
	
	// 扫描得到子串的函数
	function pass(sqList, rec, comp) {
	    var num = 0;
	    rec[num++] = 0;
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        if (comp(sqList[i], sqList[i + 1]) > 0) rec[num++] = i + 1;
	    }
	    rec[num++] = len;
	
	    return num;
	}
	
	function natureMergeSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var rec = [];
	
	    //num=2说明已经排好序了
	    //每循环一次，进行一次pass()操作
	    for (var num = pass(sqList, rec, comp); num !== 2; num = pass(sqList, rec, comp)) {
	        for (var i = 0; i + 2 < num; i += 2) {
	            merge(sqList, rec[i], rec[i + 1] - 1, rec[i + 2] - 1, comp);
	        }
	    }
	}
	
	exports.natureMergeSort = natureMergeSort;
	
	console.log('\nnatureMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	natureMergeSort(arr);
	console.log(arr + '');
	
	console.log(recursiveCount);
	console.log(nonRecursiveCount);
	console.log(nCount);
	
	// 双向自然合并排序算法
	/*
	双向自然合并排序是根据欲排序数据局部不是升序就是降序的自然有序特点,先线性扫描出自然有序的子数组段,再进行合并排序.扫描时的有序数段长度越长,段数越少,对应合并树的层数就会越少,算法的效率越高.
	 */
	var naturalMergeSort = function () {
	    return naturalMergeSort;
	
	    function naturalMergeSort(a, comp) {
	        if (comp == null) comp = defaultCompare;
	        var b = [];
	        var n = a.length;
	        while (!mergeRuns(a, b, n, comp)) {}
	    }
	
	    function mergeRuns(a, b, n, comp) {
	        var i = 0;
	        var k = 0;
	        var asc = true;
	        var x;
	
	        while (i < n) {
	            k = i;
	            // 找到最后一个递增序列元素
	            do {
	                x = a[i++];
	            } while (i < n && comp(x, a[i]) <= 0);
	            // 找到最后一个递减序列元素
	            while (i < n && comp(x, a[i]) >= 0) {
	                x = a[i++];
	            } // 归并递增序列和递减序列，结果可能递增或递减
	            merge(a, b, k, i - 1, asc, comp);
	            asc = !asc;
	        }
	
	        // 当k等于0时代表a已经排好序了
	        return k === 0;
	    }
	
	    function merge(a, b, low, high, asc, comp) {
	        var k = asc ? low : high;
	        var c = asc ? 1 : -1;
	        var i = low;
	        var j = high;
	
	        while (i <= j) {
	            if (comp(a[i], a[j]) <= 0) b[k] = a[i++];else b[k] = a[j--];
	            k += c;
	        }
	        for (i = k = low, j = high; i <= j; ++i, ++k) {
	            a[i] = b[k];
	        }
	    }
	}();
	
	exports.naturalMergeSort = naturalMergeSort;
	
	console.log('\nnaturalMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	naturalMergeSort(arr);
	console.log(arr + '');
	
	// 链表存储结构的自然合并排序
	var linkedListNaturalMergeSort = function () {
	    return mergeSort;
	
	    function mergeSort(linkedlist, needReplace, comp) {
	        if (comp == null) comp = defaultCompare;
	        if (!linkedlist) return linkedlist;
	
	        var queue = new _Queue2.default();
	        var list = linkedlist.head;
	
	        if (!list || !list.next) return linkedlist;
	
	        needReplace = needReplace == null ? true : needReplace;
	        var u = list;
	        var t = list;
	        var v;
	        // 将递增的结点放入到队列中（会被切断）
	        for (; t; t = u) {
	            while (u && u.next && comp(u.data, u.next.data) <= 0) {
	                u = u.next;
	            }v = u;
	            u = u.next;
	            v.next = null;
	            queue.enQueue(t);
	        }
	
	        t = queue.deQueue();
	        // 合并结点
	        while (queue.size) {
	            queue.enQueue(t);
	            var a = queue.deQueue();
	            var b = queue.deQueue();
	            t = merge(a, b, comp);
	        }
	
	        if (needReplace) linkedlist.head = t;
	
	        return t;
	    }
	
	    function merge(a, b, comp) {
	        var c = new _LinkedList2.default();
	        var head = { data: null, next: null };
	        c.head = head;
	        c = c.head;
	
	        while (a && b) {
	            if (comp(a.data, b.data) < 0) {
	                c.next = a;
	                c = a;
	                a = a.next;
	            } else {
	                c.next = b;
	                c = b;
	                b = b.next;
	            }
	        }
	
	        c.next = a ? a : b;
	
	        return head.next;
	    }
	}();
	exports.linkedListNaturalMergeSort = linkedListNaturalMergeSort;
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	var linkedList = new _LinkedList2.default(arr);
	linkedListNaturalMergeSort(linkedList);
	console.log(linkedList + '');

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Created by luke on 2015/2/2.
	 */
	
	var defaultCompare = __webpack_require__(24);
	
	/*
	选择排序
	
	选择排序(Selection Sort)的基本思想是：每次从当前待排序的记录中选取关键字最小的记录表，然后与待排序的记录序列中的第一个记录进行交换，直到整个记录序列有序为止。
	
	
	简单选择排序
	
	简单选择排序(Simple Selection Sort ，又称为直接选择排序)的基本操作是：通过n-i次关键字间的比较，从n-i+1个记录中选取关键字最小的记录，然后和第i个记录进行交换，i=1, 2, … n-1 。
	1  排序示例
	例：设有关键字序列为：7, 4, -2, 19, 13, 6，直接选择排序的过程：
	初始记录的关键字：  7     4    -2     19    13    6
	    第一趟排序：  -2     4     7     19    13    6
	    第二趟排序：  -2     4     7     19    13    6
	    第三趟排序：  -2     4     6     19    13    7
	    第四趟排序：  -2     4     6     7     13    19
	    第五趟排序：  -2     4     6     7     13    19
	    第六趟排序：  -2     4     6     7     13    19
	
	2.算法分析
	整个算法是二重循环：外循环控制排序的趟数，对n个记录进行排序的趟数为n-1趟；内循环控制每一趟的排序。
	进行第i趟排序时，关键字的比较次数为n-i，则：
	比较次数： n*(n - 1) / 2
	时间复杂度是：T(n)=O(n2)
	空间复杂度是：S(n)=O(1)
	从排序的稳定性来看，直接选择排序是不稳定的。
	
	 */
	
	function simpleSelectionSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 0, len = sqList.length; i < len; ++i) {
	        for (var k = i, j = k + 1; j < len; ++j) {
	            if (comp(sqList[j], sqList[k]) < 0) k = j;
	        }if (k !== i) {
	            var temp = sqList[k];
	            sqList[k] = sqList[i];
	            sqList[i] = temp;
	        }
	    }
	}
	exports.simpleSelectionSort = simpleSelectionSort;
	
	var arr = [7, 4, -2, 19, 13, 6];
	simpleSelectionSort(arr);
	console.log(arr + '');
	
	/*
	树形选择排序
	
	首先对n个记录的关键字两两进行比较，选取n/2个较小者；然后这n/2个较小者两两进行比较，选取n/4个较小者… 如此重复，直到只剩1个关键字为止。
	该过程可用一棵有n个叶子结点的完全二叉树表示，每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点的关键字就是最小的关键字。
	输出最小关键字后，根据关系的可传递性，欲选取次小关键字，只需将叶子结点中的最小关键字改为“最大值” ，然后重复上述步骤即可。
	含有n个叶子结点的完全二叉树的深度为㏒2n+1，则总的时间复杂度为O(n㏒2n) 。
	
	但这种排序方法尚有辅助存储空间较多,和最大值进行多余比较等缺点。为了弥补这些缺陷，出现了另一种选择排序---堆排序
	 */
	
	/*
	堆排序
	
	1  堆的定义
	是n个元素的序列H={k1, k2 , … kn} ，满足：
	    ki≤k2i       当2i≤n时
	    ki≤k2i+1   当2i+1≤n时
	
	由堆的定义知，堆是一棵以k1为根的完全二叉树。若对该二叉树的结点进行编号(从上到下，从左到右)，得到的序列就是将二叉树的结点以顺序结构存放，堆的结构正好和该序列结构完全一致。
	
	2  堆的性质
	    1)  堆是一棵采用顺序存储结构的完全二叉树， k1是根结点；
	    2)  堆的根结点是关键字序列中的最小(或最大)值，分别称为小(或大)根堆；
	    3)  从根结点到每一叶子结点路径上的元素组成的序列都是按元素值(或关键字值)非递减(或非递增)的；
	    4)  堆中的任一子树也是堆。
	
	利用堆顶记录的关键字值最小(或最大)的性质，从当前待排序的记录中依次选取关键字最小(或最大)的记录，就可以实现对数据记录的排序，这种排序方法称为堆排序。
	
	3  堆排序思想
	
	①  对一组待排序的记录，按堆的定义建立堆；
	②  将堆顶记录和最后一个记录交换位置，则前n-1个记录是无序的，而最后一个记录是有序的；
	③  堆顶记录被交换后，前n-1个记录不再是堆，需将前n-1个待排序记录重新组织成为一个堆，然后将堆顶记录和倒数第二个记录交换位置，即将整个序列中次小关键字值的记录调整(排除)出无序区；
	④  重复上述步骤，直到全部记录排好序为止。
	
	结论：排序过程中，若采用小根堆，排序后得到的是非递减序列；若采用大根堆，排序后得到的是非递增序列。
	
	堆排序的关键
	①  如何由一个无序序列建成一个堆？
	②  如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？
	
	4  堆的调整——筛选
	⑴ 堆的调整思想
	输出堆顶元素之后，以堆中最后一个元素替代之；然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；重复上述操作，直到是叶子结点或其关键字值小于等于左、右子树的关键字的值，将得到新的堆。称这个从堆顶至叶子的调整过程为“筛选”。
	
	注意：筛选过程中，根结点的左、右子树都是堆，因此，筛选是从根结点到某个叶子结点的一次调整过程。
	
	5  堆的建立
	利用筛选算法，可以将任意无序的记录序列建成一个堆，设R[1],R[2], …,R[n]是待排序的记录序列。
	将二叉树的每棵子树都筛选成为堆。只有根结点的树是堆。第⌊n/2⌋个结点之后的所有结点都没有子树，即以第⌊n/2⌋个结点之后的结点为根的子树都是堆。因此，以这些结点为左、右孩子的结点，其左、右子树都是堆，则进行一次筛选就可以成为堆。同理，只要将这些结点的直接父结点进行一次筛选就可以成为堆…。
	只需从第⌊n/2⌋个记录到第1个记录依次进行筛选就可以建立堆。
	
	6   堆排序算法实现
	堆的根结点是关键字最小的记录，输出根结点后，是以序列的最后一个记录作为根结点，而原来堆的左、右子树都是堆，则进行一次筛选就可以成为堆。
	
	7  算法分析
	主要过程：初始建堆和重新调整成堆。设记录数为n，所对应的完全二叉树深度为h 。
	◆  初始建堆：每个非叶子结点都要从上到下做“筛选” 。第i层结点数≤2i-1，结点下移的最大深度是h-i，而每下移一层要比较2次，则比较次数C1(n)为：
	C1(n)≤4(n-㏒2n-1)
	◆  筛选调整：每次筛选要将根结点“下沉”到一个合适位置。第i次筛选时：堆中元素个数为n-i+1；堆的深度是㏒2(n-i+1)+1，则进行n-1次“筛选”的比较次数C2(n)为：
	C2(n)<2n㏒2n
	堆排序的比较次数的数量级为： T(n)=O(n㏒2n)；而附加空间就是交换时所用的临时空间，故空间复杂度为： S(n)=O(1) 。
	
	堆排序适合记录数较大的情况
	
	
	http://blog.csdn.net/zz198808/article/details/7678055
	 */
	
	/**
	 * 已知sqList[s..m]中记录的关键字除sqList[s]之外均满足堆的定义，
	 * 本函数调整sqList[s]的关键字，使sqList[s..m]成为一个大堆顶（对其中关键字而言）
	 * @param {Array} sqList
	 * @param {Number} s
	 * @param {Number} m
	 */
	function heapAdjust(sqList, s, m, comp) {
	    var rc = sqList[s];
	
	    // 沿关键字较大的孩子结点向下筛选
	    for (var j = 2 * s + 1; j <= m; j = j * 2 + 1) {
	        // j为关键字较大的记录下标
	        if (j < m && comp(sqList[j], sqList[j + 1]) < 0) ++j;
	        // rc应插入在位置s上
	        if (comp(rc, sqList[j]) >= 0) break;
	        sqList[s] = sqList[j];
	        s = j;
	    }
	
	    sqList[s] = rc;
	}
	
	function heapSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var len = sqList.length;
	    // 建立大堆顶
	    for (var i = (len >> 1) - 1; i >= 0; --i) {
	        heapAdjust(sqList, i, len - 1, comp);
	    }for (i = len - 1; i > 0; --i) {
	        // 将堆顶记录和当前未经排序子序列sqList[0..i]中
	        // 最后一个记录相互交换
	        var temp = sqList[i];
	        sqList[i] = sqList[0];
	        sqList[0] = temp;
	
	        // 将sqList[0..i - 1]重新调整为大堆顶
	        heapAdjust(sqList, 0, i - 1, comp);
	    }
	}
	exports.heapSort = heapSort;
	
	var arr = [1, 3, 4, 5, 7, 2, 6, 8, 0];
	heapSort(arr);
	console.log(arr + '');

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 堆分配存储表示
	 *
	 * 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在c语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间。
	 */
	
	var HString = function () {
	    function HString() {
	        (0, _classCallCheck3.default)(this, HString);
	
	        this.ch = {};
	        this.length = 0;
	    }
	
	    // 1 <= position <= this.length.在串的第position个字符之前插入串tHString
	
	
	    (0, _createClass3.default)(HString, [{
	        key: 'strInsert',
	        value: function strInsert(position, tHString) {
	            if (position < 1 || position > this.length + 1) throw new Error('unexpected position');
	
	            if (tHString.length) {
	                // 为插入t而腾出位置
	                var i = this.length - 1;
	                for (var len = position - 1; i >= len; --i) {
	                    this.ch[i + tHString.length] = this.ch[i];
	                }stringCopy(this.ch, tHString.ch, position - 1, tHString.length - 1, 0);
	
	                this.length += tHString.length;
	            }
	        }
	    }, {
	        key: 'strAssign',
	        value: function strAssign(chars) {
	            stringCopy(this.ch, chars, 0, chars.length - 1, 0);
	            this.length = chars.length;
	        }
	    }, {
	        key: 'strLength',
	        value: function strLength() {
	            return this.length;
	        }
	    }, {
	        key: 'strCompare',
	        value: function strCompare(tHString) {
	            for (var i = 0, len = this.length; i < len && i < tHString.length; i++) {
	                if (this.ch[i] !== tHString.ch[i]) return this.ch[i] - tHString.ch[i];
	            }return this.length - tHString.length;
	        }
	    }, {
	        key: 'clearString',
	        value: function clearString() {
	            this.ch = {};
	            this.length = 0;
	        }
	    }, {
	        key: 'concat',
	        value: function concat(s) {
	            var t = new HString();
	
	            // t.ch[0..this.length - 1] = this.ch[0..this.length - 1]
	            stringCopy(t.ch, this.ch, 0, this.length - 1, 0);
	            t.length = this.length + s.length;
	            // t.ch[this.length..t.length - 1] = s.ch[0..s.length - 1]
	            stringCopy(t.ch, s.ch, this.length, s.length - 1, 0);
	
	            return t;
	        }
	    }, {
	        key: 'substring',
	        value: function substring(position, len) {
	            position = ~ ~position || 0;
	            len = ~ ~len || this.length;
	            if (position < 0 || position > this.length - 1 || len < 0 || len > this.length - position) throw new Error('unexpected parameter');
	
	            var sub = new HString();
	            stringCopy(sub.ch, this.ch, 0, len - 1, position);
	            sub.length = len;
	
	            return sub;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var s = '';
	            for (var i = 0, len = this.length; i < len; i++) {
	                s += this.ch[i];
	            }
	            return s;
	        }
	    }]);
	    return HString;
	}();
	
	exports.default = HString;
	
	
	function stringCopy(destination, target, destStart, length, targetStart) {
	    destStart = destStart || 0;
	    length = length || target.length;
	    targetStart = targetStart || 0;
	
	    for (var i = 0; i <= length; i++) {
	        destination[destStart + i] = target[targetStart + i];
	    }
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(19);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Chunk = function Chunk() {
	    var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	    (0, _classCallCheck3.default)(this, Chunk);
	
	    this.chunkSize = chunkSize;
	    this.ch = [];
	    for (var i = 0; i < this.chunkSize; i++) {
	        this.ch[i] = '#';
	    }
	    // type: Chunk
	    this.next = null;
	}; /**
	    * 串的块链存储表示
	    *
	    * 和线性表的链式存储结构相类似，也可采用链式方式存储串值。由于串结构的特殊性--结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。
	    * 下面是结点大小为4（即每个结点存放4个字符）的链表
	    * head --> (a,b,c,d) --> (e,f,g,h) --> (i###)
	    * 下面是结点大小为1的链表
	    * head --> (a) --> (b) --> (c) --> ... --> (i)
	    *
	    * 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其它非串值字符。
	    * 为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度，称如此定义的串存储结构为块链结构。
	    *
	    * 由于一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行连接操作，但应注意连接时需处理第一个串尾的无效字符。
	    * 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响到串处理的效率。如果串很长，这要求我们考虑串值的存储密度：
	    * 存储密度 = 串值所占的存储位 / 实际分配的存储位
	    *
	    * 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。
	    */
	
	
	var LString = function () {
	    function LString() {
	        var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	        (0, _classCallCheck3.default)(this, LString);
	
	        // type Chunk
	        this.head = null;
	        // type: chunk
	        this.tail = null;
	        // 串的当前长度
	        this.length = 0;
	        this.chunkSize = chunkSize;
	    }
	
	    // 将字符串转换成LString类型
	
	
	    (0, _createClass3.default)(LString, [{
	        key: 'strAssign',
	        value: function strAssign(chars) {
	            this.head = this.tail = new Chunk(this.chunkSize);
	            this.length = chars.length;
	
	            var current = this.head;
	            for (var i = 0, len = chars.length; i < len; i++) {
	                current.ch[i % this.chunkSize] = chars[i];
	                if (i + 1 < len && (i + 1) % this.chunkSize === 0) {
	                    current.next = new Chunk();
	                    current = current.next;
	                }
	            }
	
	            this.tail = current;
	        }
	        // 字符串对比
	        // TODO 是否去掉chunkSize的对比
	
	    }, {
	        key: 'strCompare',
	        value: function strCompare(tLString) {
	            var current = this.head;
	            var curT = tLString.head;
	
	            if (this.length !== tLString.length) return false;
	
	            while (current) {
	                for (var i = 0; i < this.chunkSize; i++) {
	                    if (current.ch[i] !== curT.ch[i]) return false;
	                }
	
	                current = current.next;
	                curT = curT.next;
	            }
	
	            return true;
	        }
	    }, {
	        key: 'clearString',
	        value: function clearString() {
	            this.head = this.tail = null;
	            this.length = 0;
	        }
	    }, {
	        key: 'concat',
	        value: function concat(tLSting) {
	            if (!tLSting.length) return;
	
	            var ret = new LString(this.chunkSize);
	
	            if (this.head === null) {
	                copyString(ret, tLSting);
	            } else {
	                ret.head = ret.tail = new Chunk(this.chunkSize);
	                copyString(ret, this);
	
	                var index = ret.tail.ch.indexOf('#');
	                if (index === -1) {
	                    copyString(ret, tLSting);
	                } else {
	                    copyString(ret, tLSting, ret.tail, tLSting.head, index);
	                }
	            }
	
	            return ret;
	        }
	    }, {
	        key: 'substring',
	        value: function substring(pos, len) {
	            pos = ~ ~pos || 0;
	            len = ~ ~len || this.length;
	            if (pos < 0 || pos > this.length - 1 || len < 0 || len > this.length - pos) throw new Error('unexpected parameter');
	
	            var sub = new LString(this.chunkSize);
	            var current = findPosChunk(this, pos);
	            var curS = sub.head = new Chunk(this.chunkSize);
	            var i = 0;
	            sub.length = len;
	
	            outerloop: while (current) {
	                for (var j = 0, size = this.chunkSize; j < size; j++) {
	                    if (i === len) {
	                        break outerloop;
	                    } else {
	                        curS.ch[j] = current.ch[(i + pos) % this.chunkSize];
	                        i++;
	                        if ((i + pos) % this.chunkSize === 0) {
	                            current = current.next;
	                        }
	                        if (i % this.chunkSize === 0 && (current.ch[i] || current.next)) {
	                            curS.next = new Chunk(this.chunkSize);
	                            curS = curS.next;
	                        }
	                    }
	                }
	            }
	
	            return sub;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var current = this.head;
	
	            if (current === null) return '';
	
	            var str = '';
	            while (current) {
	                for (var i = 0, len = this.chunkSize; i < len; i++) {
	                    var ch = current.ch[i];
	                    if (ch === '#') {
	                        return str;
	                    } else {
	                        str += current.ch[i];
	                    }
	                }
	                current = current.next;
	            }
	
	            return str;
	        }
	    }]);
	    return LString;
	}();
	
	exports.default = LString;
	
	
	function findPosChunk(lString, pos) {
	    var current = lString.head;
	    while (current) {
	        for (var i = 0, len = lString.chunkSize; i < len; i++) {
	            if (pos-- === 0) return current;
	        }
	        current = current.next;
	    }
	}
	
	function copyString(destination, target, curD, currT, offset) {
	    offset = offset || 0;
	    currT = currT || target.head;
	    curD = curD || destination.head;
	    var k = 0;
	
	    while (currT) {
	        for (var i = 0, len = target.chunkSize; i < len; i++, k++) {
	            var j = k % curD.chunkSize + offset;
	            curD.ch[j % curD.chunkSize] = currT.ch[i];
	
	            if ((j + 1) % curD.chunkSize === 0 && (currT.ch[i + 1] || currT.next)) {
	                curD.next = new Chunk(destination.chunkSize);
	                curD = curD.next;
	            }
	        }
	
	        currT = currT.next;
	    }
	
	    destination.tail = curD;
	    destination.length += target.length;
	}
	
	var a = new LString();
	var b = new LString();
	var c = new LString();
	
	a.strAssign('abcdefg');
	console.log(a + '');
	b.strAssign('hijklmno');
	console.log(b + '');
	c.strAssign('abcdefg');
	console.log(a.strCompare(b));
	console.log(a.strCompare(c));
	var t = a.concat(b);
	console.log(t + '');
	t = t.substring(2, 5);
	console.log(t + '');
	
	// 判断是否为回文字符串
	function palindrome(lStr) {
	    var stack = new _index2.default();
	    var p = lStr.head;
	    var i = 0;
	
	    for (var k = 1; k <= lStr.length; ++k) {
	        if (k <= lStr.length / 2) stack.push(p.ch[i]);else if (k > (lStr.length + 1) / 2) {
	            var _c = stack.pop();
	            if (p.ch[i] !== _c) return false;
	        }
	
	        if (++i === lStr.chunkSize) {
	            p = p.next;
	            i = 0;
	        }
	    }
	
	    return true;
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 串（string）（或字符串）是由零个或多个字符组成的有限序列。串中字符的数目称为串的长度。零个字符的串称为空串（null string），它的长度为零。
	 * 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。
	 * 只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。
	 *
	 * 串有3种机内表示方法：
	 * 1.定长顺序存储表示
	 * 2.堆分配存储表示
	 * 3.串的块链存储表示
	 */
	
	/**
	 * 定长顺序存储表示
	 * 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组来描述。
	 * 以下标为0的数组分量存放串的实际长度。
	 */
	
	var SString = function () {
	    function SString(str) {
	        (0, _classCallCheck3.default)(this, SString);
	
	        this.MAXSTRLEN = 10;
	        if (str) {
	            this[0] = str.length;
	            for (var i = 1; i <= str.length; ++i) {
	                this[i] = str[i - 1];
	            }
	        }
	    }
	
	    // 返回由s1和s2连接而成的新串
	
	
	    (0, _createClass3.default)(SString, [{
	        key: 'concat',
	        value: function concat(s2) {
	            var t = new SString();
	            // 未截断
	            if (this[0] + s2[0] <= this.MAXSTRLEN) {
	                copyStr2T(this);
	                copyStr2T(s2, this[0]);
	                t[0] = this[0] + s2[0];
	
	                // 截断
	            } else if (this[0] < this.MAXSTRLEN) {
	                    copyStr2T(this);
	                    copyStr2T(s2, this[0], this.MAXSTRLEN - this[0]);
	                    t[0] = this.MAXSTRLEN;
	
	                    // 截断（仅取s1）
	                } else {
	                        copyStr2T(this, 0, this.MAXSTRLEN);
	                        t[0] = this[0] = this.MAXSTRLEN;
	                    }
	
	            return t;
	
	            function copyStr2T(str) {
	                var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	                var end = arguments.length <= 2 || arguments[2] === undefined ? str[0] : arguments[2];
	
	                for (var i = 1, len = end || str[0]; i <= len; i++) {
	                    t[start + i] = str[i];
	                }
	            }
	        }
	    }, {
	        key: 'substring',
	        value: function substring() {
	            var position = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            var len = arguments.length <= 1 || arguments[1] === undefined ? this[0] : arguments[1];
	
	            position = ~ ~position;
	            len = ~ ~len;
	            if (position < 0 || position > this[0] - 1 || len < 0 || len > this[0] - position) throw new Error('unexpected parameter');
	
	            var sub = new SString();
	            for (var i = 1; i <= len; i++) {
	                sub[i] = this[position + i - 1];
	            }
	            sub[0] = len;
	
	            return sub;
	        }
	
	        /**
	         * 将串s中的子串t替换为v，返回替换次数
	         * todo to be tested
	         * @param {SString} t
	         * @param {SString} v
	         * @returns {number} 替换次数
	         */
	
	    }, {
	        key: 'replace',
	        value: function replace(t, v) {
	            for (var _n = 0, i = 1; i <= this[0] - t[0] + 1; i++) {
	                for (var j = i, _k = 1; t[_k] && this[j] === t[_k]; ++j, ++_k) {}
	
	                // 找到了与t匹配的字串：分三种情况处理
	                if (k > t[0]) {
	                    var l = void 0;
	                    // 新字串的长度与原子串相同时，直接替换
	                    if (t[0] === v[0]) {
	                        for (l = 1; l <= t[0]; ++l) {
	                            this[i + l - 1] = v[l];
	                        }
	                    }
	                    // 新子串长度大于原子串时，先将后部右移
	                    else if (t[0] < v[0]) {
	                            for (l = this[0]; l >= i + t[0]; --l) {
	                                this[l + v[0] - t[0]] = this[l];
	                            }for (l = 1; l <= v[0]; ++l) {
	                                this[i + l - 1] = v[l];
	                            }
	                        }
	                        // 新子串长度小于原子串时，先将后部左移
	                        else {
	                                for (l = i + v[0]; l <= this[0] + v[0] - t[0]; ++l) {
	                                    this[l] = this[l - v[0] + t[0]];
	                                }for (l = 1; l <= v[0]; ++l) {
	                                    this[i + l - 1] = v[l];
	                                }
	                            }
	
	                    this[0] = this[0] - t[0] + v[0];
	                    i += v[0];
	                    ++_n;
	                }
	            }
	
	            return n;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	            for (var i = 1; this[i]; i++) {
	                str += this[i];
	            }
	            return str;
	        }
	        // 返回子串sstring在主串中的第position个字符之后的位置
	
	    }, {
	        key: 'index',
	        value: function index(sstring, position) {
	            var i = position || 1;
	            var j = 1;
	
	            while (i <= this[0] && j <= sstring[0]) {
	                if (this[i] === sstring[j]) {
	                    i++;
	                    j++;
	                } else {
	                    i = i - j + 2;
	                    j = 1;
	                }
	            }
	
	            return j > sstring[0] ? i - sstring[0] : -1;
	        }
	    }, {
	        key: 'kmpIndex',
	        value: function kmpIndex(sstring, position) {
	            var i = position || 1;
	            var j = 1;
	            var next = getNext(sstring);
	
	            while (i <= this[0] && j <= sstring[0]) {
	                if (j === 0 || this[i] === sstring[j]) {
	                    ++i;
	                    ++j;
	                } else {
	                    j = next[j];
	                }
	            }
	
	            return j > sstring[0] ? i - sstring[0] : -1;
	        }
	
	        // 求包含在字符串中而str没有的字符串
	
	    }, {
	        key: 'subtract',
	        value: function subtract(str) {
	            var r = new SString();
	            r[0] = 0;
	
	            for (var i = 1; i <= this[0]; ++i) {
	                var _c = this[i];
	                // 判断当前字符c是否第一次出现
	                var j = 1;
	                for (; j < i && this[j] !== _c; ++j) {}
	                if (i === j) {
	                    // 判断当前字符是否包含在str中
	                    var _k2 = 1;
	                    for (; _k2 <= str[0] && str[_k2] !== _c; ++_k2) {}
	                    if (_k2 > str[0]) r[++r[0]] = _c;
	                }
	            }
	
	            return r;
	        }
	
	        // todo bug exists
	
	    }, {
	        key: 'delete_substring',
	        value: function delete_substring(str) {
	            var n = 0;
	            for (var i = 1; i <= this[0] - str[0] + 1; ++i) {
	                var j = 1;
	                for (; j <= str[0] && this[i + j - 1] === str[j]; ++j) {}
	                if (j > str[0] - 1) {
	                    for (var _k3 = i; _k3 <= this[0] - str[0]; ++_k3) {
	                        this[_k3] = this[_k3 + str[0]];
	                    }this[0] -= str[0];
	                    ++n;
	                }
	            }
	
	            return n;
	        }
	    }]);
	    return SString;
	}();
	
	exports.default = SString;
	
	
	function getNext(sstring) {
	    var i = 1;
	    var next = { 1: 0 };
	    var j = 0;
	
	    while (i < sstring[0]) {
	        if (j === 0 || sstring[i] === sstring[j]) {
	            if (sstring[++i] !== sstring[++j]) {
	                next[i] = j;
	            } else {
	                next[i] = next[j];
	            }
	            //                next[++i] = ++j;
	        } else {
	                j = next[j];
	            }
	    }
	
	    return next;
	}
	
	var a = new SString();
	var b = new SString();
	for (var i = 0; i < 4; i++) {
	    a[i + 1] = i + '';
	    b[i + 1] = i + '';
	}
	a[0] = b[0] = 4;
	var t = a.concat(b);
	console.log(t + ''); // 01230123
	
	var d = new SString('acabaabaabcacaabc');
	var c = new SString('abaabc');
	
	console.log('index: ' + d.index(c));
	console.log('kmpIndex: ' + d.kmpIndex(c));
	
	a = new SString('abcdefg');
	b = new SString('asdfg');
	console.log(a.subtract(b) + '');
	
	a = new SString('abcdefgh');
	b = new SString('cdef');
	console.log(a.delete_substring(b) + '');
	console.log(a + '');
	
	/*
	 在顺序存储结构中，实现串操作的原操作为“字符串序列的复制”，操作时间复杂度基于复制的字符串序列的长度。
	 另一操作特点是，如果在操作中出现串值序列的长度超过MAXSTRLEN时，约定用截尾法处理，这种情况不仅在求连接串时可能发生，在串的其他操作中，如插入，置换等也可能发生，克服这个弊病唯有不限定串长的最大长度，即动态分配串值的存储空间。
	 */

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Created by lukelin on 2016/4/30.
	 */
	
	if (!process.browser) {
	    __webpack_require__(107);
	}
	
	module.exports = {
	    Array: {
	        CrossList: __webpack_require__(77),
	        TSMatrix: __webpack_require__(78)
	    },
	
	    BinaryTree: {
	        // BinaryThreadTree: require('./BinaryTree/BinaryThreadTree'),
	        BinaryTree: __webpack_require__(18),
	        // EBTNode: require('./BinaryTree/EBTNode'),
	        huffManCoding: __webpack_require__(79)
	    },
	
	    // MFSet: require('./BinaryTree/MFSet'),
	    // PBTNode: require('./BinaryTree/PBTNode')
	    GeneralizedList: {
	        GList: __webpack_require__(80)
	    },
	
	    Graph: {
	        AdjacencyListGraph: __webpack_require__(82),
	        AdjacencyMatrixGraph: __webpack_require__(83),
	        AMLGraph: __webpack_require__(81),
	        OLGraph: __webpack_require__(84)
	    },
	
	    List: {
	        DoubleLinkedList: __webpack_require__(55),
	        LinearList: __webpack_require__(86),
	        StaticLinkedList: __webpack_require__(57),
	        LRUCache: __webpack_require__(85).default
	    },
	
	    Queue: {
	        CycleQueue: __webpack_require__(87),
	        PriorityQueue: __webpack_require__(88),
	        Queue: __webpack_require__(13)
	    },
	
	    Search: {
	        AVLTree: __webpack_require__(89),
	        binarySearch: __webpack_require__(92),
	        BinarySortedTree: __webpack_require__(58),
	        BPlusTree: __webpack_require__(90),
	        BTree: __webpack_require__(91),
	        DigitalSearchTree: __webpack_require__(93),
	        fibonacciSearch: __webpack_require__(97),
	        HashTable: __webpack_require__(94),
	        RedBlackTree: __webpack_require__(95),
	        sequentialSearch: __webpack_require__(98),
	        SOSTree: __webpack_require__(96)
	    },
	
	    Sort: {
	        distribution: __webpack_require__(99),
	        exchange: __webpack_require__(59),
	        insertion: __webpack_require__(100),
	        merging: __webpack_require__(101),
	        selection: __webpack_require__(102)
	    },
	
	    Stack: __webpack_require__(19),
	
	    String: {
	        HString: __webpack_require__(103),
	        LString: __webpack_require__(104),
	        SString: __webpack_require__(105)
	    }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76)))

/***/ },
/* 107 */
/***/ function(module, exports) {

	// required to safely use babel/register within a browserify codebase
	
	"use strict";
	
	exports.__esModule = true;
	
	exports["default"] = function () {};
	
	module.exports = exports["default"];

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(115), __esModule: true };

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(117), __esModule: true };

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(118), __esModule: true };

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(120), __esModule: true };

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(123), __esModule: true };

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(109);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(25);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(108);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(23);
	__webpack_require__(150);
	module.exports = __webpack_require__(3).Array.from;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(30);
	__webpack_require__(23);
	module.exports = __webpack_require__(148);

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(30);
	__webpack_require__(23);
	module.exports = __webpack_require__(149);

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(3)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(152);
	var $Object = __webpack_require__(3).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(153);
	var $Object = __webpack_require__(3).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(154);
	module.exports = __webpack_require__(3).Object.getPrototypeOf;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(155);
	module.exports = __webpack_require__(3).Object.setPrototypeOf;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(75);
	__webpack_require__(23);
	__webpack_require__(30);
	__webpack_require__(156);
	module.exports = __webpack_require__(3).Promise;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(157);
	__webpack_require__(75);
	__webpack_require__(158);
	__webpack_require__(159);
	module.exports = __webpack_require__(3).Symbol;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(23);
	__webpack_require__(30);
	module.exports = __webpack_require__(51).f('iterator');

/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(12)
	  , toLength  = __webpack_require__(47)
	  , toIndex   = __webpack_require__(147);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(7)
	  , createDesc      = __webpack_require__(22);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(27)
	  , gOPS    = __webpack_require__(69)
	  , pIE     = __webpack_require__(43);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(15)
	  , call        = __webpack_require__(64)
	  , isArrayIter = __webpack_require__(63)
	  , anObject    = __webpack_require__(6)
	  , toLength    = __webpack_require__(47)
	  , getIterFn   = __webpack_require__(52);
	module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 132 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(20);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(20);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(42)
	  , descriptor     = __webpack_require__(22)
	  , setToStringTag = __webpack_require__(28)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(4)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(27)
	  , toIObject = __webpack_require__(12);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(29)('meta')
	  , isObject = __webpack_require__(16)
	  , has      = __webpack_require__(10)
	  , setDesc  = __webpack_require__(7).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(21)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(5)
	  , macrotask = __webpack_require__(74).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(20)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(7)
	  , anObject = __webpack_require__(6)
	  , getKeys  = __webpack_require__(27);
	
	module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(12)
	  , gOPN      = __webpack_require__(68).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(9)
	  , core    = __webpack_require__(3)
	  , fails   = __webpack_require__(21);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(5)
	  , core        = __webpack_require__(3)
	  , dP          = __webpack_require__(7)
	  , DESCRIPTORS = __webpack_require__(8)
	  , SPECIES     = __webpack_require__(4)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(6)
	  , aFunction = __webpack_require__(37)
	  , SPECIES   = __webpack_require__(4)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(46)
	  , defined   = __webpack_require__(39);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(46)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(6)
	  , get      = __webpack_require__(52);
	module.exports = __webpack_require__(3).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(38)
	  , ITERATOR  = __webpack_require__(4)('iterator')
	  , Iterators = __webpack_require__(17);
	module.exports = __webpack_require__(3).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(15)
	  , $export        = __webpack_require__(9)
	  , toObject       = __webpack_require__(48)
	  , call           = __webpack_require__(64)
	  , isArrayIter    = __webpack_require__(63)
	  , toLength       = __webpack_require__(47)
	  , createProperty = __webpack_require__(129)
	  , getIterFn      = __webpack_require__(52);
	
	$export($export.S + $export.F * !__webpack_require__(66)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(126)
	  , step             = __webpack_require__(136)
	  , Iterators        = __webpack_require__(17)
	  , toIObject        = __webpack_require__(12);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(65)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(42)});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperty: __webpack_require__(7).f});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(48)
	  , $getPrototypeOf = __webpack_require__(70);
	
	__webpack_require__(142)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(73).set});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(26)
	  , global             = __webpack_require__(5)
	  , ctx                = __webpack_require__(15)
	  , classof            = __webpack_require__(38)
	  , $export            = __webpack_require__(9)
	  , isObject           = __webpack_require__(16)
	  , anObject           = __webpack_require__(6)
	  , aFunction          = __webpack_require__(37)
	  , anInstance         = __webpack_require__(127)
	  , forOf              = __webpack_require__(131)
	  , setProto           = __webpack_require__(73).set
	  , speciesConstructor = __webpack_require__(145)
	  , task               = __webpack_require__(74).set
	  , microtask          = __webpack_require__(139)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(4)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(143)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(28)($Promise, PROMISE);
	__webpack_require__(144)(PROMISE);
	Wrapper = __webpack_require__(3)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(66)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(5)
	  , has            = __webpack_require__(10)
	  , DESCRIPTORS    = __webpack_require__(8)
	  , $export        = __webpack_require__(9)
	  , redefine       = __webpack_require__(72)
	  , META           = __webpack_require__(138).KEY
	  , $fails         = __webpack_require__(21)
	  , shared         = __webpack_require__(45)
	  , setToStringTag = __webpack_require__(28)
	  , uid            = __webpack_require__(29)
	  , wks            = __webpack_require__(4)
	  , wksExt         = __webpack_require__(51)
	  , wksDefine      = __webpack_require__(50)
	  , keyOf          = __webpack_require__(137)
	  , enumKeys       = __webpack_require__(130)
	  , isArray        = __webpack_require__(134)
	  , anObject       = __webpack_require__(6)
	  , toIObject      = __webpack_require__(12)
	  , toPrimitive    = __webpack_require__(49)
	  , createDesc     = __webpack_require__(22)
	  , _create        = __webpack_require__(42)
	  , gOPNExt        = __webpack_require__(141)
	  , $GOPD          = __webpack_require__(67)
	  , $DP            = __webpack_require__(7)
	  , $keys          = __webpack_require__(27)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = gOPD(it = toIObject(it), key = toPrimitive(key, true));
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	      configurable: true,
	      set: function(value){
	        if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	        setSymbolDesc(this, tag, createDesc(1, value));
	      }
	    });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(68).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(43).f  = $propertyIsEnumerable;
	  __webpack_require__(69).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(26)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(50)('asyncIterator');

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(50)('observable');

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module, process) {"use strict";
	
	var _promise = __webpack_require__(112);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _setPrototypeOf = __webpack_require__(60);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(31);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(36);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _iterator = __webpack_require__(14);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(33);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!function (global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol = typeof _symbol2.default === "function" && _iterator2.default || "@@iterator";
	
	  var inModule = ( false ? "undefined" : (0, _typeof3.default)(module)) === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = (0, _create2.default)((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      prototype[method] = function (arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction ||
	    // For the native GeneratorFunction constructor, the best we can
	    // do is to check its .name property.
	    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };
	
	  runtime.mark = function (genFun) {
	    if (_setPrototypeOf2.default) {
	      (0, _setPrototypeOf2.default)(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = (0, _create2.default)(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function (arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument ? _promise2.default.resolve(value.arg).then(invokeNext, invokeThrow) : _promise2.default.resolve(value).then(function (unwrapped) {
	        // When a yielded Promise is resolved, its final value becomes
	        // the .value of the Promise<{value,done}> result for the
	        // current iteration. If the Promise is rejected, however, the
	        // result for this iteration will be rejected with the same
	        // reason. Note that rejections of yielded Promises are not
	        // thrown back into the generator function, as is the case
	        // when an awaited Promise is rejected. This difference in
	        // behavior between yield and await is important, because it
	        // allows the consumer to decide what to do with the yielded
	        // rejection (swallow it and continue, manually .throw it back
	        // into the generator, abandon iteration, whatever). With
	        // await, by contrast, there is no opportunity to examine the
	        // rejection reason outside the generator function, so the
	        // only option is to throw it from the await expression, and
	        // let the generator function handle the exception.
	        result.value = unwrapped;
	        return result;
	      });
	    }
	
	    if ((typeof process === "undefined" ? "undefined" : (0, _typeof3.default)(process)) === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	      // If enqueue has been called before, then we want to wait until
	      // all previous Promises have been resolved before calling invoke,
	      // so that results are always delivered in the correct order. If
	      // enqueue has not been called before, then it is important to
	      // call invoke immediately, without waiting on a callback to fire,
	      // so that the async generator function has the opportunity to do
	      // any necessary setup in a predictable way. This predictability
	      // is why the Promise constructor synchronously invokes its
	      // executor callback, and why async functions synchronously
	      // execute code before the first await. Since we implement simple
	      // async functions in terms of async generators, it is especially
	      // important to get this right, even though it requires care.
	      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
	      // Avoid propagating failures to Promises returned by later
	      // invocations of the iterator.
	      callInvokeWithMethodAndArg) : new _promise2.default(function (resolve) {
	        resolve(callInvokeWithMethodAndArg());
	      });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
	
	    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	    : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function () {
	    return this;
	  };
	
	  Gp.toString = function () {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function (object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	            next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function stop() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	}(
	// Among the various tricks for obtaining a reference to the global
	// object, this seems to be the most reliable technique that does not
	// use indirect eval (which violates Content Security Policy).
	(typeof global === "undefined" ? "undefined" : (0, _typeof3.default)(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : (0, _typeof3.default)(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : (0, _typeof3.default)(self)) === "object" ? self : undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(54)(module), __webpack_require__(76)))

/***/ },
/* 161 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if(true) {
		var lastData;
		var upToDate = function upToDate() {
			return lastData.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(true, function(err, updatedModules) {
				if(err) {
					if(module.hot.status() in {
							abort: 1,
							fail: 1
						}) {
						console.warn("[HMR] Cannot apply update. Need to do a full reload!");
						console.warn("[HMR] " + err.stack || err.message);
						window.location.reload();
					} else {
						console.warn("[HMR] Update failed: " + err.stack || err.message);
					}
					return;
				}
	
				if(!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					window.location.reload();
					return;
				}
	
				if(!upToDate()) {
					check();
				}
	
				__webpack_require__(163)(updatedModules, updatedModules);
	
				if(upToDate()) {
					console.log("[HMR] App is up to date.");
				}
	
			});
		};
		var addEventListener = window.addEventListener ? function(eventName, listener) {
			window.addEventListener(eventName, listener, false);
		} : function(eventName, listener) {
			window.attachEvent("on" + eventName, listener);
		};
		addEventListener("message", function(event) {
			if(typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
				lastData = event.data;
				if(!upToDate() && module.hot.status() === "idle") {
					console.log("[HMR] Checking for updates on the server...");
					check();
				}
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}


/***/ },
/* 163 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function(moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});
	
		if(unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function(moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}
	
		if(!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function(moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDZhODMzMzBlYjFkOWE1MjFiOTciLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9RdWV1ZS9RdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0RvdWJsZUxpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9TdGF0aWNMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQmluYXJ5U29ydGVkVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9leGNoYW5nZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXJyYXkvQ3Jvc3NMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9BcnJheS9UU01hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQmluYXJ5VHJlZS9odWZmTWFuQ29kaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9HZW5lcmFsaXplZExpc3QvR0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dyYXBoL0FNTEdyYXBoLmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BZGphY2VuY3lMaXN0R3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoLmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9PTEdyYXBoLmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9MaW5lYXJMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9RdWV1ZS9DeWNsZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL3NyYy9RdWV1ZS9Qcmlvcml0eVF1ZXVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQVZMVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0JQbHVzVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0JUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQmluYXJ5U2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9IYXNoVGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9SZWRCbGFja1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9TT1NUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvZmlib25hY2NpU2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvc2VxdWVudGlhbFNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kaXN0cmlidXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvaW5zZXJ0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L21lcmdpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvc2VsZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9TdHJpbmcvSFN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RyaW5nL0xTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0cmluZy9TU3RyaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJlZ2lzdGVyL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9kZXYtc2VydmVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy1hcHBseS1yZXN1bHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQSxtRUFBMkQ7QUFDM0Q7QUFDQTtBQUNBOztBQUVBLG9EQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCO0FBQzNCO0FBQ0EsWUFBSTtBQUNKO0FBQ0EsV0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxzREFBOEM7QUFDOUM7QUFDQSxxQ0FBNkI7O0FBRTdCLCtDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ04sYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTCxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBNkI7QUFDN0IscUNBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBLDREQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsVUFBVTtBQUNiO0FBQ0EsRzs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNOQSwwQzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEc7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNoQkEsMEM7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTyxVQUFVLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxHQUFHO0FBQ1I7QUFDQSxHOzs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7Ozs7Ozs7O0FDMUVBOztBQUVBO0FBQ0E7QUFD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QkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsRUFBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsRUFBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsRUFBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsRUFBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7QUFDQSxrQkFBaUIsTUFBakIsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7O0FBRUEsa0JBQWlCLFlBQWpCOztBQUtBLEtBQUksVUFBVSxJQUFJLGtCQUFKLENBQXVCLEVBQXZCLEVBQTJCLEVBQTNCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLEVBQXJDLENBQWQ7O0FBRUEsU0FBUSxTQUFSLENBQWtCLEdBQWxCO0FBQ0EsU0FBUSxTQUFSLENBQWtCLEdBQWxCO0FBQ0EsU0FBUSxTQUFSLENBQWtCLEdBQWxCO0FBQ0EsU0FBUSxTQUFSLENBQWtCLEdBQWxCO0FBQ0EsU0FBUSxTQUFSLENBQWtCLEdBQWxCO0FBQ0EsU0FBUSxT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QUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksS0FBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE9BQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxNQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLElBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE1BQVo7O0FBRUEsU0FBUSxHQUFSLENBQVksWUFBWjtBQUNBLFNBQVEsR0FBUixDQUFZLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBWjtBQUNBLFNBQVEsR0FBUixDQUFZLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBWjtBQUNBLFNBQVEsR0FBUixDQUFZLEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBWjtBQUNBLFNBQVEsR0FBUixDQUFZLEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBWjs7QUFFQSxTQUFRLEdBQVIsQ0FBWSxXQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksT0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksTUFBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksTUFBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksSUFBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFS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QUNIO0FBQ0o7O0FBRUQsb0JBQU8sS0FBUDtBQUNIOzs7OztBQUdMLEtBQUksT0FBTyxJQUFJLFFBQUosRUFBWDs7QUFFQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksS0FBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE9BQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxNQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLElBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksS0FBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE1BQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksSUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE1BQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjs7QUFFQSxTQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksTUFBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaOztBQUVBLE1BQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxJQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxNQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksS0FBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE9B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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSIsImZpbGUiOiIuL2RhdGEtc3RydWN0dXJlLWRlYnVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0dmFyIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrID0gdGhpc1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR0aGlzW1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IFxyXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0XHRpZihwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gXHRcdHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuIFx0XHRzY3JpcHQuY2hhcnNldCA9IFwidXRmLThcIjtcclxuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xyXG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChjYWxsYmFjaykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydFwiKSk7XHJcbiBcdFx0dHJ5IHtcclxuIFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiBcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzb25cIjtcclxuIFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSAxMDAwMDtcclxuIFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcclxuIFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiBcdFx0fVxyXG4gXHRcdHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcbiBcdFx0XHRcdC8vIHRpbWVvdXRcclxuIFx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9yKFwiTWFuaWZlc3QgcmVxdWVzdCB0byBcIiArIHJlcXVlc3RQYXRoICsgXCIgdGltZWQgb3V0LlwiKSk7XHJcbiBcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXHJcbiBcdFx0XHRcdGNhbGxiYWNrKCk7XHJcbiBcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XHJcbiBcdFx0XHRcdC8vIG90aGVyIGZhaWx1cmVcclxuIFx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9yKFwiTWFuaWZlc3QgcmVxdWVzdCB0byBcIiArIHJlcXVlc3RQYXRoICsgXCIgZmFpbGVkLlwiKSk7XHJcbiBcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHQvLyBzdWNjZXNzXHJcbiBcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuIFx0XHRcdFx0XHRjYWxsYmFjayhlKTtcclxuIFx0XHRcdFx0XHRyZXR1cm47XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdXBkYXRlKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9O1xyXG4gXHR9XHJcblxuIFx0XHJcbiBcdFxyXG4gXHQvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iZWY0NWIwL3NyYy9zaGFyZWQvdXRpbHMvY2FuRGVmaW5lUHJvcGVydHkuanNcclxuIFx0dmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XHJcbiBcdHRyeSB7XHJcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInhcIiwge1xyXG4gXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHt9XHJcbiBcdFx0fSk7XHJcbiBcdFx0Y2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xyXG4gXHR9IGNhdGNoKHgpIHtcclxuIFx0XHQvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcclxuIFx0fVxyXG4gXHRcclxuIFx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xyXG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcIjQ2YTgzMzMwZWIxZDlhNTIxYjk3XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XHJcbiBcdHZhciBob3RDdXJyZW50UGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgbWUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRpZighbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xyXG4gXHRcdHZhciBmbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuIFx0XHRcdGlmKG1lLmhvdC5hY3RpdmUpIHtcclxuIFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xyXG4gXHRcdFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKSA8IDApXHJcbiBcdFx0XHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMucHVzaChtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdFx0aWYobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA8IDApXHJcbiBcdFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0Zm9yKHZhciBuYW1lIGluIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfX3dlYnBhY2tfcmVxdWlyZV9fLCBuYW1lKSkge1xyXG4gXHRcdFx0XHRpZihjYW5EZWZpbmVQcm9wZXJ0eSkge1xyXG4gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgKGZ1bmN0aW9uKG5hbWUpIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0XHR9KG5hbWUpKSk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0Zm5bbmFtZV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBlbnN1cmUoY2h1bmtJZCwgY2FsbGJhY2spIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5lKGNodW5rSWQsIGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgZm4pO1xyXG4gXHRcdFx0XHR9IGZpbmFsbHkge1xyXG4gXHRcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFxyXG4gXHRcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xyXG4gXHRcdFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFx0aWYoY2FuRGVmaW5lUHJvcGVydHkpIHtcclxuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJlXCIsIHtcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0dmFsdWU6IGVuc3VyZVxyXG4gXHRcdFx0fSk7XHJcbiBcdFx0fSBlbHNlIHtcclxuIFx0XHRcdGZuLmUgPSBlbnN1cmU7XHJcbiBcdFx0fVxyXG4gXHRcdHJldHVybiBmbjtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaG90ID0ge1xyXG4gXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxyXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXHJcbiBcdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcclxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXHJcbiBcdFxyXG4gXHRcdFx0Ly8gTW9kdWxlIEFQSVxyXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxyXG4gXHRcdFx0YWNjZXB0OiBmdW5jdGlvbihkZXAsIGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxyXG4gXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjaztcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkRlY2xpbmVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm51bWJlclwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRkaXNwb3NlOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0cmVtb3ZlRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHJcbiBcdFx0XHQvLyBNYW5hZ2VtZW50IEFQSVxyXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxyXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxyXG4gXHRcdFx0c3RhdHVzOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3RTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxyXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXHJcbiBcdFx0fTtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGlibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90Q2FsbGJhY2s7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSwgY2FsbGJhY2spIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcclxuIFx0XHRpZih0eXBlb2YgYXBwbHkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGZhbHNlO1xyXG4gXHRcdFx0Y2FsbGJhY2sgPSBhcHBseTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xyXG4gXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRob3REb3dubG9hZE1hbmlmZXN0KGZ1bmN0aW9uKGVyciwgdXBkYXRlKSB7XHJcbiBcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gXHRcdFx0aWYoIXVwZGF0ZSkge1xyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xyXG4gXHRcdFx0XHRjYWxsYmFjayhudWxsLCBudWxsKTtcclxuIFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGlibGVGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdXBkYXRlLmMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdGhvdEF2YWlsaWJsZUZpbGVzTWFwW3VwZGF0ZS5jW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdXBkYXRlLmg7XHJcbiBcdFxyXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuIFx0XHRcdGhvdENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcclxuIFx0XHRcdHZhciBjaHVua0lkID0gMDtcclxuIFx0XHRcdHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xyXG4gXHRcdFx0XHQvKmdsb2JhbHMgY2h1bmtJZCAqL1xyXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aWYoIWhvdEF2YWlsaWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcclxuIFx0XHRcdHJldHVybjtcclxuIFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IGZhbHNlO1xyXG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcdGlmKC0taG90V2FpdGluZ0ZpbGVzID09PSAwICYmIGhvdENodW5rc0xvYWRpbmcgPT09IDApIHtcclxuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpIHtcclxuIFx0XHRpZighaG90QXZhaWxpYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0fSBlbHNlIHtcclxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlcysrO1xyXG4gXHRcdFx0aG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwicmVhZHlcIik7XHJcbiBcdFx0dmFyIGNhbGxiYWNrID0gaG90Q2FsbGJhY2s7XHJcbiBcdFx0aG90Q2FsbGJhY2sgPSBudWxsO1xyXG4gXHRcdGlmKCFjYWxsYmFjaykgcmV0dXJuO1xyXG4gXHRcdGlmKGhvdEFwcGx5T25VcGRhdGUpIHtcclxuIFx0XHRcdGhvdEFwcGx5KGhvdEFwcGx5T25VcGRhdGUsIGNhbGxiYWNrKTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRjYWxsYmFjayhudWxsLCBvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucywgY2FsbGJhY2spIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdGlmKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdGNhbGxiYWNrID0gb3B0aW9ucztcclxuIFx0XHRcdG9wdGlvbnMgPSB7fTtcclxuIFx0XHR9IGVsc2UgaWYob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xyXG4gXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRvcHRpb25zID0ge307XHJcbiBcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRpZihlcnIpIHRocm93IGVycjtcclxuIFx0XHRcdH07XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZSkge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFttb2R1bGVdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcbiBcdFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyBtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYobW9kdWxlSWQgPT09IDApIHtcclxuIFx0XHRcdFx0XHRyZXR1cm47XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XHJcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArIG1vZHVsZUlkICsgXCIgaW4gXCIgKyBwYXJlbnRJZCk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiBbb3V0ZGF0ZWRNb2R1bGVzLCBvdXRkYXRlZERlcGVuZGVuY2llc107XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XHJcbiBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHR2YXIgaXRlbSA9IGJbaV07XHJcbiBcdFx0XHRcdGlmKGEuaW5kZXhPZihpdGVtKSA8IDApXHJcbiBcdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcclxuIFx0XHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXHJcbiBcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdHZhciBhcHBsaWVkVXBkYXRlID0ge307XHJcbiBcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSB0b01vZHVsZUlkKGlkKTtcclxuIFx0XHRcdFx0dmFyIHJlc3VsdCA9IGdldEFmZmVjdGVkU3R1ZmYobW9kdWxlSWQpO1xyXG4gXHRcdFx0XHRpZighcmVzdWx0KSB7XHJcbiBcdFx0XHRcdFx0aWYob3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0Y29udGludWU7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIpKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xyXG4gXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gaG90VXBkYXRlW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHRbMF0pO1xyXG4gXHRcdFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIHJlc3VsdFsxXSkge1xyXG4gXHRcdFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRbMV0sIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XHJcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sIHJlc3VsdFsxXVttb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxyXG4gXHRcdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHR2YXIgbW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xyXG4gXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxyXG4gXHRcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XHJcbiBcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcbiBcdFx0d2hpbGUocXVldWUubGVuZ3RoID4gMCkge1xyXG4gXHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRpZighbW9kdWxlKSBjb250aW51ZTtcclxuIFx0XHJcbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xyXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcclxuIFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0dmFyIGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cclxuIFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xyXG4gXHRcdFx0XHRpZighY2hpbGQpIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHR2YXIgaWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdHZhciBpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcclxuIFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBOb3QgaW4gXCJhcHBseVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XHJcbiBcdFxyXG4gXHRcdGhvdEN1cnJlbnRIYXNoID0gaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcclxuIFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXTtcclxuIFx0XHRcdFx0XHR2YXIgY2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcclxuIFx0XHRcdFx0XHRpZihjYWxsYmFja3MuaW5kZXhPZihjYikgPj0gMCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgY2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdGNiKG91dGRhdGVkRGVwZW5kZW5jaWVzKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXHJcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHR2YXIgbW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcclxuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH0gZWxzZSBpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxyXG4gXHRcdGlmKGVycm9yKSB7XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xyXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0Y2FsbGJhY2sobnVsbCwgb3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0fVxyXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbiBcdFx0XHRob3Q6IGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCksXG4gXHRcdFx0cGFyZW50czogaG90Q3VycmVudFBhcmVudHMsXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBob3RDcmVhdGVSZXF1aXJlKDApKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNDZhODMzMzBlYjFkOWE1MjFiOTdcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjMuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOmYn+WIl1F1ZXVlXHJcbiAqXHJcbiAqIOmYn+WIl+aYr+S4gOenjeWFiOi/m+WFiOWHuu+8iGZpcnN0IGluIGZpcnN0IG91dCwgRklGT++8ieeahOe6v+aAp+ihqOOAguWug+WPquWFgeiuuOWcqOihqOeahOS4gOerr+i/m+ihjOaPkuWFpe+8jOiAjOWcqOWPpuS4gOerr+WIoOmZpOWFg+e0oOOAglxyXG4gKiDlhYHorrjmj5LlhaXnmoTkuIDnq6/lj6vpmJ/lsL7vvIhyZWFy77yJ77yM5YWB6K645Yig6Zmk55qE5LiA56uv5Y+r6Zif5aS077yIZnJvbnTvvInjgIJcclxuICovXHJcblxyXG4vLyDpk77pmJ/liJdcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFyID09PSBudWxsO1xyXG4gICAgfVxyXG4gICAgY2xlYXIgKCkge1xyXG4gICAgICAgIHRoaXMucmVhciA9IHRoaXMuZnJvbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXRIZWFkICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9udCA/IHRoaXMuZnJvbnQuZGF0YSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBlblF1ZXVlIChlbGVtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IHtkYXRhOiBlbGVtLCBuZXh0OiBudWxsfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcCA9IHtkYXRhOiBlbGVtLCBuZXh0OiBudWxsfTtcclxuICAgICAgICAgICAgdGhpcy5yZWFyLm5leHQgPSBwO1xyXG4gICAgICAgICAgICB0aGlzLnJlYXIgPSBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNpemUrKztcclxuICAgIH1cclxuICAgIGRlUXVldWUgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb250KSB7XHJcbiAgICAgICAgICAgIGxldCBlbGVtID0gdGhpcy5mcm9udC5kYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmZyb250ID0gdGhpcy5mcm9udC5uZXh0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNpemUtLTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcXVldWVUcmF2ZXJzZSAoaXRlcmF0b3IpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZnJvbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKGN1cnJlbnQuZGF0YSkpIGJyZWFrO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBlZWtBdCAoaW5kZXggPSAwKSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5zaXplKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5mcm9udDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhcnIgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZnJvbnQ7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnNpemU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSBjdXJyZW50LmRhdGE7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxucXVldWUuZW5RdWV1ZSgxKTtcclxucXVldWUuZGVRdWV1ZSgpO1xyXG5xdWV1ZS5lblF1ZXVlKDIpO1xyXG5xdWV1ZS5lblF1ZXVlKDMpO1xyXG5jb25zb2xlLmxvZyhxdWV1ZS5wZWVrQXQoMCkpO1xyXG5jb25zb2xlLmxvZyhxdWV1ZS5wZWVrQXQoMSkpO1xyXG5jb25zb2xlLmxvZyhxdWV1ZS5wZWVrQXQoMikpO1xyXG5jb25zb2xlLmxvZyhxdWV1ZS5wZWVrQXQoMykpO1xyXG5jb25zb2xlLmxvZyhxdWV1ZS50b1N0cmluZygpLmpvaW4oKSk7XHJcblxyXG5cclxuXHJcbi8vIOexu+S8vOW5v+W6puS8mOWFiOmBjeWOhlxyXG5mdW5jdGlvbiByZXBhaW50Q29sb3IobWF0cml4LCBpLCBqLCBjb2xvcil7XHJcbiAgICBsZXQgb2xkID0gbWF0cml4W2ldW2pdO1xyXG4gICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICBsZXQgbSA9IG1hdHJpeC5sZW5ndGggLSAxO1xyXG4gICAgbGV0IG4gPSBtYXRyaXhbMF0ubGVuZ3RoIC0gMTtcclxuXHJcbiAgICBxdWV1ZS5lblF1ZXVlKHt4OiBpLCB5OiBqfSk7XHJcblxyXG4gICAgd2hpbGUocXVldWUucmVhcil7XHJcbiAgICAgICAgbGV0IGEgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgbGV0IHggPSBhLng7XHJcbiAgICAgICAgbGV0IHkgPSBhLnk7XHJcblxyXG4gICAgICAgIGlmKHggPj0gMSkgc2V0Q29sb3IoeCAtIDEsIHkpO1xyXG4gICAgICAgIGlmKHkgPj0gMSkgc2V0Q29sb3IoeCwgeSAtIDEpO1xyXG4gICAgICAgIGlmKHggPCBtKSBzZXRDb2xvcih4ICsgMSwgeSk7XHJcbiAgICAgICAgaWYoeSA8IG4pIHNldENvbG9yKHgsIHkgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRDb2xvcih4LCB5KXtcclxuICAgICAgICBpZihtYXRyaXhbeF1beV0gPT09IG9sZCkge1xyXG4gICAgICAgICAgICBtYXRyaXhbeF1beV0gPSBjb2xvcjtcclxuICAgICAgICAgICAgcXVldWUuZW5RdWV1ZSh7eDogeCwgeTogeX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubGV0IG1hdHJpeCA9IFtdO1xyXG5cclxuZm9yKGxldCBpID0gMDsgaSA8IDg7IGkrKyl7XHJcbiAgICBtYXRyaXhbaV0gPSBbXTtcclxuICAgIGZvcihsZXQgaiA9IDA7IGogPCA4OyBqKyspe1xyXG4gICAgICAgIG1hdHJpeFtpXVtqXSA9IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbnJlcGFpbnRDb2xvcihtYXRyaXgsIDQsIDUsIDEpO1xyXG5jb25zb2xlLmxvZyhtYXRyaXgpO1xyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvUXVldWUvUXVldWUuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDmoJHnmoTkuIDkupvmpoLlv7VcclxuICpcclxuICog5qCR77yIVHJlZe+8ieaYr27vvIhuPj0w77yJ5Liq57uT54K555qE5pyJ6ZmQ6ZuG44CC5Zyo5Lu75oSP5LiA5qO16Z2e56m65qCR5Lit77yaXHJcbiAqIO+8iDHvvInmnInkuJTku4XmnInkuIDkuKrnibnlrprnmoTnp7DkuLrmoLnvvIhSb29077yJ55qE57uT54K577ybXHJcbiAqIO+8iDLvvInlvZNuPjHml7bvvIzlhbbkvZnnu5Pngrnlj6/liIbkuLptKG0+MCnkuKrkupLkuI3nm7jkuqTnmoTmnInpmZDpm4ZUMSxUMixUMywuLi5Ube+8jOWFtuS4reavj+S4gOS4qumbhuWQiOacrOi6q+WPiOaYr+S4gOajteagke+8jOW5tuS4lOensOS4uuagueeahOWtkOagke+8iFN1YnRyZWXvvInjgIJcclxuICpcclxuICog5L6L5aaC77yM77yIYe+8ieaYr+WPquacieS4gOS4quaguee7k+eCueeahOagke+8m1xyXG4gKiDvvIhi77yJ5piv5pyJMTPkuKrnu5PngrnnmoTmoJHvvIzlhbbkuK1B5piv5qC577yM5YW25L2Z57uT54K55YiG5oiQM+S4quS6kuS4jeebuOS6pOeahOWtkOmbhu+8mlQxPXtCLEUsRixLLEx9LHQyPXtELEgsSSxKLE19O1QxLFQy5ZKMVDPpg73mmK/moLlB55qE5a2Q5qCR77yM5LiU5pys6Lqr5Lmf5piv5LiA5qO15qCR44CCXHJcbiAqXHJcbiAqIOagkeeahOe7k+eCueWMheWQq+S4gOS4quaVsOaNruWFg+e0oOWPiuiLpeW5suaMh+WQkeWFtuWtkOagkeeahOWIhuaUr+OAgue7k+eCueaLpeacieeahOWtkOagkeaVsOensOS4uue7k+eCueeahOW6pu+8iERlZ3JlZe+8ieOAguS+i+Wmgu+8jO+8iGLvvInkuK1B55qE5bqm5Li6M++8jEPnmoTluqbkuLox77yMRueahOW6puS4ujAu5bqm5Li6MOeahOe7k+eCueensOS4uuWPtuWtkO+8iExlYWbvvInmiJbogIXnu4jnq6/nu5PngrnjgILluqbkuI3kuLow55qE57uT54K556ew5Li66Z2e57uI56uv57uT54K55oiW5YiG5pSv57uT54K544CC5qCR55qE5bqm5piv5qCR5YaF5ZCE57uT54K555qE5bqm55qE5pyA5aSn5YC844CC77yIYu+8ieeahOagkeeahOW6puS4ujMu57uT54K555qE5a2Q5qCR55qE5qC556ew5Li66K+l57uT54K555qE5a2p5a2Q77yIQ2hpbGTvvInjgILnm7jlupTnmoTvvIzor6Xnu5Pngrnnp7DkuLrlranlrZDnmoTlj4zkurLvvIhQYXJlbnTvvInjgILlkIzkuIDkuKrlj4zkurLnmoTlranlrZDkuYvpl7TkupLnp7DlhYTlvJ/vvIhTaWJsaW5n77yJ44CC57uT54K555qE56WW5YWI5piv5LuO5qC55Yiw6K+l57uT54K55omA57uP5YiG5pSv5LiK55qE5omA5pyJ57uT54K544CC5Y+N5LmL77yM5Lul5p+Q57uT54K55Li65qC555qE5a2Q5qCR5Lit55qE5Lu75LiA57uT54K56YO956ew5Li66K+l57uT54K555qE5a2Q5a2Z44CCXHJcbiAqIOe7k+eCueeahOWxguasoe+8iExldmVs77yJ5LuO5qC55byA5aeL5a6a5LmJ6LW377yM5qC55Li656ys5LiA5bGC77yM6Lef55qE5a2p5a2Q5Li656ys5LqM5bGC44CC6Iul5p+Q57uT54K55Zyo56ysbOWxgu+8jOWImeWFtuWtkOagkeeahOagueWwseWcqOesrGwrMeWxguOAguWFtuWPjOS6suWcqOWQjOS4gOWxgueahOe7k+eCueS6kuS4uuWgguWFhOW8n+OAguS+i+Wmgu+8jOe7k+eCuUfkuI5F77yMRixILEksSuS6kuS4uuWgguWFhOW8n+OAguagkeS4ree7k+eCueeahOacgOWkp+WxguasoeensOS4uuagkeeahOa3seW6pu+8iERlcHRo77yJ5oiW6auY5bqm44CC77yIYu+8ieeahOagkeeahOa3seW6puS4ujTjgIJcclxuICpcclxuICog5aaC5p6c5bCG5qCR5Lit57uT54K555qE5ZCE5a2Q5qCR55yL5oiQ5LuO5bem6Iez5Y+z5piv5pyJ5qyh5bqP55qE77yI5Y2z5LiN6IO95Lqk5o2i77yJ77yM5YiZ56ew6K+l5qCR5Li65pyJ5bqP5qCR77yM5ZCm5YiZ56ew5Li65peg5bqP5qCR44CC5Zyo5pyJ5bqP5qCR5Lit5pyA5bem6L6555qE5a2Q5qCR55qE5qC556ew5Li656ys5LiA5Liq5a2p5a2Q77yM5pyA5Y+z6L6555qE56ew5Li65pyA5ZCO5LiA5Liq5a2p5a2Q44CCXHJcbiAqIOajruael++8iEZvcmVzdO+8ieaYr23vvIhtPj0w77yJ5qO15LqS5LiN55u45Lqk55qE5qCR55qE6ZuG5ZCI44CC5a+55qCR5Lit5q+P5Liq57uT54K56ICM6KiA77yM5YW25a2Q5qCR55qE6ZuG5ZCI5Y2z5Li65qOu5p6X44CCXHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIOS6jOWPieagke+8iEJpbmFyeSBUcmVl77yJ5piv5Y+m5LiA56eN5qCR5Z6L57uT5p6E77yM5a6D55qE54m554K55piv5q+P5Liq57uT54K56Iez5aSa5Y+q5pyJ5Lik5qO15a2Q5qCR77yI5Y2z5LqM5Y+J5qCR5Lit5LiN5a2Y5Zyo5bqm5aSn5LqOMueahOe7k+eCue+8ie+8jOW5tuS4lO+8jOS6jOWPieagkeeahOWtkOagkeacieW3puWPs+S5i+WIhu+8iOWFtuasoeW6j+S4jeiDveS7u+aEj+mioOWAkuOAgu+8iVxyXG4gKlxyXG4gKiDkuozlj4nmoJHnmoTmgKfotKhcclxuICogMS7lnKjkuozlj4nmoJHnmoTnrKxp5bGC5LiK6Iez5aSa5pyJMueahGktMeasoeaWueS4que7k+eCuShpPj0xKeOAglxyXG4gKiAyLua3seW6puS4umvnmoTkuozlj4nmoJHoh7PlpJrmnIky55qEa+asoeaWuS0x5Liq57uT54K577yMKGs+PTEp44CCXHJcbiAqIDMu5a+55Lu75L2V5LiA5qO15LqM5Y+J5qCRVO+8jOWmguaenOWFtue7iOerr+e7k+eCueaVsOS4um4w77yM5bqm5Li6MueahOe7k+eCueaVsOS4um4y77yM5YiZbjAgPSBuMiArIDE7XHJcbiAqICAgICAg5LiA5qO15rex5bqm5Li6a+S4lOaciTLnmoRr5qyh5pa5LTHkuKrnu5PngrnnmoTkuozlj4nmoJHnp7DkuLrmu6Hkuozlj4nmoJHjgIJcclxuICogICAgICDmt7HluqbkuLpr55qE77yM5pyJbuS4que7k+eCueeahOS6jOWPieagke+8jOW9k+S4lOS7heW9k+WFtuavj+S4gOS4que7k+eCuemDveS4jua3seW6puS4umvnmoTmu6Hkuozlj4nmoJHkuK3nvJblj7fku44x6IezbueahOe7k+eCueS4gOS4gOWvueW6lOaXtu+8jOensOS5i+S4uuWujOWFqOS6jOWPieagkeOAglxyXG4gKiDkuIvpnaLmmK/lrozlhajkuozlj4nmoJHnmoTkuKTkuKrnibnmgKdcclxuICogNC7lhbfmnIlu5Liq57uT54K555qE5a6M5YWo5LqM5Y+J5qCR55qE5rex5bqm5Li6TWF0aC5mbG9vcihsb2cgMiBuKSArIDFcclxuICogNS7lpoLmnpzlr7nkuIDmo7XmnIlu5Liq57uT54K555qE5a6M5YWo5LqM5Y+J5qCR77yI5YW25rex5bqm5Li6TWF0aC5mbG9vcihsb2cgMiBuKSArIDHvvInnmoTnu5PngrnmjInlsYLluo/nvJblj7fvvIjku47nrKwx5bGC5Yiw56ysTWF0aC5mbG9vcigyIG4pICsgMe+8jOavj+WxguS7juW3puWIsOWPs++8ie+8jOWImeWvueS7u+S4gOe7k+eCue+8iDE8PWk8PW7vvInmnInvvJpcclxuICogICAgICgxKeWmguaenGk9Me+8jOWImee7k+eCuWnjgIHmmK/kuozlj4nmoJHnmoTmoLnvvIzml6Dlj4zkurLvvJvlpoLmnpxpPjHvvIzliJnlhbblj4zkurJwYXJlbnQoaSnmmK/nu5PngrlNYXRoLmZsb29yKGkvMinjgIJcclxuICogICAgICgyKeWmguaenDJpID4gbu+8jOWImee7k+eCuWnml6Dlt6blranlrZDvvIjnu5Pngrlp5Li65Y+25a2Q57uT54K577yJ77yb5ZCm5YiZ5YW25bem5a2p5a2QTENoaWxkKGkp5piv57uT54K5MmkuXHJcbiAqICAgICAoMynlpoLmnpwyaSArIDEgPiBu77yM5YiZ57uT54K5aeaXoOWPs+WtqeWtkO+8m+WQpuWImeWFtuWPs+WtqeWtkFJDaGlsZChpKeaYr+e7k+eCuTJpICsgMTtcclxuICovXHJcblxyXG4vKlxyXG4g5LqM5Y+J5qCR55qE5a2Y5YKo57uT5p6EXHJcblxyXG4gMS7pobrluo/lrZjlgqjnu5PmnoRcclxuIOeUqOS4gOe7hOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeiHquS4iuiAjOS4i++8jOiHquW3puiHs+WPs+WtmOWCqOWujOWFqOS6jOWPieagkeS4iueahOe7k+eCueWFg+e0oO+8jOWNs+WwhuS6jOWPieagkeS4iue8luWPt+S4umnnmoTnu5PngrnlhYPntKDlrZjlgqjlnKjliqDkuIrlrprkuYnnmoTkuIDnu7TmlbDnu4TkuK3kuIvmoIfkuLppLTHnmoTliIbph4/kuK3jgILigJww4oCd6KGo56S65LiN5a2Y5Zyo5q2k57uT54K544CC6L+Z56eN6aG65bqP5a2Y5YKo57uT5p6E5LuF6YCC55So5LqO5a6M5YWo5LqM5Y+J5qCR44CCXHJcbiDlm6DkuLrvvIzlnKjmnIDlnY/mg4XlhrXkuIvvvIzkuIDkuKrmt7HluqbkuLpr5LiU5Y+q5pyJa+S4que7k+eCueeahOWNleaUr+agke+8iOagkeS4reS4jeWtmOWcqOW6puS4ujLnmoTnu5PngrnvvInljbTpnIDopoHplb/luqbkuLoy55qEbuasoeaWuS0x55qE5LiA57u05pWw57uE44CCXHJcblxyXG4gMi7pk77lvI/lrZjlgqjnu5PmnoRcclxuIOS6jOWPieagkeeahOe7k+eCueeUseS4gOS4quaVsOaNruWFg+e0oOWSjOWIhuWIq+aMh+WQkeWFtuW3puWPs+WtkOagkeeahOS4pOS4quWIhuaUr+aehOaIkO+8jOWImeihqOekuuS6jOWPieagkeeahOmTvuihqOS4reeahOe7k+eCueiHs+WwkeWMheWQq+S4ieS4quWfn++8muaVsOaNruWfn+WSjOW3puWPs+aMh+mSiOWfn+OAguacieaXtu+8jOS4uuS6huS+v+S6juaJvuWIsOe7k+eCueeahOWPjOS6su+8jOWImei/mOWPr+WcqOe7k+eCuee7k+aehOS4reWinuWKoOS4gOS4quaMh+WQkeWFtuWPjOS6sue7k+eCueeahOaMh+mSiOWfn+OAguWIqeeUqOi/meS4pOenjee7k+aehOaJgOW+l+eahOS6jOWPieagkeeahOWtmOWCqOe7k+aehOWIhuWIq+ensOS5i+S4uuS6jOWPiemTvuihqOWSjOS4ieWPiemTvuihqOOAglxyXG4g5Zyo5ZCr5pyJbuS4que7k+eCueeahOS6jOWPiemTvuihqOS4reaciW4rMeS4quepuumTvuWfn++8jOaIkeS7rOWPr+S7peWIqeeUqOi/meS6m+epuumTvuWfn+WtmOWCqOWFtuS7luacieeUqOS/oeaBr++8jOS7juiAjOW+l+WIsOWPpuS4gOenjemTvuW8j+WtmOWCqOe7k+aehC0tLee6v+e0oumTvuihqOOAglxyXG5cclxuIOWFiO+8iOague+8ieW6j+mBjeWOhu+8muagueW3puWPs1xyXG4g5Lit77yI5qC577yJ5bqP6YGN5Y6G77ya5bem5qC55Y+zXHJcbiDlkI7vvIjmoLnvvInluo/pgY3ljobvvJrlt6blj7PmoLlcclxuXHJcbiAqL1xyXG5cclxuXHJcbi8vIOmhuuW6j+WtmOWCqOe7k+aehFxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgLy8g6aG65bqP5a2Y5YKo57uT5p6E55qE6YGN5Y6GXHJcbiAgICBsZXQgdHJlZSA9IFsxLCAyLCAzLCA0LCA1LCAsIDYsICwgLCA3XTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygncHJlT3JkZXI6Jyk7XHJcbiAgICB2b2lkIGZ1bmN0aW9uIHByZU9yZGVyUmVjdXJzaXZlKHgsIHZpc2l0KSB7XHJcbiAgICAgICAgdmlzaXQodHJlZVt4XSk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgcHJlT3JkZXJSZWN1cnNpdmUoMiAqIHggKyAxLCB2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkgcHJlT3JkZXJSZWN1cnNpdmUoMiAqIHggKyAyLCB2aXNpdCk7XHJcbiAgICB9KDAsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdpbk9yZGVyOicpO1xyXG4gICAgdm9pZCBmdW5jdGlvbiBpbk9yZGVyUmVjdXJzaXZlKHgsIHZpc2l0KSB7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgaW5PcmRlclJlY3Vyc2l2ZSgyICogeCArIDEsIHZpc2l0KTtcclxuICAgICAgICB2aXNpdCh0cmVlW3hdKTtcclxuICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSBpbk9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgfSgwLCAodmFsdWUpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygncG9zdE9yZGVyOicpO1xyXG4gICAgdm9pZCBmdW5jdGlvbiBwb3N0T3JkZXJSZWN1cnNpdmUoeCwgdmlzaXQpIHtcclxuICAgICAgICBpZiAodHJlZVsyICogeCArIDFdKSBwb3N0T3JkZXJSZWN1cnNpdmUoMiAqIHggKyAxLCB2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkgcG9zdE9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgICAgIHZpc2l0KHRyZWVbeF0pO1xyXG4gICAgfSgwLCAodmFsdWUpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICB9KTtcclxufSgpKTtcclxuXHJcbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XHJcblxyXG4vLyDpk77lvI/lrZjlgqjnu5PmnoRcclxuZXhwb3J0IGNsYXNzIEJpbmFyeVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIGxlZnRDaGlsZCA9IG51bGwsIHJpZ2h0Q2hpbGQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvLyDlt6blj7PlranlrZDnu5PngrlcclxuICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreS4pOajteagkeaYr+WQpuebuOS8vFxyXG4gICAgaXNTaW1pbGFyKHRyZWUpIHtcclxuICAgICAgICByZXR1cm4gISEodHJlZSAmJlxyXG4gICAgICAgICgodGhpcy5sZWZ0Q2hpbGQgJiYgdGhpcy5sZWZ0Q2hpbGQuaXNTaW1pbGFyKHRyZWUubGVmdENoaWxkKSkgfHwgKCF0aGlzLmxlZnRDaGlsZCAmJiAhdHJlZS5sZWZ0Q2hpbGQpKSAmJlxyXG4gICAgICAgICgodGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5pc1NpbWlsYXIodHJlZS5yaWdodENoaWxkKSkgfHwgKCF0aGlzLnJpZ2h0Q2hpbGQgJiYgIXRyZWUucmlnaHRDaGlsZCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVCaW5hcnlUcmVlKHRyZWUpIHtcclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHByZU9yZGVyUmVjdXJzaXZlKG5vZGUsIHgsIHZpc2l0KSB7XHJcbiAgICAgICAgICAgIHZpc2l0KG5vZGUsIHRyZWVbeF0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHA7XHJcbiAgICAgICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIHAgPSBub2RlLmxlZnRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmVPcmRlclJlY3Vyc2l2ZShwLCAyICogeCArIDEsIHZpc2l0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gbm9kZS5yaWdodENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcclxuICAgICAgICAgICAgICAgIHByZU9yZGVyUmVjdXJzaXZlKHAsIDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocCkgcC5wYXJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB9KHRoaXMsIDAsIChub2RlLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUHJlZml4IGl0ZXJhdGlvbiAqL1xyXG4gICAgKiBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmRhdGE7XHJcbiAgICAgICAgaWYodGhpcy5sZWZ0Q2hpbGQpIHlpZWxkKiB0aGlzLmxlZnRDaGlsZDtcclxuICAgICAgICBpZih0aGlzLnJpZ2h0Q2hpbGQpIHlpZWxkKiB0aGlzLnJpZ2h0Q2hpbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5YWI5bqP6YGN5Y6G5LqM5Y+J5qCR55qE6Z2e6YCS5b2S566X5rOVXHJcbiAgICBwcmVPcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIGxldCBwID0gdGhpcztcclxuXHJcbiAgICAgICAgd2hpbGUgKHAgfHwgc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIOWQkeW3pui1sOWIsOWwveWktFxyXG4gICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAubGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDkuK3luo/pnZ7pgJLlvZLpgY3ljoZcclxuICAgIGluT3JkZXJOb25SZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBsZXQgcCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHdoaWxlIChwIHx8IHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHAgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDkuLrkuobljLrliIbkuKTmrKHov4fmoIjnmoTkuI3lkIzlpITnkIbmlrnlvI/vvIzlnKjloIbmoIjkuK3lop7liqDkuIDkuKptYXJr5Z+f77yMXHJcbiAgICAvLyBtYXJrPTDooajnpLrliJrliJrorr/pl67mraTnu5PngrnvvIxtYXJrPTHooajnpLrlt6blrZDmoJHlpITnkIbnu5PmnZ/ov5Tlm57vvIxcclxuICAgIC8vIG1hcms9MuihqOekuuWPs+WtkOagkeWkhOeQhue7k+adn+i/lOWbnuOAguavj+asoeagueaNruagiOmhtueahG1hcmvln5/lhrPlrprlgZrkvZXliqjkvZxcclxuICAgIHBvc3RPcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHN0YWNrLnB1c2goW3RoaXMsIDBdKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGFbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtub2RlLCAxXSk7ICAvLyDkv67mlLltYXJr5Z+fXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdENoaWxkKSBzdGFjay5wdXNoKFtub2RlLmxlZnRDaGlsZCwgMF0pOyAgLy8g6K6/6Zeu5bem5a2Q5qCRXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChbbm9kZSwgMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2goW25vZGUucmlnaHRDaGlsZCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSAmJiB2aXNpdChub2RlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcmVPcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIHZpc2l0KHRoaXMuZGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5wcmVPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLnByZU9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcclxuICAgIH1cclxuXHJcbiAgICBpbk9yZGVyUmVjdXJzaXZlKHZpc2l0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcclxuICAgICAgICB2aXNpdCh0aGlzLmRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcclxuICAgIH1cclxuXHJcbiAgICBwb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXZlbE9yZGVyVHJhdmVyc2UodmlzaXQpIHtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICBxdWV1ZS5lblF1ZXVlKHRoaXMpO1xyXG5cclxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICBsZXQgcCA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgcC5kYXRhICYmIHZpc2l0KHAuZGF0YSk7XHJcbiAgICAgICAgICAgIHAubGVmdENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgICAgICBwLnJpZ2h0Q2hpbGQgJiYgcXVldWUuZW5RdWV1ZShwLnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLlhYjluo/luo/liJfkuLpr55qE57uT54K555qE5YC8XHJcbiAgICBnZXRQcmVTZXF1ZW5jZShrKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBsZXQgZGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gaylcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gIG5vZGUuZGF0YTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0odGhpcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguS6jOWPieagkeS4reWPtuWtkOe7k+eCueeahOaVsOebrlxyXG4gICAgY291bnRMZWF2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybiAwO1xyXG4gICAgICAgICAgICBlbHNlIGlmICghbm9kZS5sZWZ0Q2hpbGQgJiYgIW5vZGUucmlnaHRDaGlsZCkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpICsgcmVjdXJzZShub2RlLnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH0odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Lqk5o2i5omA5pyJ57uT54K555qE5bem5Y+z5a2Q5qCRXHJcbiAgICByZXZvbHV0ZUJpbmFyeVRyZWUoKSB7XHJcbiAgICAgICAgW3RoaXMubGVmdENoaWxkLCB0aGlzLnJpZ2h0Q2hpbGRdID0gW3RoaXMucmlnaHRDaGlsZCwgdGhpcy5sZWZ0Q2hpbGRdO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnJldm9sdXRlQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5yZXZvbHV0ZUJpbmFyeVRyZWUoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXZvbHV0ZU5vblJlY3Vyc2l2ZSgpe1xyXG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgICAgIHN0YWNrLnB1c2godGhpcyk7XHJcblxyXG4gICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIFtub2RlLmxlZnRDaGlsZCwgbm9kZS5yaWdodENoaWxkXSA9IFtub2RlLnJpZ2h0Q2hpbGQsIG5vZGUubGVmdENoaWxkXTtcclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUubGVmdENoaWxkKSBzdGFjay5wdXNoKG5vZGUubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgaWYobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKG5vZGUucmlnaHRDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguS6jOWPieagkeS4reS7peWAvOS4unjnmoTnu5PngrnkuLrmoLnnmoTlrZDmoJHmt7HluqZcclxuICAgIGdldFN1YkRlcHRoKHgpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHN0YWNrLnB1c2godGhpcyk7XHJcblxyXG4gICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmRhdGEgPT09IHgpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gbm9kZS5nZXREZXB0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2gobm9kZS5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIGdldERlcHRoKCkge1xyXG4gICAgICAgIGxldCBtID0gdGhpcy5sZWZ0Q2hpbGQgJiYgdGhpcy5sZWZ0Q2hpbGQuZ2V0RGVwdGgoKSB8fCAwO1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5nZXREZXB0aCgpIHx8IDA7XHJcbiAgICAgICAgcmV0dXJuIChtID4gbiA/IG0gOiBuKSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yig6Zmk5omA5pyJ5Lul5YWD57SgeOS4uuagueeahOWtkOagkVxyXG4gICAgZGVsU3ViWCh4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PT0geCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5kZWxTdWJYKHgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQuZGVsU3ViWCh4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpnZ7pgJLlvZLlpI3liLbkuozlj4nmoJFcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIOaLt+i0nei/h+eoi+S4reS8muaJp+ihjOeahOWbnuiwg++8jOWPr+S7peeUqOadpeaLt+i0neWFtuWug+iHquWumuS5ieWxnuaAp1xyXG4gICAgICogQHJldHVybnMge0NzdHJ9IOi/lOWbnuaWsOeahOWunuS+i1xyXG4gICAgICovXHJcbiAgICBjb3B5KGNiID0gZnVuY3Rpb24oKXt9KSB7XHJcbiAgICAgICAgLy8g55So5p2l5a2Y5pS+5pys5L2T57uT54K555qE5qCIXHJcbiAgICAgICAgbGV0IHN0YWNrMSA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIC8vIOeUqOadpeWtmOaUvuaWsOS6jOWPieagkee7k+eCueeahOagiFxyXG4gICAgICAgIGxldCBzdGFjazIgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBzdGFjazEucHVzaCh0aGlzKTtcclxuICAgICAgICBsZXQgQ3N0ciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgbGV0IG5ld1RyZWUgPSBuZXcgQ3N0cigpO1xyXG4gICAgICAgIGxldCBxID0gbmV3VHJlZTtcclxuICAgICAgICBzdGFjazIucHVzaChuZXdUcmVlKTtcclxuICAgICAgICBsZXQgcDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrMS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8g5ZCR5bem6LWw5Yiw5bC95aS0XHJcbiAgICAgICAgICAgIHdoaWxlICgocCA9IHN0YWNrMS5wZWVrKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sZWZ0Q2hpbGQpIHEubGVmdENoaWxkID0gbmV3IENzdHIoKTtcclxuICAgICAgICAgICAgICAgIHEgPSBxLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwID0gc3RhY2sxLnBvcCgpO1xyXG4gICAgICAgICAgICBxID0gc3RhY2syLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YWNrMS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBzdGFjazEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBxID0gc3RhY2syLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAucmlnaHRDaGlsZCkgcS5yaWdodENoaWxkID0gbmV3IENzdHIoKTtcclxuICAgICAgICAgICAgICAgIHEuZGF0YSA9IHAuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNiKHEsIHApO1xyXG4gICAgICAgICAgICAgICAgcSA9IHEucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAucmlnaHRDaGlsZCk7ICAvLyDlkJHlj7PkuIDmraVcclxuICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3VHJlZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLkuozlj4nmoJHkuK3nu5Pngrlw5ZKMceeahOacgOi/keelluWFiFxyXG4gICAgZmluZE5lYXJBbmNpZW50KHBOb2RlLCBxTm9kZSkge1xyXG4gICAgICAgIGxldCBwYXRoUCA9IGZpbmRQYXRoKHRoaXMsIHBOb2RlLCAwKTtcclxuICAgICAgICBsZXQgcGF0aFEgPSBmaW5kUGF0aCh0aGlzLCBxTm9kZSwgMCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBwYXRoUFtpXSA9PSBwYXRoUVtpXSAmJiBwYXRoUFtpXTsgaSsrKTtcclxuICAgICAgICByZXR1cm4gcGF0aFBbLS1pXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0b2RvXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLkuIDmo7Xkuozlj4nmoJHnmoTnuYHojILluqZcclxuICAgIGx1c2hEZWdyZWUoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50QXJyID0gW107XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh7XHJcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXHJcbiAgICAgICAgICAgIGxheWVyOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8g5Yip55So5bGC5bqP6YGN5Y6G5p2l57uf6K6h5ZCE5bGC55qE57uT54K55pWwXHJcbiAgICAgICAgbGV0IHI7XHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgciA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgY291bnRBcnJbci5sYXllcl0gPSAoY291bnRBcnJbci5sYXllcl0gfHwgMCkgKyAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIubm9kZS5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiByLm5vZGUubGVmdENoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChyLm5vZGUucmlnaHRDaGlsZClcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHIubm9kZS5yaWdodENoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmnIDlkI7kuIDkuKrpmJ/liJflhYPntKDmiYDlnKjlsYLlsLHmmK/moJHnmoTpq5jluqZcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gci5sYXllcjtcclxuICAgICAgICBsZXQgbWF4ID0gY291bnRBcnJbMF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGNvdW50QXJyW2ldOyBpKyspXHJcbiAgICAgICAgICAgIC8vIOaxguWxguacgOWkp+e7k+eCueaVsFxyXG4gICAgICAgICAgICBpZiAoY291bnRBcnJbaV0gPiBtYXgpIG1heCA9IGNvdW50QXJyW2ldO1xyXG5cclxuICAgICAgICByZXR1cm4gaGVpZ2h0ICogbWF4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguagkee7k+eCueeahOWtkOWtmeaAu+aVsOWhq+WFpWRlc2NOdW3ln5/kuK3vvIzlubbov5Tlm55cclxuICAgIGRlc2NOdW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xyXG4gICAgICAgICAgICBsZXQgZDtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIGVsc2UgZCA9IHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpICsgcmVjdXJzZShub2RlLnJpZ2h0Q2hpbGQpICsgMjtcclxuXHJcbiAgICAgICAgICAgIG5vZGUuZGVzY051bSA9IGQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICB9KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreS6jOWPieagkeaYr+WQpuWujOWFqOS6jOWPieagkVxyXG4gICAgc3RhdGljIGlzRnVsbEJpbmFyeVRyZWUodHJlZSkge1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIGxldCBmbGFnID0gMDtcclxuICAgICAgICBxdWV1ZS5lblF1ZXVlKHRyZWUpO1xyXG5cclxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICBsZXQgcCA9IHF1ZXVlLmRlUXVldWUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcCkgZmxhZyA9IDE7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIOaxguS7jnRyZWXliLBub2Rl57uT54K56Lev5b6E55qE6YCS5b2S566X5rOVXHJcbmZ1bmN0aW9uIGZpbmRQYXRoKHRyZWUsIG5vZGUsIGkgPSAwKSB7XHJcbiAgICBsZXQgcGF0aCA9IFtdO1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgdm9pZCBmdW5jdGlvbiByZWN1cnNlKHRyZWUsIGkpIHtcclxuICAgICAgICBpZiAodHJlZSA9PSBub2RlKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGF0aFtpXSA9IHRyZWU7XHJcbiAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSByZWN1cnNlKHRyZWUubGVmdENoaWxkLCBpICsgMSk7XHJcbiAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCAmJiAhZm91bmQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCBpICsgMSk7XHJcbiAgICAgICAgaWYgKCFmb3VuZCkgcGF0aFtpXSA9IG51bGw7XHJcbiAgICB9KHRyZWUsIGkpO1xyXG5cclxuICAgIHJldHVybiBwYXRoO1xyXG59XHJcblxyXG5sZXQgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzOycpKCk7XHJcblxyXG4vLyDmsYLmt7HluqbnrYnkuo7moJHnmoTpq5jluqblh4/kuIDnmoTmnIDpnaDlt6bnmoTnu5PngrlcclxuZnVuY3Rpb24gcHJpbnRQYXRoX21heERlcHRoUzEodHJlZSl7XHJcbiAgICBsZXQgbWF4aCA9IHRyZWUuZ2V0RGVwdGgoKTtcclxuICAgIGxldCBwYXRoID0gW107XHJcblxyXG4gICAgaWYgKG1heGggPCAyKSByZXR1cm4gZmFsc2U7XHJcbiAgICBmaW5kX2godHJlZSwgMSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZF9oKHRyZWUsIGgpIHtcclxuICAgICAgICBwYXRoW2hdID0gdHJlZTtcclxuXHJcbiAgICAgICAgaWYgKGggPT0gbWF4aCAtIDEpIHtcclxuICAgICAgICAgICAgbGV0IHMgPSAnICc7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBwYXRoW2ldOyBpKyspIHMgKz0gcGF0aFtpXS5kYXRhICsgKHBhdGhbaSArIDFdID8gJyAtPiAnIDogJycpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgZmluZF9oKHRyZWUubGVmdENoaWxkLCBoICsgMSk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIGZpbmRfaCh0cmVlLnJpZ2h0Q2hpbGQsIGggKyAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhdGhbaF0gPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgdHJlZSA9IFsxLCAyLCAzLCA0LCA1LCAsIDYsICwgLCA3XTtcclxudmFyIHRlc3QgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG50ZXN0LmNyZWF0ZUJpbmFyeVRyZWUodHJlZSk7XHJcblxyXG5jb25zb2xlLmxvZygnaXRlcmF0b3I6ICcpO1xyXG5mb3IobGV0IHggb2YgdGVzdCl7XHJcbiAgICBjb25zb2xlLmxvZyh4KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiDmoJHnmoQz56eN5bi455So6ZO+6KGo57uT5p6EXHJcbiAqL1xyXG5cclxuLy8gMS7lj4zkurLooajnpLrms5VcclxuLy8g5LyY54K577yacGFyZW50KHRyZWUsIHgp5pON5L2c5Y+v5Lul5Zyo5bi46YeP5pe26Ze05YaF5a6e546wXHJcbi8vIOe8uueCue+8muaxgue7k+eCueeahOWtqeWtkOaXtumcgOimgemBjeWOhuaVtOS4que7k+aehFxyXG5leHBvcnQgY2xhc3MgUGFyZW50VHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVwdGgoKSB7XHJcbiAgICAgICAgbGV0IG1heERlcHRoID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBkZXAgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+PSAwOyBqID0gdGhpcy5ub2Rlc1tpXS5wYXJlbnQpIGRlcCsrO1xyXG4gICAgICAgICAgICBpZiAoZGVwID4gbWF4RGVwdGgpIG1heERlcHRoID0gZGVwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1heERlcHRoO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBQYXJlbnRUcmVlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgcGFyZW50ID0gMCkge1xyXG4gICAgICAgIC8vIHR5cGU6IFBhcmVudFRyZWVcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIC8vIOWPjOS6suS9jee9ruWfnyB7TnVtYmVyfVxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgcHQgPSBuZXcgUGFyZW50VHJlZSgpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnUicsIC0xKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdBJywgMCkpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnQicsIDApKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0MnLCAwKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdEJywgMSkpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRScsIDEpKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0YnLCAzKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdHJywgNikpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnSCcsIDYpKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0knLCA2KSk7XHJcblxyXG5cclxuLy8g5a2p5a2Q6KGo56S65rOVXHJcblxyXG5leHBvcnQgY2xhc3MgQ2hpbGRUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREZXB0aCgpIHtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN1YkRlcHRoKHJvb3RJbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYubm9kZXNbcm9vdEluZGV4XSkgcmV0dXJuIDE7XHJcblxyXG4gICAgICAgICAgICBsZXQgc2QgPSAxO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gc2VsZi5ub2Rlc1tyb290SW5kZXhdOyBwOyBwID0gcC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHN1YkRlcHRoKHAuY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPiBzZCkgc2QgPSBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2QgKyAxO1xyXG4gICAgICAgIH0odGhpcy5kYXRhWzBdKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhXHJcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gZmlyc3RDaGlsZCDlranlrZDpk77ooajlpLTmjIfpkohcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBDaGlsZFRyZWVCb3gge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIGZpcnN0Q2hpbGQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICog5a2p5a2Q57uT54K5XHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGlsZFxyXG4gKiBAcGFyYW0ge0NoaWxkVHJlZU5vZGV9IG5leHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBDaGlsZFRyZWVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoaWxkID0gbnVsbCwgbmV4dCA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcclxuICAgIH1cclxufVxyXG5cclxuLypcclxuIOWtqeWtkOihqOekuuazleS+v+S6jua2ieWPiuWtqeWtkOeahOaTjeS9nOeahOWunueOsO+8jOS9huS4jemAgueUqOS6jnBhcmVudOaTjeS9nOOAglxyXG4g5oiR5Lus5Y+v5Lul5oqK5Y+M5Lqy6KGo56S65rOV5ZKM5a2p5a2Q6KGo56S65rOV57uT5ZCI6LW35p2l44CCXHJcbiAqL1xyXG5cclxuXHJcbi8vIOWtqeWtkOWFhOW8n+ihqOekuuazlSjkuozlj4nmoJHooajnpLrms5UpXHJcbi8vIOWPr+WinuiuvuS4gOS4qnBhcmVudOWfn+WunueOsHBhcmVudOaTjeS9nFxyXG5leHBvcnQgY2xhc3MgQ2hpbGRTaWJsaW5nVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgZmlyc3RDaGlsZCA9IG51bGwsIG5leHRTaWJsaW5nID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gZmlyc3RDaGlsZDtcclxuICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6L6T5Ye65a2p5a2Q5YWE5byf6ZO+6KGo6KGo56S655qE5qCR55qE5ZCE6L65XHJcbiAgICBwcmludCgpIHtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHRoaXMuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJyVjICVjJywgdGhpcy5kYXRhLCBjaGlsZC5kYXRhKTtcclxuICAgICAgICAgICAgY2hpbGQucHJpbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5a2p5a2Q5YWE5byf6ZO+6KGo6KGo56S655qE5qCR55qE5Y+25a2Q5pWw55uuXHJcbiAgICBsZWFmQ291bnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0Q2hpbGQpIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHRoaXMuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ICs9IGNoaWxkLmxlYWZDb3VudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5qCR55qE5bqmXHJcbiAgICBnZXREZWdyZWUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0Q2hpbGQpIHJldHVybiAwO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGVncmVlID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIGRlZ3JlZSsrO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkID0gcC5nZXREZWdyZWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkID4gZGVncmVlKSBkZWdyZWUgPSBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVncmVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXREZXB0aCgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gZ2xvYmFsKSByZXR1cm4gMDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG1heGQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy5maXJzdENoaWxkOyBwOyBwID0gcC5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGQgPSBwLmdldERlcHRoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG1heGQpIG1heGQgPSBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWF4ZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZS5qc1xuICoqLyIsIi8qKlxyXG4gKiDmoIhcclxuICpcclxuICog5piv6ZmQ5a6a5LuF5Zyo6KGo5bC+6L+b6KGM5o+S5YWl5oiW5Yig6Zmk5pON5L2c55qE57q/5oCn6KGo44CC6KGo5bC+5Li65qCI6aG277yIdG9w77yJ77yM6KGo5aS05Li65qCI5bqV77yIYm90dG9t77yJ77yM5LiN5ZCr5YWD57Sg55qE56m66KGo5Li656m65qCI44CCXHJcbiAqIOagiOWPiOensOS4uuWQjui/m+WFiOWHuu+8iGxhc3QgaW4gZmlyc3Qgb3V077yJ55qE57q/5oCn6KGo44CCXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIOmhuuW6j+agiFxyXG4gKiDmoIjnmoTpobrluo/lrZjlgqjnu5PmnoTmmK/liKnnlKjkuIDnu4TlnLDlnYDov57nu63nmoTlrZjlgqjljZXlhYPkvp3mrKHlrZjmlL7oh7PmoIjlupXliLDmoIjpobbnmoTlhYPntKDvvIzlkIzml7bpmYTorr7mjIfpkoh0b3DmjIfnpLrmoIjpobblhYPntKDlnKjpobrluo/moIjkuK3nmoTkvY3nva7jgIJcclxuICpcclxuICovXHJcblxyXG4vLyDmoIjnmoTpk77lvI/ooajnpLpcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50b3AgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2l6ZSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBpc0VtcHR5KCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgcHVzaCAoZGF0YSkge1xyXG4gICAgICAgIGxldCBub2RlID0ge1xyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBuZXh0OiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy50b3A7XHJcbiAgICAgICAgdGhpcy50b3AgPSBub2RlO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICB9XHJcbiAgICBwZWVrICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b3AgPT09IG51bGwgP1xyXG4gICAgICAgICAgICBudWxsIDpcclxuICAgICAgICAgICAgdGhpcy50b3AuZGF0YTtcclxuICAgIH1cclxuICAgIHBvcCAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IG91dCA9IHRoaXMudG9wO1xyXG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AubmV4dDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dC5kYXRhO1xyXG4gICAgfVxyXG4gICAgY2xlYXIgKCkge1xyXG4gICAgICAgIHRoaXMudG9wID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy50b3A7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnNpemU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSBjdXJyZW50LmRhdGE7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuXHJcbnN0YWNrLnB1c2goMSk7XHJcbnN0YWNrLnB1c2goJ2FzZCcpO1xyXG5cclxuc3RhY2sucG9wKCk7XHJcbnN0YWNrLnB1c2goe2E6IDF9KTtcclxuY29uc29sZS5sb2coc3RhY2spO1xyXG5cclxuLyoqXHJcbiAqIOi/memHjOeUqOWtl+espuS4snRyYWlu6KGo56S654Gr6L2m77yMSOihqOekuuehrOW4re+8jFPooajnpLrova/luK1cclxuICogQHBhcmFtIHtTdHJpbmd9IHRyYWluXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFpbkFycmFuZ2UodHJhaW4pe1xyXG4gICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICBsZXQgcSA9IFtdO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IGogPSAwO1xyXG5cclxuICAgIHdoaWxlKHRyYWluW2ldKXtcclxuICAgICAgICBpZih0cmFpbltpXSA9PT0gJ0gnKSBzdGFjay5wdXNoKHRyYWluW2ldKTtcclxuICAgICAgICBlbHNlIHFbaisrXSA9IHRyYWluW2ldO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZShzdGFjay5sZW5ndGgpe1xyXG4gICAgICAgIGxldCBjID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcVtqKytdID0gYztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcSArICcnO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygndHJhaW5BcnJhbmdlOiAnICsgdHJhaW5BcnJhbmdlKCdIU1NIU1NTSEhISEhTJykpOyAgLy8gdHJhaW5BcnJhbmdlOiBTLFMsUyxTLFMsUyxILEgsSCxILEgsSCxIXHJcblxyXG5cclxuLy8g5Yik5pat5a2X56ym5Liy5Lit4oCcJuKAneWJjeWSjOKAnCbigJ3lkI7pg6jliIbmmK/lkKbkuLrpgIbkuLLvvIxcIkBcIuihqOekuue7k+adn+espu+8jOaYr+WImei/lOWbnnRydWXvvIzlkKbliJnov5Tlm55mYWxzZVxyXG5mdW5jdGlvbiBpc1JldmVyc2Uoc3RyKXtcclxuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgbGV0IGkgPSAwO1xyXG5cclxuICAgIHdoaWxlKHN0cltpXSAhPT0gJyYnKXtcclxuICAgICAgICBpZihzdHJbaV0gPT09ICdAJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHN0YWNrLnB1c2goc3RyW2ldKTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgaSsrO1xyXG5cclxuICAgIHdoaWxlKHN0cltpXSAhPT0gJ0AnKSB7XHJcbiAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgcyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGlmKHMgIT09IHN0cltpXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIXN0YWNrLmxlbmd0aDtcclxufVxyXG5cclxuY29uc29sZS5sb2coJ2lzUmV2ZXJzZTogJyArIGlzUmV2ZXJzZSgnYWJjZCZkY2JhQGEnKSk7ICAvLyB0cnVlXHJcblxyXG5cclxuLy8g5pWw5YC86L+b5Yi26L2s5o2iXHJcbi8vIOWFrOW8j++8miBOID0gKE4gLyBkKSAqIGQgKyBOICUgZFxyXG4vLyBO77ya5Y2B6L+b5Yi25pWw5YC877yMIGTvvJrpnIDopoHovazmjaLnmoTov5vliLbmlbBcclxuZnVuY3Rpb24gbnVtVHJhbnNmb3JtKG51bWJlciwgcmFkKSB7XHJcbiAgICBsZXQgcyA9IG5ldyBTdGFjaygpO1xyXG5cclxuICAgIHdoaWxlIChudW1iZXIpIHtcclxuICAgICAgICBzLnB1c2gobnVtYmVyICUgcmFkKTtcclxuICAgICAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIgLyA4LCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFyciA9IFtdO1xyXG4gICAgd2hpbGUgKHMudG9wKSB7XHJcbiAgICAgICAgYXJyLnB1c2gocy5wb3AoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhhcnIuam9pbignJykpO1xyXG59XHJcblxyXG5udW1UcmFuc2Zvcm0oMTM0OCwgOCk7XHJcbm51bVRyYW5zZm9ybSgxMzQ4LCAyKTtcclxuXHJcblxyXG4vLyDmi6zlj7fljLnphY3mo4Dmn6VcclxuZnVuY3Rpb24gYnJhY2tldHNNYXRjaChzdHIpIHtcclxuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgbGV0IHRleHQgPSAnJztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHJbaV07XHJcbiAgICAgICAgaWYgKGMgPT09ICdbJykge1xyXG4gICAgICAgICAgICBzdGFjay5wdXNoKGMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoIHx8IHN0YWNrLnBvcCgpICE9PSAnWycpIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBicmFja2V0czonICsgYyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dCArPSBjO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhicmFja2V0c01hdGNoKCdbYXNkXScpKTtcclxuXHJcbmZ1bmN0aW9uIE1hdGNoZXIobGVmdCwgcmlnaHQpIHtcclxuICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB0aGlzLnN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbn1cclxuTWF0Y2hlci5wcm90b3R5cGUgPSB7XHJcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGMgPSBzdHJbaV07XHJcbiAgICAgICAgICAgIGlmIChjID09PSB0aGlzLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChjKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSB0aGlzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2sucG9wKCkgIT09IHRoaXMubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBicmFja2V0czonICsgYyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gJywnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG59O1xyXG5sZXQgbSA9IG5ldyBNYXRjaGVyKCd7JywgJ30nKTtcclxubS5tYXRjaCgnW3sxMjN9MTIzJyk7XHJcblxyXG5mdW5jdGlvbiBMaW5lRWRpdG9yKHN0cikge1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgdGhpcy5zdHIgPSBzdHIgfHwgJyc7XHJcbn1cclxuTGluZUVkaXRvci5wcm90b3R5cGUgPSB7XHJcbiAgICBnZXRSZXN1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnN0YWNrO1xyXG4gICAgICAgIGxldCBzdHIgPSB0aGlzLnN0cjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjID0gc3RyW2ldO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gc3RhY2subGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnQuZGF0YSArIHJlc3VsdDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgbGUgPSBuZXcgTGluZUVkaXRvcignd2hsaSMjaWxyI2UocyMqcylcXFxyXG4gICAgXFxub3V0Y2hhQHB1dGNoYXIoKnM9IysrKScpO1xyXG5jb25zb2xlLmxvZyhsZS5nZXRSZXN1bHQoKSk7XHJcblxyXG5cclxubGV0IHByaW90eSA9IHtcclxuICAgIFwiK1wiOiAxLFxyXG4gICAgXCItXCI6IDEsXHJcbiAgICBcIiVcIjogMixcclxuICAgIFwiKlwiOiAyLFxyXG4gICAgXCIvXCI6IDIsXHJcbiAgICBcIl5cIjogMyxcclxuICAgIFwiKFwiOiAwLFxyXG4gICAgXCIpXCI6IDAsXHJcbiAgICBcImBcIjogLTFcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRvb3Aob3AsIG9wbjEsIG9wbjIpIHtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gb3BuMSArIG9wbjI7XHJcbiAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgLSBvcG4yO1xyXG4gICAgICAgIGNhc2UgXCIqXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBvcG4xICogb3BuMjtcclxuICAgICAgICBjYXNlIFwiL1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gb3BuMSAvIG9wbjI7XHJcbiAgICAgICAgY2FzZSBcIiVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgJSBvcG4yO1xyXG4gICAgICAgIGNhc2UgXCJeXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhvcG4xLCBvcG4yKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb3Bjb21wKGEsIGIpIHtcclxuICAgIHJldHVybiBwcmlvdHlbYV0gLSBwcmlvdHlbYl07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbEluZml4RXhwcmVzc2lvbihleHApIHtcclxuICAgIGxldCBjcyA9IFtdO1xyXG4gICAgbGV0IG5zID0gW107XHJcbiAgICBleHAgPSBleHAucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xyXG4gICAgZXhwICs9ICdgJztcclxuICAgIGlmIChleHBbMF0gPT09ICctJykge1xyXG4gICAgICAgIGV4cCA9IFwiMFwiICsgZXhwO1xyXG4gICAgfVxyXG4gICAgbGV0IGM7XHJcbiAgICBsZXQgb3A7XHJcbiAgICBsZXQgb3BuMTtcclxuICAgIGxldCBvcG4yO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHAubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gZXhwW2ldO1xyXG4gICAgICAgIC8vIOWmguaenOaYr+aTjeS9nOesplxyXG4gICAgICAgIGlmIChjIGluIHByaW90eSkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzlj7PovrnkuI3mmK/lt6bmi6zlj7fkuJTmk43kvZznrKbmoIjnmoTmoIjpobblhYPntKDkvJjlhYjmnYPmr5Tlj7PovrnlpKdcclxuICAgICAgICAgICAgLy8g5b6q546v6YGN5Y6G6L+b6KGM6L+e57ut6L+Q566XXHJcbiAgICAgICAgICAgIHdoaWxlIChjICE9ICcoJyAmJiBjcy5sZW5ndGggJiYgb3Bjb21wKGNzW2NzLmxlbmd0aCAtIDFdLCBjKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlh7rmoIjnmoTmk43kvZznrKZcclxuICAgICAgICAgICAgICAgIG9wID0gY3MucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkuI3mmK/lt6bmi6zlj7fmiJbogIXlj7Pmi6zlj7fvvIzor7TmmI7mmK/ov5DnrpfnrKZcclxuICAgICAgICAgICAgICAgIGlmIChvcCAhPSAnKCcgJiYgb3AgIT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Ye65qCI5L+d5a2Y5pWw5a2X55qE5qCI55qE5Lik5Liq5YWD57SgXHJcbiAgICAgICAgICAgICAgICAgICAgb3BuMiA9IG5zLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wbjEgPSBucy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlsIbkuI7mk43kvZznrKbov5DnrpflkI7nmoTnu5Pmnpzkv53lrZjliLDmoIjpobZcclxuICAgICAgICAgICAgICAgICAgICBucy5wdXNoKGRvb3Aob3AsIG9wbjEsIG9wbjIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDlpoLmnpzlj7PovrnkuI3mmK/lj7Pmi6zlj7fvvIzkv53lrZjliLDmk43kvZznrKbmoIjkuK1cclxuICAgICAgICAgICAgaWYgKGMgIT0gJyknKSBjcy5wdXNoKGMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOWkmuS9jeaVsOeahOaVsOWtl+eahOaDheWGtVxyXG4gICAgICAgICAgICB3aGlsZSAoIShleHBbaV0gaW4gcHJpb3R5KSkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgYyArPSBleHBbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbnMucHVzaChwYXJzZUZsb2F0KGMpKTtcclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBucy5sZW5ndGggPyBuc1swXSA6IE5hTjtcclxufVxyXG5cclxubGV0IGV4cDEgPSBjYWxJbmZpeEV4cHJlc3Npb24oJzUrMyo0LzItMl4zKzUlMicpO1xyXG5jb25zb2xlLmxvZyhleHAxKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU3RhY2svaW5kZXguanNcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGxkcCBvbiAyMDE1LzQvMTIuXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XHJcbiAgICByZXR1cm4gYSAtIGI7XHJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxyXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcclxubW9kdWxlLmV4cG9ydHMgPSAoXHJcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcclxuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxyXG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcclxuXHJcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcclxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xyXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXHJcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcclxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXHJcbiAgICAsIGd0ICAgICA9ICc+J1xyXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcclxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcclxuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBpZihPICE9PSBudWxsKXtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxyXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XHJcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcclxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOW+queOr+mTvuihqO+8iGNpcmN1bGFyIGxpbmtlZCBsaXN077yJXHJcbiAqIOaYr+WPpuS4gOenjeW9ouW8j+eahOmTvuW8j+WtmOWCqOe7k+aehOOAguWug+eahOeJueeCueaYr+ihqOS4reacgOWQjuS4gOS4que7k+eCueeahOaMh+mSiOWfn+aMh+WQkeWktOe7k+eCue+8jOaVtOS4quihqOW9ouaIkOS4gOS4queOr+OAglxyXG4gKiDlvqrnjq/pk77ooajnmoTmk43kvZzlkoznur/mgKfpk77ooajln7rmnKzkuIDoh7TvvIzku4XmnInnu4blvq7lt67liKvjgIJcclxuICovXHJcblxyXG4vKipcclxuICog5Y+M5ZCR6ZO+6KGoXHJcbiAqXHJcbiAqIOWPjOWQkemTvuihqOaYr+S4uuS6huWFi+acjeWNlemTvuihqOi/meenjeWNleWQkeaAp+eahOe8uueCueOAglxyXG4gKiDlj4zlkJHpk77ooajnmoTnu5PngrnkuK3mnInkuKTkuKrmjIfpkojln5/vvIzlhbbkuIDmjIflkJHnm7TmjqXlkI7nu6fvvIzlj6bkuIDmjIflkJHnm7TmjqXliY3otovjgIJcclxuICpcclxuICog5Y+M5ZCR6ZO+6KGo5Lmf5Y+v5Lul5pyJ5b6q546v6KGo44CCXHJcbiAqL1xyXG5cclxuY2xhc3MgTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmV2ID0gbnVsbCwgbmV4dCA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3Ioc3FMaXN0LCBjb21wYXJlID0gZGVmYXVsdENvbXBhcmUpIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xyXG5cclxuICAgICAgICBpZihzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHNxTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpe1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICB5aWVsZCBjdXJyZW50LmRhdGE7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCl7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1c2goZGF0YSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZGF0YSBhcmd1bWVudCByZXF1aXJlZCcpO1xyXG5cclxuICAgICAgICArK3RoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgTm9kZShkYXRhLCB0aGlzLnRhaWwsIG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICB1bnNoaWZ0KGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgYXJndW1lbnQgcmVxdWlyZWQnKTtcclxuXHJcbiAgICAgICAgKyt0aGlzLnNpemU7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gbmV3IE5vZGUoZGF0YSwgbnVsbCwgdGhpcy5oZWFkKTtcclxuICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC0tdGhpcy5zaXplO1xyXG5cclxuICAgICAgICB0aGlzLnRhaWwucHJldi5uZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcclxuICAgIH1cclxuXHJcbiAgICBzaGlmdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAtLXRoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5oZWFkLm5leHQucHJldiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHVwZGF0ZShpbmRleCwgZGF0YSl7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmZpbmRCeUluZGV4KGluZGV4LCB0cnVlKTtcclxuICAgICAgICBub2RlLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZShkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgYXJndW1lbnQgcmVxdWlyZWQnKTtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoZGF0YSwgY3VycmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgLS10aGlzLnNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IHRoaXMudGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YWlsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbC5wcmV2Lm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wcmV2Lm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uZXh0LnByZXYgPSBjdXJyZW50LnByZXY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpbmRleE9mKGRhdGEpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgaW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZShkYXRhLCBjdXJyZW50LmRhdGEpKSByZXR1cm4gaW5kZXg7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRCeUluZGV4KGluZGV4ID0gMCwgcmV0dXJuTm9kZSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBqID0gMDtcclxuXHJcbiAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICBpZiAoaisrID09PSBpbmRleCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0dXJuTm9kZSA/IGN1cnJlbnQgOiBjdXJyZW50LmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yRWFjaChjYiA9IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XHJcblxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBjYihjdXJyZW50LmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGxldCBsaXN0ID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChjdXJyZW50LmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvSlNPTigpICsgJyc7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5sZXQgYSA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KFsyLCAzXSk7XHJcbmEudW5zaGlmdCgxKTtcclxuYS5wdXNoKDQpO1xyXG5jb25zb2xlLmxvZyhhLmluZGV4T2YoNCkpO1xyXG5jb25zb2xlLmxvZyhhLmZpbmRCeUluZGV4KDIpKTtcclxuXHJcbmZvcihsZXQgaXRlbSBvZiBhKXtcclxuICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xyXG59XHJcblxyXG5hLnBvcCgpO1xyXG5hLnNoaWZ0KCk7XHJcbmEucmVtb3ZlKDIpO1xyXG5hLnJlbW92ZSgzMik7XHJcbmEucmVtb3ZlKDMpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0xpc3QvRG91YmxlTGlua2VkTGlzdC5qc1xuICoqLyIsIi8qKlxyXG4gKiDnlLHkuo7pk77ooajlnKjnqbrpl7TnmoTlkIjnkIbliKnnlKjkuIrlkozmj5LlhaXvvIzliKDpmaTml7bkuI3pnIDopoHnp7vliqjnrYnnmoTmnInngrnvvIzlm6DmraTlnKjlvojlpJrlnLrlkIjkuIvvvIzlroPmmK/nur/mgKfooajnmoTpppbpgInlrZjlgqjnu5PmnoTjgILnhLbogIzvvIzlroPkuZ/lrZjlnKjnnYDlrp7njrDmn5Dkupvln7rmnKzmk43kvZzvvIzlpoLmsYLnur/mgKfooajplb/luqbml7bkuI3lpoLpobrluo/lrZjlgqjnu5PmnoTnmoTnvLrngrnvvJvlj6bkuIDmlrnpnaLvvIznlLHkuo7lnKjpk77ooajkuK3vvIznu5PngrnkuYvpl7TnmoTlhbPns7vkvb/nlKjmjIfpkojmnaXooajnpLrvvIzliJnmlbDmja7lhYPntKDlnKjnur/mgKfooajkuK3nmoTigJzkvY3luo/igJ3nmoTmpoLlv7Xlt7Lmt6HljJbvvIzogIzooqvmlbDmja7lhYPntKDlnKjnur/mgKfpk77ooajkuK3nmoTigJzkvY3nva7igJ3miYDku6Pmm7/jgILkuLrmraTvvIzku47lrp7pmYXlh7rlj5Hph43mlrDlrprkuYnnur/mgKfpk77ooajlj4rlhbbln7rmnKzmk43kvZxcclxuICovXHJcblxyXG5jbGFzcyBOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBuZXh0ID0gbnVsbCl7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rZWRMaXN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHNxTGlzdCl7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoc3FMaXN0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goc3FMaXN0W2ldKTtcclxuICAgICAgICB9IFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzdGF0aWMgbWVyZ2VMaXN0IChhLCBiLCBjb21wYXJlID0gY29tcEZuKSB7XHJcbiAgICAgICAgbGV0IGhhID0gYS5oZWFkO1xyXG4gICAgICAgIGxldCBoYiA9IGIuaGVhZDtcclxuICAgICAgICBsZXQgcGEgPSBoYTtcclxuICAgICAgICBsZXQgcGIgPSBoYjtcclxuICAgICAgICBsZXQgYyA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbiAgICAgICAgbGV0IHE7XHJcblxyXG4gICAgICAgIHdoaWxlIChwYSAmJiBwYikge1xyXG4gICAgICAgICAgICBsZXQgZGF0YTEgPSBwYS5kYXRhO1xyXG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBwYi5kYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjb21wYXJlKGRhdGExLCBkYXRhMikpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBoZWFkIG5vZGVcclxuICAgICAgICAgICAgICAgIHEgPSBhLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIG5vZGUgdG8gYyBsaW5rZWRMaXN0XHJcbiAgICAgICAgICAgICAgICBjLmFwcGVuZChxKTtcclxuICAgICAgICAgICAgICAgIHBhID0gYS5oZWFkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcSA9IGIuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGMuYXBwZW5kKHEpO1xyXG4gICAgICAgICAgICAgICAgcGIgPSBiLmhlYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYSkgYy5hcHBlbmQocGEpO1xyXG4gICAgICAgIGVsc2UgYy5hcHBlbmQocGIpO1xyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuXHJcbiAgICAvLyBkZWxldGUgZmlyc3QgZWxlbWVudCBhbmQgcmV0dXJuIGl0XHJcbiAgICBzaGlmdCAoKSB7XHJcbiAgICAgICAgbGV0IGhlYWQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XHJcbiAgICAgICAgaGVhZC5uZXh0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gbnVsbCkgdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gaGVhZDtcclxuICAgIH1cclxuXHJcbiAgICBwb3AoKXtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgcHJldmlvdXMgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGVsZW07XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaWwgPT09IGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpcy50YWlsLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBwcmV2aW91cztcclxuXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgZWxlbSA9IGN1cnJlbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0gOiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBlbmQgbm9kZVxyXG4gICAgYXBwZW5kIChub2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBkYXRhXHJcbiAgICBwdXNoIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50YWlsLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSBkYXRhXHJcbiAgICByZW1vdmUgKGRhdGEpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgcHJldmlvdXMgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGVsZW07XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBjdXJyZW50LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGN1cnJlbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy50YWlsKSB0aGlzLnRhaWwgPSBwcmV2aW91cztcclxuXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgZWxlbSA9IGN1cnJlbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0gOiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpbmRleE9mKGRhdGEpe1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEgPT09IGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICB1bnNoaWZ0IChkYXRhKSB7XHJcbiAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICB0ZW1wLm5leHQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGVtcDtcclxuICAgIH1cclxuICAgIGluc2VydEFmdGVyICh0YXJnZXQsIGRhdGEpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5kYXRhID09PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMudGFpbCkgdGhpcy50YWlsID0gdGVtcDtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGl0ZW0gKGluZGV4KSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWluZGV4ID09PSAwKSByZXR1cm4gY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVhY2ggKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjdXJyZW50ID0gdGhpcy5oZWFkOyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5uZXh0KVxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soY3VycmVudCkpIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpe1xyXG4gICAgICAgIGZvcihsZXQgY3VycmVudCA9IHRoaXMuaGVhZDsgY3VycmVudDsgY3VycmVudCA9IGN1cnJlbnQubmV4dCl7XHJcbiAgICAgICAgICAgIHlpZWxkIGN1cnJlbnQuZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2l6ZSAoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IHNpemUgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICArK3NpemU7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLmVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgc3RyICs9IG5vZGUuZGF0YSArIChub2RlLm5leHQgPyAnLCcgOiAnJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgb3JkZXJJbnNlcnQgKGRhdGEsIGNtcCkge1xyXG4gICAgICAgIGNtcCA9IHR5cGVvZiBjbXAgPT09ICdmdW5jdGlvbicgPyBjbXAgOiAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYSA+IGIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gYilcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcHJldmlvdXMgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGxldCByZXQgPSBjbXAoZGF0YSwgY3VycmVudC5kYXRhKTtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5o+S5YWl5YWD57Sg5aSn5LqO5b2T5YmN5YWD57Sg77yM5YeG5aSH5LiL5qyh6YGN5Y6GXHJcbiAgICAgICAgICAgIGlmIChyZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIOWmguaenOetieS6ju+8jOebtOaOpeaPkuWFpeWIsOWQjumdolxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJldCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEJldHdlZW4oZGF0YSwgcHJldmlvdXMsIGN1cnJlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIOWmguaenOWwj+S6juWImeaPkuWFpeWIsOWJjeiKgueCueWSjOW9k+WJjeiKgueCueS4rVxyXG4gICAgICAgICAgICAgICAgLy8g5Zug5Li65bey57uP5piv5o6S5bqP5LqG77yM5omA5Lul5LiN6ZyA6KaB5aSa5L2Z5Yik5pat5LqGXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkID09PSBwcmV2aW91cyAmJiBwcmV2aW91cyA9PT0gY3VycmVudClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNoaWZ0KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnRCZXR3ZWVuKGRhdGEsIHByZXZpb3VzLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5o+S5YWl5Yiw5pyA5ZCO5LiA5Liq57uT54K5XHJcbiAgICAgICAgcHJldmlvdXMubmV4dCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IHByZXZpb3VzLm5leHQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydEJldHdlZW4oZGF0YSwgYSwgYikge1xyXG4gICAgICAgICAgICBpZiAoYSA9PSBiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSBtZS5oZWFkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS51bnNoaWZ0KGRhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIHRlbXAubmV4dCA9IGI7XHJcbiAgICAgICAgICAgICAgICBhLm5leHQgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yig6Zmk5YWD57Sg6YCS5aKe5o6S5YiX55qE6ZO+6KGo5Lit5YC85aSn5LqObWlu77yM5LiU5bCP5LqObWF455qE5omA5pyJ5YWD57SgXHJcbiAgICBkZWxldGVfYmV0d2VlbiAobWluLCBtYXgpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgLy8gcOaYr+acgOWQjuS4gOS4quS4jeWkp+S6jm1pbueahOWFg+e0oFxyXG4gICAgICAgIHdoaWxlIChwLm5leHQgJiYgcC5uZXh0LmRhdGEgPD0gbWluKSBwID0gcC5uZXh0O1xyXG5cclxuICAgICAgICAvLyDlpoLmnpzov5jmnInmr5RtaW7mm7TlpKfnmoTlhYPntKBcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICBpZiAocC5uZXh0KSB7XHJcbiAgICAgICAgICAgIHEgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIC8vIHHmmK/nrKzkuIDkuKrkuI3lsI/kuo5tYXjnmoTlhYPntKBcclxuICAgICAgICAgICAgd2hpbGUgKHEgJiYgcS5kYXRhIDwgbWF4KSBxID0gcS5uZXh0O1xyXG4gICAgICAgICAgICBwLm5leHQgPSBxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxhc3QgPSBxIHx8IHA7XHJcbiAgICAgICAgd2hpbGUgKGxhc3QubmV4dCkgbGFzdCA9IGxhc3QubmV4dDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBsYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIoOmZpOWFg+e0oOmAkuWinuaOkuWIl+eahOmTvuihqOeahOmHjeWkjeWFg+e0oFxyXG4gICAgZGVsZXRlX2VxdWFsICgpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgcSA9IHAubmV4dDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHAubmV4dCkge1xyXG4gICAgICAgICAgICAvLyDlvZPnm7jpgrvkuKTlhYPntKDkuI3nm7jnrYnml7bvvIxwLHHpg73lkJHlkI7np7tcclxuICAgICAgICAgICAgaWYgKHAuZGF0YSAhPT0gcS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgcSA9IHAubmV4dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChxLmRhdGEgPT09IHAuZGF0YSkgcSA9IHEubmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyDliKDpmaRcclxuICAgICAgICAgICAgICAgIHAubmV4dCA9IHE7XHJcbiAgICAgICAgICAgICAgICBwID0gcTtcclxuICAgICAgICAgICAgICAgIHEgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV2ZXJzZSAoKSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IHEgPSBwLm5leHQ7XHJcbiAgICAgICAgbGV0IHMgPSBxLm5leHQ7XHJcbiAgICAgICAgcC5uZXh0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHMubmV4dCkge1xyXG4gICAgICAgICAgICBxLm5leHQgPSBwO1xyXG4gICAgICAgICAgICBwID0gcTtcclxuICAgICAgICAgICAgcSA9IHM7XHJcbiAgICAgICAgICAgIHMgPSBzLm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxLm5leHQgPSBwO1xyXG4gICAgICAgIHMubmV4dCA9IHE7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gcztcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29tcEZuKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5cclxuXHJcbi8vIOaxguWFg+e0oOmAkuWinuaOkuWIl+eahOe6v+aAp+ihqEHlkoxC55qE5YWD57Sg55qE5Lqk6ZuG5bm25a2Y5YWlQ1xyXG5mdW5jdGlvbiBpbnRlcnNlY3QobGlzdCwgYkxpc3QpIHtcclxuICAgIGxldCBjTGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcblxyXG4gICAgbGV0IHAgPSBsaXN0LmhlYWQ7XHJcbiAgICBsZXQgcSA9IGJMaXN0LmhlYWQ7XHJcblxyXG4gICAgd2hpbGUgKHAgJiYgcSkge1xyXG4gICAgICAgIGlmIChwLmRhdGEgPCBxLmRhdGEpIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgZWxzZSBpZiAocS5kYXRhID4gcS5kYXRhKSBxID0gcS5uZXh0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjTGlzdC5wdXNoKHEuZGF0YSk7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjTGlzdDtcclxufVxyXG5cclxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaXlm55hXHJcbmZ1bmN0aW9uIGludGVyc2VjdF90cnVlKGxpc3QsIGJMaXN0KSB7XHJcbiAgICBsZXQgcCA9IGxpc3QuaGVhZDtcclxuICAgIGxldCBxID0gYkxpc3QuaGVhZDtcclxuICAgIGxldCBwYyA9IGxpc3QuaGVhZDtcclxuXHJcbiAgICB3aGlsZSAocCAmJiBxKSB7XHJcbiAgICAgICAgaWYgKHAuZGF0YSA8IHEuZGF0YSkgcCA9IHAubmV4dDtcclxuICAgICAgICBlbHNlIGlmIChwLmRhdGEgPiBxLmRhdGEpIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBjLmRhdGEgPSBwLmRhdGE7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIHEgPSBxLm5leHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXAgfHwgIXEpIHtcclxuICAgICAgICAgICAgICAgIHBjLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGlzdC50YWlsID0gcGM7XHJcbiAgICAgICAgICAgIH0gZWxzZSBwYyA9IHBjLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBjLm5leHQgPSBudWxsO1xyXG4gICAgbGlzdC50YWlsID0gcGM7XHJcbn1cclxuXHJcbi8vIGHvvIxi77yMY+eahOWFg+e0oOWdh+aYr+mdnumAkuWHj+aOkuWIl1xyXG4vLyDmsYJh6ZO+6KGo5Lit6Z2eYumTvuihqOWSjGPpk77ooajnmoTkuqTpm4bnmoTlhYPntKDjgIJcclxuZnVuY3Rpb24gaW50ZXJzZWN0X2RlbGV0ZShsaXN0LCBiLCBjKSB7XHJcbiAgICBsZXQgcCA9IGIuaGVhZDtcclxuICAgIGxldCBxID0gYy5oZWFkO1xyXG4gICAgbGV0IHIgPSBsaXN0LmhlYWQ7XHJcblxyXG4gICAgd2hpbGUgKHAgJiYgcSAmJiByKSB7XHJcbiAgICAgICAgaWYgKHAuZGF0YSA8IHEuZGF0YSkgcCA9IHAubmV4dDtcclxuICAgICAgICBlbHNlIGlmIChwLmRhdGEgPiBxLmRhdGEpIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOehruWumuW+heWIoOmZpOWFg+e0oFxyXG4gICAgICAgICAgICBsZXQgZWxlbSA9IHAuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyLmRhdGEgPT09IGVsZW0gJiYgciA9PT0gbGlzdC5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LmhlYWQgPSBsaXN0LmhlYWQubmV4dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOehruWumuacgOWQjuS4gOS4quWwj+S6jmVsZW3nmoTlhYPntKDmjIfpkohcclxuICAgICAgICAgICAgICAgIHdoaWxlIChyLm5leHQgJiYgci5uZXh0LmRhdGEgPCBlbGVtKSByID0gci5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyLm5leHQuZGF0YSA9PT0gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gci5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDnoa7lrprnrKzkuIDkuKrlpKfkuo5lbGVt55qE5YWD57Sg5oyH6ZKIXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMgJiYgcy5kYXRhID09PSBlbGVtKSBzID0gcy5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWIoOmZpHLlkoxz5LmL6Ze055qE5YWD57SgXHJcbiAgICAgICAgICAgICAgICAgICAgci5uZXh0ID0gcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5kYXRhID09PSBlbGVtKSBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICB3aGlsZSAocSAmJiBxLmRhdGEgPT09IGVsZW0pIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxpc3QudGFpbCA9IHI7XHJcbn1cclxuXHJcbnZhciBsaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxubGlzdC5wdXNoKCdiJyk7XHJcbmxpc3QudW5zaGlmdCgnYScpO1xyXG5saXN0Lmluc2VydEFmdGVyKCdiJywgJ2MnKTtcclxuY29uc29sZS5sb2cobGlzdC5pdGVtKDIpKTtcclxuY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobGlzdCkpO1xyXG5saXN0LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIGlmIChub2RlLmRhdGEgPT09ICdiJykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXQgYiBpbiBlYWNoJyk7XHJcbiAgICB9XHJcbn0pO1xyXG5saXN0LnJlbW92ZSgnYycpO1xyXG5saXN0LnJlbW92ZSgnYScpO1xyXG5jb25zb2xlLmxvZyhsaXN0KTtcclxuXHJcbmxldCBsaXN0MiA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbmxpc3QyLnB1c2goJ2MnKTtcclxubGlzdDIudW5zaGlmdCgnZCcpO1xyXG5saXN0Mi5pbnNlcnRBZnRlcignZCcsICdiJyk7XHJcbmNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGxpc3QyKSk7XHJcblxyXG5sZXQgbGlzdDMgPSBMaW5rZWRMaXN0Lm1lcmdlTGlzdChsaXN0LCBsaXN0Mik7XHJcbmNvbnNvbGUubG9nKGxpc3QzKTtcclxuXHJcblxyXG52YXIgbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcblxyXG5saXN0Lm9yZGVySW5zZXJ0KDUpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDIpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDMpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDEpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDQpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDQpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDYpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDYpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDcpO1xyXG5cclxubGlzdC5kZWxldGVfYmV0d2Vlbig1LCA4KTtcclxuY29uc29sZS5sb2coJ2RlbGV0ZS1iZXR3ZWVuOiAgJyk7XHJcbmNvbnNvbGUubG9nKGxpc3QpO1xyXG5cclxubGlzdC5vcmRlckluc2VydCgyKTtcclxubGlzdC5vcmRlckluc2VydCgzKTtcclxubGlzdC5vcmRlckluc2VydCgxKTtcclxuXHJcbmxpc3QuZGVsZXRlX2VxdWFsKCk7XHJcbmNvbnNvbGUubG9nKGxpc3QpO1xyXG5cclxubGlzdC5yZXZlcnNlKCk7XHJcbmNvbnNvbGUubG9nKGxpc3QpO1xyXG5cclxubGV0IGEgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5hLm9yZGVySW5zZXJ0KDEpO1xyXG5hLm9yZGVySW5zZXJ0KDMpO1xyXG5hLm9yZGVySW5zZXJ0KDUpO1xyXG5hLm9yZGVySW5zZXJ0KDcpO1xyXG5hLm9yZGVySW5zZXJ0KDkpO1xyXG5cclxubGV0IGIgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5iLm9yZGVySW5zZXJ0KDEpO1xyXG5iLm9yZGVySW5zZXJ0KDUpO1xyXG5iLm9yZGVySW5zZXJ0KDkpO1xyXG5iLm9yZGVySW5zZXJ0KDEzKTtcclxuYi5vcmRlckluc2VydCgxNyk7XHJcbmNvbnNvbGUubG9nKGludGVyc2VjdChhLCBiKSk7XHJcblxyXG5jb25zb2xlLmxvZyhpbnRlcnNlY3RfdHJ1ZShhLCBiKSk7XHJcblxyXG5hID0gbmV3IExpbmtlZExpc3QoKTtcclxuYS5vcmRlckluc2VydCgxKTtcclxuYS5vcmRlckluc2VydCgzKTtcclxuYS5vcmRlckluc2VydCg1KTtcclxuYS5vcmRlckluc2VydCg3KTtcclxuYS5vcmRlckluc2VydCg5KTtcclxuXHJcbmxldCB0ZXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxudGVzdC5vcmRlckluc2VydCgxKTtcclxudGVzdC5vcmRlckluc2VydCgyKTtcclxudGVzdC5vcmRlckluc2VydCgzKTtcclxudGVzdC5vcmRlckluc2VydCg0KTtcclxudGVzdC5vcmRlckluc2VydCg1KTtcclxudGVzdC5vcmRlckluc2VydCg2KTtcclxudGVzdC5vcmRlckluc2VydCg5KTtcclxuXHJcbmludGVyc2VjdF9kZWxldGUodGVzdCwgYSwgYik7XHJcbmNvbnNvbGUubG9nKHRlc3QpO1xyXG5cclxudmFyIHBvcFRlc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5wb3BUZXN0LnB1c2goMSk7XHJcbnBvcFRlc3QucHVzaCgyKTtcclxucG9wVGVzdC5wb3AoKTtcclxucG9wVGVzdC5wb3AoKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9MaW5rZWRMaXN0LmpzXG4gKiovIiwiLy8g6Z2Z5oCB5Y2V6ZO+6KGoXHJcbi8qXHJcbiDmnInml7blj6/lgJ/nlKjkuIDnu7TmlbDnu4TmnaXmj4/ov7Dnur/mgKfpk77ooajvvIzov5nlsLHmmK/nur/mgKfooajnmoTpnZnmgIHljZXpk77ooajlrZjlgqjnu5PmnoTjgIJcclxuIOWcqOmdmeaAgemTvuihqOS4re+8jOaVsOe7hOeahOS4gOS4quWIhumHj+ihqOekuuS4gOS4que7k+eCue+8jOWQjOaXtueUqOa4uOagh++8iGN1cu+8ieS7o+abv+aMh+mSiOaMh+ekuue7k+eCueWcqOaVsOe7hOS4reeahOebuOWvueS9jee9ruOAglxyXG4g5pWw57uE55qE56ysMOWIhumHj+WPr+eci+aIkOWktOe7k+eCue+8jOWFtuaMh+mSiOWfn+aMh+ekuumTvuihqOeahOesrOS4gOS4que7k+eCueOAglxyXG4g6L+Z56eN5a2Y5YKo57uT5p6E6ZyA6KaB6aKE5YWI5YiG6YWN5LiA5Liq6L6D5aSn55qE56m66Ze077yM5L2G5Zyo57q/5oCn6KGo55qE5o+S5YWl5ZKM5Yig6Zmk5pON5L2c5pe25LiN6ZyA56e75Yqo5YWD57Sg77yMXHJcbiDku4XpnIDopoHkv67mlLnmjIfpkojvvIzmlYXku43lhbfmnInpk77lvI/lrZjlgqjnu5PmnoTnmoTkuLvopoHkvJjngrlcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNMaW5rZWRMaXN0IHtcclxuICAgIGNvbnN0cnVjdG9yKE1BWFNJWkUpIHtcclxuICAgICAgICB0aGlzWy0xXSA9IHtjdXI6IDB9O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLk1BWFNJWkUgPSBNQVhTSVpFICsgMSB8fCAxMDAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zyo6Z2Z5oCB5Y2V6ZO+57q/5oCn6KGoTOS4reafpeaJvuesrDHkuKrlgLzkuLpl55qE5YWD57Sg77yMXHJcbiAgICAgKiDoi6Xmib7liLDvvIzliJnov5Tlm57lroPlnKhM5Lit55qE5L2N5bqPXHJcbiAgICAgKiBAcGFyYW0gZGF0YVxyXG4gICAgICovXHJcbiAgICBmaW5kIChkYXRhKSB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzWzBdLmN1cjtcclxuICAgICAgICB3aGlsZSAoaSAmJiB0aGlzW2ldLmRhdGEgIT09IGRhdGEpIHtcclxuICAgICAgICAgICAgaSA9IHRoaXNbaV0uY3VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5bCG5LiA57u05pWw57uE5Lit5ZCE5YiG6YeP6ZO+5oiQ5LiA5Liq5aSH55So6ZO+6KGoXHJcbiAgICAgKiB0aGlzWzBdLmN1cuS4uuWktOaMh+mSiFxyXG4gICAgICovXHJcbiAgICBpbml0IChsZW4pIHtcclxuICAgICAgICBsZW4gPSBsZW4gPyBsZW4gKyAxIDogdGhpcy5NQVhTSVpFO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXNbaV0gPSB0aGlzW2ldIHx8IHtkYXRhOiBudWxsLCBjdXI6IG51bGx9O1xyXG4gICAgICAgICAgICB0aGlzW2ldLmN1ciA9IGkgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpc1tsZW4gLSAxXSA9IHRoaXNbbGVuIC0gMV0gfHwge307XHJcbiAgICAgICAgdGhpc1tsZW4gLSAxXS5jdXIgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDoi6XlpIfnlKjpk77ooajpnZ7nqbrvvIzliJnov5Tlm57liIbphY3nmoTnu5PngrnkuIvmoIfvvIzlj43liJnov5Tlm54wXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgbWFsbG9jICgpIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXNbLTFdLmN1cjtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXNbLTFdLmN1ciAhPT0gJ3VuZGVmaW5lZCcpIHRoaXNbLTFdLmN1ciA9IHRoaXNbaV0uY3VyO1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIbkuIvmoIfkuLpr55qE56m66Zey57uT54K55Zue5pS25Yiw5aSH55So6ZO+6KGoXHJcbiAgICAgKiBAcGFyYW0ga1xyXG4gICAgICovXHJcbiAgICBmcmVlIChrKSB7XHJcbiAgICAgICAgdGhpc1trXS5jdXIgPSB0aGlzWzBdLmN1cjtcclxuICAgICAgICB0aGlzWzBdLmN1ciA9IGs7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlIChzcUxpc3QpIHtcclxuICAgICAgICAvLyDliJ3lp4vljJblpIfnlKjnqbrpl7RcclxuICAgICAgICB0aGlzLmluaXQoc3FMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgLy8g55Sf5oiQc+eahOWktOe7k+eCuVxyXG4gICAgICAgIGxldCBzID0gdGhpcy5tYWxsb2MoKTtcclxuICAgICAgICAvLyBy5oyH5ZCRc+eahOW9k+WJjeacgOWQjue7k+eCuVxyXG4gICAgICAgIGxldCByID0gcztcclxuICAgICAgICBsZXQgbSA9IHNxTGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIOW7uueri+mbhuWQiEHnmoTpk77ooahcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgICAgICAgICAvL+WIhumFjee7k+eCuVxyXG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMubWFsbG9jKCk7XHJcbiAgICAgICAgICAgIC8vIOi+k+WFpUHlhYPntKDnmoTlgLxcclxuICAgICAgICAgICAgdGhpc1tpXS5kYXRhID0gc3FMaXN0W2pdO1xyXG4gICAgICAgICAgICAvLyDmj5LlhaXliLDooajlsL5cclxuICAgICAgICAgICAgdGhpc1tyXS5jdXIgPSBpO1xyXG4gICAgICAgICAgICArK3RoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICByID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5bC+57uT54K555qE5oyH6ZKI5Li656m6XHJcbiAgICAgICAgdGhpc1tyXS5jdXIgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvZG9cclxuICAgIGFkZCAoaW5kZXgsIGVsZW0pIHtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmUgKGluZGV4KSB7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlnKjkuIDnu7TmlbDnu4TkuK3lu7rnq4vooajnpLrpm4blkIgoQS1CKVUoQi1BKVxyXG4gKiDnmoTpnZnmgIHpk77ooajvvIxz5Li65YW25aS05oyH6ZKI44CCXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gZGlmZmVyZW5jZShzbGxpc3QsIGFycjEsIGFycjIpIHtcclxuICAgIC8vIOWIneWni+WMluWkh+eUqOepuumXtFxyXG4gICAgc2xsaXN0LmluaXQoKTtcclxuICAgIC8vIOeUn+aIkHPnmoTlpLTnu5PngrlcclxuICAgIGxldCBzID0gc2xsaXN0Lm1hbGxvYygpO1xyXG4gICAgLy8gcuaMh+WQkXPnmoTlvZPliY3mnIDlkI7nu5PngrlcclxuICAgIGxldCByID0gcztcclxuICAgIC8vIOWIoOmZpEHlkoxC55qE5YWD57Sg5Liq5pWwXHJcbiAgICBsZXQgbSA9IGFycjEubGVuZ3RoO1xyXG4gICAgbGV0IG4gPSBhcnIyLmxlbmd0aDtcclxuXHJcbiAgICAvLyDlu7rnq4vpm4blkIhB55qE6ZO+6KGoXHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgICAgIC8v5YiG6YWN57uT54K5XHJcbiAgICAgICAgbGV0IGkgPSBzbGxpc3QubWFsbG9jKCk7XHJcbiAgICAgICAgLy8g6L6T5YWlQeWFg+e0oOeahOWAvFxyXG4gICAgICAgIHNsbGlzdFtpXS5kYXRhID0gYXJyMVtqXTtcclxuICAgICAgICAvLyDmj5LlhaXliLDooajlsL5cclxuICAgICAgICBzbGxpc3Rbcl0uY3VyID0gaTtcclxuICAgICAgICByID0gaTtcclxuICAgIH1cclxuICAgIC8vIOWwvue7k+eCueeahOaMh+mSiOS4uuepulxyXG4gICAgc2xsaXN0W3JdLmN1ciA9IDA7XHJcblxyXG4gICAgLy8g5L6d5qyh6L6T5YWlQueahOWFg+e0oO+8jOiLpeS4jeWcqOW9k+WJjeihqOS4re+8jOWImeaPkuWFpe+8jFxyXG4gICAgLy8g5ZCm5YiZ5Yig6ZmkXHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47ICsraikge1xyXG4gICAgICAgIGxldCBiID0gYXJyMltqXTtcclxuICAgICAgICBsZXQgcCA9IHM7XHJcbiAgICAgICAgLy8ga+aMh+WQkembhuWQiOS4reeahOesrOS4gOS4que7k+eCuVxyXG4gICAgICAgIGxldCBrID0gc2xsaXN0W3NdLmN1cjtcclxuICAgICAgICAvLyDlnKjlvZPliY3ooajkuK3mn6Xmib5cclxuICAgICAgICB3aGlsZSAoayAhPT0gc2xsaXN0W3JdLmN1ciAmJiBzbGxpc3Rba10uZGF0YSAhPT0gYikge1xyXG4gICAgICAgICAgICBwID0gaztcclxuICAgICAgICAgICAgayA9IHNsbGlzdFtrXS5jdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW9k+WJjeihqOS4reS4jeWtmOWcqOivpeWFg+e0oO+8jOaPkuWFpeWcqHLmiYDmjIfnu5PngrnkuYvlkI7vvIzkuJRy55qE5L2N572u5LiN5Y+YXHJcbiAgICAgICAgaWYgKGsgPT09IHNsbGlzdFtyXS5jdXIpIHtcclxuICAgICAgICAgICAgbGV0IGkgPSBzbGxpc3QubWFsbG9jKCk7XHJcbiAgICAgICAgICAgIHNsbGlzdFtpXS5kYXRhID0gYjtcclxuICAgICAgICAgICAgc2xsaXN0W2ldLmN1ciA9IHNsbGlzdFtyXS5jdXI7XHJcbiAgICAgICAgICAgIHNsbGlzdFtyXS5jdXIgPSBpO1xyXG5cclxuICAgICAgICAgICAgLy8g6K+l5YWD57Sg5bey5Zyo6KGo5Lit77yM5Yig6Zmk5LmLXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2xsaXN0W3BdLmN1ciA9IHNsbGlzdFtrXS5jdXI7XHJcbiAgICAgICAgICAgIHNsbGlzdC5mcmVlKGspO1xyXG4gICAgICAgICAgICAvLyDoi6XliKDpmaTnmoTmmK9y5omA5oyH57uT54K577yM5YiZ6ZyA5L+u5pS55bC+5oyH6ZKIXHJcbiAgICAgICAgICAgIGlmIChyID09PSBrKSByID0gcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCBzbCA9IG5ldyBTdGF0aWNMaW5rZWRMaXN0KDEwKTtcclxubGV0IHJldCA9IGRpZmZlcmVuY2Uoc2wsIFsxLCAyLCAzXSwgWzMsIDQsIDVdKTtcclxuY29uc29sZS5sb2coc2wpO1xyXG5cclxuXHJcbmxldCB0ZXN0ID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoMTApO1xyXG50ZXN0LmNyZWF0ZShbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5XSk7XHJcbmNvbnNvbGUubG9nKHRlc3QpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0xpc3QvU3RhdGljTGlua2VkTGlzdC5qc1xuICoqLyIsIi8qXHJcbiDliqjmgIHmn6Xmib5cclxuXHJcbiDlvZPmn6Xmib7ooajku6Xnur/mgKfooajnmoTlvaLlvI/nu4Tnu4fml7bvvIzoi6Xlr7nmn6Xmib7ooajov5vooYzmj5LlhaXjgIHliKDpmaTmiJbmjpLluo/mk43kvZzvvIzlsLHlv4Xpobvnp7vliqjlpKfph4/nmoTorrDlvZXvvIzlvZPorrDlvZXmlbDlvojlpJrml7bvvIzov5nnp43np7vliqjnmoTku6Pku7flvojlpKfjgIJcclxuIOWIqeeUqOagkeeahOW9ouW8j+e7hOe7h+afpeaJvuihqO+8jOWPr+S7peWvueafpeaJvuihqOi/m+ihjOWKqOaAgemrmOaViOeahOafpeaJvuOAglxyXG5cclxuXHJcbiDkuozlj4nmjpLluo/moJEoQlNUKeeahOWumuS5iVxyXG5cclxuIOS6jOWPieaOkuW6j+agkShCaW5hcnkgU29ydCBUcmVl5oiWQmluYXJ5IFNlYXJjaCBUcmVlKSDnmoTlrprkuYnkuLrvvJrkuozlj4nmjpLluo/moJHmiJbogIXmmK/nqbrmoJHvvIzmiJbogIXmmK/mu6HotrPkuIvliJfmgKfotKjnmoTkuozlj4nmoJHjgIJcclxuICgxKSDvvJroi6Xlt6blrZDmoJHkuI3kuLrnqbrvvIzliJnlt6blrZDmoJHkuIrmiYDmnInnu5PngrnnmoTlgLwo5YWz6ZSu5a2XKemDveWwj+S6juaguee7k+eCueeahOWAvO+8m1xyXG4gKDIpIO+8muiLpeWPs+WtkOagkeS4jeS4uuepuu+8jOWImeWPs+WtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95aSn5LqO5qC557uT54K555qE5YC877ybXHJcbiAoMykg77ya5bem44CB5Y+z5a2Q5qCR6YO95YiG5Yir5piv5LqM5Y+J5o6S5bqP5qCR44CCXHJcbiDnu5PorrrvvJroi6XmjInkuK3luo/pgY3ljobkuIDmo7Xkuozlj4nmjpLluo/moJHvvIzmiYDlvpfliLDnmoTnu5Pngrnluo/liJfmmK/kuIDkuKrpgJLlop7luo/liJfjgIJcclxuXHJcblxyXG4gQlNU5qCR55qE5p+l5om+XHJcbiAxICDmn6Xmib7mgJ3mg7NcclxuIOmmluWFiOWwhue7meWumueahEvlgLzkuI7kuozlj4nmjpLluo/moJHnmoTmoLnnu5PngrnnmoTlhbPplK7lrZfov5vooYzmr5TovoPvvJroi6Xnm7jnrYnvvJog5YiZ5p+l5om+5oiQ5Yqf77ybXHJcbiDikaAg57uZ5a6a55qES+WAvOWwj+S6jkJTVOeahOaguee7k+eCueeahOWFs+mUruWtl++8mue7p+e7reWcqOivpee7k+eCueeahOW3puWtkOagkeS4iui/m+ihjOafpeaJvu+8m1xyXG4g4pGhIOe7meWumueahEvlgLzlpKfkuo5CU1TnmoTmoLnnu5PngrnnmoTlhbPplK7lrZfvvJrnu6fnu63lnKjor6Xnu5PngrnnmoTlj7PlrZDmoJHkuIrov5vooYzmn6Xmib7jgIJcclxuXHJcbiDlnKjpmo/mnLrmg4XlhrXkuIvvvIzkuozlj4nmjpLluo/moJHnmoTlubPlnYfmn6Xmib7plb/luqZBU0zlkozjj5Iobiko5qCR55qE5rex5bqmKeaYr+etieaVsOmHj+e6p+eahOOAglxyXG5cclxuXHJcbiBCU1TmoJHnmoTmj5LlhaVcclxuXHJcbiDlnKhCU1TmoJHkuK3mj5LlhaXkuIDkuKrmlrDnu5PngrnvvIzopoHkv53or4Hmj5LlhaXlkI7ku43mu6HotrNCU1TnmoTmgKfotKjjgIJcclxuXHJcbiAxIOaPkuWFpeaAneaDs1xyXG4g5ZyoQlNU5qCR5Lit5o+S5YWl5LiA5Liq5paw57uT54K5eOaXtu+8jOiLpUJTVOagkeS4uuepuu+8jOWImeS7pOaWsOe7k+eCuXjkuLrmj5LlhaXlkI5CU1TmoJHnmoTmoLnnu5PngrnvvJvlkKbliJnvvIzlsIbnu5Pngrl455qE5YWz6ZSu5a2X5LiO5qC557uT54K5VOeahOWFs+mUruWtl+i/m+ihjOavlOi+g++8mlxyXG4g4pGgIOiLpeebuOetie+8miDkuI3pnIDopoHmj5LlhaXvvJtcclxuIOKRoSAg6IuleC5rZXk8VC0+a2V577ya57uT54K5eOaPkuWFpeWIsFTnmoTlt6blrZDmoJHkuK3vvJtcclxuIOKRoiAg6IuleC5rZXk+VC0+a2V577ya57uT54K5eOaPkuWFpeWIsFTnmoTlj7PlrZDmoJHkuK3jgIJcclxuXHJcbiDnlLHnu5Porrrnn6XvvIzlr7nkuo7kuIDkuKrml6Dluo/luo/liJflj6/ku6XpgJrov4fmnoTpgKDkuIDmo7VCU1TmoJHogIzlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcclxuIOeUseeul+azleefpe+8jOavj+asoeaPkuWFpeeahOaWsOe7k+eCuemDveaYr0JTVOagkeeahOWPtuWtkOe7k+eCue+8jOWNs+WcqOaPkuWFpeaXtuS4jeW/heenu+WKqOWFtuWug+e7k+eCue+8jOS7hemcgOS/ruaUueafkOS4que7k+eCueeahOaMh+mSiOOAglxyXG5cclxuXHJcbiBCU1TmoJHnmoTliKDpmaRcclxuXHJcbiAxICDliKDpmaTmk43kvZzov4fnqIvliIbmnpBcclxuIOS7jkJTVOagkeS4iuWIoOmZpOS4gOS4que7k+eCue+8jOS7jeeEtuimgeS/neivgeWIoOmZpOWQjua7oei2s0JTVOeahOaAp+i0qOOAguiuvuiiq+WIoOmZpOe7k+eCueS4unDvvIzlhbbniLbnu5PngrnkuLpmIO+8jOWIoOmZpOaDheWGteWmguS4i++8mlxyXG4g4pGgICDoi6Vw5piv5Y+25a2Q57uT54K577yaIOebtOaOpeWIoOmZpHDjgIJcclxuIOKRoSAg6IulcOWPquacieS4gOajteWtkOagkSjlt6blrZDmoJHmiJblj7PlrZDmoJEp77ya55u05o6l55SocOeahOW3puWtkOagkSjmiJblj7PlrZDmoJEp5Y+W5LujcOeahOS9jee9ruiAjOaIkOS4umbnmoTkuIDmo7XlrZDmoJHjgILljbPljp/mnaVw5pivZueahOW3puWtkOagke+8jOWImXDnmoTlrZDmoJHmiJDkuLpm55qE5bem5a2Q5qCR77yb5Y6f5p2lcOaYr2bnmoTlj7PlrZDmoJHvvIzliJlw55qE5a2Q5qCR5oiQ5Li6ZueahOWPs+WtkOagkeOAglxyXG4g4pGiIOiLpXDml6LmnInlt6blrZDmoJHlj4jmnInlj7PlrZDmoJEg77ya5aSE55CG5pa55rOV5pyJ5Lul5LiL5Lik56eN77yM5Y+v5Lul5Lu76YCJ5YW25Lit5LiA56eN44CCXHJcbiDil4YgIOeUqHDnmoTnm7TmjqXliY3pqbHnu5Pngrnku6Pmm79w44CC5Y2z5LuOcOeahOW3puWtkOagkeS4remAieaLqeWAvOacgOWkp+eahOe7k+eCuXPmlL7lnKhw55qE5L2N572uKOeUqOe7k+eCuXPnmoTlhoXlrrnmm7/mjaLnu5Pngrlw5YaF5a65Ke+8jOeEtuWQjuWIoOmZpOe7k+eCuXPjgIJz5pivcOeahOW3puWtkOagkeS4reeahOacgOWPs+i+ueeahOe7k+eCueS4lOayoeacieWPs+WtkOagke+8jOWvuXPnmoTliKDpmaTlkIzikaHjgIJcclxuIOKXhiDnlKhw55qE55u05o6l5ZCO57un57uT54K55Luj5pu/cOOAguWNs+S7jnDnmoTlj7PlrZDmoJHkuK3pgInmi6nlgLzmnIDlsI/nmoTnu5Pngrlz5pS+5ZyocOeahOS9jee9rijnlKjnu5Pngrlz55qE5YaF5a655pu/5o2i57uT54K5cOWGheWuuSnvvIznhLblkI7liKDpmaTnu5Pngrlz44CCc+aYr3DnmoTlj7PlrZDmoJHkuK3nmoTmnIDlt6bovrnnmoTnu5PngrnkuJTmsqHmnInlt6blrZDmoJHvvIzlr7lz55qE5Yig6Zmk5ZCM4pGh44CCXHJcblxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEJpbmFyeVRyZWUgfSBmcm9tICcuLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQlNUTm9kZSBleHRlbmRzIEJpbmFyeVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IoLi4uYXJnKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJTVOagkeeahOafpeaJvu+8iOmAkuW9ku+8iVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBzZWFyY2goa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA8IHRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnRDaGlsZC5zZWFyY2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRDaGlsZC5zZWFyY2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCU1TmoJHnmoTmn6Xmib7vvIjpnZ7pgJLlvZLvvIlcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc2VhcmNoTm9uUmVjdXJzaXZlKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGxldCBwID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgIT09IGtleSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIGVsc2UgcCA9IHAucmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcCB8fCBrZXkgIT09IHAuZGF0YSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmAkuW9ku+8iVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5kYXRhKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBub2RlID0gbmV3IEJTVE5vZGUoa2V5KTtcclxuICAgICAgICBpZiAoa2V5IDwgdGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0Q2hpbGQuaW5zZXJ0KGtleSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRDaGlsZC5pbnNlcnQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCU1TmoJHnmoTmj5LlhaXvvIjpnZ7pgJLlvZLvvIlcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKi9cclxuICAgIGluc2VydE5vblJlY3Vyc2l2ZShrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcCA9IHRoaXM7XHJcbiAgICAgICAgbGV0IHE7XHJcbiAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgaWYgKHAuZGF0YSA9PT0ga2V5KSByZXR1cm47XHJcbiAgICAgICAgICAgIC8vIHHkvZzkuLpw55qE54i26IqC54K5XHJcbiAgICAgICAgICAgIHEgPSBwO1xyXG4gICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIGVsc2UgcCA9IHAucmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBub2RlID0gbmV3IEJTVE5vZGUoa2V5KTtcclxuICAgICAgICBpZiAoa2V5IDwgcS5kYXRhKSBxLmxlZnRDaGlsZCA9IG5vZGU7XHJcbiAgICAgICAgZWxzZSBxLnJpZ2h0Q2hpbGQgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yip55SoQlNU5qCR55qE5o+S5YWl5pON5L2c5bu656uL5LiA5qO1QlNU5qCRXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnx1bmRlZmluZWR9IHVzZU5vblJlY3Vyc2l2ZSDmmK/lkKbkvb/nlKjpnZ7pgJLlvZJcclxuICAgICAqL1xyXG4gICAgY3JlYXRlQlNUKGFyciwgdXNlTm9uUmVjdXJzaXZlKSB7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgaWYgKHVzZU5vblJlY3Vyc2l2ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb25SZWN1cnNpdmUoYXJyW2ldKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoYXJyW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5L2/55So6YCS5b2S55qE5pa55rOV5Yig6Zmk5LiO5YWz6ZSu5a2X56ym5ZCI55qE57uT54K5XHJcbiAgICAgKiBAcGFyYW0geyp9IGtleSDpnIDopoHmn6Xmib7nmoTlhbPplK7lrZdcclxuICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gcGFyZW50IOeItuiKgueCue+8jOWGhemDqOiwg+eUqOmcgOimgeeUqOWIsFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXksIHBhcmVudCkge1xyXG4gICAgICAgIC8vIOepuue7k+eCueeahOaDheWGtVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAvLyDmib7liLDlhbPplK7lrZdcclxuICAgICAgICBpZiAodGhpcy5kYXRhID09PSBrZXkpIHJldHVybiBkZWxldGVOb2RlKHRoaXMsIHBhcmVudCk7XHJcbiAgICAgICAgLy8g5p+l5om+5bem5a2Q5qCR77yM5aaC5p6c5pyJ55qE6K+dXHJcbiAgICAgICAgZWxzZSBpZiAoa2V5IDwgdGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgcmV0dXJuIHRoaXMubGVmdENoaWxkLnJlbW92ZShrZXksIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDmn6Xmib7lj7PlrZDmoJHvvIzlpoLmnpzmnInnmoTor51cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgcmV0dXJuIHRoaXMucmlnaHRDaGlsZC5yZW1vdmUoa2V5LCB0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOacquaJvuWIsFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmdnumAkuW9kuWIoOmZpOS4juWFs+mUruWtl+espuWQiOeahOe7k+eCuVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXkg6ZyA6KaB5p+l5om+55qE5YWz6ZSu5a2XXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTm9uUmVjdXJzaXZlKGtleSkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcztcclxuICAgICAgICBsZXQgZjtcclxuXHJcbiAgICAgICAgd2hpbGUgKHAgJiYgcC5kYXRhICE9PSBrZXkpIHtcclxuICAgICAgICAgICAgZiA9IHA7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgZWxzZSBwID0gcC5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5rKh5pyJ6KaB5Yig6Zmk55qE57uT54K5XHJcbiAgICAgICAgaWYgKCFwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIOaJvuWIsOS6huimgeWIoOmZpOeahOe7k+eCuXBcclxuICAgICAgICBsZXQgcyA9IHA7XHJcbiAgICAgICAgbGV0IHE7XHJcbiAgICAgICAgLy8g5aaC5p6c5pyJ5bem5Y+z5a2Q5qCRXHJcbiAgICAgICAgaWYgKHAubGVmdENoaWxkICYmIHAucmlnaHRDaGlsZCkge1xyXG4gICAgICAgICAgICBmID0gcDtcclxuICAgICAgICAgICAgcyA9IHAubGVmdENoaWxkO1xyXG5cclxuICAgICAgICAgICAgLy8g5om+5Yiw5bem5a2Q5qCR55qE5pyA5aSn5Y+z5a2Q5qCR77yM5Y2z5LuF5bCP5LqO5bem5a2Q5qCR55qE5YC855qE57uT54K5XHJcbiAgICAgICAgICAgIHdoaWxlIChzLnJpZ2h0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGYgPSBzO1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcC5kYXRhID0gcy5kYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6Iulc+acieW3puWtkOagke+8jOWPs+WtkOagkeS4uuepulxyXG4gICAgICAgIGlmIChzLmxlZnRDaGlsZCkgcSA9IHMubGVmdENoaWxkO1xyXG4gICAgICAgIGVsc2UgcSA9IHMucmlnaHRDaGlsZDtcclxuXHJcbiAgICAgICAgLy8g5Y+q5pyJ5LiA5Liq5qC557uT54K555qE5oOF5Ya1XHJcbiAgICAgICAgaWYgKCFmKSB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgIGVsc2UgaWYgKGYubGVmdENoaWxkID09IHMpIGYubGVmdENoaWxkID0gcTtcclxuICAgICAgICBlbHNlIGYucmlnaHRDaGlsZCA9IHE7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5om+5Yiw5bCP5LqOeOeahOacgOWkp+WFg+e0oOWSjOWkp+S6jnjnmoTmnIDlsI/lhYPntKBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0geFxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBbbWluLCBtYXhdXHJcbiAgICAgKi9cclxuICAgIGZpbmROZWlnaGJvckVsZW0oeCkge1xyXG4gICAgICAgIGxldCBsYXN0ID0gdHlwZW9mIHRoaXMuZGF0YSA9PT0gJ251bWJlcicgPyAtSW5maW5pdHkgOiAnYSc7XHJcbiAgICAgICAgbGV0IHJldCA9IFtdO1xyXG5cclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2UodHJlZSwgeCkge1xyXG4gICAgICAgICAgICBpZiAodHJlZS5sZWZ0Q2hpbGQpIHJlY3Vyc2UodHJlZS5sZWZ0Q2hpbGQsIHgpO1xyXG4gICAgICAgICAgICBpZiAobGFzdCA8IHggJiYgdHJlZS5kYXRhID49IHgpIHJldFswXSA9IGxhc3Q7XHJcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IHggJiYgdHJlZS5kYXRhID4geCkgcmV0WzFdID0gdHJlZS5kYXRhO1xyXG4gICAgICAgICAgICBsYXN0ID0gdHJlZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAodHJlZS5yaWdodENoaWxkKSByZWN1cnNlKHRyZWUucmlnaHRDaGlsZCwgeCk7XHJcbiAgICAgICAgfSh0aGlzLCB4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaKiuS6jOWPieaOkuW6j+agkWJzdOWQiOW5tuWIsOivpeagkeS4rVxyXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBic3RcclxuICAgICAqL1xyXG4gICAgbWVyZ2UoYnN0KSB7XHJcbiAgICAgICAgaWYgKGJzdC5sZWZ0Q2hpbGQpIHRoaXMubWVyZ2UoYnN0LmxlZnRDaGlsZCk7XHJcbiAgICAgICAgaWYgKGJzdC5yaWdodENoaWxkKSB0aGlzLm1lcmdlKGJzdC5yaWdodENoaWxkKTtcclxuICAgICAgICB0aGlzLmluc2VydChic3QuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmiornu5Pngrnmj5LlhaXliLDlkIjpgILkvY3nva5cclxuICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gbm9kZSDlvoXmj5LlhaXnmoTnu5PngrlcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0Tm9kZShub2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGUuZGF0YTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhID4gdGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5yaWdodENoaWxkLmluc2VydE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5kYXRhIDwgdGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMubGVmdENoaWxkLmluc2VydE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGUubGVmdENoaWxkID0gbm9kZS5yaWdodENoaWxkID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIhuijguS4uuS4pOajteS6jOWPieaOkuW6j+agkVxyXG4gICAgICogQHBhcmFtIHsqfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7QlNUTm9kZVthLCBiXX0gYeeahOWFg+e0oOWFqOmDqOWwj+S6juetieS6jnjvvIxi55qE5YWD57Sg5YWo6YOo5aSn5LqOeFxyXG4gICAgICovXHJcbiAgICBzcGxpdCh4KSB7XHJcbiAgICAgICAgbGV0IGEgPSBuZXcgQlNUTm9kZSgpO1xyXG4gICAgICAgIGxldCBiID0gbmV3IEJTVE5vZGUoKTtcclxuXHJcbiAgICAgICAgdm9pZCBmdW5jdGlvbiBzcGxpdCh0cmVlLCB4KSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgc3BsaXQodHJlZS5sZWZ0Q2hpbGQsIHgpO1xyXG4gICAgICAgICAgICBpZiAodHJlZS5yaWdodENoaWxkKSBzcGxpdCh0cmVlLnJpZ2h0Q2hpbGQsIHgpO1xyXG4gICAgICAgICAgICBpZiAodHJlZS5kYXRhIDw9IHgpIGEuaW5zZXJ0Tm9kZSh0cmVlKTtcclxuICAgICAgICAgICAgZWxzZSBiLmluc2VydE5vZGUodHJlZSk7XHJcbiAgICAgICAgfSh0aGlzLCB4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFthLCBiXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrXRyZWXmmK/lkKbmmK/kuozlj4nmjpLluo/moJFcclxuICAgICAqIEBwYXJhbSB0cmVlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0JTVFRyZWUodHJlZSkge1xyXG4gICAgICAgIGxldCBsYXN0ID0gdHlwZW9mIHRyZWUuZGF0YSA9PT0gJ251bWJlcicgPyAtSW5maW5pdHkgOiAnYSc7XHJcbiAgICAgICAgbGV0IGZsYWcgPSB0cnVlO1xyXG5cclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIGlzQlNUVHJlZSh0cmVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCAmJiBmbGFnKSBpc0JTVFRyZWUodHJlZS5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAodHJlZS5kYXRhIDwgbGFzdCkgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsYXN0ID0gdHJlZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAodHJlZS5yaWdodENoaWxkICYmIGZsYWcpIGlzQlNUVHJlZSh0cmVlLnJpZ2h0Q2hpbGQpO1xyXG5cclxuICAgICAgICB9KHRyZWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmxhZztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOWIoOmZpOe7k+eCuVxyXG4gKiBAcGFyYW0ge0JTVE5vZGV9IHAg6KaB5Yig6Zmk55qE57uT54K5XHJcbiAqIEBwYXJhbSB7QlNUTm9kZX0gcGFyZW50IOimgeWIoOmZpOeahOe7k+eCueeahOeItuiKgueCuVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0g6L+U5Zue5Yig6Zmk5oiQ5YqfXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVOb2RlKHAsIHBhcmVudCkge1xyXG4gICAgLy8g5Y+25a2Q57uT54K55oiW5Y+q5pyJ5LiA5Liq57uT54K5XHJcbiAgICBpZiAoIXAubGVmdENoaWxkICYmICFwLnJpZ2h0Q2hpbGQpIHtcclxuICAgICAgICAvLyDlvZPliY3nu5PngrnmmK/lhbbniLbnu5PngrnnmoTlt6blrZDmoJHov5jmmK/lj7PlrZDmoJFcclxuICAgICAgICBsZXQgcG9zID0gcGFyZW50ICYmIHBhcmVudC5sZWZ0Q2hpbGQgPT0gcCA/ICdsZWZ0Q2hpbGQnIDogJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHBhcmVudFtwb3NdID0gbnVsbDtcclxuICAgICAgICAvLyDlj6rmnInkuIDkuKrnu5PngrnnmoTmg4XlhrVcclxuICAgICAgICBlbHNlICBwLmRhdGEgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8g5Y+q5pyJ5bem5a2Q5qCRXHJcbiAgICBlbHNlIGlmICghcC5yaWdodENoaWxkKSB7XHJcbiAgICAgICAgcC5kYXRhID0gcC5sZWZ0Q2hpbGQuZGF0YTtcclxuICAgICAgICBwLmxlZnRDaGlsZCA9IHAubGVmdENoaWxkLmxlZnRDaGlsZDtcclxuICAgIH1cclxuICAgIC8vIOWPquacieWPs+WtkOagkVxyXG4gICAgZWxzZSBpZiAoIXAubGVmdENoaWxkKSB7XHJcbiAgICAgICAgcC5kYXRhID0gcC5yaWdodENoaWxkLmRhdGE7XHJcbiAgICAgICAgcC5yaWdodENoaWxkID0gcC5yaWdodENoaWxkLnJpZ2h0Q2hpbGQ7XHJcbiAgICB9XHJcbiAgICAvLyDlt6blj7PlrZDmoJHpg73mnIlcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBzID0gcC5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgLy8gceS4uueItue7k+eCuVxyXG4gICAgICAgIGxldCBxID0gcDtcclxuICAgICAgICAvLyDmib7liLDlt6blrZDmoJHnmoTmnIDlpKflj7PlrZDmoJHvvIzljbPku4XlsI/kuo7lt6blrZDmoJHnmoTlgLznmoTnu5PngrlcclxuICAgICAgICB3aGlsZSAocy5yaWdodENoaWxkKSB7XHJcbiAgICAgICAgICAgIHEgPSBzO1xyXG4gICAgICAgICAgICBzID0gcy5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcC5kYXRhID0gcy5kYXRhO1xyXG4gICAgICAgIGlmIChxICE9IHApIHEucmlnaHRDaGlsZCA9IHMubGVmdENoaWxkO1xyXG4gICAgICAgIGVsc2UgcS5sZWZ0Q2hpbGQgPSBzLmxlZnRDaGlsZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxubGV0IGJzdCA9IG5ldyBCU1ROb2RlKCk7XHJcbmJzdC5jcmVhdGVCU1QoWzQ1LCAyNCwgNTMsIDEyLCAyNCwgOTBdKTtcclxuY29uc29sZS5sb2coYnN0LnNlYXJjaCgxMikpO1xyXG5jb25zb2xlLmxvZyhic3Quc2VhcmNoKDEzKSk7XHJcblxyXG5sZXQgYnN0MiA9IG5ldyBCU1ROb2RlKCk7XHJcbmJzdDIuY3JlYXRlQlNUKFs0NSwgMjQsIDUzLCAxMiwgMjQsIDkwXSwgdHJ1ZSk7XHJcbmNvbnNvbGUubG9nKGJzdDIuc2VhcmNoTm9uUmVjdXJzaXZlKDEyKSk7XHJcbmNvbnNvbGUubG9nKGJzdDIuc2VhcmNoTm9uUmVjdXJzaXZlKDEzKSk7XHJcblxyXG5jb25zb2xlLmxvZygnXFxuZmluZFNpYmxpbmdFbGVtOiAnKTtcclxuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oMTIpICsgJycpO1xyXG5jb25zb2xlLmxvZyhic3QuZmluZE5laWdoYm9yRWxlbSg5MCkgKyAnJyk7XHJcbmNvbnNvbGUubG9nKGJzdC5maW5kTmVpZ2hib3JFbGVtKDQ1KSArICcnKTtcclxuXHJcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoNDUpKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSgxKSk7XHJcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoNTMpKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSgxMikpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDkwKSk7XHJcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMjQpKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSgyKSk7XHJcblxyXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDQ1KSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMSkpO1xyXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDUzKSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMTIpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSg5MCkpO1xyXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDI0KSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMikpO1xyXG5cclxuY29uc29sZS5sb2coJ1xcbmlzQlNUVHJlZTogJyk7XHJcbmNvbnNvbGUubG9nKEJTVE5vZGUuaXNCU1RUcmVlKGJzdCkpO1xyXG4vL2NvbnNvbGUubG9nKEJTVE5vZGUuaXNCU1RUcmVlKHNvc1RyZWUpKTtcclxuXHJcblxyXG4vKipcclxuICog5LuO5aSn5Yiw5bCP6L6T5Ye65LqM5Y+J5o6S5bqP5qCR5Lit5omA5pyJ5LiN5bCP5LqOeOeahOWFg+e0oFxyXG4gKiBAcGFyYW0gYnN0XHJcbiAqIEBwYXJhbSB4XHJcbiAqL1xyXG5mdW5jdGlvbiBwcmludE5vdExlc3NUaGFuKGJzdCwgeCkge1xyXG4gICAgaWYgKGJzdC5yaWdodENoaWxkKSBwcmludE5vdExlc3NUaGFuKGJzdC5yaWdodENoaWxkLCB4KTtcclxuICAgIGlmIChic3QuZGF0YSA8IHgpIHJldHVybjtcclxuICAgIGNvbnNvbGUubG9nKGJzdC5kYXRhKTtcclxuICAgIGlmIChic3QubGVmdENoaWxkKSBwcmludE5vdExlc3NUaGFuKGJzdC5sZWZ0Q2hpbGQsIHgpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygnXFxucHJpbnROb3RMZXNzVGhhbjogJyk7XHJcbnByaW50Tm90TGVzc1RoYW4oYnN0MiwgOTApO1xyXG5jb25zb2xlLmxvZygnXFxuJyk7XHJcbnByaW50Tm90TGVzc1RoYW4oYnN0MiwgMTIpO1xyXG5cclxuXHJcbmJzdC5tZXJnZShic3QyKTtcclxuXHJcbmxldCBhMSA9IG5ldyBCU1ROb2RlKDUpO1xyXG5sZXQgYTIgPSBuZXcgQlNUTm9kZSg5MSk7XHJcbmJzdDIuaW5zZXJ0Tm9kZShhMSk7XHJcbmJzdDIuaW5zZXJ0Tm9kZShhMik7XHJcblxyXG5ic3QyLnNwbGl0KDQ1KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0JpbmFyeVNvcnRlZFRyZWUuanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTUvMi8yLlxyXG4gKi9cclxuXHJcbnZhciBkZWZhdWx0Q29tcGFyZSA9IHJlcXVpcmUoJy4uL2RlZmF1bHRDb21wYXJpc2lvbicpO1xyXG5cclxuLypcclxuIOS6pOaNouaOkuW6j1xyXG5cclxuIOaYr+S4gOexu+WfuuS6juS6pOaNoueahOaOkuW6j++8jOezu+e7n+WcsOS6pOaNouWPjeW6j+eahOiusOW9leeahOWBtuWvue+8jOebtOWIsOS4jeWGjeaciei/meagt+eahOWBtuWvueS4uuatouOAguWFtuS4reacgOWfuuacrOeahOaYr+WGkuazoeaOkuW6jyhCdWJibGUgU29ydCnjgIJcclxuXHJcbiDlhpLms6HmjpLluo9cclxuIDEgIOaOkuW6j+aAneaDs1xyXG4g5L6d5qyh5q+U6L6D55u46YK755qE5Lik5Liq6K6w5b2V55qE5YWz6ZSu5a2X77yM6Iul5Lik5Liq6K6w5b2V5piv5Y+N5bqP55qEKOWNs+WJjeS4gOS4quiusOW9leeahOWFs+mUruWtl+Wkp+S6juWQjuWJjeS4gOS4quiusOW9leeahOWFs+mUruWtlynvvIzliJnov5vooYzkuqTmjaLvvIznm7TliLDmsqHmnInlj43luo/nmoTorrDlvZXkuLrmraLjgIJcclxuICAgICDikaAg6aaW5YWI5bCGTC0+UlsxXeS4jkwtPlJbMl3nmoTlhbPplK7lrZfov5vooYzmr5TovoPvvIzoi6XkuLrlj43luo8oTC0+UlsxXeeahOWFs+mUruWtl+Wkp+S6jkwtPlJbMl3nmoTlhbPplK7lrZcp77yM5YiZ5Lqk5o2i5Lik5Liq6K6w5b2V77yb54S25ZCO5q+U6L6DTC0+UlsyXeS4jkwtPlJbM13nmoTlhbPplK7lrZfvvIzkvp3mraTnsbvmjqjvvIznm7TliLBMLT5SW24tMV3kuI5MLT5SW25d55qE5YWz6ZSu5a2X5q+U6L6D5ZCO5Li65q2i77yM56ew5Li65LiA6Laf5YaS5rOh5o6S5bqP77yMTC0+UltuXeS4uuWFs+mUruWtl+acgOWkp+eahOiusOW9leOAglxyXG4gICAgIOKRoSAg54S25ZCO6L+b6KGM56ys5LqM6Laf5YaS5rOh5o6S5bqP77yM5a+55YmNbi0x5Liq6K6w5b2V6L+b6KGM5ZCM5qC355qE5pON5L2c44CCXHJcbiDkuIDoiKzlnLDvvIznrKxp6Laf5YaS5rOh5o6S5bqP5piv5a+5TC0+UlsxIOKApiBuLWkrMV3kuK3nmoTorrDlvZXov5vooYznmoTvvIzlm6DmraTvvIzoi6XlvoXmjpLluo/nmoTorrDlvZXmnIlu5Liq77yM5YiZ6KaB57uP6L+Hbi0x6Laf5YaS5rOh5o6S5bqP5omN6IO95L2/5omA5pyJ55qE6K6w5b2V5pyJ5bqP44CCXHJcblxyXG4gMiAg5o6S5bqP56S65L6LXHJcbiDorr7mnIk55Liq5b6F5o6S5bqP55qE6K6w5b2V77yM5YWz6ZSu5a2X5YiG5Yir5Li6MjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MVxyXG5cclxuIOWIneWni+WFs+mUruWtl+W6j+WIlzogIDIzICAgIDM4ICAgICAyMiAgICAgNDUgICAgIDIzICAgICA2NyAgICAgMzEgICAgIDE1ICAgIDQxXHJcbiDnrKzkuIDotp/mjpLluo/lkI46ICAgIDIzICAgIDIyICAgICAzOCAgICAgMjMgICAgIDQ1ICAgICAzMSAgICAgMTUgICAgIDQxICAgIDY3XHJcbiDnrKzkuozotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMzggICAgIDMxICAgICAxNSAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzkuInotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMzEgICAgIDE1ICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzlm5votp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMTUgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzkupTotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAxNSAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzlha3otp/mjpLluo/lkI46ICAgIDIyICAgIDE1ICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzkuIPotp/mjpLluo/lkI46ICAgIDE1ICAgIDIyICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcblxyXG4zLueul+azleWIhuaekFxyXG4g5pe26Ze05aSN5p2C5bqmXHJcbiDil4YgIOacgOWlveaDheWGtSjmraPluo8p77ya5q+U6L6D5qyh5pWw77yabi0x77yb56e75Yqo5qyh5pWw77yaMO+8m1xyXG4g4peGICDmnIDlnY/mg4XlhrUo6YCG5bqPKe+8mlxyXG4g5q+U6L6D5qyh5pWw77yaIG4gKiAobiAtIDEpIC8gMlxyXG4g56e75Yqo5qyh5pWw77yaIDMqbioobiAtIDEpIC8gMlxyXG5cclxuIOaVheaXtumXtOWkjeadguW6pu+8mlQobik9TyhuwrIpXHJcbiDnqbrpl7TlpI3mnYLluqbvvJpTKG4pPU8oMSlcclxuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYnViYmxlU29ydChzcUxpc3QsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBmb3IodmFyIGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIHZhciBjaGFuZ2UgPSAwO1xyXG5cclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDw9IGxlbiAtIGk7ICsrail7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoc3FMaXN0W2ogKyAxXSwgc3FMaXN0W2pdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtqXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtqXSA9IHNxTGlzdFtqICsgMV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gdGVtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIWNoYW5nZSkgYnJlYWs7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5idWJibGVTb3J0ID0gYnViYmxlU29ydDtcclxuXHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5idWJibGVTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKCdidWJibGVTb3J0OlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuLy8g5YaS5rOh5pS56L+bMVxyXG5mdW5jdGlvbiBidWJibGVTb3J0MihzcUxpc3QsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIHZhciBjaGFuZ2UgPSBsZW4gLSAxO1xyXG5cclxuICAgIHdoaWxlKGNoYW5nZSl7XHJcbiAgICAgICAgZm9yKHZhciBjID0gMCwgaSA9IDA7IGkgPCBjaGFuZ2U7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgLy8gY+aMh+ekuui/meS4gOi2n+WGkuazoeS4reWPkeeUn+S6pOaNoueahOWFg+e0oFxyXG4gICAgICAgICAgICAgICAgYyA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGFuZ2UgPSBjO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYnViYmxlU29ydDIgPSBidWJibGVTb3J0MjtcclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbmJ1YmJsZVNvcnQyKGFycik7XHJcbmNvbnNvbGUubG9nKCdidWJibGVTb3J0MjpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8vIOebuOmCu+S4pOi2n+WPjeaWueWQkei1t+azoeeahOWGkuazoeaOkuW6j+eul+azlVxyXG5mdW5jdGlvbiBjb2NrVGFpbFNvcnQoc3FMaXN0LCBjb21wKXtcclxuICAgIGlmKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgdmFyIGxlbiA9IHNxTGlzdC5sZW5ndGg7XHJcbiAgICAvLyDlhpLms6HkuIrkuIvnlYxcclxuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGVuIC0gMTtcclxuICAgIHZhciBjaGFuZ2UgPSAxO1xyXG4gICAgdmFyIHRlbXA7XHJcblxyXG4gICAgd2hpbGUobG93IDwgaGlnaCAmJiBjaGFuZ2Upe1xyXG4gICAgICAgIGNoYW5nZSA9IDA7XHJcblxyXG4gICAgICAgIC8vIOS7juS4iuWQkeS4i+i1t+azoVxyXG4gICAgICAgIGZvcih2YXIgaSA9IGxvdzsgaSA8IGhpZ2g7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOS/ruaUueS4iueVjFxyXG4gICAgICAgIC0taGlnaDtcclxuXHJcbiAgICAgICAgLy8g5LuO5LiL5ZCR5LiK6LW35rOhXHJcbiAgICAgICAgZm9yKGkgPSBoaWdoOyBpID4gbG93OyAtLWkpe1xyXG4gICAgICAgICAgICBpZihjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgLSAxXSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpIC0gMV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDkv67mlLnkuIvnlYxcclxuICAgICAgICArK2xvdztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvY2tUYWlsU29ydCA9IGNvY2tUYWlsU29ydDtcclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbmNvY2tUYWlsU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZygnY29ja1RhaWxTb3J0OlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuLy8g5pS56L+bM1xyXG5mdW5jdGlvbiBjb2NrVGFpbFNvcnQyKHNxTGlzdCwgY29tcCl7XHJcbiAgICBpZihjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIHZhciBiID0ge307XHJcbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIC8vIGTkuLrlhpLms6HmlrnlkJHmoIfor4bvvIwgMeS4uuWQkeS4iu+8jC0x5Li65ZCR5LiLXHJcbiAgICB2YXIgZCA9IDE7XHJcbiAgICAvLyBiWzBd5Li65YaS5rOh5LiK55WM77yMYlsyXeS4uuWGkuazoeS4iueVjO+8jGJbMV3ml6DnlKhcclxuICAgIGJbMF0gPSAwO1xyXG4gICAgYlsyXSA9IGxlbiAtIDE7XHJcbiAgICB2YXIgY2hhbmdlID0gMTtcclxuXHJcbiAgICB3aGlsZShiWzBdIDwgYlsyXSAmJiBjaGFuZ2Upe1xyXG4gICAgICAgIGNoYW5nZSA9IDA7XHJcblxyXG4gICAgICAgIC8vIOe7n+S4gOeahOWGkuazoeeul+azlVxyXG4gICAgICAgIGZvcih2YXIgaSA9IGJbMSAtIGRdOyBpICE9PSBiWzEgKyBkXTsgaSArPSBkKXtcclxuICAgICAgICAgICAgLy8g5rOo5oSP6L+Z5Liq5Lqk5o2i5p2h5Lu2XHJcbiAgICAgICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIGRdKSAqIGQgPiAwKXtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyBkXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgZF0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5L+u5pS56L6555WMXHJcbiAgICAgICAgYlsxICsgZF0gLT0gZDtcclxuICAgICAgICAvLyDmjaLkuKrmlrnlkJFcclxuICAgICAgICBkICo9IC0xO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29ja1RhaWxTb3J0MiA9IGNvY2tUYWlsU29ydDI7XHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5jb2NrVGFpbFNvcnQyKGFycik7XHJcbmNvbnNvbGUubG9nKCdjb2NrVGFpbFNvcnQyOlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDlv6vpgJ/mjpLluo9cclxuXHJcbiAxICDmjpLluo/mgJ3mg7NcclxuIOmAmui/h+S4gOi2n+aOkuW6j++8jOWwhuW+heaOkuW6j+iusOW9leWIhuWJsuaIkOeLrOeri+eahOS4pOmDqOWIhu+8jOWFtuS4reS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wdh+avlOWPpuS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wwj++8jOWGjeWIhuWIq+Wvuei/meS4pOmDqOWIhuiusOW9lei/m+ihjOS4i+S4gOi2n+aOkuW6j++8jOS7pei+vuWIsOaVtOS4quW6j+WIl+acieW6j+OAglxyXG5cclxuIDIgIOaOkuW6j+i/h+eoi1xyXG4g6K6+5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX5pivUltz4oCmdF0g77yM5Zyo6K6w5b2V5bqP5YiX5Lit5Lu75Y+W5LiA5Liq6K6w5b2VKOS4gOiIrOWPllJbc10p5L2c5Li65Y+C54WnKOWPiOensOS4uuWfuuWHhuaIluaeoui9tCnvvIzku6VSW3NdLmtleeS4uuWfuuWHhumHjeaWsOaOkuWIl+WFtuS9meeahOaJgOacieiusOW9le+8jOaWueazleaYr++8mlxyXG4gICAgIOKXhiDmiYDmnInlhbPplK7lrZfmr5Tln7rlh4blsI/nmoTmlL5SW3Nd5LmL5YmN77ybXHJcbiAgICAg4peGIOaJgOacieWFs+mUruWtl+avlOWfuuWHhuWkp+eahOaUvlJbc13kuYvlkI7jgIJcclxuIOS7pVJbc10ua2V55pyA5ZCO5omA5Zyo5L2N572uaeS9nOS4uuWIhueVjO+8jOWwhuW6j+WIl1Jbc+KApnRd5YiG5Ymy5oiQ5Lik5Liq5a2Q5bqP5YiX77yM56ew5Li65LiA6Laf5b+r6YCf5o6S5bqP44CCXHJcblxyXG4gMyAg5LiA6Laf5b+r6YCf5o6S5bqP5pa55rOVXHJcbiDku47luo/liJfnmoTkuKTnq6/kuqTmm7/miavmj4/lkITkuKrorrDlvZXvvIzlsIblhbPplK7lrZflsI/kuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXkvp3mrKHmlL7nva7liLDluo/liJfnmoTliY3ovrnvvJvogIzlsIblhbPplK7lrZflpKfkuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXku47luo/liJfnmoTmnIDlkI7nq6/otbfvvIzkvp3mrKHmlL7nva7liLDluo/liJfnmoTlkI7ovrnvvIznm7TliLDmiavmj4/lrozmiYDmnInnmoTorrDlvZXjgIJcclxuXHJcbiDorr7nva7mjIfpkohsb3fvvIxoaWdo77yM5Yid5YC85Li656ysMeS4quWSjOacgOWQjuS4gOS4quiusOW9leeahOS9jee9ruOAglxyXG4g6K6+5Lik5Liq5Y+Y6YePae+8jGrvvIzliJ3lp4vml7bku6RpPWxvd++8jGo9aGlnaO+8jOS7pVJbbG93XS5rZXnkvZzkuLrln7rlh4Yo5bCGUltsb3dd5L+d5a2Y5ZyodGVtcOS4rSkg44CCXHJcbiDikaAg5LuOauaJgOaMh+S9jee9ruWQkeWJjeaQnOe0ou+8muWwhnRlbXDkuI5SW2pdLmtleei/m+ihjOavlOi+g++8mlxyXG4gICAg4peGIOiLpXRlbXDiiaRSW2pdLmtleSDvvJrku6RqPWotMe+8jOeEtuWQjue7p+e7rei/m+ihjOavlOi+g++8jCDnm7TliLBpPWrmiJZ0ZW1wPlJbal0ua2V55Li65q2i77ybXHJcbiAgICDil4Yg6IuldGVtcD5SW2pdLmtleSDvvJpSW2pd74OeUltpXe+8jOiFvuepulJbal3nmoTkvY3nva7vvIwg5LiU5LukaT1pKzHvvJtcclxuIOKRoSDku45p5omA5oyH5L2N572u6LW35ZCR5ZCO5pCc57Si77ya5bCGdGVtcOS4jlJbaV0ua2V56L+b6KGM5q+U6L6D77yaXHJcbiAgICDil4Yg6IuldGVtcOKJpVJbaV0ua2V5IO+8muS7pGk9aSsx77yM54S25ZCO57un57ut6L+b6KGM5q+U6L6D77yMIOebtOWIsGk9auaIlnRlbXA8UltpXS5rZXnkuLrmraLvvJtcclxuICAgIOKXhiDoi6V0ZW1wPFJbaV0ua2V5IO+8mlJbaV3vg55SW2pd77yM6IW+56m6UltpXeeahOS9jee9ru+8jCDkuJTku6RqPWotMe+8m1xyXG4g4pGiIOmHjeWkjeKRoOOAgeKRoe+8jOebtOiHs2k9auS4uuatou+8jGnlsLHmmK90ZW1wKOWfuuWHhinmiYDlupTmlL7nva7nmoTkvY3nva7jgIJcclxuXHJcbiDnrpfms5XliIbmnpBcclxuIOW/q+mAn+aOkuW6j+eahOS4u+imgeaXtumXtOaYr+iKsei0ueWcqOWIkuWIhuS4iu+8jOWvuemVv+W6puS4umvnmoTorrDlvZXluo/liJfov5vooYzliJLliIbml7blhbPplK7lrZfnmoTmr5TovoPmrKHmlbDmmK9rLTEg44CC6K6+6ZW/5bqm5Li6bueahOiusOW9leW6j+WIl+i/m+ihjOaOkuW6j+eahOavlOi+g+asoeaVsOS4ukMobinvvIzliJlDKG4pPW4tMStDKGspK0Mobi1rLTEpIOOAglxyXG4g4peGICDmnIDlpb3mg4XlhrXvvJrmr4/mrKHliJLliIblvpfliLDnmoTlrZDluo/liJflpKfoh7Tnm7jnrYnvvIzliJlcclxuIEMobik8PWjDl24rMmjDl0Mobi8yaCkg77yM5b2Tbi8yaD0x5pe25o6S5bqP57uT5p2f44CCXHJcbiDljbNDKG4p4omkTyhuw5fjj5Iybikg77ybXHJcbiDil4YgIOacgOWdj+aDheWGte+8muavj+asoeWIkuWIhuW+l+WIsOeahOWtkOW6j+WIl+S4reacieS4gOS4quS4uuepuu+8jOWPpuS4gOS4quWtkOW6j+WIl+eahOmVv+W6puS4um4tMeOAguWNs+avj+asoeWIkuWIhuaJgOmAieaLqeeahOWfuuWHhuaYr+W9k+WJjeW+heaOkuW6j+W6j+WIl+S4reeahOacgOWwjyjmiJbmnIDlpKcp5YWz6ZSu5a2X44CCXHJcbiDmr5TovoPmrKHmlbDvvJo6ICDljbNDKG4pPU8objIpXHJcbiDil4YgIOS4gOiIrOaDheWGte+8miDlr7lu5Liq6K6w5b2V6L+b6KGM5b+r6YCf5o6S5bqP5omA6ZyA55qE5pe26Ze0VChuKee7hOaIkOaYr++8mlxyXG4gICAgIOKRoCDlr7lu5Liq6K6w5b2V6L+b6KGM5LiA6Laf5YiS5YiG5omA6ZyA55qE5pe26Ze05piv77yabsOXQyDvvIxD5piv5bi45pWw77ybXHJcbiAgICAg4pGhIOWvueaJgOW+l+WIsOeahOS4pOS4quWtkOW6j+WIl+i/m+ihjOW/q+mAn+aOkuW6j+eahOaXtumXtO+8mlxyXG4gICAgICAgIFRhdmcobik9QyhuKStUYXZnKGstMSkrVGF2ZyhuLWspICAgICAgICAgIOKApuKAplxyXG5cclxuIOW/q+mAn+aOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puaYr++8mlQobik9Tyhu44+SMm4pXHJcbiDku47miYDpnIDopoHnmoTpmYTliqDnqbrpl7TmnaXnnIvvvIzlv6vpgJ/mjpLluo/nrpfms5XmmK/pgJLlvZLosIPnlKjvvIzns7vnu5/lhoXnlKjloIbmoIjkv53lrZjpgJLlvZLlj4LmlbDvvIzlvZPmr4/mrKHliJLliIbmr5TovoPlnYfljIDml7bvvIzmoIjnmoTmnIDlpKfmt7HluqbkuLpb44+SMm5dKzEg44CCXHJcblxyXG4g5b+r6YCf5o6S5bqP55qE56m66Ze05aSN5p2C5bqm5piv77yaUyhuKT1PKOOPkjJuKVxyXG4g5LuO5o6S5bqP55qE56iz5a6a5oCn5p2l55yL77yM5b+r6YCf5o6S5bqP5piv5LiN56iz5a6a55qE44CCXHJcblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHBhcnRpdGlvbjEoc3FMaXN0LCBsb3csIGhpZ2gpe1xyXG4gICAgdmFyIHRlbXAgPSBzcUxpc3RbbG93XTtcclxuXHJcbiAgICB3aGlsZShsb3cgPCBoaWdoKXtcclxuICAgICAgICB3aGlsZShsb3cgPCBoaWdoICYmIHNxTGlzdFtoaWdoXSA+PSB0ZW1wKSAtLWhpZ2g7XHJcbiAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbaGlnaF07XHJcbiAgICAgICAgd2hpbGUobG93IDwgaGlnaCAmJiBzcUxpc3RbbG93XSA8PSB0ZW1wKSArK2xvdztcclxuICAgICAgICBzcUxpc3RbaGlnaF0gPSBzcUxpc3RbbG93XTtcclxuICAgIH1cclxuXHJcbiAgICBzcUxpc3RbbG93XSA9IHRlbXA7XHJcblxyXG4gICAgcmV0dXJuIGxvdztcclxufVxyXG5cclxuLy8g5LyY5YyW5LiA6Laf5b+r6YCf5o6S5bqP5pa55rOV77yaIOmaj+acuuWMlnBhcnRpdGlvblxyXG4vLyDmnIDlnY/mg4XlhrXmlYjnjoflpKfluYXmj5DljYfvvIzml7bpl7TlpI3mnYLluqZUKG4pPU8obuOPkjJuKVxyXG5mdW5jdGlvbiBwYXJ0aXRpb24yKHNxTGlzdCwgbG93LCBoaWdoKXtcclxuICAgIHZhciB0ZW1wO1xyXG4gICAgdmFyIG4gPSBoaWdoIC0gbG93ICsgMTtcclxuICAgIHZhciByYW5kID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbikgKyBsb3c7XHJcblxyXG4gICAgLy92YXIgcmFuZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xyXG4gICAgdGVtcCA9IHNxTGlzdFtoaWdoXTtcclxuICAgIHNxTGlzdFtoaWdoXSA9IHNxTGlzdFtyYW5kXTtcclxuICAgIHNxTGlzdFtyYW5kXSA9IHRlbXA7XHJcblxyXG4gICAgdmFyIGkgPSBsb3cgLSAxO1xyXG4gICAgdmFyIHBpdm90ID0gc3FMaXN0W2hpZ2hdO1xyXG5cclxuICAgIGZvcih2YXIgaiA9IGxvdzsgaiA8IGhpZ2g7ICsrail7XHJcbiAgICAgICAgaWYoc3FMaXN0W2pdIDw9IHBpdm90KSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2pdO1xyXG4gICAgICAgICAgICBzcUxpc3Rbal0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICArK2k7XHJcbiAgICBzcUxpc3RbaGlnaF0gPSBzcUxpc3RbaV07XHJcbiAgICBzcUxpc3RbaV0gPSBwaXZvdDtcclxuXHJcbiAgICByZXR1cm4gaTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKXtcclxuICAgIHZhciB0ZW1wO1xyXG4gICAgdmFyIGkgPSBsb3c7XHJcbiAgICB2YXIgaiA9IGhpZ2ggKyAxO1xyXG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpICsgbG93ICsgMTtcclxuICAgIC8vdmFyIHJhbmQgPSAobG93ICsgaGlnaCkgPj4gMTtcclxuXHJcbiAgICB0ZW1wID0gc3FMaXN0W2xvd107XHJcbiAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtyYW5kXTtcclxuICAgIHNxTGlzdFtyYW5kXSA9IHRlbXA7XHJcblxyXG4gICAgdmFyIHggPSBzcUxpc3RbbG93XTtcclxuXHJcbiAgICB3aGlsZSgxKXtcclxuICAgICAgICB3aGlsZShjb21wKHNxTGlzdFsrK2ldLCB4KSA8IDAgJiYgaSA8IGhpZ2gpO1xyXG4gICAgICAgIHdoaWxlKGNvbXAoc3FMaXN0Wy0tal0sIHgpID4gMCk7XHJcbiAgICAgICAgaWYoaSA+PSBqKSBicmVhaztcclxuICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtqXTtcclxuICAgICAgICBzcUxpc3Rbal0gPSB0ZW1wO1xyXG4gICAgfVxyXG5cclxuICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2pdO1xyXG4gICAgc3FMaXN0W2pdID0geDtcclxuXHJcbiAgICByZXR1cm4gajtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKXtcclxuICAgIGlmKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgaWYobG93ID09IG51bGwpIGxvdyA9IDA7XHJcbiAgICBpZihoaWdoID09IG51bGwpIGhpZ2ggPSBzcUxpc3QubGVuZ3RoIC0gMTtcclxuXHJcbiAgICBpZihsb3cgPj0gaGlnaCkgcmV0dXJuO1xyXG5cclxuICAgIHZhciBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuICAgIHF1aWNrU29ydFJlY3Vyc2l2ZShzcUxpc3QsIGxvdywgayAtIDEsIGNvbXApO1xyXG4gICAgcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgayArIDEsIGhpZ2gsIGNvbXApO1xyXG59XHJcbmV4cG9ydHMucXVpY2tTb3J0UmVjdXJzaXZlID0gcXVpY2tTb3J0UmVjdXJzaXZlO1xyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxucXVpY2tTb3J0UmVjdXJzaXZlKGFycik7XHJcbmNvbnNvbGUubG9nKCdxdWlja1NvcnRSZWN1cnNpdmU6XFxuJyArIGFyciArICcnKTtcclxuXHJcblxyXG4vKlxyXG7lv6vmjpLpgJLlvZLnrpfms5XkvJjljJbvvIzlnKjmnIDlnY/mg4XlhrXkuIvloIbmoIjmt7HluqbkuLpPKGxvZ24pXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWlja1NvcnRSZWN1cnNpdmUyKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKXtcclxuICAgIGlmKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgaWYobG93ID09IG51bGwpIGxvdyA9IDA7XHJcbiAgICBpZihoaWdoID09IG51bGwpIGhpZ2ggPSBzcUxpc3QubGVuZ3RoIC0gMTtcclxuXHJcbiAgICB3aGlsZShsb3cgPCBoaWdoKXtcclxuICAgICAgICB2YXIgayA9IHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCk7XHJcblxyXG4gICAgICAgIC8vIOWvueS4pOS4quWtkOaVsOe7hOS4rei+g+Wwj+eahOS4gOS4quWtkOaVsOe7hOi/m+ihjOmAkuW9kuiwg+eUqOOAglxyXG4gICAgICAgIC8vIOi+g+Wwj+WtkOaVsOe7hOeahOWkp+Wwj+acgOWkmuS4uuWOn+aVsOe7hOWkp+Wwj+S4gOWNiu+8jFxyXG4gICAgICAgIC8vIOeUseS6juavj+asoemAkuW9kuiwg+eUqOeahOaVsOe7hOWkp+Wwj+iHs+WwkeWHj+WwkeS4gOWNiu+8jOaJgOS7pemAkuW9kuiwg+eUqOeahOasoeaVsFxyXG4gICAgICAgIC8vIOacgOWkmuS4uk8obG9nbilcclxuICAgICAgICBpZihrIC0gbG93ICsgMSA8IGhpZ2ggLSBrKSB7XHJcbiAgICAgICAgICAgIHF1aWNrU29ydFJlY3Vyc2l2ZTIoc3FMaXN0LCBsb3csIGsgLSAxLCBjb21wKTtcclxuICAgICAgICAgICAgbG93ID0gayArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXVpY2tTb3J0UmVjdXJzaXZlMihzcUxpc3QsIGsgKyAxLCBoaWdoLCBjb21wKTtcclxuICAgICAgICAgICAgaGlnaCA9IGsgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnF1aWNrU29ydFJlY3Vyc2l2ZTIgPSBxdWlja1NvcnRSZWN1cnNpdmUyO1xyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5xdWlja1NvcnRSZWN1cnNpdmUyKGFycik7XHJcbmNvbnNvbGUubG9nKCdxdWlja1NvcnRSZWN1cnNpdmUyOlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gcXVpY2tTb3J0Tm9uUmVjdXJzaXZlKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKXtcclxuICAgIGlmKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgaWYobG93ID09IG51bGwpIGxvdyA9IDA7XHJcbiAgICBpZihoaWdoID09IG51bGwpIGhpZ2ggPSBzcUxpc3QubGVuZ3RoIC0gMTtcclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgdmFyIGs7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHdoaWxlKGxvdyA8IGhpZ2gpe1xyXG4gICAgICAgICAgICBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuICAgICAgICAgICAgLy8g56ys5LqM5Liq5a2Q5bqP5YiX55qE5LiKLOS4i+eVjOWIhuWIq+WFpeagiFxyXG4gICAgICAgICAgICBzdGFjay5wdXNoKGhpZ2gsIGsgKyAxKTtcclxuICAgICAgICAgICAgLy9zdGFjay5wdXNoKGsgKyAxKTtcclxuICAgICAgICAgICAgaGlnaCA9IGsgLSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsb3cgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICBoaWdoID0gc3RhY2sucG9wKCk7XHJcbiAgICB9IHdoaWxlKDEpO1xyXG59XHJcbmV4cG9ydHMucXVpY2tTb3J0Tm9uUmVjdXJzaXZlID0gcXVpY2tTb3J0Tm9uUmVjdXJzaXZlO1xyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxucXVpY2tTb3J0Tm9uUmVjdXJzaXZlKGFycik7XHJcbmNvbnNvbGUubG9nKCdxdWlja1NvcnROb25SZWN1cnNpdmU6XFxuJyArIGFyciArICcnKTtcclxuXHJcbi8vIOS8mOWMlueJiOacrFxyXG5mdW5jdGlvbiBxdWlja1NvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBpZihsb3cgPT0gbnVsbCkgbG93ID0gMDtcclxuICAgIGlmKGhpZ2ggPT0gbnVsbCkgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxO1xyXG4gICAgdmFyIHN0YWNrID0gW107XHJcbiAgICB2YXIgcGl2b3Q7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIC8vIOWmguaenOW9k+WJjeWtkOW6j+WIl+mVv+W6puWkp+S6jjPkuJTlsJrmnKrmjpLlpb3luo9cclxuICAgICAgICBpZihoaWdoIC0gbG93ID4gMikge1xyXG4gICAgICAgICAgICAvLyDov5vooYzkuIDotp/liJLliIZcclxuICAgICAgICAgICAgcGl2b3QgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xyXG5cclxuICAgICAgICAgICAgLy8g5ZCn6ZW/55qE5a2Q5bqP5YiX6L6555WM5YWl5qCI77yMXHJcbiAgICAgICAgICAgIC8vIOefreeahOWtkOW6j+WIl+eVmeW+heS4i+asoeaOkuW6j1xyXG4gICAgICAgICAgICBpZihoaWdoIC0gcGl2b3QgPiBwaXZvdCAtIGxvdykge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChoaWdoLCBwaXZvdCArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy9zdGFjay5wdXNoKCk7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gcGl2b3QgLSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwaXZvdCAtIDEsIGxvdyk7XHJcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcclxuICAgICAgICAgICAgICAgIGxvdyA9IHBpdm90ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlpoLmnpzlvZPliY3lrZDluo/liJfplb/luqblsI/kuo4z77yM5LiU5bCa5pyq5o6S5aW95bqP77yMXHJcbiAgICAgICAgLy8g55u05o6l6L+b6KGM5q+U6L6D5o6S5bqP5Lmw5b2T5YmN5a2Q5bqP5YiX5qCH5b+X5Li65bey5o6S5aW95bqPXHJcbiAgICAgICAgZWxzZSBpZihsb3cgPCBoaWdoICYmIGhpZ2ggLSBsb3cgPCAzKSB7XHJcbiAgICAgICAgICAgIGVhc3lTb3J0KHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuICAgICAgICAgICAgbG93ID0gaGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5aaC5p6c5b2T5YmN5a2Q5bqP5YiX5bey5o6S5aW95bqP5L2G5qCI5Lit6L+Y5pyJ5pyq5o6S5bqP55qE5a2Q5bqP5YiXXHJcbiAgICAgICAgLy8g5LuO5qCI5Lit5Y+W5Ye65LiA5Liq5a2Q5bqP5YiXXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKCFzdGFjay5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxvdyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBoaWdoID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSB3aGlsZSgxKTtcclxufVxyXG5leHBvcnRzLnF1aWNrU29ydCA9IHF1aWNrU29ydDtcclxuXHJcbmZ1bmN0aW9uIGVhc3lTb3J0KHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKXtcclxuICAgIHZhciB0ZW1wO1xyXG5cclxuICAgIGlmKGhpZ2ggLSBsb3cgPT09IDEpIHtcclxuICAgICAgICBpZihjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbaGlnaF0pID4gMCkge1xyXG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2hpZ2hdO1xyXG4gICAgICAgICAgICBzcUxpc3RbaGlnaF0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYoY29tcChzcUxpc3RbbG93XSwgc3FMaXN0W2xvdyArIDFdKSA+IDApIHtcclxuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtsb3cgKyAxXTtcclxuICAgICAgICAgICAgc3FMaXN0W2xvdyArIDFdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY29tcChzcUxpc3RbbG93ICsgMV0sIHNxTGlzdFtoaWdoXSkgPiAwKSB7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbbG93ICsgMV07XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHNxTGlzdFtoaWdoXTtcclxuICAgICAgICAgICAgc3FMaXN0W2hpZ2hdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY29tcChzcUxpc3RbbG93XSwgc3FMaXN0W2xvdyArIDFdKSA+IDApIHtcclxuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtsb3cgKyAxXTtcclxuICAgICAgICAgICAgc3FMaXN0W2xvdyArIDFdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbnF1aWNrU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZygncXVpY2tTb3J0OlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuLy8g5aWH5YG25Lqk5o2i5o6S5bqPXHJcbmZ1bmN0aW9uIG9kZEV2ZW5Tb3J0KHNxTGlzdCwgY29tcCl7XHJcbiAgICBpZihjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIHZhciBjaGFuZ2UgPSAxO1xyXG4gICAgdmFyIHRlbXA7XHJcbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZShjaGFuZ2Upe1xyXG4gICAgICAgIGNoYW5nZSA9IDA7XHJcbiAgICAgICAgLy8g5a+55omA5pyJ5aWH5pWw6L+b6KGM5LiA6Laf5q+U6L6DXHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGxlbiAtIDE7IGkgKz0gMil7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5a+55omA5pyJ5YG25pWw6L+b6KGM5LiA6Laf5q+U6L6DXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAyKXtcclxuICAgICAgICAgICAgaWYoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcclxuXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMub2RkRXZlblNvcnQgPSBvZGRFdmVuU29ydDtcclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbm9kZEV2ZW5Tb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKCdvZGRFdmVuU29ydDpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbuaKiueUseS4ieenjeminOiJsue7hOaIkOeahOW6j+WIl+mHjeaOkuS4uuaMieeFp+e6oueZveiTneeahOmhuuW6j+aOkuWIl++8jFxyXG7mgJ3ot6/vvJpcclxu6K6+56uL5LiJ5Liq5oyH6ZKI77yM5YW25LitauihqOekuuW9k+WJjeWFg+e0oO+8m2nku6XliY3nmoTlhYPntKDlhajpg6jkuLrnuqLoibLvvJtr5Lul5ZCO55qE6aKc6Imy5YWo5Li66JOd6Imy44CC6L+Z5qC35bCx5Y+v5Lul5qC55o2uaueahOminOiJsuaKiuWFtuS6pOaNouWIsOW6j+WIl+eahOWJjemdouaIluiAheWQjumdouOAglxyXG4gKi9cclxudmFyIFJFRCA9IDA7XHJcbnZhciBXSElURSA9IDE7XHJcbnZhciBCTFVFID0gMjtcclxuXHJcbmZ1bmN0aW9uIGZsYWdBcnJhbmdlKGNvbG9ycyl7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgaiA9IDA7XHJcbiAgICB2YXIgayA9IGNvbG9ycy5sZW5ndGggLSAxO1xyXG4gICAgdmFyIHRlbXA7XHJcblxyXG4gICAgd2hpbGUoaiA8PSBrKXtcclxuICAgICAgICBzd2l0Y2goY29sb3JzW2pdKXtcclxuICAgICAgICAgICAgY2FzZSBSRUQ6XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gY29sb3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29sb3JzW2ldID0gY29sb3JzW2pdO1xyXG4gICAgICAgICAgICAgICAgY29sb3JzW2pdID0gdGVtcDtcclxuICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgICsrajtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdISVRFOlxyXG4gICAgICAgICAgICAgICAgKytqO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQkxVRTpcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBjb2xvcnNbal07XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbal0gPSBjb2xvcnNba107XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNba10gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgLS1rO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhcnIgPSBbMiwgMSwgMCwgMiwgMSwgMSwgMCwgMiwgMCwgMiwgMV07XHJcbmZsYWdBcnJhbmdlKGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9Tb3J0L2V4Y2hhbmdlL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcclxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXHJcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxyXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXHJcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcblxyXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcclxuICBPID0gdG9JT2JqZWN0KE8pO1xyXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcclxuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xyXG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XHJcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxyXG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXHJcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcclxuXHJcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXHJcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XHJcbiAgTyA9IHRvT2JqZWN0KE8pO1xyXG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xyXG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xyXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog5Y2B5a2X6ZO+6KGoXHJcbiAqXHJcbiAqIOW9k+efqemYteeahOmdnumbtuS4quaVsOWSjOS9jee9ruWcqOaTjeS9nOi/h+eoi+S4reWPmOWMluWkp+aXtu+8jOWwseS4jeWunOmHh+eUqOmhuuW6j+WtmOWCqOe7k+aehOadpeihqOekuuS4ieWFg+e7hOeahOe6v+aAp+ihqOOAguS+i+Wmgu+8jOWcqOS9nOKAnOWwhuefqemYtULliqDliLDnn6npmLVB5LiK4oCd55qE5pON5L2c5pe277yM55Sx5LqO6Z2e6Zu25YWD55qE5o+S5YWl5oiW5Yig6Zmk5bCG5Lya5byV6LW3QS5kYXRh5Lit5YWD57Sg55qE56e75Yqo44CC5Li65q2k77yM5a+56L+Z56eN57G75Z6L55qE55+p6Zi177yM6YeH55So6ZO+5byP5a2Y5YKo57uT5p6E6KGo56S65LiJ5YWD57uE55qE57q/5oCn6KGo5pu05Li65oGw5b2T44CCXHJcbiAqXHJcbiAqIOWcqOmTvuihqOS4re+8jOavj+S4qumdnumbtuWFg+WPr+eUqOS4gOS4quWQqzXkuKrln5/nmoTnu5PngrnooajnpLrvvIzlhbbkuK1p77yMauWSjGXov5kz5Liq5Z+f5YiG5Yir6KGo56S66K+l6Z2e6Zu25YWD5omA5Zyo55qE6KGM77yM5YiX5ZKM6Z2e6Zu25YWD55qE5YC877yM5ZCR5Y+z5Z+fcmlnaHTnlKjku6Xpk77mjqXlkIzkuIDooYzkuK3kuIvkuIDkuKrpnZ7pm7blhYPvvIzlkJHkuIvln59kb3du55So5Lul6ZO+5o6l5ZCM5LiA5YiX5Lit5LiL5LiA5Liq6Z2e6Zu25YWD44CC5ZCM5LiA6KGM55qE6Z2e6Zu25YWD6YCa6L+HcmlnaHTln5/pk77mjqXmiJDkuIDkuKrnur/mgKfooajvvIzlkIzkuIDliJfkuK3nmoTpnZ7pm7blhYPpgJrluLhkb3du5Z+f6ZO+5o6l5oiQ5LiA5Liq57q/5oCn6ZO+6KGo77yM5q+P5LiA5Liq6Z2e6Zu25YWD5pei5piv5p+Q5Liq6KGM6ZO+6KGo5Lit55qE5LiA5Liq57uT54K577yM5Y+I5piv5p+Q5Liq5YiX6ZO+6KGo5Lit55qE5LiA5Liq57uT54K577yM5pW05Liq55+p6Zi15p6E5oiQ5LqG5LiA5Liq5Y2B5a2X5Lqk5Y+J55qE6ZO+6KGo44CCXHJcbiAqXHJcbiAqIOWPr+eUqOS4pOS4quWIhuWIq+WtmOWCqOihjOmTvuihqOeahOWktOaMh+mSiOWSjOWIl+mTvuihqOeahOWktOaMh+mSiOeahOS4gOe7tOaVsOe7hOadpeihqOekuuOAglxyXG4gKi9cclxuXHJcbi8vIOeogOeWj+efqemYteeahOWNgeWtl+mTvuihqOWtmOWCqOihqOekulxyXG5jbGFzcyBPTE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoaSA9IDAsIGogPSAwLCBlKSB7XHJcbiAgICAgICAgLy8g6K+l6Z2e6Zu25YWD55qE6KGM5ZKM5YiX5LiL5qCHXHJcbiAgICAgICAgdGhpcy5pID0gaTtcclxuICAgICAgICB0aGlzLmogPSBqO1xyXG4gICAgICAgIHRoaXMuZSA9IGU7XHJcbiAgICAgICAgLy8g6K+l6Z2e6Zu25YWD5omA5Zyo6KGM6KGo5ZKM5YiX6KGo55qE5ZCO57un6ZO+5Z+fXHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7ICAvLyB0eXBlOiBPTE5vZGVcclxuICAgICAgICB0aGlzLmRvd24gPSBudWxsOyAgIC8vIHR5cGU6IE9MTm9kZVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcm9zc0xpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8g6KGM5ZKM5YiX6ZO+6KGo5aS05oyH6ZKI5ZCR6YeP5Z+65Z2A55SxQ3JlYXRlU01hdHJpeOWIhumFjVxyXG4gICAgICAgIHRoaXMucmhlYWQgPSBbXTtcclxuICAgICAgICB0aGlzLmNoZWFkID0gW107XHJcbiAgICAgICAgLy8g56iA55aP55+p6Zi155qE6KGM5pWw77yM5YiX5pWwXHJcbiAgICAgICAgdGhpcy5tdSA9IDA7XHJcbiAgICAgICAgdGhpcy5udSA9IDA7XHJcbiAgICAgICAgdGhpcy50dSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnn6npmLXliJ3lp4vljJZcclxuICAgICAqIEBwYXJhbSBtXHJcbiAgICAgKiBAcGFyYW0gblxyXG4gICAgICogQHBhcmFtIHRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3Qg5LqM57u05pWw57uE77yM5q+P6KGM55qE5YWD57Sg5YiG5Yir5pivW2ksIGosIGVdXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNNYXRyaXgobSwgbiwgdCwgbGlzdCkge1xyXG4gICAgICAgIHRoaXMubXUgPSBtO1xyXG4gICAgICAgIHRoaXMubnUgPSBuO1xyXG4gICAgICAgIHRoaXMudHUgPSB0O1xyXG5cclxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBsaXN0Lmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBuZXcgT0xOb2RlKC4uLmxpc3Rbcm93XSk7XHJcbiAgICAgICAgICAgIGxldCBbaSwgal0gPSBsaXN0W3Jvd107XHJcbiAgICAgICAgICAgIGxldCBxO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucmhlYWRbaV0gPT0gbnVsbCB8fCB0aGlzLnJoZWFkW2ldLmogPiBqKSB7XHJcbiAgICAgICAgICAgICAgICBwLnJpZ2h0ID0gdGhpcy5yaGVhZFtpXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmhlYWRbaV0gPSBwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g5p+l6K+i5Zyo6KGM6KGo5Lit55qE5o+S5YWl5L2N572uXHJcbiAgICAgICAgICAgICAgICBmb3IgKHEgPSB0aGlzLnJoZWFkW2ldOyBxLnJpZ2h0ICYmIHEucmlnaHQuaiA8IGo7IHEgPSBxLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHAucmlnaHQgPSBxLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcS5yaWdodCA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWFkW2pdID09IG51bGwgfHwgdGhpcy5jaGVhZFtqXS5pID4gaSkge1xyXG4gICAgICAgICAgICAgICAgcC5kb3duID0gdGhpcy5jaGVhZFtqXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlYWRbal0gPSBwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChxID0gdGhpcy5jaGVhZFtqXTsgcS5kb3duICYmIHEuZG93bi5pIDwgaTsgcSA9IHEuZG93bik7XHJcbiAgICAgICAgICAgICAgICBwLmRvd24gPSBxLmRvd247XHJcbiAgICAgICAgICAgICAgICBxLmRvd24gPSBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOefqemYteebuOWKoFxyXG4gICAgYWRkTWF0cml4KGNyb3NzTGlzdCkge1xyXG4gICAgICAgIGxldCBobCA9IFtdO1xyXG4gICAgICAgIC8vaGzliJ3lp4vljJZcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSB0aGlzLm51OyBqKyspXHJcbiAgICAgICAgICAgIGhsW2pdID0gdGhpcy5jaGVhZFtqXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5tdTsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vcGHlkoxwYuaMh+WQkeavj+S4gOihjOeahOesrOS4gOS4qumdnjDlhYPnu5PngrnvvIznm7Toh7PmnIDlkI7kuIDooYxcclxuICAgICAgICAgICAgbGV0IHBhID0gdGhpcy5yaGVhZFtpXTtcclxuICAgICAgICAgICAgbGV0IHBiID0gY3Jvc3NMaXN0LnJoZWFkW2ldO1xyXG4gICAgICAgICAgICBsZXQgcHJlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8v5aSE55CGQueahOS4gOihjO+8jOebtOiHs+acrOihjOS4reaXoOmdnjDlhYPntKDnmoTnu5PngrlcclxuICAgICAgICAgICAgd2hpbGUgKHBiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcCwgcTtcclxuICAgICAgICAgICAgICAgIC8vIOaWsOaPkuWFpeS4gOS4que7k+eCueWIsHBh55qE5bem5L6nXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhIHx8IHBhLmogPiBwYi5qKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBPTE5vZGUocGIuaSwgcGIuaiwgcGIuZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8v6KGM6KGo55qE5oyH6ZKI5Y+Y5YyWXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRoaXMucmhlYWRbcC5pXSA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBwcmUucmlnaHQgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwLnJpZ2h0ID0gcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy/liJfooajnmoTmjIfpkojlj5jljJZcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGxbcC5qXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDku45obFtwLmpd5byA5aeL5om+5Yiw5paw57uT54K55Zyo5ZCM5LiA5YiX5Lit55qE5YmN6amx57uT54K577yM5bm26K6paGxbcC5qXeaMh+WQkeWug1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSBobFtwLmpdOyBxICYmIHEuaSA8IHAuaTtxID0gcS5kb3duKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxbcC5qXSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL+WcqOWIl+ihqOS4reaPkuWFpeaWsOe7k+eCue+8jOagueaNruihjOaVsOWIpOaWreaPkuWFpeWJjemdoui/mOaYr+WQjumdolxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVhZFtwLmpdIHx8IHRoaXMuY2hlYWRbcC5qXS5pID4gcC5pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuZG93biA9IHRoaXMuY2hlYWRbcC5qXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVhZFtwLmpdID0gcDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLmRvd24gPSBobFtwLmpdLmRvd247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsW3Aual0uZG93biA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBobFtwLmpdID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBwYiA9IHBiLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYS5qIDwgcGIuaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZSA9IHBhO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhID0gcGEucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5b2TcGEuaiA9PT0gcGIuauaXtu+8jOWwhkLkuK3lvZPliY3nu5PngrnnmoTlgLzliqDliLBB5Lit5b2T5YmN57uT54K55LiKXHJcbiAgICAgICAgICAgICAgICAgICAgcGEuZSArPSBwYi5lO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL+W9k3BhLmUgPT09IDDml7bvvIzliKDpmaTor6Xnu5PngrlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGEuZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDoi6Xml6DliY3pqbHnu5PngrnvvIzlsIbnrKzkuIDkuKrpnZ4w5YWD57uT54K5572u5Li65b2T5YmN57uT54K555qE5ZCO57un57uT54K577yMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWQpuWImeWJjempsee7k+eCueeahOWQjue7p+e7k+eCueS4uuW9k+WJjee7k+eCueeahOWQjue7p+e7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZSkgdGhpcy5yaGVhZFtwYS5pXSA9IHBhLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHByZS5yaWdodCA9IHBhLnJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYSA9IHBhLnJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/liJfooajnmoTmjIfpkojlj5jljJZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsW3Aual0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5LuOaGxbcC5qXeW8gOWni+aJvuWIsOaWsOe7k+eCueWcqOWQjOS4gOWIl+S4reeahOWJjempsee7k+eCue+8jOW5tuiuqWhsW3Aual3mjIflkJHlroNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGhsW3Aual07IHEgJiYgcS5pIDwgcC5pOyBxID0gcS5kb3duKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsW3Aual0gPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVhZFtwLmpdID09IHApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWFkW3Aual0gPSBobFtwLmpdID0gcC5kb3duO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobFtwLmpdLmRvd24gPSBwLmRvd247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYiA9IHBiLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmxldCBsaXN0cyA9IFtcclxuICAgIFsxLCA0LCA1XSxcclxuICAgIFsyLCAyLCAtMV0sXHJcbiAgICBbMSwgMSwgM10sXHJcbiAgICBbMywgMSwgMl1cclxuXTtcclxubGV0IGEgPSBuZXcgQ3Jvc3NMaXN0KCk7XHJcbmEuY3JlYXRlU01hdHJpeCg0LCA0LCA0LCBsaXN0cyk7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG5cclxubGV0IGxpc3RzMiA9IFtcclxuICAgIFsxLCA0LCAtNV0sXHJcbiAgICBbMiwgMywgMV0sXHJcbiAgICBbMSwgMSwgM10sXHJcbiAgICBbMywgMiwgMl1cclxuXTtcclxubGV0IGIgPSBuZXcgQ3Jvc3NMaXN0KCk7XHJcbmIuY3JlYXRlU01hdHJpeCg0LCA0LCA0LCBsaXN0czIpO1xyXG5jb25zb2xlLmxvZyhiKTtcclxuXHJcbmEuYWRkTWF0cml4KGIpO1xyXG5jb25zb2xlLmxvZyhhKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvQXJyYXkvQ3Jvc3NMaXN0LmpzXG4gKiovIiwiLyoqXHJcbiAqIOezu+aVsOefqemYteeahOS4ieWFg+e7hOmhuuW6j+ihqOWtmOWCqOihqOekulxyXG4gKi9cclxuXHJcbmNsYXNzIFRyaXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpLCBqLCBlbGVtKSB7XHJcbiAgICAgICAgLy8g6K+l6Z2e6Zu25YWD55qE6KGM5LiL5qCH5ZKM5YiX5LiL5qCHXHJcbiAgICAgICAgdGhpcy5pID0gaSB8fCAwO1xyXG4gICAgICAgIHRoaXMuaiA9IGogfHwgMDtcclxuICAgICAgICB0aGlzLmUgPSBlbGVtIHx8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUU01hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtdSwgbnUpIHtcclxuICAgICAgICAvLyDpnZ7pm7blhYPkuInlhYPnu4TooahcclxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgICAgICAvLyDnn6npmLXnmoTooYzmlbDvvIzliJfmlbBcclxuICAgICAgICB0aGlzLm11ID0gbXUgfHwgMDtcclxuICAgICAgICB0aGlzLm51ID0gbnUgfHwgMDtcclxuICAgIH1cclxuICAgIGFkZFRyaXBsZSAodHJpcGxlKSB7XHJcbiAgICAgICAgaWYgKHRyaXBsZSBpbnN0YW5jZW9mIFRyaXBsZSkge1xyXG4gICAgICAgICAgICBpZih0cmlwbGUuaSA+PSB0aGlzLm11KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tdSA9IHRyaXBsZS5pICsgMTtcclxuICAgICAgICAgICAgaWYodHJpcGxlLmogPj0gdGhpcy5udSlcclxuICAgICAgICAgICAgICAgIHRoaXMubnUgPSB0cmlwbGUuaiArIDE7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh0cmlwbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8g6YeH55So5LiJ5YWD57uE6KGo5a2Y5YKo6KGo56S677yM5rGC56iA55aP55+p6Zi155qE6L2s572u55+p6Zi1dFxyXG4gICAgLy8g5oyJ54WnYi5kYXRh5Lit5LiJ5YWD57uE55qE5qyh5bqP5L6d5qyh5ZyoYS5kYXRh5Lit5om+5Yiw55u45bqU55qE5LiJ5YWD57uE6L+b6KGM6L2s572uXHJcbiAgICB0cmFuc3Bvc2VTTWF0cml4ICgpIHtcclxuICAgICAgICBsZXQgdCA9IG5ldyBUU01hdHJpeCgpO1xyXG4gICAgICAgIHQubXUgPSB0aGlzLm51O1xyXG4gICAgICAgIHQubnUgPSB0aGlzLm11O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgcSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnU7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHRoaXMuZGF0YS5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbcF0uaiA9PT0gY29sKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmRhdGFbcSsrXSA9IG5ldyBUcmlwbGUodGhpcy5kYXRhW3BdLmosIHRoaXMuZGF0YVtwXS5pLCB0aGlzLmRhdGFbcF0uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgLy8g6YeH55So5LiJ5YWD57uE6KGo5a2Y5YKo6KGo56S677yM5rGC56iA55aP55+p6Zi155qE6L2s572u55+p6Zi1dFxyXG4gICAgLypcclxuICAgICDmjInnhadhLmRhdGHkuK3kuInlhYPnu4TnmoTmrKHluo/ov5vooYzovaznva7vvIzlubblsIbovaznva7lkI7nmoTkuInlhYPnu4Tnva7lhaVi5Lit5oGw5b2T55qE5L2N572u44CCXHJcbiAgICAg5aaC5p6c6IO96aKE5YWI56Gu5a6a55+p6Zi1TeS4reavj+S4gOWIl++8iOWNs1TkuK3mr4/kuIDooYzvvInnmoTnrKzkuIDkuKrpnZ7pm7blhYPlnKhiLmRhdGHkuK3lupTmnInnmoTkvY3nva7vvIxcclxuICAgICDpgqPkuYjlnKjlr7lhLmRhdGHkuK3nmoTkuInlhYPnu4Tkvp3mrKHlgZrovaznva7ml7bvvIzkvr/lj6/nm7TmjqXmlL7liLBiLmRhdGHkuK3mgbDlvZPnmoTkvY3nva7kuIrljrvjgIJcclxuICAgICDkuLrkuoblhbbpop3lrprov5nkupvkvY3nva7vvIzlnKjovaznva7liY3vvIzlupTlhYjmsYLlvpdN55qE5q+P5LiA5YiX5Lit6Z2e6Zu25YWD55qE5Liq5pWw77yM6L+b6ICM5rGC5b6X5q+P5LiA5YiX55qE56ys5LiA5Liq6Z2e6Zu25YWD5ZyoYi5kYXRh5Lit5bqU5pyJ55qE5L2N572u44CCXHJcbiAgICAg5Zyo5q2k77yM6ZyA6KaB6K6+bnVt5ZKMY3BvdOS4pOS4quWPmOmHj+OAgm51bVtjb2xd6KGo56S655+p6Zi1TeS4reesrGNvbOWIl+S4remdnumbtuWFg+eahOS4quaVsO+8jFxyXG4gICAgIGNwb3RbY29sXeaMh+ekuk3kuK3nrKxjb2zliJfnmoTnrKzkuIDkuKrpnZ7pm7blhYPlnKhiLmRhdGHkuK3nmoTmgbDlvZPkvY3nva7jgILmmL7nhLbmnInvvJpcclxuICAgICBjcG90WzBdID0gMTtcclxuICAgICBjcG90W2NvbF0gPSBjcG90W2NvbCAtIDFdICsgbnVtW2NvbCAtIDFdICAgIDIgPD0gY29sIDw9IGEubnVcclxuICAgICAqL1xyXG4gICAgZmFzdFRyYW5zcG9zZVNNYXRyaXgoKXtcclxuICAgICAgICBsZXQgdCA9IG5ldyBUU01hdHJpeCgpO1xyXG4gICAgICAgIHQubXUgPSB0aGlzLm51O1xyXG4gICAgICAgIHQubnUgPSB0aGlzLm11O1xyXG5cclxuICAgICAgICBpZih0aGlzLmRhdGEubGVuZ3RoKXtcclxuICAgICAgICAgICAgbGV0IG51bSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnU7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgbnVtW2NvbF0gPSAwO1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgKytudW1bdGhpcy5kYXRhW2ldLmpdOyAgLy8g5rGC55+p6Zi15Lit5q+P5LiA5YiX5ZCr6Z2e6Zu25YWD5Liq5pWwXHJcbiAgICAgICAgICAgIC8vIOaxguesrGNvbOWIl+S4reesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reeahOW6j+WPt1xyXG4gICAgICAgICAgICBsZXQgY3BvdCA9IFswXTtcclxuICAgICAgICAgICAgZm9yKGxldCBjb2wgPSAxOyBjb2wgPCB0aGlzLm51OyBjb2wrKylcclxuICAgICAgICAgICAgICAgIC8vIOS4iuS4gOWIl+S5i+WJjeeahOW6j+WPtyvkuIrkuIDliJfnmoTpnZ7pm7blhYPkuKrmlbAgPSDor6XliJfnmoTluo/lj7dcclxuICAgICAgICAgICAgICAgIGNwb3RbY29sXSA9IGNwb3RbY29sIC0gMV0gKyBudW1bY29sIC0gMV07XHJcbiAgICAgICAgICAgIGZvcihsZXQgcCA9IDA7IHAgPCB0aGlzLmRhdGEubGVuZ3RoOyBwKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbCA9IHRoaXMuZGF0YVtwXS5qO1xyXG4gICAgICAgICAgICAgICAgbGV0IHEgPSBjcG90W2NvbF07XHJcbiAgICAgICAgICAgICAgICB0LmRhdGFbcV0gPSBuZXcgVHJpcGxlKHRoaXMuZGF0YVtwXS5qLCB0aGlzLmRhdGFbcF0uaSwgdGhpcy5kYXRhW3BdLmUpO1xyXG4gICAgICAgICAgICAgICAgLy8g57uZ6K+l5YiX55qE5bqP5Y+3KzHvvIznlKjkvZznm7jlkIzliJfmlbDnmoTmg4XlhrVcclxuICAgICAgICAgICAgICAgICsrY3BvdFtjb2xdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxufVxyXG5cclxubGV0IGExID0gbmV3IFRyaXBsZSgxLCAyLCAxMik7XHJcbmxldCBhMiA9IG5ldyBUcmlwbGUoMSwgMywgOSk7XHJcbmxldCBhMyA9IG5ldyBUcmlwbGUoMywgMSwgLTMpO1xyXG5sZXQgYTQgPSBuZXcgVHJpcGxlKDMsIDYsIDE0KTtcclxubGV0IGE1ID0gbmV3IFRyaXBsZSg0LCAzLCAyNCk7XHJcbmxldCBhNiA9IG5ldyBUcmlwbGUoNSwgMiwgMTgpO1xyXG5sZXQgYTcgPSBuZXcgVHJpcGxlKDYsIDEsIDE1KTtcclxubGV0IGE4ID0gbmV3IFRyaXBsZSg2LCA0LCAtNyk7XHJcblxyXG5sZXQgbWF0cml4ID0gbmV3IFRTTWF0cml4KCk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTEpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGEyKTtcclxubWF0cml4LmFkZFRyaXBsZShhMyk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTQpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGE1KTtcclxubWF0cml4LmFkZFRyaXBsZShhNik7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTcpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGE4KTtcclxuXHJcbmNvbnNvbGUubG9nKG1hdHJpeC50cmFuc3Bvc2VTTWF0cml4KCkpO1xyXG5jb25zb2xlLmxvZyhtYXRyaXguZmFzdFRyYW5zcG9zZVNNYXRyaXgoKSk7XHJcblxyXG4vKlxyXG4g5LiJ5YWD57uE6aG65bqP6KGo5Y+I56ew5pyJ5bqP55qE5Y+M5LiL5qCH5rOV77yM5a6D55qE54m554K55piv77yM6Z2e6Zu25YWD5Zyo6KGo5Lit5oyJ6KGM5bqP5pyJ5bqP5a2Y5YKo77yM5Zug5q2k5L6/5LqO6L+b6KGM5L6d6KGM6aG65bqP5aSE55CG55qE55+p6Zi16L+Q566X44CCXHJcbiDnhLbogIzvvIzoi6XpnIDmjInooYzlj7flrZjlj5bmn5DkuIDooYznmoTpnZ7pm7blhYPvvIzliJnku47lpLTlvIDlp4vov5vooYzmn6Xmib7jgIJcclxuICovXHJcblxyXG4vKipcclxuICog6KGM6YC76L6R6ZO+5o6l55qE6aG65bqP6KGoXHJcbiAqXHJcbiAqIOS4uuS6huS+v+S6jumaj+acuuWtmOWPluS7u+aEj+S4gOihjOeahOmdnumbtuWFg++8jOWImemcgOefpemBk+avj+S4gOihjOeahOesrOS4gOS4qumdnumbtuWFg+WcqOS4ieWFg+e7hOihqOS4reeahOS9jee9ruOAglxyXG4gKiDkuLrmraTlj6/lsIblv6vpgJ/ovaznva7nn6npmLXnmoTnrpfms5XkuK3liJvlu7rnmoTvvIzmjIfnpLrigJzooYzigJ3kv6Hmga/nmoTovoXliqnmlbDnu4RjcG905Zu65a6a5Zyo56iA55aP55+p6Zi155qE5a2Y5YKo57uT5p6E5Lit44CCXHJcbiAqIOensOi/meenjeKAnOW4puihjOmTvuaOpeS/oeaBr+KAneeahOS4ieWFg+e7hOihqOS4uuihjOmAu+i+kemTvuaOpeeahOmhuuW6j+ihqFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJMU01hdHJpeCBleHRlbmRzIFRTTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnJwb3MgPSBbMF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOaxguefqemYteS5mOenr1EgPSBNICogTu+8jOmHh+eUqOihjOmAu+i+kemTvuaOpeWtmOWCqOihqOekulxyXG4gICAgICogQHBhcmFtIG5NYXRyaXhcclxuICAgICAqIEByZXR1cm5zIHtSTFNNYXRyaXh9XHJcbiAgICAgKi9cclxuICAgIG11bHRTTWF0cml4KG5NYXRyaXgpe1xyXG4gICAgICAgIGlmKHRoaXMubnUgIT09IG5NYXRyaXgubXUpIHRocm93IEVycm9yKCdudSBpcyBub3QgZXF1aXZhbGVudCB0byBtdScpO1xyXG5cclxuICAgICAgICAvLyDliJ3lp4vljJZRXHJcbiAgICAgICAgbGV0IHFNYXRyaXggPSBuZXcgUkxTTWF0cml4KHRoaXMubXUsIG5NYXRyaXgubnUpO1xyXG4gICAgICAgIC8vIFHmmK/pnZ7pm7bnn6npmLVcclxuICAgICAgICBpZih0aGlzLmRhdGEubGVuZ3RoICogbk1hdHJpeC5kYXRhLmxlbmd0aCAhPT0gMCl7XHJcbiAgICAgICAgICAgIC8vIOWkhOeQhk3nmoTmr4/kuIDooYxcclxuICAgICAgICAgICAgZm9yKGxldCBhcm93ID0gMDsgYXJvdyA8IHRoaXMubXU7IGFyb3crKyl7XHJcbiAgICAgICAgICAgICAgICAvLyDlvZPliY3ooYzlkITlhYPntKDntK/liqDlmajmuIXpm7ZcclxuICAgICAgICAgICAgICAgIGxldCBjdGVtcCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcU1hdHJpeC5ycG9zW2Fyb3ddID0gcU1hdHJpeC5kYXRhLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgdHAsIGNjb2w7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYXJvdyA8IHRoaXMubXUpXHJcbiAgICAgICAgICAgICAgICAgICAgdHAgPSB0aGlzLnJwb3NbYXJvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRwID0gdGhpcy5kYXRhLmxlbmd0aCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy/lr7nlvZPliY3ooYzkuK3mr4/kuIDkuKrpnZ7pm7blhYPmib7liLDlr7nlupTlhYPlnKhO5Lit55qE6KGM5Y+3XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHAgPSB0aGlzLnJwb3NbYXJvd107IHAgPCB0cDsgcCsrKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYnJvdyA9IHRoaXMuZGF0YVtwXS5qO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJyb3cgPCBuTWF0cml4Lm11KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gbk1hdHJpeC5ycG9zW2Jyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuTWF0cml4LmRhdGEubGVuZ3RoICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBxID0gbk1hdHJpeC5ycG9zW2Jyb3ddOyBxIDwgdDsgcSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5LmY56ev5YWD57Sg5ZyoUeS4reeahOW6j+WPt1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjY29sID0gbk1hdHJpeC5kYXRhW3FdLmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0ZW1wW2Njb2xdID0gKGN0ZW1wW2Njb2xdIHx8IDApICsgdGhpcy5kYXRhW3BdLmUgKiBuTWF0cml4LmRhdGFbcV0uZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5Y6L57yp5a2Y5YKo6K+l6KGM6Z2e6Zu25YWDXHJcbiAgICAgICAgICAgICAgICBmb3IoY2NvbCA9IDE7IGNjb2wgPCBxTWF0cml4Lm51OyBjY29sKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGN0ZW1wW2Njb2xdKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoKytxTWF0cml4LmRhdGEubGVuZ3RoID4gUkxTTWF0cml4Lk1BWFNJWkUpIHRocm93IEVycm9yKCdvdmVyZmxvdycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxTWF0cml4LmRhdGFbcU1hdHJpeC5kYXRhLmxlbmd0aCAtIDFdID0gbmV3IFRyaXBsZShhcm93LCBjY29sLCBjdGVtcFtjY29sXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcU1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICBfY2FsY1BvcyAoKXtcclxuICAgICAgICBsZXQgbnVtID0gW107XHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm51OyBjb2wrKylcclxuICAgICAgICAgICAgbnVtW2NvbF0gPSAwO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICsrbnVtW3RoaXMuZGF0YVtpXS5qXTsgIC8vIOaxguefqemYteS4reavj+S4gOWIl+WQq+mdnumbtuWFg+S4quaVsFxyXG4gICAgICAgIC8vIOaxguesrGNvbOWIl+S4reesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reeahOW6j+WPt1xyXG4gICAgICAgIGZvcihsZXQgY29sID0gMTsgY29sIDwgdGhpcy5udTsgY29sKyspXHJcbiAgICAgICAgICAgIC8vIOS4iuS4gOWIl+S5i+WJjeeahOW6j+WPtyvkuIrkuIDliJfnmoTpnZ7pm7blhYPkuKrmlbAgPSDor6XliJfnmoTluo/lj7dcclxuICAgICAgICAgICAgdGhpcy5ycG9zW2NvbF0gPSB0aGlzLnJwb3NbY29sIC0gMV0gKyBudW1bY29sIC0gMV07XHJcbiAgICB9XHJcbn1cclxuUkxTTWF0cml4Lk1BWFNJWkUgPSAxMDA7XHJcblxyXG5cclxubGV0IGIxID0gbmV3IFRyaXBsZSgxLCAxLCAzKTtcclxubGV0IGIyID0gbmV3IFRyaXBsZSgxLCAzLCA1KTtcclxubGV0IGIzID0gbmV3IFRyaXBsZSgyLCAyLCAtMSk7XHJcbmxldCBiNCA9IG5ldyBUcmlwbGUoMywgMSwgMik7XHJcblxyXG5sZXQgdDEgPSBuZXcgUkxTTWF0cml4KCk7XHJcbnQxLmFkZFRyaXBsZShiMSk7XHJcbnQxLmFkZFRyaXBsZShiMik7XHJcbnQxLmFkZFRyaXBsZShiMyk7XHJcbnQxLmFkZFRyaXBsZShiNCk7XHJcbnQxLl9jYWxjUG9zKCk7XHJcblxyXG5sZXQgYzEgPSBuZXcgVHJpcGxlKDEsIDIsIDIpO1xyXG5sZXQgYzIgPSBuZXcgVHJpcGxlKDIsIDEsIDEpO1xyXG5sZXQgYzMgPSBuZXcgVHJpcGxlKDMsIDEsIC0yKTtcclxubGV0IGM0ID0gbmV3IFRyaXBsZSgzLCAyLCA0KTtcclxuXHJcbmxldCB0MiA9IG5ldyBSTFNNYXRyaXgoKTtcclxudDIuYWRkVHJpcGxlKGMxKTtcclxudDIuYWRkVHJpcGxlKGMyKTtcclxudDIuYWRkVHJpcGxlKGMzKTtcclxudDIuYWRkVHJpcGxlKGM0KTtcclxudDIuX2NhbGNQb3MoKTtcclxuXHJcbnQxLm11bHRTTWF0cml4KHQyKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9BcnJheS9UU01hdHJpeC5qc1xuICoqLyIsIi8qKlxyXG4gKiDotavlpKvmm7zvvIhIdWZmbWFu77yJ5qCR77yM5Y+I56ew5pyA5LyY5qCR77yM5piv5LiA57G75bim5p2D6Lev5b6E6ZW/5bqm5pyA55+t55qE5qCR77yM5pyJ552A5bm/5rOb5bqU55So44CCXHJcbiAqXHJcbiAqIOS7juagkeS4reS4gOS4que7k+eCueWIsOWPpuS4gOS4que7k+eCueS5i+mXtOeahOWIhuaUr+aehOaIkOi/meS4pOS4que7k+eCueS5i+mXtOeahOi3r+W+hO+8jOi3r+W+hOS4iueahOWIhuaUr+aVsOebruensOS9nOi3r+W+hOmVv+W6puOAglxyXG4gKiDmoJHnmoTot6/lvoTplb/luqbmmK/ku47moJHmoLnliLDmr4/kuIDkuKrnu5PngrnnmoTot6/lvoTkuYvlkozjgIJcclxuICog57uT54K555qE5bim5p2D6Lev5b6E6ZW/5bqm5Li65LuO6K+l57uT54K55Yiw5qCR5qC55LmL6Ze055qE6Lev5b6E6ZW/5bqm5LiO57uT54K55LiK5p2D55qE5LmY56ev44CC5qCR55qE5bim5p2D6Lev5b6E6ZW/5bqm5Li65qCR5Lit5omA5pyJ5Y+25a2Q57uT54K555qE5bim5p2D6Lev5b6E6ZW/5bqm5LmL5ZKM44CCXHJcbiAqXHJcbiAqIOaehOmAoOi1q+Wkq+abvOagkeeahOatpemqpO+8mlxyXG4gKiDvvIgx77yJ5qC55o2u57uZ5a6a55qEbuS4quadg+WAvHt3MSx3MiwuLi53bn3mnoTmiJBu5qO15LqM5Y+J5qCR55qE6ZuG5ZCIRiA9IHtUMSxUMiwuLi5Ubn3vvIzlhbbkuK3mr4/mo7Xkuozlj4nmoJFUaeS4reWPquacieS4gOS4quW4puadg+S4undp55qE5qC557uT54K577yM5YW25bem5Y+z5a2Q5qCR5Z2H56m644CCXHJcbiAqIO+8iDLvvInlnKhG5Lit6YCJ5Y+W5Lik5qO15qC557uT54K555qE5p2D5YC85pyA5bCP55qE5qCR5L2c5Li65bem5Y+z5a2Q5qCR5p6E6YCg5LiA5qO15paw55qE5LqM5Y+J5qCR77yM5LiU572u5paw55qE5LqM5Y+J5qCR55qE5qC557uT54K555qE5p2D5YC85Li65YW25bem5Y+z5a2Q5qCR5LiK5qC557uT54K555qE5p2D5YC85LmL5ZKM44CCXHJcbiAqIO+8iDPvvInlnKhG5Lit5Yig6Zmk6L+Z5Lik5qO15qCR77yM5ZCM5pe25bCG5paw5b6X5Yiw55qE5LqM5Y+J5qCR5Yqg5YWlRuS4reOAglxyXG4gKiDvvIg077yJ6YeN5aSN77yIMu+8ieWSjO+8iDPvvInvvIznm7TliLBG5Y+q5ZCr5LiA5qO15qCR5Li65q2i44CC6L+Z5qO15qCR5L6/5piv6LWr5aSr5pu85qCR44CCXHJcbiAqL1xyXG4vKlxyXG7otavlpKvmm7znvJbnoIFcclxuaHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS8lRTklOUMlOEQlRTUlQTQlQUIlRTYlOUIlQkMlRTclQkMlOTYlRTclQTAlODFcclxuXHJcbuWBh+iuvueUteaKpemcgOS8oOmAgeeahOeUteaWh+S4uuKAnEEgQiBBIEMgQyBEIEHigJ3vvIzlroPlj6rmnIk056eN5a2X56ym5Y+q6ZyA5Lik5Liq5a2X56ym5Liy5L6/5Y+v5YiG6L6o44CC5YGH6K6+QSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAwLDAxLDEw5ZKMMTHvvIzliJnkuIrov7A35Liq5a2X56ym55qE55S15paH5L6/5Li64oCcMDAwMTAwMTAxMDExMDDigJ3vvIzlr7nmlrnmjqXmlLbml7bvvIzlj6/mjInkuozkvY3kuIDliIbov5vooYzor5HnoIHjgIJcclxu5Zyo5Lyg6YCB55S15paH5pe277yM5biM5pyb5oC76ZW/5bC95Y+v6IO95Zyw55+t44CC5aaC5p6c5a+55q+P5Liq5a2X56ym6K6+6K6h6ZW/5bqm5LiN562J55qE57yW56CB77yM5LiU6K6p55S15paH5Lit5Ye6546w5qyh5pWw6L6D5aSa55qE5a2X56ym6YeH55So5bC95Y+v6IO955+t55qE57yW56CB77yM5YiZ5Lyg6YCB55S15paH55qE5oC76ZW/5L6/5Y+v5YeP5bCR44CCXHJcbuWmguaenOa2ieWPikEsQixDLETnmoTnvJbnoIHliIbliKvkuLowLDAwLDHlkowwMe+8jOWImeS4iui/sDfkuKrlrZfnrKbnmoTnlLXmloflj6/ovazmjaLmiJDmgLvplb/kuLo555qE5a2X56ym5Liy4oCcMDAwMDExMDEw4oCd44CC5L2G5piv77yM6L+Z5qC355qE55S15paH5peg5rOV57+76K+R77yM5Zug5Li65Y+v5pyJ5aSa56eN6K+R5rOV44CCXHJcbuWboOatpO+8jOiLpeimgeiuvuiuoemVv+efreS4jeetieeahOe8luegge+8jOWImeW/hemhu+aYr+S7u+aEj+S4quWtl+espueahOe8lueggemDveS4jeaYr+WPpuS4gOS4quWtl+espue8lueggeeahOWJjee8gO+8jOi/meenjee8lueggeensOS9nOWJjee8gOe8lueggeOAglxyXG7lj6/liKnnlKjkuozlj4nmoJHmnaXorr7orqHkuozov5vliLbnmoTliY3nvIDnvJbnoIHjgILlgYforr7mnInkuIDmo7Xkuozlj4nmoJHvvIzlhbY05Liq5Y+25a2Q57uT54K55YiG5Yir6KGo56S6QSxCLEMsROi/mTTkuKrlrZfnrKbvvIzkuJTnuqblrprlt6bliIbmlK/ooajnpLrlrZfnrKbigJww4oCd77yM5Y+z5YiG5pSv6KGo56S65a2X56ym4oCcMeKAne+8jOWImeWPr+S7peS7juaguee7k+eCueWIsOWPtuWtkOe7k+eCueeahOi3r+W+hOS4iuWIhuaUr+Wtl+espue7hOaIkOeahOWtl+espuS4suS9nOS4uuivpeWPtuWtkOe7k+eCueWtl+espueahOe8lueggeOAguaJgOW+l+S6jOi/m+WItuWJjee8gOe8lueggeWIhuWIq+S4ujAsMTAsMTEwLDExMS5cclxu6K6+6K6h55S15paH5oC76ZW/5pyA55+t55qE5LqM6L+b5Yi25YmN57yA57yW56CB5Y2z5LulbuenjeWtl+espuWHuueOsOeahOmikeeOh+S9nOadg+OAglxyXG4gKi9cclxuXHJcbi8vIOi1q+Wkq+abvOagkeWSjOi1q+Wkq+abvOe8lueggeeahOWtmOWCqOe7k+aehFxyXG5mdW5jdGlvbiBIdWZmbWFuTm9kZSh3ZWlnaHQsIHBhcmVudCwgbGVmdENoaWxkLCByaWdodENoaWxkKSB7XHJcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodCB8fCAwO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgMDtcclxuICAgIHRoaXMubGVmdENoaWxkID0gbGVmdENoaWxkIHx8IDA7XHJcbiAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkIHx8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGh1ZmZNYW5Db2Rpbmcod2VpZ2h0cykge1xyXG4gICAgbGV0IG4gPSB3ZWlnaHRzLmxlbmd0aDtcclxuICAgIGlmIChuIDwgMSkgcmV0dXJuO1xyXG5cclxuICAgIGxldCBodWZmbWFuVHJlZSA9IGJ1aWxkSHVmZm1hblRyZWUod2VpZ2h0cywgbik7XHJcblxyXG4gICAgLy8g5LuO5Y+25a2Q5Yiw5qC56YCG5ZCR5rGC5q+P5Liq5a2X56ym55qE6LWr5aSr5pu857yW56CBXHJcbiAgICBsZXQgaGMgPSBjYWxjSHVmZm1hbkNvZGUoaHVmZm1hblRyZWUsIG4pO1xyXG5cclxuICAgIHJldHVybiBbaHVmZm1hblRyZWUsIGhjXTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNhbGNIdWZmbWFuQ29kZShodWZmbWFuVHJlZSwgbikge1xyXG4gICAgLy8g5LuO5Y+25a2Q5Yiw5qC56YCG5ZCR5rGC5q+P5Liq5a2X56ym55qE6LWr5aSr5pu857yW56CBXHJcbiAgICBsZXQgaGMgPSBbXTtcclxuICAgIGxldCBjZCA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBuIC0gMTtcclxuICAgICAgICBmb3IgKGxldCBjID0gaSwgZiA9IGh1ZmZtYW5UcmVlW2ldLnBhcmVudDsgZiAhPSAwOyBjID0gZiwgZiA9IGh1ZmZtYW5UcmVlW2ZdLnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaHVmZm1hblRyZWVbZl0ubGVmdENoaWxkID09IGMpIGNkWy0tc3RhcnRdID0gJzAnO1xyXG4gICAgICAgICAgICBlbHNlIGNkWy0tc3RhcnRdID0gJzEnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaGNbaV0gPSBzdHJDb3B5KGNkLCBzdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhjO1xyXG59XHJcblxyXG4vLyDliJvlu7rkuIDmo7Xlj7blrZDnu5PngrnmlbDkuLpu55qESHVmZm1hbuagkVxyXG5mdW5jdGlvbiBidWlsZEh1ZmZtYW5UcmVlKHdlaWdodHMsIG4pIHtcclxuICAgIG4gPSBuIHx8IHdlaWdodHMubGVuZ3RoO1xyXG4gICAgbGV0IG0gPSAyICogbiAtIDE7XHJcbiAgICBsZXQgaHVmZm1hblRyZWUgPSBbXTtcclxuXHJcbiAgICAvLyDliJ3lp4vljJZcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICBodWZmbWFuVHJlZVtpXSA9IG5ldyBIdWZmbWFuTm9kZSh3ZWlnaHRzW2ldLCAwLCAwLCAwKTtcclxuICAgIGZvciAoOyBpIDwgbTsgaSsrKVxyXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldID0gbmV3IEh1ZmZtYW5Ob2RlKDAsIDAsIDAsIDApO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBuOyBpIDwgbTsgaSsrKSB7XHJcbiAgICAgICAgLy8g5ZyoSFRbMS4uaS0xXemAieaLqXBhcmVudOS4ujDkuJR3ZWlnaHTmnIDlsI/nmoTkuKTkuKrnu5PngrnvvIzov5Tlm57lhbbluo/lj7fkuLpbczEsIHMyXVxyXG4gICAgICAgIGxldCByZXQgPSBzZWxlY3QoaHVmZm1hblRyZWUsIGkpO1xyXG4gICAgICAgIGxldCBzMSA9IHJldFswXTtcclxuICAgICAgICBsZXQgczIgPSByZXRbMV07XHJcbiAgICAgICAgaHVmZm1hblRyZWVbczFdLnBhcmVudCA9IGk7XHJcbiAgICAgICAgaHVmZm1hblRyZWVbczJdLnBhcmVudCA9IGk7XHJcbiAgICAgICAgaHVmZm1hblRyZWVbaV0ubGVmdENoaWxkID0gczE7XHJcbiAgICAgICAgaHVmZm1hblRyZWVbaV0ucmlnaHRDaGlsZCA9IHMyO1xyXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLndlaWdodCA9IGh1ZmZtYW5UcmVlW3MxXS53ZWlnaHQgKyBodWZmbWFuVHJlZVtzMl0ud2VpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBodWZmbWFuVHJlZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyQ29weShzdHIsIHN0YXJ0KSB7XHJcbiAgICBsZXQgcyA9ICcnO1xyXG4gICAgZm9yICg7IHN0cltzdGFydF07IHN0YXJ0KyspIHtcclxuICAgICAgICBzICs9IHN0cltzdGFydF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcztcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0KGh1ZmZtYW5UcmVlLCBsZW4pIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBsZXQgbm9kZSA9IGh1ZmZtYW5UcmVlW2ldO1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAhPT0gMCkgY29udGludWU7XHJcblxyXG4gICAgICAgIGlmIChyZXQubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICByZXQucHVzaChpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBodWZmbWFuVHJlZVtyZXRbMF1dLndlaWdodCA+IGh1ZmZtYW5UcmVlW3JldFsxXV0ud2VpZ2h0XHJcbiAgICAgICAgICAgICAgICA/IDAgOiAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5vZGUud2VpZ2h0IDwgaHVmZm1hblRyZWVbcmV0W2luZGV4XV0ud2VpZ2h0KVxyXG4gICAgICAgICAgICAgICAgcmV0W2luZGV4XSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXRbMF0gPiByZXRbMV0pIHtcclxuICAgICAgICBsZXQgdGVtcCA9IHJldFswXTtcclxuICAgICAgICByZXRbMF0gPSByZXRbMV07XHJcbiAgICAgICAgcmV0WzFdID0gdGVtcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygnLS0tLS0tLWh1ZmZtYW4gY29kaW5nIDE6LS0tLS0tJyk7XHJcbmNvbnNvbGUubG9nKGh1ZmZNYW5Db2RpbmcoWzUsIDI5LCA3LCA4LCAxNCwgMjMsIDMsIDExXSkpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZy5qc1xuICoqLyIsIi8qKlxyXG4gKiDlub/kuYnooahcclxuICpcclxuICog5bm/5LmJ6KGo5piv57q/5oCn6KGo55qE5o6o5bm/44CC5bm/5rOb55So5LqO5Lq65bel5pm66IO955qE6KGo5aSE55CG6K+t6KiATGlzcO+8jOaKiuW5v+S5ieihqOS9nOS4uuWfuuacrOeahOaVsOaNrue7k+aehOOAglxyXG4gKiDlub/kuYnooajkuIDoiKzorrDkvZzvvJpcclxuICogICAgICBMUyA9IChhMSwgYTIsIC4uLiwgYW4pXHJcbiAqIExT5piv5bm/5LmJ6KGo55qE5ZCN56ew77yMbuaYr+Wug+eahOmVv+W6pu+8jGFp5Y+v5Lul5piv5Y2V5Liq5YWD57Sg77yM5Lmf5Y+v5Lul5piv5bm/5LmJ6KGo77yM5YiG5Yir56ew5Li65bm/5LmJ6KGoTFPnmoTljp/lrZDlkozlrZDooajjgILkuaDmg6/kuIrvvIznlKjlpKflhpnlrZfmr43ooajnpLrlub/kuYnooajnmoTlkI3np7DvvIzlsI/lhpnlrZfmr43ooajnpLrljp/lrZDjgILlvZPlub/kuYnooahMU+mdnuepuuaXtu+8jOensOesrOS4gOS4quWFg+e0oGEx5Li6TFPnmoTooajlpLTvvIznp7DlhbbkvZnlhYPntKDnu4TmiJDnmoTooagoYTIsIGEzLCAuLi4sIGFuKeaYr0xT55qE6KGo5bC+44CCXHJcbiAqXHJcbiAqIOS4i+mdouWIl+S4vuS4gOS6m+W5v+S5ieihqOeahOS+i+WtkO+8mlxyXG4gKiAxLkEgPSAoKSAtLS0tIEHmmK/kuIDkuKrnqbrooajvvIzlroPnmoTplb/luqbkuLow44CCXHJcbiAqIDIuQiA9IChlKSAtLS0tIOWIl+ihqELlj6rmnInkuIDkuKrljp/lrZBl77yMQueahOmVv+W6puS4ujHjgIJcclxuICogMy5DID0gKGEsIChiLCBjLCBkKSkgLS0tLSDliJfooahD55qE6ZW/5bqm5Li6Mu+8jOS4pOS4quWFg+e0oOWIhuWIq+S4uuWOn+WtkGHlkozlrZDooagoYiwgYywgZCnjgIJcclxuICogNC5EID0gKEEsIEIsIEMpIC0tLS0g5YiX6KGoROeahOmVv+W6puS4ujMsM+S4quWFg+e0oOmDveaYr+WIl+ihqOOAguaYvuekuu+8jOWwhuWtkOihqOeahOWAvOS7o+WFpeWQju+8jOWImeaciUQgPSAoKCksIChlKSwgKGEsIChiLCBjLCBkKSkp44CCXHJcbiAqIDUuRSA9IChhLCBFKSAtLS0tIOi/meaYr+S4gOS4qumAkuW9kueahOihqO+8jOWug+eahOmVv+W6puS4ujIuReebuOW9k+S6juS4gOS4quaXoOmZkOeahOWIl+ihqEUgPSAoYSwgKGEsIChhLCAuLi4pKSnjgIJcclxuICpcclxuICogMe+8ieWIl+ihqOeahOWFg+e0oOWPr+S7peaYr+WtkOihqO+8jOiAjOWtkOihqOeahOWFg+e0oOi/mOWPr+S7peaYr+WtkOihqOOAgueUseatpO+8jOWIl+ihqOaYr+S4gOS4quWkmuWxguasoeeahOe7k+aehO+8jOWPr+S7peeUqOWbvuW9ouixoeWcsOihqOekuuOAglxyXG4gKiAyKeWIl+ihqOWPr+S4uuWFtuWug+WIl+ihqOaJgOWFseS6q+OAguWIl+ihqEHvvIxC5ZKMQ+S4ukTnmoTlrZDooajvvIzliJnlnKhE5Lit5Y+v5Lul5LiN5b+F5YiX5Ye65a2Q6KGo55qE5YC844CCXHJcbiAqIDPvvInliJfooajlj6/ku6XmmK/kuIDkuKrpgJLlvZLnmoTooajvvIzljbPliJfooajkuZ/lj6/ku6XmmK/lhbbmnKzouqvnmoTkuIDkuKrlrZDooajjgILkvovlpoLliJfooahF44CCXHJcbiAqXHJcbiAqIOS7u+S9leS4gOS4qumdnuepuuWIl+ihqOWFtuihqOWktOWPr+iDveaYr+WOn+WtkO+8jOS5n+WPr+iDveaYr+WIl+ihqO+8jOiAjOWFtuihqOWwvuW/heWumuS4uuWIl+ihqOOAglxyXG4gKlxyXG4gKi9cclxuXHJcbi8qXHJcbiDlub/kuYnooajnmoTpgJLlvZLnrpfms5VcclxuXHJcbiDpgJLlvZLlrprkuYnnmoTlvZLnurPpobnmj4/ov7DkuoblpoLkvZXlrp7njrDku47lvZPliY3nirbmgIHliLDnu4jnu5PnirbmgIHnmoTovazljJbjgIJcclxuXHJcbiDnlLHkuo7pgJLlvZLlh73mlbDnmoTorr7orqHnlKjnmoTmmK/lvZLnurPmgJ3nu7TnmoTmlrnms5XvvIzliJnlnKjorr7orqHpgJLlvZLlh73mlbDml7bvvIzlupTms6jmhI/vvJpcclxuIO+8iDHvvInpppblhYjlupTkuablhpnlh73mlbDnmoTpppbpg6jlkozop4TmoLzor7TmmI7vvIzkuKXmoLzlrprkuYnlh73mlbDnmoTlip/og73lkozmjqXlj6PvvIjpgJLlvZLosIPnlKjnmoTnlYzpnaLvvInvvIzlr7nmsYLnsr7lh73mlbDkuK3miYDlvpfnmoTlkozljp/pl67popjmgKfotKjnm7jlkIznmoTlrZfpl67popjvvIzlj6ropoHmjqXlj6PkuIDoh7TvvIzkvr/lj6/ov5vooYzpgJLlvZLosIPnlKjjgIJcclxuIO+8iDLvvInlr7nlh73mlbDkuK3nmoTmr4/kuIDkuKrpgJLlvZLosIPnlKjpg73nnIvmiJDlj6rmmK/kuIDkuKrnroDljZXnmoTmk43kvZzvvIzlj6ropoHmjqXlj6PkuIDoh7TvvIzlv4Xog73lrp7njrDop4TmoLzor7TmmI7kuK3lrprkuYnnmoTlip/og73vvIzliIflv4zmg7PlvpflpKrmt7HlpKrov5zjgIJcclxuICovXHJcblxyXG4vKlxyXG4g5rGC5bm/5LmJ6KGo55qE5rex5bqmXHJcblxyXG4g5bm/5LmJ6KGo55qE5rex5bqm5a6a5LmJ5Li65bm/5LmJ6KGo5Lit5ous5byn55qE6YeN5pWw77yM5piv5bm/5LmJ6KGo55qE5LiA56eN6YeP5bqm44CCXHJcbiDorr7pnZ7nqbrlub/kuYnooajkuLo6XHJcbiBMUyA9IChhMSwgYTIsIC4uLiwgYW4pXHJcblxyXG4g5YW25LitYWkoaSA9IDEsIDIsIC4uLiwgbinmiJbkuLrljp/lrZDmiJbkuLpMU+eahOWtkOihqO+8jOWImeaxgkxT55qE5rex5bqm5Y+v5YiG6Kej5Li6buS4quWtkOmXrumimO+8jOavj+S4quWtkOmXrumimOS4uuaxgmFp55qE5rex5bqm77yM6IulYWnmmK/ljp/lrZDvvIzliJnnlLHlrprkuYnlhbbmt7HluqbkuLrpm7bvvIzoi6VhaeaYr+W5v+S5ieihqO+8jOWImemAkuW9kuWkhOeQhu+8jOiAjExT55qE5rex5bqm5Li65ZCEYWkoaSA9IDEsIDIsIC4uLiwgbinnmoTmt7HluqbmnIDlpKflgLzliqAxLuepuuihqOS5n+aYr+W5v+S5ieihqO+8jOS4lOa3seW6puS4ujEuXHJcblxyXG4g5bm/5LmJ6KGo55qE5rex5bqmREVQVEgoTFMp55qE6YCS5b2S5a6a5LmJ5Li677yaXHJcbiDln7rmnKzpobnvvJogICAgREVQVEgoTFMpID0gMSAgIOW9k0xT5Li656m66KGo5pe2XHJcbiBERVBUSChMUykgPSAwICAg5b2TTFPkuLrljp/lrZDml7ZcclxuIOW9kue6s+mhue+8miAgICBERVBUSChMUykgPSAxICsgTUFYe0RFUFRIKGFpKX0gIDEgPD0gaSA8PSBuXHJcbiAqL1xyXG5cclxuY29uc3QgQVRPTSA9IFN5bWJvbCgpO1xyXG5jb25zdCBMSVNUID0gU3ltYm9sKCk7XHJcblxyXG5sZXQgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuLy8g5L2/55So6ZO+6Zif5YiXXHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZS5qcyc7XHJcblxyXG4vLyDlub/kuYnooajnmoTlpLTlsL7pk77ooajlrZjlgqjooajnpLpcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR0xOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgLy8g5YWs5YWx6YOo5YiG77yM55So5LqO5Yy65YiG5Y6f5a2Q57uT54K55ZKM6KGo57uT54K5XHJcbiAgICAgICAgdGhpcy50YWcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIGF0b23mmK/ljp/lrZDnu5PngrnnmoTlgLzln59cclxuICAgICAgICB0aGlzLmF0b20gPSBudWxsO1xyXG4gICAgICAgIC8vIHB0cuaYr+ihqOe7k+eCueeahOaMh+mSiOWfn1xyXG4gICAgICAgIHRoaXMucHRyID0ge1xyXG4gICAgICAgICAgICAvLyBwdHIuaHDlkoxwdHIudHDliIbliKvmjIflkJHooajlpLTlkozooajlsL5cclxuICAgICAgICAgICAgaHA6IG51bGwsXHJcbiAgICAgICAgICAgIHRwOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDph4fnlKjlpLTlsL7pk77ooajlrZjlgqjnu5PmnoTvvIzmsYLlub/kuYnooajnmoTmt7HluqZcclxuICAgIGRlcHRoICgpe1xyXG4gICAgICAgIHJldHVybiBnZXREZXB0aCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDlpI3liLblub/kuYnooahcclxuICAgIGNvcHlMaXN0IChnTGlzdCkge1xyXG4gICAgICAgIGdMaXN0LnRhZyA9IHRoaXMudGFnO1xyXG5cclxuICAgICAgICBpZiAodGhpcy50YWcgPT09IEFUT00pIHtcclxuICAgICAgICAgICAgZ0xpc3QuYXRvbSA9IHRoaXMuYXRvbTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdHIuaHApIHtcclxuICAgICAgICAgICAgICAgIGdMaXN0LnB0ci5ocCA9IG5ldyBHTE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyLmhwLmNvcHlMaXN0KGdMaXN0LnB0ci5ocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucHRyLnRwKSB7XHJcbiAgICAgICAgICAgICAgICBnTGlzdC5wdHIudHAgPSBuZXcgR0xOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ci50cC5jb3B5TGlzdChnTGlzdC5wdHIudHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOmHh+eUqOWktOWwvumTvuihqOWtmOWCqOe7k+aehO+8jOeUseW5v+S5ieihqOeahOS5puWGmeW9ouW8j+S4suWIm+W7uuW5v+S5ieihqFxyXG4gICAgY3JlYXRlR0xpc3QgKHN0cmluZykge1xyXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XHJcblxyXG4gICAgICAgIC8vIOWIm+W7uuWNleWOn+WtkOW5v+S5ieihqFxyXG4gICAgICAgIGxldCBxO1xyXG4gICAgICAgIGlmIChpc1dvcmQoc3RyaW5nKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhZyA9IEFUT007XHJcbiAgICAgICAgICAgIHRoaXMuYXRvbSA9IHN0cmluZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRhZyA9IExJU1Q7XHJcbiAgICAgICAgICAgIGxldCBwID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIOiEseWkluWxguaLrOWPt1xyXG4gICAgICAgICAgICBsZXQgc3ViID0gc3RyaW5nLnN1YnN0cigxLCBzdHJpbmcubGVuZ3RoIC0gMik7XHJcblxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaHN1YjtcclxuICAgICAgICAgICAgICAgIGxldCBuID0gc3ViLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGxldCBjaDtcclxuXHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzdWJbaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gJygnKSArK2s7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gJyknKSAtLWs7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgbiAmJiAoY2ggIT0gJywnIHx8IGsgIT0gMCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGnkuLrnrKzkuIDkuKrpgJflj7fliIbpmpTntKLlvJVcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhzdWIgPSBzdWIuc3Vic3RyKDAsIGkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWIuc3Vic3RyKGksIG4gLSBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5pyA5ZCO5LiA57uEXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhzdWIgPSBzdWI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaHN1YiA9PT0gJygpJykgcC5wdHIuaHAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8g5Yib5bu66KGo5aS057uT54K5XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwLnB0ci5ocCA9IG5ldyBHTE5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnB0ci5ocC5jcmVhdGVHTGlzdChoc3ViKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBxID0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyDliJvlu7rooajlsL7nu5PngrlcclxuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gbmV3IEdMTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAudGFnID0gTElTVDtcclxuICAgICAgICAgICAgICAgICAgICBxLnB0ci50cCA9IHA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHN1Yik7XHJcblxyXG4gICAgICAgICAgICBxLnB0ci50cCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlcXVhbChnTGlzdDEsIGdMaXN0Mikge1xyXG4gICAgICAgIC8vIOepuuihqOaXtuebuOetieeahFxyXG4gICAgICAgIGlmICghZ0xpc3QxICYmICFnTGlzdDIpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChnTGlzdDEudGFnID09PSBBVE9NICYmIGdMaXN0Mi50YWcgPT09IEFUT00gJiYgZ0xpc3QxLmF0b20gPT09IGdMaXN0Mi5hdG9tKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKGdMaXN0MS50YWcgPT09IExJU1QgJiYgZ0xpc3QyLnRhZyA9PT0gTElTVCkge1xyXG4gICAgICAgICAgICAvLyDooajlpLTooajlsL7pg73nm7jnrYlcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwoZ0xpc3QxLnB0ci5ocCwgZ0xpc3QyLnB0ci5ocCkgJiYgdGhpcy5lcXVhbChnTGlzdDEucHRyLnRwLCBnTGlzdDIucHRyLnRwKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6YCS5b2S6YCG6L2s5bm/5LmJ6KGoXHJcbiAgICByZXZlcnNlKCkge1xyXG4gICAgICAgIGxldCBwdHIgPSBbXTtcclxuICAgICAgICAvLyDlvZNB5LiN5Li65Y6f5a2Q5LiU6KGo5bC+6Z2e56m65pe25omN6ZyA6YCG6L2sXHJcbiAgICAgICAgaWYgKHRoaXMudGFnID09PSBMSVNUICYmIHRoaXMucHRyLnRwKSB7XHJcbiAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCwgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDpgIbovazlkITlrZDooahcclxuICAgICAgICAgICAgICAgIGlmIChwLnB0ci5ocCkgcC5wdHIuaHAucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHB0cltpXSA9IHAucHRyLmhwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDph43mlrDmjInpgIbluo/mjpLliJflkITlrZDooajnmoTpobrluo9cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cClcclxuICAgICAgICAgICAgICAgIHAucHRyLmhwID0gcHRyWy0taV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBsZXQgc3RyID0gJyc7XHJcbiAgICAgICAgaWYgKHRoaXMgPT0gZ2xvYmFsIHx8IHRoaXMgPT0gbnVsbCkgc3RyID0gJygpJztcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnRhZyA9PT0gQVRPTSkgc3RyID0gdGhpcy5hdG9tOyAgLy8g5Y6f5a2QXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnKCc7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy50b1N0cmluZy5jYWxsKHAucHRyLmhwKTtcclxuICAgICAgICAgICAgICAgIGlmIChwLnB0ci50cCkgc3RyICs9ICcsICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyICs9ICcpJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5oyJ5bGC5bqP6L6T5Ye65bm/5LmJ6KGoXHJcbiAgICAvLyDlsYLluo/pgY3ljobnmoTpl67popjvvIzkuIDoiKzpg73mmK/lgJ/liqnpmJ/liJfmnaXlrozmiJDnmoTvvIzmr4/mrKHku47pmJ/lpLRcclxuICAgIC8vIOWPluWHuuS4gOS4quWFg+e0oOeahOWQjOaXtuaKiuWug+S4i+S4gOWxgueahOWtqeWtkOaPkuWFpemYn+Wwvu+8jOi/meaYr+WxguW6j+mBjeWOhueahOWfuuacrOaAneaDs1xyXG4gICAgb3JkZXJQcmludCAoKXtcclxuICAgICAgICBsZXQgcXVldWUgPSBbXTtcclxuICAgICAgICBmb3IobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApIHF1ZXVlLnB1c2gocCk7XHJcblxyXG4gICAgICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIGxldCByID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYoci50YWcgPT09IEFUT00pIGNvbnNvbGUubG9nKHIuYXRvbSk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yKHIgPSByLnB0ci5ocDsgcjsgciA9IHIucHRyLnRwKVxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb3JkZXJQcmludDIgKCl7XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCkgcXVldWUuZW5RdWV1ZShwKTtcclxuXHJcbiAgICAgICAgd2hpbGUocXVldWUuc2l6ZSl7XHJcbiAgICAgICAgICAgIGxldCByID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgICAgICBpZihyLnRhZyA9PT0gQVRPTSkgY29uc29sZS5sb2coci5hdG9tKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IociA9IHIucHRyLmhwOyByOyByID0gci5wdHIudHApXHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8g5bm/5LmJ6KGo55qE5omp5bGV57q/5oCn6ZO+6KGo5a2Y5YKo6KGo56S6XHJcbmNsYXNzIEdMTm9kZTIge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICAvLyDlhazlhbHpg6jliIbvvIznlKjkuo7ljLrliIbljp/lrZDnu5Pngrnlkozooajnu5PngrlcclxuICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8g5Y6f5a2Q57uT54K555qE5YC85Z+fXHJcbiAgICAgICAgdGhpcy5hdG9tID0gbnVsbDtcclxuICAgICAgICAvLyDooajnu5PngrnnmoTooajlpLTmjIfpkohcclxuICAgICAgICB0aGlzLmhwID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8g55u45b2T5LqO57q/5oCn6ZO+6KGo55qEbmV4dO+8jOaMh+WQkeS4i+S4gOS4quWFg+e0oOe7k+eCuVxyXG4gICAgICAgIHRoaXMudHAgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREZXB0aChnTGlzdCkge1xyXG4gICAgaWYgKCFnTGlzdCkgcmV0dXJuIDE7XHJcbiAgICBlbHNlIGlmIChnTGlzdC50YWcgPT09IEFUT00pIHJldHVybiAwO1xyXG5cclxuICAgIGxldCBtID0gZ2V0RGVwdGgoZ0xpc3QucHRyLmhwKSArIDE7XHJcbiAgICBsZXQgbiA9IGdldERlcHRoKGdMaXN0LnB0ci50cCk7XHJcblxyXG4gICAgcmV0dXJuIG0gPiBuID8gbSA6IG47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzV29yZChzdHIpe1xyXG4gICAgcmV0dXJuIC9eW1xcdy1dKyQvLnRlc3Qoc3RyKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiBt5YWD5aSa6aG55byP6KGo56S6XHJcblxyXG4g5aaC5p6c55So57q/5oCn6KGo5p2l6KGo56S6LOWImeavj+S4quaVsOaNruWFg+e0oOmcgOimgW0rMeS4quaVsOaNrumhue+8jOS7peWtmOWCqOS4gOS4quezu+aVsOWSjG3kuKrmjIfmlbDlgLzvvIzov5nlsIbkuqfnlJ/kuKTkuKrpl67popjjgIJcclxuIOS4gOaYr+aXoOiuuuWkmumhueW8j+S4reWQhOmhueeahOWPmOWFg+aVsOaYr+WkmuaYr+Wwke+8jOiLpemDveaMiW3kuKrlj5jlhYPliIbphY3lrZjlgqjnqbrpl7TvvIzliJnlsIbpgKDmiJDmtarotLnvvJvlj43kuYvvvIzoi6XmjInlkITpobnlrp7pmYXnmoTlj5jlhYPmlbDliIbphY3lrZjlgqjnqbrpl7TvvIzlsLHkvJrpgKDmiJDnu5PngrnnmoTlpKflsI/kuI3ljIDvvIznu5nmk43kvZzluKbmnaXkuI3kvr/jgILkuozmmK/lr7lt5YC85LiN5ZCM55qE5aSa6aG55byP77yM57q/5oCn6KGo5Lit55qE57uT54K55aSn5bCP5Lmf5LiN5ZCM77yM6L+Z5ZCM5qC35byV6LW35a2Y5YKo566h55CG55qE5LiN5L6/44CCXHJcbiDmlYXkuI3pgILkuo7nlKjnur/mgKfooajooajnpLrjgIJcclxuXHJcbiDkvovlpoLkuInlhYPlpJrpobnlvI/vvJpcclxuIFAoeCwgeSwgeikgPSB4KDEwKXkoMyl6KDIpICsgMngoNil5KDMpeigyKSArIDN4KDUpeSgyKXooMikgKyB4KDQpeSg0KXogKyAyeXogKyAxNVxyXG5cclxuIOWmguiLpeaUueWGmeS4uu+8mlxyXG4gUCh4LCB5LCB6KSA9ICgoeCgxMCkgKyAyeCg2KSl5KDMpICsgM3goNSl5KDIpKXooMikgKyAoKHgoNCkgKyA2eCgzKSl5KDQpICsgMnkpeiArIDE1XHJcblxyXG4g55So5bm/5LmJ6KGo6KGo56S677yaXHJcbiBQID0geigoQSwgMiksIChCLCAxKSwgKDE1LCAwKSlcclxuIEEgPSB5KChDLCAzKSwgKEQsIDIpKVxyXG4gQiA9IHkoKEUsIDQpLCAoRiwgMSkpXHJcbiBDID0geCgoMSwgMTApLCAoMiwgNikpXHJcbiBEID0geCgoMywgNSkpXHJcbiBFID0geCgoMSwgNCksICg2LCAzKSlcclxuIEYgPSB4KCgyLCAwKSlcclxuXHJcblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIE1QTm9kZSgpIHtcclxuICAgIC8vIOWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxyXG4gICAgdGhpcy50YWcgPSB1bmRlZmluZWQ7XHJcbiAgICAvLyDmjIfmlbDln59cclxuICAgIHRoaXMuZXhwID0gMDtcclxuXHJcbiAgICAvLyDns7vmlbDln59cclxuICAgIHRoaXMuY29lZiA9IDA7XHJcbiAgICAvLyDooajnu5PngrnnmoTooajlpLTmjIfpkohcclxuICAgIHRoaXMuaHAgPSBudWxsO1xyXG5cclxuICAgIC8vIOebuOW9k+S6jue6v+aAp+ihqOeahG5leHTvvIzmjIflkJHkuIvkuIDkuKrlhYPntKDnu5PngrlcclxuICAgIHRoaXMudHAgPSBudWxsO1xyXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvR2VuZXJhbGl6ZWRMaXN0L0dMaXN0LmpzXG4gKiovIiwiLypcclxuIOmCu+aOpeWkmumHjeihqFxyXG5cclxuIOmCu+aOpeWkmumHjeihqChBZGphY2VuY3kgTXVsdGlsaXN0KeaYr+aXoOWQkeWbvueahOWPpuS4gOenjemTvuW8j+WtmOWCqOe7k+aehOOAglxyXG5cclxuIOmCu+aOpeihqOaYr+aXoOWQkeWbvueahOS4gOenjeacieaViOeahOWtmOWCqOe7k+aehO+8jOWcqOaXoOWQkeWbvueahOmCu+aOpeihqOS4re+8jOS4gOadoei+uSh2LHcp55qE5Lik5Liq6KGo57uT54K55YiG5Yir5Yid6YCJ5Zyo5LulduWSjHfkuLrlpLTnu5PngrnnmoTpk77ooajkuK3vvIzlvojlrrnmmJPmsYLlvpfpobbngrnlkozovrnnmoTkv6Hmga/vvIzkvYblnKjmtonlj4rliLDovrnnmoTmk43kvZzkvJrluKbmnaXkuI3kvr/jgIJcclxuXHJcbiDpgrvmjqXlpJrph43ooajnmoTnu5PmnoTlkozljYHlrZfpk77ooajnsbvkvLzvvIzmr4/mnaHovrnnlKjkuIDkuKrnu5PngrnooajnpLrvvJvpgrvmjqXlpJrph43ooajkuK3nmoTpobbngrnnu5Pngrnnu5PmnoTkuI7pgrvmjqXooajkuK3nmoTlrozlhajnm7jlkIzvvIzogIzooajnu5PngrnljIXmi6zlha3kuKrln5/jgIJcclxuXHJcbiDil4YgIERhdGHln5/vvJrlrZjlgqjlkozpobbngrnnm7jlhbPnmoTkv6Hmga/vvJtcclxuIOKXhiDmjIfpkojln59maXJzdGVkZ2XvvJrmjIflkJHkvp3pmYTkuo7or6XpobbngrnnmoTnrKzkuIDmnaHovrnmiYDlr7nlupTnmoTooajnu5PngrnvvJtcclxuIOKXhiDmoIflv5fln59tYXJr77ya55So5Lul5qCH6K+G6K+l5p2h6L655piv5ZCm6KKr6K6/6Zeu6L+H77ybXHJcbiDil4YgaXZleOWSjGp2ZXjln5/vvJrliIbliKvkv53lrZjor6XovrnmiYDkvp3pmYTnmoTkuKTkuKrpobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcclxuIOKXhiBpbmZv5Z+f77ya5L+d5a2Y6K+l6L6555qE55u45YWz5L+h5oGv77ybXHJcbiDil4Yg5oyH6ZKI5Z+faWxpbmvvvJrmjIflkJHkuIvkuIDmnaHkvp3pmYTkuo7pobbngrlpdmV455qE6L6577ybXHJcbiDil4Yg5oyH6ZKI5Z+famxpbmvvvJrmjIflkJHkuIvkuIDmnaHkvp3pmYTkuo7pobbngrlqdmV455qE6L6577ybXHJcblxyXG4g6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo55qE5Yy65Yir77yaXHJcbiDlkI7ogIXnmoTlkIzkuIDmnaHovrnnlKjkuKTkuKrooajnu5PngrnooajnpLrvvIzogIzliY3ogIXlj6rnlKjkuIDkuKrooajnu5PngrnooajnpLrvvJvpmaTmoIflv5fln5/lpJbvvIzpgrvmjqXlpJrph43ooajkuI7pgrvmjqXooajooajovr7nmoTkv6Hmga/mmK/nm7jlkIznmoTvvIzlm6DmraTvvIzmk43kvZznmoTlrp7njrDkuZ/ln7rmnKznm7jkvLzjgIJcclxuXHJcbiAqL1xyXG5cclxuY29uc3QgVU5WSVNJVEVEID0gMDtcclxuY29uc3QgVklTSVRFRCA9IDE7XHJcblxyXG5cclxuY2xhc3MgRUJveCB7XHJcbiAgICAvKipcclxuICAgICAqIOi+ueeahOe7k+eCueihqOekulxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1hcmsg6K6/6Zeu5qCH6K6wIDAgLS0g5pyq6K6/6ZeuICAxID09IOW3suiuv+mXrlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl2ZXgg6K+l6L655L6d6ZmE55qE5Lik5Liq6aG254K555qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ganZleCDor6Xovrnkvp3pmYTnmoTkuKTkuKrpobbngrnnmoTkvY3nva5cclxuICAgICAqIEBwYXJhbSB7RUJveH0gaWxpbmsg5YiG5Yir5oyH5ZCR5L6d6ZmE6L+Z5Lik5Liq6aG254K555qE5LiL5LiA5p2h6L65XHJcbiAgICAgKiBAcGFyYW0ge0VCb3h9IGpsaW5rIOWIhuWIq+aMh+WQkeS+nemZhOi/meS4pOS4qumhtueCueeahOS4i+S4gOadoei+uVxyXG4gICAgICogQHBhcmFtIHsqfSBpbmZvIOivpei+ueS/oeaBr1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1hcmssIGl2ZXgsIGp2ZXgsIGlsaW5rLCBqbGluaywgaW5mbyl7XHJcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyayB8fCBVTlZJU0lURUQ7XHJcbiAgICAgICAgdGhpcy5pdmV4ID0gaXZleCB8fCAwO1xyXG4gICAgICAgIHRoaXMuanZleCA9IGp2ZXggfHwgMDtcclxuICAgICAgICB0aGlzLmlsaW5rID0gaWxpbmsgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmpsaW5rID0gamxpbmsgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmluZm8gPSBpbmZvIHx8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEFNTFZleEJveCB7XHJcbiAgICAvKipcclxuICAgICAqIOmhtueCueeahOe7k+eCueihqOekulxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXHJcbiAgICAgKiBAcGFyYW0ge0VCb3h9IGZpcnN0RWRnZSDmjIflkJHnrKzkuIDmnaHkvp3pmYTor6XpobbngrnnmoTovrlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmaXJzdEVkZ2Upe1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmZpcnN0RWRnZSA9IGZpcnN0RWRnZSB8fCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBTUxHcmFwaCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgQU1MVmV4Qm94fSBhZGpNdWxpc3RcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlbnVtXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWRqTXVsaXN0LCB2ZXhudW0sIGVkZ2VudW0pe1xyXG4gICAgICAgIHRoaXMuYWRqTXVsaXN0ID0gYWRqTXVsaXN0IHx8IFtdO1xyXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtIHx8IDA7XHJcbiAgICAgICAgdGhpcy5lZGdlbnVtID0gZWRnZW51bSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGxvY2F0ZVZleCAodikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3RbaV0uZGF0YSA9PT0gdikgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVBcmModiwgdykge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5sb2NhdGVWZXgodik7XHJcbiAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleCh3KTtcclxuXHJcbiAgICAgICAgaWYgKGkgPCAwIHx8IGogPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBub3QgZm91bmQhJyk7XHJcblxyXG4gICAgICAgIHZhciBwO1xyXG4gICAgICAgIC8vIOWcqGnpk77ooajkuK3liKDpmaTor6XovrlcclxuICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlLmp2ZXggPT09IGopIHtcclxuICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlID0gdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlLmlsaW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZTsgcCAmJiBwLmlsaW5rLmp2ZXggIT09IGo7IHAgPSBwLmlsaW5rKTtcclxuICAgICAgICAgICAgaWYgKCFwKSB0aHJvdyBuZXcgRXJyb3IoJ2VkZ2Ugbm90IGZvdW5kIScpO1xyXG4gICAgICAgICAgICBwLmlsaW5rID0gcC5pbGluay5pbGluaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWcqGrpk77ooajkuK3liKDpmaTor6XovrlcclxuICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlLml2ZXggPT09IGkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlID0gdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlLmpsaW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZTsgcCAmJiBwLmpsaW5rLml2ZXggIT09IGk7IHAgPSBwLmpsaW5rKTtcclxuICAgICAgICAgICAgaWYgKCFwKSB0aHJvdyBuZXcgRXJyb3IoJ2VkZ2Ugbm90IGZvdW5kIScpO1xyXG4gICAgICAgICAgICBwLmpsaW5rID0gcC5qbGluay5qbGluaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWRnZW51bS0tO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUdyYXBoKCkge1xyXG4gICAgICAgIHZhciB2ZXhudW0gPSArcHJvbXB0KCd2ZXhudW06ICcpO1xyXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xyXG4gICAgICAgIHZhciBlZGdlbnVtID0gK3Byb21wdCgnZWRnZW51bTogJyk7XHJcbiAgICAgICAgdGhpcy5lZGdlbnVtID0gZWRnZW51bTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB2ZXhudW07ICsrbSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkak11bGlzdFttXSA9IG5ldyBBTUxWZXhCb3gocHJvbXB0KCdkYXRhOiAnKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKG0gPSAwOyBtIDwgZWRnZW51bTsgKyttKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gcHJvbXB0KCd0YWlsVmV4OiAnKTtcclxuICAgICAgICAgICAgdmFyIGggPSBwcm9tcHQoJ2hlYWRWZXg6ICcpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMubG9jYXRlVmV4KHQpO1xyXG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kISBUcnkgYWdhaW46Jyk7XHJcbiAgICAgICAgICAgICAgICBtLS07XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgRUJveCgwLCBpLCBqLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgdmFyIHEsIHI7XHJcblxyXG4gICAgICAgICAgICAvLyDmj5LlhaVp6ZO+6KGo5bC+6YOoXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UgPSBwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcSA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuaXZleCA9PT0gaSkgcSA9IHEuaWxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxID0gcS5qbGluaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyLml2ZXggPT09IGkpIHIuaWxpbmsgPSBwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSByLmpsaW5rID0gcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g5o+S5YWlaumTvuihqOWwvumDqFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlID0gcDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEgPSB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmp2ZXggPT09IGopIHEgPSBxLmpsaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcSA9IHEuaWxpbms7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoci5qdmV4ID09PSBqKSByLmpsaW5rID0gcDtcclxuICAgICAgICAgICAgICAgIGVsc2Ugci5pbGluayA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vdmFyIGcgPSBuZXcgQU1MR3JhcGgoKTtcclxuLy9nLmNyZWF0ZUdyYXBoKCk7XHJcbi8vY29uc29sZS5sb2coZyk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0dyYXBoL0FNTEdyYXBoLmpzXG4gKiovIiwiLyogQ3JlYXRlIEJ5IEx1a2UgKi9cclxuXHJcbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XHJcbmltcG9ydCB7IENoaWxkU2libGluZ1RyZWUgfSBmcm9tICcuLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnO1xyXG5cclxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XHJcbmNvbnN0IERHID0gMTsgICAgIC8vIOacieWQkeWbvlxyXG5jb25zdCBETiA9IDI7ICAgICAvLyDmnInlkJHnvZFcclxuY29uc3QgVURHID0gMzsgICAgLy8g5peg5ZCR5Zu+XHJcbmNvbnN0IFVETiA9IDQ7ICAgIC8vIOaXoOWQkee9kVxyXG5cclxuXHJcbi8qXHJcbiDpgrvmjqXpk77ooajms5VcclxuXHJcbiDln7rmnKzmgJ3mg7PvvJrlr7nlm77nmoTmr4/kuKrpobbngrnlu7rnq4vkuIDkuKrljZXpk77ooajvvIzlrZjlgqjor6XpobbngrnmiYDmnInpgrvmjqXpobbngrnlj4rlhbbnm7jlhbPkv6Hmga/jgILmr4/kuIDkuKrljZXpk77ooajorr7kuIDkuKrooajlpLTnu5PngrnjgIJcclxuXHJcbiDnrKxp5Liq5Y2V6ZO+6KGo6KGo56S65L6d6ZmE5LqO6aG254K5VmnnmoTovrko5a+55pyJ5ZCR5Zu+5piv5Lul6aG254K5VmnkuLrlpLTmiJblsL7nmoTlvKcp44CCXHJcblxyXG4gMSAg57uT54K557uT5p6E5LiO6YK75o6l6ZO+6KGo56S65L6LXHJcblxyXG4g6ZO+6KGo5Lit55qE57uT54K556ew5Li66KGo57uT54K577yM5q+P5Liq57uT54K555Sx5LiJ5Liq5Z+f57uE5oiQ44CC5YW25Lit6YK75o6l54K55Z+fKGFkanZleCnmjIfnpLrkuI7pobbngrlWaemCu+aOpeeahOmhtueCueWcqOWbvuS4reeahOS9jee9rijpobbngrnnvJblj7cp77yM6ZO+5Z+fKG5leHRhcmMp5oyH5ZCR5LiL5LiA5Liq5LiO6aG254K5VmnpgrvmjqXnmoTooajnu5PngrnvvIzmlbDmja7ln58oaW5mbynlrZjlgqjlkozovrnmiJblvKfnm7jlhbPnmoTkv6Hmga/vvIzlpoLmnYPlgLznrYnjgILlr7nkuo7ml6DmnYPlm77vvIzlpoLmnpzmsqHmnInkuI7ovrnnm7jlhbPnmoTlhbbku5bkv6Hmga/vvIzlj6/nnIHnlaXmraTln5/jgIJcclxuXHJcbiDmr4/kuKrpk77ooajorr7kuIDkuKrooajlpLTnu5Pngrko56ew5Li66aG254K557uT54K5Ke+8jOeUseS4pOS4quWfn+e7hOaIkOOAgumTvuWfnyhmaXJzdGFyYynmjIflkJHpk77ooajkuK3nmoTnrKzkuIDkuKrnu5PngrnvvIzmlbDmja7ln58oZGF0YSkg5a2Y5YKo6aG254K55ZCN5oiW5YW25LuW5L+h5oGv44CCXHJcblxyXG4g5Zyo5Zu+55qE6YK75o6l6ZO+6KGo6KGo56S65Lit77yM5omA5pyJ6aG254K557uT54K555So5LiA5Liq5ZCR6YePIOS7pemhuuW6j+e7k+aehOW9ouW8j+WtmOWCqO+8jOWPr+S7pemaj+acuuiuv+mXruS7u+aEj+mhtueCueeahOmTvuihqO+8jOivpeWQkemHj+ensOS4uuihqOWktOWQkemHj++8jOWQkemHj+eahOS4i+agh+aMh+ekuumhtueCueeahOW6j+WPt+OAglxyXG5cclxuIOeUqOmCu+aOpemTvuihqOWtmOWCqOWbvuaXtu+8jOWvueaXoOWQkeWbvu+8jOWFtumCu+aOpemTvuihqOaYr+WUr+S4gOeahO+8m+WvueacieWQkeWbvu+8jOWFtumCu+aOpemTvuihqOacieS4pOenjeW9ouW8j+OAglxyXG5cclxuXHJcbiAyICDpgrvmjqXooajms5XnmoTnibnngrlcclxuXHJcbiDil4Yg6KGo5aS05ZCR6YeP5Lit5q+P5Liq5YiG6YeP5bCx5piv5LiA5Liq5Y2V6ZO+6KGo55qE5aS057uT54K577yM5YiG6YeP5Liq5pWw5bCx5piv5Zu+5Lit55qE6aG254K55pWw55uu77ybXHJcbiDil4Yg5Zyo6L655oiW5byn56iA55aP55qE5p2h5Lu25LiL77yM55So6YK75o6l6KGo6KGo56S65q+U55So6YK75o6l55+p6Zi16KGo56S66IqC55yB5a2Y5YKo56m66Ze077ybXHJcbiDil4Yg5Zyo5peg5ZCR5Zu+77yM6aG254K5VmnnmoTluqbmmK/nrKxp5Liq6ZO+6KGo55qE57uT54K55pWw77ybXHJcbiDil4Yg5a+55pyJ5ZCR5Zu+5Y+v5Lul5bu656uL5q2j6YK75o6l6KGo5oiW6YCG6YK75o6l6KGo44CC5q2j6YK75o6l6KGo5piv5Lul6aG254K5VmnkuLrlh7rluqYo5Y2z5Li65byn55qE6LW354K5KeiAjOW7uueri+eahOmCu+aOpeihqO+8m+mAhumCu+aOpeihqOaYr+S7pemhtueCuVZp5Li65YWl5bqmKOWNs+S4uuW8p+eahOe7iOeCuSnogIzlu7rnq4vnmoTpgrvmjqXooajvvJtcclxuIOKXhiDlnKjmnInlkJHlm77kuK3vvIznrKxp5Liq6ZO+6KGo5Lit55qE57uT54K55pWw5piv6aG254K5VmnnmoTlh7ogKOaIluWFpSnluqbvvJvmsYLlhaUgKOaIluWHuinluqbvvIzpobvpgY3ljobmlbTkuKrpgrvmjqXooajvvJtcclxuIOKXhiDlnKjpgrvmjqXooajkuIrlrrnmmJPmib7lh7rku7vkuIDpobbngrnnmoTnrKzkuIDkuKrpgrvmjqXngrnlkozkuIvkuIDkuKrpgrvmjqXngrnvvJtcclxuXHJcbiAqL1xyXG5cclxuXHJcbmNsYXNzIEFyY05vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFkalZleFxyXG4gICAgICogQHBhcmFtIHtBcmNOb2RlfSBuZXh0QXJjXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZGpWZXggPSAwLCBuZXh0QXJjID0gbnVsbCwgaW5mbyA9IG51bGwpe1xyXG4gICAgICAgIC8vIOivpeW8p+aJgOaMh+WQkeeahOmhtueCueeahOS9jee9rlxyXG4gICAgICAgIHRoaXMuYWRqVmV4ID0gYWRqVmV4O1xyXG4gICAgICAgIC8vIOaMh+WQkeS4i+S4gOadoeW8p+eahOaMh+mSiFxyXG4gICAgICAgIHRoaXMubmV4dEFyYyA9IG5leHRBcmM7XHJcbiAgICAgICAgLy8g6K+l5byn55u45YWz5L+h5oGv55qE5oyH6ZKIXHJcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgVmV4Tm9kZSB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcclxuICAgICAqIEBwYXJhbSB7QXJjTm9kZX0gZmlyc3RBcmNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlZ3JlZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGZpcnN0QXJjID0gbnVsbCwgaW5kZWdyZWUgPSAwKXtcclxuICAgICAgICAvLyDpobbngrnkv6Hmga9cclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIC8vIOaMh+WQkeesrOS4gOadoeS+nemZhOivpemhtueCueeahOW8p+eahOaMh+mSiFxyXG4gICAgICAgIHRoaXMuZmlyc3RBcmMgPSBmaXJzdEFyYztcclxuICAgICAgICAvLyAg6aG254K555qE5bqmLCDmnInlkJHlm77mmK/lhaXluqbmiJblh7rluqbmiJbmsqHmnIlcclxuICAgICAgICB0aGlzLmluZGVncmVlID0gaW5kZWdyZWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkamFjZW5jeUxpc3RHcmFwaCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgVmV4Tm9kZX0gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBraW5kXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmVydGljZXMgPSBbXSwgdmV4bnVtID0gMCwgYXJjbnVtID0gMCwga2luZCA9IERHKXtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XHJcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWw5ZKM5byn5pWwXHJcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW07XHJcbiAgICAgICAgdGhpcy5hcmNudW0gPSBhcmNudW07XHJcbiAgICAgICAgLy8g5Zu+55qE56eN57G75qCH5b+XXHJcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmn6Xmib7pobbngrnkvY3nva5cclxuICAgIGxvY2F0ZVZleCh2cCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc1tpXS5kYXRhID09PSB2cCkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5re75Yqg6aG254K5XHJcbiAgICBhZGRWZXJ0ZXgodnApIHtcclxuICAgICAgICBpZiAodGhpcy5sb2NhdGVWZXgodnApICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggaGFzIGV4aXN0ZWQhJyk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXhudW0rK10gPSBuZXcgVmV4Tm9kZSh2cCwgbnVsbCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmV4bnVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg5bynXHJcbiAgICAgKiDlpoLmnpzmmK/ml6DlkJHlm77miJbogIXml6DlkJHnvZEsYXJjMeWSjGFyYzLml6Dpobrluo/opoHmsYJcclxuICAgICAqIOWmguaenOaYr+acieWQkeWbvuaIluiAheacieWQkee9ke+8jOWPquS8mua3u+WKoGFyYzHvvIzlm6DmraTmraPpgrvmjqXooajlkozpgIbpgrvmjqXooajnmoTpobrluo/pnIDopoHms6jmhI9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmMxXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJjMlxyXG4gICAgICogQHBhcmFtIHsqfSBpbmZvXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgYWRkQXJjKGFyYzEsIGFyYzIsIGluZm8pIHtcclxuICAgICAgICBsZXQgayA9IHRoaXMubG9jYXRlVmV4KGFyYzEpO1xyXG4gICAgICAgIGxldCBqID0gdGhpcy5sb2NhdGVWZXgoYXJjMik7XHJcblxyXG4gICAgICAgIGlmIChrID09PSAtMSB8fCBqID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdBcmNcXCdzIFZlcnRleCBkbyBub3QgZXhpc3RlZCEnKTtcclxuXHJcbiAgICAgICAgLy8g6L6555qE6LW35aeL6KGo57uT54K56LWL5YC8XHJcbiAgICAgICAgbGV0IHAgPSBuZXcgQXJjTm9kZShrLCBudWxsLCBpbmZvKTtcclxuICAgICAgICAvLyDovrnnmoTmnKvlsL7ooajnu5PngrnotYvlgLxcclxuICAgICAgICBsZXQgcSA9IG5ldyBBcmNOb2RlKGosIG51bGwsIGluZm8pO1xyXG5cclxuICAgICAgICAvLyDmmK/ml6DlkJHlm77vvIznlKjlpLTmj5LlhaXms5Xmj5LlhaXliLDkuKTkuKrljZXpk77ooahcclxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcclxuICAgICAgICAgICAgcS5uZXh0QXJjID0gdGhpcy52ZXJ0aWNlc1trXS5maXJzdEFyYztcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1trXS5maXJzdEFyYyA9IHE7XHJcbiAgICAgICAgICAgIHAubmV4dEFyYyA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbal0uZmlyc3RBcmMgPSBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlu7rnq4vmnInlkJHlm77nmoTpgrvmjqXpk77ooajvvIznlKjlpLTmj5LlhaXms5VcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcC5uZXh0QXJjID0gdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYztcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYyA9IHA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICArK3RoaXMuYXJjbnVtO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIOWFtuS7luWbvuexu+Wei+eahOWIm+W7uuaaguaXtuayoeW8hFxyXG4gICAgY3JlYXRlR3JhcGgoKSB7XHJcbiAgICAgICAgdGhpcy52ZXhudW0gPSArcHJvbXB0KCd2ZXhudW06ICcpO1xyXG4gICAgICAgIHRoaXMuYXJjbnVtID0gK3Byb21wdCgnYXJjbnVtOiAnKTtcclxuICAgICAgICAvLyBpbmNJbmZv5Li6MOWImeWQhOW8p+S4jeWQq+WFtuS7luS/oeaBr1xyXG4gICAgICAgIGxldCBpbmNJbmZvID0gK3Byb21wdCgnaW5jSW5mbzogJyk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW21dID0gbmV3IFZleE5vZGUoKTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttXS5kYXRhID0gcHJvbXB0KCd2ZXJ0ZXg6ICcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChtID0gMDsgbSA8IHRoaXMuYXJjbnVtOyArK20pIHtcclxuICAgICAgICAgICAgbGV0IGggPSBwcm9tcHQoJ+W8p+WktDogJyk7XHJcbiAgICAgICAgICAgIGxldCB0ID0gcHJvbXB0KCflvKflsL46ICcpO1xyXG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMubG9jYXRlVmV4KHQpO1xyXG4gICAgICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBhbGVydCgn6aG254K55Li65om+5Yiw77yM6K+36YeN5paw6L6T5YWl77yBJyk7XHJcbiAgICAgICAgICAgICAgICBtLS07XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHAgPSBuZXcgQXJjTm9kZShqLCBudWxsLCBpbmNJbmZvICYmIHByb21wdCgnaW5mbzogJykpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjKSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjID0gcDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBxID0gdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcS5uZXh0QXJjOyBxID0gcS5uZXh0QXJjKTtcclxuICAgICAgICAgICAgICAgIHEubmV4dEFyYyA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yik5pat5LiA5Liq6YK75o6l6KGo5a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXHJcbiAgICBpc1Bhc3MoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2luZCAhPT0gREcpIHRocm93IG5ldyBFcnJvcignZ3JhcGgga2luZCBzaG91bGQgYmUgREcnKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnZleG51bTsgKyt4KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW3hdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcSA9IHRoaXMudmVydGljZXNbeV0uZmlyc3RBcmM7IHE7IHEgPSBxLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeiA9IHEuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuaXNBZGooeCwgeikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yik5pat5pyJ5ZCR5Zu+5piv5ZCm5a2Y5Zyo6L65KG0sbilcclxuICAgIGlzQWRqKG0sIG4pIHtcclxuICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1ttXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICBpZiAocC5hZGpWZXggPT09IG4pIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmt7HluqbkvJjlhYjliKTmlq08Yj7mnInlkJHlm748Yj7nmoTpobbngrlp5Yiw6aG254K5auaYr+WQpuaciei3r+W+hO+8jOWunuWImei/lOWbnnRydWXvvIzlkKbliJnov5Tlm55mYWxzZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqXHJcbiAgICAgKi9cclxuICAgIGV4aXN0X3BhdGhfREZTKGksIGopIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcclxuICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XHJcblxyXG4gICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kIScpO1xyXG5cclxuICAgICAgICByZXR1cm4gZXhpc3RfcGF0aCh0aGlzLCBpLCBqKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZXhpc3RfcGF0aChncmFwaCwgaSwgaikge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2tdICYmIGV4aXN0X3BhdGgoZ3JhcGgsIGssIGopKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOW5v+W6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpcclxuICAgICAqL1xyXG4gICAgZXhpc3RfcGF0aF9CRlMoaSwgaikge1xyXG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcclxuICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICBxdWV1ZS5lblF1ZXVlKGkpO1xyXG5cclxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICBsZXQgdSA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDE7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSBqKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtrXSkgcXVldWUuZW5RdWV1ZShrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5pat6YK75o6l6KGo5pa55byP5a2Y5YKo55qE5pyJ5ZCR5Zu+55qE6aG254K5aeWIsGrmmK/lkKblrZjlnKjplb/luqbkuLpr55qE566A5Y2V6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXHJcbiAgICAgKi9cclxuICAgIGV4aXN0X3BhdGhfbGVuKGksIGosIGspIHtcclxuICAgICAgICBpID0gdGhpcy5sb2NhdGVWZXgoaSk7XHJcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcblxyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gcmVjdXJzZShncmFwaCwgaSwgaiwgaykge1xyXG4gICAgICAgICAgICAvLyDmib7liLDkuobkuIDmnaHot6/lvoTvvIzkuJTplb/luqbnrKblkIhcclxuICAgICAgICAgICAgaWYgKGkgPT09IGogJiYgayA9PT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWJqeS9mei3r+W+hOmVv+W6puWHj+S4gFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZShncmFwaCwgbCwgaiwgayAtIDEpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDlhYHorrjmm77nu4/ooqvorr/pl67ov4fnmoTnu5Pngrnlh7rnjrDlnKjlj6bkuIDmnaHot6/lvoTkuIpcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSkodGhpcywgaSwgaiwgayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmsYLmnInlkJHlm77kuK3pobbngrl15YiwduS5i+mXtOeahOaJgOacieeugOWNlei3r+W+hO+8jGvkuLrlvZPliY3ot6/lvoTplb/luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGdyYXBoLmZpbmRfYWxsX3BhdGgoJ3YxJywgJ3YyJywgMCk7XHJcbiAgICAgKi9cclxuICAgIGZpbmRfYWxsX3BhdGgodSwgdiwgaykge1xyXG4gICAgICAgIHUgPSB0aGlzLmxvY2F0ZVZleCh1KTtcclxuICAgICAgICB2ID0gdGhpcy5sb2NhdGVWZXgodik7XHJcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG5cclxuICAgICAgICBmaW5kUGF0aCh0aGlzLCB1LCB2LCBrKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmluZFBhdGgoZ3JhcGgsIHUsIHYsIGspIHtcclxuICAgICAgICAgICAgLy8g5Yqg5YWl5b2T5YmN6Lev5b6E5LitXHJcbiAgICAgICAgICAgIHBhdGhba10gPSB1O1xyXG4gICAgICAgICAgICB2aXNpdGVkW3VdID0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOS4gOadoeeugOWNlei3r+W+hFxyXG4gICAgICAgICAgICBpZiAodSA9PT0gdikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIG9uZSBwYXRoIScpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IHBhdGhbaV07ICsraSkgY29uc29sZS5sb2cocGF0aFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbdV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOe7p+e7reWvu+aJvlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtsXSkgZmluZFBhdGgoZ3JhcGgsIGwsIHYsIGsgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDA7XHJcbiAgICAgICAgICAgIC8vIOWbnua6r1xyXG4gICAgICAgICAgICBwYXRoW2tdID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmsYLmnInlkJHlm77nmoTpobbngrnkuYvpl7Tplb/luqbkuLpsZW7nmoTnroDljZXot6/lvoTmnaHmlbBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlblxyXG4gICAgICovXHJcbiAgICBnZXRQYXRoTnVtX2xlbihpLCBqLCBsZW4pIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG5cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIHJlY3Vyc2UoZ3JhcGgsIGksIGosIGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaiAmJiBsZW4gPT09IDApIHJldHVybiAxO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbF0pIHN1bSArPSByZWN1cnNlKGwsIGosIGxlbiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkodGhpcywgaSwgaiwgbGVuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaxguacieWQkeaXoOeOr+WbvueahOaguVxyXG4gICAgICovXHJcbiAgICBnZXRSb290KCl7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgLy8g5q+P5qyh6YO96KaB5bCG6K6/6Zeu5pWw57uE5riF6Zu2XHJcbiAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykgdmlzaXRlZFt3XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyDku47pobbngrlp5Ye65Y+R6L+b6KGM5rex5bqm5LyY5YWI6YGN5Y6GXHJcbiAgICAgICAgICAgIGRmcyh0aGlzLCBpKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBmbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdyl7XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpxp5piv5qC577yM5YiZ5rex5bqm5LyY5YWI6YGN5Y6G5Y+v5Lul6K6/6Zeu5Yiw5omA5pyJ57uT54K5XHJcbiAgICAgICAgICAgICAgICBpZighdmlzaXRlZFt3XSkgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihmbGFnKSBjb25zb2xlLmxvZygnRm91bmQgYSByb290IHZlcnRleDogJWQnLCBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdil7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBwID0gZ3JhcGgudmVydGljZXNbdl0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHcgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmKCF2aXNpdGVkW3ddKSBkZnMoZ3JhcGgsIHcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rGC5LiA5Liq5pyJ5ZCR5peg546v5Zu+5Lit5pyA6ZW/55qE6Lev5b6EXHJcbiAgICAgKi9cclxuICAgIGdldExvbmdlc3RQYXRoKCl7XHJcbiAgICAgICAgbGV0IG1scCA9IFtdO1xyXG4gICAgICAgIGxldCBwYXRoID0gW107XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgbWF4TGVuID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5jb3VudEluZGVncmVlKCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikgdmlzaXRlZFtqXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyDku47mr4/kuIDkuKrpm7blhaXluqbnu5PngrnlvIDlp4vmt7HluqbkvJjlhYjpgY3ljoZcclxuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIGRmcyh0aGlzLCBpLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb25nZXN0IFBhdGg6Jyk7XHJcbiAgICAgICAgLy8g6L6T5Ye65pyA6ZW/6Lev5b6EXHJcbiAgICAgICAgZm9yKGkgPSAwOyBtbHBbaV07ICsraSkgY29uc29sZS5sb2cobWxwLmpvaW4oJywnKSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgaSwgbGVuKXtcclxuICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHBhdGhbbGVuXSA9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyDmlrDnmoTmnIDplb/ot6/lvoRcclxuICAgICAgICAgICAgaWYobGVuID4gbWF4TGVuICYmICFncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYykge1xyXG4gICAgICAgICAgICAgICAgLy8g5L+d5a2Y5LiL5p2lXHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDw9IGxlbjsgKytqKSBtbHBbal0gPSBwYXRoW2pdO1xyXG4gICAgICAgICAgICAgICAgbWF4TGVuID0gbGVuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXZpc2l0ZWRbd10pIGRmcyhncmFwaCwgdywgbGVuICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhdGhbaV0gPSAwO1xyXG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOmCu+aOpeihqOeahOmAkuW9kuW8j+a3seW6puS8mOWFiOmBjeWOhlxyXG4gICAgREZTVHJhdmVyc2UodmlzaXRGbikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmcyh0aGlzLCBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdikge1xyXG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmlzaXRGbi5jYWxsKGdyYXBoLCB2KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwID0gZ3JhcGgudmVydGljZXNbdl0uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSBkZnMoZ3JhcGgsIHAuYWRqVmV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOmCu+aOpeihqOeahOmdnumAkuW9kua3seW6puS8mOWFiOaQnOe0olxyXG4gICAgREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB2O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCh2ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzLnZlcnRpY2VzW3ZdLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbcC5hZGpWZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBwLmFkalZleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHAuYWRqVmV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHN0YWNrLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOmCu+aOpeihqOeahOW5v+W6puS8mOWFiOaQnOe0olxyXG4gICAgQkZTVHJhdmVyc2UodmlzaXRGbikge1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1t3XS5maXJzdEFyYztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW3AuYWRqVmV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgcC5hZGpWZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShwLmFkalZleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOW7uueri+aXoOWQkeWbvueahOa3seW6puS8mOWFiOeUn+aIkOajruael+eahOWtqeWtkOWFhOW8n+mTvuihqOagkVxyXG4gICAgY3JlYXRlREZTRm9yZXN0KCkge1xyXG4gICAgICAgIGxldCB0cmVlID0gbnVsbDtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmlrDnmoTnlJ/miJDmoJHnmoTmoLnnu5PngrlcclxuICAgICAgICAgICAgICAgIGxldCBwID0gbmV3IENoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1tpXS5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDmo7XnlJ/miJDmoJHnmoTmoLlcclxuICAgICAgICAgICAgICAgIGlmICghdHJlZSkgdHJlZSA9IHA7XHJcbiAgICAgICAgICAgICAgICAvLyDlhbblroPnlJ/miJDmoJHnmoTmoLlcclxuICAgICAgICAgICAgICAgIGVsc2UgcS5uZXh0U2libGluZyA9IHA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gceS4uuW9k+WJjeeUn+aIkOagkeeahOaguVxyXG4gICAgICAgICAgICAgICAgcSA9IHA7XHJcbiAgICAgICAgICAgICAgICAvLyDlu7rnq4vku6Vw5Li65qC555qE55Sf5oiQ5qCRXHJcbiAgICAgICAgICAgICAgICBERlNUcmVlKHRoaXMsIGksIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuXHJcbiAgICAgICAgLy8g5Lul56ysduS4qumhtueCueinpuWPkea3seW6puS8mOWFiOmBjeWOhuWbvu+8jOW7uueri+S7pXRyZWXkuLrmoLnnmoTnlJ/miJDmoJFcclxuICAgICAgICBmdW5jdGlvbiBERlNUcmVlKGdyYXBoLCB2LCB0cmVlKSB7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBsZXQgdyA9IGdyYXBoLnZlcnRpY2VzW3ZdLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICBsZXQgcTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICh3KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbdy5hZGpWZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFt3LmFkalZleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gbmV3IENoaWxkU2libGluZ1RyZWUoZ3JhcGgudmVydGljZXNbdy5hZGpWZXhdLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB35pivdueahOesrOS4gOS4quacquiiq+iuv+mXrueahOmCu+aOpee7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlLmZpcnN0Q2hpbGQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB35pivdueahOWFtuWug+acquiiq+iuv+mXrueahOmCu+aOpemhtueCuVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcS5uZXh0U2libGluZyA9IHA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHEgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBERlNUcmVlKGdyYXBoLCB3LmFkalZleCwgcSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdyA9IHcubmV4dEFyYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVCRlNGb3Jlc3QoKSB7XHJcbiAgICAgICAgbGV0IHRyZWUgPSBudWxsO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCBxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKHRoaXMudmVydGljZXNbaV0uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyZWUpIHRyZWUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBxLm5leHRTaWJsaW5nID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBxID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1t3XS5maXJzdEFyYztcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbcC5hZGpWZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5hZGpWZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlMiA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKHRoaXMudmVydGljZXNbcC5hZGpWZXhdLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZmlyc3RDaGlsZCA9IG5vZGUyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHByZS5uZXh0U2libGluZyA9IG5vZGUyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZSA9IG5vZGUyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kQXJ0aWN1bCgpIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBjb3VudCA9IDE7XHJcbiAgICAgICAgbGV0IGxvdyA9IFtdO1xyXG4gICAgICAgIGxvd1swXSA9IGNvdW50O1xyXG4gICAgICAgIHZpc2l0ZWRbMF0gPSAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IDA7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLnZlcnRpY2VzWzBdLmZpcnN0QXJjO1xyXG4gICAgICAgIGxldCB2ID0gcC5hZGpWZXg7XHJcblxyXG4gICAgICAgIERGU0FydGljdWwodGhpcywgdik7XHJcbiAgICAgICAgaWYgKGNvdW50IDwgdGhpcy52ZXhudW0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coMCArICcgICcgKyB0aGlzLnZlcnRpY2VzWzBdLmRhdGEpO1xyXG4gICAgICAgICAgICB3aGlsZSAocC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xyXG4gICAgICAgICAgICAgICAgdiA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbdl0gPT09IDApIERGU0FydGljdWwodGhpcywgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIERGU0FydGljdWwoZ3JhcGgsIHYwKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW4gPSB2aXNpdGVkW3YwXSA9ICsrY291bnQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t2MF0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFt3XSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIERGU0FydGljdWwoZ3JhcGgsIHcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dbd10gPCBtaW4pIG1pbiA9IGxvd1t3XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG93W3ddID49IHZpc2l0ZWRbdjBdKSBjb25zb2xlLmxvZyh2MCArICcgICcgKyBncmFwaC52ZXJ0aWNlc1t2MF0uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpc2l0ZWRbd10gPCBtaW4pIG1pbiA9IHZpc2l0ZWRbd107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG93W3YwXSA9IG1pbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g57uf6K6h5ZCE6aG254K55YWl5bqm55qE5Ye95pWwXHJcbiAgICBjb3VudEluZGVncmVlKCkge1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykgdGhpcy52ZXJ0aWNlc1trXS5pbmRlZ3JlZSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1trXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYylcclxuICAgICAgICAgICAgICAgICsrdGhpcy52ZXJ0aWNlc1twLmFkalZleF0uaW5kZWdyZWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuLy8g5ouT5omR5o6S5bqP566X5rOVXHJcbiAgICB0b3BvbG9naWNTb3J0KCkge1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHRoaXMudG9wb2xvZ2ljYWxPcmRlciA9IFtdO1xyXG4gICAgICAgIHRoaXMuY291bnRJbmRlZ3JlZSgpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIHN0YWNrLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IGkgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyLnB1c2goaSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbaV0uZGF0YSk7XHJcbiAgICAgICAgICAgICsrY291bnQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKC0tdGhpcy52ZXJ0aWNlc1trXS5pbmRlZ3JlZSA9PT0gMCkgc3RhY2sucHVzaChrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChjb3VudCA+PSB0aGlzLnZleG51bSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6L6T5Ye65pyJ5ZCR5Zu+55qE5ZCE6aG55YWz6ZSu5rS75YqoXHJcbiAgICBjcml0aWNhbFBhdGgoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRvcG9sb2dpY1NvcnQoKSkgdGhyb3cgbmV3IEVycm9yKCdBT0XnvZHkuK3lrZjlnKjlm57ot6/vvIEnKTtcclxuXHJcbiAgICAgICAgbGV0IHZlID0gW107XHJcbiAgICAgICAgLy8g5LqL5Lu25pyA5pep5Y+R55Sf5pe26Ze05Yid5aeL5YyWXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB2ZVtqXSA9IDA7XHJcbiAgICAgICAgLy8g6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pep5Y+R55Sf5pe26Ze0dmXlgLxcclxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcclxuICAgICAgICAgICAgbGV0IGogPSB0aGlzLnRvcG9sb2dpY2FsT3JkZXJbbV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZlW2pdICsgcC5pbmZvID4gdmVba10pIHZlW2tdID0gdmVbal0gKyBwLmluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZsID0gW107XHJcbiAgICAgICAgLy8g5LqL5Lu25pyA5pma5Y+R55Sf5pe26Ze05Yid5aeL5YyWXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB2bFtqXSA9IHZlW3RoaXMudmV4bnVtIC0gMV07XHJcbiAgICAgICAgLy8g6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pma5Y+R55Sf5pe26Ze0dmznmoTlgLxcclxuICAgICAgICBmb3IgKGxldCBtID0gdGhpcy52ZXhudW0gLSAxOyBtID49IDA7IC0tbSkge1xyXG4gICAgICAgICAgICBsZXQgaiA9IHRoaXMudG9wb2xvZ2ljYWxPcmRlclttXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmxba10gLSBwLmluZm8gPCB2bFtqXSkgdmxbal0gPSB2bFtrXSAtIHAuaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDovpPlh7rmiYDmnInlhbPplK7mtLvliqhcclxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbbV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmVbbV0gKyBwLmluZm8gPT09IHZsW2tdKSBjb25zb2xlLmxvZygnPCVkLCAlZD4nLCBtLCBrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG9ydGVzdFBhdGhfRGlqa3N0cmEodjApIHtcclxuICAgICAgICBsZXQgZGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBwcmUgPSBbXTtcclxuICAgICAgICBsZXQgZmluYWwgPSBbXTtcclxuICAgICAgICBsZXQgdztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KVxyXG4gICAgICAgICAgICBkaXN0W3ZdID0gSW5maW5pdHk7XHJcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbdjBdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKVxyXG4gICAgICAgICAgICBkaXN0W3AuYWRqVmV4XSA9IHAuaW5mbztcclxuXHJcbiAgICAgICAgbGV0IHY7XHJcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpIHtcclxuICAgICAgICAgICAgZmluYWxbdl0gPSBmYWxzZTtcclxuICAgICAgICAgICAgcHJlW3ZdID0gcHJlW3ZdIHx8IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykgcHJlW3ZdW3ddID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGlzdFt2XSA8IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBwcmVbdl1bdjBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByZVt2XVt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpc3RbdjBdID0gMDtcclxuICAgICAgICBmaW5hbFt2MF0gPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBkaXN0W3ddIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdFt3XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmluYWxbdl0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbdl0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIHcgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgbWluICsgcC5pbmZvIDwgZGlzdFt3XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Rbd10gPSBtaW4gKyBwLmluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddID0gcHJlW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZVt3XVt3XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGZpbmFsKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhwcmUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRpc3QpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaW5hbDogZmluYWwsXHJcbiAgICAgICAgICAgIHByZTogcHJlLFxyXG4gICAgICAgICAgICBkaXN0OiBkaXN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vIOaXoOWQkeWbvueahOmCu+aOpeihqFxyXG52YXIgYWRqTGlzdEdyYXBoID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgVURHKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjEnKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjInKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjMnKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjQnKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YxJywgJ3YyJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YxJywgJ3YzJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YyJywgJ3YzJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3Y0Jyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3Y1Jyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XHJcblxyXG5jb25zb2xlLmxvZyhhZGpMaXN0R3JhcGgpO1xyXG5cclxuLy8g5pyJ5ZCR5Zu+55qE6YCG6YK75o6l6KGoXHJcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xyXG5nLmFkZFZlcnRleCgndjEnKTtcclxuZy5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmcuYWRkVmVydGV4KCd2MycpO1xyXG5nLmFkZFZlcnRleCgndjQnKTtcclxuZy5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5nLmFkZEFyYygndjEnLCAndjInKTtcclxuZy5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XHJcbmcuYWRkQXJjKCd2MycsICd2MicpO1xyXG5nLmFkZEFyYygndjMnLCAndjEnKTtcclxuZy5hZGRBcmMoJ3Y0JywgJ3YzJyk7XHJcbmcuYWRkQXJjKCd2MycsICd2NScpO1xyXG5nLmFkZEFyYygndjUnLCAndjQnKTtcclxuXHJcbmNvbnNvbGUubG9nKGcpO1xyXG5cclxuLy8g5pyJ5ZCR5Zu+55qE5q2j6YK75o6l6KGoXHJcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xyXG5nLmFkZFZlcnRleCgndjEnKTtcclxuZy5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmcuYWRkVmVydGV4KCd2MycpO1xyXG5nLmFkZFZlcnRleCgndjQnKTtcclxuZy5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5nLmFkZEFyYygndjInLCAndjEnKTtcclxuZy5hZGRBcmMoJ3Y0JywgJ3YxJyk7XHJcbmcuYWRkQXJjKCd2MicsICd2MycpO1xyXG5nLmFkZEFyYygndjEnLCAndjMnKTtcclxuZy5hZGRBcmMoJ3YzJywgJ3Y0Jyk7XHJcbmcuYWRkQXJjKCd2NScsICd2MycpO1xyXG5nLmFkZEFyYygndjQnLCAndjUnKTtcclxuXHJcbmNvbnNvbGUubG9nKGcpO1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coJ2Fkakxpc3RHcmFwaCBERlNUcmF2ZXJzZTogJyk7XHJcbnZhciBhZGpMaXN0R3JhcGggPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBVREcpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MScpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MicpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MycpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NCcpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NScpO1xyXG5cclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjUnLCAndjQnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjInKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjInLCAndjEnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjEnKTtcclxuXHJcbmFkakxpc3RHcmFwaC5ERlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xyXG4gICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1t2XS5kYXRhKTtcclxufSk7XHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggREZTVHJhdmVyc2VfTm9uUmVjdXJzZTogJyk7XHJcbmFkakxpc3RHcmFwaC5ERlNUcmF2ZXJzZV9Ob25SZWN1cnNlKGZ1bmN0aW9uICh2KSB7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZlcnRpY2VzW3ZdLmRhdGEpO1xyXG59KTtcclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coJ2Fkakxpc3RHcmFwaCBCRlNUcmF2ZXJzZTogJyk7XHJcbnZhciBnMiA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcclxuZzIuYWRkVmVydGV4KCd2MScpO1xyXG5nMi5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmcyLmFkZFZlcnRleCgndjMnKTtcclxuZzIuYWRkVmVydGV4KCd2NCcpO1xyXG5nMi5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5nMi5hZGRBcmMoJ3Y0JywgJ3YxJyk7XHJcbmcyLmFkZEFyYygndjInLCAndjEnKTtcclxuZzIuYWRkQXJjKCd2NScsICd2MycpO1xyXG5nMi5hZGRBcmMoJ3YyJywgJ3YzJyk7XHJcbmcyLmFkZEFyYygndjEnLCAndjMnKTtcclxuZzIuYWRkQXJjKCd2MycsICd2NCcpO1xyXG5nMi5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XHJcblxyXG5nMi5CRlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xyXG4gICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1t2XS5kYXRhKTtcclxufSk7XHJcblxyXG5jb25zb2xlLmxvZygnREZTOiBleHBlY3QgZmFsc2U6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RfcGF0aF9ERlMoJ3YxJywgJ3Y0JykpO1xyXG5jb25zb2xlLmxvZygnREZTOiBleHBlY3QgdHJ1ZTogJyArIGFkakxpc3RHcmFwaC5leGlzdF9wYXRoX0RGUygndjEnLCAndjInKSk7XHJcblxyXG5jb25zb2xlLmxvZygnQkZTIDogZXhwZWN0IGZhbHNlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0X3BhdGhfQkZTKCd2MScsICd2NCcpKTtcclxuY29uc29sZS5sb2coJ0JGUyA6ZXhwZWN0IHRydWU6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RfcGF0aF9CRlMoJ3YxJywgJ3YyJykpO1xyXG5cclxuXHJcblxyXG4vKlxyXG4g5Zu+55qE6L+e6YCa5oCn6Zeu6aKYXHJcblxyXG4g5peg5ZCR5Zu+55qE6L+e6YCa5YiG6YeP5LiO55Sf5oiQ5qCRXHJcblxyXG4gMSDml6DlkJHlm77nmoTov57pgJrliIbph4/lkoznlJ/miJDmoJFcclxuIOWvueS6juaXoOWQkeWbvu+8jOWvueWFtui/m+ihjOmBjeWOhuaXtu+8mlxyXG4g4peGIOiLpeaYr+i/numAmuWbvu+8muS7hemcgOS7juWbvuS4reS7u+S4gOmhtueCueWHuuWPke+8jOWwseiDveiuv+mXruWbvuS4reeahOaJgOaciemhtueCue+8m1xyXG4g4peGIOiLpeaYr+mdnui/numAmuWbvu+8mumcgOS7juWbvuS4reWkmuS4qumhtueCueWHuuWPkeOAguavj+asoeS7juS4gOS4quaWsOmhtueCueWHuuWPkeaJgOiuv+mXrueahOmhtueCuembhuW6j+WIl+aBsOWlveaYr+WQhOS4qui/numAmuWIhumHj+eahOmhtueCuembhu+8m1xyXG5cclxuIOKRtCDoi6VHPShWLEUp5piv5peg5ZCR6L+e6YCa5Zu+77yMIOmhtueCuembhuWSjOi+uembhuWIhuWIq+aYr1YoRykg77yMRShHKSDjgILoi6Xku45H5Lit5Lu75oSP54K55Ye65Y+R6YGN5Y6G5pe277yMIEUoRynooqvliIbmiJDkuKTkuKrkupLkuI3nm7jkuqTnmoTpm4blkIjvvJpcclxuIFQoRykg77ya6YGN5Y6G6L+H56iL5Lit5omA57uP6L+H55qE6L6555qE6ZuG5ZCI77ybXHJcbiBCKEcpIO+8mumBjeWOhui/h+eoi+S4reacque7j+i/h+eahOi+ueeahOmbhuWQiO+8m1xyXG4g5pi+54S277yaIEUoRyk9VChHKeKIqkIoRykg77yMVChHKeKIqUIoRyk9w5hcclxuIOaYvueEtu+8jOWbvkfigJk9KFYsIFQoRykp5pivR+eahOaegeWwj+i/numAmuWtkOWbvu+8jOS4lEfigJnmmK/kuIDmo7XmoJHjgIJH4oCZ56ew5Li65Zu+R+eahOS4gOajteeUn+aIkOagkeOAglxyXG4g5LuO5Lu75oSP54K55Ye65Y+R5oyJREZT566X5rOV5b6X5Yiw55Sf5oiQ5qCRR+KAmeensOS4uua3seW6puS8mOWFiOeUn+aIkOagke+8m+aMiUJGU+eul+azleW+l+WIsOeahEfigJnnp7DkuLrlub/luqbkvJjlhYjnlJ/miJDmoJHjgIJcclxuXHJcbiDikbUgIOiLpUc9KFYsRSnmmK/ml6DlkJHpnZ7ov57pgJrlm77vvIzlr7nlm77ov5vooYzpgY3ljobml7blvpfliLDoi6XlubLkuKrov57pgJrliIbph4/nmoTpobbngrnpm4bvvJpWMShHKSAsVjIoRykgLOKApixWbihHKeWSjOebuOW6lOaJgOe7j+i/h+eahOi+uembhu+8mlQxKEcpICxUMihHKSAsIOKApixUbihHKSDjgIJcclxuIOWImeWvueW6lOeahOmhtueCuembhuWSjOi+uembhueahOS6jOWFg+e7hO+8mkdpPShWaShHKSxUaShHKSlcclxuICgx4ommaeKJpm4p5piv5a+55bqU5YiG6YeP55qE55Sf5oiQ5qCR77yM5omA5pyJ6L+Z5Lqb55Sf5oiQ5qCR5p6E5oiQ5LqG5Y6f5p2l6Z2e6L+e6YCa5Zu+55qE55Sf5oiQ5qOu5p6X44CCXHJcblxyXG4g6K+05piO77ya5b2T57uZ5a6a5peg5ZCR5Zu+6KaB5rGC55S75Ye65YW25a+55bqU55qE55Sf5oiQ5qCR5oiW55Sf5oiQ5qOu5p6X5pe277yM5b+F6aG75YWI57uZ5Ye655u45bqU55qE6YK75o6l6KGo77yM54S25ZCO5omN6IO95qC55o2u6YK75o6l6KGo55S75Ye65YW25a+55bqU55qE55Sf5oiQ5qCR5oiW55Sf5oiQ5qOu5p6X44CCXHJcblxyXG5cclxuIDIgIOWbvueahOeUn+aIkOagkeWSjOeUn+aIkOajruael+eul+azlVxyXG5cclxuIOWvueWbvueahOa3seW6puS8mOWFiOaQnOe0oumBjeWOhkRGUyjmiJZCRlMp566X5rOV56iN5L2c5L+u5pS577yM5bCx5Y+v5b6X5Yiw5p6E6YCg5Zu+55qEREZT55Sf5oiQ5qCR566X5rOV44CCXHJcbiDlnKjnrpfms5XkuK3vvIzmoJHnmoTlrZjlgqjnu5PmnoTph4fnlKjlranlrZDigJTlhYTlvJ/ooajnpLrms5XjgILpppblhYjlu7rnq4vku47mn5DkuKrpobbngrlW5Ye65Y+R77yM5bu656uL5LiA5Liq5qCR57uT54K577yM54S25ZCO5YaN5YiG5Yir5LulVueahOmCu+aOpeeCueS4uui1t+Wni+eCue+8jOW7uueri+ebuOW6lOeahOWtkOeUn+aIkOagke+8jOW5tuWwhuWFtuS9nOS4ulYg57uT54K555qE5a2Q5qCR6ZO+5o6l5YiwVue7k+eCueS4iuOAguaYvueEtu+8jOeul+azleaYr+S4gOS4qumAkuW9kueul+azleOAglxyXG5cclxuICovXHJcblxyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZyhhZGpMaXN0R3JhcGguY3JlYXRlREZTRm9yZXN0KCkpO1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZUJGU0ZvcmVzdCgpKTtcclxuXHJcblxyXG5cclxuLypcclxuIOWcqOafkOWbvuS4re+8jOiLpeWIoOmZpOmhtueCuVbku6Xlj4pW55u45YWz55qE6L655ZCO77yM5Zu+55qE5LiA5Liq6L+e6YCa5YiG6YeP5YiG5Ymy5Li65Lik5Liq5oiW5Lik5Liq5Lul5LiK55qE6L+e6YCa5YiG6YeP77yM5YiZ56ew6aG254K5VuS4uuivpeWbvueahOS4gOS4quWFs+iKgueCueOAguS4gOS4quayoeacieWFs+iKgueCueeahOi/numAmuWbvuensOS4uumHjei/numAmuWbvuOAglxyXG4g5Zyo6YeN6L+e6YCa5Zu+5Lit77yM5Lu75oSP5LiA5a+56aG254K55LmL6Ze06Iez5bCR5a2Y5Zyo5Lik5p2h6Lev5b6E77yM5YiZ5YaN5Yig5Y675p+Q5Liq6aG254K55Y2z55u45YWz5ZCE6L655ZCO5Lmf5LiN56C05Z2P5Zu+55qE6L+e6YCa5oCn44CC6Iul5Zyo5Zu+55qE6L+e6YCa5Zu+5LiK5Yig5Y67a+S4quiKgueCueaJjeiDveegtOWdj+WbvueahOi/numAmuaAp++8jOWImeensEvkuLrmraTlm77nmoTov57pgJrluqbjgIJcclxuIOS7luS7rOW4uOW4uOWcqOmAmuS/oee9kee7nOeahOWbvuaIluiIquepuue9keS4reW6lOeUqO+8jEvotorlpKfvvIzns7vnu5/otornqLPlrprvvIzlj43kuYvvvIzmiJjkuonkuK3oi6XopoHmkafmr4HmlYzmlrnnmoTov5DovpPnur/vvIzlj6rpobvnoLTlnY/lhbbov5DovpPnvZHkuK3nmoTlhbPoioLngrnljbPlj6/jgIJcclxuICovXHJcblxyXG5cclxuXHJcbnZhciBhcnRpY3VsVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIFVERyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnQScpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdDJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRCcpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0UnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdGJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRycpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0gnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdJJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSicpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0snKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdMJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnTScpO1xyXG5cclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0MnKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0YnKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0wnKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdDJywgJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdEJywgJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdIJywgJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdNJywgJ0InKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdEJywgJ0UnKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0gnKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0knKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0snKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdIJywgJ0snKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdKJywgJ0wnKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdKJywgJ00nKTtcclxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdMJywgJ00nKTtcclxuXHJcbmFydGljdWxUZXN0LmZpbmRBcnRpY3VsKCk7XHJcblxyXG5cclxuLypcclxuIOacieWQkeaXoOeOr+WbvuWPiuWFtuW6lOeUqFxyXG5cclxuIOacieWQkeaXoOeOr+WbvihEaXJlY3RlZCBBY3ljbGluZyBHcmFwaCnvvJrmmK/lm77kuK3msqHmnInlm57ot68o546vKeeahOacieWQkeWbvuOAguaYr+S4gOexu+WFt+acieS7o+ihqOaAp+eahOWbvu+8jOS4u+imgeeUqOS6jueglOeptuW3peeoi+mhueebrueahOW3peW6j+mXrumimOOAgeW3peeoi+aXtumXtOi/m+W6pumXrumimOetieOAglxyXG5cclxuIOS4gOS4quW3peeoiyhwcm9qZWN0KemDveWPr+WIhuS4uuiLpeW5suS4quensOS4uua0u+WKqChhY3RpdmUp55qE5a2Q5bel56iLKOaIluW3peW6jynvvIzlkITkuKrlrZDlt6XnqIvlj5fliLDkuIDlrprnmoTmnaHku7bnuqbmnZ/vvJrmn5DkuKrlrZDlt6XnqIvlv4XpobvlvIDlp4vkuo7lj6bkuIDkuKrlrZDlt6XnqIvlrozmiJDkuYvlkI7vvJvmlbTkuKrlt6XnqIvmnInkuIDkuKrlvIDlp4vngrko6LW354K5KeWSjOS4gOS4que7iOeCueOAguS6uuS7rOWFs+W/g++8mlxyXG4g4peGIOW3peeoi+iDveWQpumhuuWIqeWujOaIkD/lvbHlk43lt6XnqIvnmoTlhbPplK7mtLvliqjmmK/ku4DkuYg/XHJcbiDil4Yg5Lyw566X5pW05Liq5bel56iL5a6M5oiQ5omA5b+F6aG755qE5pyA55+t5pe26Ze05piv5aSa5bCRP1xyXG5cclxuIOWvueW3peeoi+eahOa0u+WKqOWKoOS7peaKveixoe+8muWbvuS4remhtueCueihqOekuua0u+WKqO+8jOacieWQkei+ueihqOekuua0u+WKqOS5i+mXtOeahOS8mOWFiOWFs+ezu++8jOi/meagt+eahOacieWQkeWbvuensOS4uumhtueCueihqOekuua0u+WKqOeahOe9kShBY3Rpdml0eSBPbiBWZXJ0ZXggTmV0d29yayDvvIxBT1bnvZEpIOOAglxyXG5cclxuXHJcbiDmi5PmiZHmjpLluo9cclxuXHJcbiAxIOWumuS5iVxyXG4g5ouT5omR5o6S5bqPKFRvcG9sb2dpY2FsIFNvcnQpIO+8mueUseafkOS4qumbhuWQiOS4iueahOS4gOS4quWBj+W6j+W+l+WIsOivpembhuWQiOS4iueahOS4gOS4quWFqOW6j+eahOaTjeS9nOOAglxyXG5cclxuIOKXhiDpm4blkIjkuIrnmoTlhbPns7vvvJrpm4blkIhB5LiK55qE5YWz57O75piv5LuOQeWIsEHnmoTlhbPns7soQe+CtEEpIOOAglxyXG4g4peGIOWFs+ezu+eahOiHquWPjeaAp++8muiLpe+AomHiiIhB5pyJKGHvvIxhKeKIiFLvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+iHquWPjeeahOOAglxyXG4g4peGIOWFs+ezu+eahOWvueensOaAp++8muWmguaenOWvueS6jmHvvIxi4oiIQSDvvIzlj6ropoHmnIkoYe+8jGIp4oiIUuWwseaciShi77yMYSniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5a+556ew55qE44CCXHJcbiDil4Yg5YWz57O755qE5a+556ew5oCn5LiO5Y+N5a+556ew5oCn77ya5aaC5p6c5a+55LqOYe+8jGLiiIhBIO+8jOWPquimgeaciShh77yMYiniiIhS5bCx5pyJKGLvvIxhKeKIiFIg77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/lr7nnp7DnmoTjgILlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5LuF5b2TYT1i5pe25pyJKGHvvIxiKeKIiFLlkowoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WPjeWvueensOeahOOAglxyXG4g4peGIOWFs+ezu+eahOS8oOmAkuaAp++8muiLpWHvvIxi77yMY+KIiEHvvIzoi6UoYe+8jGIp4oiIUu+8jOW5tuS4lChi77yMYyniiIhSIO+8jOWImShh77yMYyniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5Lyg6YCS55qE44CCXHJcbiDil4Yg5YGP5bqP77ya6Iul6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/oh6rlj43nmoTvvIzlj43lr7nnp7DnmoTlkozkvKDpgJLnmoTvvIzliJnnp7BS5piv6ZuG5ZCIQeS4iueahOWBj+W6j+WFs+ezu+OAglxyXG4g4peGIOWFqOW6j++8muiuvlLmmK/pm4blkIhB5LiK55qE5YGP5bqP5YWz57O777yM74CiYe+8jGLiiIhB77yM5b+F5pyJYVJi5oiWYlJh77yMIOWImeensFLmmK/pm4blkIhB5LiK55qE5YWo5bqP5YWz57O744CCXHJcblxyXG4g5Y2z5YGP5bqP5piv5oyH6ZuG5ZCI5Lit5LuF5pyJ6YOo5YiG5YWD57Sg5LmL6Ze05Y+v5Lul5q+U6L6D77yM6ICM5YWo5bqP5piv5oyH6ZuG5ZCI5Lit5Lu75oSP5Lik5Liq5YWD57Sg5LmL6Ze06YO95Y+v5Lul5q+U6L6D44CCXHJcbiDlnKhBT1bnvZHkuK3vvIzoi6XmnInmnInlkJHovrk8aSwgaj7vvIzliJlp5pivaueahOebtOaOpeWJjempse+8jGrmmK9p55qE55u05o6l5ZCO57un77yb5o6o6ICM5bm/5LmL77yM6Iul5LuO6aG254K5aeWIsOmhtueCuWrmnInmnInlkJHot6/lvoTvvIzliJlp5pivaueahOWJjempse+8jGrmmK9p55qE5ZCO57un44CCXHJcbiDlnKhBT1bnvZHkuK3vvIzkuI3og73mnInnjq/vvIzlkKbliJnvvIzmn5DpobnmtLvliqjog73lkKbov5vooYzmmK/ku6Xoh6rouqvnmoTlrozmiJDkvZzkuLrliY3mj5DmnaHku7bjgIJcclxuIOajgOafpeaWueazle+8muWvueacieWQkeWbvueahOmhtueCuei/m+ihjOaLk+aJkeaOkuW6j++8jOiLpeaJgOaciemhtueCuemDveWcqOWFtuaLk+aJkeacieW6j+W6j+WIl+S4re+8jOWImeaXoOeOr+OAglxyXG4g5pyJ5ZCR5Zu+55qE5ouT5omR5o6S5bqP77ya5p6E6YCgQU9W572R5Lit6aG254K555qE5LiA5Liq5ouT5omR57q/5oCn5bqP5YiXKHbigJkxLHbigJkyLCDii68sduKAmW4p77yM5L2/5b6X6K+l57q/5oCn5bqP5YiX5LiN5LuF5L+d5oyB5Y6f5p2l5pyJ5ZCR5Zu+5Lit6aG254K55LmL6Ze055qE5LyY5YWI5YWz57O777yM6ICM5LiU5a+55Y6f5Zu+5Lit5rKh5pyJ5LyY5YWI5YWz57O755qE6aG254K55LmL6Ze05Lmf5bu656uL5LiA56eNKOS6uuS4uueahCnkvJjlhYjlhbPns7vjgIJcclxuXHJcbiAyIOaLk+aJkeaOkuW6j+eul+azlVxyXG4g566X5rOV5oCd5oOzXHJcblxyXG4g4pGgIOWcqEFPVue9keS4remAieaLqeS4gOS4quayoeacieWJjempseeahOmhtueCueS4lOi+k+WHuu+8m1xyXG4g4pGhIOWcqEFPVue9keS4reWIoOmZpOivpemhtueCueS7peWPiuS7juivpemhtueCueWHuuWPkeeahCjku6Xor6XpobbngrnkuLrlsL7nmoTlvKcp5omA5pyJ5pyJ5ZCR5bynKOi+uSkg77ybXHJcbiDikaIg6YeN5aSN4pGg44CB4pGh77yM55u05Yiw5Zu+5Lit5YWo6YOo6aG254K56YO95bey6L6T5Ye6KOWbvuS4reaXoOeOrynmiJblm77kuK3kuI3lrZjlnKjml6DliY3pqbHnmoTpobbngrko5Zu+5Lit5b+F5pyJ546vKeOAglxyXG5cclxuIDMgIOeul+azleWunueOsOivtOaYjlxyXG4g4peGIOmHh+eUqOato+mCu+aOpemTvuS9nOS4ukFPVue9keeahOWtmOWCqOe7k+aehO+8m1xyXG4g4peGIOiuvueri+WghuagiO+8jOeUqOadpeaaguWtmOWFpeW6puS4ujDnmoTpobbngrnvvJtcclxuIOKXhiDliKDpmaTpobbngrnku6XlroPkuLrlsL7nmoTlvKfvvJrlvKflpLTpobbngrnnmoTlhaXluqblh48x44CCXHJcblxyXG4g5pW05Liq566X5rOV55qE5pe26Ze05aSN5p2C5bqm5pivTyhuK2UpIOOAglxyXG5cclxuICovXHJcblxyXG52YXIgdG9wb2xvZ2ljVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2MicpO1xyXG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjMnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2NScpO1xyXG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjYnKTtcclxuXHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2MicsICd2MScpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjQnLCAndjEnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YzJywgJ3YxJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2MicsICd2MycpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjMnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y0JywgJ3Y2Jyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2NCcpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjYnKTtcclxuXHJcbmNvbnNvbGUubG9nKCd0b3BvbG9naWNTb3J0OiAnKTtcclxuY29uc29sZS5sb2codG9wb2xvZ2ljVGVzdC50b3BvbG9naWNTb3J0KCkpO1xyXG5cclxuXHJcblxyXG4vKlxyXG4g5YWz6ZSu6Lev5b6EKENyaXRpY2FsIFBhdGgpXHJcblxyXG4g5LiOQU9W572R55u45a+55bqU55qE5pivQU9FKEFjdGl2aXR5IE9uIEVkZ2UpIO+8jOaYr+i+ueihqOekuua0u+WKqOeahOacieWQkeaXoOeOr+Wbvu+8jOWmguWbvjctMjTmiYDnpLrjgILlm77kuK3pobbngrnooajnpLrkuovku7YoRXZlbnQp77yM5q+P5Liq5LqL5Lu26KGo56S65Zyo5YW25YmN55qE5omA5pyJ5rS75Yqo5bey57uP5a6M5oiQ77yM5YW25ZCO55qE5rS75Yqo5Y+v5Lul5byA5aeL77yb5byn6KGo56S65rS75Yqo77yM5byn5LiK55qE5p2D5YC86KGo56S655u45bqU5rS75Yqo5omA6ZyA55qE5pe26Ze05oiW6LS555So44CCXHJcblxyXG4gMSDkuI5BT0XmnInlhbPnmoTnoJTnqbbpl67pophcclxuIOKXhiDlrozmiJDmlbTkuKrlt6XnqIvoh7PlsJHpnIDopoHlpJrlsJHml7bpl7Q/XHJcbiDil4Yg5ZOq5Lqb5rS75Yqo5piv5b2x5ZON5bel56iL6L+b5bqmKOi0ueeUqCnnmoTlhbPplK4/XHJcbiDlt6XnqIvlrozmiJDmnIDnn63ml7bpl7TvvJrku47otbfngrnliLDnu4jngrnnmoTmnIDplb/ot6/lvoTplb/luqYo6Lev5b6E5LiK5ZCE5rS75Yqo5oyB57ut5pe26Ze05LmL5ZKMKSDjgILplb/luqbmnIDplb/nmoTot6/lvoTnp7DkuLrlhbPplK7ot6/lvoTvvIzlhbPplK7ot6/lvoTkuIrnmoTmtLvliqjnp7DkuLrlhbPplK7mtLvliqjjgILlhbPplK7mtLvliqjmmK/lvbHlk43mlbTkuKrlt6XnqIvnmoTlhbPplK7jgIJcclxuIOiuvnYw5piv6LW354K577yM5LuOdjDliLB2aeeahOacgOmVv+i3r+W+hOmVv+W6puensOS4uuS6i+S7tnZp55qE5pyA5pep5Y+R55Sf5pe26Ze077yM5Y2z5piv5LuldmnkuLrlsL7nmoTmiYDmnInmtLvliqjnmoTmnIDml6nlj5HnlJ/ml7bpl7TjgIJcclxuIOiLpea0u+WKqGFp5piv5bynPGosIGs+77yM5oyB57ut5pe26Ze05pivZHV0KDxqLCBrPinvvIzorr7vvJpcclxuIOKXhiBlKGkp77ya6KGo56S65rS75YqoYWnnmoTmnIDml6nlvIDlp4vml7bpl7TvvJtcclxuIOKXhiBsKGkp77ya5Zyo5LiN5b2x5ZON6L+b5bqm55qE5YmN5o+Q5LiL77yM6KGo56S65rS75YqoYWnnmoTmnIDmmZrlvIDlp4vml7bpl7TvvJsg5YiZbChpKS1lKGkp6KGo56S65rS75YqoYWnnmoTml7bpl7TkvZnph4/vvIzoi6VsKGkpLWUoaSk9MO+8jOihqOekuua0u+WKqGFp5piv5YWz6ZSu5rS75Yqo44CCXHJcbiDil4YgdmUoaSnvvJrooajnpLrkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtO+8jOWNs+S7jui1t+eCueWIsOmhtueCuXZp55qE5pyA6ZW/6Lev5b6E6ZW/5bqm77ybXHJcbiDil4YgdmwoaSnvvJrooajnpLrkuovku7Z2aeeahOacgOaZmuWPkeeUn+aXtumXtOOAguWImeacieS7peS4i+WFs+ezu++8mlxyXG4gZShpKT12ZShqKVxyXG4gbChpKT0gdmwoayktZHV0KDxqLCBrPilcclxuIDAgICAgaj0w77yM6KGo56S6dmrmmK/otbfngrlcclxuIHZlKGopPVxyXG4gTWF4e3ZlKGkpK2R1dCg8aSwgaj4pfDx2aSwgdmo+5piv572R5Lit55qE5bynfVxyXG5cclxuIOWQq+S5ieaYr++8mua6kOeCueS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtOiuvuS4ujDvvJvpmaTmupDngrnlpJbvvIzlj6rmnInov5vlhaXpobbngrl2aueahOaJgOacieW8p+aJgOS7o+ihqOeahOa0u+WKqOWFqOmDqOe7k+adn+WQju+8jOS6i+S7tnZq5omN6IO95Y+R55Sf44CC5Y2z5Y+q5pyJdmrnmoTmiYDmnInliY3pqbHkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtHZlKGkp6K6h566X5Ye65p2l5ZCO77yM5omN6IO96K6h566XdmUoaikg44CCXHJcbiDmlrnms5XmmK/vvJrlr7nmiYDmnInkuovku7bov5vooYzmi5PmiZHmjpLluo/vvIznhLblkI7kvp3mrKHmjInmi5PmiZHpobrluo/orqHnrpfmr4/kuKrkuovku7bnmoTmnIDml6nlj5HnlJ/ml7bpl7TjgIJcclxuIHZlKG4tMSkgICAgaj1uLTHvvIzooajnpLp2auaYr+e7iOeCuVxyXG4gdmwoaik9XHJcbiBNaW57dmwoayktZHV0KDxqLCBrPil8PHZqLCB2az7mmK/nvZHkuK3nmoTlvKd9XHJcbiDlkKvkuYnmmK/vvJrlj6rmnIl2aueahOaJgOacieWQjue7p+S6i+S7tnZr55qE5pyA5pma5Y+R55Sf5pe26Ze0dmwoaynorqHnrpflh7rmnaXlkI7vvIzmiY3og73orqHnrpd2bChqKSDjgIJcclxuIOaWueazleaYr++8muaMieaLk+aJkeaOkuW6j+eahOmAhumhuuW6j++8jOS+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtOOAglxyXG5cclxuXHJcbiAyIOaxgkFPReS4reWFs+mUrui3r+W+hOWSjOWFs+mUrua0u+WKqFxyXG4g4pG0IOeul+azleaAneaDs1xyXG4g4pGgIOWIqeeUqOaLk+aJkeaOkuW6j+axguWHukFPRee9keeahOS4gOS4quaLk+aJkeW6j+WIl++8m1xyXG4g4pGhICDku47mi5PmiZHmjpLluo/nmoTluo/liJfnmoTnrKzkuIDkuKrpobbngrko5rqQ54K5KeW8gOWni++8jOaMieaLk+aJkemhuuW6j+S+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZlKGkpIO+8m1xyXG4g4pGiICDku47mi5PmiZHmjpLluo/nmoTluo/liJfnmoTmnIDlkI7kuIDkuKrpobbngrko5rGH54K5KeW8gOWni++8jOaMiemAhuaLk+aJkemhuuW6j+S+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtHZsKGkpIO+8m1xyXG5cclxuIOiuvkFPRee9keaciW7kuKrkuovku7bvvIxl5Liq5rS75Yqo77yM5YiZ566X5rOV55qE5Li76KaB5omn6KGM5piv77yaXHJcbiDil4Yg6L+b6KGM5ouT5omR5o6S5bqP77ya5pe26Ze05aSN5p2C5bqm5pivTyhuK2UpIO+8m1xyXG4g4peGIOaxguavj+S4quS6i+S7tueahHZl5YC85ZKMdmzlgLzvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg77ybXHJcbiDil4Yg5qC55o2udmXlgLzlkox2bOWAvOaJvuWFs+mUrua0u+WKqO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcclxuIOWboOatpO+8jOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08obitlKSDjgIJcclxuXHJcbiAqL1xyXG5cclxuXHJcbnZhciBjcml0aWNhbFBhdGhUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjAnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MicpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjMnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NScpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjYnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y3Jyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2OCcpO1xyXG5cclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3YxJywgJ3YwJywgMyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MicsICd2MCcsIDEwKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y0JywgJ3YxJywgMTMpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjQnLCAndjInLCAxMik7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MycsICd2MScsIDkpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjUnLCAndjInLCA3KTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y3JywgJ3Y0JywgNik7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NycsICd2MycsIDQpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjcnLCAndjUnLCAxMSk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NicsICd2MycsIDgpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjgnLCAndjcnLCA1KTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y4JywgJ3Y2JywgMik7XHJcblxyXG5jcml0aWNhbFBhdGhUZXN0LmNyaXRpY2FsUGF0aCgpO1xyXG5cclxuXHJcblxyXG5cclxudmFyIGRpalRlc3QgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCBbXSwgMCwgMCwgRE4pO1xyXG5cclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzAnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzEnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzInKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzMnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzQnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzUnKTtcclxuXHJcbmRpalRlc3QuYWRkQXJjKCcxJywgJzAnLCAyMCk7XHJcbmRpalRlc3QuYWRkQXJjKCc0JywgJzAnLCAxMCk7XHJcbmRpalRlc3QuYWRkQXJjKCcyJywgJzAnLCA2MCk7XHJcbmRpalRlc3QuYWRkQXJjKCc1JywgJzAnLCA2NSk7XHJcbmRpalRlc3QuYWRkQXJjKCcyJywgJzEnLCAzMCk7XHJcbmRpalRlc3QuYWRkQXJjKCczJywgJzInLCA0MCk7XHJcbmRpalRlc3QuYWRkQXJjKCcyJywgJzUnLCAxNSk7XHJcbmRpalRlc3QuYWRkQXJjKCc1JywgJzQnLCAyMCk7XHJcbmRpalRlc3QuYWRkQXJjKCc0JywgJzMnLCAzNSk7XHJcbmRpalRlc3QuYWRkQXJjKCczJywgJzEnLCA3MCk7XHJcblxyXG5kaWpUZXN0LnNob3J0ZXN0UGF0aF9EaWprc3RyYSgwKTtcclxuXHJcblxyXG4oZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICog6L6T5Ye65pyJ5ZCR5peg546v5Zu+5b2i5byP6KGo56S655qE6YCG5rOi5YWw5byPXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5pQm9MYW5fREFHKGdyYXBoKXtcclxuICAgICAgICBncmFwaC5jb3VudEluZGVncmVlKCk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGdyYXBoLnZleG51bTsgKytpKXtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5pyJ5ZCR5peg546v5Zu+55qE5qC5XHJcbiAgICAgICAgICAgIGlmKGdyYXBoLnZlcnRpY2VzW2ldLmluZGVncmVlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcmludE5pQm9MYW4oZ3JhcGgsIGkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcmludE5pQm9MYW4oZ3JhcGgsIGkpe1xyXG4gICAgICAgIGxldCBjID0gZ3JhcGgudmVydGljZXNbaV0uZGF0YTtcclxuICAgICAgICBsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjO1xyXG5cclxuICAgICAgICAvLyDlrZDooajovr7lvI9cclxuICAgICAgICBpZihwKSB7XHJcbiAgICAgICAgICAgIHByaW50TmlCb0xhbihncmFwaCwgcC5hZGpWZXgpO1xyXG4gICAgICAgICAgICBwcmludE5pQm9MYW4oZ3JhcGgsIHAubmV4dEFyYy5hZGpWZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYyArICcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe7meacieWQkeaXoOeOr+WbvuihqOekuueahOihqOi+vuW8j+axguWAvFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBldmFsdWF0ZV9EQUcoZ3JhcGgpe1xyXG4gICAgICAgIGdyYXBoLmNvdW50SW5kZWdyZWUoKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZ3JhcGgudmV4bnVtOyArK2kpe1xyXG4gICAgICAgICAgICBpZighZ3JhcGgudmVydGljZXNbaV0uaW5kZWdyZWUpIHJldHVybiBldmFsdWF0ZV9pbXAoZ3JhcGgsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBldmFsdWF0ZV9pbXAoZywgaSl7XHJcbiAgICAgICAgaWYoL15cXGQrJC8udGVzdChnLnZlcnRpY2VzW2ldLmRhdGEpKSByZXR1cm4gZy52ZXJ0aWNlc1tpXS5kYXRhO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcCA9IGcudmVydGljZXNbaV0uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgIGxldCB2MSA9IGV2YWx1YXRlX2ltcChnLCBwLmFkalZleCk7XHJcbiAgICAgICAgICAgIGxldCB2MiA9IGV2YWx1YXRlX2ltcChnLCBwLm5leHRBcmMuYWRqVmV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZSh2MSwgZy52ZXJ0aWNlc1tpXS5kYXRhLCB2Mik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZShhLCBvcGVyYXRpb24sIGIpe1xyXG4gICAgICAgIC8vIOWBt+S4gOS4i+aHki4uXHJcbiAgICAgICAgcmV0dXJuIGV2YWwoYSArIG9wZXJhdGlvbiArIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICgoMSArIDIpICogKDIgKiAoMyArIDQpKSArICgzICsgNCkgKiA1KSAqICgoMyArIDQpICogNSlcclxuICAgIGxldCBkYWcgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XHJcblxyXG4gICAgbGV0IGExID0gbmV3IFN0cmluZygnKicpO1xyXG4gICAgbGV0IGEyID0gbmV3IFN0cmluZygnKycpO1xyXG4gICAgbGV0IGEzID0gbmV3IFN0cmluZygnKicpO1xyXG4gICAgbGV0IGE0ID0gbmV3IFN0cmluZygnKicpO1xyXG4gICAgbGV0IGE1ID0gbmV3IFN0cmluZygnKycpO1xyXG4gICAgbGV0IGE2ID0gbmV3IFN0cmluZygnKicpO1xyXG4gICAgbGV0IGE3ID0gbmV3IFN0cmluZygnKycpO1xyXG5cclxuICAgIC8vIDEyXHJcbiAgICBkYWcuYWRkVmVydGV4KGExKTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTIpO1xyXG4gICAgZGFnLmFkZFZlcnRleChhMyk7XHJcbiAgICBkYWcuYWRkVmVydGV4KGE0KTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTUpO1xyXG4gICAgZGFnLmFkZFZlcnRleChhNik7XHJcbiAgICBkYWcuYWRkVmVydGV4KGE3KTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoMSk7XHJcbiAgICBkYWcuYWRkVmVydGV4KDIpO1xyXG4gICAgZGFnLmFkZFZlcnRleCgzKTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoNCk7XHJcbiAgICBkYWcuYWRkVmVydGV4KDUpO1xyXG5cclxuICAgIC8vIDE0XHJcbiAgICBkYWcuYWRkQXJjKGEyLCBhMSk7XHJcbiAgICBkYWcuYWRkQXJjKGE0LCBhMSk7XHJcbiAgICBkYWcuYWRkQXJjKGEzLCBhMik7XHJcbiAgICBkYWcuYWRkQXJjKGE0LCBhMik7XHJcbiAgICBkYWcuYWRkQXJjKGE1LCBhMyk7XHJcbiAgICBkYWcuYWRkQXJjKGE2LCBhMyk7XHJcbiAgICBkYWcuYWRkQXJjKGE3LCBhNik7XHJcbiAgICBkYWcuYWRkQXJjKGE3LCBhNCk7XHJcbiAgICBkYWcuYWRkQXJjKDUsIGE0KTtcclxuICAgIGRhZy5hZGRBcmMoMSwgYTUpO1xyXG4gICAgZGFnLmFkZEFyYygyLCBhNSk7XHJcbiAgICBkYWcuYWRkQXJjKDIsIGE2KTtcclxuICAgIGRhZy5hZGRBcmMoMywgYTcpO1xyXG4gICAgZGFnLmFkZEFyYyg0LCBhNyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ25pQm9MYW5fREFHOiAnKTtcclxuICAgIG5pQm9MYW5fREFHKGRhZyk7XHJcbiAgICBjb25zb2xlLmxvZygnZXZhbHVhdGVfREFHOiAnICsgZXZhbHVhdGVfREFHKGRhZykpOyAgLy8gMjY5NVxyXG59KSgpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9HcmFwaC9BZGphY2VuY3lMaXN0R3JhcGguanNcbiAqKi8iLCIvKiBjcmVhdGUgYnkgTHVrZSAqL1xyXG4vKipcclxuICog5Zu+KEdyYXBoKVxyXG4gKlxyXG4gKiDlm74oR3JhcGgp5piv5LiA56eN5q+U57q/5oCn6KGo5ZKM5qCR5pu05Li65aSN5p2C55qE5pWw5o2u57uT5p6E44CCXHJcbiAqXHJcbiAqIOe6v+aAp+e7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueS4gOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOmZpOesrOS4gOS4quWSjOacgOWQjuS4gOS4quWFg+e0oOWklu+8jOS7u+S9leS4gOS4quWFg+e0oOmDveacieWUr+S4gOeahOS4gOS4quebtOaOpeWJjempseWSjOebtOaOpeWQjue7p+OAglxyXG4gKlxyXG4gKiDmoJHnu5PmnoTvvJrmmK/noJTnqbbmlbDmja7lhYPntKDkuYvpl7TnmoTkuIDlr7nlpJrnmoTlhbPns7vjgILlnKjov5nnp43nu5PmnoTkuK3vvIzmr4/kuKrlhYPntKDlr7nkuIso5bGCKeWPr+S7peaciTDkuKrmiJblpJrkuKrlhYPntKDnm7jogZTns7vvvIzlr7nkuIoo5bGCKeWPquacieWUr+S4gOeahOS4gOS4quWFg+e0oOebuOWFs++8jOaVsOaNruWFg+e0oOS5i+mXtOacieaYjuaYvueahOWxguasoeWFs+ezu+OAglxyXG4gKlxyXG4gKiDlm77nu5PmnoTvvJrmmK/noJTnqbbmlbDmja7lhYPntKDkuYvpl7TnmoTlpJrlr7nlpJrnmoTlhbPns7vjgILlnKjov5nnp43nu5PmnoTkuK3vvIzku7vmhI/kuKTkuKrlhYPntKDkuYvpl7Tlj6/og73lrZjlnKjlhbPns7vjgILljbPnu5PngrnkuYvpl7TnmoTlhbPns7vlj6/ku6XmmK/ku7vmhI/nmoTvvIzlm77kuK3ku7vmhI/lhYPntKDkuYvpl7Tpg73lj6/og73nm7jlhbPjgIJcclxuICpcclxuICog5Zu+55qE5bqU55So5p6B5Li65bm/5rOb77yM5bey5riX5YWl5Yiw6K+45aaC6K+t6KiA5a2m44CB6YC76L6R5a2m44CB54mp55CG44CB5YyW5a2m44CB55S16K6v44CB6K6h566X5py656eR5a2m5Lul5Y+K5pWw5a2m55qE5YW25a6D5YiG5pSv44CCXHJcbiAqXHJcbiAqIOWbvueahOWfuuacrOamguW/tVxyXG4gKlxyXG4gKiDkuIDkuKrlm74oRynlrprkuYnkuLrkuIDkuKrlgbblr7koVixFKSDvvIzorrDkuLpHPShWLEUpIOOAguWFtuS4re+8miBW5piv6aG254K5KFZlcnRleCnnmoTpnZ7nqbrmnInpmZDpm4blkIjvvIzorrDkuLpWKEcp77ybReaYr+aXoOW6j+mbhlYmVueahOS4gOS4quWtkOmbhu+8jOiusOS4ukUoRykg77yM5YW25YWD57Sg5piv5Zu+55qE5bynKEFyYynjgIJcclxuICog5bCG6aG254K56ZuG5ZCI5Li656m655qE5Zu+56ew5Li656m65Zu+44CC5YW25b2i5byP5YyW5a6a5LmJ5Li677yaXHJcbiBHPShWIO+8jEUpXHJcbiBWPXt2fHbiiIhkYXRhIG9iamVjdH1cclxuIEU9ezx2LHc+fCB2LHfiiIhW4oincCh2LHcpfVxyXG4gUCh2LHcp6KGo56S65LuO6aG254K5duWIsOmhtueCuXfmnInkuIDmnaHnm7TmjqXpgJrot6/jgIJcclxuICpcclxuICog5bynKEFyYykg77ya6KGo56S65Lik5Liq6aG254K5duWSjHfkuYvpl7TlrZjlnKjkuIDkuKrlhbPns7vvvIznlKjpobbngrnlgbblr7k8dix3PuihqOekuuOAgumAmuW4uOagueaNruWbvueahOmhtueCueWBtuWvueWwhuWbvuWIhuS4uuacieWQkeWbvuWSjOaXoOWQkeWbvuOAglxyXG4gKiDmnInlkJHlm74oRGlncmFwaCnvvJog6Iul5Zu+R+eahOWFs+ezu+mbhuWQiEUoRynkuK3vvIzpobbngrnlgbblr7k8dix3PueahHblkox35LmL6Ze05piv5pyJ5bqP55qE77yM56ew5Zu+R+aYr+acieWQkeWbvuOAglxyXG4gKiAgIOWcqOacieWQkeWbvuS4re+8jOiLpSA8dix3PuKIiEUoRykg77yM6KGo56S65LuO6aG254K5duWIsOmhtueCuXfmnInkuIDmnaHlvKfjgIIg5YW25Lit77yaduensOS4uuW8p+Wwvih0YWlsKeaIluWni+eCuShpbml0aWFsIG5vZGUp77yMd+ensOS4uuW8p+WktChoZWFkKeaIlue7iOeCuSh0ZXJtaW5hbCBub2RlKSDjgIJcclxuICog5peg5ZCR5Zu+KFVuZGlncmFwaCnvvJog6Iul5Zu+R+eahOWFs+ezu+mbhuWQiEUoRynkuK3vvIzpobbngrnlgbblr7k8dix3PueahHblkox35LmL6Ze05piv5peg5bqP55qE77yM56ew5Zu+R+aYr+aXoOWQkeWbvuOAglxyXG4gKiAgIOWcqOaXoOWQkeWbvuS4re+8jOiLpe+Aojx2LHc+4oiIRShHKSDvvIzmnIk8dyx2PuKIiEUoRykg77yM5Y2zRShHKeaYr+WvueensO+8jOWImeeUqOaXoOW6j+WvuSh2LHcpIOihqOekunblkox35LmL6Ze055qE5LiA5p2h6L65KEVkZ2Up77yM5Zug5q2kKHYsdykg5ZKMKHcsdinku6PooajnmoTmmK/lkIzkuIDmnaHovrnjgIJcclxuICpcclxuICog5L6LMe+8muiuvuacieacieWQkeWbvkcx5ZKM5peg5ZCR5Zu+RzLvvIzlvaLlvI/ljJblrprkuYnliIbliKvmmK/vvJpcclxuIEcxPShWMSDvvIxFMSlcclxuIFYxPXthLGIsYyxkLGV9XHJcbiBFMT17PGEsYj4sPGEsYz4sIDxhLGU+LDxjLGQ+LDxjLGU+ICw8ZCxhPiw8ZCxiPiw8ZSxkPn1cclxuIEcyPShWMiDvvIxFMilcclxuIFYyPXthLGIsYyxkfVxyXG4gRTI9eyhhLGIpLCAoYSxjKSwgKGEsZCksIChiLGQpLCAoYixjKSwgKGMsZCl9XHJcbiAqXHJcbiAqIOWujOWFqOaXoOWQkeWbvu+8muWvueS6juaXoOWQkeWbvu+8jOiLpeWbvuS4remhtueCueaVsOS4um4g77yM55SoZeihqOekuui+ueeahOaVsOebru+8jOWImWUg4oiIWzDvvIxuKG4tMSkvMl0g44CC5YW35pyJbihuLTEpLzLmnaHovrnnmoTml6DlkJHlm77np7DkuLrlrozlhajml6DlkJHlm77jgIJcclxuIOWujOWFqOaXoOWQkeWbvuWPpuWklueahOWumuS5ieaYr++8mlxyXG4gKiDlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZqIOKIiFYg77yM5b2TdmniiaB2auaXtu+8jOaciSh2aSAsdmop4oiIRe+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeaXoOWQkei+ue+8jOi/meagt+eahOaXoOWQkeWbvuensOS4uuWujOWFqOaXoOWQkeWbvuOAglxyXG4gKlxyXG4gKiDlrozlhajmnInlkJHlm77vvJrlr7nkuo7mnInlkJHlm77vvIzoi6Xlm77kuK3pobbngrnmlbDkuLpuIO+8jOeUqGXooajnpLrlvKfnmoTmlbDnm67vvIzliJll4oiIWzDvvIxuKG4tMSldIOOAguWFt+aciW4obi0xKeadoei+ueeahOacieWQkeWbvuensOS4uuWujOWFqOacieWQkeWbvuOAglxyXG4g5a6M5YWo5pyJ5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXHJcbiAqIOWvueS6juacieWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZp77yMdmriiIhWIO+8jOW9k3ZpIOKJoHZq5pe277yM5pyJPHZpICx2aj7iiIhF4oinPHZqICwgdmkgPuKIiEUg77yM5Y2z5Zu+5Lit5Lu75oSP5Lik5Liq5LiN5ZCM55qE6aG254K56Ze06YO95pyJ5LiA5p2h5byn77yM6L+Z5qC355qE5pyJ5ZCR5Zu+56ew5Li65a6M5YWo5pyJ5ZCR5Zu+44CCXHJcbiAqXHJcbiAqIOacieW+iOWwkei+ueaIluW8p+eahOWbvu+8iGU8buOPkm7vvInnmoTlm77np7DkuLrnqIDnlo/lm77vvIzlj43kuYvnp7DkuLrnqKDlr4blm77jgIJcclxuICog5p2DKFdlaWdodCnvvJrkuI7lm77nmoTovrnlkozlvKfnm7jlhbPnmoTmlbDjgILmnYPlj6/ku6XooajnpLrku47kuIDkuKrpobbngrnliLDlj6bkuIDkuKrpobbngrnnmoTot53nprvmiJbogJfotLnjgIJcclxuICpcclxuICog5a2Q5Zu+5ZKM55Sf5oiQ5a2Q5Zu+77ya6K6+5pyJ5Zu+Rz0oVu+8jEUp5ZKMR+KAmT0oVuKAme+8jEXigJkp77yM6IulVuKAmeKIiFbkuJRF4oCZ4oiIRSDvvIzliJnnp7Dlm75H4oCZ5pivR+eahOWtkOWbvu+8m+iLpVbigJk9VuS4lEXigJniiIhF77yM5YiZ56ew5Zu+R+KAmeaYr0fnmoTkuIDkuKrnlJ/miJDlrZDlm77jgIJcclxuICog6aG254K555qE6YK75o6lKEFkamFjZW50Ke+8muWvueS6juaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpei+uSh2LHcp4oiIRe+8jOWImeensOmhtueCuXblkox3IOS6kuS4uumCu+aOpeeCue+8jOWNs3blkox355u46YK75o6l44CC6L65KHYsdynkvp3pmYQoaW5jaWRlbnQp5LiO6aG254K5duWSjHcg44CCXHJcbiAqIOWvueS6juacieWQkeWbvkc9KFYg77yMRSnvvIzoi6XmnInlkJHlvKc8dix3PuKIiEXvvIzliJnnp7Dpobbngrl2IOKAnOmCu+aOpeWIsOKAnemhtueCuXfvvIzpobbngrl3IOKAnOmCu+aOpeiHquKAnemhtueCuXYg77yM5bynPHYsdz4g5LiO6aG254K5duWSjHcg4oCc55u45YWz6IGU4oCdIOOAglxyXG4gKlxyXG4gKiDpobbngrnnmoTluqbjgIHlhaXluqbjgIHlh7rluqbvvJrlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIwg74CidmniiIhW77yM5Zu+R+S4reS+nemZhOS6jnZp55qE6L6555qE5pWw55uu56ew5Li66aG254K5dmnnmoTluqYoZGVncmVlKe+8jOiusOS4ulREKHZpKeOAglxyXG4g5pi+54S277yM5Zyo5peg5ZCR5Zu+5Lit77yM5omA5pyJ6aG254K55bqm55qE5ZKM5piv5Zu+5Lit6L6555qEMuWAjeOAgiDljbMgICDiiJFURCh2aSk9MmUgICAgICBpPTEsIDIsIOKApiwgbiDvvIxl5Li65Zu+55qE6L655pWw44CCXHJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDiiIhWIO+8jOWbvkfkuK3ku6V2aeS9nOS4uui1t+eCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlh7rluqYoT3V0ZGVncmVlKe+8jOiusOS4uk9EKHZpKSDvvJvku6V2aeS9nOS4uue7iOeCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlhaXluqYoSW5kZWdyZWUp77yM6K6w5Li6SUQodmkpIOOAgumhtueCuXZp55qE5Ye65bqm5LiO5YWl5bqm5LmL5ZKM56ew5Li6dmnnmoTluqbvvIzorrDkuLpURCh2aSkg44CC5Y2zXHJcbiBURCh2aSk9T0QodmkpK0lEKHZpKVxyXG4gKlxyXG4gKiDot6/lvoQoUGF0aCnjgIHot6/lvoTplb/luqbjgIHlm57ot68oQ3ljbGUpIO+8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpeS7jumhtueCuXZp57uP6L+H6Iul5bmy5p2h6L656IO95Yiw6L6+dmrvvIznp7Dpobbngrl2aeWSjHZq5piv6L+e6YCa55qE77yM5Y+I56ew6aG254K5dmnliLB2auaciei3r+W+hOOAglxyXG4g5a+55pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM5LuO6aG254K5dmnliLB2auacieacieWQkei3r+W+hO+8jOaMh+eahOaYr+S7jumhtueCuXZp57uP6L+H6Iul5bmy5p2h5pyJ5ZCR6L65KOW8pynog73liLDovr52auOAglxyXG4g5oiW6Lev5b6E5piv5Zu+R+S4rei/nuaOpeS4pOmhtueCueS5i+mXtOaJgOe7j+i/h+eahOmhtueCueW6j+WIl+OAguWNs1xyXG4gUGF0aD12aTB2aTHigKZ2aW0g77yMdmlq4oiIVuS4lCh2aWotMSwgdmlqKeKIiEUgICBqPTEsMiwg4oCmLG1cclxuIOaIllxyXG4gUGF0aD12aTB2aTEg4oCmdmltIO+8jHZpauKIiFbkuJQ8dmlqLTEsIHZpaj7iiIhFICBqPTEsMiwg4oCmLG1cclxuIOi3r+W+hOS4iui+ueaIluacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66K+l6Lev5b6E55qE6ZW/5bqm44CCXHJcbiDlnKjkuIDmnaHot6/lvoTkuK3vvIzoi6XmsqHmnInph43lpI3nm7jlkIznmoTpobbngrnvvIzor6Xot6/lvoTnp7DkuLrnroDljZXot6/lvoTvvJvnrKzkuIDkuKrpobbngrnlkozmnIDlkI7kuIDkuKrpobbngrnnm7jlkIznmoTot6/lvoTnp7DkuLrlm57ot68o546vKe+8m+WcqOS4gOS4quWbnui3r+S4re+8jOiLpemZpOesrOS4gOS4quS4juacgOWQjuS4gOS4qumhtueCueWklu+8jOWFtuS9memhtueCueS4jemHjeWkjeWHuueOsOeahOWbnui3r+ensOS4uueugOWNleWbnui3ryjnroDljZXnjq8p44CCXHJcbiAqXHJcbiAqIOi/numAmuWbvuOAgeWbvueahOi/numAmuWIhumHj++8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZpIO+8jHZqIOKIiFbvvIx2aeWSjHZq6YO95piv6L+e6YCa55qE77yM5YiZ56ew5Zu+R+aYr+i/numAmuWbvu+8jOWQpuWImeensOS4uumdnui/numAmuWbvuOAguiLpUfmmK/pnZ7ov57pgJrlm77vvIzliJnmnoHlpKfnmoTov57pgJrlrZDlm77np7DkuLpH55qE6L+e6YCa5YiG6YeP44CCXHJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDvvIx2aiDiiIhW77yM6YO95pyJ5LuldmnkuLrotbfngrnvvIwgdmog5Li657uI54K55Lul5Y+K5LuldmrkuLrotbfngrnvvIx2aeS4uue7iOeCueeahOacieWQkei3r+W+hO+8jOensOWbvkfmmK/lvLrov57pgJrlm77vvIzlkKbliJnnp7DkuLrpnZ7lvLrov57pgJrlm77jgILoi6VH5piv6Z2e5by66L+e6YCa5Zu+77yM5YiZ5p6B5aSn55qE5by66L+e6YCa5a2Q5Zu+56ew5Li6R+eahOW8uui/numAmuWIhumHj+OAglxyXG4g4oCc5p6B5aSn4oCd55qE5ZCr5LmJ77ya5oyH55qE5piv5a+55a2Q5Zu+5YaN5aKe5Yqg5Zu+R+S4reeahOWFtuWug+mhtueCue+8jOWtkOWbvuWwseS4jeWGjei/numAmuOAglxyXG4g55Sf5oiQ5qCR44CB55Sf5oiQ5qOu5p6X77ya5LiA5Liq6L+e6YCa5Zu+KOaXoOWQkeWbvinnmoTnlJ/miJDmoJHmmK/kuIDkuKrmnoHlsI/ov57pgJrlrZDlm77vvIzlroPlkKvmnInlm77kuK3lhajpg6hu5Liq6aG254K55ZKM5Y+q5pyJ6Laz5Lul5p6E5oiQ5LiA5qO15qCR55qEbi0x5p2h6L6577yM56ew5Li65Zu+55qE55Sf5oiQ5qCR44CCXHJcbiDlhbPkuo7ml6DlkJHlm77nmoTnlJ/miJDmoJHnmoTlh6DkuKrnu5PorrrvvJpcclxuIOKXhiDkuIDmo7XmnIlu5Liq6aG254K555qE55Sf5oiQ5qCR5pyJ5LiU5LuF5pyJbi0x5p2h6L6577ybXHJcbiDil4Yg5aaC5p6c5LiA5Liq5Zu+5pyJbuS4qumhtueCueWSjOWwj+S6jm4tMeadoei+ue+8jOWImeaYr+mdnui/numAmuWbvu+8m1xyXG4g4peGIOWmguaenOWkmuS6jm4tMeadoei+ue+8jOWImeS4gOWumuacieeOr++8m1xyXG4g4peGIOaciW4tMeadoei+ueeahOWbvuS4jeS4gOWumuaYr+eUn+aIkOagkeOAglxyXG5cclxuIOacieWQkeWbvueahOeUn+aIkOajruael+aYr+i/meagt+S4gOS4quWtkOWbvu+8jOeUseiLpeW5suajteacieWQkeagkee7hOaIkO+8jOWQq+acieWbvuS4reWFqOmDqOmhtueCueOAglxyXG4g5pyJ5ZCR5qCR5piv5Y+q5pyJ5LiA5Liq6aG254K555qE5YWl5bqm5Li6MCDvvIzlhbbkvZnpobbngrnnmoTlhaXluqblnYfkuLox55qE5pyJ5ZCR5Zu+44CCXHJcblxyXG4gKlxyXG4gKiDnvZHvvJrmr4/kuKrovrko5oiW5bynKemDvemZhOWKoOS4gOS4quadg+WAvOeahOWbvu+8jOensOS4uuW4puadg+WbvuOAguW4puadg+eahOi/numAmuWbvijljIXmi6zlvLHov57pgJrnmoTmnInlkJHlm74p56ew5Li6572R5oiW572R57uc44CC572R57uc5piv5bel56iL5LiK5bi455So55qE5LiA5Liq5qaC5b+177yM55So5p2l6KGo56S65LiA5Liq5bel56iL5oiW5p+Q56eN5rWB56iLXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIOWbvueahOWtmOWCqOe7k+aehFxyXG4gKlxyXG4g5Zu+55qE5a2Y5YKo57uT5p6E5q+U6L6D5aSN5p2C77yM5YW25aSN5p2C5oCn5Li76KaB6KGo546w5Zyo77yaXHJcbiDil4Yg5Lu75oSP6aG254K55LmL6Ze05Y+v6IO95a2Y5Zyo6IGU57O777yM5peg5rOV5Lul5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo5Yy65Lit55qE54mp55CG5L2N572u5p2l6KGo56S65YWD57Sg5LmL6Ze055qE5YWz57O744CCXHJcbiDil4Yg5Zu+5Lit6aG254K555qE5bqm5LiN5LiA5qC377yM5pyJ55qE5Y+v6IO955u45beu5b6I5aSn77yM6Iul5oyJ5bqm5pWw5pyA5aSn55qE6aG254K56K6+6K6h57uT5p6E77yM5YiZ5Lya5rWq6LS55b6I5aSa5a2Y5YKo5Y2V5YWD77yM5Y+N5LmL5oyJ5q+P5Liq6aG254K56Ieq5bex55qE5bqm6K6+6K6h5LiN5ZCM55qE57uT5p6E77yM5Y+I5Lya5b2x5ZON5pON5L2c44CCXHJcbiDlm77nmoTluLjnlKjnmoTlrZjlgqjnu5PmnoTmnInvvJrpgrvmjqXnn6npmLXjgIHpgrvmjqXpk77ooajjgIHljYHlrZfpk77ooajjgIHpgrvmjqXlpJrph43ooajlkozovrnooajjgIJcclxuICovXHJcblxyXG4vKlxyXG4g6YK75o6l55+p6Zi1KOaVsOe7hCnooajnpLrms5VcclxuXHJcbiDln7rmnKzmgJ3mg7PvvJrlr7nkuo7mnIlu5Liq6aG254K555qE5Zu+77yM55So5LiA57u05pWw57uEdmV4c1tuXeWtmOWCqOmhtueCueS/oeaBr++8jOeUqOS6jOe7tOaVsOe7hEFbbl1bbl3lrZjlgqjpobbngrnkuYvpl7TlhbPns7vnmoTkv6Hmga/jgILor6Xkuoznu7TmlbDnu4Tnp7DkuLrpgrvmjqXnn6npmLXjgILlnKjpgrvmjqXnn6npmLXkuK3vvIzku6XpobbngrnlnKh2ZXhz5pWw57uE5Lit55qE5LiL5qCH5Luj6KGo6aG254K577yM6YK75o6l55+p6Zi15Lit55qE5YWD57SgQVtpXVtqXeWtmOaUvueahOaYr+mhtueCuWnliLDpobbngrlq5LmL6Ze05YWz57O755qE5L+h5oGv44CCXHJcblxyXG4gMSAg5peg5ZCR5Zu+55qE5pWw57uE6KGo56S6XHJcblxyXG4gKDEpICDml6DmnYPlm77nmoTpgrvmjqXnn6npmLVcclxuIOaXoOWQkeaXoOadg+Wbvkc9KFbvvIxFKeaciW4obuKJpzEp5Liq6aG254K577yM5YW26YK75o6l55+p6Zi15pivbumYtuWvueensOaWuemYteOAguWFtuWFg+e0oOeahOWumuS5ieWmguS4i++8mlxyXG4gICAgICAgICAgICAtLSAxICAg6IulKHZpICwgdmop4oiIRe+8jOWNs3ZpICwgdmrpgrvmjqVcclxuIEFbaV1bal09XHJcbiAgICAgICAgICAgICAtLSAwICAg6IulKHZpICwgdmop4oiJRe+8jOWNs3ZpICwgdmrkuI3pgrvmjqVcclxuXHJcbiAoMikgIOW4puadg+WbvueahOmCu+aOpeefqemYtVxyXG4g5peg5ZCR5bim5p2D5Zu+Rz0oVu+8jEUpIOeahOmCu+aOpeefqemYteOAguWFtuWFg+e0oOeahOWumuS5ieWmguS4i++8mlxyXG4gICAgICAgICAgICAtLSBXaWogICAg6IulKHZpICwgdmop4oiIRe+8jOWNs3ZpICwgdmrpgrvmjqXvvIzmnYPlgLzkuLp3aWpcclxuIEFbaV1bal09XHJcblxyXG4gICAgICAgICAgICAtLSDiiJ4gICDoi6UodmkgLCB2ainiiIlF77yM5Y2zdmkgLCB2auS4jemCu+aOpeaXtlxyXG5cclxuICgzKSAg5peg5ZCR5Zu+6YK75o6l55+p6Zi155qE54m55oCnXHJcbiDil4Yg6YK75o6l55+p6Zi15piv5a+556ew5pa56Zi1XHJcbiDil4Yg5a+55LqO6aG254K5dmnvvIzlhbbluqbmlbDmmK/nrKxp6KGM55qE6Z2eMOWFg+e0oOeahOS4quaVsO+8m1xyXG4g4peGIOaXoOWQkeWbvueahOi+ueaVsOaYr+S4iijmiJbkuIsp5LiJ6KeS5b2i55+p6Zi15Lit6Z2eMOWFg+e0oOS4quaVsOOAglxyXG5cclxuIDIgIOacieWQkeWbvueahOaVsOe7hOihqOekulxyXG5cclxuICgxKSAg5peg5p2D5Zu+55qE6YK75o6l55+p6Zi1XHJcbiDoi6XmnInlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWImeWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhYPntKDlrprkuYnlpoLkuIvvvJpcclxuICAgICAgICAgICAgLS0gMSAgIOiLpTx2aSwgdmo+4oiIRe+8jOS7jnZp5YiwdmrmnInlvKdcclxuIEFbaV1bal09XHJcbiAgICAgICAgICAgIC0tIDAgICDoi6U8dmkgLCB2aj7iiIlFICDku452aeWIsHZqIOayoeacieW8p1xyXG5cclxuICgyKSAg5bim5p2D5Zu+55qE6YK75o6l55+p6Zi1XHJcbiDmnInlkJHluKbmnYPlm75HPShW77yMRSnnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcclxuICAgICAgICAgICAgLS0gd2lqICAgIOiLpTx2aSx2aj7iiIhF77yM5Y2zdmkgLCB2aumCu+aOpe+8jOadg+WAvOS4undpalxyXG4gQVtpXVtqXT1cclxuICAgICAgICAgICAg4oieICAg6IulPHZpLHZqPuKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6l5pe2XHJcblxyXG4g4pG2IOacieWQkeWbvumCu+aOpeefqemYteeahOeJueaAp1xyXG4g4peGIOWvueS6jumhtueCuXZp77yM56ysaeihjOeahOmdnjDlhYPntKDnmoTkuKrmlbDmmK/lhbblh7rluqZPRCh2aSnvvJvnrKxp5YiX55qE6Z2eMOWFg+e0oOeahOS4quaVsOaYr+WFtuWFpeW6pklEKHZpKSDjgIJcclxuIOKXhiDpgrvmjqXnn6npmLXkuK3pnZ4w5YWD57Sg55qE5Liq5pWw5bCx5piv5Zu+55qE5byn55qE5pWw55uu44CCXHJcblxyXG4gMyAg5Zu+55qE6YK75o6l55+p6Zi155qE5pON5L2cXHJcblxyXG4g5Zu+55qE6YK75o6l55+p6Zi155qE5a6e546w5q+U6L6D5a655piT77yM5a6a5LmJ5Lik5Liq5pWw57uE5YiG5Yir5a2Y5YKo6aG254K55L+h5oGvKOaVsOaNruWFg+e0oCnlkozovrnmiJblvKfnmoTkv6Hmga8o5pWw5o2u5YWD57Sg5LmL6Ze055qE5YWz57O7KSDjgIJcclxuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcclxuaW1wb3J0IFF1ZXVlIGZyb20gJy4uL1F1ZXVlL1F1ZXVlJztcclxuaW1wb3J0IHsgQ2hpbGRTaWJsaW5nVHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XHJcblxyXG4vLyDlm77nmoTmlbDnu4TvvIjpgrvmjqXnn6npmLXvvInlrZjlgqjooajnpLpcclxuY29uc3QgREcgPSAxOyAgICAgLy8g5pyJ5ZCR5Zu+XHJcbmNvbnN0IEROID0gMjsgICAgIC8vIOacieWQkee9kVxyXG5jb25zdCBVREcgPSAzOyAgICAvLyDml6DlkJHlm75cclxuY29uc3QgVUROID0gNDsgICAgLy8g5peg5ZCR572RXHJcblxyXG5cclxuY2xhc3MgQXJjQ2VsbCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWRqXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZGosIGluZm8gPSBudWxsKXtcclxuICAgICAgICAvLyDpobbngrnnsbvlnovjgILlr7nkuo7ml6DmnYPlm77vvIznlKgx5oiWMOihqOekuuebuOmCu+WQpu+8m+WvueW4puadg+Wbvu+8jOWImeS4uuadg+WAvOexu+Wei1xyXG4gICAgICAgIHRoaXMuYWRqID0gdHlwZW9mIGFkaiA9PT0gJ251bWJlcicgPyBhZGogOiBJbmZpbml0eTtcclxuICAgICAgICAvLyDor6XlvKfnm7jlhbPkv6Hmga9cclxuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRqYWNlbmN5TWF0cml4R3JhcGgge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmV4cyDpobbngrnlkJHph49cclxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBBcmNDZWxsfSBhcmNzIOmCu+aOpeefqemYtVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyY251bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtpbmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXhzID0gW10sIGFyY3MgPSBbXSwgdmV4bnVtID0gMCwgYXJjbnVtID0gMCwga2luZCA9IERHKXtcclxuICAgICAgICAvLyDpobbngrnlkJHph49cclxuICAgICAgICB0aGlzLnZleHMgPSB2ZXhzO1xyXG4gICAgICAgIC8vIOmCu+aOpeefqemYtVxyXG4gICAgICAgIHRoaXMuYXJjcyA9IGFyY3M7XHJcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWwXHJcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW07XHJcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN5byn5pWwXHJcbiAgICAgICAgdGhpcy5hcmNudW0gPSBhcmNudW07XHJcbiAgICAgICAgLy8g5Zu+55qE56eN57G75qCH5b+XXHJcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVHcmFwaCgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xyXG4gICAgICAgICAgICBjYXNlIERHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZURHKHRoaXMpOyAgICAgLy8g5p6E6YCg5pyJ5ZCR5Zu+XHJcbiAgICAgICAgICAgIGNhc2UgRE46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRE4odGhpcyk7ICAgICAvLyDmnoTpgKDmnInlkJHnvZFcclxuICAgICAgICAgICAgY2FzZSBVREc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVURHKHRoaXMpOyAgICAvLyDmnoTpgKDml6DlkJHlm75cclxuICAgICAgICAgICAgY2FzZSBVRE46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVUROKHRoaXMpOyAgICAvLyDmnoTpgKDml6DlkJHnvZFcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcign6Z2e5pyJ5pWI55qE5Zu+57G75Z6LJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5p+l5om+6aG254K5XHJcbiAgICAgKiBAcGFyYW0geyp9IHZwIOmhtueCueWQkemHj1xyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgbG9jYXRlVmV4ICh2cCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXhzW2ldID09PSB2cCkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlkJHlm77kuK3lop7liqDpobbngrlcclxuICAgICAqIEBwYXJhbSB7Kn0gdnAg6aG254K55ZCR6YePXHJcbiAgICAgKi9cclxuICAgIGFkZFZlcnRleCh2cCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvY2F0ZVZleCh2cCkgIT09IC0xKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBoYXMgZXhpc3RlZCEnKTtcclxuXHJcbiAgICAgICAgbGV0IGsgPSB0aGlzLnZleG51bTtcclxuICAgICAgICB0aGlzLnZleHNbdGhpcy52ZXhudW0rK10gPSB2cDtcclxuXHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5raW5kID09PSBERyB8fCB0aGlzLmtpbmQgPT09IFVERyA/XHJcbiAgICAgICAgICAgIDAgOiBJbmZpbml0eTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2pdID0gdGhpcy5hcmNzW2pdIHx8IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nba10gPSB0aGlzLmFyY3Nba10gfHwgW107XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXSA9IHRoaXMuYXJjc1tqXVtrXSB8fCBuZXcgQXJjQ2VsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nba11bal0gPSB0aGlzLmFyY3Nba11bal0gfHwgbmV3IEFyY0NlbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmFkaiA9IHRoaXMuYXJjc1trXVtqXS5hZGogPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlkJHlm77kuK3lop7liqDkuIDmnaHlvKdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmV4MSDpobbngrkx5ZCR6YePXHJcbiAgICAgKiBAcGFyYW0geyp9IHZleDIg6aG254K5MuWQkemHj1xyXG4gICAgICogQHBhcmFtIHtBcmNDZWxsfSBhcmNcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBhZGRBcmModmV4MSwgdmV4MiwgYXJjKSB7XHJcbiAgICAgICAgYXJjID0gYXJjIHx8IG5ldyBBcmNDZWxsKHRoaXMua2luZCA9PT0gREcgfHwgdGhpcy5raW5kID09PSBVREcgPyAxIDogJ3dlaWdodCcpO1xyXG4gICAgICAgIGxldCBrID0gdGhpcy5sb2NhdGVWZXgodmV4MSk7XHJcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleCh2ZXgyKTtcclxuXHJcbiAgICAgICAgaWYgKGsgPT09IC0xIHx8IGogPT09IC0xKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyY1xcJ3MgVmVydGV4IGRvIG5vdCBleGlzdGVkIScpO1xyXG5cclxuICAgICAgICB0aGlzLmFyY3Nba11bal0uYWRqID0gYXJjLmFkajtcclxuICAgICAgICB0aGlzLmFyY3Nba11bal0uaW5mbyA9IGFyYy5pbmZvO1xyXG4gICAgICAgIC8vIOaXoOWQkeWbvuaIluaXoOWQkee9kVxyXG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFVERyB8fCB0aGlzLmtpbmQgPT09IFVETikge1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10uYWRqID0gYXJjLmFkajtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmluZm8gPSBhcmMuaW5mbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICsrdGhpcy5hcmNudW07XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk6aG254K5XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmV4IOimgeWIoOmZpOeahOmhtueCuVxyXG4gICAgICovXHJcbiAgICBkZWxldGVWZXgodmV4KSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzLnZleG51bSAtIDE7XHJcbiAgICAgICAgbGV0IG0gPSB0aGlzLmxvY2F0ZVZleCh2ZXgpO1xyXG5cclxuICAgICAgICBpZiAobSA8IDApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8g5bCG5b6F5Yig6Zmk6aG254K55Lqk5o2i5Yiw5pyA5ZCO5LiA5Liq6aG254K5XHJcbiAgICAgICAgbGV0IHRlbXAgPSB0aGlzLnZleHNbbV07XHJcbiAgICAgICAgdGhpcy52ZXhzW21dID0gdGhpcy52ZXhzW25dO1xyXG4gICAgICAgIHRoaXMudmV4c1tuXSA9IHRlbXA7XHJcblxyXG4gICAgICAgIC8vIOWwhui+ueeahOWFs+ezu+maj+S5i+S6pOaNolxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLmFyY3NbaV1bbV0gPSB0aGlzLmFyY3NbaV1bbl07XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1ttXVtpXSA9IHRoaXMuYXJjc1tuXVtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYXJjc1ttXVttXS5hZGogPSAwO1xyXG4gICAgICAgIHRoaXMudmV4cy5sZW5ndGggPSAtLXRoaXMudmV4bnVtO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk6L65KHYsIHcpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBkZWxldGVBcmModiwgdykge1xyXG4gICAgICAgIGxldCBpID0gdGhpcy5sb2NhdGVWZXgodik7XHJcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleCh3KTtcclxuXHJcbiAgICAgICAgaWYgKGkgPCAwIHx8IGogPCAwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFyY3NbaV1bal0uYWRqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tpXVtqXS5hZGogPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmFyY251bS0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yik5pat5LiA5Liq6YK75o6l55+p6Zi15a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXHJcbiAgICBpc1Bhc3MoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2luZCAhPT0gREcpIHRocm93IG5ldyBFcnJvcignZ3JhcGgga2luZCBzaG91bGQgYmUgREcnKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnZleG51bTsgKyt4KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy52ZXhudW07ICsreSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t4XVt5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgdGhpcy52ZXhudW07ICsreikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeiAhPT0geCAmJiB0aGlzLmFyY3NbeV1bel0gJiYgIXRoaXMuYXJjc1t4XVt6XSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RBZGpWZXgodikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSBJbmZpbml0eSkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgbmV4dEFkalZleCh2LCB3KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHcgKyAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSBJbmZpbml0eSkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5a+56YK75o6l55+p6Zi15Zu+5L2c6YCS5b2S5byP5rex5bqm5LyY5YWI6YGN5Y6GXHJcbiAgICBERlNUcmF2ZXJzZSh2aXNpdEZuKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICAvLyDorr/pl67moIflv5fmlbDnu4TliJ3lp4vljJZcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnModGhpcywgaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHZlcnRleCkge1xyXG4gICAgICAgICAgICB2aXNpdGVkW3ZlcnRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB2aXNpdEZuLmNhbGwoZ3JhcGgsIHZlcnRleCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyYXBoLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGguYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gMCAmJiBncmFwaC5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICYmICF2aXNpdGVkW2pdKSBkZnMoZ3JhcGgsIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOmdnumAkuW9klxyXG4gICAgREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG4gICAgICAgIC8vIOiuv+mXruagh+W/l+aVsOe7hOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwobWUsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHZlcnRleCA9IHN0YWNrLnBlZWsoKSkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gSW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICF2aXNpdGVkW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwobWUsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtqXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOWvuemCu+aOpeefqemYteWbvuS9nOW5v+W6puS8mOWFiOmBjeWOhlxyXG4gICAgQkZTVHJhdmVyc2UodmlzaXRGbikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBpKTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHF1ZXVlLmRlUXVldWUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbdV1bal0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t1XVtqXS5hZGogIT09IEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhdmlzaXRlZFtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtqXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1pblNwYW5UcmVlX1BSSU0odSkge1xyXG4gICAgICAgIGxldCBjbG9zZWRnZSA9IFtdO1xyXG5cclxuICAgICAgICAvLyDliJ3lp4vljJZcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgY2xvc2VkZ2Vbal0gPSB7YWRqdmV4OiB1LCBsb3djb3N0OiArdGhpcy5hcmNzW2pdW3VdLmFkan07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsb3NlZGdlW3VdLmxvd2Nvc3QgPSAwO1xyXG5cclxuICAgICAgICBsZXQgdGUgPSBbXTtcclxuICAgICAgICAvLyDpgInmi6nlhbbkvZl0aGlzLnZleG51bSAtIDHkuKrpobbngrlcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtIC0gMTsgKytqKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgbGV0IGs7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZGdlW3ZdLmxvd2Nvc3QgIT09IDAgJiYgY2xvc2VkZ2Vbdl0ubG93Y29zdCA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNsb3NlZGdlW3ZdLmxvd2Nvc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRlW2pdID0ge1xyXG4gICAgICAgICAgICAgICAgdmV4MTogY2xvc2VkZ2Vba10uYWRqdmV4LFxyXG4gICAgICAgICAgICAgICAgdmV4MjogayxcclxuICAgICAgICAgICAgICAgIHdlaWdodDogY2xvc2VkZ2Vba10ubG93Y29zdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjbG9zZWRnZVtrXS5sb3djb3N0ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2tdLmFkaiA8IGNsb3NlZGdlW3ZdLmxvd2Nvc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZWRnZVt2XS5sb3djb3N0ID0gdGhpcy5hcmNzW3ZdW2tdLmFkajtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZWRnZVt2XS5hZGp2ZXggPSBrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGU7XHJcbiAgICB9XHJcblxyXG4gICAgbWluU3BhblRyZWVfS3J1c2thbCgpIHtcclxuICAgICAgICBsZXQgc2V0ID0gW107XHJcbiAgICAgICAgbGV0IHRlID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSBzZXRbaV0gPSBpO1xyXG5cclxuICAgICAgICBsZXQgayA9IDA7XHJcbiAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBhID0gMDtcclxuICAgICAgICBsZXQgYiA9IDA7XHJcbiAgICAgICAgd2hpbGUoayA8IHRoaXMudmV4bnVtIC0gMSl7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy52ZXhudW07ICsrail7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmNzW2ldW2pdLmFkaiA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0aGlzLmFyY3NbaV1bal0uYWRqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzZXRbYV0gIT09IHNldFtiXSl7XHJcbiAgICAgICAgICAgICAgICB0ZVtrKytdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZleDE6IGEsXHJcbiAgICAgICAgICAgICAgICAgICAgdmV4MjogYixcclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXMuYXJjc1thXVtiXS5hZGpcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNldFtpXSA9PT0gc2V0W2JdICYmIGkgIT09IGIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFtpXSA9IHNldFthXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldFtiXSA9IHNldFthXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWluID0gdGhpcy5hcmNzW2FdW2JdLmFkaiA9IEluZmluaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55SoRGlqa3N0cmHnrpfms5XmsYLmnInlkJHnvZHnmoR2MOmhtueCueWIsOWFtuS9memhtueCuXbnmoTmnIDnn63ot6/lvoRwcmVbdl3lj4rlhbbluKbmnYPplb/luqZkaXN0W3Zd44CCXHJcbiAgICAgKiDoi6VwcmVbdl1bd13kuLp0cnVl77yM5YiZd+aYr+S7jnYw5YiwduW9k+WJjeaxguW+l+acgOefrei3r+W+hOS4iueahOmhtueCueOAglxyXG4gICAgICogZmluYWxbdl3kuLp0cnVl5b2T5LiU5LuF5b2TduKIiFPvvIzljbPlt7Lnu4/msYLlvpd2MOWIsHbnmoTmnIDnn63ot6/lvoRcclxuICAgICAqIEBwYXJhbSB2MFxyXG4gICAgICovXHJcbiAgICBzaG9ydGVzdFBhdGhfRGlqa3N0cmEodjApIHtcclxuICAgICAgICBsZXQgcHJlID0gW107XHJcbiAgICAgICAgbGV0IGRpc3QgPSBbXTtcclxuICAgICAgICBsZXQgZmluYWwgPSBbXTtcclxuICAgICAgICBsZXQgdywgdjtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XHJcbiAgICAgICAgICAgIGZpbmFsW3ZdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRpc3Rbdl0gPSB0aGlzLmFyY3NbdjBdW3ZdLmFkajtcclxuICAgICAgICAgICAgcHJlW3ZdID0gcHJlW3ZdIHx8IFtdO1xyXG4gICAgICAgICAgICAvLyDorr7nqbrot6/lvoRcclxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHByZVt2XVt3XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZGlzdFt2XSA8IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBwcmVbdl1bdjBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByZVt2XVt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWIneWni+WMlu+8jHYw6aG254K55bGe5LqOU+mbhlxyXG4gICAgICAgIGRpc3RbdjBdID0gMDtcclxuICAgICAgICBmaW5hbFt2MF0gPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyDlvIDlp4vkuLvlvqrnjq/vvIzmr4/mrKHmsYLlvpd2MOWIsOafkOS4qnbpobbngrnnmoTmnIDnn63ot6/lvoTvvIzlubbliqB25YiwU+mbhlxyXG5cclxuICAgICAgICAvLyDlhbbkvZnnmoTpobbngrlcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAvLyDlvZPliY3miYDmjIfnprt2MOmhtueCueeahOacgOi/kei3neemu1xyXG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xyXG4gICAgICAgICAgICAgICAgLy8gd+mhtueCueWcqFYgLSBT5LitXHJcbiAgICAgICAgICAgICAgICAvLyDkuJR36aG254K556a7djDpobbngrnmm7Tov5FcclxuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgZGlzdFt3XSA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRpc3Rbd107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOemu3Yw6aG254K55pyA6L+R55qEduWKoOWFpVPpm4ZcclxuICAgICAgICAgICAgZmluYWxbdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDlvZPliY3mnIDnn63ot6/lvoTlj4rot53nprtcclxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgbWluICsgdGhpcy5hcmNzW3ZdW3ddLmFkaiA8IGRpc3Rbd10pIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0W3ddID0gbWluICsgdGhpcy5hcmNzW3ZdW3ddLmFkajtcclxuICAgICAgICAgICAgICAgICAgICBwcmVbd10gPSBwcmVbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddW3ddID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coZmluYWwpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHByZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coZGlzdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbmFsOiBmaW5hbCxcclxuICAgICAgICAgICAgcHJlOiBwcmUsXHJcbiAgICAgICAgICAgIGRpc3Q6IGRpc3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHNob3J0ZXN0UGF0aF9GTE9ZRCgpIHtcclxuICAgICAgICBsZXQgYSA9IFtdO1xyXG4gICAgICAgIGxldCBwYXRoID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICBhW2pdID0gYVtqXSB8fCBbXTtcclxuICAgICAgICAgICAgcGF0aFtqXSA9IHBhdGhbal0gfHwgW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykge1xyXG4gICAgICAgICAgICAgICAgaWYoaiA9PT0gaykgYVtqXVtrXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGFbal1ba10gPSB0aGlzLmFyY3Nbal1ba10uYWRqO1xyXG4gICAgICAgICAgICAgICAgcGF0aFtqXVtrXSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMudmV4bnVtOyArK2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVtqXVttXSArIGFbbV1ba10gPCBhW2pdW2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbal1ba10gPSBhW2pdW21dICsgYVttXVtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFtqXVtrXSA9IG07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiAhPT0gaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZOWIsCVk55qE5pyA55+t6Lev5b6E5Li677yaJywgaiwgayk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIGopOyBwcm5fcGFzcyhqLCBrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWQgJywgayk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+acgOefrei3r+W+hOmVv+W6puS4uu+8miAlZCcsIGFbal1ba10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcm5fcGFzcyhqLCBrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoW2pdW2tdICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcHJuX3Bhc3MoaiwgcGF0aFtqXVtrXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLCAlZCcsIHBhdGhbal1ba10pO1xyXG4gICAgICAgICAgICAgICAgcHJuX3Bhc3MocGF0aFtqXVtrXSwgayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCBjcmVhdGVERyA9IGNyZWF0ZUdyYXBoKERHKTtcclxubGV0IGNyZWF0ZUROID0gY3JlYXRlR3JhcGgoRE4pO1xyXG5sZXQgY3JlYXRlVURHID0gY3JlYXRlR3JhcGgoVURHKTtcclxubGV0IGNyZWF0ZVVETiA9IGNyZWF0ZUdyYXBoKFVETik7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVHcmFwaChraW5kKSB7XHJcbiAgICBsZXQgYWRqO1xyXG4gICAgbGV0IHNldE1hdHJpeFZhbHVlO1xyXG5cclxuICAgIGlmIChraW5kID09PSAyIHx8IGtpbmQgPT09IDQpIHtcclxuICAgICAgICBhZGogPSBJbmZpbml0eTtcclxuICAgICAgICBzZXRNYXRyaXhWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21wdCgnd2VpZ2h0OiAnKTtcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhZGogPSAwO1xyXG4gICAgICAgIHNldE1hdHJpeFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoQWRqYWNlbmN5TWF0cml4R3JhcGgpIHtcclxuICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW0gPSBwYXJzZUludChwcm9tcHQoJ3ZleG51bTogJyksIDEwKTtcclxuICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNudW0gPSBwYXJzZUludChwcm9tcHQoJ2FyY251bTogJyksIDEwKTtcclxuICAgICAgICAvLyBpbmNJbmZv5Li6MOWImeWQhOW8p+S4jeWQq+WFtuS7luS/oeaBr1xyXG4gICAgICAgIGxldCBpbmNJbmZvID0gcGFyc2VJbnQocHJvbXB0KCdpbmNJbmZvOiAnKSwgMTApO1xyXG5cclxuICAgICAgICAvLyDmnoTpgKDpobbngrnlkJHph49cclxuICAgICAgICBsZXQgaSwgajtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtOyArK2kpIEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleHNbaV0gPSBwcm9tcHQoJ+mhtueCueWQkemHj3ZleDogJyk7XHJcblxyXG4gICAgICAgIC8vIOWIneWni+WMlumCu+aOpeefqemYtVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV0gPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXSA9IG5ldyBBcmNDZWxsKGFkaiwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOaehOmAoOmCu+aOpeefqemYtVxyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtOyArK2spIHtcclxuICAgICAgICAgICAgLy8g6L6T5YWl5LiA5p2h6L655L6d6ZmE55qE6aG254K55Y+K5p2D5YC8XHJcbiAgICAgICAgICAgIGxldCB2MSA9IHByb21wdCgndjE6ICcpO1xyXG4gICAgICAgICAgICBsZXQgdjIgPSBwcm9tcHQoJ3YyOiAnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOehruWumnYx77yMdjLlnKhH5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGkgPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5sb2NhdGVWZXgodjEpO1xyXG4gICAgICAgICAgICBqID0gQWRqYWNlbmN5TWF0cml4R3JhcGgubG9jYXRlVmV4KHYyKTtcclxuXHJcbiAgICAgICAgICAgIGxldCB3ID0gc2V0TWF0cml4VmFsdWUoKTtcclxuICAgICAgICAgICAgLy8g5bynPHYxLCB2Mj7nmoTmnYPlgLxcclxuICAgICAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXS5hZGogPSB3O1xyXG4gICAgICAgICAgICBpZiAoaW5jSW5mbykgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXS5pbmZvID0gcHJvbXB0KCdpbmZvOiAnKTtcclxuICAgICAgICAgICAgaWYgKGtpbmQgPT09IDMgfHwga2luZCA9PT0gNCkgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tqXVtpXSA9IEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuLy8g56ys5LiA56eN5Yib5bu65Zu+5pa55rOVXHJcbmxldCB2ZXhzID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcclxubGV0IGFyY3MgPSBbXHJcbiAgICBbXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiNlwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAge1wiYWRqXCI6IFwiNlwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiNFwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAge1wiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiNFwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiNVwiLCBcImluZm9cIjogbnVsbH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IFwiNVwiLCBcImluZm9cIjogbnVsbH0sXHJcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH1cclxuICAgIF1cclxuXTtcclxubGV0IHVkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaCh2ZXhzLCBhcmNzLCA1LCA3LCA0KTtcclxuXHJcbi8vIOesrOS6jOenjeWIm+W7uuWbvuaWueazlVxyXG5sZXQgZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCAyKTtcclxuZG4uYWRkVmVydGV4KCdhJyk7XHJcbmRuLmFkZFZlcnRleCgnYicpO1xyXG5kbi5hZGRWZXJ0ZXgoJ2MnKTtcclxuZG4uYWRkVmVydGV4KCdkJyk7XHJcbmRuLmFkZFZlcnRleCgnZScpO1xyXG5cclxuZG4uYWRkQXJjKCdhJywgJ2InLCB7XHJcbiAgICBhZGo6IDZcclxufSk7XHJcbmRuLmFkZEFyYygnYScsICdjJywge1xyXG4gICAgYWRqOiAyXHJcbn0pO1xyXG5kbi5hZGRBcmMoJ2MnLCAnYicsIHtcclxuICAgIGFkajogM1xyXG59KTtcclxuZG4uYWRkQXJjKCdjJywgJ2QnLCB7XHJcbiAgICBhZGo6IDFcclxufSk7XHJcbmRuLmFkZEFyYygnZCcsICdiJywge1xyXG4gICAgYWRqOiA0XHJcbn0pO1xyXG5kbi5hZGRBcmMoJ2InLCAnZScsIHtcclxuICAgIGFkajogM1xyXG59KTtcclxuZG4uYWRkQXJjKCdkJywgJ2UnLCB7XHJcbiAgICBhZGo6IDVcclxufSk7XHJcblxyXG5jb25zb2xlLmxvZyhkbik7XHJcblxyXG4vKlxyXG5cclxuIC8vIOesrOS4ieenjeWIm+W7uuWbvuaWueazlVxyXG4gbGV0IGcgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoKTtcclxuIGcua2luZCA9IEROO1xyXG4gZy5jcmVhdGVHcmFwaCgpO1xyXG4gY29uc29sZS5sb2coZyk7XHJcblxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbiDlm77nmoTpgY3ljoZcclxuXHJcbiDlm77nmoTpgY3ljoYoVHJhdmVyaW5nIEdyYXBoKe+8muS7juWbvueahOafkOS4gOmhtueCueWHuuWPke+8jOiuv+mBjeWbvuS4reeahOWFtuS9memhtueCue+8jOS4lOavj+S4qumhtueCueS7heiiq+iuv+mXruS4gOasoeOAguWbvueahOmBjeWOhueul+azleaYr+WQhOenjeWbvueahOaTjeS9nOeahOWfuuehgOOAglxyXG5cclxuIOKXhiDlpI3mnYLmgKfvvJrlm77nmoTku7vmhI/pobbngrnlj6/og73lkozlhbbkvZnnmoTpobbngrnnm7jpgrvmjqXvvIzlj6/og73lnKjorr/pl67kuobmn5DkuKrpobbngrnlkI7vvIzmsr/mn5DmnaHot6/lvoTmkJzntKLlkI7lj4jlm57liLDljp/pobbngrnjgIJcclxuIOKXhiDop6PlhrPlip7ms5XvvJrlnKjpgY3ljobov4fnqIvkuK3orrDkuIvlt7Looqvorr/pl67ov4fnmoTpobbngrnjgILorr7nva7kuIDkuKrovoXliqnlkJHph49WaXNpdGVkWzHigKZuXShu5Li66aG254K55pWwKe+8jOWFtuWIneWAvOS4ujDvvIzkuIDml6borr/pl67kuobpobbngrl2aeWQju+8jOS9v1Zpc2l0ZWRbaV3kuLox5oiW5Li66K6/6Zeu55qE5qyh5bqP5Y+344CCXHJcbiDlm77nmoTpgY3ljobnrpfms5XmnInmt7HluqbkvJjlhYjmkJzntKLnrpfms5Xlkozlub/luqbkvJjlhYjmkJzntKLnrpfms5XjgIJcclxuXHJcbiDmt7HluqbkvJjlhYjmkJzntKIoRGVwdGggRmlyc3QgU2VhcmNoLS1ERlMp6YGN5Y6G57G75Ly85qCR55qE5YWI5bqP6YGN5Y6G77yM5piv5qCR55qE5YWI5bqP6YGN5Y6G55qE5o6o5bm/44CCXHJcblxyXG4g566X5rOV5oCd5oOzXHJcbiDorr7liJ3lp4vnirbmgIHml7blm77kuK3nmoTmiYDmnInpobbngrnmnKrooqvorr/pl67vvIzliJnvvJpcclxuIOKRtCDvvJrku47lm77kuK3mn5DkuKrpobbngrl2aeWHuuWPke+8jOiuv+mXrnZp77yb54S25ZCO5om+5YiwdmnnmoTkuIDkuKrpgrvmjqXpobbngrl2aTEg77ybXHJcbiDikbXvvJrku452aTHlh7rlj5HvvIzmt7HluqbkvJjlhYjmkJzntKLorr/pl67lkox2aTHnm7jpgrvmjqXkuJTmnKrooqvorr/pl67nmoTmiYDmnInpobbngrnvvJtcclxuIOKRtu+8mui9rOKRtCDvvIznm7TliLDlkox2aeebuOmCu+aOpeeahOaJgOaciemhtueCuemDveiiq+iuv+mXruS4uuatolxyXG4g4pG3IO+8mue7p+e7remAieWPluWbvuS4reacquiiq+iuv+mXrumhtueCuXZq5L2c5Li66LW35aeL6aG254K577yM6L2sKDEp77yM55u05Yiw5Zu+5Lit5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2i44CCXHJcblxyXG5cclxuIOW5v+W6puS8mOWFiOaQnOe0oihCcmVhZHRoIEZpcnN0IFNlYXJjaC0tQkZTKemBjeWOhuexu+S8vOagkeeahOaMieWxguasoemBjeWOhueahOi/h+eoi+OAglxyXG5cclxuIOeul+azleaAneaDs1xyXG4g6K6+5Yid5aeL54q25oCB5pe25Zu+5Lit55qE5omA5pyJ6aG254K55pyq6KKr6K6/6Zeu77yM5YiZ77yaXHJcbiDikbQg77ya5LuO5Zu+5Lit5p+Q5Liq6aG254K5dmnlh7rlj5HvvIzorr/pl652ae+8m1xyXG4g4pG177ya6K6/6ZeudmnnmoTmiYDmnInnm7jpgrvmjqXkuJTmnKrooqvorr/pl67nmoTmiYDmnInpobbngrl2aTHvvIx2aTLvvIzigKbvvIx2aW3vvJtcclxuIOKRtu+8muS7pXZpMe+8jHZpMu+8jCDigKbvvIx2aW3nmoTmrKHluo/vvIzku6V2aWooMeKJpmriiaZtKeS+neatpOS9nOS4unZpIO+8jOi9rOKRtO+8m1xyXG4g4pG3IO+8mue7p+e7remAieWPluWbvuS4reacquiiq+iuv+mXrumhtueCuXZr5L2c5Li66LW35aeL6aG254K577yM6L2s4pG077yM55u05Yiw5Zu+5Lit5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2i44CCXHJcblxyXG4g55So5bm/5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+5LiO5rex5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+55qE5ZSv5LiA5Yy65Yir5piv6YK75o6l54K55pCc57Si5qyh5bqP5LiN5ZCMLlxyXG4gKi9cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coJ0RGU1RyYXZlcnNlOiB1ZG4nKTtcclxuXHJcbmxldCBnMSA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIFVERyk7XHJcbmcxLmFkZFZlcnRleCgndjEnKTtcclxuZzEuYWRkVmVydGV4KCd2MycpO1xyXG5nMS5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmcxLmFkZFZlcnRleCgndjQnKTtcclxuZzEuYWRkVmVydGV4KCd2NScpO1xyXG5cclxuZzEuYWRkQXJjKCd2NScsICd2NCcpO1xyXG5nMS5hZGRBcmMoJ3YzJywgJ3YxJyk7XHJcbmcxLmFkZEFyYygndjInLCAndjEnKTtcclxuZzEuYWRkQXJjKCd2MycsICd2MicpO1xyXG5cclxuXHJcbmcxLkRGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdERlNUcmF2ZXJzZV9Ob25SZWN1cnNlOiB1ZG4nKTtcclxuZzEuREZTVHJhdmVyc2VfTm9uUmVjdXJzZShmdW5jdGlvbiAodikge1xyXG4gICAgY29uc29sZS5sb2codGhpcy52ZXhzW3ZdKTtcclxufSk7XHJcblxyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZygnQkZTVHJhdmVyc2U6ICcpO1xyXG5sZXQgYnNmRyA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIERHKTtcclxuYnNmRy5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmJzZkcuYWRkVmVydGV4KCd2MicpO1xyXG5ic2ZHLmFkZFZlcnRleCgndjMnKTtcclxuYnNmRy5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmJzZkcuYWRkVmVydGV4KCd2NScpO1xyXG5cclxuYnNmRy5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XHJcbmJzZkcuYWRkQXJjKCd2MScsICd2MicpO1xyXG5ic2ZHLmFkZEFyYygndjMnLCAndjUnKTtcclxuYnNmRy5hZGRBcmMoJ3YzJywgJ3YyJyk7XHJcbmJzZkcuYWRkQXJjKCd2MycsICd2MScpO1xyXG5ic2ZHLmFkZEFyYygndjQnLCAndjMnKTtcclxuYnNmRy5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XHJcblxyXG5ic2ZHLkJGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbiDmnIDlsI/nlJ/miJDmoJFcclxuXHJcbiDlpoLmnpzov57pgJrlm77mmK/kuIDkuKrluKbmnYPlm77vvIzliJnlhbbnlJ/miJDmoJHkuK3nmoTovrnkuZ/luKbmnYPvvIznlJ/miJDmoJHkuK3miYDmnInovrnnmoTmnYPlgLzkuYvlkoznp7DkuLrnlJ/miJDmoJHnmoTku6Pku7fjgIJcclxuXHJcbiDmnIDlsI/nlJ/miJDmoJEoTWluaW11bSBTcGFubmluZyBUcmVlKSDvvJrluKbmnYPov57pgJrlm77kuK3ku6Pku7fmnIDlsI/nmoTnlJ/miJDmoJHnp7DkuLrmnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiDmnIDlsI/nlJ/miJDmoJHlnKjlrp7pmYXkuK3lhbfmnInph43opoHnlKjpgJTvvIzlpoLorr7orqHpgJrkv6HnvZHjgILorr7lm77nmoTpobbngrnooajnpLrln47luILvvIzovrnooajnpLrkuKTkuKrln47luILkuYvpl7TnmoTpgJrkv6Hnur/ot6/vvIzovrnnmoTmnYPlgLzooajnpLrlu7rpgKDpgJrkv6Hnur/ot6/nmoTotLnnlKjjgIJu5Liq5Z+O5biC5LmL6Ze05pyA5aSa5Y+v5Lul5bu6bu+CtChuLTEpLzLmnaHnur/ot6/vvIzlpoLkvZXpgInmi6nlhbbkuK3nmoRuLTHmnaHvvIzkvb/mgLvnmoTlu7rpgKDotLnnlKjmnIDkvY4/XHJcblxyXG4g5p6E6YCg5pyA5bCP55Sf5oiQ5qCR55qE566X5rOV5pyJ6K645aSa77yM5Z+65pys5Y6f5YiZ5piv77yaXHJcbiDil4Yg5bC95Y+v6IO96YCJ5Y+W5p2D5YC85pyA5bCP55qE6L6577yM5L2G5LiN6IO95p6E5oiQ5Zue6Lev77ybXHJcbiDil4Yg6YCJ5oupbi0x5p2h6L655p6E5oiQ5pyA5bCP55Sf5oiQ5qCR44CCXHJcbiDku6XkuIrnmoTln7rmnKzljp/liJnmmK/ln7rkuo5NU1TnmoTlpoLkuIvmgKfotKjvvJpcclxuIOiuvkc9KFbvvIxFKeaYr+S4gOS4quW4puadg+i/numAmuWbvu+8jFXmmK/pobbngrnpm4ZW55qE5LiA5Liq6Z2e56m65a2Q6ZuG44CC6IuldeKIiFUg77yMduKIiFYtVe+8jOS4lCh1LCB2KeaYr1XkuK3pobbngrnliLBWLVXkuK3pobbngrnkuYvpl7TmnYPlgLzmnIDlsI/nmoTovrnvvIzliJnlv4XlrZjlnKjkuIDmo7XljIXlkKvovrkodSwgdinnmoTmnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiDor4HmmI7vvJog55So5Y+N6K+B5rOV6K+B5piO44CCXHJcbiDorr7lm75H55qE5Lu75L2V5LiA5qO15pyA5bCP55Sf5oiQ5qCR6YO95LiN5YyF5ZCr6L65KHUsdinjgILorr5U5pivR+eahOS4gOajteeUn+aIkOagke+8jOWImVTmmK/ov57pgJrnmoTvvIzku4515YiwduW/heacieS4gOadoei3r+W+hCh1LOKApix2Ke+8jOW9k+Wwhui+uSh1LHYp5Yqg5YWl5YiwVOS4reaXtuWwseaehOaIkOS6huWbnui3r+OAguWImei3r+W+hCh1LCDigKYsdinkuK3lv4XmnInkuIDmnaHovrkodeKAmSx24oCZKSDvvIzmu6HotrN14oCZ4oiIVSDvvIx24oCZ4oiIVi1VIOOAguWIoOWOu+i+uSh14oCZLHbigJkpIOS+v+WPr+a2iOmZpOWbnui3r++8jOWQjOaXtuW+l+WIsOWPpuS4gOajteeUn+aIkOagkVTigJnjgIJcclxuIOeUseS6jih1LHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOaVhSh1LHYp55qE5p2D5YC85LiN5Lya6auY5LqOKHXigJksduKAmSnnmoTmnYPlgLzvvIxU4oCZ55qE5Luj5Lu35Lmf5LiN5Lya6auY5LqOVO+8jCBU4oCZ5piv5YyF5ZCrKHUsdikg55qE5LiA5qO15pyA5bCP55Sf5oiQ5qCR77yM5LiO5YGH6K6+55+b55u+44CCXHJcblxyXG4gKi9cclxuXHJcbi8qXHJcbiDmma7ph4zlp4YoUHJpbSnnrpfms5VcclxuXHJcbiDpgILlkIjovrnnqKDlr4bnmoTnvZFcclxuXHJcbiDku47ov57pgJrnvZFOPShV77yMRSnkuK3mib7mnIDlsI/nlJ/miJDmoJFUPShV77yMVEUpIOOAglxyXG5cclxuIDEg566X5rOV5oCd5oOzXHJcbiDikbQgIOiLpeS7jumhtueCuXYw5Ye65Y+R5p6E6YCg77yMVT17djB977yMVEU9e33vvJtcclxuIOKRtSDlhYjmib7mnYPlgLzmnIDlsI/nmoTovrkode+8jHYp77yM5YW25LitdeKIiFXkuJR24oiIVi1V77yM5bm25LiU5a2Q5Zu+5LiN5p6E5oiQ546v77yM5YiZVT0gVeKIqnt2fe+8jFRFPVRF4oiqeyh177yMdil9IO+8m1xyXG4g4pG2IOmHjeWkjeKRtSDvvIznm7TliLBVPVbkuLrmraLjgILliJlUReS4reW/heaciW4tMeadoei+ue+8jCBUPShV77yMVEUp5bCx5piv5pyA5bCP55Sf5oiQ5qCR44CCXHJcblxyXG4gMi7nrpfms5Xlrp7njrDor7TmmI5cclxuIOS4uuS+v+S6jueul+azleWunueOsO+8jOiuvue9ruS4gOS4quS4gOe7tOaVsOe7hGNsb3NlZGdlW25d77yM55So5p2l5L+d5a2YVi0gVeS4reWQhOmhtueCueWIsFXkuK3pobbngrnlhbfmnInmnYPlgLzmnIDlsI/nmoTovrnjgIJcclxuIGNsb3NlZGdlW2pdLmFkanZleD1r77yM6KGo5piO6L65KHZqLCB2aynmmK9WLVXkuK3pobbngrl2auWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIzogIzpobbngrl2a+aYr+ivpei+ueaJgOS+nemZhOeahFXkuK3nmoTpobbngrnjgIIgY2xvc2VkZ2Vbal0ubG93Y29zdOWtmOaUvuivpei+ueeahOadg+WAvOOAglxyXG4g5YGH6K6+5LuO6aG254K5dnPlvIDlp4vmnoTpgKDmnIDlsI/nlJ/miJDmoJHjgILliJ3lp4vml7bku6TvvJpcclxuIENsb3NlZGdlW3NdLmxvd2Nvc3Q9MCDvvJrooajmmI7pobbngrl2c+mmluWFiOWKoOWFpeWIsFXkuK3vvJtcclxuIENsb3NlZGdlW2tdLmFkanZleD1zIO+8jENsb3NlZGdlW2tdLmxvd2Nvc3Q9Y29zdChrLCBzKVxyXG4g6KGo56S6Vi1V5Lit55qE5ZCE6aG254K55YiwVeS4readg+WAvOacgOWwj+eahOi+uShr4omgcykg77yMY29zdChrLCBzKeihqOekuui+uSh2aywgdnMpIOadg+WAvOOAglxyXG5cclxuIDMu566X5rOV5q2l6aqkXHJcbiDikbQgIOS7jmNsb3NlZGdl5Lit6YCJ5oup5LiA5p2h5p2D5YC8KOS4jeS4ujAp5pyA5bCP55qE6L65KHZrLCB2aikg77yM54S25ZCO5YGa77yaXHJcbiDikaAg572uY2xvc2VkZ2Vba10ubG93Y29zdOS4ujAg77yM6KGo56S6dmvlt7LliqDlhaXliLBV5Lit44CCXHJcbiDikaEgIOagueaNruaWsOWKoOWFpXZr55qE5pu05pawY2xvc2VkZ2XkuK3mr4/kuKrlhYPntKDvvJpcclxuIO+AonZp4oiIVi1VIO+8jOiLpWNvc3QoaSwgayniiaZjb2xzZWRnZVtpXS5sb3djb3N077yM6KGo5piO5ZyoVeS4reaWsOWKoOWFpemhtueCuXZr5ZCO77yMICh2aSwgdmsp5oiQ5Li6dmnliLBV5Lit5p2D5YC85pyA5bCP55qE6L6577yM572u77yaXHJcbiBDbG9zZWRnZVtpXS5sb3djb3N0PWNvc3QoaSwgaylcclxuIENsb3NlZGdlW2ldLmFkanZleD1rXHJcbiDikbUgIOmHjeWkjeKRtG4tMeasoeWwseW+l+WIsOacgOWwj+eUn+aIkOagkeOAglxyXG5cclxuIOeul+azleWIhuaekO+8mlxyXG4g6K6+5bim5p2D6L+e6YCa5Zu+5pyJbuS4qumhtueCue+8jOWImeeul+azleeahOS4u+imgeaJp+ihjOaYr+S6jOmHjeW+queOr++8miDmsYJjbG9zZWRnZeS4readg+WAvOacgOWwj+eahOi+ue+8jOmikeW6puS4um4tMe+8myDkv67mlLljbG9zZWRnZeaVsOe7hO+8jOmikeW6puS4um4g44CC5Zug5q2k77yM5pW05Liq566X5rOV55qE5pe26Ze05aSN5p2C5bqm5pivTyhuMinvvIzkuI7ovrnnmoTmlbDnm67ml6DlhbPjgIJcclxuXHJcbiAqL1xyXG5cclxudWRuID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgNCk7XHJcbnVkbi5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbnVkbi5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbnVkbi5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbnVkbi5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbnVkbi5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcbnVkbi5hZGRWZXJ0ZXgoJ3Y2Jyk7XHJcblxyXG51ZG4uYWRkQXJjKCd2MScsICd2MicsIHthZGo6IDZ9KTtcclxudWRuLmFkZEFyYygndjEnLCAndjMnLCB7YWRqOiAxfSk7XHJcbnVkbi5hZGRBcmMoJ3YxJywgJ3Y0Jywge2FkajogNX0pO1xyXG51ZG4uYWRkQXJjKCd2MicsICd2MycsIHthZGo6IDV9KTtcclxudWRuLmFkZEFyYygndjInLCAndjUnLCB7YWRqOiAzfSk7XHJcbnVkbi5hZGRBcmMoJ3YzJywgJ3Y0Jywge2FkajogNX0pO1xyXG51ZG4uYWRkQXJjKCd2MycsICd2NScsIHthZGo6IDZ9KTtcclxudWRuLmFkZEFyYygndjMnLCAndjYnLCB7YWRqOiA0fSk7XHJcbnVkbi5hZGRBcmMoJ3Y0JywgJ3Y2Jywge2FkajogMn0pO1xyXG51ZG4uYWRkQXJjKCd2NScsICd2NicsIHthZGo6IDZ9KTtcclxuXHJcbmNvbnNvbGUubG9nKCdtaW5TcGFuVHJlZV9QUklNOiAnKTtcclxuY29uc29sZS5sb2codWRuLm1pblNwYW5UcmVlX1BSSU0oMCkpO1xyXG5cclxuXHJcblxyXG4vKlxyXG4g5YWL6bKB5pav5Y2h5bCUKEtydXNrYWwp566X5rOVXHJcblxyXG4g6YCC5ZCI6L6556iA55aP55qE572RXHJcblxyXG4gMSDnrpfms5XmgJ3mg7NcclxuIOiuvkc9KFYsIEUp5piv5YW35pyJbuS4qumhtueCueeahOi/numAmue9ke+8jFQ9KFUsIFRFKeaYr+WFtuacgOWwj+eUn+aIkOagkeOAguWIneWAvO+8mlU9Vu+8jFRFPXt9IOOAglxyXG4g5a+5R+S4reeahOi+ueaMieadg+WAvOWkp+Wwj+S7juWwj+WIsOWkp+S+neasoemAieWPluOAglxyXG4g4pG0ICAg6YCJ5Y+W5p2D5YC85pyA5bCP55qE6L65KHZp77yMdmop77yM6Iul6L65KHZp77yMdmop5Yqg5YWl5YiwVEXlkI7lvaLmiJDlm57ot6/vvIzliJnoiI3lvIPor6Xovrko6L65KHZp77yMdmopIO+8m+WQpuWIme+8jOWwhuivpei+ueW5tuWFpeWIsFRF5Lit77yM5Y2zVEU9VEXiiKp7KHZp77yMdmopfSDjgIJcclxuIOKRtSDph43lpI3ikbQg77yM55u05YiwVEXkuK3ljIXlkKvmnIluLTHmnaHovrnkuLrmraLjgIJcclxuIOWmguWbvjctMjLmiYDmj5DnpLrjgIJcclxuXHJcbiAyIOeul+azleWunueOsOivtOaYjlxyXG4gS3J1c2thbOeul+azleWunueOsOeahOWFs+mUruaYr++8muW9k+S4gOadoei+ueWKoOWFpeWIsFRF55qE6ZuG5ZCI5ZCO77yM5aaC5L2V5Yik5pat5piv5ZCm5p6E5oiQ5Zue6LevP1xyXG4g566A5Y2V55qE6Kej5Yaz5pa55rOV5piv77ya5a6a5LmJ5LiA5Liq5LiA57u05pWw57uEVnNldFtuXSDvvIzlrZjmlL7lm75U5Lit5q+P5Liq6aG254K55omA5Zyo55qE6L+e6YCa5YiG6YeP55qE57yW5Y+344CCXHJcbiDil4Yg5Yid5YC877yaVnNldFtpXT1p77yM6KGo56S65q+P5Liq6aG254K55ZCE6Ieq57uE5oiQ5LiA5Liq6L+e6YCa5YiG6YeP77yM6L+e6YCa5YiG6YeP55qE57yW5Y+3566A5Y2V5Zyw5L2/55So6aG254K55Zyo5Zu+5Lit55qE5L2N572uKOe8luWPtynjgIJcclxuIOKXhiDlvZPlvoBU5Lit5aKe5Yqg5LiA5p2h6L65KHZp77yMdmopIOaXtu+8jOWFiOajgOafpVZzZXRbaV3lkoxWc2V0W2pd5YC877yaXHJcbiDimIYg6IulVnNldFtpXT1Wc2V0W2pd77ya6KGo5piOdmnlkox2auWkhOWcqOWQjOS4gOS4qui/numAmuWIhumHj+S4re+8jOWKoOWFpeatpOi+ueS8muW9ouaIkOWbnui3r++8m1xyXG4g4piGIOiLpVZzZXRbaV3iiaBWc2V0W2pd77yM5YiZ5Yqg5YWl5q2k6L655LiN5Lya5b2i5oiQ5Zue6Lev77yM5bCG5q2k6L655Yqg5YWl5Yiw55Sf5oiQ5qCR55qE6L656ZuG5Lit44CCXHJcbiDil4Yg5Yqg5YWl5LiA5p2h5paw6L655ZCO77yM5bCG5Lik5Liq5LiN5ZCM55qE6L+e6YCa5YiG6YeP5ZCI5bm277ya5bCG5LiA5Liq6L+e6YCa5YiG6YeP55qE57yW5Y+35o2i5oiQ5Y+m5LiA5Liq6L+e6YCa5YiG6YeP55qE57yW5Y+344CCXHJcblxyXG4gKi9cclxuXHJcbmNvbnNvbGUubG9nKCdtaW5TcGFuVHJlZV9LcnVza2FsOiAnKTtcclxuY29uc29sZS5sb2codWRuLm1pblNwYW5UcmVlX0tydXNrYWwoKSk7XHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG4g5pyA55+t6Lev5b6EXHJcblxyXG4g6Iul55So5bim5p2D5Zu+6KGo56S65Lqk6YCa572R77yM5Zu+5Lit6aG254K56KGo56S65Zyw54K577yM6L655Luj6KGo5Lik5Zyw5LmL6Ze05pyJ55u05o6l6YGT6Lev77yM6L655LiK55qE5p2D5YC86KGo56S66Lev56iLKOaIluaJgOiKsei0ueeUqOaIluaXtumXtCkg44CC5LuO5LiA5Liq5Zyw5pa55Yiw5Y+m5LiA5Liq5Zyw5pa555qE6Lev5b6E6ZW/5bqm6KGo56S66K+l6Lev5b6E5LiK5ZCE6L6555qE5p2D5YC85LmL5ZKM44CC6Zeu6aKY77yaXHJcbiDil4Yg5Lik5Zyw5LmL6Ze05piv5ZCm5pyJ6YCa6LevP1xyXG4g4peGIOWcqOacieWkmuadoemAmui3r+eahOaDheWGteS4i++8jOWTquadoeacgOefrT9cclxuIOiAg+iZkeWIsOS6pOmAmue9keeahOacieWQkeaAp++8jOebtOaOpeiuqOiuuueahOaYr+W4puadg+acieWQkeWbvueahOacgOefrei3r+W+hOmXrumimO+8jOS9huino+WGs+mXrumimOeahOeul+azleS5n+mAgueUqOS6juaXoOWQkeWbvuOAglxyXG4g5bCG5LiA5Liq6Lev5b6E55qE6LW35aeL6aG254K556ew5Li65rqQ54K577yM5pyA5ZCO5LiA5Liq6aG254K556ew5Li657uI54K544CCXHJcblxyXG5cclxuIOWNlea6kOeCueacgOefrei3r+W+hFxyXG5cclxuIOWvueS6jue7meWumueahOacieWQkeWbvkc9KFbvvIxFKeWPiuWNleS4qua6kOeCuVZz77yM5rGCVnPliLBH55qE5YW25L2Z5ZCE6aG254K555qE5pyA55+t6Lev5b6E44CCXHJcbiDpkojlr7nljZXmupDngrnnmoTmnIDnn63ot6/lvoTpl67popjvvIxEaWprc3RyYeaPkOWHuuS6huS4gOenjeaMiei3r+W+hOmVv+W6pumAkuWinuasoeW6j+S6p+eUn+acgOefrei3r+W+hOeahOeul+azle+8jOWNs+i/quadsOaWr+eJueaLiShEaWprc3RyYSnnrpfms5XjgIJcclxuXHJcbiAxIOWfuuacrOaAneaDs1xyXG4g5LuO5Zu+55qE57uZ5a6a5rqQ54K55Yiw5YW25a6D5ZCE5Liq6aG254K55LmL6Ze05a6i6KeC5LiK5bqU5a2Y5Zyo5LiA5p2h5pyA55+t6Lev5b6E77yM5Zyo6L+Z57uE5pyA55+t6Lev5b6E5Lit77yM5oyJ5YW26ZW/5bqm55qE6YCS5aKe5qyh5bqP77yM5L6d5qyh5rGC5Ye65Yiw5LiN5ZCM6aG254K555qE5pyA55+t6Lev5b6E5ZKM6Lev5b6E6ZW/5bqm44CCXHJcbiDljbPmjInplb/luqbpgJLlop7nmoTmrKHluo/nlJ/miJDlkITpobbngrnnmoTmnIDnn63ot6/lvoTvvIzljbPlhYjmsYLlh7rplb/luqbmnIDlsI/nmoTkuIDmnaHmnIDnn63ot6/lvoTvvIznhLblkI7msYLlh7rplb/luqbnrKzkuozlsI/nmoTmnIDnn63ot6/lvoTvvIzkvp3mraTnsbvmjqjvvIznm7TliLDmsYLlh7rplb/luqbmnIDplb/nmoTmnIDnn63ot6/lvoTjgIJcclxuXHJcbiAyIOeul+azleaAneaDs+ivtOaYjlxyXG4g6K6+57uZ5a6a5rqQ54K55Li6VnPvvIxT5Li65bey5rGC5b6X5pyA55+t6Lev5b6E55qE57uI54K56ZuG77yM5byA5aeL5pe25LukUz17VnN9IOOAguW9k+axguW+l+esrOS4gOadoeacgOefrei3r+W+hChWcyDvvIxWaSnlkI7vvIxT5Li6e1Zz77yMVml9IOOAguagueaNruS7peS4i+e7k+iuuuWPr+axguS4i+S4gOadoeacgOefrei3r+W+hOOAglxyXG4g6K6+5LiL5LiA5p2h5pyA55+t6Lev5b6E57uI54K55Li6Vmog77yM5YiZVmrlj6rmnInvvJpcclxuIOKXhiAg5rqQ54K55Yiw57uI54K55pyJ55u05o6l55qE5bynPFZz77yMVmo+77ybXHJcbiDil4Yg5LuOVnMg5Ye65Y+R5YiwVmog55qE6L+Z5p2h5pyA55+t6Lev5b6E5omA57uP6L+H55qE5omA5pyJ5Lit6Ze06aG254K55b+F5a6a5ZyoU+S4reOAguWNs+WPquaciei/meadoeacgOefrei3r+W+hOeahOacgOWQjuS4gOadoeW8p+aJjeaYr+S7jlPlhoXmn5DkuKrpobbngrnov57mjqXliLBT5aSW55qE6aG254K5Vmog44CCXHJcbiDoi6XlrprkuYnkuIDkuKrmlbDnu4RkaXN0W25d77yM5YW25q+P5LiqZGlzdFtpXeWIhumHj+S/neWtmOS7jlZzIOWHuuWPkeS4remXtOWPque7j+i/h+mbhuWQiFPkuK3nmoTpobbngrnogIzliLDovr5WaeeahOaJgOaciei3r+W+hOS4remVv+W6puacgOWwj+eahOi3r+W+hOmVv+W6puWAvO+8jOWImeS4i+S4gOadoeacgOefrei3r+W+hOeahOe7iOeCuVZq5b+F5a6a5piv5LiN5ZyoU+S4reS4lOWAvOacgOWwj+eahOmhtueCue+8jOWNs++8mlxyXG4gZGlzdFtpXT1NaW57IGRpc3Rba118IFZr4oiIVi1TIH1cclxuIOWIqeeUqOS4iui/sOWFrOW8j+WwseWPr+S7peS+neasoeaJvuWHuuS4i+S4gOadoeacgOefrei3r+W+hOOAglxyXG5cclxuIDMgIOeul+azleatpemqpFxyXG4g4pGgIOS7pFM9e1ZzfSDvvIznlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIzlr7nlm77kuK3mr4/kuKrpobbngrlWaeaMieS7peS4i+WOn+WImee9ruWIneWAvO+8mlxyXG4gMCAgICBpID1zXHJcbiBkaXN0W2ldID0gICBXc2kgICAgIGniiaBz5LiUPHZzLHZpPuKIiEXvvIwgd3Np5Li65byn5LiK55qE5p2D5YC8XHJcbiDiiJ4gICBp4omgc+S4lDx2cyx2aT7kuI3lsZ7kuo5FXHJcbiDikaEg6YCJ5oup5LiA5Liq6aG254K5Vmog77yM5L2/5b6X77yaXHJcbiBkaXN0W2pdPU1pbnsgZGlzdFtrXXwgVmviiIhWLVMgfVxyXG4gVmrlsLHmmK/msYLlvpfnmoTkuIvkuIDmnaHmnIDnn63ot6/lvoTnu4jngrnvvIzlsIZWaiDlubblhaXliLBT5Lit77yM5Y2zUz1T4oiqe1ZqfSDjgIJcclxuIOKRoiDlr7lWLVPkuK3nmoTmr4/kuKrpobbngrlWayDvvIzkv67mlLlkaXN0W2td77yM5pa55rOV5piv77yaXHJcbiDoi6VkaXN0W2pdK1dqazxkaXN0W2td77yM5YiZ5L+u5pS55Li677yaXHJcbiBkaXN0W2tdPWRpc3Rbal0rV2prICjvgKJWa+KIiFYtUyApXHJcbiDikaMg6YeN5aSN4pGh77yM4pGi77yM55u05YiwUz1W5Li65q2i44CCXHJcblxyXG4gNCDnrpfms5Xlrp7njrBcclxuIOeUqOW4puadg+eahOmCu+aOpeefqemYteihqOekuuacieWQkeWbvu+8jCDlr7lQcmlt566X5rOV55Wl5Yqg5pS55Yqo5bCx5oiQ5LqGRGlqa3N0cmHnrpfms5XvvIzlsIZQcmlt566X5rOV5Lit5rGC5q+P5Liq6aG254K5VmvnmoRsb3djb3N05YC855SoZGlzdFtrXeS7o+abv+WNs+WPr+OAglxyXG4g4peGICDorr7mlbDnu4RwcmVbbl3kv53lrZjku45Wc+WIsOWFtuWug+mhtueCueeahOacgOefrei3r+W+hOOAguiLpXByZVtpXT1r77yM6KGo56S65LuOVnMg5YiwVmnnmoTmnIDnn63ot6/lvoTkuK3vvIxWaeeahOWJjeS4gOS4qumhtueCueaYr1Zr77yM5Y2z5pyA55+t6Lev5b6E5bqP5YiX5pivKFZzICwg4oCmLCBWayAgLCBWaSkg44CCXHJcbiDil4Yg6K6+5pWw57uEZmluYWxbbl3vvIzmoIfor4bkuIDkuKrpobbngrnmmK/lkKblt7LliqDlhaVT5Lit44CCXHJcblxyXG4gNSAg566X5rOV5YiG5p6QXHJcbiBEaWprc3RyYeeul+azleeahOS4u+imgeaJp+ihjOaYr++8mlxyXG4g4peGIOaVsOe7hOWPmOmHj+eahOWIneWni+WMlu+8muaXtumXtOWkjeadguW6puaYr08obikg77ybXHJcbiDil4Yg5rGC5pyA55+t6Lev5b6E55qE5LqM6YeN5b6q546v77ya5pe26Ze05aSN5p2C5bqm5pivTyhuMikg77ybXHJcbiDlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4yKSDjgIJcclxuXHJcbiAqL1xyXG5cclxubGV0IGRpalRlc3QgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XHJcblxyXG5kaWpUZXN0LmFkZFZlcnRleCgnMCcpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnMScpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnMicpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnMycpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnNCcpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnNScpO1xyXG5cclxuZGlqVGVzdC5hZGRBcmMoJzAnLCAnMScsIHthZGo6IDIwfSk7XHJcbmRpalRlc3QuYWRkQXJjKCcwJywgJzQnLCB7YWRqOiAxMH0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMCcsICcyJywge2FkajogNjB9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzAnLCAnNScsIHthZGo6IDY1fSk7XHJcbmRpalRlc3QuYWRkQXJjKCcxJywgJzInLCB7YWRqOiAzMH0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMicsICczJywge2FkajogNDB9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzUnLCAnMicsIHthZGo6IDE1fSk7XHJcbmRpalRlc3QuYWRkQXJjKCc0JywgJzUnLCB7YWRqOiAyMH0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMycsICc0Jywge2FkajogMzV9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMycsIHthZGo6IDcwfSk7XHJcblxyXG5kaWpUZXN0LnNob3J0ZXN0UGF0aF9EaWprc3RyYSgwKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG4g5q+P5LiA5a+56aG254K56Ze055qE5pyA55+t6Lev5b6EXHJcblxyXG4g55SoRGlqa3N0cmHnrpfms5XkuZ/lj6/ku6XmsYLlvpfmnInlkJHlm75HPShW77yMRSnkuK3mr4/kuIDlr7npobbngrnpl7TnmoTmnIDnn63ot6/lvoTjgILmlrnms5XmmK/vvJrmr4/mrKHku6XkuIDkuKrkuI3lkIznmoTpobbngrnkuLrmupDngrnph43lpI1EaWprc3RyYeeul+azleS+v+WPr+axguW+l+avj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hO+8jOaXtumXtOWkjeadguW6puaYr08objMpIOOAglxyXG5cclxuIOW8l+e9l+S8iuW+tyhGbG95ZCnmj5Dlh7rkuoblj6bkuIDkuKrnrpfms5XvvIzlhbbml7bpl7TlpI3mnYLluqbku43mmK9PKG4zKSDvvIwg5L2G566X5rOV5b2i5byP5pu05Li6566A5piO44CCXHJcblxyXG4gMSDnrpfms5XmgJ3mg7NcclxuXHJcbiDorr7pobbngrnpm4ZTKOWIneWAvOS4uuepuinvvIznlKjmlbDnu4RB55qE5q+P5Liq5YWD57SgQVtpXVtqXeS/neWtmOS7jlZp5Y+q57uP6L+HU+S4reeahOmhtueCueWIsOi+vlZq55qE5pyA55+t6Lev5b6E6ZW/5bqm77yM5YW25oCd5oOz5piv77yaXHJcbiDikaAg5Yid5aeL5pe25LukUz17IH0g77yMIEFbaV1bal3nmoTotYvliJ3lgLzmlrnlvI/mmK/vvJpcclxuIDAgICAgaSA9auaXtlxyXG4gQVtpXVtqXT0gICAgV2lqICAgICBp4omgauS4lDx2aSx2aj7iiIhF77yMIHdpauS4uuW8p+S4iueahOadg+WAvFxyXG4g4oieICAgaeKJoGrkuJQ8dmksdmo+5LiN5bGe5LqORVxyXG4g4pGhIOWwhuWbvuS4reS4gOS4qumhtueCuVZrIOWKoOWFpeWIsFPkuK3vvIzkv67mlLlBW2ldW2pd55qE5YC877yM5L+u5pS55pa55rOV5piv77yaXHJcbiBBW2ldW2pdPU1pbntBW2ldW2pdICwgKEFbaV1ba10rQVtrXVtqXSkgfVxyXG4g5Y6f5Zug77yaIOS7jlZq5Y+q57uP6L+HU+S4reeahOmhtueCuShWaynliLDovr5WaueahOi3r+W+hOmVv+W6puWPr+iDveavlOWOn+adpeS4jee7j+i/h1Zr55qE6Lev5b6E5pu055+t44CCXHJcbiDikaIg6YeN5aSN4pGh77yM55u05YiwR+eahOaJgOaciemhtueCuemDveWKoOWFpeWIsFPkuK3kuLrmraLjgIJcclxuXHJcbiAyIOeul+azleWunueOsFxyXG5cclxuIOKXhiAg5a6a5LmJ5LqM57u05pWw57uEUGF0aFtuXVtuXShu5Li65Zu+55qE6aG254K55pWwKSDvvIzlhYPntKBQYXRoW2ldW2pd5L+d5a2Y5LuOVmnliLBWaueahOacgOefrei3r+W+hOaJgOe7j+i/h+eahOmhtueCueOAglxyXG4g4peGIOiLpVBhdGhbaV1bal09a++8muS7jlZp5YiwVmog57uP6L+HVmsg77yM5pyA55+t6Lev5b6E5bqP5YiX5pivKFZpICwg4oCmLCBWayAsIOKApiwgVmopIO+8jOWImei3r+W+hOWtkOW6j+WIl++8mihWaSAsIOKApiwgVmsp5ZKMKFZrICwg4oCmLCBWainkuIDlrprmmK/ku45WaeWIsFZr5ZKM5LuOVmvliLBWaiDnmoTmnIDnn63ot6/lvoTjgILku47ogIzlj6/ku6XmoLnmja5QYXRoW2ldW2td5ZKMUGF0aFtrXVtqXeeahOWAvOWGjeaJvuWIsOivpei3r+W+hOS4iuaJgOe7j+i/h+eahOWFtuWug+mhtueCue+8jOKApuS+neatpOexu+aOqOOAglxyXG4g4peGIOWIneWni+WMluS4ulBhdGhbaV1bal09LTHvvIzooajnpLrku45WaeWIsFZqIOS4jee7j+i/h+S7u+S9lShT5Lit55qE5Lit6Ze0KemhtueCueOAguW9k+afkOS4qumhtueCuVZr5Yqg5YWl5YiwU+S4reWQjuS9v0FbaV1bal3lj5jlsI/ml7bvvIzku6RQYXRoW2ldW2pdPWvjgIJcclxuXHJcblxyXG4gKi9cclxuXHJcbmxldCBmbG95ZCA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIEROKTtcclxuZmxveWQuYWRkVmVydGV4KCd2MCcpO1xyXG5mbG95ZC5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmZsb3lkLmFkZFZlcnRleCgndjInKTtcclxuZmxveWQuYWRkQXJjKCd2MCcsICd2MicsIHthZGo6IDh9KTtcclxuZmxveWQuYWRkQXJjKCd2MCcsICd2MScsIHthZGo6IDJ9KTtcclxuZmxveWQuYWRkQXJjKCd2MScsICd2MicsIHthZGo6IDR9KTtcclxuZmxveWQuYWRkQXJjKCd2MicsICd2MCcsIHthZGo6IDV9KTtcclxuXHJcbmZsb3lkLnNob3J0ZXN0UGF0aF9GTE9ZRCgpO1xyXG5cclxuLy8gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1L2FydGljbGUvZGV0YWlscy83NzE5NDI4XHJcbi8vIOa3u+WKoOOAiuWbvueahOW6lOeUqOivpuinoy3mlbDmja7nu5PmnoTjgItcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9HcmFwaC9BZGphY2VuY3lNYXRyaXhHcmFwaC5qc1xuICoqLyIsIi8qXHJcbiDljYHlrZfpk77ooajms5VcclxuXHJcbiDljYHlrZfpk77ooagoT3J0aG9nb25hbCBMaXN0KeaYr+acieWQkeWbvueahOWPpuS4gOenjemTvuW8j+WtmOWCqOe7k+aehO+8jOaYr+WwhuacieWQkeWbvueahOato+mCu+aOpeihqOWSjOmAhumCu+aOpeihqOe7k+WQiOi1t+adpeW+l+WIsOeahOS4gOenjemTvuihqOOAglxyXG5cclxuIOWcqOi/meenjee7k+aehOS4re+8jOavj+adoeW8p+eahOW8p+WktOe7k+eCueWSjOW8p+Wwvue7k+eCuemDveWtmOaUvuWcqOmTvuihqOS4re+8jOW5tuWwhuW8p+e7k+eCueWIhuWIq+e7hOe7h+WIsOS7peW8p+Wwvue7k+eCueS4uuWktCjpobbngrkp57uT54K55ZKM5Lul5byn5aS057uT54K55Li65aS0KOmhtueCuSnnu5PngrnnmoTpk77ooajkuK3jgIJcclxuXHJcbiDil4YgIGRhdGHln5/vvJrlrZjlgqjlkozpobbngrnnm7jlhbPnmoTkv6Hmga/vvJtcclxuIOKXhiDmjIfpkojln59maXJzdGlu77ya5oyH5ZCR5Lul6K+l6aG254K55Li65byn5aS055qE56ys5LiA5p2h5byn5omA5a+55bqU55qE5byn57uT54K577ybXHJcbiDil4Yg5oyH6ZKI5Z+fZmlyc3RvdXTvvJrmjIflkJHku6Xor6XpobbngrnkuLrlvKflsL7nmoTnrKzkuIDmnaHlvKfmiYDlr7nlupTnmoTlvKfnu5PngrnvvJtcclxuIOKXhiDlsL7ln590YWlsdmV477ya5oyH56S65byn5bC+6aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXHJcbiDil4Yg5aS05Z+faGVhZHZleO+8muaMh+ekuuW8p+WktOmhtueCueWcqOWbvuS4reeahOS9jee9ru+8m1xyXG4g4peGIOaMh+mSiOWfn2hsaW5r77ya5oyH5ZCR5byn5aS055u45ZCM55qE5LiL5LiA5p2h5byn77ybXHJcbiDil4Yg5oyH6ZKI5Z+fdGxpbmvvvJrmjIflkJHlvKflsL7nm7jlkIznmoTkuIvkuIDmnaHlvKfvvJtcclxuIOKXhiBJbmZv5Z+f77ya5oyH5ZCR6K+l5byn55qE55u45YWz5L+h5oGv77ybXHJcblxyXG4g5LuO6L+Z56eN5a2Y5YKo57uT5p6E5Zu+5Y+v5Lul55yL5Ye677yM5LuO5LiA5Liq6aG254K557uT54K555qEZmlyc3RvdXTlh7rlj5HvvIzmsr/ooajnu5PngrnnmoR0bGlua+aMh+mSiOaehOaIkOS6huato+mCu+aOpeihqOeahOmTvuihqOe7k+aehO+8jOiAjOS7juS4gOS4qumhtueCuee7k+eCueeahGZpcnN0aW7lh7rlj5HvvIzmsr/ooajnu5PngrnnmoRobGlua+aMh+mSiOaehOaIkOS6humAhumCu+aOpeihqOeahOmTvuihqOe7k+aehOOAglxyXG5cclxuICovXHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlYWRWZXgg5byn55qE5aS06aG254K555qE5L2N572uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YWlsVmV4IOW8p+eahOWwvumhtueCueS9jee9rlxyXG4gKiBAcGFyYW0ge0FyY0JveH0gaExpbmsg5byn5aS055u45ZCM55qE5byn55qE6ZO+5Z+fXHJcbiAqIEBwYXJhbSB7QXJjQm94fSB0TGluayDlvKflsL7nm7jlkIznmoTlvKfnmoTpk77ln59cclxuICogQHBhcmFtIHsqfSBpbmZvXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQXJjQm94KHRhaWxWZXgsIGhlYWRWZXgsIGhMaW5rLCB0TGluaywgaW5mbykge1xyXG4gICAgdGhpcy5oZWFkVmV4ID0gaGVhZFZleCB8fCAwO1xyXG4gICAgdGhpcy50YWlsVmV4ID0gdGFpbFZleCB8fCAwO1xyXG4gICAgdGhpcy5oTGluayA9IGhMaW5rIHx8IG51bGw7XHJcbiAgICB0aGlzLnRMaW5rID0gdExpbmsgfHwgbnVsbDtcclxuICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gKiBAcGFyYW0ge0FyY0JveH0gZmlyc3RJbiDor6XpobbngrnnrKzkuIDmnaHlhaXlvKdcclxuICogQHBhcmFtIHtBcmNCb3h9IGZpcnN0T3V0IOivpemhtueCueesrOS4gOadoeWHuuW8p1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE9MVmV4Tm9kZShkYXRhLCBmaXJzdEluLCBmaXJzdE91dCkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCBudWxsO1xyXG4gICAgdGhpcy5maXJzdEluID0gZmlyc3RJbiB8fCBudWxsO1xyXG4gICAgdGhpcy5maXJzdE91dCA9IGZpcnN0T3V0IHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5IHwgT0xWZXhOb2RlfSB4TGlzdCDooajlpLTlkJHph49cclxuICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bSDmnInlkJHlm77nmoTlvZPliY3pobbngrnmlbBcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFyY251bSDmnInlkJHlm77nmoTlvZPliY3lvKfmlbBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBPTEdyYXBoKHhMaXN0LCB2ZXhudW0sIGFyY251bSkge1xyXG4gICAgdGhpcy54TGlzdCA9IHhMaXN0IHx8IFtdO1xyXG4gICAgdGhpcy52ZXhudW0gPSB2ZXhudW0gfHwgMDtcclxuICAgIHRoaXMuYXJjbnVtID0gYXJjbnVtIHx8IDA7XHJcbn1cclxuZXhwb3J0cy5PTEdyYXBoID0gT0xHcmFwaDtcclxuT0xHcmFwaC5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogT0xHcmFwaCxcclxuXHJcbiAgICBsb2NhdGVWZXg6IGZ1bmN0aW9uICh2cCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5kYXRhID09PSB2cCkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIOWIoOmZpOmhtueCuVxyXG4gICAgZGVsZXRlVmVydGV4OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBtID0gdGhpcy5sb2NhdGVWZXgodik7XHJcblxyXG4gICAgICAgIGlmIChtIDwgMCkgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kIScpO1xyXG5cclxuICAgICAgICB2YXIgbiA9IHRoaXMudmV4bnVtO1xyXG4gICAgICAgIHZhciBxLCBpLCBwO1xyXG4gICAgICAgIC8vIOWIoOmZpOaJgOacieS7pXbkuLrlpLTnmoTovrlcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIOWmguaenOW+heWIoOmZpOeahOi+ueaYr+WktOmTvuS4iueahOesrOS4gOS4que7k+eCuVxyXG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5maXJzdEluLnRhaWxWZXggPT09IG0pIHtcclxuICAgICAgICAgICAgICAgIHEgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhMaXN0W2ldLmZpcnN0SW4gPSBxLmhMaW5rO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAocCA9IHRoaXMueExpc3RbaV0uZmlyc3RJbjsgcCAmJiBwLmhMaW5rLnRhaWxWZXggIT09IG07IHAgPSBwLmhMaW5rKTtcclxuICAgICAgICAgICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHAuaExpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5oTGluayA9IHEuaExpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Yig6Zmk5omA5pyJ5LulduS4uuWwvueahOi+uVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5b6F5Yig6Zmk55qE6L655piv5bC+6ZO+5LiK55qE56ys5LiA5Liq57uT54K5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmZpcnN0T3V0LmhlYWRWZXggPT09IG0pIHtcclxuICAgICAgICAgICAgICAgIHEgPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdE91dCA9IHEudExpbms7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDsgcCAmJiBwLnRMaW5rLmhlYWRWZXggIT09IG07IHAgPSBwLnRMaW5rKTtcclxuICAgICAgICAgICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHAudExpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgcC50TGluayA9IHEudExpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6aG65qyh55So57uT54K5beS5i+WQjueahOmhtueCueWPluS7o+WJjeS4gOS4qumhtueCuVxyXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgLy8g5L+u5pS56KGo5aS05ZCR6YePXHJcbiAgICAgICAgICAgIHRoaXMueExpc3RbaV0gPSB0aGlzLnhMaXN0W2kgKyAxXTtcclxuICAgICAgICAgICAgZm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdEluOyBwOyBwID0gcC5oTGluaylcclxuICAgICAgICAgICAgICAgIHAuaGVhZFZleC0tO1xyXG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaylcclxuICAgICAgICAgICAgICAgIHAudGFpbFZleC0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52ZXhudW0tLTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlREc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnZleG51bSA9IHByb21wdCgnVmV4bnVtOiAnKTtcclxuICAgICAgICB0aGlzLmFyY251bSA9IHByb21wdCgnQXJjbnVtOiAnKTtcclxuICAgICAgICAvLyBJbmNJbmZv5Li6MOWImeWQhOW8p+S4jeWQq+WFtuS7luS/oeaBr1xyXG4gICAgICAgIHZhciBpbmNJbmZvID0gK3Byb21wdCgnSW5jSW5mbzogJyk7XHJcblxyXG4gICAgICAgIC8vIOi+k+WFpemhtueCueWAvFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnhMaXN0W2ldID0gbmV3IE9MVmV4Tm9kZShwcm9tcHQoJ2RhdGE6ICcpLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5hcmNudW07ICsraykge1xyXG4gICAgICAgICAgICB2YXIgdjEgPSBwcm9tcHQoJ3YxOiAnKTtcclxuICAgICAgICAgICAgdmFyIHYyID0gcHJvbXB0KCd2MjogJyk7XHJcblxyXG4gICAgICAgICAgICBpID0gdGhpcy5sb2NhdGVWZXgodjEpO1xyXG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KHYyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpID09PSAtMSB8fCBqID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ+aXoOatpOmhtueCue+8jOivt+mHjeaWsOi+k+WFpSEnKTtcclxuICAgICAgICAgICAgICAgIGstLTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBBcmNCb3goaSwgaiwgdGhpcy54TGlzdFtqXS5maXJzdEluLCB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0LCBpbmNJbmZvICYmIHByb21wdCgnaW5mbzogJykpO1xyXG4gICAgICAgICAgICB0aGlzLnhMaXN0W2pdLmZpcnN0SW4gPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0ID0gcDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rGC5pyJ5ZCR5Zu+55qE5by66L+e6YCa5YiG6YePXHJcbiAgICAgKi9cclxuICAgIGdldFNHcmFwaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aXNpdGVkID0gW107XHJcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gW107XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcbiAgICAgICAgLy8g56ys5LiA5qyh5rex5bqm5LyY5YWI6YGN5Y6G5bu656uLZmluaXNoZWTmlbDnu4RcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmczEodGhpcywgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOa4heepunZpc2l0ZWTmlbDnu4RcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIOesrOS6jOasoemAhuWQkeeahOa3seW6puS8mOWFiOmBjeWOhlxyXG4gICAgICAgIGZvciAodmFyIGxlbiA9IHRoaXMudmV4bnVtIC0gMTsgbGVuID49IDA7IC0tbGVuKSB7XHJcbiAgICAgICAgICAgIGkgPSBmaW5pc2hlZFtpXTtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnMyKHRoaXMsIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGZzMShncmFwaCwgdikge1xyXG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBwLmhlYWRWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbd10pIGRmczEoZ3JhcGgsIHcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmlzaGVkWysrY291bnRdID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRmczIoZ3JhcGgsIHYpIHtcclxuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZCcsIHYpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwID0gZ3JhcGgueExpc3Rbdl0uZmlyc3RJbjsgcDsgcCA9IHAuaExpbmspIHtcclxuICAgICAgICAgICAgICAgIHZhciB3ID0gcC50YWlsVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3ddKSBkZnMyKGdyYXBoLCB3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8vdmFyIGcgPSBuZXcgT0xHcmFwaCgpO1xyXG4vL2cuY3JlYXRlREcoKTtcclxuLy9jb25zb2xlLmxvZyhnKTtcclxuXHJcblxyXG4vKlxyXG4g5pyJ5ZCR5Zu+55qE5by66L+e6YCa5YiG6YePXHJcblxyXG4g5a+55LqO5pyJ5ZCR5Zu+77yM5Zyo5YW25q+P5LiA5Liq5by66L+e6YCa5YiG6YeP5Lit77yM5Lu75L2V5Lik5Liq6aG254K56YO95piv5Y+v6L6+55qE44CCIFbiiIhH77yM5LiOVuWPr+ebuOS6kuWIsOi+vueahOaJgOaciemhtueCueWwseaYr+WMheWQq1bnmoTlvLrov57pgJrliIbph4/nmoTmiYDmnInpobbngrnjgIJcclxuXHJcbiDorr7ku45W5Y+v5Yiw6L6+ICjku6VW5Li66LW354K555qE5omA5pyJ5pyJ5ZCR6Lev5b6E55qE57uI54K5KeeahOmhtueCuembhuWQiOS4ulQxKEcp77yM6ICM5Yiw6L6+ViAo5LulVuS4uue7iOeCueeahOaJgOacieacieWQkei3r+W+hOeahOi1t+eCuSnnmoTpobbngrnpm4blkIjkuLpUMihHKe+8jOWImeWMheWQq1bnmoTlvLrov57pgJrliIbph4/nmoTpobbngrnpm4blkIjmmK/vvJogVDEoRyniiKlUMihHKSDjgIJcclxuXHJcbiDmsYLmnInlkJHlm75H55qE5by66L+e6YCa5YiG6YeP55qE5Z+65pys5q2l6aqk5piv77yaXHJcbiDikbQg5a+5R+i/m+ihjOa3seW6puS8mOWFiOmBjeWOhu+8jOeUn+aIkEfnmoTmt7HluqbkvJjlhYjnlJ/miJDmo67mnpdU44CCXHJcbiDikbUgIOWvueajruael1TnmoTpobbngrnmjInkuK3luo/pgY3ljobpobrluo/ov5vooYznvJblj7fjgIJcclxuIOKRtiAg5pS55Y+YR+S4reavj+S4gOadoeW8p+eahOaWueWQke+8jOaehOaIkOS4gOS4quaWsOeahOacieWQkeWbvkfigJnjgIJcclxuIOKRtyAg5oyJ4pG15Lit5qCH5Ye655qE6aG254K557yW5Y+377yM5LuO57yW5Y+35pyA5aSn55qE6aG254K55byA5aeL5a+5R+KAmei/m+ihjOa3seW6puS8mOWFiOaQnOe0ou+8jOW+l+WIsOS4gOajtea3seW6puS8mOWFiOeUn+aIkOagkeOAguiLpeS4gOasoeWujOaVtOeahOaQnOe0oui/h+eoi+ayoeaciemBjeWOhkfigJnnmoTmiYDmnInpobbngrnvvIzliJnku47mnKrorr/pl67nmoTpobbngrnkuK3pgInmi6nkuIDkuKrnvJblj7fmnIDlpKfnmoTpobbngrnvvIznlLHlroPlvIDlp4vlho3ov5vooYzmt7HluqbkvJjlhYjmkJzntKLvvIzlubblvpfliLDlj6bkuIDmo7Xmt7HluqbkvJjlhYjnlJ/miJDmoJHjgILlnKjor6XmraXpqqTkuK3vvIzmr4/kuIDmrKHmt7HluqbkvJjlhYjmkJzntKLmiYDlvpfliLDnmoTnlJ/miJDmoJHkuK3nmoTpobbngrnlsLHmmK9H55qE5LiA5Liq5by66L+e6YCa5YiG6YeP55qE5omA5pyJ6aG254K544CCXHJcbiDikbggIOmHjeWkjeatpemqpOKRtyDvvIznm7TliLBH4oCZ5Lit55qE5omA5pyJ6aG254K56YO96KKr6K6/6Zeu44CCXHJcblxyXG4g5Zyo566X5rOV5a6e546w5pe277yM5bu656uL5LiA5Liq5pWw57uEaW5fb3JkZXJbbl3lrZjmlL7mt7HluqbkvJjlhYjnlJ/miJDmo67mnpfnmoTkuK3luo/pgY3ljobluo/liJfjgILlr7nmr4/kuKrpobbngrl277yM5Zyo6LCD55SoREZT5Ye95pWw57uT5p2f5pe277yM5bCG6aG254K55L6d5qyh5a2Y5pS+5Zyo5pWw57uEaW5fb3JkZXJbbl3kuK3jgILlm77ph4fnlKjljYHlrZfpk77ooajkvZzkuLrlrZjlgqjnu5PmnoTmnIDlkIjpgILjgIJcclxuXHJcbiAqL1xyXG5cclxuLy8gdG9kbyB0byBiZSB0ZXN0ZWRcclxuT0xHcmFwaC5wcm90b3R5cGUuY29ubmVjdGVkX0RHID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZpc2l0ZWQgPSBbXTtcclxuICAgIHZhciBpbl9vcmRlciA9IFtdO1xyXG4gICAgdmFyIGNvdW50ID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgIC8vIOWvueWbvuato+WQkemBjeWOhlxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgZGZzKHRoaXMsIGksIGluX29yZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgIC8vIOWvueWbvumAhuWQkemBjeWOhlxyXG4gICAgdmFyIGsgPSAxO1xyXG4gICAgZm9yICh2YXIgaiA9IHRoaXMudmV4bnVtIC0gMTsgaiA+PSAwOyAtLWopIHtcclxuICAgICAgICB2YXIgdiA9IGluX29yZGVyW2pdO1xyXG4gICAgICAgIGlmICghdmlzaXRlZFt2XSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn56ysJyArIGsrKyArICfkuKrov57pgJrliIbph4/pobbngrknKTtcclxuICAgICAgICAgICAgcmV2X2Rmcyh0aGlzLCB2KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2KSB7XHJcbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuaGVhZFZleF0pIHtcclxuICAgICAgICAgICAgICAgIGRmcyhncmFwaCwgcC5oZWFkVmV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5fb3JkZXJbY291bnQrK10gPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJldl9kZnMoZ3JhcGgsIHYpIHtcclxuICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuICAgICAgICBjb25zb2xlLmxvZygn6aG254K577yaJyArIHYpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwID0gZ3JhcGgueExpc3Rbdl0uZmlyc3RJbjsgcDsgcCA9IHAuaExpbmspIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AudGFpbFZleF0pIHtcclxuICAgICAgICAgICAgICAgIHJldl9kZnMoZ3JhcGgsIHAudGFpbFZleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvR3JhcGgvT0xHcmFwaC5qc1xuICoqLyIsIi8qKlxyXG4gKiBMUlUoIExlYXN0IHJlY2VudGx5IHVzZWQgKVxyXG4gKi9cclxuXHJcbmltcG9ydCBEb3VibGVMaW5rZWRMaXN0IGZyb20gJy4vRG91YmxlTGlua2VkTGlzdCc7XHJcblxyXG5jb25zdCBMSU1JVCA9IDIwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFJVQ2FjaGUge1xyXG4gICAgY29uc3RydWN0b3Ioc3FMaXN0LCBsaW1pdCA9IExJTUlUKXtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgc3FMaXN0ID0gKHNxTGlzdCAmJiBzcUxpc3QubGVuZ3RoKSA/IHNxTGlzdCAmJiBzcUxpc3QubGVuZ3RoLnNsaWNlKDAsIHRoaXMubGltaXQpIDogW107XHJcbiAgICAgICAgdGhpcy5fX2NhY2hlID0gbmV3IERvdWJsZUxpbmtlZExpc3Qoc3FMaXN0LCBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgICAgICAgcmV0dXJuIGEua2V5ID09PSBiLmtleTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBzaXplKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZS5zaXplO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZW1vdmUoa2V5KXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnJlbW92ZSh7IGtleSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fX2NhY2hlLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdldChrZXkpe1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX19jYWNoZS5pbmRleE9mKHsga2V5IH0pO1xyXG5cclxuICAgICAgICBpZihpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5fX2NhY2hlLmZpbmRCeUluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnJlbW92ZShkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnVuc2hpZnQoZGF0YSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgYWRkKGtleSwgdmFsdWUpe1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICBpZihkYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZih0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYWNoZS5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnVuc2hpZnQoe1xyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCl7XHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIHRoaXMuX19jYWNoZS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBhcnIucHVzaChgJHsgZGF0YS5rZXkgfTokeyBkYXRhLnZhbHVlIH1gKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5qb2luKCcgPiAnKTtcclxuICAgIH1cclxuXHJcbiAgICB0b0pTT04oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnRvSlNPTigpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zb2xlLmxvZygnTFJVQ2FjaGUnKTtcclxuXHJcbmxldCBhID0gbmV3IExSVUNhY2hlKFtdLCAzKTtcclxuYS5hZGQoJ2FkYW0nLCAyOSk7XHJcbmEuYWRkKCdqb2huJywgMjYpO1xyXG5hLmFkZCgnYW5nZWxhJywgMjQpO1xyXG5jb25zb2xlLmxvZyhhICsgJycpO1xyXG5hLmdldCgnam9obicpO1xyXG5jb25zb2xlLmxvZyhhICsgJycpO1xyXG5hLmFkZCgnem9ycm8nLCAxNDEpO1xyXG5jb25zb2xlLmxvZyhhICsgJycpO1xyXG5jb25zb2xlLmxvZyhhLnRvSlNPTigpKTtcclxuXHJcbmZvcihsZXQgaXRlbSBvZiBhKXtcclxuICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xyXG59XHJcblxyXG5hLnJlbW92ZSgnem9ycm8nKTtcclxuYS5yZW1vdmUoJ2pvaG4nKTtcclxuYS5yZW1vdmUoJ2FuZ2VsYScpO1xyXG5jb25zb2xlLmxvZyhhICsgJycpO1xyXG5cclxuY29uc29sZS5sb2coJ0xSVUNhY2hlRW5kJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9MUlUuanNcbiAqKi8iLCIvKipcclxuICog57q/5oCn6KGoXHJcbiAqL1xyXG5cclxuLy8g57q/5oCn6KGo55qE57G75Z6L5a6a5LmJXHJcbi8vIOWwhuaJgOacieWcqOaVsOe7hGLkuK3kvYbkuI3lnKjmlbDnu4Rh55qE5pWw5o2u5YWD57Sg5o+S5YWl5YiwYeS4rVxyXG5cclxudmFyIGEgPSBbMSwgMiwgMywgNCwgNV07XHJcbnZhciBiID0gWzEsIDMsIDUsIDcsIDldO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uKGEsIGIpIHtcclxuICAgIHZhciBlbGVtLCBlcXVhbDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgYkxlbiA9IGIubGVuZ3RoOyBpIDwgYkxlbjsgaSsrKSB7XHJcbiAgICAgICAgZWxlbSA9IGJbaV07XHJcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGFMZW4gPSBhLmxlbmd0aDsgaiA8IGFMZW47IGorKykge1xyXG4gICAgICAgICAgICBpZiAoZWxlbSA9PT0gYVtqXSkge1xyXG4gICAgICAgICAgICAgICAgZXF1YWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZXF1YWwpIGEucHVzaChlbGVtKTtcclxuICAgIH1cclxufVxyXG5cclxudW5pb24oYSwgYik7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG4vLyBbMSwgMiwgMywgNCwgNSwgNywgOV1cclxuXHJcbi8vIOaXtumXtOWkjeadguW6pu+8mk8oYUxlbiAqIGJMZW4pXHJcblxyXG4vLyDlt7Lnn6XmlbDnu4Rh5ZKM5pWw57uEYuS4reeahOaVsOaNruWFg+e0oOaMieWAvOmdnumAkuWHj+aOkuWIl1xyXG4vLyDlvZLlubZh5ZKMYuW+l+WIsOaWsOeahOaVsOe7hGPvvIxj55qE5pWw5o2u5YWD57Sg5Lmf5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXHJcbnZhciBhID0gWzMsIDUsIDgsIDExXTtcclxudmFyIGIgPSBbMiwgNiwgOCwgOSwgMTEsIDE1LCAyMF07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMaXN0KGEsIGIpIHtcclxuICAgIHZhciBjID0gW10sIGFFbGVtLCBiRWxlbTtcclxuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xyXG4gICAgdmFyIGFMZW4gPSBhLmxlbmd0aDtcclxuICAgIHZhciBiTGVuID0gYi5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBhTGVuICYmIGogPCBiTGVuKSB7XHJcbiAgICAgICAgYUVsZW0gPSBhW2ldO1xyXG4gICAgICAgIGJFbGVtID0gYltqXTtcclxuXHJcbiAgICAgICAgaWYgKGFFbGVtIDwgYkVsZW0pIHtcclxuICAgICAgICAgICAgY1trKytdID0gYUVsZW07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjW2srK10gPSBiRWxlbTtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcclxuICAgICAgICBjW2srK10gPSBhW2krK107XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGogPCBiTGVuKSB7XHJcbiAgICAgICAgY1trKytdID0gYltqKytdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjO1xyXG59XHJcblxyXG52YXIgYyA9IG1lcmdlTGlzdChhLCBiKTtcclxuY29uc29sZS5sb2coYyk7XHJcbi8vIFsyLCAzLCA1LCA2LCA4LCA4LCA5LCAxMSwgMTEsIDE1LCAyMF1cclxuXHJcbi8vIOaXtumXtOWkjeadguW6pu+8miBPKGFMZW4gKyBiTGVuKVxyXG5cclxuLy8g57q/5oCn6KGo55qE6aG65bqP6KGo56S65ZKM5a6e546wXHJcbi8vIOS9v+eUqOS8quaVsOe7hOaooeaLn+e6v+aAp+ihqOaPkuWFpeaTjeS9nOeahOWJjeWQjuaVsOaNruWFg+e0oOWcqOWtmOWCqOepuumXtOS4reeahOS9jee9ruWPmOWMllxyXG52YXIgYSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1fTtcclxuYS5sZW5ndGggPSA2O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydChhLCBpLCBlbGVtKSB7XHJcbiAgICBpZiAoIWVsZW0pIHJldHVybjtcclxuXHJcbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XHJcbiAgICBpZiAoaSA+PSBsZW4pIHtcclxuICAgICAgICB3aGlsZSAobGVuIDwgaSkge1xyXG4gICAgICAgICAgICBhW2xlbisrXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgYS5sZW5ndGgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgYVtpXSA9IGVsZW07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlIChsZW4gPiBpKSB7XHJcbiAgICAgICAgICAgIGFbbGVuLS1dID0gYVtsZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2ldID0gZWxlbTtcclxuICAgIH1cclxuICAgIGEubGVuZ3RoKys7XHJcbn1cclxuXHJcbmluc2VydChhLCAzLCA4KTtcclxuaW5zZXJ0KGEsIDEwLCAxMCk7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG5cclxuLy8g5L2/55So5Lyq5pWw57uE5qih5ouf57q/5oCn6KGo5Yig6Zmk5pON5L2c55qE5YmN5ZCO5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo56m66Ze05Lit55qE5L2N572u5Y+Y5YyWXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVsKGEsIGkpIHtcclxuICAgIHZhciB0ZW1wID0gYVtpXTtcclxuICAgIHZhciBqID0gaSArIDE7XHJcbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKGogPCBsZW4pIHtcclxuICAgICAgICBhW2ogLSAxXSA9IGFbaisrXTtcclxuICAgIH1cclxuICAgIGEubGVuZ3RoLS07XHJcbiAgICBkZWxldGUgYVtsZW4gLSAxXTtcclxuXHJcbiAgICByZXR1cm4gdGVtcDtcclxufVxyXG5cclxuZGVsKGEsIDMpO1xyXG5jb25zb2xlLmxvZyhhKTtcclxuZGVsKGEsIDEwKTtcclxuY29uc29sZS5sb2coYSk7XHJcblxyXG4vLyDml7bpl7TlpI3mnYLluqbvvJogTyhhLmxlbmd0aClcclxuXHJcbi8vIOavlOi+g+Wtl+espuihqEHlkoxC77yM5bm255So6L+U5Zue5YC86KGo56S657uT5p6c77yM5YC85Li6Me+8jOihqOekukE+Qu+8jOWAvOS4ui0x77yM6KGo56S6QTxC77yM5YC85Li6MO+8jOihqOekukE9QlxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdENvbXAoYUxpc3QsIGJMaXN0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFMaXN0Lmxlbmd0aCAmJiBpIDwgYkxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYUxpc3RbaV0gIT09IGJMaXN0W2ldKSByZXR1cm4gYUxpc3RbaV0gPiBiTGlzdFtpXSA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYUxpc3QubGVuZ3RoID09IGJMaXN0Lmxlbmd0aCkgcmV0dXJuIDA7XHJcblxyXG4gICAgcmV0dXJuIGFMaXN0Lmxlbmd0aCA+IGJMaXN0Lmxlbmd0aCA/IDEgOiAtMTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2UobGlzdCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPD0gajsgaSsrLCBqLS0pIHtcclxuICAgICAgICB2YXIgdGVtcCA9IGxpc3RbaV07XHJcbiAgICAgICAgbGlzdFtpXSA9IGxpc3Rbal07XHJcbiAgICAgICAgbGlzdFtqXSA9IHRlbXA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIOaxguWFg+e0oOmAkuWinuaOkuWIl+eahOe6v+aAp+ihqEHlkoxC55qE5YWD57Sg55qE5Lqk6ZuG5bm25a2Y5YWlQ1xyXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0KGFMaXN0LCBiTGlzdCkge1xyXG4gICAgdmFyIGNMaXN0ID0gW107XHJcbiAgICB2YXIgaSA9IDAsIGogPSAwLCBrID0gMDtcclxuXHJcbiAgICB3aGlsZSAoYUxpc3RbaV0gJiYgYkxpc3Rbal0pIHtcclxuICAgICAgICBpZiAoYUxpc3RbaV0gPCBiTGlzdFtqXSkgaSsrO1xyXG4gICAgICAgIGVsc2UgaWYgKGFMaXN0W2ldID4gYkxpc3Rbal0pIGorKztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY0xpc3RbaysrXSA9IGFMaXN0W2ldO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGorKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNMaXN0O1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhpbnRlcnNlY3QoWzEsIDMsIDUsIDcsIDldLCBbMSwgNSwgOSwgMTMsIDE3XSkgKyAnJyk7XHJcblxyXG4vLyDmsYLlhYPntKDpgJLlop7mjpLliJfnmoTnur/mgKfooahB5ZKMQueahOWFg+e0oOeahOS6pOmbhuW5tuWtmOWFpeWbnmFcclxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdF90cnVlKGEsIGIpIHtcclxuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xyXG5cclxuICAgIHdoaWxlIChhW2ldICYmIGJbal0pIHtcclxuICAgICAgICBpZiAoYVtpXSA8IGJbal0pIGkrKztcclxuICAgICAgICBlbHNlIGlmIChhW2ldID4gYltqXSkgaisrO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhW2srK10gPSBhW2ldO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGorKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGFba10pIGEuc3BsaWNlKGssIDEpO1xyXG5cclxuICAgIHJldHVybiBhO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhpbnRlcnNlY3RfdHJ1ZShbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcclxuXHJcbi8vIGHvvIxi77yMY+eahOWFg+e0oOWdh+aYr+mdnumAkuWHj+aOkuWIl1xyXG4vLyDmsYJh5pWw57uE5Lit6Z2eYuaVsOe7hOWSjGPmlbDnu4TnmoTkuqTpm4bnmoTlhYPntKDjgIJcclxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdF9kZWxldGUoYSwgYiwgYykge1xyXG4gICAgdmFyIGkgPSAwLCBqID0gMCwgayA9IDAsIG0gPSAwO1xyXG5cclxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaiA8IGIubGVuZ3RoICYmIGsgPCBjLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChiW2pdIDwgY1trXSkgaisrO1xyXG4gICAgICAgIGVsc2UgaWYgKGJbal0gPiBjW2tdKSBrKys7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOS6huebuOWQjOWFg+e0oHNhbWVcclxuICAgICAgICAgICAgdmFyIHNhbWUgPSBiW2pdO1xyXG5cclxuICAgICAgICAgICAgLy8gau+8jGvlkI7np7vliLDmlrDnmoTlhYPntKBcclxuICAgICAgICAgICAgd2hpbGUgKGJbal0gPT09IHNhbWUpIGorKztcclxuICAgICAgICAgICAgd2hpbGUgKGNba10gPT09IHNhbWUpIGsrKztcclxuICAgICAgICAgICAgLy8g6ZyA5L+d55WZ55qE5YWD57Sg56e75Yqo5Yiw5paw5L2N572uXHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgYVtpXSA8IHNhbWUpIGFbbSsrXSA9IGFbaSsrXTtcclxuICAgICAgICAgICAgLy8g6Lez6L+H55u45ZCM55qE5YWD57SgXHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgYVtpXSA9PT0gc2FtZSkgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBh55qE5Ymp5L2Z5YWD57Sg6YeN5paw5a2Y5YKoXHJcbiAgICB3aGlsZSAoaSA8IGEubGVuZ3RoKSBhW20rK10gPSBhW2krK107XHJcbiAgICBhLmxlbmd0aCA9IG07XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdF9kZWxldGUoWzEsIDIsIDMsIDQsIDUsIDYsIDldLCBbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9MaW5lYXJMaXN0LmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMS8xOS5cclxuICovXHJcblxyXG4vLyDlvqrnjq/pmJ/liJdcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3ljbGVRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhzaXplID0gMTAwKXtcclxuICAgICAgICB0aGlzLmJhc2UgPSB7fTtcclxuICAgICAgICB0aGlzLmZyb250ID0gdGhpcy5yZWFyID0gMDtcclxuICAgICAgICB0aGlzLk1BWFFTSVpFID0gbWF4c2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBlblF1ZXVlKGRhdGEpIHtcclxuICAgICAgICBpZiAoKHRoaXMucmVhciArIDEpICUgdGhpcy5NQVhRU0laRSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdjeWNsZVF1ZXVlIGlzIGFscmVhZHkgZnVsbCEnKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYXNlW3RoaXMucmVhcl0gPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucmVhciA9ICh0aGlzLnJlYXIgKyAxKSAlIHRoaXMuTUFYUVNJWkU7XHJcbiAgICB9XHJcbiAgICBkZVF1ZXVlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb250ID09PSB0aGlzLnJlYXIpIHRocm93IG5ldyBFcnJvcignY3ljbGVRdWV1ZSBpcyBhbHJlYWR5IGVtcHR5Jyk7XHJcblxyXG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xyXG4gICAgICAgIHRoaXMuZnJvbnQgPSAodGhpcy5mcm9udCArIDEpICUgdGhpcy5NQVhRU0laRTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmJhc2UgPSB7fTtcclxuICAgICAgICB0aGlzLmZyb250ID0gdGhpcy5yZWFyID0gMDtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yZWFyIC0gdGhpcy5mcm9udCArIHRoaXMuTUFYUVNJWkUpICUgdGhpcy5NQVhRU0laRTtcclxuICAgIH1cclxuICAgIHBlZWtBdChpbmRleCA9IDApIHtcclxuICAgICAgICBpbmRleCA9IChpbmRleCArIHRoaXMuTUFYUVNJWkUpICUgdGhpcy5NQVhRU0laRTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVtpbmRleCArIHRoaXMuZnJvbnRdIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRIZWFkKCkge1xyXG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xyXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBxdWV1ZVRyYXZlcnNlKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZnJvbnQsIGxlbiA9IHRoaXMucmVhciA9IHRoaXMuZnJvbnQ7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IodGhpcy5iYXNlW2ldLCBpKSkgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgdmFyIGJhc2UgPSBbXS5zbGljZS5jYWxsKHRoaXMuYmFzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBiYXNlLnNsaWNlKHRoaXMuZnJvbnQsIHRoaXMucmVhciAtIHRoaXMuZnJvbnQpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgcXVldWUgPSBuZXcgQ3ljbGVRdWV1ZSgpO1xyXG5xdWV1ZS5lblF1ZXVlKDEpO1xyXG5xdWV1ZS5kZVF1ZXVlKCk7XHJcbnF1ZXVlLmVuUXVldWUoMik7XHJcbnF1ZXVlLmVuUXVldWUoMyk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgwKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgxKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgyKSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvUXVldWUvQ3ljbGVRdWV1ZS5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8yLzI2LlxyXG4gKi9cclxuXHJcbi8qXHJcbuS8mOWFiOmYn+WIlyhwcmlvcml0eSBxdWV1ZSlcclxuXHJcbuaZrumAmueahOmYn+WIl+aYr+S4gOenjeWFiOi/m+WFiOWHuueahOaVsOaNrue7k+aehO+8jOWFg+e0oOWcqOmYn+WIl+Wwvui/veWKoO+8jOiAjOS7jumYn+WIl+WktOWIoOmZpOOAguWcqOS8mOWFiOmYn+WIl+S4re+8jOWFg+e0oOiiq+i1i+S6iOS8mOWFiOe6p+OAguW9k+iuv+mXruWFg+e0oOaXtu+8jOWFt+acieacgOmrmOS8mOWFiOe6p+eahOWFg+e0oOacgOWFiOWIoOmZpOOAguS8mOWFiOmYn+WIl+WFt+acieacgOmrmOe6p+WFiOWHuiDvvIhsYXJnZXN0LWlu77yMZmlyc3Qtb3V077yJ55qE6KGM5Li654m55b6B44CCXHJcblxyXG7kvJjlhYjpmJ/liJfmmK8w5Liq5oiW5aSa5Liq5YWD57Sg55qE6ZuG5ZCILOavj+S4quWFg+e0oOmDveacieS4gOS4quS8mOWFiOadg+aIluWAvCzlr7nkvJjlhYjpmJ/liJfmiafooYznmoTmk43kvZzmnIkxKSDmn6Xmib47Mikg5o+S5YWl5LiA5Liq5paw5YWD57SgOzMpIOWIoOmZpC7lnKjmnIDlsI/kvJjlhYjpmJ/liJcobWluIHByaW9yaXR5cSB1IGUgdSBlKeS4rSzmn6Xmib7mk43kvZznlKjmnaXmkJzntKLkvJjlhYjmnYPmnIDlsI/nmoTlhYPntKAs5Yig6Zmk5pON5L2c55So5p2l5Yig6Zmk6K+l5YWD57SgO+WvueS6juacgOWkp+S8mOWFiOmYn+WIlyhtYXggcHJpb3JpdHkgcXVldWUpLOafpeaJvuaTjeS9nOeUqOadpeaQnOe0ouS8mOWFiOadg+acgOWkp+eahOWFg+e0oCzliKDpmaTmk43kvZznlKjmnaXliKDpmaTor6XlhYPntKAu5LyY5YWI5p2D6Zif5YiX5Lit55qE5YWD57Sg5Y+v5Lul5pyJ55u45ZCM55qE5LyY5YWI5p2DLOafpeaJvuS4juWIoOmZpOaTjeS9nOWPr+agueaNruS7u+aEj+S8mOWFiOadg+i/m+ihjC5cclxuXHJcblxyXG7lhaXpmJ/mk43kvZxcclxu4pGg77ya5a6M5YWo5LqM5Y+J5qCR55qE5p6E5bu65pON5L2c5piv4oCc5LuO5LiK5Yiw5LiL77yM5LuO5bem5Yiw5Y+z4oCd55qE5b2i5byP77yM5omA5Lul5YWl6Zif55qE6IqC54K55piv5pS+5Zyo5pWw57uE55qE5pyA5ZCO77yM5Lmf5bCx5piv5qCR5Lit5Y+25a2Q5bGC55qE5pyJ5bqP5pyA5Y+z6L6556m65L2N44CCXHJcbuKRoe+8muW9k+iKgueCueaPkuWFpeWIsOacgOWQjuaXtu+8jOacieWPr+iDveegtOWdj+S6huWghueahOaAp+i0qO+8jOatpOaXtuaIkeS7rOimgei/m+ihjOKAnOS4iua7pOaTjeS9nOKAne+8jOW9k+eEtuaXtumXtOWkjeadguW6puS4uk8obGdOKeOAglxyXG5cclxu5Ye66Zif5pON5L2cXHJcbuWHuumYn+aTjeS9nOaXtu+8jOaIkeS7rOmHh+WPlueahOaWueahiOaYr++8muW8ueWHuuWghumhtuWFg+e0oO+8jOeEtuWQjuWwhuWPtuWtkOWxguS4reeahOacgOWPs+WtkOiKgueCuei1i+e7meWghumhtu+8jOWQjOagt+i/meaXtuS5n+S8muWPr+iDveWtmOWcqOegtOWdj+WghueahOaAp+i0qO+8jOacgOWQjuaIkeS7rOimgeiiq+i/q+i/m+ihjOS4i+a7pOaTjeS9nOOAglxyXG4gKi9cclxuXHJcbi8vIOeUqOWghuWunueOsOS8mOWFiOmYn+WIl1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmhlYXAgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2l6ZSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGVuUXVldWUodmFsdWUsIHByaW9yaXR5ID0gMCkge1xyXG4gICAgICAgIGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgcmVxdWlyZWQnKTtcclxuXHJcbiAgICAgICAgLy8g5bCG5b2T5YmN6IqC54K56L+95Yqg5Yiw5aCG5bC+XHJcbiAgICAgICAgdGhpcy5oZWFwLnB1c2goe1xyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8g5aaC5p6c5Y+q5pyJ5LiA5Liq6IqC54K577yM5YiZ5LiN6ZyA6KaB6L+b6KGM562b6YCJ5pON5L2cXHJcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT09IDEpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8g6I635Y+W5pyA5ZCO5LiA5Liq6Z2e5Y+25a2Q6IqC54K577yM5bm26L+b6KGM5aCG6LCD5pW0XHJcbiAgICAgICAgdXBIZWFwQWRqdXN0KHRoaXMuaGVhcCwgKHRoaXMuaGVhcC5sZW5ndGggPj4gMSkgLSAxKTtcclxuICAgIH1cclxuICAgIGRlUXVldWUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYXAubGVuZ3RoKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IGhlYXAgPSB0aGlzLmhlYXA7XHJcbiAgICAgICAgLy8g5Ye66Zif5YiX5pON5L2c77yM5by55Ye65pWw5o2u5aS05YWD57SgXHJcbiAgICAgICAgbGV0IGRhdGEgPSBoZWFwWzBdO1xyXG4gICAgICAgIC8vIOeUqOWwvuWFg+e0oOWhq+WFheWktOWFg+e0oFxyXG4gICAgICAgIGhlYXBbMF0gPSBoZWFwW2hlYXAubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgLy8g5Yig6Zmk5bC+6IqC54K5XHJcbiAgICAgICAgaGVhcC5wb3AoKTtcclxuXHJcbiAgICAgICAgLy/nhLblkI7ku47moLnoioLngrnkuIvmu6TloIZcclxuICAgICAgICBkb3duSGVhcEFkanVzdChoZWFwLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKXtcclxuICAgICAgICB0aGlzLmhlYXAgPSBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLy8g5a+55aCG6L+b6KGM5LiK5ruk5pON5L2c77yM5L2/5b6X5ruh6Laz5aCG5oCn6LSoXHJcbmZ1bmN0aW9uIHVwSGVhcEFkanVzdChoZWFwLCBwYXJlbnQpIHtcclxuICAgIGxldCBsZW4gPSBoZWFwLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAocGFyZW50ID49IDApIHtcclxuICAgICAgICBsZXQgbGVmdENoaWxkID0gMiAqIHBhcmVudCArIDE7XHJcbiAgICAgICAgbGV0IHJpZ2h0Q2hpbGQgPSBsZWZ0Q2hpbGQgKyAxO1xyXG4gICAgICAgIGxldCBtYXggPSBsZWZ0Q2hpbGQ7XHJcblxyXG4gICAgICAgIGlmIChyaWdodENoaWxkIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIG1heCA9IGhlYXBbbGVmdENoaWxkXS5wcmlvcml0eSA8IGhlYXBbcmlnaHRDaGlsZF0ucHJpb3JpdHlcclxuICAgICAgICAgICAgICAgID8gcmlnaHRDaGlsZCA6IGxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWmguaenHBhcmVudOiKgueCueWwj+S6juWug+eahOafkOS4quWtkOiKgueCueeahOivne+8jOatpOaXtuetm+mAieaTjeS9nFxyXG4gICAgICAgIGlmIChoZWFwW3BhcmVudF0ucHJpb3JpdHkgPCBoZWFwW21heF0ucHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgbGV0IHRlbXAgPSBoZWFwW3BhcmVudF07XHJcbiAgICAgICAgICAgIGhlYXBbcGFyZW50XSA9IGhlYXBbbWF4XTtcclxuICAgICAgICAgICAgaGVhcFttYXhdID0gdGVtcDtcclxuXHJcbiAgICAgICAgICAgIC8vIOe7p+e7rei/m+ihjOabtOS4iuS4gOWxgueahOi/h+a7pFxyXG4gICAgICAgICAgICBwYXJlbnQgPSBNYXRoLmNlaWwocGFyZW50IC8gMikgLSAxO1xyXG4gICAgICAgIH0gZWxzZSBicmVhaztcclxuICAgIH1cclxufVxyXG5cclxuLy8g5a+55aCG6L+b6KGM5LiL5ruk5pON5L2c77yM5L2/5b6X5ruh6Laz5aCG5oCn6LSoXHJcbmZ1bmN0aW9uIGRvd25IZWFwQWRqdXN0KGhlYXAsIHBhcmVudCkge1xyXG4gICAgbGV0IGxlbiA9IGhlYXAubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlICgyICogcGFyZW50ICsgMSA8IGxlbikge1xyXG4gICAgICAgIGxldCBsZWZ0Q2hpbGQgPSAyICogcGFyZW50ICsgMTtcclxuICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XHJcbiAgICAgICAgbGV0IG1heCA9IGxlZnRDaGlsZDtcclxuXHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQgPCBsZW4pIHtcclxuICAgICAgICAgICAgbWF4ID0gaGVhcFtsZWZ0Q2hpbGRdLnByaW9yaXR5IDwgaGVhcFtyaWdodENoaWxkXS5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgPyByaWdodENoaWxkIDogbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhlYXBbcGFyZW50XS5wcmlvcml0eSA8IGhlYXBbbWF4XS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICBsZXQgdGVtcCA9IGhlYXBbcGFyZW50XTtcclxuICAgICAgICAgICAgaGVhcFtwYXJlbnRdID0gaGVhcFttYXhdO1xyXG4gICAgICAgICAgICBoZWFwW21heF0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgcGFyZW50ID0gbWF4O1xyXG4gICAgICAgIH0gZWxzZSBicmVhaztcclxuICAgIH1cclxufVxyXG5cclxubGV0IHRlc3QgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG50ZXN0LmVuUXVldWUoOCwgNSk7XHJcbnRlc3QuZW5RdWV1ZSg3LCAyKTtcclxudGVzdC5lblF1ZXVlKDYsIDEpO1xyXG50ZXN0LmVuUXVldWUoNSwgNCk7XHJcbnRlc3QuZW5RdWV1ZSg0LCA3KTtcclxudGVzdC5lblF1ZXVlKDMsIDMpO1xyXG50ZXN0LmVuUXVldWUoMiwgOCk7XHJcbnRlc3QuZW5RdWV1ZSgxLCAxMCk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvUXVldWUvUHJpb3JpdHlRdWV1ZS5qc1xuICoqLyIsIi8qKlxyXG4gKiBBVkwgVFJFRSBDbGFzc1xyXG4gKlxyXG4gKiBAYXV0aG9yIEJyaWNlIENoZXZhbGllclxyXG4gKlxyXG4gKlxyXG4gKiBAZGVzY1xyXG4gKlxyXG4gKiAgICBNZXRob2QgICAgICAgICAgICAgICAgVGltZSBDb21wbGV4aXR5XHJcbiAqICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXHJcbiAqXHJcbiAqICAgIGFkZCAgICAgICAgICAgICAgICAgICAgTyhsb2cyKG4pKVxyXG4gKiAgICByZW1vdmUgICAgICAgICAgICAgICAgTyhsb2cyKG4pKVxyXG4gKiAgICBnZXRGaXJzdCAgICAgICAgICAgIE8oMSlcclxuICogICAgZ2V0TGFzdCAgICAgICAgICAgICAgICBPKDEpXHJcbiAqICAgIGdldENvdW50ICAgICAgICAgICAgTygxKVxyXG4gKiAgICBhcHBseSAgICAgICAgICAgICAgICBPKG4pXHJcbiAqICAgIGNsZWFyICAgICAgICAgICAgICAgIE8obilcclxuICpcclxuICogICAgTWVtb3J5IENvbXBsZXhpdHkgaW4gTyhuKVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIE5vZGUob2JqKSB7XHJcbiAgICB0aGlzLm9iamVjdCA9IG9iajtcclxuICAgIHRoaXMuaGVpZ2h0ID0gMTtcclxuICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xyXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gQXZsVHJlZSgpIHtcclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcclxufVxyXG5BdmxUcmVlLmNtcCA9IGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgaWYoYSA+IGIpIHJldHVybiAxO1xyXG4gICAgZWxzZSBpZihhIDwgYikgcmV0dXJuIC0xO1xyXG4gICAgZWxzZSByZXR1cm4gMDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9hZGRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgbm9kZS5wcmV2aW91cyA9IHBhcmVudC5wcmV2aW91cztcclxuICAgIG5vZGUubmV4dCA9IHBhcmVudDtcclxuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgIHBhcmVudC5sZWZ0ID0gbm9kZTtcclxuICAgIHBhcmVudC5wcmV2aW91cyA9IG5vZGU7XHJcblxyXG4gICAgaWYgKG5vZGUucHJldmlvdXMpIHtcclxuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJlbnQgPT09IHRoaXMuZmlyc3QpIHtcclxuICAgICAgICB0aGlzLmZpcnN0ID0gbm9kZTtcclxuICAgIH1cclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9hZGRSaWdodCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQ7XHJcbiAgICBub2RlLm5leHQgPSBwYXJlbnQubmV4dDtcclxuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgIHBhcmVudC5yaWdodCA9IG5vZGU7XHJcbiAgICBwYXJlbnQubmV4dCA9IG5vZGU7XHJcblxyXG4gICAgaWYgKG5vZGUubmV4dCkge1xyXG4gICAgICAgIG5vZGUubmV4dC5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhcmVudCA9PT0gdGhpcy5sYXN0KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZTtcclxuICAgIH1cclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHRoaXMuY291bnQgKz0gMTtcclxuICAgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUob2JqKTtcclxuXHJcbiAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbmV3Tm9kZTtcclxuICAgICAgICB0aGlzLmZpcnN0ID0gdGhpcy5yb290O1xyXG4gICAgICAgIHRoaXMubGFzdCA9IHRoaXMucm9vdDtcclxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3VycmVudCA9IHRoaXMucm9vdDtcclxuXHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG5cclxuICAgICAgICB2YXIgY21wID0gQXZsVHJlZS5jbXAob2JqLCBjdXJyZW50Lm9iamVjdCk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgLy8gQWRkaW5nIHRvIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZExlZnQobmV3Tm9kZSwgY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQWRkaW5nIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmlnaHQobmV3Tm9kZSwgY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVmdChuZXdOb2RlLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJpZ2h0KG5ld05vZGUsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodC5oZWlnaHQgPCBjdXJyZW50LmxlZnQuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYmFsYW5jZShuZXdOb2RlLnBhcmVudCk7XHJcblxyXG4gICAgcmV0dXJuIG5ld05vZGU7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5fYmFsYW5jZUxlZnRSaWdodCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcclxuICAgIHZhciBhID0gbGVmdC5sZWZ0O1xyXG4gICAgdmFyIGIgPSBsZWZ0LnJpZ2h0LmxlZnQ7XHJcblxyXG4gICAgbGVmdC5yaWdodC5sZWZ0ID0gbGVmdDtcclxuICAgIG5vZGUubGVmdCA9IGxlZnQucmlnaHQ7XHJcbiAgICBsZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgbGVmdC5wYXJlbnQgPSBub2RlO1xyXG5cclxuICAgIHZhciBsZWZ0TGVmdCA9IGxlZnQubGVmdDtcclxuICAgIGxlZnRMZWZ0LnBhcmVudCA9IGxlZnQ7XHJcbiAgICBsZWZ0TGVmdC5sZWZ0ID0gYTtcclxuICAgIGxlZnRMZWZ0LnJpZ2h0ID0gYjtcclxuICAgIGlmIChhICE9PSBudWxsKSB7XHJcbiAgICAgICAgYS5wYXJlbnQgPSBsZWZ0TGVmdDtcclxuICAgIH1cclxuICAgIGlmIChiICE9PSBudWxsKSB7XHJcbiAgICAgICAgYi5wYXJlbnQgPSBsZWZ0TGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBsZWZ0LmhlaWdodCA9IGxlZnRMZWZ0LmhlaWdodCArIDE7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5fYmFsYW5jZUxlZnRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgdmFyIGMgPSBsZWZ0LnJpZ2h0O1xyXG5cclxuICAgIGlmIChub2RlID09PSB0aGlzLnJvb3QpIHtcclxuICAgICAgICB0aGlzLnJvb3QgPSBsZWZ0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSBsZWZ0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZWZ0LnJpZ2h0ID0gbm9kZTtcclxuICAgIGxlZnQucGFyZW50ID0gbm9kZS5wYXJlbnQ7XHJcbiAgICBub2RlLnBhcmVudCA9IGxlZnQ7XHJcbiAgICBub2RlLmxlZnQgPSBjO1xyXG4gICAgaWYoYyAhPT0gbnVsbCkge1xyXG4gICAgICAgIGMucGFyZW50ID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBub2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0IC0gMTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlUmlnaHRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICB2YXIgYSA9IHJpZ2h0LnJpZ2h0O1xyXG4gICAgdmFyIGIgPSByaWdodC5sZWZ0LnJpZ2h0O1xyXG5cclxuICAgIHJpZ2h0LmxlZnQucmlnaHQgPSByaWdodDtcclxuICAgIG5vZGUucmlnaHQgPSByaWdodC5sZWZ0O1xyXG4gICAgcmlnaHQgPSBub2RlLnJpZ2h0O1xyXG4gICAgcmlnaHQucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICB2YXIgcmlnaHRSaWdodCA9IHJpZ2h0LnJpZ2h0O1xyXG4gICAgcmlnaHRSaWdodC5wYXJlbnQgPSByaWdodDtcclxuICAgIHJpZ2h0UmlnaHQucmlnaHQgPSBhO1xyXG4gICAgcmlnaHRSaWdodC5sZWZ0ID0gYjtcclxuICAgIGlmIChhICE9PSBudWxsKSB7XHJcbiAgICAgICAgYS5wYXJlbnQgPSByaWdodFJpZ2h0O1xyXG4gICAgfVxyXG4gICAgaWYgKGIgIT09IG51bGwpIHtcclxuICAgICAgICBiLnBhcmVudCA9IHJpZ2h0UmlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZS5yaWdodC5oZWlnaHQgPSByaWdodFJpZ2h0LmhlaWdodCArIDE7XHJcbn07XHJcblxyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICB2YXIgYyA9IHJpZ2h0LmxlZnQ7XHJcblxyXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJpZ2h0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQubGVmdCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5sZWZ0ID0gcmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSByaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmlnaHQubGVmdCA9IG5vZGU7XHJcbiAgICByaWdodC5wYXJlbnQgPSBub2RlLnBhcmVudDtcclxuICAgIG5vZGUucGFyZW50ID0gcmlnaHQ7XHJcbiAgICBub2RlLnJpZ2h0ID0gYztcclxuICAgIGlmKGMgIT09IG51bGwpIHtcclxuICAgICAgICBjLnBhcmVudCA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodCAtIDE7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5fYmFsYW5jZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAvLyBCYWxhbmNpbmcgdGhlIHRyZWVcclxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcclxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGxlZnRIZWlnaHQgPSAoY3VycmVudC5sZWZ0ID09PSBudWxsKSA/IDAgOiBjdXJyZW50LmxlZnQuaGVpZ2h0O1xyXG4gICAgICAgIHZhciByaWdodEhlaWdodCA9IChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSA/IDAgOiBjdXJyZW50LnJpZ2h0LmhlaWdodDtcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gMSArIE1hdGgubWF4KGxlZnRIZWlnaHQsIHJpZ2h0SGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKG5ld0hlaWdodCA+IGN1cnJlbnQuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAobGVmdEhlaWdodCAtIHJpZ2h0SGVpZ2h0ID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVmdC5yaWdodCAhPT0gbnVsbCAmJiAoY3VycmVudC5sZWZ0LmxlZnQgPT09IG51bGwgfHwgY3VycmVudC5sZWZ0LmxlZnQuaGVpZ2h0IDwgY3VycmVudC5sZWZ0LnJpZ2h0LmhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IFJpZ2h0IENhc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlTGVmdFJpZ2h0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlZnQgTGVmdCBDYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlTGVmdExlZnQoY3VycmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRyZWUgaGFzIGJlZW4gYmFsYW5jZWRcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0SGVpZ2h0IC0gbGVmdEhlaWdodCA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodC5sZWZ0ICE9PSBudWxsICYmIChjdXJyZW50LnJpZ2h0LnJpZ2h0ID09PSBudWxsIHx8IGN1cnJlbnQucmlnaHQucmlnaHQuaGVpZ2h0IDwgY3VycmVudC5yaWdodC5sZWZ0LmhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCBMZWZ0IENhc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlUmlnaHRMZWZ0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IFJpZ2h0IENhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodFJpZ2h0KGN1cnJlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSB0cmVlIGhhcyBiZWVuIGJhbGFuY2VkXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgaXMgYmFsYW5jZWRcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHRoaXMuX3JlbW92ZShvYmosIHRoaXMucm9vdCk7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKG9iaiwgbm9kZSkge1xyXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xyXG5cclxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGNtcCA9IEF2bFRyZWUuY21wKG9iaiwgY3VycmVudC5vYmplY3QpO1xyXG4gICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvYmogPT09IGN1cnJlbnQub2JqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50IC09IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucHJldmlvdXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5uZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gY3VycmVudC5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uZXh0LnByZXZpb3VzID0gY3VycmVudC5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNpbmcgdGhlIG5vZGUgYnkgdGhlIHNtYWxsZXN0IGVsZW1lbnQgZ3JlYXRlciB0aGFuIGl0XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGN1cnJlbnQucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBiYWxhbmNlRnJvbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LmxlZnQgPSBsZWZ0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5yaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBiYWxhbmNlRnJvbSA9IHJlcGxhY2VtZW50LnBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW92ZShvYmosIGN1cnJlbnQubGVmdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUob2JqLCBjdXJyZW50LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLnJlbW92ZUJ5UmVmID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIC8vIE5vZGUgcmVtb3ZhbFxyXG4gICAgdGhpcy5jb3VudCAtPSAxO1xyXG5cclxuICAgIGlmIChub2RlLnByZXZpb3VzID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5maXJzdCA9IG5vZGUubmV4dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5wcmV2aW91cy5uZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUubmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMubGFzdCA9IG5vZGUucHJldmlvdXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGUubmV4dC5wcmV2aW91cyA9IG5vZGUucHJldmlvdXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwbGFjaW5nIHRoZSBub2RlIGJ5IHRoZSBzbWFsbGVzdCBlbGVtZW50IGdyZWF0ZXIgdGhhbiBpdFxyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xyXG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xyXG5cclxuICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBsZWZ0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fYmFsYW5jZShwYXJlbnQpO1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXBsYWNlbWVudCA9IG5vZGUucmlnaHQ7XHJcbiAgICB2YXIgYmFsYW5jZUZyb207XHJcblxyXG4gICAgaWYgKHJlcGxhY2VtZW50LmxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICBiYWxhbmNlRnJvbSA9IHJlcGxhY2VtZW50O1xyXG5cclxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZWZ0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSByZXBsYWNlbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5sZWZ0O1xyXG4gICAgd2hpbGUgKHJlcGxhY2VtZW50LmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudC5yaWdodDtcclxuXHJcbiAgICBpZiAocmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICByaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudDtcclxuICAgIH1cclxuICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gcmlnaHQ7XHJcblxyXG4gICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudC5wYXJlbnQ7XHJcblxyXG4gICAgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICBsZWZ0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XHJcblxyXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xyXG5cclxuICAgIHJldHVybiAxO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0Rmlyc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maXJzdDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmdldExhc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sYXN0O1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY291bnQ7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKHByb2Nlc3NpbmdGdW5jLCBwYXJhbXMpIHtcclxuICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmZpcnN0OyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XHJcbiAgICAgICAgcHJvY2Vzc2luZ0Z1bmMoY3VycmVudC5vYmplY3QsIHBhcmFtcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChwcm9jZXNzaW5nRnVuYywgcGFyYW1zKSB7XHJcbiAgICBmb3IgKHZhciBjdXJyZW50ID0gdGhpcy5sYXN0OyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5wcmV2aW91cykge1xyXG4gICAgICAgIHByb2Nlc3NpbmdGdW5jKGN1cnJlbnQub2JqZWN0LCBwYXJhbXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICB0aGlzLmZpcnN0ID0gbnVsbDtcclxuICAgIHRoaXMubGFzdCA9IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF2bFRyZWU7XHJcblxyXG5cclxuY29uc29sZS5sb2coJ1xcbkFWTCB0cmVlIGluc2VydDI6ICcpO1xyXG52YXIgdGVzdCA9IG5ldyBBdmxUcmVlKCk7XHJcbnRlc3QuYWRkKDMpO1xyXG50ZXN0LmFkZCgxNCk7XHJcbnRlc3QuYWRkKDI1KTtcclxudGVzdC5hZGQoODEpO1xyXG50ZXN0LmFkZCg0NCk7XHJcblxyXG4vKlxyXG4gMTRcclxuIC8gICAgXFxcclxuIDMgICAgICAgNDRcclxuIC8gICBcXFxyXG4gMjUgICAgIDgxXHJcbiAqL1xyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdyZW1vdmVfUmVjdXJzaXZlIDI6Jyk7XHJcblxyXG50ZXN0LnJlbW92ZSg4MSk7XHJcbnRlc3QucmVtb3ZlKDMpO1xyXG50ZXN0LnJlbW92ZSgxNCk7XHJcbnRlc3QucmVtb3ZlKDI1KTtcclxudGVzdC5yZW1vdmUoNDQpO1xyXG5cclxuXHJcbmxldCBzdHIgPSAnY2tub2JmanRscHFhZWdybWRocyc7XHJcbi8vdmFyIHN0ciA9ICdja2JmamxhZWdtZGgnO1xyXG5cclxuXHJcbnRlc3QgPSBuZXcgQXZsVHJlZSgpO1xyXG5mb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKXtcclxuICAgIHRlc3QuYWRkKHN0cltpXSk7XHJcbn1cclxuXHJcblxyXG50ZXN0LnJlbW92ZSgnZScpO1xyXG50ZXN0LnJlbW92ZSgnaCcpO1xyXG50ZXN0LnJlbW92ZSgnYicpO1xyXG50ZXN0LnJlbW92ZSgnbCcpO1xyXG50ZXN0LnJlbW92ZSgnZicpO1xyXG50ZXN0LnJlbW92ZSgnaicpO1xyXG50ZXN0LnJlbW92ZSgnZycpO1xyXG50ZXN0LnJlbW92ZSgnZCcpO1xyXG50ZXN0LnJlbW92ZSgnaycpO1xyXG50ZXN0LnJlbW92ZSgnYScpO1xyXG50ZXN0LnJlbW92ZSgnbScpO1xyXG50ZXN0LnJlbW92ZSgnbicpO1xyXG50ZXN0LnJlbW92ZSgnbycpO1xyXG50ZXN0LnJlbW92ZSgncCcpO1xyXG50ZXN0LnJlbW92ZSgncScpO1xyXG50ZXN0LnJlbW92ZSgncicpO1xyXG50ZXN0LnJlbW92ZSgncycpO1xyXG50ZXN0LnJlbW92ZSgndCcpO1xyXG50ZXN0LnJlbW92ZSgnYycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9BVkxUcmVlLmpzXG4gKiovIiwiLypcclxuIE1JVCBMaWNlbnNlXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTIgU2FudGFudSBCYXN1XHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMgRGFuaWVsIFdpcnR6XHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcclxuIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLy8gQmFzZWQgb24gU2FudGFudSBCYXN1J3MgQlBsdXNKU1xyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2FudGFudWJhc3UvQlBsdXNKU1xyXG4vLyBNb2RpZmllZCBmb3Igc3RhbmQtYWxvbmUgdXNlXHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgQlRyZWUuanNcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vQlRyZWUuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0RlZmluZWQodikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdiAhPSAndW5kZWZpbmVkJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgTm9kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdGhpcy5vcmRlciA9IG9wdGlvbnMub3JkZXIgfHwgMTAwO1xyXG4gICAgICAgIHRoaXMubWVyZ2VUaHJlc2hvbGQgPSBvcHRpb25zLm1lcmdlVGhyZXNob2xkIHx8IDQwO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRMZWZ0UGVlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuc2V0TGVmdFBlZXIgPSBmdW5jdGlvbiAobGVmdFBlZXIpIHtcclxuICAgICAgICB0aGlzLmxlZnRQZWVyID0gbGVmdFBlZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldFJpZ2h0UGVlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodFBlZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLnNldFJpZ2h0UGVlciA9IGZ1bmN0aW9uIChyaWdodFBlZXIpIHtcclxuICAgICAgICB0aGlzLnJpZ2h0UGVlciA9IHJpZ2h0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRTdXJwbHVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKCh0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5tZXJnZVRocmVzaG9sZCkgLyAyKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldFJpZ2h0U3VycGx1c0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN1cnBsdXMgPSB0aGlzLmdldFN1cnBsdXMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNwbGljZSh0aGlzLmRhdGEubGVuZ3RoIC0gc3VycGx1cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldExlZnRTdXJwbHVzRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VycGx1cyA9IHRoaXMuZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3BsaWNlKDAsIHN1cnBsdXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgSW50ZXJuYWxOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBvcHRpb25zLmxlZnRQZWVyO1xyXG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gb3B0aW9ucy5yaWdodFBlZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB2YXIgbGVmdCA9IDA7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xyXG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbWlkID0gbGVmdCArIE1hdGguZmxvb3IoKHJpZ2h0IC0gbGVmdCkgLyAyKTtcclxuICAgICAgICAgICAgaWYgKGRhdGFbbWlkXS5rZXkgPCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFbbWlkXS5rZXkgPiBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAobGVmdCA8IHJpZ2h0ICYmICFmb3VuZCk7XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kQ2hpbGQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICAgICAgdmFyIGNoaWxkO1xyXG4gICAgICAgIGlmIChlbGVtZW50LmtleSA8PSBrZXkpIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LnJpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9O1xyXG5cclxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgdmFyIG5ld05vZGVzLCBsZWZ0RWxlbWVudCwgcmlnaHRFbGVtZW50O1xyXG4gICAgICAgIGlmIChlbGVtZW50LmtleSA8PSBrZXkpIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICBuZXdOb2RlcyA9IGNoaWxkLmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcclxuICAgICAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1swXSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMl1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAxLCBsZWZ0RWxlbWVudCwgcmlnaHRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcclxuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XHJcbiAgICAgICAgICAgIGlmIChuZXdOb2Rlcy5sZW5ndGggPT0gMykge1xyXG4gICAgICAgICAgICAgICAgbGVmdEVsZW1lbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1swXSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMl1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1syXSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWxlbWVudC5yaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3Tm9kZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPCB0aGlzLm9yZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBNYXRoLmZsb29yKHRoaXMuZGF0YS5sZW5ndGggLyAyKTtcclxuICAgICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcclxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKDAsIHNwbGl0SW5kZXgpLFxyXG4gICAgICAgICAgICBsZWZ0UGVlcjogdGhpcy5sZWZ0UGVlcixcclxuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2Uoc3BsaXRJbmRleCArIDEsIHRoaXMuZGF0YS5sZW5ndGgpLFxyXG4gICAgICAgICAgICByaWdodFBlZXI6IHRoaXMucmlnaHRQZWVyLFxyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZWZ0Tm9kZS5zZXRSaWdodFBlZXIocmlnaHROb2RlKTtcclxuICAgICAgICByaWdodE5vZGUuc2V0TGVmdFBlZXIobGVmdE5vZGUpO1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5sZWZ0UGVlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0UGVlci5zZXRSaWdodFBlZXIobGVmdE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMucmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGVlci5zZXRMZWZ0UGVlcihyaWdodE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2xlZnROb2RlLCB0aGlzLmRhdGFbc3BsaXRJbmRleF0ua2V5LCByaWdodE5vZGVdO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICB2YXIgbWVyZ2VJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgIGlmIChlbGVtZW50LmtleSA8PSBrZXkpIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICByZXR2YWwgPSBjaGlsZC5yZW1vdmUoa2V5LCBlbGVtZW50LmxlZnQsIGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAtIDEgPyBjaGlsZC5nZXRSaWdodFBlZXIoKSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID09IDEgJiYgcmV0dmFsLmxlbmd0aCA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXSwgcmV0dmFsWzNdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR2YWxbMV0gPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZUluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcclxuICAgICAgICAgICAgcmV0dmFsID0gY2hpbGQucmVtb3ZlKGtleSwgaW5kZXggPiAwID8gY2hpbGQuZ2V0TGVmdFBlZXIoKSA6IHVuZGVmaW5lZCwgZWxlbWVudC5yaWdodCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID09IDEgJiYgcmV0dmFsLmxlbmd0aCA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXSwgcmV0dmFsWzNdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR2YWxbMV0gPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmdlSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgbWVyZ2VFbGVtZW50ID0gdGhpcy5kYXRhW21lcmdlSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA9PSA1KSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZUVsZW1lbnQua2V5ID0gcmV0dmFsWzNdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW21lcmdlSW5kZXggLSAxXS5yaWdodCA9IHJldHZhbFszXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtZXJnZUluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbWVyZ2VJbmRleCArIDFdLmxlZnQgPSByZXR2YWxbM107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKG1lcmdlSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA+IHRoaXMubWVyZ2VUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pICYmICFpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmV0dmFsID0gW107XHJcbiAgICAgICAgLy8gdmFyIGRlZmljaXQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBsZWZ0U3VycGx1cyA9IDA7XHJcbiAgICAgICAgdmFyIGxlZnREYXRhO1xyXG4gICAgICAgIHZhciByaWdodFN1cnBsdXMgPSAwO1xyXG4gICAgICAgIHZhciByaWdodERhdGE7XHJcbiAgICAgICAgdmFyIGxlZnRQZWVyID0gdGhpcy5sZWZ0UGVlcjtcclxuICAgICAgICB2YXIgcmlnaHRQZWVyID0gdGhpcy5yaWdodFBlZXI7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pKSB7XHJcbiAgICAgICAgICAgIGxlZnREYXRhID0gbGVmdE1lcmdlT3B0aW9uLmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGVmdFN1cnBsdXMgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0TWVyZ2VPcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICByaWdodFN1cnBsdXMgPSByaWdodE1lcmdlT3B0aW9uLmdldFN1cnBsdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRTdXJwbHVzID4gcmlnaHRTdXJwbHVzKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0U3VycGx1c0RhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0UmlnaHRTdXJwbHVzRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBsZWZ0U3VycGx1c0RhdGEuc2xpY2UoMSkuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdFN1cnBsdXNEYXRhW2xlZnRTdXJwbHVzRGF0YS5sZW5ndGggLSAxXS5yaWdodCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSwgdGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgIHJldHZhbFsxXSA9IGxlZnRNZXJnZU9wdGlvbjtcclxuICAgICAgICAgICAgcmV0dmFsWzJdID0gbGVmdFN1cnBsdXNEYXRhWzBdLmtleTtcclxuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcclxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0U3VycGx1cyA+IGxlZnRTdXJwbHVzKSB7XHJcbiAgICAgICAgICAgIHZhciByaWdodFN1cnBsdXNEYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXRMZWZ0U3VycGx1c0RhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiByaWdodFN1cnBsdXNEYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFN1cnBsdXNEYXRhWzBdLmxlZnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSwgcmlnaHRTdXJwbHVzRGF0YS5zbGljZSgwLCByaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcclxuICAgICAgICAgICAgcmV0dmFsWzFdID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRTdXJwbHVzRGF0YVtyaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLmtleTtcclxuICAgICAgICAgICAgcmV0dmFsWzNdID0gcmlnaHRNZXJnZU9wdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbWVyZ2VkSW50ZXJuYWxOb2RlO1xyXG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChsZWZ0RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0RGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RGF0YVswXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLCByaWdodERhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHJpZ2h0RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnREYXRhW2xlZnREYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuZGF0YVswXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLmRhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRJbnRlcm5hbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodERhdGEubGVuZ3RoIDwgbGVmdERhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiByaWdodERhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXS5yaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodERhdGFbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXSwgcmlnaHREYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRJbnRlcm5hbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikgJiYgaXNEZWZpbmVkKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLnNldFJpZ2h0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0RGF0YVtsZWZ0RGF0YS5sZW5ndGggLSAxXS5yaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmRhdGFbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5kYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuZ2V0TGVmdFBlZXIoKS5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRDaGlsZChrZXkpLmZpbmQoa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENoaWxkKHN0YXJ0KS5yYW5nZShzdGFydCwgZW5kKTtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW2luZGVudCArIFwiW2tleT1cIiArIGVsZW1lbnQua2V5LCBcIlxcblwiICsgaW5kZW50ICsgXCIgICAgTEVGVFxcblwiICsgZWxlbWVudC5sZWZ0LnRvU3RyaW5nKGluZGVudCArIFwiICAgIFwiKSwgXCJcXG5cIiArIGluZGVudCArIFwiICAgIFJJR0hUXFxuXCIgKyBlbGVtZW50LnJpZ2h0LnRvU3RyaW5nKGluZGVudCArIFwiICAgIFwiKSArIFwiXFxuXCIgKyBpbmRlbnQgKyBcIl1cIl07XHJcbiAgICAgICAgfSkuam9pbihcIixcXG5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBMZWFmTm9kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgTm9kZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcclxuICAgICAgICB0aGlzLmxlZnRQZWVyID0gb3B0aW9ucy5sZWZ0UGVlcjtcclxuICAgICAgICB0aGlzLnJpZ2h0UGVlciA9IG9wdGlvbnMucmlnaHRQZWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdCA9IDA7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVttaWRdLmtleSA8IGtleSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdLmtleSA+IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChsZWZ0ICE9PSByaWdodCAmJiAhZm91bmQpO1xyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWlkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmtleSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjbG9iYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1lbnQudmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY29uZGl0aW9uIG1heSBuZXZlciBvY2N1ciwgZ2l2ZW4gdGhlIHdheSBmaW5kSW5kZXggaXMgd3JpdHRlblxyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5rZXkgPCBrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCArIDEsIDAsIHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPCB0aGlzLm9yZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBNYXRoLmZsb29yKHRoaXMuZGF0YS5sZW5ndGggLyAyKTtcclxuICAgICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2UoMCwgc3BsaXRJbmRleCksXHJcbiAgICAgICAgICAgIGxlZnRQZWVyOiB0aGlzLmxlZnRQZWVyLFxyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IExlYWZOb2RlKHtcclxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpLFxyXG4gICAgICAgICAgICByaWdodFBlZXI6IHRoaXMucmlnaHRQZWVyLFxyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZWZ0Tm9kZS5zZXRSaWdodFBlZXIocmlnaHROb2RlKTtcclxuICAgICAgICByaWdodE5vZGUuc2V0TGVmdFBlZXIobGVmdE5vZGUpO1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5sZWZ0UGVlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0UGVlci5zZXRSaWdodFBlZXIobGVmdE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMucmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGVlci5zZXRMZWZ0UGVlcihyaWdodE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2xlZnROb2RlLCB0aGlzLmRhdGFbc3BsaXRJbmRleF0ua2V5LCByaWdodE5vZGVdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgbGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAmJiBlbGVtZW50LmtleSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnQudmFsdWVdLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA+IHRoaXMubWVyZ2VUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pICYmICFpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmV0dmFsID0gW107XHJcbiAgICAgICAgLy8gdmFyIGRlZmljaXQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBsZWZ0U3VycGx1cyA9IDA7XHJcbiAgICAgICAgdmFyIGxlZnREYXRhO1xyXG4gICAgICAgIHZhciByaWdodFN1cnBsdXMgPSAwO1xyXG4gICAgICAgIHZhciByaWdodERhdGE7XHJcbiAgICAgICAgdmFyIGxlZnRQZWVyID0gdGhpcy5sZWZ0UGVlcjtcclxuICAgICAgICB2YXIgcmlnaHRQZWVyID0gdGhpcy5yaWdodFBlZXI7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pKSB7XHJcbiAgICAgICAgICAgIGxlZnREYXRhID0gbGVmdE1lcmdlT3B0aW9uLmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGVmdFN1cnBsdXMgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0TWVyZ2VPcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICByaWdodFN1cnBsdXMgPSByaWdodE1lcmdlT3B0aW9uLmdldFN1cnBsdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRTdXJwbHVzID4gcmlnaHRTdXJwbHVzKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0U3VycGx1c0RhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0UmlnaHRTdXJwbHVzRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBsZWZ0U3VycGx1c0RhdGEuY29uY2F0KHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xyXG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XHJcbiAgICAgICAgICAgIHJldHZhbFsyXSA9IHRoaXMuZGF0YVswXS5rZXk7XHJcbiAgICAgICAgICAgIHJldHZhbFszXSA9IHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRTdXJwbHVzRGF0YSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0TGVmdFN1cnBsdXNEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5jb25jYXQocmlnaHRTdXJwbHVzRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XHJcbiAgICAgICAgICAgIHJldHZhbFsxXSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHZhbFsyXSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgcmV0dmFsWzNdID0gcmlnaHRNZXJnZU9wdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbWVyZ2VkTGVhZk5vZGU7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnREYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQocmlnaHREYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRGVmaW5lZChyaWdodERhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGVmdERhdGEuY29uY2F0KHRoaXMuZGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KHJpZ2h0RGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRMZWFmTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLnNldFJpZ2h0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdCh0aGlzLmRhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuZ2V0TGVmdFBlZXIoKS5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLnNldExlZnRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoICYmIGVsZW1lbnQua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcztcclxuICAgICAgICB2YXIgcmFuZ2UgPSBbXTtcclxuICAgICAgICB3aGlsZSAoaXNEZWZpbmVkKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gbm9kZS5maW5kSW5kZXgoc3RhcnQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBub2RlLmZpbmRJbmRleChlbmQpO1xyXG4gICAgICAgICAgICB2YXIgbm9kZURhdGEgPSBub2RlLmdldERhdGEoKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBub2RlRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2gobm9kZURhdGFbaV0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PSBub2RlRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldFJpZ2h0UGVlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5kZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGVudCArIFwiW1wiICsgdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQua2V5O1xyXG4gICAgICAgICAgICB9KS50b1N0cmluZygpICsgXCJdXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBUcmVlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAxMDA7XHJcbiAgICAgICAgdGhpcy5tZXJnZVRocmVzaG9sZCA9IG9wdGlvbnMubWVyZ2VUaHJlc2hvbGQgfHwgNDA7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IExlYWZOb2RlKHtcclxuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICBkYXRhOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LnRvU3RyaW5nKFwiXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY2xvYmJlcikge1xyXG4gICAgICAgIHZhciBuZXdOb2RlcyA9IHRoaXMucm9vdC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XHJcbiAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbmV3Tm9kZXNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMl1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdOb2Rlcy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciByZXR2YWwgPSB0aGlzLnJvb3QucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSByZXR2YWxbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR2YWxbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5maW5kKGtleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LnJhbmdlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHBvc2UgYWxsIHR5cGVzIG9uIHRvcFxyXG4gICAgVHJlZS5Ob2RlID0gTm9kZTtcclxuICAgIFRyZWUuSW50ZXJuYWxOb2RlID0gSW50ZXJuYWxOb2RlO1xyXG4gICAgVHJlZS5MZWFmTm9kZSA9IExlYWZOb2RlO1xyXG5cclxuICAgIC8vIEVuYWJsZSBtb2R1bGUgbG9hZGluZyBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pIHsgLy8gQ29tbW9uSlNcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gVHJlZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmVbXCJhbWRcIl0pIHsgLy8gQU1EXHJcbiAgICAgICAgZGVmaW5lKFwiQlBsdXNUcmVlXCIsIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyZWU7IH0pO1xyXG4gICAgfSBlbHNlIHsgLy8gU2hpbVxyXG4gICAgICAgIGlmICghZ2xvYmFsW1wiZGNvZGVJT1wiXSkge1xyXG4gICAgICAgICAgICBnbG9iYWxbXCJkY29kZUlPXCJdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl1bXCJCUGx1c1RyZWVcIl0gPSBUcmVlO1xyXG4gICAgfVxyXG5cclxufSkodGhpcyk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanNcbiAqKi8iLCIvKlxyXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgYnRyZWUuanMgKGMpIDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2Rjb2RlSU8vYnRyZWUuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbiAobW9kdWxlLCBjb25zb2xlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25jYXRlbmF0ZXMgbXVsdGlwbGUgYXJyYXlzIGludG8gYSBuZXcgb25lLlxyXG4gICAgICogQHBhcmFtIHsuLi5bQXJyYXldfSB2YXJfYXJnc1xyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29uY2F0KHZhcl9hcmdzKSB7XHJcbiAgICAgICAgLy8gQXJyYXkjY29uY2F0IGJlaGF2ZXMgc3RyYW5nZWx5IGZvciBlbXB0eSBhcnJheXMsIHNvLi4uXHJcbiAgICAgICAgdmFyIGEgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhLCBhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaGVzIGFuIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYVxyXG4gICAgICogQHBhcmFtIHsqfSB2XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBJbmRleCBvciAtMSBpZiBub3QgZm91bmRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFzZWFyY2goYSwgdikge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gQXJyYXkjaW5kZXhPZiBiZWNhdXNlIGl0J3MgcmF3LiBIb3dldmVyLCB3ZVxyXG4gICAgICAgIC8vIGNhbm5vdCB1c2UgYmluYXJ5IHNlYXJjaCBiZWNhdXNlIG5vZGVzIGRvIG5vdCBoYXZlIGEgY29tcGFyYWJsZVxyXG4gICAgICAgIC8vIGtleS4gSWYgdGhlIGNvbXBpbGVyIGlzIHNtYXJ0LCBpdCB3aWxsIGlubGluZSB0aGlzLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gdikgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtaTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGJ0cmVlIG5hbWVzcGFjZS5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqL1xyXG4gICAgdmFyIGJ0cmVlID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpY3RseSBjb21wYXJlcyB0d28gc3RyaW5ncywgY2hhcmFjdGVyIGJ5IGNoYXJhY3Rlci4gTm8gbG9jYWxlcywgbm8gbnVtYmVyIGV4dGVuc2lvbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgYSA8IGIsIDEgaWYgYSA+IGIsIDAgb3RoZXJ3aXNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIGJ0cmVlLnN0cmNtcCA9IGZ1bmN0aW9uIHN0cmNtcChhLCBiKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdmFyIGFjO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHZhciBiYztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPj0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoYWMgPSBhLmNoYXJDb2RlQXQoaSkpIDwgKGJjID0gYi5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFjID4gYmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHNhbWUsIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCA/IDAgOiAtMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0d28gbnVtYmVycy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgYSA8IGIsIDEgaWYgYSA+IGIsIDAgb3RoZXJ3aXNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIGJ0cmVlLm51bWNtcCA9IGZ1bmN0aW9uIGludGNtcChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAoYSA+IGIgPyAxIDogMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEJUcmVlIGNsYXNzIHVzaW5nIHRoZSBnaXZlbiBvcmRlci5cclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgY2xhc3MsIG5vdCBhbiBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb3JkZXIgRGVmYXVsdHMgdG8gMlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/LCA/KTpudW1iZXI9fSBjb21wYXJlIENvbXBhcmUgaW1wbGVtZW50YXRpb24gdG8gdXNlIG9uIGtleXNcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgYnRyZWUuY3JlYXRlID0gZnVuY3Rpb24gKG9yZGVyLCBjb21wYXJlKSB7XHJcblxyXG4gICAgICAgIC8vIFZhbGlkYXRlIG9yZGVyXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBvcmRlciA9IDUyOyAvLyBCZW5jaG1hcmtzIHByb29mZWQgdGhhdCB0aGlzIGlzIGNsb3NlIHRvIHRoZSBvcHRpbXVtXHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb3JkZXIgPSBNYXRoLmZsb29yKG9yZGVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcmRlciA9IHBhcnNlSW50KG9yZGVyLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmRlciA8IDEpIG9yZGVyID0gMTtcclxuICAgICAgICB2YXIgbWluT3JkZXIgPSBvcmRlciA+IDEgPyBNYXRoLmZsb29yKG9yZGVyIC8gMikgOiAxO1xyXG5cclxuICAgICAgICAvLyBVc2UgbnVtY21wIGJ5IGRlZmF1bHRcclxuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgIT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb21wYXJlID0gYnRyZWUubnVtY21wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmFsaWRhdGVzIGEgbm9kZSBhbmQgcHJpbnRzIGRlYnVnZ2luZyBpbmZvIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVRyZWVOb2RlfCFUcmVlfSBub2RlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBieSB0aGUgY29tcGlsZXJcclxuICAgICAgICAgICAgaWYgKChub2RlIGluc3RhbmNlb2YgVHJlZSkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKG5vZGUubGVhdmVzLmxlbmd0aCArIDEgIT0gbm9kZS5ub2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbGVhZi9ub2RlIGNvdW50IGluIFwiICsgbm9kZSArIFwiOiBcIiArIG5vZGUubGVhdmVzLmxlbmd0aCArIFwiL1wiICsgbm9kZS5ub2Rlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWF2ZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBJbGxlZ2FsIGxlYWYgaW4gXCIgKyBub2RlICsgXCIgYXQgXCIgKyBpICsgXCI6IFwiICsgbm9kZS5sZWF2ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubm9kZXNbaV0gPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBJbGxlZ2FsIG5vZGUgaW4gXCIgKyBub2RlICsgXCIgYXQgXCIgKyBpICsgXCI6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlTm9kZS5cclxuICAgICAgICAgKiBAY2xhc3MgQSBUcmVlTm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEoVHJlZU5vZGV8VHJlZSl9IHBhcmVudCBQYXJlbnQgbm9kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPCFMZWFmPj19IGxlYXZlcyBMZWFmIG5vZGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48VHJlZU5vZGU+PX0gbm9kZXMgQ2hpbGQgbm9kZXNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVHJlZU5vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBsZWF2ZXMsIG5vZGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyZW50IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshVHJlZU5vZGV8IVRyZWV9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMZWFmIG5vZGVzIChtYXguIG9yZGVyKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48IUxlYWY+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBsZWF2ZXMgfHwgW107XHJcbiAgICAgICAgICAgIHRoaXMubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKGxlYWYpIHtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hpbGQgbm9kZXMgKG1heC4gb3JkZXIrMSkuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPFRyZWVOb2RlPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcyB8fCBbbnVsbF07XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIG5vZGUucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VhcmNoZXMgZm9yIHRoZSBub2RlIHRoYXQgd291bGQgY29udGFpbiB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7e2xlYWY6ICFMZWFmLCBpbmRleDogbnVtYmVyfXx7bm9kZTogIVRyZWVOb2RlLCBpbmRleDogbnVtYmVyfX0gTGVhZiBpZiB0aGUga2V5IGV4aXN0cywgZWxzZSB0aGUgaW5zZXJ0aW9uIG5vZGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWF2ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmxlYXZlc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGEua2V5LCBrZXkpID09IDApIHJldHVybiB7bGVhZjogYSwgaW5kZXg6IDB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBhLmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uc2VhcmNoKGtleSk7IC8vIExlZnRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogMH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubGVhdmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGIua2V5LCBrZXkpID09IDApIHJldHVybiB7bGVhZjogYiwgaW5kZXg6IGl9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgYi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbaV0uc2VhcmNoKGtleSk7IC8vIElubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogaX07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tpXS5zZWFyY2goa2V5KTsgLy8gUmlnaHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7bm9kZTogdGhpcywgaW5kZXg6IGl9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7bm9kZTogdGhpcywgaW5kZXg6IDB9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfHVuZGVmaW5lZH0gSWYgdGhlcmUgaXMgbm8gc3VjaCBrZXksIHVuZGVmaW5lZCBpcyByZXR1cm5lZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHJldHVybiByZXN1bHQubGVhZi52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNlcnRzIGEga2V5L3ZhbHVlIHBhaXIgaW50byB0aGlzIG5vZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHN1Y2Nlc3NmdWxseSBzZXQsIGZhbHNlIGlmIGFscmVhZHkgcHJlc2VudCBhbmQgb3ZlcndyaXRlIGlzIGBmYWxzZWBcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2goa2V5KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJ3cml0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIW92ZXJ3cml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZWFmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSAvLyBLZXkgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSByZXN1bHQubm9kZSxcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0LmluZGV4O1xyXG4gICAgICAgICAgICBub2RlLmxlYXZlcy5zcGxpY2UoaW5kZXgsIDAsIG5ldyBMZWFmKG5vZGUsIGtleSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgbm9kZS5ub2Rlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBudWxsKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUubGVhdmVzLmxlbmd0aCA+IG9yZGVyKSB7IC8vIFJlYmFsYW5jZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5zcGxpdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGlzIG5vZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGtleSBoYXMgYmVlbiBkZWxldGVkLCBmYWxzZSBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoKGtleSk7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmxlYWYpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGxlYWYgPSByZXN1bHQubGVhZixcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBsZWFmLnBhcmVudCxcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0LmluZGV4LFxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5vZGUubm9kZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIG5vZGUubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IGxlZnQubGVhdmVzW2xlZnQubGVhdmVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgbGVmdC5kZWwobWF4LmtleSk7XHJcbiAgICAgICAgICAgICAgICBtYXgucGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMSwgbWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYWxhbmNlcyB0aGlzIG5vZGUgdG8gZnVsZmlsbCBhbGwgY29uZGl0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuYmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBSb290IGhhcyBqdXN0IGEgc2luZ2xlIGNoaWxkIGFuZCBubyBsZWF2ZXNcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPT0gMCAmJiB0aGlzLm5vZGVzWzBdICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucm9vdCA9IHRoaXMubm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucm9vdC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWF2ZXMubGVuZ3RoID49IG1pbk9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gYXNlYXJjaCh0aGlzLnBhcmVudC5ub2RlcywgdGhpcyksXHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaW5kZXggPiAwID8gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggLSAxXSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyZW50Lm5vZGVzLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMucGFyZW50Lm5vZGVzW2luZGV4ICsgMV0gOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgc2VwLCBsZWFmLCByZXN0O1xyXG4gICAgICAgICAgICBpZiAocmlnaHQgIT09IG51bGwgJiYgcmlnaHQubGVhdmVzLmxlbmd0aCA+IG1pbk9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHNlcGVyYXRvciBmcm9tIHBhcmVudCB0byB0aGlzXHJcbiAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgc2VwLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKHNlcCk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBibGFuayB3aXRoIHRoZSBmaXJzdCByaWdodCBsZWFmXHJcbiAgICAgICAgICAgICAgICBsZWFmID0gcmlnaHQubGVhdmVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVhdmVzW2luZGV4XSA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJpZ2h0IHJlc3QgdG8gdGhpc1xyXG4gICAgICAgICAgICAgICAgcmVzdCA9IHJpZ2h0Lm5vZGVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdCAhPT0gbnVsbCkgcmVzdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHJlc3QpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09IG51bGwgJiYgbGVmdC5sZWF2ZXMubGVuZ3RoID4gbWluT3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgdGhlIHNlcGVyYXRvciBmcm9tIHBhcmVudCB0byB0aGlzXHJcbiAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgIHNlcC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMudW5zaGlmdChzZXApO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgYmxhbmsgd2l0aCB0aGUgbGFzdCBsZWZ0IGxlYWZcclxuICAgICAgICAgICAgICAgIGxlYWYgPSBsZWZ0LmxlYXZlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXSA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIHRoZSBsZWZ0IHJlc3QgdG8gdGhpc1xyXG4gICAgICAgICAgICAgICAgcmVzdCA9IGxlZnQubm9kZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdCAhPT0gbnVsbCkgcmVzdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy51bnNoaWZ0KHJlc3QpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluZSB0aGlzICsgc2VwZXJhdG9yIGZyb20gdGhlIHBhcmVudCArIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gdGhpcy5wYXJlbnQubGVhdmVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdCA9IG5ldyBUcmVlTm9kZSh0aGlzLnBhcmVudCwgY29uY2F0KHRoaXMubGVhdmVzLCBbc2VwXSwgcmlnaHQubGVhdmVzKSwgY29uY2F0KHRoaXMubm9kZXMsIHJpZ2h0Lm5vZGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVhdmVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHJlcGxhY2UgdGhlIG5vZGVzIGl0IHNlcGVyYXRlZCB3aXRoIHN1YnN0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubm9kZXMuc3BsaWNlKGluZGV4LCAyLCBzdWJzdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIGxlZnQgKyBzZXBlcmF0b3IgZnJvbSBwYXJlbnQgKyB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gdGhpcy5wYXJlbnQubGVhdmVzW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIGNvbmNhdChsZWZ0LmxlYXZlcywgW3NlcF0sIHRoaXMubGVhdmVzKSwgY29uY2F0KGxlZnQubm9kZXMsIHRoaXMubm9kZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXMuc3BsaWNlKGluZGV4IC0gMSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHJlcGxhY2UgdGhlIG5vZGVzIGl0IHNlcGVyYXRlZCB3aXRoIHN1YnN0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubm9kZXMuc3BsaWNlKGluZGV4IC0gMSwgMiwgc3Vic3QpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogXCIgKyB0aGlzLnRvU3RyaW5nKHRydWUpICsgXCIgaGFzIG5laXRoZXIgYSBsZWZ0IG5vciBhIHJpZ2h0IHNpYmxpbmdcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5zcGxpdHMgYSBjaGlsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyFMZWFmfSBsZWFmXHJcbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV9IHJlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUudW5zcGxpdCA9IGZ1bmN0aW9uIChsZWFmLCByZXN0KSB7XHJcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgcmVzdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMubGVhdmVzWzBdO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyZShsZWFmLmtleSwgYS5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMudW5zaGlmdChsZWFmKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuc3BsaWNlKDEsIDAsIHJlc3QpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5sZWF2ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUobGVhZi5rZXksIGIua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMuc3BsaWNlKGksIDAsIGxlYWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnNwbGljZShpICsgMSwgMCwgcmVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpID09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnB1c2gobGVhZik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHJlc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPiBvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BsaXRzIHRoaXMgbm9kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IodGhpcy5sZWF2ZXMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFRyZWVOb2RlKHRoaXMsIHRoaXMubGVhdmVzLnNsaWNlKDAsIGluZGV4KSwgdGhpcy5ub2Rlcy5zbGljZSgwLCBpbmRleCArIDEpKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoaW5kZXggKyAxKSwgdGhpcy5ub2Rlcy5zbGljZShpbmRleCArIDEpKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzID0gW3RoaXMubGVhdmVzW2luZGV4XV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVhZiA9IHRoaXMubGVhdmVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN0ID0gbmV3IFRyZWVOb2RlKHRoaXMucGFyZW50LCB0aGlzLmxlYXZlcy5zbGljZShpbmRleCArIDEpLCB0aGlzLm5vZGVzLnNsaWNlKGluZGV4ICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zbGljZSgwLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwLCBpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQudW5zcGxpdChsZWFmLCByZXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVOb2RlcyBXaGV0aGVyIHRvIGluY2x1ZGUgc3ViLW5vZGVzIG9yIG5vdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGluY2x1ZGVOb2Rlcykge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbC5wdXNoKHRoaXMubGVhdmVzW2ldLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHMgPSBcIltcIiArIHZhbC50b1N0cmluZygpICsgXCJdXCIgKyAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlID8gXCI6KlwiIDogXCI6XCIgKyB0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgICAgIGlmIChpbmNsdWRlTm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcIiAtPiBcIiArIHRoaXMubm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpbnRzIG91dCB0aGUgbm9kZXMgbGVhdmVzIGFuZCBub2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKGluZGVudCkge1xyXG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGVudDsgaSsrKSBzcGFjZSArPSBcIiBcIjtcclxuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5sZWF2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2kgKyAxXSAhPT0gbnVsbCkgdGhpcy5ub2Rlc1tpICsgMV0ucHJpbnQoaW5kZW50ICsgMik7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzcGFjZSArIHRoaXMubGVhdmVzW2ldLmtleSArICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUgPyBcIipcIiA6IFwiXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkgdGhpcy5ub2Rlc1swXS5wcmludChpbmRlbnQgKyAyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IExlYWYgY29udGFpbmluZyBhIHZhbHVlLlxyXG4gICAgICAgICAqIEBjbGFzcyBBIExlYWYuXHJcbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV9IHBhcmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTGVhZiA9IGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgdmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgbm9kZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFUcmVlTm9kZX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEtleS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyEqfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVmFsdWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExlYWYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMua2V5O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVHJlZS5cclxuICAgICAgICAgKiBAY2xhc3MgQSBUcmVlLlxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRyZWUoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBUcmVlTm9kZSh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYSBrZXkvdmFsdWUgcGFpciBpbnRvIHRoZSB0cmVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvdmVyd3JpdGUgV2hldGhlciB0byBvdmVyd3JpdGUgZXhpc3RpbmcgdmFsdWVzLCBkZWZhdWx0cyB0byBgdHJ1ZWBcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzZXQsIGZhbHNlIGlmIGFscmVhZHkgcHJlc2VudCBhbmQgb3ZlcndyaXRlIGlzIGBmYWxzZWBcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGtleSBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvdmVyd3JpdGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGtleSA9PT0gbnVsbCkgIHRocm93KG5ldyBFcnJvcihcIklsbGVnYWwga2V5OiBcIiArIGtleSkpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIgKyB2YWx1ZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnB1dChrZXksIHZhbHVlLCBvdmVyd3JpdGUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfHVuZGVmaW5lZH0gSWYgdGhlcmUgaXMgbm8gc3VjaCBrZXksIHVuZGVmaW5lZCBpcyByZXR1cm5lZFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUga2V5IGlzIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGtleSA9PT0gbnVsbCkgIHRocm93KG5ldyBFcnJvcihcIklsbGVnYWwga2V5OiBcIiArIGtleSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldChrZXkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGUgdHJlZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5IGhhcyBiZWVuIGRlbGV0ZWQsIGZhbHNlIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuZGVsKGtleSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2Fsa3MgdGhyb3VnaCBhbGwga2V5cyBbbWluS2V5LCAuLi4sIG1heEtleV0gaW4gYXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpfSBtaW5LZXkgSWYgb21pdHRlZCBvciBOVUxMLCBzdGFydHMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBOVUxMLCB3YWxrcyB0aWxsIHRoZSBlbmRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXHJcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLndhbGtBc2MgPSBmdW5jdGlvbiAobWluS2V5LCBtYXhLZXksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QubGVhdmVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW5LZXkgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBtaW5LZXk7XHJcbiAgICAgICAgICAgICAgICBtaW5LZXkgPSBtYXhLZXkgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXhLZXkgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBtYXhLZXk7XHJcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pbktleSA9IHR5cGVvZiBtaW5LZXkgIT0gJ3VuZGVmaW5lZCcgPyBtaW5LZXkgOiBudWxsO1xyXG4gICAgICAgICAgICBtYXhLZXkgPSB0eXBlb2YgbWF4S2V5ICE9ICd1bmRlZmluZWQnID8gbWF4S2V5IDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIHB0ciwgaW5kZXg7XHJcbiAgICAgICAgICAgIGlmIChtaW5LZXkgPT09IG51bGwpIHsgLy8gSWYgdGhlcmUgaXMgbm8gbWluaW11bSBsaW1pdFxyXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yb290OyAvLyBzZXQgcHRyIHRvIHRoZSBvdXRlciBsZWZ0IG5vZGVcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwdHIubm9kZXNbMF0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7IC8vIGFuZCBzdGFydCBhdCBpdHMgZmlyc3QgbGVhZlxyXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBFbHNlIGxvb2t1cFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucm9vdC5zZWFyY2gobWluS2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikgeyAvLyBJZiB0aGUgbWluaW11bSBrZXkgaXRzZWxmIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5sZWFmLnBhcmVudDsgLy8gc2V0IHB0ciB0byB0aGUgY29udGFpbmluZyBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5sZWF2ZXMsIHJlc3VsdC5sZWFmKTsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBpbmRleFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5ub2RlOyAvLyBzZXQgcHRyIHRvIHRoZSBpbnNlcnRpb24gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0LmluZGV4OyAvLyBhbmQgc3RhcnQgYXQgdGhlIGluc2VydGlvbiBpbmRleCAoa2V5ID4gbWluS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBwdHIubGVhdmVzLmxlbmd0aCkgeyAvLyBvbiBvdmVycnVuLCBiZWdpbiBhdCB0aGUgc2VwYXJhdG9yIGluIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB0ci5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVtcHR5IHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5wYXJlbnQubm9kZXMsIHB0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBwdHIucGFyZW50LmxlYXZlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwdHIvaW5kZXggbm93IHBvaW50cyBhdCBvdXIgZmlyc3QgcmVzdWx0XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4S2V5ICE9PSBudWxsICYmIGNvbXBhcmUocHRyLmxlYXZlc1tpbmRleF0ua2V5LCBtYXhLZXkpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBrZXlzIGxlc3MgdGhhbiBtYXhLZXlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhwdHIubGVhdmVzW2luZGV4XS5rZXksIHB0ci5sZWF2ZXNbaW5kZXhdLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGJyZWFrcyB0aGUgbG9vcCBieSByZXR1cm5pbmcgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHB0ci5ub2Rlc1tpbmRleCArIDFdICE9PSBudWxsKSB7IC8vIERlc2NlbmRcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1swXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwdHIubGVhdmVzLmxlbmd0aCA+IGluZGV4ICsgMSkgeyAvLyBOZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEFzY2VuZFxyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpbmRleCA+PSBwdHIubGVhdmVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGlhcyBvZiB7QGxpbmsgVHJlZSN3YWxrQXNjfS5cclxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgKiBAcGFyYW0geygqfChmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBOVUxMLCB3YWxrcyB0aWxsIHRoZSBlbmRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXHJcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLndhbGsgPSBUcmVlLnByb3RvdHlwZS53YWxrQXNjO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCBrZXlzIFttaW5LZXksIC4uLiwgbWF4S2V5XSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpfSBtaW5LZXkgSWYgb21pdHRlZCBvciBudWxsLCB3YWxrcyB0aWxsIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgKiBAcGFyYW0geygqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCkpPX0gbWF4S2V5IElmIG9taXR0ZWQgb3IgbnVsbCwgc3RhcnRzIGF0IHRoZSBlbmRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXHJcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLndhbGtEZXNjID0gZnVuY3Rpb24gKG1pbktleSwgbWF4S2V5LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1pbktleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1pbktleTtcclxuICAgICAgICAgICAgICAgIG1pbktleSA9IG1heEtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1heEtleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1heEtleTtcclxuICAgICAgICAgICAgICAgIG1heEtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWluS2V5ID0gdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGw7XHJcbiAgICAgICAgICAgIG1heEtleSA9IHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgcHRyLCBpbmRleDtcclxuICAgICAgICAgICAgaWYgKG1heEtleSA9PT0gbnVsbCkgeyAvLyBJZiB0aGVyZSBpcyBubyBtYXhpbXVtIGxpbWl0XHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJvb3Q7IC8vIHNldCBwdHIgdG8gdGhlIG91dGVyIHJpZ2h0IG5vZGVcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gcHRyLmxlYXZlcy5sZW5ndGggLSAxOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGxhc3QgbGVhZlxyXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBFbHNlIGxvb2t1cFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucm9vdC5zZWFyY2gobWF4S2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikgeyAvLyBJZiB0aGUgbWF4aW11bSBrZXkgaXRzZWxmIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5sZWFmLnBhcmVudDsgLy8gc2V0IHB0ciB0byB0aGUgY29udGFpbmluZyBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5sZWF2ZXMsIHJlc3VsdC5sZWFmKTsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBpbmRleFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5ub2RlOyAvLyBzZXQgcHRyIHRvIHRoZSBpbnNlcnRpb24gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0LmluZGV4IC0gMTsgLy8gYW5kIHN0YXJ0IGF0IHRoZSBpbnNlcnRpb24gaW5kZXgtMSAoa2V5IDwgbWF4S2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IDApIHsgLy8gb24gdW5kZXJydW4sIGJlZ2luIGF0IHRoZSBzZXBhcmF0b3IgaW4gdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwdHIvaW5kZXggbm93IHBvaW50cyBhdCBvdXIgZmlyc3QgcmVzdWx0XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluS2V5ICE9PSBudWxsICYmIGNvbXBhcmUocHRyLmxlYXZlc1tpbmRleF0ua2V5LCBtaW5LZXkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBrZXlzIGJpZ2dlciB0aGFuIG1pbktleVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgcHRyLmxlYXZlc1tpbmRleF0udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgYnJlYWtzIHRoZSBsb29wIGJ5IHJldHVybmluZyB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHRyLm5vZGVzW2luZGV4XSAhPT0gbnVsbCkgeyAvLyBEZXNjZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHB0ci5sZWF2ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7IC8vIE5leHRcclxuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXNjZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHB0ci5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpbmRleCA8IDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ291bnRzIHRoZSBudW1iZXIgb2Yga2V5cyBiZXR3ZWVuIG1pbktleSBhbmQgbWF4S2V5IChib3RoIGluY2x1c2l2ZSkuXHJcbiAgICAgICAgICogQHBhcmFtIHsqPX0gbWluS2V5IElmIG9taXR0ZWQsIGNvdW50cyBmcm9tIHRoZSBzdGFydFxyXG4gICAgICAgICAqIEBwYXJhbSB7Kj19IG1heEtleSBJZiBvbWl0dGVkLCBjb3VudHMgdGlsbCB0aGUgZW5kXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAobWluS2V5LCBtYXhLZXkpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLndhbGsoXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgbisrOyB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByaW50cyBvdXQgYWxsIG5vZGVzIGluIHRoZSB0cmVlLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290LnByaW50KDApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJUcmVlKFwiICsgb3JkZXIgKyBcIikgXCIgKyB0aGlzLnJvb3QudG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gVHJlZTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBidHJlZTtcclxuXHJcbn0pKG1vZHVsZSwgY29uc29sZSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9CVHJlZS5qc1xuICoqLyIsIi8qXHJcbiDmipjljYrmn6Xmib4oQmluYXJ5IFNlYXJjaClcclxuXHJcbiDmipjljYrmn6Xmib7lj4jnp7DkuLrkuozliIbmn6Xmib7vvIzmmK/kuIDnp43mlYjnjofovoPpq5jnmoTmn6Xmib7mlrnms5XjgIJcclxuIOWJjeaPkOadoeS7tu+8muafpeaJvuihqOS4reeahOaJgOacieiusOW9leaYr+aMieWFs+mUruWtl+acieW6jyjljYfluo/miJbpmY3luo8pIOOAglxyXG4g5p+l5om+6L+H56iL5Lit77yM5YWI56Gu5a6a5b6F5p+l5om+6K6w5b2V5Zyo6KGo5Lit55qE6IyD5Zu077yM54S25ZCO6YCQ5q2l57yp5bCP6IyD5Zu0KOavj+asoeWwhuW+heafpeiusOW9leaJgOWcqOWMuumXtOe8qeWwj+S4gOWNiinvvIznm7TliLDmib7liLDmiJbmib7kuI3liLDorrDlvZXkuLrmraLjgIJcclxuXHJcbiAxICDmn6Xmib7mgJ3mg7NcclxuIOeUqExvd+OAgUhpZ2jlkoxNaWTooajnpLrlvoXmn6Xmib7ljLrpl7TnmoTkuIvnlYzjgIHkuIrnlYzlkozkuK3pl7TkvY3nva7mjIfpkojvvIzliJ3lgLzkuLpMb3c9MO+8jEhpZ2g9biAtIDHjgIJcclxuIOKRtCAg5Y+W5Lit6Ze05L2N572uTWlk77yaTWlkPU1hdGguZmxvb3IoKExvdytIaWdoKS8yKe+8m1xyXG4g4pG1ICDmr5TovoPkuK3pl7TkvY3nva7orrDlvZXnmoTlhbPplK7lrZfkuI7nu5nlrprnmoRL5YC877yaXHJcbiDikaAgIOebuOetie+8miDmn6Xmib7miJDlip/vvJtcclxuIOKRoSAg5aSn5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5YmN5Y2K5q6177yM5L+u5pS55LiK55WM5oyH6ZKI77yaIEhpZ2g9TWlkLTHvvIzovazikbQg77ybXHJcbiDikaIgIOWwj+S6ju+8muW+heafpeiusOW9leWcqOWMuumXtOeahOWQjuWNiuaute+8jOS/ruaUueS4i+eVjOaMh+mSiO+8mkxvdz1NaWQrMe+8jOi9rOKRtCDvvJtcclxuIOebtOWIsOi2iueVjChMb3c+SGlnaCnvvIzmn6Xmib7lpLHotKXjgIJcclxuXHJcbiAyICDnrpfms5XliIbmnpBcclxuIOKRoCAg5p+l5om+5pe25q+P57uP6L+H5LiA5qyh5q+U6L6D77yM5p+l5om+6IyD5Zu05bCx57yp5bCP5LiA5Y2K77yM6K+l6L+H56iL5Y+v55So5LiA5qO15LqM5Y+J5qCR6KGo56S677yaXHJcbiDil4Yg5qC557uT54K55bCx5piv56ys5LiA5qyh6L+b6KGM5q+U6L6D55qE5Lit6Ze05L2N572u55qE6K6w5b2V77ybXHJcbiDil4Yg5o6S5Zyo5Lit6Ze05L2N572u5YmN6Z2i55qE5L2c5Li65bem5a2Q5qCR55qE57uT54K577ybXHJcbiDil4Yg5o6S5Zyo5Lit6Ze05L2N572u5ZCO6Z2i55qE5L2c5Li65Y+z5a2Q5qCR55qE57uT54K577ybXHJcbiDlr7nlkITlrZDmoJHmnaXor7Tpg73mmK/nm7jlkIznmoTjgILov5nmoLfmiYDlvpfliLDnmoTkuozlj4nmoJHnp7DkuLrliKTlrprmoJEoRGVjaXNpb24gVHJlZSnjgIJcclxuIOKRoSAg5bCG5LqM5Y+J5Yik5a6a5qCR55qE56ysTWF0aC5mbG9vcihNYXRoLmxvZygyLCBuKSkrMeWxguS4iueahOe7k+eCueihpem9kOWwseaIkOS4uuS4gOajtea7oeS6jOWPieagke+8jOa3seW6puS4jeWPmO+8jGg9IE1hdGguZmxvb3IoTWF0aC5sb2coMiwgbiArIDEpKSDjgIJcclxuIOKRoiAg55Sx5ruh5LqM5Y+J5qCR5oCn6LSo55+l77yM56ysaSDlsYLkuIrnmoTnu5PngrnmlbDkuLpNYXRoLnBvdygyLCBpLTEpKGk8PWgpIO+8jOiuvuihqOS4reavj+S4quiusOW9leeahOafpeaJvuamgueOh+ebuOetie+8jOWNs1BpPTEvbu+8jOafpeaJvuaIkOWKn+aXtueahOW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mlxyXG4gKG4rMSkvbipNYXRoLmxvZygyLG4rMSktMVxyXG4g5b2TbuW+iOWkpyAobj41MCnml7bvvIwgQVNM4omIIE1hdGgubG9nKDIsbisxKS0x44CCXHJcblxyXG5cclxuIOaXtumXtOWkjeadguW6pk8obG9nbilcclxuICovXHJcblxyXG4vLyDpnZ7pgJLlvZLlvI9cclxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHNUYWJsZSwga2V5KSB7XHJcbiAgICBsZXQgbG93ID0gMDtcclxuICAgIGxldCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgd2hpbGUobG93IDw9IGhpZ2gpe1xyXG4gICAgICAgIGxldCAgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XHJcbiAgICAgICAgbGV0IGVsZW0gPSBzVGFibGVbbWlkXTtcclxuXHJcbiAgICAgICAgaWYoZWxlbSA9PT0ga2V5KSByZXR1cm4gbWlkO1xyXG4gICAgICAgIGVsc2UgaWYoZWxlbSA8IGtleSkgbG93ID0gbWlkICsgMTtcclxuICAgICAgICBlbHNlIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5cclxuY29uc29sZS5sb2coJ2JpbmFyeVNlYXJjaDogJyk7XHJcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDEpKTsgIC8vIDBcclxuXHJcbi8vIOmAkuW9kuW8j1xyXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2hSZWN1cnNpdmUoc1RhYmxlLCBrZXksIGxvdyA9IDAsIGhpZ2ggPSBzVGFibGUubGVuZ3RoIC0gMSkge1xyXG4gICAgaWYobG93ID4gaGlnaCkgcmV0dXJuIC0xO1xyXG5cclxuICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcclxuICAgIGxldCBlbGVtID0gc1RhYmxlW21pZF07XHJcblxyXG4gICAgaWYoZWxlbSA9PT0ga2V5KSByZXR1cm4gbWlkO1xyXG4gICAgZWxzZSBpZihlbGVtIDwga2V5KSByZXR1cm4gYmluYXJ5U2VhcmNoUmVjdXJzaXZlKHNUYWJsZSwga2V5LCBtaWQgKyAxLCBoaWdoKTtcclxuICAgIGVsc2UgcmV0dXJuIGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShzVGFibGUsIGtleSwgbG93LCBtaWQgLSAxKTtcclxufVxyXG5cclxuY29uc29sZS5sb2coJ2JpbmFyeVNlYXJjaFJlY3Vyc2l2ZTogJyk7XHJcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShbMSwgMiwgMywgNCwgNV0sIDEpKTsgLy8gMFxyXG5jb25zb2xlLmxvZyhiaW5hcnlTZWFyY2hSZWN1cnNpdmUoWzEsIDIsIDMsIDQsIDVdLCA2KSk7IC8vIC0xXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9CaW5hcnlTZWFyY2guanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTUvMS8xMS5cclxuICovXHJcblxyXG4vKlxyXG5cclxuIOWmguaenOS4gOS4quWFs+mUruWtl+WPr+S7peihqOekuuaIkOWtl+espueahOW6j+WPt++8jOWNs+Wtl+espuS4su+8jOmCo+S5iOWPr+S7peeUqOmUruagke+8iGtleXdvcmQgdHJlZe+8ie+8jOWPiOensOaVsOWtl+aQnOe0ouagke+8iGRpZ2l0YWwgc2VhcmNoIHRyZWXvvInmiJblrZfnrKbmoJHvvIzkuZ/lj6vlrZflhbjmoJHvvIzmnaXooajnpLrov5nmoLfnmoTlrZfnrKbkuLLnmoTpm4blkIjjgIJcclxuXHJcbiDmpoLlv7VcclxuXHJcbiDlpoLmnpzkuIDkuKrlhbPplK7lrZflj6/ku6XooajnpLrmiJDlrZfnrKbnmoTluo/lj7fvvIzljbPlrZfnrKbkuLLvvIzpgqPkuYjlj6/ku6XnlKjplK7moJHvvIhrZXl3b3JkIHRyZWXvvInvvIzlj4jnp7DmlbDlrZfmkJzntKLmoJHvvIhkaWdpdGFsIHNlYXJjaCB0cmVl77yJ5oiW5a2X56ym5qCR77yM5p2l6KGo56S66L+Z5qC355qE5a2X56ym5Liy55qE6ZuG5ZCI44CC6ZSu5qCR5Y+I56ew5Li65pWw5a2X5p+l5om+5qCR77yIRGlnaXRhbCBTZWFyY2ggVHJlZSnmiJZUcmll5qCRKHRyaWXkuLpyZXRyaWV2ZeS4remXtDTkuKrlrZfnrKYp77yM5YW257uT5p6E5Y+X5ZCv5Y+R5LqO5LiA6YOo5aSn5Z6L5a2X5YW455qE4oCc5Lmm6L655qCH55uu4oCd44CC5a2X5YW45Lit5qCH5Ye66aaW5a2X5q+N5pivIEEsQixDLC4uLi5a55qE5Y2V6K+N5omA5Zyo6aG1LOWGjeWvueWQhOmDqOWIhuagh+WHuuesrOS6jOWtl+avjeS4ukEsQixDLC4uLlrnmoTljZXor43miYDlnKjnmoTpobUsIC4uLi7nrYnnrYnjgIJcclxuXHJcbiDplK7moJHmmK/kuIDnp43nibnmrornmoTmn6Xmib7moJHvvIzlroPnmoTmn5DkuKroioLngrnkuI3mmK/ljIXlkKvkuIDkuKrmiJblpJrkuKrlhbPplK7lrZfvvIzogIzmmK/lj6rljIXlkKvnu4TmiJDlhbPplK7lrZfnmoTkuIDpg6jliIbvvIjlrZfnrKbmiJbmlbDlrZfvvInvvIzmr5TlpoLvvJrlpoLmnpzlhbPplK7lrZfmmK/mlbDlgLzvvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrmlbDkvY3vvJvlpoLmnpzlhbPplK7lrZfmmK/ljZXor43vvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrlrZfmr43lrZfnrKbjgIJcclxuXHJcbiDmoLnnu5PngrnkuI3ku6Pooajku7vkvZXlrZfnrKbvvIzmoLnku6XkuIvnrKzkuIDlsYLnmoTnu5Pngrnlr7nlupTkuo7lrZfnrKbkuLLnmoTnrKzkuIDkuKrlrZfnrKbvvIznrKzkuozlsYLnmoTnu5Pngrnlr7nlupTkuo7lrZfnrKbkuLLnmoTnrKzkuozkuKrlrZfnrKbigKbigKbmr4/kuKrlrZfnrKbkuLLlj6/nlLHkuIDkuKrnibnmrornmoTlrZfnrKblpoLigJwk4oCd562J5L2c5Li65a2X56ym5Liy55qE57uT5p2f56ym77yM55So5LiA5Liq5Y+25a2Q57uT54K55p2l6KGo56S66K+l54m55q6K5a2X56ym44CC5oqK5LuO5qC55Yiw5Y+25a2Q55qE6Lev5b6E5LiK77yM5omA5pyJ57uT54K577yI6Zmk5qC55Lul5aSW77yJ5a+55bqU55qE5a2X56ym6L+e5o6l6LW35p2l77yM5bCx5b6X5Yiw5LiA5Liq5a2X56ym5Liy44CC5Zug5q2k77yM5q+P5Liq5Y+25a2Q57uT54K55a+55bqU5LiA5Liq5YWz6ZSu5a2X44CC5Zyo5Y+25a2Q57uT54K56L+Y5Y+v5Lul5YyF5ZCr5LiA5Liq5oyH6ZKI77yM5oyH5ZCR6K+l5YWz6ZSu5a2X5omA5a+55bqU55qE5YWD57Sg44CC5pW05Liq5a2X56ym5Liy6ZuG5ZCI5Lit55qE5a2X56ym5Liy55qE5pWw55uu562J5LqO5Y+25a2Q57uT54K555qE5pWw55uu44CC5aaC5p6c5LiA5Liq6ZuG5ZCI5Lit55qE5YWz6ZSu5a2X6YO95YW35pyJ6L+Z5qC355qE5a2X56ym5Liy54m55oCn77yM6YKj5LmI77yM6K+l5YWz6ZSu5a2X6ZuG5ZCI5bCx5Y+v6YeH55So6L+Z5qC35LiA5qO16ZSu5qCR5p2l6KGo56S644CC5LqL5a6e5LiK77yM6L+Y5Y+v5Lul6LWL5LqI4oCc5a2X56ym5Liy4oCd5pu05bm/5rOb55qE5ZCr5LmJ77yM5a6D5Y+v5Lul5piv5Lu75L2V57G75Z6L55qE5a+56LGh57uE5oiQ55qE5Liy44CCXHJcblxyXG5cclxuIOmUruagkeeahOWtmOWCqFxyXG4gMe+8ieWPjOmTvuagkeihqOekulxyXG4gMikg5aSa6YeN6ZO+6KGo6KGo56S6XHJcblxyXG5cclxuIOmUruagkeeahOW6lOeUqOWcuuaZr1xyXG5cclxuIFRyaWXmmK/kuIDnp43pnZ7luLjnroDljZXpq5jmlYjnmoTmlbDmja7nu5PmnoTvvIzkvYbmnInlpKfph4/nmoTlupTnlKjlrp7kvovjgIJcclxuIO+8iDHvvIkg5a2X56ym5Liy5qOA57SiXHJcbiDkuovlhYjlsIblt7Lnn6XnmoTkuIDkupvlrZfnrKbkuLLvvIjlrZflhbjvvInnmoTmnInlhbPkv6Hmga/kv53lrZjliLB0cmll5qCR6YeM77yM5p+l5om+5Y+m5aSW5LiA5Lqb5pyq55+l5a2X56ym5Liy5piv5ZCm5Ye6546w6L+H5oiW6ICF5Ye6546w6aKR546H44CCXHJcbiDkuL7kvovvvJpcclxuIEAgIOe7meWHuk4g5Liq5Y2V6K+N57uE5oiQ55qE54af6K+N6KGo77yM5Lul5Y+K5LiA56+H5YWo55So5bCP5YaZ6Iux5paH5Lmm5YaZ55qE5paH56ug77yM6K+35L2g5oyJ5pyA5pep5Ye6546w55qE6aG65bqP5YaZ5Ye65omA5pyJ5LiN5Zyo54af6K+N6KGo5Lit55qE55Sf6K+N44CCXHJcbiBAICDnu5nlh7rkuIDkuKror43lhbjvvIzlhbbkuK3nmoTljZXor43kuLrkuI3oia/ljZXor43jgILljZXor43lnYfkuLrlsI/lhpnlrZfmr43jgILlho3nu5nlh7rkuIDmrrXmlofmnKzvvIzmlofmnKznmoTmr4/kuIDooYzkuZ/nlLHlsI/lhpnlrZfmr43mnoTmiJDjgILliKTmlq3mlofmnKzkuK3mmK/lkKblkKvmnInku7vkvZXkuI3oia/ljZXor43jgILkvovlpoLvvIzoi6Vyb2LmmK/kuI3oia/ljZXor43vvIzpgqPkuYjmlofmnKxwcm9ibGVt5ZCr5pyJ5LiN6Imv5Y2V6K+N44CCXHJcblxyXG4g77yIMu+8ieWtl+espuS4suacgOmVv+WFrOWFseWJjee8gFxyXG4gVHJpZeagkeWIqeeUqOWkmuS4quWtl+espuS4sueahOWFrOWFseWJjee8gOadpeiKguecgeWtmOWCqOepuumXtO+8jOWPjeS5i++8jOW9k+aIkeS7rOaKiuWkp+mHj+Wtl+espuS4suWtmOWCqOWIsOS4gOajtXRyaWXmoJHkuIrml7bvvIzmiJHku6zlj6/ku6Xlv6vpgJ/lvpfliLDmn5DkupvlrZfnrKbkuLLnmoTlhazlhbHliY3nvIDjgIJcclxuIOS4vuS+i++8mlxyXG4gQCDnu5nlh7pOIOS4quWwj+WGmeiLseaWh+Wtl+avjeS4su+8jOS7peWPilEg5Liq6K+i6Zeu77yM5Y2z6K+i6Zeu5p+Q5Lik5Liq5Liy55qE5pyA6ZW/5YWs5YWx5YmN57yA55qE6ZW/5bqm5piv5aSa5bCR77yfXHJcbiDop6PlhrPmlrnmoYjvvJrpppblhYjlr7nmiYDmnInnmoTkuLLlu7rnq4vlhbblr7nlupTnmoTlrZfmr43moJHjgILmraTml7blj5HnjrDvvIzlr7nkuo7kuKTkuKrkuLLnmoTmnIDplb/lhazlhbHliY3nvIDnmoTplb/luqbljbPlroPku6zmiYDlnKjnu5PngrnnmoTlhazlhbHnpZblhYjkuKrmlbDvvIzkuo7mmK/vvIzpl67popjlsLHovazljJbkuLrkuobnprvnur/vvIhPZmZsaW5l77yJ55qE5pyA6L+R5YWs5YWx56WW5YWI77yITGVhc3QgQ29tbW9uIEFuY2VzdG9y77yM566A56ewTENB77yJ6Zeu6aKY44CCXHJcbiDogIzmnIDov5HlhazlhbHnpZblhYjpl67popjlkIzmoLfmmK/kuIDkuKrnu4/lhbjpl67popjvvIzlj6/ku6XnlKjkuIvpnaLlh6Dnp43mlrnms5XvvJpcclxuIDEuIOWIqeeUqOW5tuafpembhu+8iERpc2pvaW50IFNldO+8ie+8jOWPr+S7pemHh+eUqOmHh+eUqOe7j+WFuOeahFRhcmphbiDnrpfms5XvvJtcclxuIDIuIOaxguWHuuWtl+avjeagkeeahOasp+aLieW6j+WIl++8iEV1bGVyIFNlcXVlbmNlIO+8ieWQju+8jOWwseWPr+S7pei9rOS4uue7j+WFuOeahOacgOWwj+WAvOafpeivou+8iFJhbmdlIE1pbmltdW0gUXVlcnnvvIznroDnp7BSTVHvvInpl67popjkuobvvJtcclxuIO+8iOWFs+S6juW5tuafpembhu+8jFRhcmphbueul+azle+8jFJNUemXrumimO+8jOe9keS4iuacieW+iOWkmui1hOaWmeOAgu+8iVxyXG5cclxuIO+8iDPvvInmjpLluo9cclxuIFRyaWXmoJHmmK/kuIDmo7XlpJrlj4nmoJHvvIzlj6ropoHlhYjluo/pgY3ljobmlbTmo7XmoJHvvIzovpPlh7rnm7jlupTnmoTlrZfnrKbkuLLkvr/mmK/mjInlrZflhbjluo/mjpLluo/nmoTnu5PmnpzjgIJcclxuIOS4vuS+i++8mlxyXG4gQCDnu5nkvaBOIOS4quS6kuS4jeebuOWQjOeahOS7heeUseS4gOS4quWNleivjeaehOaIkOeahOiLseaWh+WQje+8jOiuqeS9oOWwhuWug+S7rOaMieWtl+WFuOW6j+S7juWwj+WIsOWkp+aOkuW6j+i+k+WHuuOAglxyXG5cclxuIO+8iDTvvIkg5L2c5Li65YW25LuW5pWw5o2u57uT5p6E5ZKM566X5rOV55qE6L6F5Yqp57uT5p6EXHJcbiDlpoLlkI7nvIDmoJHvvIxBQ+iHquWKqOacuuetiVxyXG4gKi9cclxuXHJcblxyXG4vKlxyXG4g5Y+M6ZO+5qCR6KGo56S6XHJcblxyXG4g5Lul5qCR55qE5a2p5a2Q5YWE5byf6ZO+6KGo5p2l6KGo56S66ZSu5qCR77yM5YiZ5q+P5Liq5YiG5pSv57uT54K55YyF5ous5LiJ5Liq5Z+f77yaXHJcbiBzeW1ib2zln5/vvJrlrZjlgqjlhbPplK7lrZfnmoTkuIDkuKrlrZfnrKbvvJtcclxuIGZpcnN05Z+f77ya5a2Y5YKo5oyH5ZCR56ys5LiA5qO15a2Q5qCR5qC555qE5oyH6ZKI77ybXHJcbiBuZXh05Z+f77ya5a2Y5YKo5oyH5ZCR5Y+z5YWE5byf55qE5oyH6ZKI44CCXHJcblxyXG4g5ZCM5pe277yM5Y+25a2Q57uT54K55LiN5ZCrZmlyc3Tln5/vvIzlroPnmoRpbmZvcHRy5Z+f5a2Y5YKo5oyH5ZCR6K+l5YWz6ZSu5a2X6K6w5b2V55qE5oyH6ZKI44CCXHJcbiDmraTml7bnmoTplK7moJHlj4jnp7Dlj4zpk77moJHjgIJcclxuIOWcqOWPjOmTvuagkeS4reaPkuWFpeaIluWIoOmZpOS4gOS4quWFs+mUruWtl++8jOebuOW9k+S6juWcqOagkeS4reafkOS4que7k+eCueS4iuaPkuWFpeaIluWIoOmZpOS4gOajteWtkOagkeOAglxyXG4g57uT54K555qE57uT5p6E5Lit5Y+v5Lul6K6+572u5LiA5Liq5p6a5Li+5Y+Y6YeP6KGo56S657uT54K555qE57G75Z6L77yM5Y+25a2Q57uT54K55ZKM5YiG5pSv57uT54K544CCXHJcbiDlj7blrZDnu5PngrnlkozliIbmlK/nu5Pngrnpg73mnIlzeW1ib2zln5/lkoxuZXh05Z+f44CC5LiN5ZCM55qE5LiA5Liq5Z+f5Y+v5Lul55So6IGU5ZCI6KGo56S677yM5Y+25a2Q57uT54K55YyF5ZCraW5mb3B0cuaMh+WQkeiusOW9le+8jOiAjOWIhuaUr+e7k+eCueaYr2ZpcnN05Z+f5oyH5ZCR5YW256ys5LiA5qO15a2Q5qCR44CCXHJcblxyXG5cclxuIOWPjOmTvuagkeeahOafpeaJvlxyXG5cclxuIOWBh+iuvue7meWumuWAvOS4uksuY2goMC4ubnVtLTEpLCDlhbbkuK1LLmNoWzBd6IezIEsuY2hbbnVtLTJd6KGo56S65b6F5p+l5YWz6ZSu5a2X5LitbnVtLTHkuKrlrZfnrKbvvIwgSy5jaFtudW0tMV3kuLrnu5PmnZ/nrKYk44CCXHJcbiDku47lj4zpk77moJHnmoTmoLnmjIfpkojlh7rlj5HvvIzpobpmaXJzdOaMh+mSiOaJvuWIsOesrOS4gOajteWtkOagkeeahOaguee7k+eCue+8jOS7pUsuY2hbMF3lkozmraTnu5PngrnnmoRzeW1ib2zln5/mr5TovoPvvIzoi6Xnm7jnrYnvvIzliJnpobpmaXJzdOWfn+WGjeavlOi+g+S4i+S4gOWtl+espu+8jOWQpuWImeayv25leHTln5/pobrluo/mn6Xmib7jgIJcclxuIOiLpeebtOiHs+epuuS7jeavlOi+g+S4jeetie+8jOWImeafpeaJvuS4jeaIkOWKn+OAglxyXG5cclxuIC8vIOebuOWFs+i1hOaWmVxyXG4gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9yb2xsZW5ob2x0L2FyY2hpdmUvMjAxMi8wNC8yNC8yNDY4OTMyLmh0bWxcclxuIGh0dHA6Ly9ibG9nLmNzZG4ubmV0L3ZfanVseV92L2FydGljbGUvZGV0YWlscy82ODk3MDk3XHJcbiBodHRwOi8vd3d3LnJheWNoYXNlLm5ldC8xNzgzXHJcbiAqL1xyXG5cclxuY29uc3QgTEVBRiA9ICdsZWFmJztcclxuY29uc3QgQlJBTkNIID0gJ2JyYW5jaCc7XHJcbmNvbnN0IFRFUk1JTkFMID0gbmV3IFN0cmluZygnJCcpO1xyXG5cclxuZXhwb3J0IGNsYXNzIERvdWJsZUxpbmtlZFRyZWUge1xyXG4gICAgY29uc3RydWN0b3Ioc3ltYm9sID0gJ3Jvb3QnLCBraW5kID0gQlJBTkNILCBpbmZvID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG4gICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHN5bm9TZWFyY2ggKGtleSkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IHAgJiYgaSA8IGtleS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAocCAmJiBwLmtpbmQgPT09IExFQUYpIGJyZWFrO1xyXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmIChwICYmIHAuc3ltYm9sID09PSBrZXlbaV0pXHJcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcclxuICAgICAgICAgICAgZWxzZSBwID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwICYmIHAua2luZCA9PT0gTEVBRiA/IHAuaW5mbyA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc2VhcmNoIChrZXkpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuZmlyc3Q7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBwICYmIGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5zeW1ib2wgPCBrZXlbaV0pIHAgPSBwLm5leHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocCAmJiBwLnN5bWJvbCA9PT0ga2V5W2ldKVxyXG4gICAgICAgICAgICAgICAgcCA9IHAuZmlyc3Q7XHJcbiAgICAgICAgICAgIGVsc2UgcCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAga2V5ICs9ICcnO1xyXG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgYyA9IGtleVtpXTtcclxuICAgICAgICAgICAgbGV0IHAgPSBjdXI7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5maXJzdDtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgRG91YmxlTGlua2VkVHJlZShjLCBCUkFOQ0gpO1xyXG5cclxuICAgICAgICAgICAgLy8g5aaC5p6c5rKh5pyJ5a2Q57uT54K55YiZ5bCG5paw57uT54K55L2c5Li65a2Q57uT54K5XHJcbiAgICAgICAgICAgIGlmICghY3VyKSB7XHJcbiAgICAgICAgICAgICAgICBwLmZpcnN0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcDtcclxuICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlnKjlhYTlvJ/nu5PngrnkuK3mib7liLDlr7nlupTnu5PngrlcclxuICAgICAgICAgICAgICAgIGlmKGMgPCBjdXIuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cjtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5maXJzdCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjID4gY3VyLnN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBiO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c55u4562J77yM6YCA5Ye66K+l5b6q546v5p+l5om+5LiL5LiA5a2X56ymXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBjdXIuc3ltYm9sKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5bCP5LqO5b2T5YmN5a2X56ym77yM5YiZ5o+S5YWl5Yiw5b2T5YmN57uT54K55YmN6Z2iXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYyA8IGN1ci5zeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gY3VyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOayoeacieWFhOW8n+e7k+eCueWImeaPkuWFpeWIsOWFhOW8n+e7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBiLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOeUn+aIkOWPtuWtkOe7k+eCuVxyXG4gICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGN1ci5raW5kID09PSBCUkFOQ0gpIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gY3VyLmZpcnN0O1xyXG5cclxuICAgICAgICAgICAgLy8g5aaC5p6c5LiN5a2Y5Zyo5YWz6ZSu5a2X5YiZ6K+05piO5o+S5YWl5oiQ5Yqf77yM5ZCm5YiZ5o+S5YWl5aSx6LSlXHJcbiAgICAgICAgICAgIGlmKCEoY2hpbGQgJiYgY2hpbGQuc3ltYm9sID09PSBURVJNSU5BTCkpIHtcclxuICAgICAgICAgICAgICAgIGN1ci5maXJzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKFRFUk1JTkFMLCBMRUFGLCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBrZXkpO1xyXG4gICAgICAgICAgICAgICAgY3VyLmZpcnN0LnBhcmVudCA9IGN1cjtcclxuICAgICAgICAgICAgICAgIGN1ci5maXJzdC5uZXh0ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlIChrZXkpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuZmlyc3Q7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAocCAmJiBpIDwga2V5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmIChwICYmIHAuc3ltYm9sID09PSBrZXlbaV0pIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLmZpcnN0O1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGRhdGEgPSBwLmluZm87XHJcbiAgICAgICAgd2hpbGUgKCFwLm5leHQgJiYgcC5wYXJlbnQpIHAgPSBwLnBhcmVudDtcclxuICAgICAgICBsZXQgdG9wID0gcDtcclxuXHJcbiAgICAgICAgaWYgKHRvcCA9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHAgPSB0b3AucGFyZW50O1xyXG4gICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgIHAgPSBwLmZpcnN0O1xyXG4gICAgICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHByZTtcclxuICAgICAgICAgICAgICAgIGlmIChwID09IHRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWIoOmZpOWcqGZpcnN05Z+f5LiK55qE5a2Q5qCR57uT54K5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRvcC5wYXJlbnQuZmlyc3QgPSB0b3AucGFyZW50LmZpcnN0Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6Zmk5ZyobmV4dOWfn+eahOWFhOW8n+e7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcHJlLm5leHQgPSBwcmUubmV4dC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB0ZXN0ID0gbmV3IERvdWJsZUxpbmtlZFRyZWUoKTtcclxudGVzdC5pbnNlcnQoJ0NBSScpO1xyXG50ZXN0Lmluc2VydCgnTEFOJyk7XHJcbnRlc3QuaW5zZXJ0KCdDQU8nKTtcclxudGVzdC5pbnNlcnQoJ0NIQScpO1xyXG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcclxudGVzdC5pbnNlcnQoJ0NIQU8nKTtcclxudGVzdC5pbnNlcnQoJ0NIRU4nKTtcclxudGVzdC5pbnNlcnQoJ0xJJyk7XHJcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcclxudGVzdC5pbnNlcnQoJ1pIQU8nKTtcclxudGVzdC5pbnNlcnQoJ1pIQU8nKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5zZWFyY2g6ICcpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0FJJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0hBJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0hBTkcnKSk7XHJcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPeCcpKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5yZW1vdmU6Jyk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQUknKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQUknKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMQU4nKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQU8nKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDSEEnKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDSEFORycpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU8nKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDSEVOJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnTEknKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSVUnKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdaSEFPJykpO1xyXG5cclxuXHJcbi8qXHJcbiDlpJrph43pk77ooajooajnpLpcclxuXHJcbiDoi6Xku6XmoJHnmoTlpJrph43pk77ooajooajnpLrplK7moJHvvIzliJnmoJHnmoTmr4/kuKrnu5PngrnkuK3lupTlkKvmnIlk5Liq5oyH6ZKI5Z+f77yM5q2k5pe255qE6ZSu5qCR5Y+I56ewVHJpZeagkeOAglxyXG4g77yIVHJpZeaYr+S7juajgOe0onJldHJpZXZl5Lit5Y+W5Lit6Ze05Zub5Liq5a2X56ym55qE77yM6K+76Z+z5ZCMdHJ577yJ44CCXHJcbiDoi6Xku47plK7moJHkuK3mn5DkuKrnu5PngrnliLDlj7blrZDnu5PngrnnmoTot6/lvoTkuIrmr4/kuKrnu5Pngrnpg73lj6rmnInkuIDkuKrlranlrZDvvIzliJnlj6/lsIbor6Xot6/lvoTkuIrmiYDmnInnu5PngrnljovnvKnmiJDkuIDkuKrigJzlj7blrZDnu5PngrnigJ3vvIzkuJTlnKjor6Xlj7blrZDnu5PngrnkuK3lrZjlgqjlhbPplK7lrZflj4rmjIflkJHorrDlvZXnmoTmjIfpkojnrYnkv6Hmga/jgIJcclxuIOWcqFRyaWXmoJHkuK3mnInkuKTnp43nu5PngrnvvJpcclxuIOWIhuaUr+e7k+eCue+8muWQq+aciWTkuKrmjIfpkojln5/lkozkuIDkuKrmjIfnpLror6Xnu5PngrnkuK3pnZ7nqbrmjIfpkojln5/nmoTkuKrmlbDnmoTmlbTmlbDln5/jgILlnKjliIbmlK/nu5PngrnkuK3kuI3orr7mlbDmja7ln5/vvIzmr4/kuKrliIbmlK/nu5PngrnmiYDooajnpLrnmoTlrZfnrKblnYfmnInlhbbniLbnu5PngrnkuK3mjIflkJHor6Xnu5PngrnnmoTmjIfpkojmiYDlnKjkvY3nva7lhrPlrprjgIJcclxuIOWPtuWtkOe7k+eCue+8muWQq+acieWFs+mUruWtl+Wfn+WSjOaMh+WQkeiusOW9leeahOaMh+mSiOWfn+OAglxyXG5cclxuXHJcbiDlnKhUcmll5qCR5LiK6L+b6KGM5p+l5om+XHJcblxyXG4g5LuO5qC557uT54K55Ye65Y+R77yM5rK/5ZKM57uZ5a6a5YC855u45bqU55qE5oyH6ZKI6YCQ5bGC5ZCR5LiL77yM55u06Iez5Y+25a2Q57uT54K577yM6Iul5Y+25a2Q57uT54K55Lit55qE5YWz6ZSu5a2X5ZKM57uZ5a6a5YC855u4562J77yM5YiZ5p+l5om+5oiQ5Yqf77yM6Iul5YiG5pSv57uT54K55Lit5ZKM57uZ5a6a5YC855u45bqU55qE5oyH6ZKI5Li656m677yM5oiW5Y+25a2Q57uT54K55Lit55qE5YWz6ZSu5a2X5ZKM57uZ5a6a5YC85LiN55u4562J77yM5YiZ5p+l5om+5LiN5oiQ5Yqf44CCXHJcblxyXG5cclxuIOS8mOWMllRyaWXmoJHnmoTmt7HluqZcclxuXHJcbiDmiJHku6zlj6/lr7nlhbPplK7lrZfpm4bpgInmi6nkuIDnp43lkIjpgILnmoTliIblibLjgILlhYjmjInpppblrZfnrKbkuI3pgJrliIbmiJDlpJrkuKrlrZDpm4bkuYvlkI7vvIznhLblkI7mjInmnIDlkI7kuIDkuKrlrZfnrKbkuI3lkIzliIblibLmr4/kuKrlrZDpm4bvvIzlho3mjInnrKzkuozkuKrlrZfnrKbjgILjgILjgILliY3lkI7kuqTlj4nliIblibLjgILkuIDnvKnlh49Ucmll5qCR55qE5rex5bqmXHJcbiAqL1xyXG4vLyDmsYLlrZfnrKblnKjlrZfmr43ooajkuK3nmoTluo/lj7dcclxuZnVuY3Rpb24gb3JkZXIoYykge1xyXG4gICAgcmV0dXJuIGMgPyBjLnRvTG93ZXJDYXNlKCkuY2hhckNvZGVBdCgwKSAtICdhJy5jaGFyQ29kZUF0KDApICsgMSA6IDA7XHJcbn1cclxuXHJcbi8vIOmAmui/h+Wbnua6r+azlea4heeQhlRyaWXmoJHnmoTlh73mlbBcclxuZnVuY3Rpb24gcmVtb3ZlTm9kZSh0cmllTm9kZSwgb3JkZXIsIGNsZWFyKSB7XHJcbiAgICB0cmllTm9kZS5icmFuY2gubm9kZXNbb3JkZXJdID0gbnVsbDtcclxuICAgIC0tdHJpZU5vZGUuYnJhbmNoLm51bTtcclxuXHJcbiAgICBpZiAoIWNsZWFyKSByZXR1cm47XHJcblxyXG4gICAgbGV0IG5vZGVzID0gdHJpZU5vZGUuYnJhbmNoLm5vZGVzO1xyXG4gICAgbGV0IHBhcmVudCA9IHRyaWVOb2RlLnBhcmVudDtcclxuICAgIGxldCBwcmUgPSB0cmllTm9kZTtcclxuXHJcbiAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSBpbiBub2Rlcykge1xyXG4gICAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgbm9kZXNbaV0pIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbmRleDtcclxuICAgICAgICBsZXQgcGFyZW50Tm9kZXMgPSBwYXJlbnQuYnJhbmNoLm5vZGVzO1xyXG4gICAgICAgIGZvciAobGV0IGkgaW4gcGFyZW50Tm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVzLmhhc093blByb3BlcnR5KGkpICYmIHBhcmVudE5vZGVzW2ldICYmIHBhcmVudE5vZGVzW2ldID09IHByZSlcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50LmJyYW5jaC5ub2Rlc1tpbmRleF0gPSBudWxsO1xyXG4gICAgICAgIC0tcGFyZW50LmJyYW5jaC5udW07XHJcblxyXG4gICAgICAgIHByZSA9IHBhcmVudDtcclxuICAgICAgICBub2RlcyA9IHBhcmVudC5icmFuY2gubm9kZXM7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRyaWVUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGtpbmQpIHtcclxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kIHx8IEJSQU5DSDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChraW5kID09PSBMRUFGKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVhZiA9IHtcclxuICAgICAgICAgICAgICAgIGtleTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGluZm86IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJyYW5jaCA9IHtcclxuICAgICAgICAgICAgICAgIC8vIOKAnCTigJ3kuLrnrKzkuIDkuKrlrZfnrKbvvIzlkI7nu63kuLoyNuS4quWtl+avjVxyXG4gICAgICAgICAgICAgICAgbm9kZXM6IG5ldyBBcnJheSgyNyksXHJcbiAgICAgICAgICAgICAgICBudW06IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VhcmNoIChrZXkpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMsIGkgPSAwO1xyXG4gICAgICAgIGZvciAoO1xyXG4gICAgICAgICAgICAgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aDtcclxuICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKTtcclxuXHJcbiAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgaWYgKHAua2luZCA9PT0gTEVBRiAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBwLmxlYWYuaW5mbztcclxuICAgICAgICAgICAgLy8g5ZCM5LmJ6K+NXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5icmFuY2gubm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAocCAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBwLmxlYWYuaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0IChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgLy8g5bu65Y+25a2Q57uT54K5XHJcbiAgICAgICAgbGV0IHEgPSBuZXcgVHJpZVRyZWUoTEVBRik7XHJcbiAgICAgICAgcS5sZWFmLmtleSA9IGtleTtcclxuICAgICAgICBxLmxlYWYuaW5mbyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAvLyDoh6rkuIrogIzkuIvmn6Xmib5cclxuICAgICAgICBsZXQgbGFzdDtcclxuICAgICAgICBsZXQgcCA9IHRoaXMsIGkgPSAwO1xyXG4gICAgICAgIGZvciAoO1xyXG4gICAgICAgICAgICAgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aCAmJiBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXTtcclxuICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKSBsYXN0ID0gcDtcclxuXHJcbiAgICAgICAgLy8g5aaC5p6c5pyA5ZCO6JC95Yiw5YiG5pSv57uT54K577yI5peg5ZCM5LmJ6K+N77yJXHJcbiAgICAgICAgLy8g55u05o6l6L+e5LiK5Y+25a2QXHJcbiAgICAgICAgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XHJcbiAgICAgICAgICAgIHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldID0gcTtcclxuICAgICAgICAgICAgcS5wYXJlbnQgPSBwO1xyXG4gICAgICAgICAgICArK3AuYnJhbmNoLm51bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5aaC5p6c5pyA5ZCO6JC95Yiw5Y+25a2Q57uT54K577yI5pyJ5ZCM5LmJ6K+N77yJXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIOW7uueri+aWsOeahOWIhuaUr+e7k+eCuVxyXG4gICAgICAgICAgICBsZXQgciA9IG5ldyBUcmllVHJlZShCUkFOQ0gpO1xyXG4gICAgICAgICAgICAvLyDnlKjmlrDnmoTliIbmlK/nu5Pngrnlj5bku6PogIHlj7blrZDnu5PngrnlkozkuIrkuIDlsYLnmoTogZTns7tcclxuICAgICAgICAgICAgbGFzdC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2kgLSAxXSldID0gcjtcclxuICAgICAgICAgICAgci5wYXJlbnQgPSBsYXN0O1xyXG4gICAgICAgICAgICByLmJyYW5jaC5udW0gPSAyO1xyXG4gICAgICAgICAgICByLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSA9IHE7XHJcbiAgICAgICAgICAgIHEucGFyZW50ID0gcjtcclxuICAgICAgICAgICAgLy8g5paw5YiG5pSv57uT54K55LiO5paw6ICB5Lik5Liq5Y+25a2Q57uT54K555u46L+eXHJcbiAgICAgICAgICAgIHIuYnJhbmNoLm5vZGVzW29yZGVyKHAubGVhZi5rZXlbaV0pXSA9IHA7XHJcbiAgICAgICAgICAgIHAucGFyZW50ID0gcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXIg5piv5ZCm6ZyA6KaB5riF55CG57uT54K5XHJcbiAgICAgKiBAcmV0dXJucyB7Kn0g5aaC5p6c5Yig6Zmk5oiQ5Yqf6L+U5ZueaW5mb+aVsOaNruWQpuWImei/lOWbnmZhbHNlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSAoa2V5LCBjbGVhcikge1xyXG4gICAgICAgIGxldCBsYXN0O1xyXG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XHJcbiAgICAgICAgLy8g5p+l5om+5b6F5Yig6Zmk5YWD57SgXHJcbiAgICAgICAgZm9yICg7XHJcbiAgICAgICAgICAgICBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpIGxhc3QgPSBwO1xyXG5cclxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgY2xlYXIgPSB0eXBlb2YgY2xlYXIgIT09ICd1bmRlZmluZWQnID8gY2xlYXIgOiB0cnVlO1xyXG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHAua2luZCA9PT0gTEVBRiAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHAubGVhZi5pbmZvO1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKGxhc3QsIG9yZGVyKGtleVtpIC0gMV0pLCBjbGVhcik7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcclxuICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAocCAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBwLmxlYWYuaW5mbztcclxuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUocC5wYXJlbnQsIDAsIGNsZWFyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB0ZXN0ID0gbmV3IFRyaWVUcmVlKCk7XHJcblxyXG50ZXN0Lmluc2VydCgnQ0hBJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEEnKTtcclxudGVzdC5pbnNlcnQoJ0NIQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdDQUknKTtcclxudGVzdC5pbnNlcnQoJ0NIRU4nKTtcclxudGVzdC5pbnNlcnQoJ0NBTycpO1xyXG50ZXN0Lmluc2VydCgnQ0hBTycpO1xyXG50ZXN0Lmluc2VydCgnTE9ORycpO1xyXG50ZXN0Lmluc2VydCgnTEknKTtcclxudGVzdC5pbnNlcnQoJ0xBTicpO1xyXG50ZXN0Lmluc2VydCgnTElVJyk7XHJcbnRlc3QuaW5zZXJ0KCdXQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdXRU4nKTtcclxudGVzdC5pbnNlcnQoJ1dVJyk7XHJcbnRlc3QuaW5zZXJ0KCdZQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdZVU4nKTtcclxudGVzdC5pbnNlcnQoJ1pIQU8nKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5zZWFyY2g6ICcpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnWVVOJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnWkhBTycpKTtcclxuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcclxuXHJcbnRlc3QucmVtb3ZlKCdMQU4nKTtcclxudGVzdC5yZW1vdmUoJ0xJVScpO1xyXG50ZXN0LnJlbW92ZSgnV0FORycpO1xyXG50ZXN0LnJlbW92ZSgnV0VOJyk7XHJcbnRlc3QucmVtb3ZlKCdXVScpO1xyXG50ZXN0LnJlbW92ZSgnWUFORycpO1xyXG50ZXN0LnJlbW92ZSgnWVVOJyk7XHJcbnRlc3QucmVtb3ZlKCdaSEFPJyk7XHJcbnRlc3QucmVtb3ZlKCdDSEEnKTtcclxudGVzdC5yZW1vdmUoJ0NIQU5HJyk7XHJcbnRlc3QucmVtb3ZlKCdDQUknKTtcclxudGVzdC5yZW1vdmUoJ0NIRU4nKTtcclxudGVzdC5yZW1vdmUoJ0NBTycpO1xyXG50ZXN0LnJlbW92ZSgnQ0hBTycpO1xyXG50ZXN0LnJlbW92ZSgnTE9ORycpO1xyXG50ZXN0LnJlbW92ZSgnTEknKTtcclxuXHJcbnRlc3QuaW5zZXJ0KCdMSScpO1xyXG50ZXN0Lmluc2VydCgnTEFOJyk7XHJcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcclxuXHJcblxyXG4vKlxyXG4g5YWz5LqO5a2X5YW45qCR55qE5LyY5YyW55qE5pWw5o2u57uT5p6E5pyJUGF0cmljaWEgVHJlZe+8jFN1ZmZpeCBUcmVlXHJcbiB0b2RvIOacieepuuWGjeWunueOsFxyXG5cclxuIOebuOWFs+i1hOaWme+8mlxyXG4gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGpzc3BhY2UvYXJ0aWNsZS9kZXRhaWxzLzY1NzE0MTRcclxuICovXHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUuanNcbiAqKi8iLCIvKipcclxuICogSGFzaFRhYmxlXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE0LzEyLzMwLlxyXG4gKi9cclxuXHJcbi8qKlxyXG7lk4jluIwo5pWj5YiXKeafpeaJvlxyXG5cclxu5Z+65pys5oCd5oOz77ya5Zyo6K6w5b2V55qE5a2Y5YKo5Zyw5Z2A5ZKM5a6D55qE5YWz6ZSu5a2X5LmL6Ze05bu656uL5LiA5Liq56Gu5a6a55qE5a+55bqU5YWz57O777yb6L+Z5qC377yM5LiN57uP6L+H5q+U6L6D77yM5LiA5qyh5a2Y5Y+W5bCx6IO95b6X5Yiw5omA5p+l5YWD57Sg55qE5p+l5om+5pa55rOV44CCXHJcblxyXG7ln7rmnKzmpoLlv7VcclxuXHJcbuWTiOW4jOWHveaVsO+8muWcqOiusOW9leeahOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+eahOS4gOenjeWvueW6lOWFs+ezu+WPq+WTiOW4jOWHveaVsOOAglxyXG7lk4jluIzlh73mlbDmmK/kuIDnp43mmKDosaHvvIzmmK/ku47lhbPplK7lrZfnqbrpl7TliLDlrZjlgqjlnLDlnYDnqbrpl7TnmoTkuIDnp43mmKDosaHjgILlj6/lhpnmiJDvvJphZGRyKGFpKT1IKGtpKSDvvIzlhbbkuK1p5piv6KGo5Lit5LiA5Liq5YWD57Sg77yMYWRkcihhaSnmmK9haeeahOWcsOWdgO+8jCBraeaYr2Fp55qE5YWz6ZSu5a2X44CCXHJcblxyXG7lk4jluIzooajvvJrlupTnlKjlk4jluIzlh73mlbDvvIznlLHorrDlvZXnmoTlhbPplK7lrZfnoa7lrprorrDlvZXlnKjooajkuK3nmoTlnLDlnYDvvIzlubblsIborrDlvZXmlL7lhaXmraTlnLDlnYDvvIzov5nmoLfmnoTmiJDnmoTooajlj6vlk4jluIzooajjgIJcclxuXHJcbuWTiOW4jOafpeaJvijlj4jlj6vmlaPliJfmn6Xmib4p77ya5Yip55So5ZOI5biM5Ye95pWw6L+b6KGM5p+l5om+55qE6L+H56iL5Y+r5ZOI5biM5p+l5om+44CCXHJcblxyXG7lhrLnqoHvvJrlr7nkuo7kuI3lkIznmoTlhbPplK7lrZdraeOAgWtq77yM6Iula2nvgrlrau+8jOS9hkgoa2kpPUgoa2op55qE546w6LGh5Y+r5Yay56qBKGNvbGxpc2lvbikg44CCXHJcblxyXG7lkIzkuYnor43vvJrlhbfmnInnm7jlkIzlh73mlbDlgLznmoTkuKTkuKrkuI3lkIznmoTlhbPplK7lrZfvvIznp7DkuLror6Xlk4jluIzlh73mlbDnmoTlkIzkuYnor43jgIJcclxu5ZOI5biM5Ye95pWw6YCa5bi45piv5LiA56eN5Y6L57yp5pig6LGh77yM5omA5Lul5Yay56qB5LiN5Y+v6YG/5YWN77yM5Y+q6IO95bC96YeP5YeP5bCR77yb5b2T5Yay56qB5Y+R55Sf5pe277yM5bqU6K+l5pyJ5aSE55CG5Yay56qB55qE5pa55rOV44CC6K6+6K6h5LiA5Liq5pWj5YiX6KGo5bqU5YyF5ous77yaXHJcbuKRoCAg5pWj5YiX6KGo55qE56m66Ze06IyD5Zu077yM5Y2z56Gu5a6a5pWj5YiX5Ye95pWw55qE5YC85Z+f77ybXHJcbuKRoSAg5p6E6YCg5ZCI6YCC55qE5pWj5YiX5Ye95pWw77yM5L2/5b6X5a+55LqO5omA5pyJ5Y+v6IO955qE5YWD57SgKOiusOW9leeahOWFs+mUruWtlynvvIzlh73mlbDlgLzlnYflnKjmlaPliJfooajnmoTlnLDlnYDnqbrpl7TojIPlm7TlhoXvvIzkuJTlh7rnjrDlhrLnqoHnmoTlj6/og73lsL3ph4/lsI/vvJtcclxu4pGiICDlpITnkIblhrLnqoHnmoTmlrnms5XjgILljbPlvZPlhrLnqoHlh7rnjrDml7blpoLkvZXop6PlhrPjgIJcclxuXHJcblxyXG7lk4jluIzlh73mlbDnmoTmnoTpgKBcclxuXHJcbuWTiOW4jOWHveaVsOaYr+S4gOenjeaYoOixoe+8jOWFtuiuvuWumuW+iOeBtea0u++8jOWPquimgeS9v+S7u+S9leWFs+mUruWtl+eahOWTiOW4jOWHveaVsOWAvOmDveiQveWcqOihqOmVv+WFgeiuuOeahOiMg+WbtOS5i+WGheWNs+WPr+OAguWTiOW4jOWHveaVsOKAnOWlveWdj+KAneeahOS4u+imgeivhOS7t+WboOe0oOacie+8mlxyXG7il4Yg5pWj5YiX5Ye95pWw55qE5p6E6YCg566A5Y2V77ybXHJcbuKXhiDog73igJzlnYfljIDigJ3lnLDlsIbmlaPliJfooajkuK3nmoTlhbPplK7lrZfmmKDlsITliLDlnLDlnYDnqbrpl7TjgILmiYDosJPigJzlnYfljIDigJ0odW5pZm9ybSnmmK/mjIflj5HnlJ/lhrLnqoHnmoTlj6/og73mgKflsL3lj6/og73mnIDlsJHjgIJcclxuXHJcbjEgIOebtOaOpeWumuWdgOazlVxyXG7lj5blhbPplK7lrZfmiJblhbPplK7lrZfnmoTmn5DkuKrnur/mgKflh73mlbDkvZzlk4jluIzlnLDlnYDvvIzljbNIKGtleSk9a2V5ICAgIOaIliAgIEgoa2V5KT1hwrdrZXkrYihhLGLkuLrluLjmlbApXHJcbueJueeCue+8muebtOaOpeWumuWdgOazleaJgOW+l+WcsOWdgOmbhuWQiOS4juWFs+mUruWtl+mbhuWQiOWkp+Wwj+ebuOetie+8jOS4jeS8muWPkeeUn+WGsueqge+8jOS9huWunumZheS4reW+iOWwkeS9v+eUqOOAglxyXG5cclxuMiAg5pWw5a2X5YiG5p6Q5rOVXHJcbuWvueWFs+mUruWtl+i/m+ihjOWIhuaekO+8jOWPluWFs+mUruWtl+eahOiLpeW5suS9jeaIlue7hOWQiOS9nOS4uuWTiOW4jOWcsOWdgOOAglxyXG7pgILnlKjkuo7lhbPplK7lrZfkvY3mlbDmr5Tlk4jluIzlnLDlnYDkvY3mlbDlpKfvvIzkuJTlj6/og73lh7rnjrDnmoTlhbPplK7lrZfkuovlhYjnn6XpgZPnmoTmg4XlhrXjgIJcclxu5L6L77yaIOiuvuaciTgw5Liq6K6w5b2V77yM5YWz6ZSu5a2X5Li6OOS9jeWNgei/m+WItuaVsO+8jOWTiOW4jOWcsOWdgOS4ujLkvY3ljYHov5vliLbmlbDjgIJcclxu74KBICDvgoIg74KDICDvgoQg74KFICDvgoYg74KHICDvgohcclxuOCAgMSAgMyAgNCAgNiAgNSAgMyAgMlxyXG44ICAxICAzICA3ICAyICAyICA0ICAyXHJcbjggIDEgIDMgIDggIDcgIDQgIDIgIDJcclxuOCAgMSAgMyAgMCAgMSAgMyAgNiAgN1xyXG44ICAxICAzICAyICAyICA4ICAxICA3XHJcbjggIDEgIDMgIDMgIDggIDkgIDYgIDdcclxuOCAgMSAgMyAgNiAgOCAgNSAgMyAgN1xyXG44ICAxICA0ICAxICA5ICAzICA1ICA1XHJcbuWIhuaekO+8miDvgoEg5Y+q5Y+WOFxyXG4gICAgICDvgoIg5Y+q5Y+WMVxyXG4gICAgICDvgoMg5Y+q5Y+WM+OAgTRcclxuICAgICAg74KIIOWPquWPljLjgIE344CBNVxyXG4gICAgICDvgoTvgoXvgobvgofmlbDlrZfliIbluIPov5HkuY7pmo/mnLpcclxu5omA5Lul77ya5Y+W74KE74KF74KG74KH5Lu75oSP5Lik5L2N5oiW5Lik5L2N5LiO5Y+m5Lik5L2N55qE5Y+g5Yqg5L2c5ZOI5biM5Zyw5Z2AXHJcblxyXG4zICDlubPmlrnlj5bkuK3ms5Vcclxu5bCG5YWz6ZSu5a2X5bmz5pa55ZCO5Y+W5Lit6Ze05Yeg5L2N5L2c5Li65ZOI5biM5Zyw5Z2A44CCXHJcbuS4gOS4quaVsOW5s+aWueWQjuS4remXtOWHoOS9jeWSjOaVsOeahOavj+S4gOS9jemDveacieWFs++8jOWImeeUsemaj+acuuWIhuW4g+eahOWFs+mUruWtl+W+l+WIsOeahOaVo+WIl+WcsOWdgOS5n+aYr+maj+acuueahOOAguaVo+WIl+WHveaVsOaJgOWPlueahOS9jeaVsOeUseaVo+WIl+ihqOeahOmVv+W6puWGs+WumuOAgui/meenjeaWueazlemAguS6juS4jeefpemBk+WFqOmDqOWFs+mUruWtl+aDheWGte+8jOaYr+S4gOenjei+g+S4uuW4uOeUqOeahOaWueazleOAglxyXG5cclxuNCAg5oqY5Y+g5rOVXHJcbuWwhuWFs+mUruWtl+WIhuWJsuaIkOS9jeaVsOebuOWQjOeahOWHoOmDqOWIhijmnIDlkI7kuIDpg6jliIblj6/ku6XkuI3lkIwp77yM54S25ZCO5Y+W6L+Z5Yeg6YOo5YiG55qE5Y+g5Yqg5ZKM5L2c5Li65ZOI5biM5Zyw5Z2A44CCXHJcbuaVsOS9jeWPoOWKoOacieenu+S9jeWPoOWKoOWSjOmXtOeVjOWPoOWKoOS4pOenjeOAglxyXG7il4Yg56e75L2N5Y+g5Yqg77ya5bCG5YiG5Ymy5ZCO55qE5Yeg6YOo5YiG5L2O5L2N5a+56b2Q55u45Yqg44CCXHJcbuKXhiDpl7TnlYzlj6DliqDvvJrku47kuIDnq6/liLDlj6bkuIDnq6/msr/liIblibLnlYzmnaXlm57mipjov63vvIznhLblkI7lr7npvZDnm7jliqDjgIJcclxu6YCC5LqO5YWz6ZSu5a2X5L2N5pWw5b6I5aSa77yM5LiU5q+P5LiA5L2N5LiK5pWw5a2X5YiG5biD5aSn6Ie05Z2H5YyA5oOF5Ya144CCXHJcbuS+i++8miDorr7lhbPplK7lrZfkuLowNDQyMjA1ODY077yM5ZOI5biM5Zyw5Z2A5L2N5pWw5Li6NCDjgILkuKTnp43kuI3lkIznmoTlnLDlnYDorqHnrpfmlrnms5XlpoLkuIvvvJpcclxuICAgIDU4NjQgICAgICAgICAgICAgICAgICAgICAgICA1ODY0XHJcbiAgICA0MjIwICAgICAgICAgICAgICAgICAgICAgICAgMDIyNFxyXG4gICAgICAwNCAgICAgICDnp7vkvY3lj6DliqAgICAgICAgICAgICAwNCAgICAgICAgICAg6Ze055WM5Y+g5YqgXHJcbiAtLS0tLS0tLS0gICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tXHJcbiAgIDEwMDg4ICAgICAgICAgICAgICAgICAgICAgICAgNjA5MVxyXG5cclxuNSAg6Zmk55WZ5L2Z5pWw5rOVXHJcbuWPluWFs+mUruWtl+iiq+afkOS4quS4jeWkp+S6juWTiOW4jOihqOihqOmVv23nmoTmlbBw6Zmk5ZCO5omA5b6X5L2Z5pWw5L2c5ZOI5biM5Zyw5Z2A77yM5Y2zSChrZXkpPWtleSBNT0QgcCAgICAgKHA8PW0pXHJcbuaYr+S4gOenjeeugOWNleOAgeW4uOeUqOeahOWTiOW4jOWHveaVsOaehOmAoOaWueazleOAglxyXG7liKnnlKjov5nnp43mlrnms5XnmoTlhbPplK7mmK9w55qE6YCJ5Y+W77yMcOmAieeahOS4jeWlve+8jOWuueaYk+S6p+eUn+WQjOS5ieivjeOAgnDnmoTpgInlj5bnmoTliIbmnpDvvJpcclxu4peGICDpgInlj5ZwPTJpKHA8PW0p77ya6L+Q566X5L6/5LqO55So56e75L2N5p2l5a6e546w77yM5L2G562J5LqO5bCG5YWz6ZSu5a2X55qE6auY5L2N5b+955Wl6ICM5LuF55WZ5LiL5L2O5L2N5LqM6L+b5Yi25pWw44CC6auY5L2N5LiN5ZCM6ICM5L2O5L2N55u45ZCM55qE5YWz6ZSu5a2X5piv5ZCM5LmJ6K+N44CCXHJcbuKXhiDpgInlj5ZwPXEqZihx44CBZumDveaYr+i0qOWboOaVsO+8jHA8PW0p77ya5YiZ5omA5pyJ5ZCr5pyJceaIlmblm6DlrZDnmoTlhbPplK7lrZfnmoTmlaPliJflnLDlnYDlnYfmmK9x5oiWZueahOWAjeaVsOOAglxyXG7il4Yg6YCJ5Y+WcOS4uue0oOaVsOaIlnA9cSpmKHHjgIFm5piv6LSo5pWw5LiU5Z2H5aSn5LqOMjDvvIxwPD1tKe+8muW4uOeUqOeahOmAieWPluaWueazle+8jOiDveWHj+WwkeWGsueqgeWHuueOsOeahOWPr+iDveaAp+OAglxyXG5cclxuNiAg6ZqP5py65pWw5rOVXHJcbuWPluWFs+mUruWtl+eahOmaj+acuuWHveaVsOWAvOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1yYW5kb20oa2V5KVxyXG7lvZPmlaPliJfooajkuK3lhbPplK7lrZfplb/luqbkuI3nrYnml7bvvIzor6Xmlrnms5Xmr5TovoPlkIjpgILjgIJcclxuXHJcblxyXG5cclxu6YCJ5Y+W5ZOI5biM5Ye95pWw77yM6ICD6JmR5Lul5LiL5Zug57SgXHJcbuKXhiDorqHnrpflk4jluIzlh73mlbDmiYDpnIDml7bpl7TvvJtcclxu4peGIOWFs+mUruWtl+eahOmVv+W6pu+8m1xyXG7il4Yg5ZOI5biM6KGo6ZW/5bqm77yI5ZOI5biM5Zyw5Z2A6IyD5Zu077yJ77ybXHJcbuKXhiDlhbPplK7lrZfliIbluIPmg4XlhrXvvJtcclxu4peGIOiusOW9leeahOafpeaJvumikeeOh+OAglxyXG5cclxuXHJcblxyXG7lhrLnqoHlpITnkIbnmoTmlrnms5Vcclxu5Yay56qB5aSE55CG77ya5b2T5Ye6546w5Yay56qB5pe277yM5Li65Yay56qB5YWD57Sg5om+5Yiw5Y+m5LiA5Liq5a2Y5YKo5L2N572u44CCXHJcblxyXG4xICDlvIDmlL7lrprlnYDms5Vcclxu5Z+65pys5pa55rOV77ya5b2T5Yay56qB5Y+R55Sf5pe277yM5b2i5oiQ5p+Q5Liq5o6i5rWL5bqP5YiX77yb5oyJ5q2k5bqP5YiX6YCQ5Liq5o6i5rWL5pWj5YiX6KGo5Lit55qE5YW25LuW5Zyw5Z2A77yM55u05Yiw5om+5Yiw57uZ5a6a55qE5YWz6ZSu5a2X5oiW5LiA5Liq56m65Zyw5Z2AKOW8gOaUvueahOWcsOWdgCnkuLrmraLvvIzlsIblj5HnlJ/lhrLnqoHnmoTorrDlvZXmlL7liLDor6XlnLDlnYDkuK3jgILmlaPliJflnLDlnYDnmoTorqHnrpflhazlvI/mmK/vvJpcclxuSGkoa2V5KT0oSChrZXkpK2RpKSAgTU9EIG3vvIxpPTEsIDIsIOKApiwgayhrPD1tLTEpXHJcblxyXG7lhbbkuK3vvJpIKGtleSnvvJrlk4jluIzlh73mlbDvvJtt77ya5pWj5YiX6KGo6ZW/5bqm77ybXHJcbmRp77ya56ysaeasoeaOoua1i+aXtueahOWinumHj+W6j+WIl++8m1xyXG5IaShrZXkpIO+8mue7j+esrGnmrKHmjqLmtYvlkI7lvpfliLDnmoTmlaPliJflnLDlnYDjgIJcclxuXHJcbuKRtCAg57q/5oCn5o6i5rWL5rOVXHJcbuWwhuaVo+WIl+ihqFRbMCDigKZtLTFd55yL5oiQ5b6q546v5ZCR6YeP44CC5b2T5Y+R55Sf5Yay56qB5pe277yM5LuO5Yid5qyh5Y+R55Sf5Yay56qB55qE5L2N572u5L6d5qyh5ZCR5ZCO5o6i5rWL5YW25LuW55qE5Zyw5Z2A44CCXHJcbuWinumHj+W6j+WIl+S4uu+8mmRpPTEsIDIsIDMsIOKApiwgbS0xXHJcbuiuvuWIneasoeWPkeeUn+WGsueqgeeahOWcsOWdgOaYr2jvvIzliJnkvp3mrKHmjqLmtYtUW2grMV3vvIxUW2grMl3igKbvvIznm7TliLBUW20tMV3ml7blj4jlvqrnjq/liLDooajlpLTvvIzlho3mrKHmjqLmtYtUWzBd77yMVFsxXeKApu+8jOebtOWIsFRbaC0xXeOAguaOoua1i+i/h+eoi+e7iOatoueahOaDheWGteaYr++8mlxyXG7il4Yg5o6i5rWL5Yiw55qE5Zyw5Z2A5Li656m677ya6KGo5Lit5rKh5pyJ6K6w5b2V44CC6Iul5piv5p+l5om+5YiZ5aSx6LSl77yb6Iul5piv5o+S5YWl5YiZ5bCG6K6w5b2V5YaZ5YWl5Yiw6K+l5Zyw5Z2A77ybXHJcbuKXhiDmjqLmtYvliLDnmoTlnLDlnYDmnInnu5nlrprnmoTlhbPplK7lrZfvvJroi6XmmK/mn6Xmib7liJnmiJDlip/vvJvoi6XmmK/mj5LlhaXliJnlpLHotKXvvJtcclxu4peGIOebtOWIsFRbaF3vvJrku43mnKrmjqLmtYvliLDnqbrlnLDlnYDmiJbnu5nlrprnmoTlhbPplK7lrZfvvIzmlaPliJfooajmu6HjgIJcclxuXHJcbuS+izEg77ya6K6+5pWj5YiX6KGo6ZW/5Li6N++8jOiusOW9leWFs+mUruWtl+e7hOS4uu+8mjE1LCAxNCwgMjgsIDI2LCA1NiwgMjPvvIzmlaPliJflh73mlbDvvJpIKGtleSk9a2V5ICAgTU9EICA377yM5Yay56qB5aSE55CG6YeH55So57q/5oCn5o6i5rWL5rOV44CCXHJcbkgoMTUpPTE1ICBNT0QgNz0xXHJcbkgoMTQpPTE0ICBNT0QgNz0wXHJcbkgoMjgpPTI4ICBNT0QgNz0wICDlhrLnqoEgICBIMSgyOCk9MSAg5Y+I5Yay56qBXHJcbkgyKDI4KT0yICAgICAgICAgICBIKDI2KT0yNiAgTU9EIDc9NVxyXG5IKDU2KT01NiAgTU9EIDc9MCAgICAg5Yay56qBICAgICAgSDEoNTYpPTEgICAgIOWPiOWGsueqgVxyXG5IMig1Nik9MiAgIOWPiOWGsueqgSAgICBIMyg1Nik9M1xyXG5IKDIzKT0yMyAgTU9EIDc9MiAgICAg5Yay56qBICAgICAgSDEoMjMpPTMgICAgIOWPiOWGsueqgVxyXG5IMygyMyk9NFxyXG5cclxuMCAgICAgMSAgICAgIDIgICAgICAzICAgICAgNCAgICAgICA1ICAgICA2XHJcbjE0ICAgIDE1ICAgICAyOCAgICAgNTYgICAgIDIzICAgICAgMjZcclxuXHJcbue6v+aAp+aOoua1i+azleeahOeJueeCuVxyXG7il4Yg5LyY54K577ya5Y+q6KaB5pWj5YiX6KGo5pyq5ruh77yM5oC76IO95om+5Yiw5LiA5Liq5LiN5Yay56qB55qE5pWj5YiX5Zyw5Z2A77ybXHJcbuKXhiDnvLrngrnvvJrmr4/kuKrkuqfnlJ/lhrLnqoHnmoTorrDlvZXooqvmlaPliJfliLDnprvlhrLnqoHmnIDov5HnmoTnqbrlnLDlnYDkuIrvvIzku47ogIzlj4jlop7liqDkuobmm7TlpJrnmoTlhrLnqoHmnLrkvJoo6L+Z56eN546w6LGh56ew5Li65Yay56qB55qE4oCc6IGa6ZuG4oCdKeOAglxyXG5cclxu4pG1ICDkuozmrKHmjqLmtYvms5Vcclxu5aKe6YeP5bqP5YiX5Li677yaZGk9McKyLC0xwrIsMsKyLC0ywrIsM8KyLOKApuKApsKxa8KyICAoazw94oyKbS8y4oyLKVxyXG5cclxu5LiK6L+w5L6L6aKY6Iul6YeH55So5LqM5qyh5o6i5rWL5rOV6L+b6KGM5Yay56qB5aSE55CG77yM5YiZ77yaXHJcbkgoMTUpPTE1ICBNT0QgNz0xICAgICAgICAgSCgxNCk9MTQgIE1PRCA3PTBcclxuSCgyOCk9MjggIE1PRCA3PTAgICAgIOWGsueqgSAgICAgIEgxKDI4KT0xICAgICDlj4jlhrLnqoFcclxuSDIoMjgpPTRcclxuSCgyNik9MjYgIE1PRCA3PTVcclxuSCg1Nik9NTYgIE1PRCA3PTAgICAgIOWGsueqgSAgICAgIEgxKDU2KT0xICAgICDlj4jlhrLnqoFcclxuSDIoNTYpPTAgICDlj4jlhrLnqoEgICAgSDMoNTYpPTQgICAg5Y+I5Yay56qBXHJcbkg0KDU2KT0yXHJcbkgoMjMpPTIzICBNT0QgNz0yICAgICAg5Yay56qBXHJcbkgxKDIzKT0zXHJcblxyXG7kuozmrKHmjqLmtYvms5XnmoTnibnngrlcclxu4peGIOS8mOeCue+8muaOoua1i+W6j+WIl+i3s+i3g+W8j+WcsOaVo+WIl+WIsOaVtOS4quihqOS4re+8jOS4jeaYk+S6p+eUn+WGsueqgeeahOKAnOiBmumbhuKAneeOsOixoe+8m1xyXG7il4Yg57y654K577ya5LiN6IO95L+d6K+B5o6i5rWL5Yiw5pWj5YiX6KGo55qE5omA5pyJ5Zyw5Z2A44CCXHJcblxyXG7ikbYgICDkvKrpmo/mnLrmjqLmtYvms5Vcclxu5aKe6YeP5bqP5YiX5L2/55So5LiA5Liq5Lyq6ZqP5py65Ye95pWw5p2l5Lqn55Sf5LiA5Liq6JC95Zyo6Zet5Yy66Ze0WzHvvIxtLTFd55qE6ZqP5py65bqP5YiX44CCXHJcblxyXG7kvosyIO+8miDooajplb/kuLoxMeeahOWTiOW4jOihqOS4reW3suWhq+acieWFs+mUruWtl+S4ujE377yMNjDvvIwyOeeahOiusOW9le+8jOaVo+WIl+WHveaVsOS4ukgoa2V5KT1rZXkgIE1PRCAgMTEg44CCIOeOsOacieesrDTkuKrorrDlvZXvvIzlhbblhbPplK7lrZfkuLozOO+8jOaMieS4ieenjeWkhOeQhuWGsueqgeeahOaWueazle+8jOWwhuWug+Whq+WFpeihqOS4reOAglxyXG5cclxuKDEpICBIKDM4KT0zOCBNT0QgMTE9NSAgICDlhrLnqoFcclxuICAgICBIMT0oNSsxKSBNT0QgMTE9NiAgICDlhrLnqoFcclxuICAgICBIMj0oNSsyKSBNT0QgMTE9NyAgICDlhrLnqoFcclxuICAgICBIMz0oNSszKSBNT0QgMTE9OCAgICDkuI3lhrLnqoFcclxuKDIpICBIKDM4KT0zOCBNT0QgMTE9NSAgICAgIOWGsueqgVxyXG4gICAgIEgxPSg1KzHCsikgTU9EIDExPTYgICAg5Yay56qBXHJcbiAgICAgSDI9KDUtMcKyKSBNT0QgMTE9NCAgICAg5LiN5Yay56qBXHJcbigzKSAgSCgzOCk9MzggTU9EIDExPTUgICAg5Yay56qBXHJcbiAgICAg6K6+5Lyq6ZqP5py65pWw5bqP5YiX5Li6Oe+8jOWImUgxPSg1KzkpIE1PRCAxMT0zIOS4jeWGsueqgVxyXG5cclxuXHJcbjIgIOWGjeWTiOW4jOazlVxyXG7mnoTpgKDoi6XlubLkuKrlk4jluIzlh73mlbDvvIzlvZPlj5HnlJ/lhrLnqoHml7bvvIzliKnnlKjkuI3lkIznmoTlk4jluIzlh73mlbDlho3orqHnrpfkuIvkuIDkuKrmlrDlk4jluIzlnLDlnYDvvIznm7TliLDkuI3lj5HnlJ/lhrLnqoHkuLrmraLjgILljbPvvJpIaT1SSGkoa2V5KSAgICAgaT0xLCAyLCDigKYsIGtcclxuUkhpIO+8muS4gOe7hOS4jeWQjOeahOWTiOW4jOWHveaVsOOAguesrOS4gOasoeWPkeeUn+WGsueqgeaXtu+8jOeUqFJIMeiuoeeul++8jOesrOS6jOasoeWPkeeUn+WGsueqgeaXtu+8jOeUqFJIMuiuoeeul+KApuS+neatpOexu+aOqOefpemBk+W+l+WIsOafkOS4qkhp5LiN5YaN5Yay56qB5Li65q2i44CCXHJcbuKXhiAg5LyY54K577ya5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd546w6LGh77ybXHJcbuKXhiAg57y654K577ya6K6h566X5pe26Ze05aKe5Yqg44CCXHJcblxyXG5cclxuMyAg6ZO+5Zyw5Z2A5rOVXHJcbuaWueazle+8muWwhuaJgOacieWFs+mUruWtl+S4uuWQjOS5ieivjSjmlaPliJflnLDlnYDnm7jlkIwp55qE6K6w5b2V5a2Y5YKo5Zyo5LiA5Liq5Y2V6ZO+6KGo5Lit77yM5bm255So5LiA57u05pWw57uE5a2Y5pS+6ZO+6KGo55qE5aS05oyH6ZKI44CCXHJcbuiuvuaVo+WIl+ihqOmVv+S4um3vvIzlrprkuYnkuIDkuKrkuIDnu7TmjIfpkojmlbDnu4TvvJpcclxuUmVjTm9kZSAqbGlua2hhc2hbbV3vvIzlhbbkuK1SZWNOb2Rl5piv57uT54K557G75Z6L77yM5q+P5Liq5YiG6YeP55qE5Yid5YC85Li656m644CC5Yeh5pWj5YiX5Zyw5Z2A5Li6a+eahOiusOW9lemDveaPkuWFpeWIsOS7pWxpbmtoYXNoW2td5Li65aS05oyH6ZKI55qE6ZO+6KGo5Lit77yM5o+S5YWl5L2N572u5Y+v5Lul5Zyo6KGo5aS05oiW6KGo5bC+5oiW5oyJ5YWz6ZSu5a2X5o6S5bqP5o+S5YWl44CCXHJcblxyXG7kvovvvJog5bey55+l5LiA57uE5YWz6ZSu5a2XKDE5LCAxNCwgMjMsIDEsIDY4LCAyMCwgODQsIDI3LCA1NSwgMTEsIDEwLCA3OSkg77yM5ZOI5biM5Ye95pWw5Li677yaSChrZXkpPWtleSBNT0QgMTPvvIznlKjpk77lnLDlnYDms5XlpITnkIblhrLnqoE6XHJcblxyXG4gMFxyXG4gMSAgLS0+IDE0IC0+IDEgLT4gMjcgLT4gNzlcclxuIDJcclxuIDMgIC0tPiA2OCAtPiA1NVxyXG4gNFxyXG4gNVxyXG4gNiAgLS0+IDE5IC0+IDg0XHJcbiA3ICAtLT4gMjBcclxuIDhcclxuIDlcclxuIDEwIC0tPiAyMyAtPiAxMFxyXG4gMTEgLS0+IDExXHJcbiAxMlxyXG5cclxuIOS8mOeCue+8muS4jeaYk+S6p+eUn+WGsueqgeeahOKAnOiBmumbhuKAne+8m+WIoOmZpOiusOW9leS5n+W+iOeugOWNleOAglxyXG5cclxuXHJcbiA0ICDlu7rnq4vlhazlhbHmuqLlh7rljLpcclxuIOaWueazle+8muWcqOWfuuacrOaVo+WIl+ihqOS5i+Wklu+8jOWPpuWkluiuvueri+S4gOS4qua6ouWHuuihqOS/neWtmOS4juWfuuacrOihqOS4reiusOW9leWGsueqgeeahOaJgOacieiusOW9leOAglxyXG4g6K6+5pWj5YiX6KGo6ZW/5Li6be+8jOiuvueri+WfuuacrOaVo+WIl+ihqGhhc2h0YWJsZVttXe+8jOavj+S4quWIhumHj+S/neWtmOS4gOS4quiusOW9le+8m+a6ouWHuuihqG92ZXJ0YWJsZVttXe+8jOS4gOaXpuafkOS4quiusOW9leeahOaVo+WIl+WcsOWdgOWPkeeUn+WGsueqge+8jOmDveWhq+WFpea6ouWHuuihqOS4reOAglxyXG5cclxuIOS+i++8miDlt7Lnn6XkuIDnu4TlhbPplK7lrZcoMTUsIDQsIDE4LCA3LCAzNywgNDcpIO+8jOaVo+WIl+ihqOmVv+W6puS4ujcg77yM5ZOI5biM5Ye95pWw5Li677yaSChrZXkpPWtleSBNT0QgN++8jOeUqOW7uueri+WFrOWFsea6ouWHuuWMuuazleWkhOeQhuWGsueqgeOAguW+l+WIsOeahOWfuuacrOihqOWSjOa6ouWHuuihqOWmguS4i++8mlxyXG4gICAgICAgICAgICAgICAgICAgIOaVo+WIl+WcsOWdgCAgICAwICAgICAxICAgICAyICAgICAzICAgICA0ICAgICA1ICAgICA2XHJcbiBIYXNodGFibGXooajvvJpcclxuICAgICAgICAgICAgICAgICAgICDlhbPplK7lrZcgICAgIDcgICAgIDE1ICAgIDM3ICAgICAgICAgIDQgICAgIDQ3XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIOa6ouWHuuWcsOWdgCAgICAwICAgICAxICAgICAyICAgICAzICAgICA0ICAgICA1ICAgICA2XHJcbiBvdmVydGFibGXooajvvJpcclxuICAgICAgICAgICAgICAgICAgICAg5YWz6ZSu5a2XICAgIDE4XHJcblxyXG5cclxuXHJcblxyXG4g5ZOI5biM5p+l5om+6L+H56iL5Y+K5YiG5p6QXHJcblxyXG4gMSAgIOWTiOW4jOafpeaJvui/h+eoi1xyXG4g5ZOI5biM6KGo55qE5Li76KaB55uu55qE5piv55So5LqO5b+r6YCf5p+l5om+77yM5LiU5o+S5YWl5ZKM5Yig6Zmk5pON5L2c6YO96KaB55So5Yiw5p+l5om+44CC55Sx5LqO5pWj5YiX6KGo55qE54m55q6K57uE57uH5b2i5byP77yM5YW25p+l5om+5pyJ54m55q6K55qE5pa55rOV44CCXHJcblxyXG4g57uZ5a6aS+WAvO+8jOagueaNrumAoOihqOaXtuiuvuWumueahOWTiOW4jOWHveaVsOaxguW+l+WTiOW4jOWcsOWdgO+8jOiLpeihqOS4reatpOS9jee9ruS4iuayoeacieiusOW9le+8jOWImeafpeaJvuS4jeaIkOWKn++8m+WQpuWImeavlOi+g+WFs+mUruWtl++8jOiLpeWSjOe7meWumuWFs+mUruWtl+ebuOetie+8jOWImeafpeaJvuaIkOWKn++8m+WQpuWImeagueaNrumAoOihqOaXtuiuvuWumueahOWkhOeQhuWGsueqgeeahOaWueazleaJvuKAnOS4i+S4gOWcsOWdgOKAne+8jOebtOWIsOWTiOW4jOihqOS4reafkOS4quS9jee9ruS4uuepuuaIluiAheihqOS4reaJgOWhq+iusOW9leeahOWFs+mUruWtl+etieS6jue7meWumuWAvOaXtuS4uuatouOAglxyXG5cclxuXHJcblxyXG4g5ZOI5biM5p+l5om+5YiG5p6QXHJcblxyXG4g5LuO5ZOI5biM5p+l5om+6L+H56iL5Y+v6KeB77ya5bC9566h5pWj5YiX6KGo5Zyo5YWz6ZSu5a2X5LiO6K6w5b2V55qE5a2Y5YKo5Zyw5Z2A5LmL6Ze05bu656uL5LqG55u05o6l5pig6LGh77yM5L2G55Sx5LqO4oCc5Yay56qB4oCd77yM5p+l5om+6L+H56iL5LuN5piv5LiA5Liq57uZ5a6a5YC85LiO5YWz6ZSu5a2X6L+b6KGM5q+U6L6D55qE6L+H56iL77yM6K+E5Lu35ZOI5biM5p+l5om+5pWI546H5LuN6KaB55SoQVNM44CCXHJcbiDlk4jluIzmn6Xmib7ml7blhbPplK7lrZfkuI7nu5nlrprlgLzmr5TovoPnmoTmrKHmlbDlj5blhrPkuo7vvJpcclxuIOKXhiDlk4jluIzlh73mlbDvvJtcclxuIOKXhiDlpITnkIblhrLnqoHnmoTmlrnms5XvvJtcclxuIOKXhiDlk4jluIzooajnmoTloavmu6Hlm6DlrZDOsSDjgILloavmu6Hlm6DlrZDOseeahOWumuS5ieaYr++8mlxyXG5cclxuIM6xID0g6KGo5Lit5aGr5YWl55qE6K6w5b2V5pWwIC8g5ZOI5biM6KGo6ZW/5bqmXHJcblxyXG5cclxuIOWQhOenjeaVo+WIl+WHveaVsOaJgOaehOmAoOeahOaVo+WIl+ihqOeahEFTTOWmguS4i++8mlxyXG5cclxuIOKRtCAgIOe6v+aAp+aOoua1i+azleeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxyXG4gU+aIkOWKnyDnuqbnrYnkuo4gMSAvIDIgKiAoMSArIDEgLyAoMSAtIM6xKSlcclxuIFPlpLHotKUg57qm562J5LqOIDEgLyAyICogKDEgKyAxIC8gKDEgLSDOsSkgKiAoMSAtIM6xKSlcclxuXHJcbiDikbUgICDkuozmrKHmjqLmtYvjgIHkvKrpmo/mnLrmjqLmtYvjgIHlho3lk4jluIzms5XnmoTlubPlnYfmn6Xmib7plb/luqbmmK/vvJpcclxuIFPmiJDlip8g57qm562J5LqOIC0xIC8gzrEgKiBsbigxIC0gzrEpXHJcbiBT5aSx6LSlIOe6puetieS6jiAxIC8gKDEgLSDOsSlcclxuXHJcbiDikbYgICDnlKjpk77lnLDlnYDms5Xop6PlhrPlhrLnqoHnmoTlubPlnYfmn6Xmib7plb/luqbmmK/vvJpcclxuIFPmiJDlip8g57qm562J5LqOIDEgKyDOsSAvIDJcclxuIFPlpLHotKUg57qm562J5LqOIM6xICsgZeeahC3OseasoeW5glxyXG5cclxuXHJcbiAqL1xyXG5cclxuaW1wb3J0IExpbmtlZExpc3QgZnJvbSAnLi4vTGlzdC9MaW5rZWRMaXN0JztcclxuXHJcblxyXG5sZXQgaGFzaFNpemUgPSBidWlsZEhhc2hTaXplKDk3NywgMjApO1xyXG5cclxuZXhwb3J0IGNsYXNzIEhhc2hUYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgICAgICAvLyDlvZPliY3mlbDmja7lhYPntKDkuKrmlbA7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgLy8g5b2T5YmN5a656YePXHJcbiAgICAgICAgdGhpcy5zaXplSW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOS9v+eUqOe6v+aAp+aOoua1i+azleino+WGs+WGsueqgVxyXG4gICAgc2VhcmNoKGtleSkge1xyXG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XHJcbiAgICAgICAgbGV0IHAgPSBoYXNoKGtleSwgbWF4KTtcclxuICAgICAgICBsZXQgYyA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChwIDwgbWF4ICYmIHRoaXMuZGF0YVtwXSAhPSBudWxsICYmIGtleSAhPT0gdGhpcy5kYXRhW3BdKSB7XHJcbiAgICAgICAgICAgIHAgPSBjb2xsaXNpb24oa2V5LCArK2MsIG1heCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBrZXkgPT09IHRoaXMuZGF0YVtwXSxcclxuICAgICAgICAgICAgY29sbGlzaW9uVGltZXM6IGMsXHJcbiAgICAgICAgICAgIGluZGV4OiBwXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnQoa2V5KSB7XHJcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcclxuICAgICAgICBpZiAodGhpcy5jb3VudCA+PSBtYXgpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcm1zZzogJ3RhYmxlIG92ZXJmbG93ZWQnIH07XHJcblxyXG4gICAgICAgIGxldCByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xyXG4gICAgICAgIGxldCBwID0gcmV0LmluZGV4O1xyXG4gICAgICAgIGxldCBjID0gcmV0LmNvbGxpc2lvblRpbWVzO1xyXG5cclxuICAgICAgICBpZiAocmV0LnN1Y2Nlc3MpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdIC8gMikge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbcF0gPSBrZXk7XHJcbiAgICAgICAgICAgICsrdGhpcy5jb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNyZWF0ZUhhc2hUYWJsZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY291bnQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcclxuICAgICAgICBsZXQgcCA9IGhhc2goa2V5LCBtYXgpO1xyXG4gICAgICAgIGxldCBjID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGtleSAhPT0gdGhpcy5kYXRhW3BdKVxyXG4gICAgICAgICAgICBwID0gY29sbGlzaW9uKGtleSwgKytjLCBtYXgpO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5kYXRhW3BdKSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhW3BdO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKHAsIDEpO1xyXG4gICAgICAgICAgICAtLXRoaXMuY291bnQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZWNyZWF0ZUhhc2hUYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gKyt0aGlzLnNpemVJbmRleCA8IGhhc2hTaXplLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBFTEZoYXNo5a2X56ym5Liy5pWj5YiX5Ye95pWwXHJcbmZ1bmN0aW9uIGhhc2goc3RyLCBtYXgpIHtcclxuICAgIGxldCBoYXNoID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpICsgaGFzaCArIHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgICAgaGFzaCA9IE1hdGguYWJzKGhhc2gpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc2ggJSBtYXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxpc2lvbihrZXksIHRpbWVzLCBtYXgpIHtcclxuICAgIC8vIOe6v+aAp+aOoua1i+azlVxyXG4gICAgcmV0dXJuIChoYXNoKGtleSwgbWF4KSArIHRpbWVzKSAlIG1heDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNQcmltZShuKSB7XHJcbiAgICBpZiAobiA8PSAzKSByZXR1cm4gbiA+IDE7XHJcbiAgICBpZiAobiAlIDIgPT09IDAgfHwgbiAlIDMgPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSA1OyBpICogaSA8PSBuOyBpICs9IDYpIHtcclxuICAgICAgICBpZiAobiAlIGkgPT09IDAgfHwgbiAlIChpICsgMikgPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRIYXNoU2l6ZShiZWdpbiwgbGVuZ3RoKSB7XHJcbiAgICBsZXQgaGFzaFNpemUgPSBbXTtcclxuXHJcbiAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgIGlmIChoYXNoU2l6ZS5sZW5ndGggPj0gbGVuZ3RoKSBicmVhaztcclxuICAgICAgICBpZiAoaXNQcmltZShiZWdpbikpIGhhc2hTaXplLnB1c2goYmVnaW4pO1xyXG4gICAgICAgICsrYmVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhhc2hTaXplO1xyXG59XHJcblxyXG4vLyDlvIDmlL7lrprlnYDms5VcclxuLy9oYXNoU2l6ZSA9IFs1LCA3XTsgLy8gZm9yIHRlc3QuIHdpbGwgYmUgZGVsZXRlZFxyXG5sZXQgdGVzdCA9IG5ldyBIYXNoVGFibGUoKTtcclxudGVzdC5pbnNlcnQoJzE3Jyk7XHJcbnRlc3QuaW5zZXJ0KCc2MCcpO1xyXG50ZXN0Lmluc2VydCgnMjknKTtcclxudGVzdC5pbnNlcnQoJzM4Jyk7XHJcbnRlc3QuaW5zZXJ0KCczOScpO1xyXG50ZXN0Lmluc2VydCgnNDAnKTtcclxuXHJcbnRlc3QucmVtb3ZlKCcxNycpO1xyXG50ZXN0LnJlbW92ZSgnNjAnKTtcclxudGVzdC5yZW1vdmUoJzI5Jyk7XHJcbnRlc3QucmVtb3ZlKCczOCcpO1xyXG50ZXN0LnJlbW92ZSgnMzknKTtcclxudGVzdC5yZW1vdmUoJzQwJyk7XHJcblxyXG5cclxuLy8g5L2/55So6ZO+5Zyw5Z2A5rOV6Kej5Yaz5Yay56qB55qE5ZOI5biM6KGoXHJcblxyXG5leHBvcnQgY2xhc3MgTGlua2VkTGlzdEhhc2hUYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyDlvZPliY3mlbDmja7lhYPntKDkuKrmlbA7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgLy8g5b2T5YmN5a656YePXHJcbiAgICAgICAgdGhpcy5zaXplSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuaE5vZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgc2VhcmNoKGtleSkge1xyXG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XHJcbiAgICAgICAgbGV0IGkgPSBoYXNoKGtleSwgbWF4KTtcclxuICAgICAgICBsZXQgdCA9IHRoaXMuaE5vZGVzO1xyXG5cclxuICAgICAgICBpZiAodFtpXSA9PSBudWxsKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgaW5kZXg6IGkgfTtcclxuXHJcbiAgICAgICAgbGV0IHAgPSB0W2ldO1xyXG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcclxuXHJcbiAgICAgICAgcC5lYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGRhdGEgPT09IGtleSwgaW5kZXg6IGkgfTtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnQoa2V5KSB7XHJcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcclxuICAgICAgICBpZiAodGhpcy5jb3VudCA+PSBtYXgpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcm1zZzogJ3RhYmxlIG92ZXJmbG93ZWQnIH07XHJcblxyXG4gICAgICAgIGxldCByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHJldC5pbmRleDtcclxuXHJcbiAgICAgICAgaWYgKHJldC5zdWNjZXNzKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5oTm9kZXNbaW5kZXhdKSB0aGlzLmhOb2Rlc1tpbmRleF0gPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oTm9kZXNbaW5kZXhdLnNpemUoKSA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcclxuICAgICAgICAgICAgdGhpcy5oTm9kZXNbaW5kZXhdLm9yZGVySW5zZXJ0KGtleSk7XHJcbiAgICAgICAgICAgICsrdGhpcy5jb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNyZWF0ZUhhc2hUYWJsZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY291bnQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IHJldCA9IHRoaXMuc2VhcmNoKGtleSk7XHJcblxyXG4gICAgICAgIGlmIChyZXQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSByZXQuaW5kZXg7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gcmV0LmRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XVsncmVtb3ZlJ10oa2V5KTtcclxuICAgICAgICAgICAgLS10aGlzLmNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZWNyZWF0ZUhhc2hUYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gKyt0aGlzLnNpemVJbmRleCA8IGhhc2hTaXplLmxlbmd0aDtcclxuICAgIH1cclxufTtcclxuXHJcbmxldCB0ZXN0MiA9IG5ldyBMaW5rZWRMaXN0SGFzaFRhYmxlKCk7XHJcbnRlc3QyLmluc2VydCgnMTcnKTtcclxudGVzdDIuaW5zZXJ0KCc2MCcpO1xyXG50ZXN0Mi5pbnNlcnQoJzI5Jyk7XHJcbnRlc3QyLmluc2VydCgnMzgnKTtcclxudGVzdDIuaW5zZXJ0KCczOScpO1xyXG50ZXN0Mi5pbnNlcnQoJzQwJyk7XHJcblxyXG50ZXN0Mi5yZW1vdmUoJzE3Jyk7XHJcbnRlc3QyLnJlbW92ZSgnNjAnKTtcclxudGVzdDIucmVtb3ZlKCcyOScpO1xyXG50ZXN0Mi5yZW1vdmUoJzM4Jyk7XHJcbnRlc3QyLnJlbW92ZSgnMzknKTtcclxudGVzdDIucmVtb3ZlKCc0MCcpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TZWFyY2gvSGFzaFRhYmxlLmpzXG4gKiovIiwiLyoqXHJcbiAqIFJlZCBCbGFjayBUcmVlXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE0LzEyLzMwLlxyXG4gKi9cclxuLypcclxuIGh0dHA6Ly9ibG9nLmNzZG4ubmV0L3ZfanVseV92L2FydGljbGUvZGV0YWlscy82MTA1NjMwXHJcblxyXG4g57qi6buR5qCR77yM5LiA56eN5LqM5Y+J5p+l5om+5qCR77yM5L2G5Zyo5q+P5Liq57uT54K55LiK5aKe5Yqg5LiA5Liq5a2Y5YKo5L2N6KGo56S657uT54K555qE6aKc6Imy77yM5Y+v5Lul5pivUmVk5oiWQmxhY2vjgIJcclxuIOmAmui/h+WvueS7u+S9leS4gOadoeS7juagueWIsOWPtuWtkOeahOi3r+W+hOS4iuWQhOS4que7k+eCueedgOiJsuaWueW8j+eahOmZkOWItu+8jOe6oum7keagkeehruS/neayoeacieS4gOadoei3r+W+hOS8muavlOWFtuS7lui3r+W+hOmVv+WHuuS/qeWAje+8jOWboOiAjOaYr+aOpei/keW5s+ihoeeahOOAglxyXG5cclxuIOe6oum7keagkeiZveeEtuacrOi0qOS4iuaYr+S4gOajteS6jOWPieafpeaJvuagke+8jOS9huWug+WcqOS6jOWPieafpeaJvuagkeeahOWfuuehgOS4iuWinuWKoOS6huedgOiJsuWSjOebuOWFs+eahOaAp+i0qOS9v+W+l+e6oum7keagkeebuOWvueW5s+ihoe+8jOS7juiAjOS/neivgeS6hue6oum7keagkeeahOafpeaJvuOAgeaPkuWFpeOAgeWIoOmZpOeahOaXtumXtOWkjeadguW6puacgOWdj+S4uk8obG9nIG4p44CCXHJcblxyXG4g57qi6buR5qCR55qENeS4quaAp+i0qO+8mlxyXG4gMS7mr4/kuKrnu5PngrnopoHkuYjmmK/nuqLnmoTopoHkuYjmmK/pu5HnmoTjgIJcclxuIDIu5qC557uT54K55piv6buR55qE44CCXHJcbiAzLuavj+S4quWPtue7k+eCue+8iOWPtue7k+eCueWNs+aMh+agkeWwvuerr05JTOaMh+mSiOaIlk5VTEznu5PngrnvvInpg73mmK/pu5HnmoTjgIJcclxuIDQu5aaC5p6c5LiA5Liq57uT54K55piv57qi55qE77yM6YKj5LmI5a6D55qE5Lik5Liq5YS/5a2Q6YO95piv6buR55qE44CCXHJcbiA1LuWvueS6juS7u+aEj+e7k+eCueiAjOiogO+8jOWFtuWIsOWPtue7k+eCueagkeWwvuerr05JTOaMh+mSiOeahOavj+adoei3r+W+hOmDveWMheWQq+ebuOWQjOaVsOebrueahOm7kee7k+eCueOAglxyXG5cclxuIOato+aYr+e6oum7keagkeeahOi/mTXmnaHmgKfotKjvvIzkvb/kuIDmo7Vu5Liq57uT54K555qE57qi6buR5qCR5aeL57uI5L+d5oyB5LqGbG9nbueahOmrmOW6pu+8jOS7juiAjOS5n+Wwseino+mHiuS6huS4iumdouaJgOivtOeahOKAnOe6oum7keagkeeahOafpeaJvuOAgeaPkuWFpeOAgeWIoOmZpOeahOaXtumXtOWkjeadguW6puacgOWdj+S4uk8obG9nIG4p4oCd6L+Z5LiA57uT6K665oiQ56uL55qE5Y6f5Zug44CCXHJcblxyXG5cclxuIOagkeeahOaXi+i9rFxyXG5cclxu5b2T5Zyo5a+557qi6buR5qCR6L+b6KGM5o+S5YWl5ZKM5Yig6Zmk562J5pON5L2c5pe277yM5a+55qCR5YGa5LqG5L+u5pS55Y+v6IO95Lya56C05Z2P57qi6buR5qCR55qE5oCn6LSo44CC5Li65LqG57un57ut5L+d5oyB57qi6buR5qCR55qE5oCn6LSo77yM5Y+v5Lul6YCa6L+H5a+557uT54K56L+b6KGM6YeN5paw552A6Imy77yM5Lul5Y+K5a+55qCR6L+b6KGM55u45YWz55qE5peL6L2s5pON5L2c77yM5Y2z6YCa6L+H5L+u5pS55qCR5Lit5p+Q5Lqb57uT54K555qE6aKc6Imy5Y+K5oyH6ZKI57uT5p6E77yM5p2l6L6+5Yiw5a+557qi6buR5qCR6L+b6KGM5o+S5YWl5oiW5Yig6Zmk57uT54K5562J5pON5L2c5ZCO57un57ut5L+d5oyB5a6D55qE5oCn6LSo5oiW5bmz6KGh55qE55uu55qE44CCXHJcblxyXG7moJHnmoTml4vovazliIbkuLrlt6bml4vlkozlj7Pml4tcclxuXHJcbuagkeWcqOe7j+i/h+W3puaXi+WPs+aXi+S5i+WQju+8jOagkeeahOaQnOe0ouaAp+i0qOS/neaMgeS4jeWPmO+8jOS9huagkeeahOe6oum7keaAp+i0qOWImeiiq+egtOWdj+S6hu+8jOaJgOS7pe+8jOe6oum7keagkeaPkuWFpeWSjOWIoOmZpOaVsOaNruWQju+8jOmcgOimgeWIqeeUqOaXi+i9rOS4juminOiJsumHjea2guadpemHjeaWsOaBouWkjeagkeeahOe6oum7keaAp+i0qOOAglxyXG5cclxuXHJcbue6oum7keagkeeahOaPkuWFpVxyXG5cclxu5aaC5p6c5o+S5YWl55qE5piv5qC557uT54K577yM55Sx5LqO5Y6f5qCR5piv56m65qCR77yM5q2k5oOF5Ya15Y+q5Lya6L+d5Y+N5oCn6LSoMu+8jOWboOatpOebtOaOpeaKiuatpOe7k+eCuea2guS4uum7keiJsu+8m+WmguaenOaPkuWFpeeahOe7k+eCueeahOeItue7k+eCueaYr+m7keiJsu+8jOeUseS6juatpOS4jeS8mui/neWPjeaAp+i0qDLlkozmgKfotKg077yM57qi6buR5qCR5rKh5pyJ6KKr56C05Z2P77yM5omA5Lul5q2k5pe25LuA5LmI5Lmf5LiN5YGa44CCXHJcbuS9huW9k+mBh+WIsOS4i+i/sDPnp43mg4XlhrXml7blj4jor6XlpoLkvZXosIPmlbTlkaLvvJ9cclxu4pePIOaPkuWFpeS/ruWkjeaDheWGtTHvvJrlpoLmnpzlvZPliY3nu5PngrnnmoTniLbnu5PngrnmmK/nuqLoibLkuJTnpZbniLbnu5PngrnnmoTlj6bkuIDkuKrlrZDnu5PngrnvvIjlj5Tnu5PngrnvvInmmK/nuqLoibJcclxu5q2k5pe254i257uT54K555qE54i257uT54K55LiA5a6a5a2Y5Zyo77yM5ZCm5YiZ5o+S5YWl5YmN5bCx5bey5LiN5piv57qi6buR5qCR44CC5LiO5q2k5ZCM5pe277yM5Y+I5YiG5Li654i257uT54K55piv56WW54i257uT54K555qE5bem5a2p5a2Q6L+Y5piv5Y+z5a2p5a2Q77yM5qC55o2u5a+556ew5oCn77yM5oiR5Lus5Y+q6KaB6Kej5byA5LiA5Liq5pa55ZCR5bCx5Y+v5Lul5LqG44CC6L+Z6YeM5Y+q6ICD6JmR54i257uT54K55Li656WW54i25bem5a2p5a2Q55qE5oOF5Ya1XHJcbuWvueatpO+8jOaIkeS7rOeahOino+WGs+etlueVpeaYr++8muWwhuW9k+WJjeiKgueCueeahOeItuiKgueCueWSjOWPlOWPlOiKgueCuea2gum7ke+8jOellueItue7k+eCuea2gue6ou+8jOaKiuW9k+WJjee7k+eCueaMh+WQkeellueItuiKgueCue+8jOS7juaWsOeahOW9k+WJjeiKgueCuemHjeaWsOW8gOWni+eul+azleOAglxyXG7kuo7mmK/vvIzmj5LlhaXkv67lpI3mg4XlhrUx6L2s5o2i5oiQ5LqG5o+S5YWl5L+u5aSN5oOF5Ya1MlxyXG5cclxu4pePIOaPkuWFpeS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnnmoTniLboioLngrnmmK/nuqLoibIs5Y+U6IqC54K55piv6buR6Imy77yM5b2T5YmN6IqC54K55piv5YW254i26IqC54K555qE5Y+z5a2QXHJcbuatpOaXtu+8jOino+WGs+WvueetluaYr++8muW9k+WJjeiKgueCueeahOeItuiKgueCueWBmuS4uuaWsOeahOW9k+WJjeiKgueCue+8jOS7peaWsOW9k+WJjeiKgueCueS4uuaUr+eCueW3puaXi+OAglxyXG7ku47ogIzmj5LlhaXkv67lpI3mg4XlhrUy6L2s5o2i5oiQ5LqG5o+S5YWl5L+u5aSN5oOF5Ya1M+OAglxyXG5cclxu4pePIOaPkuWFpeS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnnmoTniLboioLngrnmmK/nuqLoibIs5Y+U6IqC54K55piv6buR6Imy77yM5b2T5YmN6IqC54K55piv5YW254i26IqC54K555qE5bem5a2QXHJcbuino+WGs+WvueetluaYr++8mueItuiKgueCueWPmOS4uum7keiJsu+8jOellueItuiKgueCueWPmOS4uue6ouiJsu+8jOWcqOellueItuiKgueCueS4uuaUr+eCueWPs+aXi++8jFxyXG7mnIDlkI7vvIzmiormoLnnu5PngrnmtoLkuLrpu5HoibLvvIzmlbTmo7XnuqLpu5HmoJHkvr/ph43mlrDmgaLlpI3kuoblubPooaHjgIJcclxuXHJcbue7j+i/h+S4iumdouaDheWGtTPjgIHmg4XlhrU044CB5oOF5Ya1NeetiTPnp43mj5LlhaXkv67lpI3mg4XlhrXnmoTmk43kvZznpLrmhI/lm77vvIzor7vogIXoh6rkvJrlj5HnjrDvvIzlkI7pnaLnmoTmg4XlhrU044CB5oOF5Ya1NemDveaYr+mSiOWvueaDheWGtTPmj5LlhaXoioLngrk05Lul5ZCO77yM6L+b6KGM55qE5LiA57O75YiX5o+S5YWl5L+u5aSN5oOF5Ya15pON5L2c77yM5LiN6L+H77yM5oyH5ZCR5b2T5YmN6IqC54K5TuaMh+mSiOS4gOebtOWcqOWPmOWMluOAguaJgOS7pe+8jOS9oOWPr+S7peaDs+W9k+eEtueahOiupOS4uu+8muaVtOS4quS4i+adpe+8jOaDheWGtTPjgIE044CBNeWwseaYr+S4gOS4quWujOaVtOeahOaPkuWFpeS/ruWkjeaDheWGteeahOaTjeS9nOa1geeoi1xyXG5cclxuXHJcbue6oum7keagkeeahOWIoOmZpFxyXG5cclxu5Zyo5Yig6Zmk6IqC54K55ZCO77yM5Y6f57qi6buR5qCR55qE5oCn6LSo5Y+v6IO96KKr5pS55Y+Y77yM5aaC5p6c5Yig6Zmk55qE5piv57qi6Imy6IqC54K577yM6YKj5LmI5Y6f57qi6buR5qCR55qE5oCn6LSo5L6d5pen5L+d5oyB77yM5q2k5pe25LiN55So5YGa5L+u5q2j5pON5L2c77yM5aaC5p6c5Yig6Zmk55qE6IqC54K55piv6buR6Imy6IqC54K577yM5Y6f57qi6buR5qCR55qE5oCn6LSo5Y+v6IO95Lya6KKr5pS55Y+Y77yM5oiR5Lus6KaB5a+55YW25YGa5L+u5q2j5pON5L2c44CC6YKj5LmI5ZOq5Lqb5qCR55qE5oCn6LSo5Lya5Y+R55Sf5Y+Y5YyW5ZGi77yM5aaC5p6c5Yig6Zmk6IqC54K55LiN5piv5qCR5ZSv5LiA6IqC54K577yM6YKj5LmI5Yig6Zmk6IqC54K555qE6YKj5LiA5Liq5pSv55qE5Yiw5ZCE5Y+26IqC54K555qE6buR6Imy6IqC54K55pWw5Lya5Y+R55Sf5Y+Y5YyW77yM5q2k5pe25oCn6LSoNeiiq+egtOWdj+OAguWmguaenOiiq+WIoOiKgueCueeahOWUr+S4gOmdnuepuuWtkOiKgueCueaYr+e6ouiJsu+8jOiAjOiiq+WIoOiKgueCueeahOeItuiKgueCueS5n+aYr+e6ouiJsu+8jOmCo+S5iOaAp+i0qDTooqvnoLTlnY/jgILlpoLmnpzooqvliKDoioLngrnmmK/moLnoioLngrnvvIzogIzlroPnmoTllK/kuIDpnZ7nqbrlrZDoioLngrnmmK/nuqLoibLvvIzliJnliKDpmaTlkI7mlrDmoLnoioLngrnlsIblj5jmiJDnuqLoibLvvIzov53og4zmgKfotKgy44CCXHJcblxyXG7kuIrpnaLnmoTkv67lpI3mg4XlhrXnnIvotbfmnaXmnInkupvlpI3mnYLvvIzkuIvpnaLmiJHku6znlKjkuIDkuKrliIbmnpDmioDlt6fvvJrmiJHku6zku47ooqvliKDoioLngrnlkI7mnaXpobbmm7/lroPnmoTpgqPkuKroioLngrnlvIDlp4vosIPmlbTvvIzlubborqTkuLrlroPmnInpop3lpJbnmoTkuIDph43pu5HoibLjgILov5nph4zpop3lpJbkuIDph43pu5HoibLmmK/ku4DkuYjmhI/mgJ3lkaLvvIzmiJHku6zkuI3mmK/miornuqLpu5HmoJHnmoToioLngrnliqDkuIrpmaTnuqLkuI7pu5HnmoTlj6bkuIDnp43popzoibLvvIzov5nph4zlj6rmmK/kuIDnp43lgYforr7vvIzmiJHku6zorqTkuLrmiJHku6zlvZPliY3mjIflkJHlroPvvIzlm6DmraTnqbrmnInpop3lpJbkuIDnp43pu5HoibLvvIzlj6/ku6XorqTkuLrlroPnmoTpu5HoibLmmK/ku47lroPnmoTniLboioLngrnooqvliKDpmaTlkI7nu6fmib/nu5nlroPnmoTvvIzlroPnjrDlnKjlj6/ku6XlrrnnurPkuKTnp43popzoibLvvIzlpoLmnpzlroPljp/mnaXmmK/nuqLoibLvvIzpgqPkuYjnjrDlnKjmmK/nuqIr6buR77yM5aaC5p6c5Y6f5p2l5piv6buR6Imy77yM6YKj5LmI5a6D546w5Zyo55qE6aKc6Imy5piv6buRK+m7keOAguacieS6hui/memHjemineWklueahOm7keiJsu+8jOWOn+e6oum7keagkeaAp+i0qDXlsLHog73kv53mjIHkuI3lj5jjgILnjrDlnKjlj6ropoHmgaLlpI3lhbblroPmgKfotKjlsLHlj6/ku6XkuobvvIzlgZrms5Xov5jmmK/lsL3ph4/lkJHmoLnnp7vliqjlkoznqbfkuL7miYDmnInlj6/og73mgKfjgIJcclxuXHJcbiDlpoLmnpzmmK/ku6XkuIvmg4XlhrXvvIzmgaLlpI3mr5TovoPnroDljZXvvJpcclxuIGEp5b2T5YmN6IqC54K55piv57qiK+m7keiJslxyXG4g6Kej5rOV77yM55u05o6l5oqK5b2T5YmN6IqC54K55p+T5oiQ6buR6Imy77yM57uT5p2f5q2k5pe257qi6buR5qCR5oCn6LSo5YWo6YOo5oGi5aSN44CCXHJcbiBiKeW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTmmK/moLnoioLngrnvvIwg6Kej5rOV77ya5LuA5LmI6YO95LiN5YGa77yM57uT5p2f44CCXHJcblxyXG4g5L2G5aaC5p6c5piv5Lul5LiL5oOF5Ya15ZGi77yf77yaXHJcbiDliKDpmaTkv67lpI3mg4XlhrUx77ya5b2T5YmN6IqC54K55piv6buRK+m7keS4lOWFhOW8n+iKgueCueS4uue6ouiJsijmraTml7bniLboioLngrnlkozlhYTlvJ/oioLngrnnmoTlrZDoioLngrnliIbkuLrpu5EpXHJcbiDliKDpmaTkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K55piv6buR5Yqg6buR5LiU5YWE5byf5piv6buR6Imy5LiU5YWE5byf6IqC54K555qE5Lik5Liq5a2Q6IqC54K55YWo5Li66buR6ImyXHJcbiDliKDpmaTkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRK+m7ke+8jOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOWFhOW8n+eahOW3puWtkOaYr+e6ouiJsu+8jOWPs+WtkOaYr+m7keiJslxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1NO+8muW9k+WJjeiKgueCueminOiJsuaYr+m7kS3pu5HoibLvvIzlroPnmoTlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzkvYbmmK/lhYTlvJ/oioLngrnnmoTlj7PlrZDmmK/nuqLoibLvvIzlhYTlvJ/oioLngrnlt6blrZDnmoTpopzoibLku7vmhI9cclxuIOatpOaXtu+8jOaIkeS7rOmcgOimgeiwg+eUqFJCLURFTEVURS1GSVhVUChULCB4Ke+8jOadpeaBouWkjeS4juS/neaMgee6oum7keaAp+i0qOeahOW3peS9nOOAglxyXG5cclxuIOS4i+mdou+8jOWSseS7rOS+v+adpeWIhuWIq+WkhOeQhui/mTTnp43liKDpmaTkv67lpI3mg4XlhrXjgIJcclxuXHJcbiDliKDpmaTkv67lpI3mg4XlhrUx77ya5b2T5YmN6IqC54K55piv6buRK+m7keS4lOWFhOW8n+iKgueCueS4uue6ouiJsijmraTml7bniLboioLngrnlkozlhYTlvJ/oioLngrnnmoTlrZDoioLngrnliIbkuLrpu5Ep44CCXHJcbiDop6Pms5XvvJrmiorniLboioLngrnmn5PmiJDnuqLoibLvvIzmiorlhYTlvJ/nu5Pngrnmn5PmiJDpu5HoibLvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5XvvIjmiJHku6zlj6rorqjorrrlvZPliY3oioLngrnmmK/lhbbniLboioLngrnlt6blranlrZDml7bnmoTmg4XlhrXvvInjgILmraTlj5jmjaLlkI7ljp/nuqLpu5HmoJHmgKfotKg15LiN5Y+Y77yM6ICM5oqK6Zeu6aKY6L2s5YyW5Li65YWE5byf6IqC54K55Li66buR6Imy55qE5oOF5Ya1KOazqO+8muWPmOWMluWJje+8jOWOn+acrOWwseacqui/neWPjeaAp+i0qDXvvIzlj6rmmK/kuLrkuobmiorpl67popjovazljJbkuLrlhYTlvJ/oioLngrnkuLrpu5HoibLnmoTmg4XlhrUp44CCXHJcblxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJsuOAglxyXG4g6Kej5rOV77ya5oqK5b2T5YmN6IqC54K55ZKM5YWE5byf6IqC54K55Lit5oq95Y+W5LiA6YeN6buR6Imy6L+95Yqg5Yiw54i26IqC54K55LiK77yM5oqK54i26IqC54K55b2T5oiQ5paw55qE5b2T5YmN6IqC54K577yM6YeN5paw6L+b5YWl566X5rOV44CC77yI5q2k5Y+Y5o2i5ZCO5oCn6LSoNeS4jeWPmO+8iVxyXG5cclxuIOWIoOmZpOS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Er6buR77yM5YWE5byf6IqC54K55piv6buR6Imy77yM5YWE5byf55qE5bem5a2Q5piv57qi6Imy77yM5Y+z5a2Q5piv6buR6Imy44CCXHJcbiDop6Pms5XvvJrmiorlhYTlvJ/nu5Pngrnmn5PnuqLvvIzlhYTlvJ/lt6blrZDoioLngrnmn5Ppu5HvvIzkuYvlkI7lho3lnKjlhYTlvJ/oioLngrnkuLrmlK/ngrnop6Plj7Pml4vvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5XjgILmraTmmK/miorlvZPliY3nmoTmg4XlhrXovazljJbkuLrmg4XlhrU077yM6ICM5oCn6LSoNeW+l+S7peS/neaMgVxyXG5cclxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSP44CCXHJcbiDop6Pms5XvvJrmiorlhYTlvJ/oioLngrnmn5PmiJDlvZPliY3oioLngrnniLboioLngrnnmoTpopzoibLvvIzmiorlvZPliY3oioLngrnniLboioLngrnmn5PmiJDpu5HoibLvvIzlhYTlvJ/oioLngrnlj7PlrZDmn5PmiJDpu5HoibLvvIzkuYvlkI7ku6XlvZPliY3oioLngrnnmoTniLboioLngrnkuLrmlK/ngrnov5vooYzlt6bml4vvvIzmraTml7bnrpfms5Xnu5PmnZ/vvIznuqLpu5HmoJHmiYDmnInmgKfotKjosIPmlbTmraPnoa5cclxuXHJcblxyXG4g5pyA5ZCO5YC85b6X5LiA5o+Q55qE5piv5LiK6L+w5Yig6Zmk5L+u5aSN55qE5oOF5Ya1MX406YO95Y+q5piv5qCR55qE5bGA6YOo77yM5bm26Z2e5qCR55qE5pW05L2T5YWo6YOo77yM5LiU5Yig6Zmk5L+u5aSN5oOF5Ya1M+OAgTTlnKjnu4/ov4fkuIrpnaLnmoTosIPmlbTlkI7vvIzosIPmlbTov5jmsqHnu5PmnZ8s6L+Y5b6X57un57ut6LCD5pW055u06Iez6YeN5paw5oGi5aSN5bmz6KGhXHJcbiovXHJcbmltcG9ydCBCU1ROb2RlIGZyb20gJy4vQmluYXJ5U29ydGVkVHJlZSc7XHJcblxyXG5jb25zdCBSRUQgPSAncmVkJztcclxuY29uc3QgQkxBQ0sgPSAnYmxhY2snO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJlZEJsYWNrTm9kZSBleHRlbmRzIEJTVE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIC4uLnJlc3Qpe1xyXG4gICAgICAgIHN1cGVyKGRhdGEsIC4uLnJlc3QpO1xyXG5cclxuICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodENoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgUmVkQmxhY2tMZWFmIHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gdGhpcztcclxuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBSZWRCbGFja1RyZWUge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICAvLyDlk6jlhbVcclxuICAgICAgICB0aGlzLm5pbCA9IG5ldyBSZWRCbGFja0xlYWYoKTtcclxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm5pbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOmAkuW9kuafpeaJvueul+azlVxyXG4gICAgICogQHBhcmFtIGRhdGFcclxuICAgICAqL1xyXG4gICAgZmluZChkYXRhKXtcclxuICAgICAgICBsZXQgeiA9IHRoaXMucm9vdDtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIGZpbmQoeiwgZGF0YSl7XHJcbiAgICAgICAgICAgIGlmKHogPT0gbWUubmlsIHx8IGRhdGEgPT09IHouZGF0YSkgcmV0dXJuIHo7XHJcblxyXG4gICAgICAgICAgICBpZihkYXRhIDwgei5kYXRhKSByZXR1cm4gZmluZCh6LmxlZnRDaGlsZCwgZGF0YSk7XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZpbmQoei5yaWdodENoaWxkLCBkYXRhKTtcclxuICAgICAgICB9KSh6LCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOaPkuWFpVxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGFkZChkYXRhKXtcclxuICAgICAgICBsZXQgeiA9IG5ldyBSZWRCbGFja05vZGUoZGF0YSk7XHJcbiAgICAgICAgei5sZWZ0Q2hpbGQgPSB0aGlzLm5pbDtcclxuICAgICAgICB6LnJpZ2h0Q2hpbGQgPSB0aGlzLm5pbDtcclxuICAgICAgICBsZXQgeSA9IHRoaXMubmlsO1xyXG4gICAgICAgIGxldCB4ID0gdGhpcy5yb290O1xyXG5cclxuICAgICAgICAvLyDmib7liLDopoHmj5LlhaXkvY3nva7nmoTnu5Pngrl5XHJcbiAgICAgICAgd2hpbGUoeCAhPSB0aGlzLm5pbCl7XHJcbiAgICAgICAgICAgIHkgPSB4O1xyXG5cclxuICAgICAgICAgICAgaWYoei5kYXRhIDwgeC5kYXRhKSB4ID0geC5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIGVsc2UgeCA9IHgucmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHoucGFyZW50ID0geTtcclxuXHJcbiAgICAgICAgLy8g5aaC5p6ceeS4jeaYr+aguee7k+eCue+8jOagueaNruWkp+Wwj+aPkuWFpeWIsOW3puaIluWPs+WtkOagkVxyXG4gICAgICAgIGlmKHkgIT0gdGhpcy5uaWwpIHtcclxuICAgICAgICAgICAgaWYoei5kYXRhIDwgeS5kYXRhKSB5LmxlZnRDaGlsZCA9IHo7XHJcbiAgICAgICAgICAgIGVsc2UgeS5yaWdodENoaWxkID0gejtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5ZCm5YiZ5o+S5YWl5Yiw5qC557uT54K5XHJcbiAgICAgICAgZWxzZSB0aGlzLnJvb3QgPSB6ID09IHRoaXMubmlsID8gbnVsbCA6IHo7XHJcblxyXG4gICAgICAgIC8vIOaPkuWFpeS/ruWkjeaTjeS9nFxyXG4gICAgICAgIHRoaXMuX2FkZEZpeHVwKHopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5o+S5YWl566X5rOV5L+u5aSNXHJcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0geiDlvoXmj5LlhaXnmoTnu5PngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9hZGRGaXh1cCh6KXtcclxuXHJcbiAgICAgICAgd2hpbGUoeiAhPSB0aGlzLnJvb3QgJiYgei5wYXJlbnQuY29sb3IgPT09IFJFRCl7XHJcbiAgICAgICAgICAgIGlmKHoucGFyZW50ID09IHoucGFyZW50LnBhcmVudC5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICBsZWZ0QWRkRml4dXAodGhpcywgeik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJpZ2h0QWRkRml4dXAodGhpcywgeik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmnIDlkI7vvIzmiormoLnnu5PngrnmtoLkuLrpu5HoibLvvIzmlbTmo7XnuqLpu5HmoJHkvr/ph43mlrDmgaLlpI3kuoblubPooaFcclxuICAgICAgICB0aGlzLnJvb3QuY29sb3IgPSBCTEFDSztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOWIoOmZpOeul+azlVxyXG4gICAgICogQHBhcmFtIHtSZWRCbGFja05vZGV9IHog5b6F5Yig6Zmk57uT54K5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU5vZGUoeil7XHJcbiAgICAgICAgbGV0IHgsIHk7XHJcblxyXG4gICAgICAgIC8vIOaJvuWIsOW+heWIoOmZpOe7k+eCueeahOeItue7k+eCueaIluebuOmCu+W+heabv+aNoue7k+eCuVxyXG4gICAgICAgIGlmKHoubGVmdENoaWxkID09IHRoaXMubmlsIHx8IHoucmlnaHRDaGlsZCA9PSB0aGlzLm5pbClcclxuICAgICAgICAgICAgeSA9IHo7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB5ID0gdGhpcy5zdWNjZXNzb3Ioeik7XHJcblxyXG4gICAgICAgIGlmKHkubGVmdENoaWxkICE9IHRoaXMubmlsKSB4ID0geS5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgZWxzZSB4ID0geS5yaWdodENoaWxkO1xyXG5cclxuICAgICAgICB4LnBhcmVudCA9IHkucGFyZW50O1xyXG5cclxuICAgICAgICAvLyDliKDpmaTmk43kvZxcclxuICAgICAgICBpZih5LnBhcmVudCA9PSB0aGlzLm5pbCkgdGhpcy5yb290ID0geDtcclxuICAgICAgICBlbHNlIGlmKHkgPT0geS5wYXJlbnQubGVmdENoaWxkKSB5LnBhcmVudC5sZWZ0Q2hpbGQgPSB4O1xyXG4gICAgICAgIGVsc2UgeS5wYXJlbnQucmlnaHRDaGlsZCA9IHg7XHJcblxyXG4gICAgICAgIGlmKHkgIT0geikgei5kYXRhID0geS5kYXRhO1xyXG5cclxuICAgICAgICAvLyDliKDpmaTkv67lpI1cclxuICAgICAgICBpZih5LmNvbG9yID09PSBCTEFDSykgdGhpcy5fcmVtb3ZlRml4dXAoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g566X5rOV5a+86K665LiK55qE5Yig6Zmk57uT54K5XHJcbiAgICByZW1vdmVOb2RlMih6KXtcclxuICAgICAgICBsZXQgeSA9IHo7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsWUNvbG9yID0geS5jb2xvcjtcclxuICAgICAgICBsZXQgeDtcclxuXHJcbiAgICAgICAgaWYoei5sZWZ0Q2hpbGQgPT0gdGhpcy5uaWwpIHtcclxuICAgICAgICAgICAgeCA9IHoucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNwbGFudCh6LCB6LnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH0gZWxzZSBpZih6LnJpZ2h0Q2hpbGQgPT0gdGhpcy5uaWwpIHtcclxuICAgICAgICAgICAgeCA9IHoubGVmdENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHoubGVmdENoaWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5ID0gdGhpcy5taW4oei5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxZQ29sb3IgPSB5LmNvbG9yO1xyXG4gICAgICAgICAgICB4ID0geS5yaWdodENoaWxkO1xyXG5cclxuICAgICAgICAgICAgaWYoeS5wYXJlbnQgPT0geikgeC5wYXJlbnQgPSB5O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeSwgeS5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgICAgIHkucmlnaHRDaGlsZCA9IHoucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHkucmlnaHRDaGlsZC5wYXJlbnQgPSB5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHkpO1xyXG4gICAgICAgICAgICB5LmxlZnRDaGlsZCA9IHoubGVmdENoaWxkO1xyXG4gICAgICAgICAgICB5LmxlZnRDaGlsZC5wYXJlbnQgPSB5O1xyXG4gICAgICAgICAgICB5LmNvbG9yID0gei5jb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG9yaWdpbmFsWUNvbG9yID09PSBCTEFDSykgdGhpcy5fcmVtb3ZlRml4dXAoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3RyYW5zcGxhbnQodSwgdil7XHJcbiAgICAgICAgaWYodS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHY7XHJcbiAgICAgICAgZWxzZSBpZih1ID09IHUucGFyZW50LmxlZnRDaGlsZCkgdS5wYXJlbnQubGVmdENoaWxkID0gdjtcclxuICAgICAgICBlbHNlIHUucGFyZW50LnJpZ2h0Q2hpbGQgPSB2O1xyXG5cclxuICAgICAgICB2LnBhcmVudCA9IHUucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5L+u5aSNXHJcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0gelxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZUZpeHVwKHope1xyXG4gICAgICAgIHdoaWxlKHogIT09IHRoaXMucm9vdCAmJiB6LmNvbG9yID09PSBCTEFDSyl7XHJcbiAgICAgICAgICAgIGlmKHogPT0gei5wYXJlbnQubGVmdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgbGVmdFJlbW92ZUZpeHVwKHRoaXMsIHopO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByaWdodFJlbW92ZUZpeHVwKHRoaXMsIHopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgei5jb2xvciA9IEJMQUNLO1xyXG4gICAgfVxyXG5cclxuICAgIHN1Y2Nlc3Nvcih6KXtcclxuICAgICAgICBpZih6LnJpZ2h0Q2hpbGQgIT0gdGhpcy5uaWwpIHJldHVybiB0aGlzLm1pbih6LnJpZ2h0Q2hpbGQpO1xyXG5cclxuICAgICAgICBsZXQgeSA9IHoucGFyZW50O1xyXG5cclxuICAgICAgICB3aGlsZSh5ICE9IHRoaXMubmlsICYmIHogPT0geS5yaWdodENoaWxkKXtcclxuICAgICAgICAgICAgeiA9IHk7XHJcbiAgICAgICAgICAgIHkgPSB5LnBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIG1pbih6KXtcclxuICAgICAgICB3aGlsZSh6LmxlZnRDaGlsZCAhPSB0aGlzLm5pbCl7XHJcbiAgICAgICAgICAgIHogPSB6LmxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB6O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2ua2V55YC85Yig6Zmk57uT54K5XHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXkpe1xyXG4gICAgICAgIGxldCB6ID0gdGhpcy5maW5kKGtleSk7XHJcblxyXG4gICAgICAgIGlmKHogPT0gdGhpcy5uaWwpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTm9kZSh6KTtcclxuICAgIH1cclxufVxyXG5cclxuUmVkQmxhY2tUcmVlLnByb3RvdHlwZS5fcm90YXRlTGVmdCA9IHJvdGF0ZSgnbGVmdCcpO1xyXG5SZWRCbGFja1RyZWUucHJvdG90eXBlLl9yb3RhdGVSaWdodCA9IHJvdGF0ZSgncmlnaHQnKTtcclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZShkaXIpe1xyXG4gICAgbGV0IGMxLCBjMjtcclxuICAgIGlmKCBkaXIgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ2xlZnRDaGlsZCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAncmlnaHRDaGlsZCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIGxldCB5ID0geFtjMV07XHJcbiAgICAgICAgeFtjMV0gPSB5W2MyXTtcclxuXHJcbiAgICAgICAgaWYoeVtjMl0gIT0gdGhpcy5uaWwpIHlbYzJdLnBhcmVudCA9IHg7XHJcbiAgICAgICAgeS5wYXJlbnQgPSB4LnBhcmVudDtcclxuXHJcbiAgICAgICAgaWYoeC5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHk7XHJcbiAgICAgICAgZWxzZSBpZih4ID09IHgucGFyZW50W2MyXSkgeC5wYXJlbnRbYzJdID0geTtcclxuICAgICAgICBlbHNlIHgucGFyZW50W2MxXSA9IHk7XHJcblxyXG4gICAgICAgIHlbYzJdID0geDtcclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRGaXh1cChkaXIpe1xyXG4gICAgbGV0IGMxLCBjMiwgcm90YXRlMSwgcm90YXRlMjtcclxuICAgIGlmKCBkaXIgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ2xlZnRDaGlsZCc7XHJcbiAgICAgICAgcm90YXRlMSA9ICdfcm90YXRlTGVmdCc7XHJcbiAgICAgICAgcm90YXRlMiA9ICdfcm90YXRlUmlnaHQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjMSA9ICdsZWZ0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIHJvdGF0ZTEgPSAnX3JvdGF0ZVJpZ2h0JztcclxuICAgICAgICByb3RhdGUyID0gJ19yb3RhdGVMZWZ0JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24odHJlZSwgeil7XHJcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XHJcblxyXG4gICAgICAgIC8vIOWPlOe7k+eCuVxyXG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQucGFyZW50W2MxXTtcclxuXHJcbiAgICAgICAgLy8g5o+S5YWl5L+u5aSN5oOF5Ya1Me+8muWmguaenOW9k+WJjee7k+eCueeahOeItue7k+eCueaYr+e6ouiJsuS4lOellueItue7k+eCueeahOWPpuS4gOS4quWtkOe7k+eCue+8iOWPlOe7k+eCue+8ieaYr+e6ouiJslxyXG4gICAgICAgIC8vIOWwhuW9k+WJjeiKgueCueeahOeItuiKgueCueWSjOWPlOWPlOiKgueCuea2gum7ke+8jOellueItue7k+eCuea2gue6ou+8jOaKiuW9k+WJjee7k+eCueaMh+WQkeellueItuiKgueCue+8jOS7juaWsOeahOW9k+WJjeiKgueCuemHjeaWsOW8gOWni+eul+azleOAglxyXG4gICAgICAgIGlmKHkuY29sb3IgPT09IFJFRCkge1xyXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICB5LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHoucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgeiA9IHoucGFyZW50LnBhcmVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOWPs+WtkFxyXG4gICAgICAgICAgICAvLyDop6PlhrPlr7nnrZbmmK/vvJrlvZPliY3oioLngrnnmoTniLboioLngrnlgZrkuLrmlrDnmoTlvZPliY3oioLngrnvvIzku6XmlrDlvZPliY3oioLngrnkuLrmlK/ngrnlt6bml4vjgIJcclxuICAgICAgICAgICAgLy8g5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcclxuICAgICAgICAgICAgaWYoeiA9PT0gei5wYXJlbnRbYzFdKSB7XHJcbiAgICAgICAgICAgICAgICB6ID0gei5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0cmVlW3JvdGF0ZTFdKHopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxyXG4gICAgICAgICAgICAvLyDop6PlhrPlr7nnrZbmmK/vvJrniLboioLngrnlj5jkuLrpu5HoibLvvIznpZbniLboioLngrnlj5jkuLrnuqLoibLvvIzlnKjnpZbniLboioLngrnkuLrmlK/ngrnlj7Pml4vvvIxcclxuICAgICAgICAgICAgei5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgei5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICB0cmVlW3JvdGF0ZTJdKHoucGFyZW50LnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxubGV0IGxlZnRBZGRGaXh1cCA9IGFkZEZpeHVwKCdsZWZ0Jyk7XHJcbmxldCByaWdodEFkZEZpeHVwID0gYWRkRml4dXAoJ3JpZ2h0Jyk7XHJcbmxldCBsZWZ0UmVtb3ZlRml4dXAgPSByZW1vdmVGaXh1cCgnbGVmdCcpO1xyXG5sZXQgcmlnaHRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdyaWdodCcpO1xyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRml4dXAoZGlyKXtcclxuICAgIGxldCBjMSwgYzIsIHIxLCByMjtcclxuICAgIGlmKGRpciA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgYzEgPSAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcclxuICAgICAgICByMSA9ICdfcm90YXRlTGVmdCc7XHJcbiAgICAgICAgcjIgPSAnX3JvdGF0ZVJpZ2h0JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYzEgPSAnbGVmdENoaWxkJztcclxuICAgICAgICBjMiA9ICdyaWdodENoaWxkJztcclxuICAgICAgICByMSA9ICdfcm90YXRlUmlnaHQnO1xyXG4gICAgICAgIHIyID0gJ19yb3RhdGVMZWZ0JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24odHJlZSwgeil7XHJcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XHJcblxyXG4gICAgICAgIC8vIOWPlOe7k+eCuVxyXG4gICAgICAgIGxldCB3ID0gei5wYXJlbnRbYzFdO1xyXG5cclxuICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrUx77ya5b2T5YmN6IqC54K55piv6buRK+m7keS4lOWFhOW8n+iKgueCueS4uue6ouiJsijmraTml7bniLboioLngrnlkozlhYTlvJ/oioLngrnnmoTlrZDoioLngrnliIbkuLrpu5Ep44CCXHJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOVXHJcbiAgICAgICAgaWYody5jb2xvciA9PT0gUkVEKXtcclxuICAgICAgICAgICAgdy5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgdHJlZVtyMV0oei5wYXJlbnQpO1xyXG4gICAgICAgICAgICB3ID0gei5wYXJlbnRbYzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJsuOAglxyXG4gICAgICAgIC8vIOino+azle+8muaKiuW9k+WJjeiKgueCueWSjOWFhOW8n+iKgueCueS4reaKveWPluS4gOmHjem7keiJsui/veWKoOWIsOeItuiKgueCueS4iu+8jOaKiueItuiKgueCueW9k+aIkOaWsOeahOW9k+WJjeiKgueCue+8jOmHjeaWsOi/m+WFpeeul+azleOAglxyXG4gICAgICAgIGlmKHdbYzJdLmNvbG9yID09PSBCTEFDSyAmJiB3W2MxXS5jb2xvciA9PT0gQkxBQ0spe1xyXG4gICAgICAgICAgICB3LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICB6ID0gei5wYXJlbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueminOiJsuaYr+m7kSvpu5HvvIzlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzlhYTlvJ/nmoTlt6blrZDmmK/nuqLoibLvvIzlj7PlrZDmmK/pu5HoibLjgIJcclxuICAgICAgICAgICAgLy8g6Kej5rOV77ya5oqK5YWE5byf57uT54K55p+T57qi77yM5YWE5byf5bem5a2Q6IqC54K55p+T6buR77yM5LmL5ZCO5YaN5Zyo5YWE5byf6IqC54K55Li65pSv54K56Kej5Y+z5peL77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV44CCXHJcbiAgICAgICAgICAgIGlmKHdbYzFdLmNvbG9yID09PSBCTEFDSykge1xyXG4gICAgICAgICAgICAgICAgd1tjMl0uY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgIHcuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICB0cmVlW3IyXSh3KTtcclxuICAgICAgICAgICAgICAgIHcgPSB6LnBhcmVudFtjMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSP44CCXHJcbiAgICAgICAgICAgIC8vIOino+azle+8muaKiuWFhOW8n+iKgueCueafk+aIkOW9k+WJjeiKgueCueeItuiKgueCueeahOminOiJsu+8jOaKiuW9k+WJjeiKgueCueeItuiKgueCueafk+aIkOm7keiJsu+8jOWFhOW8n+iKgueCueWPs+WtkOafk+aIkOm7keiJsu+8jOS5i+WQjuS7peW9k+WJjeiKgueCueeahOeItuiKgueCueS4uuaUr+eCuei/m+ihjOW3puaXi++8jOatpOaXtueul+azlee7k+adn++8jOe6oum7keagkeaJgOacieaAp+i0qOiwg+aVtOato+ehrlxyXG4gICAgICAgICAgICB3LmNvbG9yID0gei5wYXJlbnQuY29sb3I7XHJcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHdbYzFdLmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHRyZWVbcjFdKHoucGFyZW50KTtcclxuICAgICAgICAgICAgeiA9IHRyZWUucm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxubGV0IHRlc3QgPSBuZXcgUmVkQmxhY2tUcmVlKCk7XHJcbnRlc3QuYWRkKDEzKTtcclxudGVzdC5hZGQoOCk7XHJcbnRlc3QuYWRkKDE3KTtcclxudGVzdC5hZGQoMSk7XHJcbnRlc3QuYWRkKDYpO1xyXG50ZXN0LmFkZCgxMSk7XHJcbnRlc3QuYWRkKDE1KTtcclxudGVzdC5hZGQoMjIpO1xyXG50ZXN0LmFkZCgyNSk7XHJcbnRlc3QuYWRkKDI3KTtcclxuXHJcbnRlc3QucmVtb3ZlKDEzKTtcclxudGVzdC5yZW1vdmUoOCk7XHJcbnRlc3QucmVtb3ZlKDE3KTtcclxudGVzdC5yZW1vdmUoMSk7XHJcbnRlc3QucmVtb3ZlKDYpO1xyXG50ZXN0LnJlbW92ZSgxMSk7XHJcbnRlc3QucmVtb3ZlKDE1KTtcclxudGVzdC5yZW1vdmUoMjIpO1xyXG50ZXN0LnJlbW92ZSgyNSk7XHJcbnRlc3QucmVtb3ZlKDI3KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL1JlZEJsYWNrVHJlZS5qc1xuICoqLyIsIi8qXHJcbiDpnZnmgIHmrKHkvJjmn6Xmib7moJFcclxuXHJcbiDpgILlkIjlkITorrDlvZXnmoTmn6Xmib7mpoLnjofkuI3nrYnnmoTmg4XlhrVcclxuXHJcbiDmn6Xmib7mlYjnjofmnIDpq5jljbPlubPlnYfmn6Xmib7plb/luqbmnIDlsI/vvIzmiJHku6zlj6/ku6Xnu5nlh7rmnInluo/ooajlnKjpnZ7nrYnmpoLnjofmg4XlhrXkuIvlupTpgbXlvqrnmoTkuKTkuKrljp/liJnvvJpcclxuIDHjgIHmnIDlhYjorr/pl67nmoTnu5PngrnlupTmmK/orr/pl67mpoLnjofmnIDlpKfnmoTnu5PngrnvvJtcclxuIDLjgIHmr4/mrKHorr/pl67lupTkvb/nu5PngrnkuKTovrnlsJrmnKrorr/pl67nmoTnu5PngrnnmoTooqvorr/mpoLnjofkuYvlkozlsL3lj6/og73nm7jnrYnjgIJcclxuXHJcblxyXG4g6L+Z5Lik5Liq5Y6f5YiZ5Y+v55So5LiA5Y+l6K+d5p2l6KGo56S677yM5Y2z5Yik5a6a5qCR5Li65bim5p2D5YaF6Lev5b6E6ZW/5bqm5LmL5ZKM5pyA5bCP55qE5LqM5Y+J5qCR77yM5Lqm5Y2z77yaUEggPSDiiJF3aWhpICDmnIDlsI/vvIzlhbbkuK0gbiDkuLrmnInluo/ooajplb/luqbvvIxoaSDkuLrnrKwgaSDkuKrnu5PngrnlnKjliKTlrprmoJHkuIrnmoTlsYLmrKHmlbDvvIx3aSA9IGNwae+8jGMg5Li65p+Q5Liq5bi45pWw77yMcGkg5Li656ysIGkg5Liq57uT54K555qE5p+l5om+5qaC546H44CCXHJcblxyXG5cclxuIOi/meagt+eahOagkeensOS4uumdmeaAgeacgOS8mOafpeaJvuagke+8iHN0YXRpYyBvcHRpbWFsIHNlYXJjaCB0cmVl77yJ77yM5p6E6YCg6L+Z5qC35LiA5qO15qCR55qE5pe26Ze05Luj5Lu35aSq5aSn77yM5Lqm5Y2z5pe26Ze05aSN5p2C5bqm5b6I5aSn77yM5Zug5q2k5oiR5Lus6YCa5bi45piv5p6E6YCg5qyh5LyY5p+l5om+5qCR77yIbmVhcmx5IG9wdGltYWwgc2VhcmNoIHRyZWXvvInvvIzmnoTpgKDlroPnmoTml7bpl7Tku6Pku7fov5zov5zkvY7kuo7mnoTpgKDmnIDkvJjmn6Xmib7moJHvvIzkvYbmn6Xmib7mgKfog73lj6rmr5TmnIDkvJjmn6Xmib7moJHlt64xJX4yJe+8jOW+iOWwkeW3rjMl5Lul5LiK44CCXHJcblxyXG4g5qyh5LyY5p+l5om+5qCR55qE5p6E6YCg77yaXHJcblxyXG4g6K6+5pyJ5bqP6KGo5q+P5Liq6K6w5b2V55qE5p2D5YC85Li6IHdsLHdsKzEs4oCmLHdo77yM56ys5LiA5Liq5bqU6K6/6Zeu55qE57uT54K55Y+35Li6IGkg77yM5YiZ5pyJ77yaXHJcbiDOlHBpID0gICDiiJF3aiAtIOKIkXdqICAg5pyA5bCP77yM5Y2zIM6UcGkgPSBNaW4ge86UcGogfVxyXG4g5YaN5YiG5Yir5a+5IHtybCxybCsxLOKApixyaS0xfSDlkowge3JpKzEscmkrMizigKYscmh9IOWIhuWIq+aehOmAoOasoeS8mOafpeaJvuagkVxyXG4gKi9cclxuaW1wb3J0IHsgQmluYXJ5VHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XHJcblxyXG4vKipcclxuICog55Sx5pyJ5bqP6KGoc1RhYmxlW2xvdy4uaGlnaF3lj4rlhbbntK/orqHmnYPlgLzooah3ZWlnaHRz6YCS5b2S5p6E6YCg5qyh5LyY5p+l5om+5qCRXHJcbiAqIEBwYXJhbSB7QmluYXJ5VHJlZX0gdHJlZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzVGFibGVcclxuICogQHBhcmFtIHtBcnJheX0gc1dlaWdodHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xyXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxyXG4gKi9cclxuZnVuY3Rpb24gc2Vjb25kT3B0aW1hbCh0cmVlLCBzVGFibGUsIHNXZWlnaHRzLCBsb3csIGhpZ2gpIHtcclxuICAgIGxldCBpID0gbG93O1xyXG4gICAgbGV0IG1pbiA9IE1hdGguYWJzKHNXZWlnaHRzW2hpZ2hdIC0gc1dlaWdodHNbbG93XSk7XHJcbiAgICBsZXQgZHcgPSBzV2VpZ2h0c1toaWdoXSArIChzV2VpZ2h0c1tsb3cgLSAxXSB8fCAwKTtcclxuXHJcbiAgICAvLyDpgInmi6nmnIDlsI/nmoTilrNQaeWAvFxyXG4gICAgZm9yIChsZXQgaiA9IGxvdyArIDE7IGogPD0gaGlnaDsgKytqKSB7XHJcbiAgICAgICAgbGV0IHQgPSBNYXRoLmFicyhkdyAtIHNXZWlnaHRzW2pdIC0gc1dlaWdodHNbaiAtIDFdKTtcclxuICAgICAgICBpZiAodCA8IG1pbikge1xyXG4gICAgICAgICAgICBpID0gajtcclxuICAgICAgICAgICAgbWluID0gdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6LCD5pW05qCR5qC55p2D77yM6YCJ5oup6YK76L+R5p2D5YC86L6D5aSn55qE5YWz6ZSu5a2XXHJcbiAgICBsZXQgYSA9IDAsIGIsIGMgPSAwO1xyXG4gICAgaWYgKGkgLSAxID49IGxvdykgIGIgPSBzV2VpZ2h0c1tpXSAtIHNXZWlnaHRzW2kgLSAxXTtcclxuICAgIGlmIChpIC0gMiA+PSBsb3cpIGEgPSBzV2VpZ2h0c1tpIC0gMV0gLSBzV2VpZ2h0c1tpIC0gMl07XHJcbiAgICBpZiAoaSArIDEgPCBoaWdoKSBjID0gc1dlaWdodHNbaSArIDFdIC0gc1dlaWdodHNbaV07XHJcbiAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaWYgKGEgPiBjICYmIGEgPiBiKSAtLWk7XHJcbiAgICAgICAgZWxzZSBpZiAoYSA8IGMgJiYgYyA+IGIpICArK2k7XHJcbiAgICB9XHJcblxyXG4gICAgdHJlZS5kYXRhID0gc1RhYmxlW2ldO1xyXG4gICAgLy/lt6blrZDmoJFcclxuICAgIGlmIChpID09PSBsb3cpIHRyZWUubGVmdENoaWxkID0gbnVsbDtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRyZWUubGVmdENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcclxuICAgICAgICBzZWNvbmRPcHRpbWFsKHRyZWUubGVmdENoaWxkLCBzVGFibGUsIHNXZWlnaHRzLCBsb3csIGkgLSAxKTtcclxuICAgIH1cclxuICAgIC8vIOWPs+WtkOagkVxyXG4gICAgaWYgKGkgPT09IGhpZ2gpIHRyZWUucmlnaHRDaGlsZCA9IG51bGw7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cmVlLnJpZ2h0Q2hpbGQgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgIHNlY29uZE9wdGltYWwodHJlZS5yaWdodENoaWxkLCBzVGFibGUsIHNXZWlnaHRzLCBpICsgMSwgaGlnaCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCB0cmVlID0gbmV3IEJpbmFyeVRyZWUoKTtcclxuc2Vjb25kT3B0aW1hbCh0cmVlLCBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJ10sIFsxLCAyLCA0LCA5LCAxMiwgMTYsIDIwLCAyMywgMjhdLCAwLCA4KTtcclxuY29uc29sZS5sb2codHJlZSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIOeUseacieW6j+ihqOaehOmAoOS4gOajteasoeS8mOafpeaJvuagkVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIOacieW6j+ihqO+8jOaVsOaNruWFg+e0oOWQq+acieadg+Wfn3dlaWdodFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU09TVHJlZShvYmopIHtcclxuICAgIGxldCB0cmVlO1xyXG4gICAgaWYgKG9iai5lbGVtcy5sZW5ndGggPT09IDApIHRyZWUgPSBudWxsO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8g5rGC57Sv6K6h5p2D5YC86KGoXHJcbiAgICAgICAgbGV0IHN3ID0gZmluZFNXKG9iai53ZWlnaHRzKTtcclxuICAgICAgICB0cmVlID0gbmV3IEJpbmFyeVRyZWUoKTtcclxuICAgICAgICBzZWNvbmRPcHRpbWFsKHRyZWUsIG9iai5lbGVtcywgc3csIDAsIG9iai5lbGVtcy5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJlZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFNXKHNUYWJsZSkge1xyXG4gICAgbGV0IHN3ID0gW3NUYWJsZVswXV07XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzVGFibGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBzd1tpXSA9IHN3W2kgLSAxXSArIHNUYWJsZVtpXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3c7XHJcbn1cclxuXHJcbmxldCBzb3NUcmVlID0gY3JlYXRlU09TVHJlZSh7XHJcbiAgICBlbGVtczogWydBJywgJ0InLCAnQycsICdEJywgJ0UnXSxcclxuICAgIHdlaWdodHM6IFsxLCAzMCwgMiwgMjksIDNdXHJcbn0pO1xyXG5zb3NUcmVlLmluT3JkZXJSZWN1cnNpdmUoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBjb25zb2xlLmxvZygnaW5PcmRlcjogJyArIHZhbHVlKTtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9TT1NUcmVlLmpzXG4gKiovIiwiLypcclxuIEZpYm9uYWNjaeafpeaJvlxyXG5cclxuIEZpYm9uYWNjaeafpeaJvuaWueazleaYr+agueaNrkZpYm9uYWNjaeaVsOWIl+eahOeJueeCueWvueafpeaJvuihqOi/m+ihjOWIhuWJsuOAgkZpYm9uYWNjaeaVsOWIl+eahOWumuS5ieaYr++8mlxyXG4gRigwKT0w77yMRigxKT0x77yMRihqKT1GKGotMSkrRihqLTIpIOOAglxyXG5cclxuIDEgIOafpeaJvuaAneaDs1xyXG4g6K6+5p+l5om+6KGo5Lit55qE6K6w5b2V5pWw5q+U5p+Q5LiqRmlib25hY2Np5pWw5bCPMe+8jOWNs+iuvm49RihqKS0x44CC55SoTG9344CBSGlnaOWSjE1pZOihqOekuuW+heafpeaJvuWMuumXtOeahOS4i+eVjOOAgeS4iueVjOWSjOWIhuWJsuS9jee9ru+8jOWIneWAvOS4ukxvdz0w77yMSGlnaD1uIC0gMeOAglxyXG4g4pG0ICAg5Y+W5YiG5Ymy5L2N572uTWlk77yaTWlkPUYoai0xKSDvvJtcclxuIOKRtSAgIOavlOi+g+WIhuWJsuS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcclxuIOKRoCDnm7jnrYnvvJog5p+l5om+5oiQ5Yqf77ybXHJcbiDikaEgIOWkp+S6ju+8muW+heafpeiusOW9leWcqOWMuumXtOeahOWJjeWNiuautSjljLrpl7Tplb/luqbkuLpGKGotMSktMSnvvIzkv67mlLnkuIrnlYzmjIfpkojvvJogSGlnaD1NaWQtMe+8jOi9rOKRtCDvvJtcclxuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q61KOWMuumXtOmVv+W6puS4ukYoai0yKS0xKe+8jOS/ruaUueS4i+eVjOaMh+mSiO+8mkxvdz1NaWQrMe+8jOi9rOKRtCDvvJvnm7TliLDotornlYwoTG93PkhpZ2gp77yM5p+l5om+5aSx6LSl44CCXHJcblxyXG4gMiAg566X5rOV5a6e546wXHJcbiDlnKjnrpfms5Xlrp7njrDml7bvvIzkuLrkuobpgb/lhY3popHnuYHorqHnrpdGaWJvbmFjY2nmlbDvvIzlj6/nlKjkuKTkuKrlj5jph49mMeWSjGYy5L+d5a2Y5b2T5YmN55u46YK755qE5Lik5LiqRmlib25hY2Np5pWw77yM6L+Z5qC35Zyo5Lul5ZCO55qE6K6h566X5Lit5Y+v5Lul5L6d5qyh6YCS5o6o6K6h566X5Ye644CCXHJcblxyXG4gMyAg566X5rOV5YiG5p6QXHJcbiDnlLHnrpfms5Xnn6XvvIxGaWJvbmFjY2nmn6Xmib7lnKjmnIDlnY/mg4XlhrXkuIvmgKfog73mr5TmipjljYrmn6Xmib7lt67vvIzkvYblubPlnYfmkJzntKLmrKHmlbDlsJHkuo7mipjljYrmn6Xmib7vvIzogIzkuJTmipjljYrmn6Xmib7opoHmsYLorrDlvZXmjInlhbPplK7lrZfmnInluo/vvJtGaWJvbmFjY2nmn6Xmib7nmoTkvJjngrnmmK/liIblibLml7blj6rpnIDov5vooYzliqDjgIHlh4/ov5DnrpfjgIJcclxuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZmliKG4pIHtcclxuICAgIGlmIChuID09PSAwKSByZXR1cm4gMDtcclxuICAgIGlmIChuID09PSAxKSByZXR1cm4gMTtcclxuICAgIGxldCBmO1xyXG4gICAgbGV0IGYwID0gMDtcclxuICAgIGxldCBmMSA9IDE7XHJcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8PSBuOyArK2kpIHtcclxuICAgICAgICBmID0gZjAgKyBmMTtcclxuICAgICAgICBmMCA9IGYxO1xyXG4gICAgICAgIGYxID0gZjtcclxuICAgIH1cclxuICAgIHJldHVybiBmO1xyXG59XHJcblxyXG4vKipcclxuICog5Zyo5pyJ5bqP6KGoU1TkuK3nlKhGaWJvbmFjY2nmlrnms5Xmn6Xmib7lhbPplK7lrZfkuLprZXnnmoTorrDlvZVcclxuICogQHBhcmFtIHNUYWJsZVxyXG4gKiBAcGFyYW0ga2V5XHJcbiAqIEBwYXJhbSBuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWJvbmFjY2lTZWFyY2goc1RhYmxlLCBrZXksIG4gPSBzVGFibGUubGVuZ3RoKSB7XHJcbiAgICBsZXQgbG93ID0gMDtcclxuICAgIGxldCBoaWdoID0gbiAtIDE7XHJcbiAgICBsZXQgZjEgPSBmaWIobik7XHJcbiAgICBsZXQgZjIgPSBmaWIobiAtIDEpO1xyXG5cclxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xyXG4gICAgICAgIGxldCBtaWQgPSBsb3cgKyBmMSAtIDE7XHJcbiAgICAgICAgaWYgKHNUYWJsZVttaWRdID09PSBrZXkpIHJldHVybiBtaWQ7XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5IDwgc1RhYmxlW21pZF0pIHtcclxuICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgICAgIGYyID0gZjEgLSBmMjtcclxuICAgICAgICAgICAgZjEgPSBmMSAtIGYyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIGYxID0gZjEgLSBmMjtcclxuICAgICAgICAgICAgZjIgPSBmMiAtIGYxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5cclxuY29uc29sZS5sb2coJ2ZpYm9uYWNjaVNlYXJjaDogJyk7XHJcbmNvbnNvbGUubG9nKGZpYm9uYWNjaVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDUpKTsgLy8gNFxyXG5jb25zb2xlLmxvZyhmaWJvbmFjY2lTZWFyY2goWzEsIDIsIDMsIDQsIDVdLCA2KSk7IC8vIC0xXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9maWJvbmFjY2lTZWFyY2guanNcbiAqKi8iLCIvKlxyXG4g6Z2Z5oCB5p+l5om+XHJcblxyXG4g57q/5oCn6KGo5piv5p+l5om+6KGo5pyA566A5Y2V55qE5LiA56eN57uE57uH5pa55byPXHJcblxyXG4g6aG65bqP5p+l5om+KFNlcXVlbnRpYWwgU2VhcmNoKVxyXG4gMSAg5p+l5om+5oCd5oOzXHJcbiDku47ooajnmoTkuIDnq6/lvIDlp4vpgJDkuKrlsIborrDlvZXnmoTlhbPplK7lrZflkoznu5nlrppL5YC86L+b6KGM5q+U6L6D77yM6Iul5p+Q5Liq6K6w5b2V55qE5YWz6ZSu5a2X5ZKM57uZ5a6aS+WAvOebuOetie+8jOafpeaJvuaIkOWKn++8m+WQpuWIme+8jOiLpeaJq+aPj+WujOaVtOS4quihqO+8jOS7jeeEtuayoeacieaJvuWIsOebuOW6lOeahOiusOW9le+8jOWImeafpeaJvuWksei0peOAglxyXG5cclxuIDIgIOeul+azleWIhuaekFxyXG4g5LiN5aSx5LiA6Iis5oCn77yM6K6+5p+l5om+5q+P5Liq6K6w5b2V5oiQ5Yqf55qE5qaC546H55u4562J77yM5Y2zUGk9MS9u77yb5p+l5om+56ysaeS4quWFg+e0oOaIkOWKn+eahOavlOi+g+asoeaVsENpPW4tae+8m1xyXG4g4peGIOafpeaJvuaIkOWKn+aXtueahOW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mihuKzEpLzJcclxuIOKXhiDljIXlkKvmn6Xmib7kuI3miJDlip/ml7bvvJrmn6Xmib7lpLHotKXnmoTmr5TovoPmrKHmlbDkuLpu77yM6Iul5oiQ5Yqf5LiO5LiN5oiQ5Yqf55qE5qaC546H55u4562J77yM5a+55q+P5Liq6K6w5b2V55qE5p+l5om+5qaC546H5Li6UGk9MS8oMm4p77yM5YiZ5bmz5Z2H5p+l5om+6ZW/5bqmQVNM77yaM++8iG4rMe+8iS80XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2VxdWVudGlhbFNlYXJjaChzVGFibGUsIGtleSkge1xyXG4gICAgZm9yICh2YXIgaSA9IHNUYWJsZS5sZW5ndGggLSAxOyBpID49IDAgJiYgc1RhYmxlW2ldICE9PSBrZXk7IC0taSk7XHJcbiAgICByZXR1cm4gaTtcclxufVxyXG5cclxuY29uc29sZS5sb2coc2VxdWVudGlhbFNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDYpKTsgIC8vIC0xXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoLmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMi8xOC5cclxuICovXHJcblxyXG4vKlxyXG4g6K6h5pWw5o6S5bqPXHJcblxyXG4g6K6h5pWw5o6S5bqP77yIQ291bnRpbmcgc29ydO+8ieaYr+S4gOenjeeos+WumueahOe6v+aAp+aXtumXtOaOkuW6j+eul+azleOAguiuoeaVsOaOkuW6j+S9v+eUqOS4gOS4qumineWklueahOaVsOe7hEPvvIzlhbbkuK3nrKxp5Liq5YWD57Sg5piv5b6F5o6S5bqP5pWw57uEQeS4reWAvOetieS6jmnnmoTlhYPntKDnmoTkuKrmlbDjgILnhLblkI7moLnmja7mlbDnu4RD5p2l5bCGQeS4reeahOWFg+e0oOaOkuWIsOato+ehrueahOS9jee9ruOAglxyXG5cclxuIOiuoeaVsOaOkuW6j+eahOeJueW+gVxyXG5cclxuIOW9k+i+k+WFpeeahOWFg+e0oOaYr27kuKow5Yiwa+S5i+mXtOeahOaVtOaVsOaXtu+8jOWug+eahOi/kOihjOaXtumXtOaYr86YKG4gKyBrKeOAguiuoeaVsOaOkuW6j+S4jeaYr+avlOi+g+aOkuW6j++8jOaOkuW6j+eahOmAn+W6puW/q+S6juS7u+S9leavlOi+g+aOkuW6j+eul+azleOAglxyXG4g55Sx5LqO55So5p2l6K6h5pWw55qE5pWw57uEQ+eahOmVv+W6puWPluWGs+S6juW+heaOkuW6j+aVsOe7hOS4reaVsOaNrueahOiMg+WbtO+8iOetieS6juW+heaOkuW6j+aVsOe7hOeahOacgOWkp+WAvOS4juacgOWwj+WAvOeahOW3ruWKoOS4ijHvvInvvIzov5nkvb/lvpforqHmlbDmjpLluo/lr7nkuo7mlbDmja7ojIPlm7TlvojlpKfnmoTmlbDnu4TvvIzpnIDopoHlpKfph4/ml7bpl7TlkozlhoXlrZjjgILkvovlpoLvvJrorqHmlbDmjpLluo/mmK/nlKjmnaXmjpLluo8w5YiwMTAw5LmL6Ze055qE5pWw5a2X55qE5pyA5aW955qE566X5rOV77yM5L2G5piv5a6D5LiN6YCC5ZCI5oyJ5a2X5q+N6aG65bqP5o6S5bqP5Lq65ZCN44CC5L2G5piv77yM6K6h5pWw5o6S5bqP5Y+v5Lul55So5Zyo5Z+65pWw5o6S5bqP5Lit55qE566X5rOV5p2l5o6S5bqP5pWw5o2u6IyD5Zu05b6I5aSn55qE5pWw57uE44CCXHJcbiDpgJrkv5flnLDnkIbop6PvvIzkvovlpoLmnIkxMOS4quW5tOm+hOS4jeWQjOeahOS6uu+8jOe7n+iuoeWHuuaciTjkuKrkurrnmoTlubTpvoTmr5RB5bCP77yM6YKjQeeahOW5tOm+hOWwseaOkuWcqOesrDnkvY3vvIznlKjov5nkuKrmlrnms5Xlj6/ku6XlvpfliLDlhbbku5bmr4/kuKrkurrnmoTkvY3nva7vvIzkuZ/lsLHmjpLlpb3kuobluo/jgILlvZPnhLbvvIzlubTpvoTmnInph43lpI3ml7bpnIDopoHnibnmrorlpITnkIbvvIjkv53or4HnqLPlrprmgKfvvInvvIzov5nlsLHmmK/kuLrku4DkuYjmnIDlkI7opoHlj43lkJHloavlhYXnm67moIfmlbDnu4TvvIzku6Xlj4rlsIbmr4/kuKrmlbDlrZfnmoTnu5/orqHlh4/ljrsx55qE5Y6f5Zug44CC566X5rOV55qE5q2l6aqk5aaC5LiL77yaXHJcbiAxLuaJvuWHuuW+heaOkuW6j+eahOaVsOe7hOS4reacgOWkp+WSjOacgOWwj+eahOWFg+e0oFxyXG4gMi7nu5/orqHmlbDnu4TkuK3mr4/kuKrlgLzkuLpp55qE5YWD57Sg5Ye6546w55qE5qyh5pWw77yM5a2Y5YWl5pWw57uEQ+eahOesrGnpoblcclxuIDMu5a+55omA5pyJ55qE6K6h5pWw57Sv5Yqg77yI5LuOQ+S4reeahOesrOS4gOS4quWFg+e0oOW8gOWni++8jOavj+S4gOmhueWSjOWJjeS4gOmhueebuOWKoO+8iVxyXG4gNC7lj43lkJHloavlhYXnm67moIfmlbDnu4TvvJrlsIbmr4/kuKrlhYPntKBp5pS+5Zyo5paw5pWw57uE55qE56ysQyhpKemhue+8jOavj+aUvuS4gOS4quWFg+e0oOWwseWwhkMoaSnlh4/ljrsxXHJcbiBcclxuIOeugOimgeWIhuaekO+8mlxyXG4gMS7orqHmlbDmjpLluo/ku4XpgILlkIjkuo7lsI/ojIPlm7TnmoTmlbDmja7ov5vooYzmjpLluo9cclxuIDIu5LiN6IO95a+55rWu54K55pWw6L+b6KGM5o6S5bqPXHJcbiAzLuaXtumXtOWkjeadguW6puS4uiBPKG4pXHJcbiA0LuiuoeaVsOaOkuW6j+aYr+eos+WumueahO+8iOaOkuW6j+WQjuWAvOebuOWQjOeahOWFg+e0oOebuOWvueS6juWOn+WFiOeahOS9jee9ruaYr+S4jeS8muWPkeeUn+WPmOWMlueahO+8iVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1heEVsZW0oYXJyKXtcclxuICAgIHZhciBtYXggPSBhcnJbMF07XHJcblxyXG4gICAgZm9yKHZhciBpID0gMSwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKVxyXG4gICAgICAgIGlmKG1heCA8IGFycltpXSkgbWF4ID0gYXJyW2ldO1xyXG5cclxuICAgIHJldHVybiBtYXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcUxpc3Qg6KaB5o6S5bqP55qE5pWw57uEXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBrIOaVsOe7hOS4reacgOWkp+eahOWFg+e0oOWAvFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBjb3VudFNvcnQoc3FMaXN0LCBrKXtcclxuICAgIGlmKGsgPT0gbnVsbCkgayA9IG1heEVsZW0oc3FMaXN0KTtcclxuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xyXG4gICAgdmFyIGMgPSBbXTtcclxuICAgIHZhciBiID0gW107XHJcblxyXG4gICAgLy8g5Yid5aeL5YyW6L6F5Yqp5pWw57uEXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDw9IGs7ICsraSkgY1tpXSA9IDA7XHJcbiAgICAvLyDorqHmlbDmlbDnu4RB5Lit5YC8562J5LqOQ+aVsOe7hOS4i+agh+eahOS4quaVsFxyXG4gICAgZm9yKGkgPSAwOyBpIDwgbGVuOyArK2kpIGNbc3FMaXN0W2ldXSsrO1xyXG4gICAgLy8g6K6h5pWw5pWw57uEQeS4reWAvOWwj+S6juetieS6jkPmlbDnu4TkuIvmoIfnmoTkuKrmlbBcclxuICAgIGZvcihpID0gMTsgaSA8PSBrOyArK2kpIGNbaV0gKz0gY1tpIC0gMV07XHJcbiAgICBmb3IoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgYltjW3NxTGlzdFtpXV0gLSAxXSA9IHNxTGlzdFtpXTtcclxuICAgICAgICAtLWNbc3FMaXN0W2ldXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW47ICsraSkgc3FMaXN0W2ldID0gYltpXTtcclxufVxyXG5leHBvcnRzLmNvdW50U29ydCA9IGNvdW50U29ydDtcclxuXHJcbnZhciBhcnIgPSBbMTAwLCA5MywgOTcsIDkyLCA5NiwgOTksIDkyLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLCA5NV07XHJcbmNvdW50U29ydChhcnIsIDEwMCk7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vKlxyXG4g5Z+65pWw5o6S5bqPXHJcblxyXG4g5Z+65pWw5o6S5bqP77yI6Iux6K+t77yaUmFkaXggc29ydO+8ieaYr+S4gOenjemdnuavlOi+g+Wei+aVtOaVsOaOkuW6j+eul+azle+8jOWFtuWOn+eQhuaYr+WwhuaVtOaVsOaMieS9jeaVsOWIh+WJsuaIkOS4jeWQjOeahOaVsOWtl++8jOeEtuWQjuaMieavj+S4quS9jeaVsOWIhuWIq+avlOi+g+OAgueUseS6juaVtOaVsOS5n+WPr+S7peihqOi+vuWtl+espuS4su+8iOavlOWmguWQjeWtl+aIluaXpeacn++8ieWSjOeJueWumuagvOW8j+eahOa1rueCueaVsO+8jOaJgOS7peWfuuaVsOaOkuW6j+S5n+S4jeaYr+WPquiDveS9v+eUqOS6juaVtOaVsOOAguWfuuaVsOaOkuW6j+eahOWPkeaYjuWPr+S7pei/vea6r+WIsDE4ODflubTotavlsJTmm7zCt+S9leS5kOekvOWcqOaJk+WtlOWNoeeJh+WItuihqOacuu+8iFRhYnVsYXRpb24gTWFjaGluZe+8ieS4iueahOi0oeeMruOAglxyXG4g5a6D5piv6L+Z5qC35a6e546w55qE77ya5bCG5omA5pyJ5b6F5q+U6L6D5pWw5YC877yI5q2j5pW05pWw77yJ57uf5LiA5Li65ZCM5qC355qE5pWw5L2N6ZW/5bqm77yM5pWw5L2N6L6D55+t55qE5pWw5YmN6Z2i6KGl6Zu244CC54S25ZCO77yM5LuO5pyA5L2O5L2N5byA5aeL77yM5L6d5qyh6L+b6KGM5LiA5qyh5o6S5bqP44CC6L+Z5qC35LuO5pyA5L2O5L2N5o6S5bqP5LiA55u05Yiw5pyA6auY5L2N5o6S5bqP5a6M5oiQ5Lul5ZCO77yM5pWw5YiX5bCx5Y+Y5oiQ5LiA5Liq5pyJ5bqP5bqP5YiX44CCXHJcbiDln7rmlbDmjpLluo/nmoTmlrnlvI/lj6/ku6Xph4fnlKhMU0TvvIhMZWFzdCBzaWduaWZpY2FudCBkaWdpdGFs77yJ5oiWTVNE77yITW9zdCBzaWduaWZpY2FudCBkaWdpdGFs77yJ77yMTFNE55qE5o6S5bqP5pa55byP55Sx6ZSu5YC855qE5pyA5Y+z6L655byA5aeL77yM6ICMTVNE5YiZ55u45Y+N77yM55Sx6ZSu5YC855qE5pyA5bem6L655byA5aeL44CCXHJcblxyXG4g5pWI546HXHJcblxyXG4g5Z+65pWw5o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5pivTyhrwrduKe+8jOWFtuS4rW7mmK/mjpLluo/lhYPntKDkuKrmlbDvvIxr5piv5pWw5a2X5L2N5pWw44CC5rOo5oSP6L+Z5LiN5piv6K+06L+Z5Liq5pe26Ze05aSN5p2C5bqm5LiA5a6a5LyY5LqOTyhuwrdsb2cobikp77yMa+eahOWkp+Wwj+WPluWGs+S6juaVsOWtl+S9jeeahOmAieaLqe+8iOavlOWmguavlOeJueS9jeaVsO+8ie+8jOWSjOW+heaOkuW6j+aVsOaNruaJgOWxnuaVsOaNruexu+Wei+eahOWFqOmbhueahOWkp+Wwj++8m2vlhrPlrprkuobov5vooYzlpJrlsJHova7lpITnkIbvvIzogIxu5piv5q+P6L2u5aSE55CG55qE5pON5L2c5pWw55uu44CCXHJcbiDku6XmjpLluo9u5Liq5LiN5ZCM5pW05pWw5p2l5Li+5L6L77yM5YGH5a6a6L+Z5Lqb5pW05pWw5LulQuS4uuW6le+8jOi/meagt+avj+S9jeaVsOmDveaciULkuKrkuI3lkIznmoTmlbDlrZfvvIxrID0gbG9nQihOKe+8jE7mmK/lvoXmjpLluo/mlbDmja7nsbvlnovlhajpm4bnmoTlir/jgILomb3nhLbmnIlC5Liq5LiN5ZCM55qE5pWw5a2X77yM6ZyA6KaBQuS4quS4jeWQjOeahOahtu+8jOS9huWcqOavj+S4gOi9ruWkhOeQhuS4re+8jOWIpOaWreavj+S4quW+heaOkuW6j+aVsOaNrumhueWPqumcgOimgeS4gOasoeiuoeeul+ehruWumuWvueW6lOaVsOS9jeeahOWAvO+8jOWboOatpOWcqOavj+S4gOi9ruWkhOeQhueahOaXtuWAmemDvemcgOimgeW5s+Wdh27mrKHmk43kvZzmnaXmiormlbTmlbDmlL7liLDlkIjpgILnmoTmobbkuK3ljrvvvIzmiYDku6XlsLHmnInvvJpcclxuIGvnuqbnrYnkuo5sb2dCKE4pXHJcbiDmiYDku6XvvIzln7rmlbDmjpLluo/nmoTlubPlnYfml7bpl7RU5bCx5piv77yaXHJcbiBU772ePSBsb2dCKE4pwrduXHJcbiDlhbbkuK3liY3kuIDpobnmmK/kuIDkuKrkuI7ovpPlhaXmlbDmja7ml6DlhbPnmoTluLjmlbDvvIzlvZPnhLbor6XpobnkuI3kuIDlrprlsI/kuo5sb2duXHJcbiDlpoLmnpzogIPomZHlkozmr5TovoPmjpLluo/ov5vooYzlr7nnhafvvIzln7rmlbDmjpLluo/nmoTlvaLlvI/lpI3mnYLluqbomb3nhLbkuI3kuIDlrprmm7TlsI/vvIzkvYbnlLHkuo7kuI3ov5vooYzmr5TovoPvvIzlm6DmraTlhbbln7rmnKzmk43kvZznmoTku6Pku7fovoPlsI/vvIzogIzkuJTlnKjpgILlvZPpgInmi6nnmoRC5LmL5LiL77yMa+S4gOiIrOS4jeWkp+S6jmxvZ27vvIzmiYDku6Xln7rmlbDmjpLluo/kuIDoiKzopoHlv6vov4fln7rkuo7mr5TovoPnmoTmjpLluo/vvIzmr5TlpoLlv6vpgJ/mjpLluo/jgIJcclxuXHJcbiDlgYforr7miJHku6zmnInkuIDkupvkuozlhYPnu4QoYSxiKe+8jOimgeWvueWug+S7rOi/m+ihjOS7pWHkuLrpppbopoHlhbPplK7lrZfvvIxi55qE5qyh6KaB5YWz6ZSu5a2X55qE5o6S5bqP44CC5oiR5Lus5Y+v5Lul5YWI5oqK5a6D5Lus5YWI5oyJ54Wn6aaW6KaB5YWz6ZSu5a2X5o6S5bqP77yM5YiG5oiQ6aaW6KaB5YWz6ZSu5a2X55u45ZCM55qE6Iul5bmy5aCG44CC54S25ZCO77yM5Zyo5oyJ54Wn5qyh6KaB5YWz6ZSu5YC85YiG5Yir5a+55q+P5LiA5aCG6L+b6KGM5Y2V54us5o6S5bqP44CC5pyA5ZCO5YaN5oqK6L+Z5Lqb5aCG5Liy6L+e5Yiw5LiA6LW377yM5L2/6aaW6KaB5YWz6ZSu5a2X6L6D5bCP55qE5LiA5aCG5o6S5Zyo5LiK6Z2i44CC5oyJ6L+Z56eN5pa55byP55qE5Z+65pWw5o6S5bqP56ew5Li6TVNEKE1vc3QgU2lnbmlmaWNhbnQgRGlnaHQp5o6S5bqP44CC56ys5LqM56eN5pa55byP5piv5LuO5pyA5L2O5pyJ5pWI5YWz6ZSu5a2X5byA5aeL5o6S5bqP77yM56ew5Li6TFNEKExlYXN0IFNpZ25pZmljYW50IERpZ2h0KeaOkuW6j+OAgummluWFiOWvueaJgOacieeahOaVsOaNruaMieeFp+asoeimgeWFs+mUruWtl+aOkuW6j++8jOeEtuWQjuWvueaJgOacieeahOaVsOaNruaMieeFp+mmluimgeWFs+mUruWtl+aOkuW6j+OAguimgeazqOaEj+eahOaYr++8jOS9v+eUqOeahOaOkuW6j+eul+azleW/hemhu+aYr+eos+WumueahO+8jOWQpuWImeWwseS8muWPlua2iOWJjeS4gOasoeaOkuW6j+eahOe7k+aenOOAgueUseS6juS4jemcgOimgeWIhuWghuWvueavj+WghuWNleeLrOaOkuW6j++8jExTROaWueazleW+gOW+gOavlE1TROeugOWNleiAjOW8gOmUgOWwj+OAguS4i+aWh+S7i+e7jeeahOaWueazleWFqOmDqOaYr+WfuuS6jkxTROeahOOAglxyXG5cclxuIOWfuuaVsOaOkuW6j+eahOeugOWNleaPj+i/sOWwseaYr+WwhuaVsOWtl+aLhuWIhuS4uuS4quS9jeWNgeS9jeeZvuS9je+8jOavj+S4quS9jeS+neasoeaOkuW6j+OAguWboOS4uui/meWvueeul+azleeos+WumuimgeaxgumrmO+8jOaJgOS7peaIkeS7rOWvueaVsOS9jeaOkuW6j+eUqOWIsOS4iuS4gOS4quaOkuW6j+aWueazleiuoeaVsOaOkuW6j+OAguWboOS4uuWfuuaVsOaOkuW6j+imgee7j+i/h2QgKOaVsOaNrumVv+W6pinmrKHmjpLluo/vvIwg5q+P5qyh5L2/55So6K6h5pWw5o6S5bqP77yMIOiuoeaVsOaOkuW6j+eahOWkjeadguW6puS4uiBPbiksICBkIOebuOW9k+S6juW4uOmHj+WSjE7ml6DlhbPvvIzmiYDku6Xln7rmlbDmjpLluo/kuZ/mmK8gTyhuKeOAguWfuuaVsOaOkuW6j+iZveeEtuaYr+e6v+aAp+WkjeadguW6pu+8jCDljbPlr7lu5Liq5pWw5a2X5aSE55CG5LqGbuasoe+8jOS9huaYr+avj+S4gOasoeS7o+S7t+mDveavlOi+g+mrmO+8jCDogIzkuJTkvb/nlKjorqHmlbDmjpLluo/nmoTln7rmlbDmjpLluo/kuI3og73ov5vooYzljp/lnLDmjpLluo/vvIzpnIDopoHmm7TlpJrnmoTlhoXlrZjvvIwg5bm25LiU5b+r6YCf5o6S5bqP5Y+v6IO95pu05aW95Zyw5Yip55So56Gs5Lu255qE57yT5a2Y77yMIOaJgOS7peavlOi+g+i1t+adpe+8jOWDj+W/q+mAn+aOkuW6j+i/meS6m+WOn+WcsOaOkuW6j+eul+azleabtOWPr+WPluOAguWvueS6juS4gOS4quS9jeaVsOaciemZkOeahOWNgei/m+WItuaVsO+8jOaIkeS7rOWPr+S7peaKiuWug+eci+S9nOS4gOS4quWkmuWFg+e7hO+8jOS7jumrmOS9jeWIsOS9juS9jeWFs+mUruWtl+mHjeimgeeoi+W6puS+neasoemAkuWHj+OAguWPr+S7peS9v+eUqOWfuuaVsOaOkuW6j+WvueS4gOS6m+S9jeaVsOaciemZkOeahOWNgei/m+WItuaVsOaOkuW6j+OAglxyXG4gKi9cclxuXHJcbi8vIOaxguaVsOaNrueahOacgOWkp+S9jeaVsFxyXG5mdW5jdGlvbiBtYXhCaXQoYXJyKXtcclxuICAgIHZhciBkID0gMTtcclxuICAgIHZhciBwID0gMTA7XHJcblxyXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGFyci5sZW5ndGg7IGkgPCBuOyArK2kpe1xyXG4gICAgICAgIHdoaWxlKGFycltpXSA+PSBwKXtcclxuICAgICAgICAgICAgcCAqPSAxMDtcclxuICAgICAgICAgICAgKytkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFkaXhTb3J0KGFyciwgZCl7XHJcbiAgICBkID0gZCB8fCBtYXhCaXQoYXJyKTtcclxuICAgIHZhciBuID0gYXJyLmxlbmd0aDtcclxuICAgIHZhciB0ZW1wID0gW107XHJcbiAgICAvLyDorqHmlbDlmahcclxuICAgIHZhciBjb3VudCA9IFtdO1xyXG4gICAgdmFyIHJhZGl4ID0gMTtcclxuXHJcbiAgICAvLyDov5vooYxk5qyh5o6S5bqPXHJcbiAgICBmb3IodmFyIGkgPSAxOyBpIDw9IGQ7ICsraSl7XHJcbiAgICAgICAgLy8g5q+P5qyh5YiG6YWN5YmN5riF56m66K6h5pWw5ZmoXHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDEwOyArK2opXHJcbiAgICAgICAgICAgIGNvdW50W2pdID0gMDtcclxuICAgICAgICAvLyDnu5/orqHmr4/kuKrmobbkuK3nmoTorrDlvZXmlbBcclxuICAgICAgICBmb3IoaiA9IDA7IGogPCBuOyArK2ope1xyXG4gICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoYXJyW2pdIC8gcmFkaXgpICUgMTA7XHJcbiAgICAgICAgICAgICsrY291bnRba107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihqID0gMTsgaiA8IDEwOyArK2opXHJcbiAgICAgICAgICAgIGNvdW50W2pdICs9IGNvdW50W2ogLSAxXTtcclxuICAgICAgICAvLyDlsIbmiYDmnInmobbkuK3orrDlvZXkvp3mrKHmlLbpm4bliLB0bXDkuK1cclxuICAgICAgICBmb3IoaiA9IG4gLSAxOyBqID49IDA7IC0tail7XHJcbiAgICAgICAgICAgIGsgPSBNYXRoLmZsb29yKGFycltqXSAvIHJhZGl4KSAlIDEwO1xyXG4gICAgICAgICAgICB0ZW1wWy0tY291bnRba11dID0gYXJyW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WwhuS4tOaXtuaVsOe7hOeahOWGheWuueWkjeWItuWIsGFycuS4rVxyXG4gICAgICAgIGZvcihqID0gMDsgaiA8IG47ICsrailcclxuICAgICAgICAgICAgYXJyW2pdID0gdGVtcFtqXTtcclxuXHJcbiAgICAgICAgcmFkaXggKj0gMTA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5yYWRpeFNvcnQgPSByYWRpeFNvcnQ7XHJcblxyXG52YXIgYXJyID0gWzEwMCwgOTMsIDk3LCA5MiwgOTYsIDk5LCA5MiwgODksIDkzLCA5NywgOTAsIDk0LCA5MiwgOTVdO1xyXG5yYWRpeFNvcnQoYXJyLCAxMDApO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDmobbmjpLluo9cclxuXHJcbiDmobbmjpLluo/vvIhCdWNrZXQgc29ydO+8ieaIluaJgOiwk+eahOeuseaOkuW6j++8jOaYr+S4gOS4quaOkuW6j+eul+azle+8jOW3peS9nOeahOWOn+eQhuaYr+WwhuaVsOe7hOWIhuWIsOaciemZkOaVsOmHj+eahOahtuWtkOmHjOOAguavj+S4quahtuWtkOWGjeS4quWIq+aOkuW6j++8iOacieWPr+iDveWGjeS9v+eUqOWIq+eahOaOkuW6j+eul+azleaIluaYr+S7pemAkuW9kuaWueW8j+e7p+e7reS9v+eUqOahtuaOkuW6j+i/m+ihjOaOkuW6j++8ieOAguahtuaOkuW6j+aYr+m4veW3ouaOkuW6j+eahOS4gOenjeW9kue6s+e7k+aenOOAguW9k+imgeiiq+aOkuW6j+eahOaVsOe7hOWGheeahOaVsOWAvOaYr+Wdh+WMgOWIhumFjeeahOaXtuWAme+8jOahtuaOkuW6j+S9v+eUqOe6v+aAp+aXtumXtO+8iM6YKG4p77yJ44CC5L2G5qG25o6S5bqP5bm25LiN5piv5q+U6L6D5o6S5bqP77yM5LuW5LiN5Y+X5YiwTyhuIGxvZyBuKeS4i+mZkOeahOW9seWTjeOAglxyXG5cclxuIOWfuuacrOaAneaDs1xyXG5cclxuIOWBh+iuvuacieS4gOe7hOmVv+W6puS4uk7nmoTlvoXmjpLlhbPplK7lrZfluo/liJdLWzEuLi4ubl3jgILpppblhYjlsIbov5nkuKrluo/liJfliJLliIbmiJBN5Liq55qE5a2Q5Yy66Ze0KOahtikg44CC54S25ZCO5Z+65LqO5p+Q56eN5pig5bCE5Ye95pWwIO+8jOWwhuW+heaOkuW6j+WIl+eahOWFs+mUruWtl2vmmKDlsITliLDnrKxp5Liq5qG25LitKOWNs+ahtuaVsOe7hELnmoTkuIvmoIcgaSkg77yM6YKj5LmI6K+l5YWz6ZSu5a2Xa+WwseS9nOS4ukJbaV3kuK3nmoTlhYPntKAo5q+P5Liq5qG2QltpXemDveaYr+S4gOe7hOWkp+Wwj+S4uk4vTeeahOW6j+WIlynjgILmjqXnnYDlr7nmr4/kuKrmobZCW2ld5Lit55qE5omA5pyJ5YWD57Sg6L+b6KGM5q+U6L6D5o6S5bqPKOWPr+S7peS9v+eUqOW/q+aOkinjgILnhLblkI7kvp3mrKHmnprkuL7ovpPlh7pCWzBdLi4uLkJbTV3kuK3nmoTlhajpg6jlhoXlrrnljbPmmK/kuIDkuKrmnInluo/luo/liJfjgIJcclxuIOWBh+WmguW+heaOkuW6j+WIl0s9IHs0OeOAgSAzOCDjgIEgMzXjgIEgOTcg44CBIDc244CBIDczIOOAgSAyN+OAgSA0OSB944CC6L+Z5Lqb5pWw5o2u5YWo6YOo5ZyoMeKAlDEwMOS5i+mXtOOAguWboOatpOaIkeS7rOWumuWItjEw5Liq5qG277yM54S25ZCO56Gu5a6a5pig5bCE5Ye95pWwZihrKT1rLzEw44CC5YiZ56ys5LiA5Liq5YWz6ZSu5a2XNDnlsIblrprkvY3liLDnrKw05Liq5qG25LitKDQ5LzEwPTQp44CC5L6d5qyh5bCG5omA5pyJ5YWz6ZSu5a2X5YWo6YOo5aCG5YWl5qG25Lit77yM5bm25Zyo5q+P5Liq6Z2e56m655qE5qG25Lit6L+b6KGM5b+r6YCf5o6S5bqP44CCXHJcblxyXG4g5YiG5p6QXHJcblxyXG4g5qG25o6S5bqP5Yip55So5Ye95pWw55qE5pig5bCE5YWz57O777yM5YeP5bCR5LqG5Yeg5LmO5omA5pyJ55qE5q+U6L6D5bel5L2c44CC5a6e6ZmF5LiK77yM5qG25o6S5bqP55qEZihrKeWAvOeahOiuoeeul++8jOWFtuS9nOeUqOWwseebuOW9k+S6juW/q+aOkuS4reWIkuWIhu+8jOW3sue7j+aKiuWkp+mHj+aVsOaNruWIhuWJsuaIkOS6huWfuuacrOacieW6j+eahOaVsOaNruWdlyjmobYp44CC54S25ZCO5Y+q6ZyA6KaB5a+55qG25Lit55qE5bCR6YeP5pWw5o2u5YGa5YWI6L+b55qE5q+U6L6D5o6S5bqP5Y2z5Y+v44CCXHJcbiDlr7lO5Liq5YWz6ZSu5a2X6L+b6KGM5qG25o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5YiG5Li65Lik5Liq6YOo5YiG77yaXHJcbiAgICAgKDEpIOW+queOr+iuoeeul+avj+S4quWFs+mUruWtl+eahOahtuaYoOWwhOWHveaVsO+8jOi/meS4quaXtumXtOWkjeadguW6puaYr08oTinjgIJcclxuICAgICAoMikg5Yip55So5YWI6L+b55qE5q+U6L6D5o6S5bqP566X5rOV5a+55q+P5Liq5qG25YaF55qE5omA5pyJ5pWw5o2u6L+b6KGM5o6S5bqP77yM5YW25pe26Ze05aSN5p2C5bqm5Li6IOKIkSBPKE5pKmxvZ05pKSDjgILlhbbkuK1OaSDkuLrnrKxp5Liq5qG255qE5pWw5o2u6YeP44CCXHJcbiDlvojmmL7nhLbvvIznrKwoMinpg6jliIbmmK/mobbmjpLluo/mgKfog73lpb3lnY/nmoTlhrPlrprlm6DntKDjgILlsL3ph4/lh4/lsJHmobblhoXmlbDmja7nmoTmlbDph4/mmK/mj5Dpq5jmlYjnjofnmoTllK/kuIDlip7ms5Uo5Zug5Li65Z+65LqO5q+U6L6D5o6S5bqP55qE5pyA5aW95bmz5Z2H5pe26Ze05aSN5p2C5bqm5Y+q6IO96L6+5YiwTyhOKmxvZ04p5LqGKeOAguWboOatpO+8jOaIkeS7rOmcgOimgeWwvemHj+WBmuWIsOS4i+mdouS4pOeCue+8mlxyXG4gICAgICgxKSDmmKDlsITlh73mlbBmKGsp6IO95aSf5bCGTuS4quaVsOaNruW5s+Wdh+eahOWIhumFjeWIsE3kuKrmobbkuK3vvIzov5nmoLfmr4/kuKrmobblsLHmnIlbTi9NXeS4quaVsOaNrumHj+OAglxyXG4gICAgICgyKSDlsL3ph4/nmoTlop7lpKfmobbnmoTmlbDph4/jgILmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rog73lvpfliLDkuIDkuKrmlbDmja7vvIzov5nmoLflsLHlrozlhajpgb/lvIDkuobmobblhoXmlbDmja7nmoTigJzmr5TovoPigJ3mjpLluo/mk43kvZzjgIIg5b2T54S277yM5YGa5Yiw6L+Z5LiA54K55b6I5LiN5a655piT77yM5pWw5o2u6YeP5beo5aSn55qE5oOF5Ya15LiL77yMZihrKeWHveaVsOS8muS9v+W+l+ahtumbhuWQiOeahOaVsOmHj+W3qOWkp++8jOepuumXtOa1qui0ueS4pemHjeOAgui/meWwseaYr+S4gOS4quaXtumXtOS7o+S7t+WSjOepuumXtOS7o+S7t+eahOadg+ihoemXrumimOS6huOAglxyXG5cclxuIOWvueS6jk7kuKrlvoXmjpLmlbDmja7vvIxN5Liq5qG277yM5bmz5Z2H5q+P5Liq5qG2W04vTV3kuKrmlbDmja7nmoTmobbmjpLluo/lubPlnYfml7bpl7TlpI3mnYLluqbkuLrvvJpcclxuIE8oTikrTyhNKihOL00pKmxvZyhOL00pKT1PKE4rTioobG9nTi1sb2dNKSk9TyhOK04qbG9nTi1OKmxvZ00pXHJcbiDlvZNOPU3ml7bvvIzljbPmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rmnInkuIDkuKrmlbDmja7ml7bjgILmobbmjpLluo/nmoTmnIDlpb3mlYjnjofog73lpJ/ovr7liLBPKE4p44CCXHJcblxyXG4g5oC757uT77yaIOahtuaOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puS4uue6v+aAp+eahE8oTitDKe+8jOWFtuS4rUM9TioobG9nTi1sb2dNKeOAguWmguaenOebuOWvueS6juWQjOagt+eahE7vvIzmobbmlbDph49N6LaK5aSn77yM5YW25pWI546H6LaK6auY77yM5pyA5aW955qE5pe26Ze05aSN5p2C5bqm6L6+5YiwTyhOKeOAgiDlvZPnhLbmobbmjpLluo/nmoTnqbrpl7TlpI3mnYLluqYg5Li6TyhOK00p77yM5aaC5p6c6L6T5YWl5pWw5o2u6Z2e5bi45bqe5aSn77yM6ICM5qG255qE5pWw6YeP5Lmf6Z2e5bi45aSa77yM5YiZ56m66Ze05Luj5Lu35peg55aR5piv5piC6LS155qE44CC5q2k5aSW77yM5qG25o6S5bqP5piv56iz5a6a55qE44CCXHJcbiAqL1xyXG5cclxudmFyIEJVQ0tFVFNOVU0gPSAxMDtcclxudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4uL2V4Y2hhbmdlL2luZGV4JykucXVpY2tTb3J0O1xyXG5cclxuZnVuY3Rpb24gYnVja2V0U29ydChzcUxpc3Qpe1xyXG4gICAgdmFyICBuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIHZhciBidWNrZXRBID0gW107XHJcbiAgICB2YXIgYiA9IFtdO1xyXG5cclxuICAgIC8vIOWIneWni+WMluahtlxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSl7XHJcbiAgICAgICAgYltpXSA9IFtdO1xyXG4gICAgICAgIGJ1Y2tldEFbaV0gPSAwO1xyXG5cclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbjsgKytqKVxyXG4gICAgICAgICAgICBiW2ldW2pdID0gSW5maW5pdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g57uZ5qG25aGr6KOF5pWw5o2uXHJcbiAgICBmb3IoaSA9IDA7IGkgPCBuOyArK2kpe1xyXG4gICAgICAgIHZhciBkYXRhID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIC8vIG5vdG86IOi/memHjOeahOaYoOWwhOWHveaVsOaYr+mSiOWvuTEtMTAw5LmL6Ze055qE5a6e5pWwXHJcbiAgICAgICAgdmFyIGJ1Y2tldCA9IE1hdGguZmxvb3IoZGF0YSAvIEJVQ0tFVFNOVU0pO1xyXG4gICAgICAgIGJbYnVja2V0XVtidWNrZXRBW2J1Y2tldF1dID0gZGF0YTtcclxuICAgICAgICArK2J1Y2tldEFbYnVja2V0XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDpkojlr7nmr4/kuKrmobbov5vooYzlv6vpgJ/mjpLluo9cclxuICAgIGZvcihpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSl7XHJcbiAgICAgICAgaWYoYnVja2V0QVtpXSAhPT0gMCkge1xyXG4gICAgICAgICAgICBxdWlja1NvcnQoYltpXSwgMCwgYnVja2V0QVtpXSAtIDEpO1xyXG4gICAgICAgICAgICAvL2ZvcihqID0gMTsgaiA8IGJ1Y2tldEFbaV07ICsrail7XHJcbiAgICAgICAgICAgIC8vICAgIHZhciBwID0gYltpXVtqXTtcclxuICAgICAgICAgICAgLy8gICAgZm9yKHZhciBrID0gaiAtIDE7IGsgPj0gMCAmJiBwIDwgYltpXVtrXTsgLS1rKXtcclxuICAgICAgICAgICAgLy8gICAgICAgIGJbaV1bayArIDFdID0gYltpXVtrXTtcclxuICAgICAgICAgICAgLy8gICAgfVxyXG4gICAgICAgICAgICAvLyAgICBiW2ldW2sgKyAxXSA9IHA7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKGIpO1xyXG4gICAgLy9jb25zb2xlLmxvZyhidWNrZXRBKTtcclxuXHJcbiAgICAvLyDlpI3liLblm57ljrtcclxuICAgIHZhciBudW0gPSAwO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgQlVDS0VUU05VTTsgKytpKXtcclxuICAgICAgICBpZihidWNrZXRBW2ldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGJ1Y2tldEFbaV07ICsrail7XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbbnVtKytdID0gYltpXVtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmJ1Y2tldFNvcnQgPSBidWNrZXRTb3J0O1xyXG5cclxudmFyIGFyciA9IFs1MS4yLCA5MywgMSwgOTIuMiwgOCwgOTkuNSwgOTIuMCwgODksIDkzLCA5NywgOTAsIDk0LCA5Mi4xLCA5NV07XHJcbmJ1Y2tldFNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xyXG5cclxudmFyIGFyciA9IFs1MS4yLCA5MywgMSwgOTIuMiwgOCwgOTkuNSwgOTIuMCwgODksIDkzLCA5NywgOTAsIDk0LCA5Mi4xLCA5NSwgSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eV07XHJcbnF1aWNrU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuLypcclxuIOaAp+iDveWIhuaekFxyXG4g5b6I5piO5pi+77yM5Z+65pWw5o6S5bqP55qE5oCn6IO95q+U5qG25o6S5bqP6KaB55Wl5beu44CC5q+P5LiA5qyh5YWz6ZSu5a2X55qE5qG25YiG6YWN6YO96ZyA6KaBTyhOKeeahOaXtumXtOWkjeadguW6pu+8jOiAjOS4lOWIhumFjeS5i+WQjuW+l+WIsOaWsOeahOWFs+mUruWtl+W6j+WIl+WPiOmcgOimgU8oTinnmoTml7bpl7TlpI3mnYLluqbjgILlgYflpoLlvoXmjpLmlbDmja7lj6/ku6XliIbkuLpk5Liq5YWz6ZSu5a2X77yM5YiZ5Z+65pWw5o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5bCG5pivTyhkKjJOKSDvvIzlvZPnhLZk6KaB6L+c6L+c5bCP5LqOTu+8jOWboOatpOWfuuacrOS4iui/mOaYr+e6v+aAp+e6p+WIq+eahOOAguWfuuaVsOaOkuW6j+eahOepuumXtOWkjeadguW6puS4uk8oTitNKe+8jOWFtuS4rU3kuLrmobbnmoTmlbDph4/jgILkuIDoiKzmnaXor7ROPj5N77yM5Zug5q2k6aKd5aSW56m66Ze06ZyA6KaB5aSn5qaCTuS4quW3puWPs+OAglxyXG4g5L2G5piv77yM5a+55q+U5qG25o6S5bqP77yM5Z+65pWw5o6S5bqP5q+P5qyh6ZyA6KaB55qE5qG255qE5pWw6YeP5bm25LiN5aSa44CC6ICM5LiU5Z+65pWw5o6S5bqP5Yeg5LmO5LiN6ZyA6KaB5Lu75L2V4oCc5q+U6L6D4oCd5pON5L2c77yM6ICM5qG25o6S5bqP5Zyo5qG255u45a+56L6D5bCR55qE5oOF5Ya15LiL77yM5qG25YaF5aSa5Liq5pWw5o2u5b+F6aG76L+b6KGM5Z+65LqO5q+U6L6D5pON5L2c55qE5o6S5bqP44CC5Zug5q2k77yM5Zyo5a6e6ZmF5bqU55So5Lit77yM5Z+65pWw5o6S5bqP55qE5bqU55So6IyD5Zu05pu05Yqg5bm/5rOb44CCXHJcbiAqL1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvZGlzdHJpYnV0aW9uL2luZGV4LmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMi5cclxuICovXHJcblxyXG5pbXBvcnQgU3RhdGljTGlua2VkTGlzdCBmcm9tICcuLi8uLi9MaXN0L1N0YXRpY0xpbmtlZExpc3QnO1xyXG52YXIgZGVmYXVsdENvbXBhcmUgPSByZXF1aXJlKCcuLi9kZWZhdWx0Q29tcGFyaXNpb24nKTtcclxuXHJcbi8qXHJcbiDmj5LlhaXmjpLluo9cclxuXHJcbiDph4fnlKjnmoTmmK/ku6Ug4oCc546p5qGl54mM6ICF4oCd55qE5pa55rOV5Li65Z+656GA55qE44CC5Y2z5Zyo6ICD5a+f6K6w5b2VUmnkuYvliY3vvIzorr7ku6XliY3nmoTmiYDmnInorrDlvZVSMSwgUjIgLOKApi4sIFJpLTHlt7LmjpLlpb3luo/vvIznhLblkI7lsIZSaeaPkuWFpeWIsOW3suaOkuWlveW6j+eahOivuOiusOW9leeahOmAguW9k+S9jee9rlxyXG5cclxuIOacgOWfuuacrOeahOaPkuWFpeaOkuW6j+aYr+ebtOaOpeaPkuWFpeaOkuW6jyhTdHJhaWdodCBJbnNlcnRpb24gU29ydCkg44CCXHJcblxyXG5cclxuIOebtOaOpeaPkuWFpeaOkuW6j1xyXG5cclxuIDEgIOaOkuW6j+aAneaDs1xyXG4g5bCG5b6F5o6S5bqP55qE6K6w5b2VUmnvvIzmj5LlhaXliLDlt7LmjpLlpb3luo/nmoTorrDlvZXooahSMSwgUjIgLOKApi4sIFJpLTHkuK3vvIzlvpfliLDkuIDkuKrmlrDnmoTjgIHorrDlvZXmlbDlop7liqAx55qE5pyJ5bqP6KGo44CCIOebtOWIsOaJgOacieeahOiusOW9lemDveaPkuWFpeWujOS4uuatouOAglxyXG4g6K6+5b6F5o6S5bqP55qE6K6w5b2V6aG65bqP5a2Y5pS+5Zyo5pWw57uEUlsx4oCmbl3kuK3vvIzlnKjmjpLluo/nmoTmn5DkuIDml7bliLvvvIzlsIborrDlvZXluo/liJfliIbmiJDkuKTpg6jliIbvvJpcclxuIOKXhiBSWzHigKZpLTFd77ya5bey5o6S5aW95bqP55qE5pyJ5bqP6YOo5YiG77ybXHJcbiDil4YgUltp4oCmbl3vvJrmnKrmjpLlpb3luo/nmoTml6Dluo/pg6jliIbjgIJcclxuIOaYvueEtu+8jOWcqOWImuW8gOWni+aOkuW6j+aXtu+8jFJbMV3mmK/lt7Lnu4/mjpLlpb3luo/nmoTjgIJcclxuXHJcbiAyLueul+azleWunueOsFxyXG5cclxuIDMu566X5rOV5YiG5p6QXHJcbiDikbQg5pyA5aW95oOF5Ya177ya6Iul5b6F5o6S5bqP6K6w5b2V5oyJ5YWz6ZSu5a2X5LuO5bCP5Yiw5aSn5o6S5YiXKOato+W6jynvvIznrpfms5XkuK3nmoTlhoXlvqrnjq/ml6DpobvmiafooYzvvIzliJnkuIDotp/mjpLluo/ml7bvvJrlhbPplK7lrZfmr5TovoPmrKHmlbAx5qyh77yM6K6w5b2V56e75Yqo5qyh5pWwMuasoShSW2ld4oaSUlswXSwgUlswXeKGklJbaisxXSnjgIJcclxuIOWImeaVtOS4quaOkuW6j+eahOWFs+mUruWtl+avlOi+g+asoeaVsOWSjOiusOW9leenu+WKqOasoeaVsOWIhuWIq+aYr++8mlxyXG4g5q+U6L6D5qyh5pWw77yabiAtIDEgICAgICAgICAg56e75Yqo5qyh5pWw77yaIDIgKiAobiAtIDEpXHJcblxyXG4g4pG1IOacgOWdj+aDheWGte+8muiLpeW+heaOkuW6j+iusOW9leaMieWFs+mUruWtl+S7juWkp+WIsOWwj+aOkuWIlyjpgIbluo8p77yM5YiZ5LiA6Laf5o6S5bqP5pe277ya566X5rOV5Lit55qE5YaF5b6q546v5L2T5omn6KGMaS0x77yM5YWz6ZSu5a2X5q+U6L6D5qyh5pWwaeasoe+8jOiusOW9leenu+WKqOasoeaVsGkrMeOAglxyXG4g5YiZ5bCx5pW05Liq5o6S5bqP6ICM6KiA77yaXHJcbiDmr5TovoPmrKHmlbDvvJogKG4gLSAxKSAqIChuICsgMSkgLyAyICAgICDnp7vliqjmrKHmlbA6IChuIC0gMSkgKiAobiArIDQpIC8gMlxyXG5cclxuIOS4gOiIrOWcsO+8jOiupOS4uuW+heaOkuW6j+eahOiusOW9leWPr+iDveWHuueOsOeahOWQhOenjeaOkuWIl+eahOamgueOh+ebuOWQjO+8jOWImeWPluS7peS4iuS4pOenjeaDheWGteeahOW5s+Wdh+WAvO+8jOS9nOS4uuaOkuW6j+eahOWFs+mUruWtl+avlOi+g+asoeaVsOWSjOiusOW9leenu+WKqOasoeaVsO+8jOe6puS4um4yLzTvvIzliJnlpI3mnYLluqbkuLpPKG4yKSDjgIJcclxuXHJcblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHN0cmFpZ2h0SW5zZXJ0U29ydChzcUxpc3QsIGNvbXApIHtcclxuICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAvLyDorr7nva7lk6jlhbUsIOW9k+iuvue9rnNxTGlzdFstMV0gPSBzcUxpc3RbaV3ml7bvvIznu4/mtYvor5XmlYjnjofmm7TmhaJcclxuICAgICAgICAvLyDlm6DkuLpqc+mHjOmdoueahOWPmOmHj+S9nOeUqOWfn+WcqOWHveaVsOWGheeahFxyXG4gICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIC8vIOafpeaJvuaPkuWFpeS9jee9ru+8jOW5tuWwhuiusOW9leWQjuenu1xyXG4gICAgICAgIGZvcih2YXIgaiA9IGkgLSAxOyBqID49IDAgJiYgY29tcCh0ZW1wLCBzcUxpc3Rbal0pIDwgMDsgLS1qKVxyXG4gICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gc3FMaXN0W2pdO1xyXG5cclxuICAgICAgICAvLyDmj5LlhaXliLDmraPnoa7kvY3nva5cclxuICAgICAgICBzcUxpc3RbaiArIDFdID0gdGVtcDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnN0cmFpZ2h0SW5zZXJ0U29ydCA9IHN0cmFpZ2h0SW5zZXJ0U29ydDtcclxuXHJcbnZhciBhID0gWzcsIDQsIC0yLCAxOSwgMTMsIDZdO1xyXG5zdHJhaWdodEluc2VydFNvcnQoYSk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcblxyXG5cclxuLypcclxuIOWFtuWug+aPkuWFpeaOkuW6j1xyXG5cclxuIDEgIOaKmOWNiuaPkuWFpeaOkuW6j1xyXG4g5b2T5bCG5b6F5o6S5bqP55qE6K6w5b2VUltpXSDmj5LlhaXliLDlt7LmjpLlpb3luo/nmoTorrDlvZXlrZDooahSWzHigKZpLTFd5Lit5pe277yM55Sx5LqOUjEsIFIyICzigKYsIFJpLTHlt7LmjpLlpb3luo/vvIzliJnmn6Xmib7mj5LlhaXkvY3nva7lj6/ku6XnlKjigJzmipjljYrmn6Xmib7igJ3lrp7njrDvvIzliJnnm7TmjqXmj5LlhaXmjpLluo/lsLHlj5jmiJDkuLrmipjljYrmj5LlhaXmjpLluo/jgIJcclxuXHJcbiDku47ml7bpl7TkuIrmr5TovoPvvIzmipjljYrmj5LlhaXmjpLluo/ku4Xku4Xlh4/lsJHkuoblhbPplK7lrZfnmoTmr5TovoPmrKHmlbDvvIzljbTmsqHmnInlh4/lsJHorrDlvZXnmoTnp7vliqjmrKHmlbDvvIzmlYXml7bpl7TlpI3mnYLluqbku43nhLbkuLpPKG4yKSDjgIJcclxuXHJcblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGJpbmFyeUluc2VydFNvcnQoc3FMaXN0LCBjb21wKSB7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgdmFyIGxvdyA9IDA7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSBpIC0gMTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcbiAgICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb21wKHRlbXAsIHNxTGlzdFttaWRdKSA8IDApIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICBlbHNlIGxvdyA9IG1pZCArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gaGlnaCArIDE7IC0taikge1xyXG4gICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gc3FMaXN0W2pdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3FMaXN0W2hpZ2ggKyAxXSA9IHRlbXA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5iaW5hcnlJbnNlcnRTb3J0ID0gYmluYXJ5SW5zZXJ0U29ydDtcclxuXHJcbnZhciBiID0gWzMwLCAxMywgNzAsIDg1LCAzOSwgNDIsIDYsIDIwXTtcclxuYmluYXJ5SW5zZXJ0U29ydChiKTtcclxuY29uc29sZS5sb2coYiArICcnKTtcclxuXHJcblxyXG4vKlxyXG4gMi3ot6/mj5LlhaXmjpLluo9cclxuXHJcbiDmmK/lr7nmipjljYrmj5LlhaXmjpLluo/nmoTmlLnov5vvvIzku6Xlh4/lsJHmjpLluo/ov4fnqIvkuK3np7vliqjorrDlvZXnmoTmrKHmlbDjgILpmYTliqBu5Liq6K6w5b2V55qE6L6F5Yqp56m66Ze077yM5pa55rOV5piv77yaXHJcbiDikaAgIOWPpuiuvuS4gOS4quaVsOe7hGTvvIxMWzFd6LWL57uZZFsxXe+8jOWwhmRbMV3nnIvmiJDmmK/mjpLlpb3luo/nmoTluo/liJfkuK3kuK3pl7TkvY3nva7nmoTorrDlvZXvvJtcclxuIOKRoSAg5YiG5Yir5bCGTFsgXeS4reeahOesrGnkuKrorrDlvZXkvp3mrKHmj5LlhaXliLBkWzFd5LmL5YmN5oiW5LmL5ZCO55qE5pyJ5bqP5bqP5YiX5Lit77yM5YW35L2T5pa55rOV77yaXHJcbiDil4YgIExbaV0ua2V5PGRbMV0ua2V577yaIExbaV3mj5LlhaXliLBkWzFd5LmL5YmN55qE5pyJ5bqP6KGo5Lit77ybXHJcbiDil4YgTFtpXS5rZXniiaVkWzFdLmtlee+8miBMW2ld5o+S5YWl5YiwZFsxXeS5i+WQjueahOacieW6j+ihqOS4re+8m1xyXG4g5YWz6ZSu54K577ya5a6e546w5pe25bCG5ZCR6YePZOeci+aIkOaYr+W+queOr+WQkemHj++8jOW5tuiuvuS4pOS4quaMh+mSiGZpcnN05ZKMZmluYWzliIbliKvmjIfnpLrmjpLluo/ov4fnqIvkuK3lvpfliLDnmoTmnInluo/luo/liJfkuK3nmoTnrKzkuIDkuKrlkozmnIDlkI7kuIDkuKrorrDlvZXjgIJcclxuXHJcbiDlnKgyLei3r+aPkuWFpeaOkuW6j+S4re+8jOenu+WKqOiusOW9leeahOasoeaVsOe6puS4um4yLzgg44CC5L2G5b2TTFsxXeaYr+W+heaOkuW6j+iusOW9leS4reWFs+mUruWtl+acgOWkp+aIluacgOWwj+eahOiusOW9leaXtu+8jDIt6Lev5o+S5YWl5o6S5bqP5bCx5a6M5YWo5aSx5Y675LqG5LyY6LaK5oCn44CCXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcGF0aDJJbnNlcnRTb3J0KHNxTGlzdCwgY29tcCkge1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgdmFyIGQgPSBbc3FMaXN0WzBdXTtcclxuICAgIC8vIGZpcnN044CBZmluYWzliIbliKvmjIfnpLpk5Lit5o6S5aW95bqP55qE6K6w5b2V55qE56ysMeS4quWSjOacgOWQjjHkuKrorrDlvZXnmoTkvY3nva7jgIJcclxuICAgIHZhciBmaXJzdCA9IDA7XHJcbiAgICB2YXIgZmluYWwgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IHNxTGlzdFtpXTtcclxuXHJcbiAgICAgICAgLy8g5b6F5o+S5YWl6K6w5b2V5bCP5LqOZOS4reacgOWwj+WAvO+8jOaPkuWFpeWIsGRbZmlyc3Rd5LmL5YmN77yI5LiN6ZyA56e75YqoZOaVsOe7hOeahOWFg+e0oO+8ieOAglxyXG4gICAgICAgIGlmIChjb21wKGl0ZW0sIGRbZmlyc3RdKSA8IDApIHtcclxuICAgICAgICAgICAgZmlyc3QgPSAoZmlyc3QgLSAxKSAlIGxlbjtcclxuICAgICAgICAgICAgZFtmaXJzdF0gPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlvoXmj5LlhaXorrDlvZXlpKfkuo5k5Lit5pyA5bCP5YC877yM5o+S5YWl5YiwZFtmaW5hbF3kuYvlkI7vvIjkuI3pnIDnp7vliqhk5pWw57uE55qE5YWD57Sg77yJ44CCXHJcbiAgICAgICAgZWxzZSBpZiAoY29tcChpdGVtLCBkW2ZpbmFsXSkgPiAwKSB7XHJcbiAgICAgICAgICAgIGRbKytmaW5hbF0gPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlvoXmj5LlhaXorrDlvZXlpKfkuo5k5Lit5pyA5bCP5YC877yM5bCP5LqOZOS4reacgOWkp+WAvO+8jOaPkuWFpeWIsGTnmoTkuK3pl7TvvIjpnIDopoHnp7vliqhk5pWw57uE55qE5YWD57Sg77yJ44CCXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOenu+WKqGTlsL7pg6jlhYPntKDku6Xkvr/mjInluo/mj5LlhaXorrDlvZXjgIJcclxuICAgICAgICAgICAgdmFyIGogPSBmaW5hbCsrO1xyXG4gICAgICAgICAgICB3aGlsZSAoY29tcChpdGVtLCBkW2pdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGRbKGogKyAxKSAlIGxlbl0gPSBkW2pdO1xyXG4gICAgICAgICAgICAgICAgaiA9IChqIC0gMSkgJSBsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZFsoaiArIDEpICUgbGVuXSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOW+queOr+aKimTotYvnu5lzcUxpc3RcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIHNxTGlzdFtpXSA9IGRbKGkgKyBmaXJzdCkgJSBsZW5dO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucGF0aDJJbnNlcnRTb3J0ID0gcGF0aDJJbnNlcnRTb3J0O1xyXG5cclxudmFyIGMgPSBbNDksIDM4LCA2NSwgMTMsIDk3LCAyNywgNzYsIDUsIDEwMCwgNzgsIDE1LCAxNSwgMjBdO1xyXG5wYXRoMkluc2VydFNvcnQoYyk7XHJcbmNvbnNvbGUubG9nKGMgKyAnJyk7XHJcblxyXG5cclxuLypcclxu6KGo5o+S5YWl5o6S5bqPXHJcblxyXG7liY3pnaLnmoTmj5LlhaXmjpLluo/kuI3lj6/pgb/lhY3lnLDopoHnp7vliqjorrDlvZXvvIzoi6XkuI3np7vliqjorrDlvZXlsLHpnIDopoHmlLnlj5jmlbDmja7nu5PmnoTjgIJcclxu5Yid5aeL5YyW77ya5LiL5qCH5YC85Li6MOeahOWIhumHj+S9nOS4uuihqOWktOe7k+eCue+8jOWFs+mUruWtl+WPluS4uuacgOWkp+WAvO+8jOWQhOWIhumHj+eahOaMh+mSiOWAvOS4uuepuu+8m1xyXG7ikaAgIOWwhumdmeaAgemTvuihqOS4reaVsOe7hOS4i+agh+WAvOS4ujHnmoTliIbph48o57uT54K5KeS4juihqOWktOe7k+eCueaehOaIkOS4gOS4quW+queOr+mTvuihqO+8m1xyXG7ikaEgaT0yIO+8jOWwhuWIhumHj1JbaV3mjInlhbPplK7lrZfpgJLlh4/mj5LlhaXliLDlvqrnjq/pk77ooajvvJtcclxu4pGiICDlop7liqBpIO+8jOmHjeWkjeKRoe+8jOebtOWIsOWFqOmDqOWIhumHj+aPkuWFpeWIsOW+queOr+mTvuihqOOAglxyXG5cclxu5ZKM55u05o6l5o+S5YWl5o6S5bqP55u45q+U77yM5LiN5ZCM55qE5piv5L+u5pS5Mm7mrKHmjIfpkojlgLzku6Xku6Pmm7/np7vliqjorrDlvZXvvIzogIzlhbPplK7lrZfnmoTmr5TovoPmrKHmlbDnm7jlkIzvvIzmlYXml7bpl7TlpI3mnYLluqbkuLpPKG4yKeOAglxyXG5cclxu6KGo5o+S5YWl5o6S5bqP5b6X5Yiw5LiA5Liq5pyJ5bqP6ZO+6KGo77yM5a+55YW25Y+v5Lul5pa55L6/5Zyw6L+b6KGM6aG65bqP5p+l5om+77yM5L2G5LiN6IO95a6e546w6ZqP5py65p+l5om+44CC5Li65LqG6IO95a6e546w5pyJ5bqP6KGo55qE5oqY5Y2K5p+l5om+5qC55o2u6ZyA6KaB77yM5Y+v5Lul5a+56K6w5b2V6L+b6KGM6YeN5o6SLlxyXG5cclxu6YeN5o6S6K6w5b2V55qE5YGa5rOV5piv77ya6aG65bqP5omr5o+P5pyJ5bqP6ZO+6KGo77yM5bCG6ZO+6KGo5Lit56ysaeS4que7k+eCueenu+WKqOiHs+aVsOe7hOeahOesrGnkuKrliIbph4/kuK3jgIJcclxuXHJcbuS+i+WtkOS4re+8jOmTvuihqOS4reesrOS4gOS4que7k+eCue+8jOWNs+WFs+mUruWtl+acgOWwj+eahOe7k+eCueaYr+aVsOe7hOS4reS4i+agh+S4ujbnmoTliIbph4/vvIzlhbbkuK3orrDlvZXlupTnp7voh7PmlbDnu4TnmoTnrKzkuIDkuKrliIbph4/vvIzliJnlsIZsaXN0WzFd5ZKMbGlzdFs2XeS6kuaNou+8jOW5tuS4uuS6huS4jeS4reaWremdmeaAgemTvuihqOS4reeahOmTvu+8jOWNs+WcqOe7p+e7remhuumTvuihqOaJq+aPj+aXtuS7jeiDveaJvuWIsOS6kuaNouS5i+WJjeWcqGxpc3RbMV3kuK3nmoTnu5PngrnvvIzku6TkupLmjaLkuYvlkI7nmoRsaXN0WzFd5Lit55qE5ri45qCH5pS55Li6NlxyXG5cclxu5o6o5bm/6Iez5LiA6Iis5oOF5Ya177yM6Iul56ysaeS4quacgOWwj+WFs+mUruWtl+eahOe7k+eCueaYr+aVsOe7hOS4reS4i+agh+S4unDkuJRwID4gaeeahOWIhumHj++8jOWImeS6kuaNomxpc3RbaV3lkoxsaXN0W3Bd77yM5LiU5LukbGlzdFtpXeS4reeahOa4uOagh+aUueS4unDvvJtcclxu55Sx5LqO5q2k5pe25pWw57uE5Lit5omA5pyJ5bCP5LqOaeeahOWIhumHj+S4reW3suaYr+WIsOS9jeiusOW9le+8jOWImeW9k3A8aeaXtu+8jOW6lOmhuumTvue7p+e7reafpeaJvuebtOWIsHA+PWnkuLrmraLjgIJcclxuICovXHJcblxyXG5cclxuLy8g6KGo5o+S5YWl5o6S5bqPXHJcbmZ1bmN0aW9uIHN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0KHNsbGlzdCwgY29tcCkge1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgLy8g5p6E5oiQ5b6q546v6ZO+6KGoXHJcbiAgICBzbGxpc3RbMF0uY3VyID0gMTtcclxuICAgIHNsbGlzdFsxXS5jdXIgPSAwO1xyXG5cclxuICAgIHZhciBwLCBxO1xyXG4gICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IHNsbGlzdC5sZW5ndGg7IGkgPD0gbGVuOyArK2kpIHtcclxuICAgICAgICBwID0gMDtcclxuICAgICAgICB2YXIgeCA9IHNsbGlzdFtpXS5kYXRhO1xyXG5cclxuICAgICAgICB3aGlsZSAoc2xsaXN0W3BdLmN1ciAmJiBjb21wKHNsbGlzdFtzbGxpc3RbcF0uY3VyXS5kYXRhLCB4KSA8IDApXHJcbiAgICAgICAgICAgIHAgPSBzbGxpc3RbcF0uY3VyO1xyXG5cclxuICAgICAgICAvLyDlvZPpgYfliLDlpKfkuo7lvZPliY3lhbPplK7lrZfnmoTkuIvmoIfml7bvvIzmj5LlhaXliLDlhbbliY3pqbHlkozlkI7nu6fnmoTkuK3pl7RcclxuICAgICAgICBxID0gc2xsaXN0W3BdLmN1cjtcclxuICAgICAgICBzbGxpc3RbcF0uY3VyID0gaTtcclxuICAgICAgICBzbGxpc3RbaV0uY3VyID0gcTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0ID0gc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQ7XHJcblxyXG4vLyDph43mjpLpnZnmgIHpk77ooajvvIzpnZnmgIHpk77ooajkuIvmoIflt7LmjpLlpb3luo9cclxuZnVuY3Rpb24gYXJyYW5nZShzbGxpc3QpIHtcclxuICAgIHZhciBwID0gc2xsaXN0WzBdLmN1cjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc2xsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgLy8g56ysaeS4quiusOW9leWcqGxpc3TkuK3nmoTlvZPliY3kvY3nva7lupTkuI3lsI/kuo5pXHJcbiAgICAgICAgLy8g5om+5Yiw56ysaeS4quiusOW9le+8jOW5tueUqHDmjIfnpLrlhbblnKhsaXN05Lit5b2T5YmN5L2N572uXHJcbiAgICAgICAgd2hpbGUgKHAgPCBpKSBwID0gc2xsaXN0W3BdLmN1cjtcclxuICAgICAgICAvLyBx5oyH5ZCR5bCa5pyq6LCD5pW055qE6KGo5bC+XHJcbiAgICAgICAgdmFyIHEgPSBzbGxpc3RbcF0uY3VyO1xyXG5cclxuICAgICAgICBpZiAocCAhPT0gaSkge1xyXG4gICAgICAgICAgICAvLyDkuqTmjaLorrDlvZXvvIzkvb/nrKxp5Liq6K6w5b2V5Yiw5L2NXHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gc2xsaXN0W3BdO1xyXG4gICAgICAgICAgICBzbGxpc3RbcF0gPSBzbGxpc3RbaV07XHJcbiAgICAgICAgICAgIHNsbGlzdFtpXSA9IHRlbXA7XHJcbiAgICAgICAgICAgIC8vIOaMh+WQkeiiq+enu+i1sOeahOiusOW9le+8jOS9v+W+l+S7peWQjuWPr+aciXdoaWxl5b6q546v5om+5YiwXHJcbiAgICAgICAgICAgIHNsbGlzdFtpXS5jdXIgPSBwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcOaMh+WQkeWwmuacquiwg+aVtOeahOihqOWwvlxyXG4gICAgICAgIHAgPSBxO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNTJdO1xyXG52YXIgZCA9IG5ldyBTdGF0aWNMaW5rZWRMaXN0KCk7XHJcbmQuY3JlYXRlKGFycik7XHJcbnN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0KGQpO1xyXG5jb25zb2xlLmxvZyhkKTtcclxuYXJyYW5nZShkKTtcclxuY29uc29sZS5sb2coZCk7XHJcblxyXG5cclxuLypcclxu5biM5bCU5o6S5bqPXHJcblxyXG7luIzlsJTmjpLluo8oU2hlbGwgU29ydO+8jOWPiOensOe8qeWwj+WinumHj+azlSnmmK/kuIDnp43liIbnu4Tmj5LlhaXmjpLluo/mlrnms5XjgIJcclxuXHJcbjEgIOaOkuW6j+aAneaDs1xyXG7ikaAgICDlhYjlj5bkuIDkuKrmraPmlbTmlbBkMShkMTxuKeS9nOS4uuesrOS4gOS4quWinumHj++8jOWwhuWFqOmDqG7kuKrorrDlvZXliIbmiJBkMee7hO+8jOaKiuaJgOacieebuOmalGQx55qE6K6w5b2V5pS+5Zyo5LiA57uE5Lit77yM5Y2z5a+55LqO5q+P5LiqayhrPTEsIDIsICDigKYgZDEp77yMUltrXSwgUltkMStrXSwgUlsyZDEra10gLCDigKbliIblnKjlkIzkuIDnu4TkuK3vvIzlnKjlkITnu4TlhoXov5vooYznm7TmjqXmj5LlhaXmjpLluo/jgILov5nmoLfkuIDmrKHliIbnu4TlkozmjpLluo/ov4fnqIvnp7DkuLrkuIDotp/luIzlsJTmjpLluo/vvJtcclxu4pGhICAg5Y+W5paw55qE5aKe6YePZDI8ZDHvvIzph43lpI3ikaDnmoTliIbnu4TlkozmjpLluo/mk43kvZzvvJvnm7Toh7PmiYDlj5bnmoTlop7ph49kaT0x5Li65q2i77yM5Y2z5omA5pyJ6K6w5b2V5pS+6L+b5LiA5Liq57uE5Lit5o6S5bqP5Li65q2i44CCXHJcblxyXG4yICDmjpLluo/npLrkvotcclxu6K6+5pyJMTDkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLo5LCAxMywgOCwgMiwgNSwgMTMsIDcsIDEsIDE1LCAxMe+8jOWinumHj+W6j+WIl+aYrzUsIDMsIDHvvIzluIzlsJTmjpLluo/nmoTov4fnqIs6XHJcbuWIneWni+WFs+mUruWtl+W6j+WIlzogICAgOSAgICAgMTMgICAgIDggICAgICAyICAgICAgNSAgICAgIDEzICAgICAgNyAgICAgIDEgICAgICAxNSAgICAgIDExXHJcbuesrOS4gOi2n+aOkuW6j+WQjjogICAgICA5ICAgICA3ICAgICAgMSAgICAgIDIgICAgICA1ICAgICAgMTMgICAgICAxMyAgICAgOCAgICAgIDE1ICAgICAgMTFcclxu56ys5LqM6Laf5o6S5bqP5ZCOOiAgICAgIDIgICAgIDUgICAgICAxICAgICAgOSAgICAgIDcgICAgICAxMyAgICAgIDExICAgICA4ICAgICAgMTUgICAgICAxM1xyXG7nrKzkuInotp/mjpLluo/lkI46ICAgICAgMSAgICAgMiAgICAgIDUgICAgICA3ICAgICAgOCAgICAgIDkgICAgICAxMSAgICAgMTMgICAgICAxMyAgICAgIDE1XHJcblxyXG5cclxu5biM5bCU5o6S5bqP55qE5YiG5p6Q5q+U6L6D5aSN5p2C77yM5raJ5Y+K5LiA5Lqb5pWw5a2m5LiK55qE6Zeu6aKY77yM5YW25pe26Ze05piv5omA5Y+W55qE4oCc5aKe6YeP4oCd5bqP5YiX55qE5Ye95pWw44CCXHJcblxyXG7luIzlsJTmjpLluo/nibnngrlcclxu5a2Q5bqP5YiX55qE5p6E5oiQ5LiN5piv566A5Y2V55qE4oCc6YCQ5q615YiG5Ymy4oCd77yM6ICM5piv5bCG55u46ZqU5p+Q5Liq5aKe6YeP55qE6K6w5b2V57uE5oiQ5LiA5Liq5a2Q5bqP5YiX44CCXHJcbuW4jOWwlOaOkuW6j+WPr+aPkOmrmOaOkuW6j+mAn+W6pu+8jOWOn+WboOaYr++8mlxyXG7il4Yg5YiG57uE5ZCObuWAvOWHj+Wwj++8jG7CsuabtOWwj++8jOiAjFQobik9TyhuwrIpLOaJgOS7pVQobinku47mgLvkvZPkuIrnnIvmmK/lh4/lsI/kuobvvJtcclxu4peGIOWFs+mUruWtl+i+g+Wwj+eahOiusOW9lei3s+i3g+W8j+WJjeenu++8jOWcqOi/m+ihjOacgOWQjuS4gOi2n+WinumHj+S4ujHnmoTmj5LlhaXmjpLluo/ml7bvvIzluo/liJflt7Lln7rmnKzmnInluo/jgIJcclxuXHJcbuWinumHj+W6j+WIl+WPluazlVxyXG7il4Yg5peg6ZmkMeS7peWklueahOWFrOWboOWtkO+8m1xyXG7il4Yg5pyA5ZCO5LiA5Liq5aKe6YeP5YC85b+F6aG75Li6MeOAglxyXG5cclxu55u45YWz6LWE5paZ77yaIGh0dHA6Ly93ZW5rdS5iYWlkdS5jb20vbGluaz91cmw9cTdrek94WHFjMEJMYUdVVkRZNDNGUU9oMmFYMVVxQkhra1lkM1ZNd0poSm82cnY0U2lVNjg2Ulcza1FDU3FHRUt5dGwxMlM4ZkJPcHdocS1ydW5oWF9wYlpjZzZCZUQtbWlZTVBnRGhYeEtcclxuICovXHJcblxyXG5mdW5jdGlvbiBzaGVsbEluc2VydChzcUxpc3QsIGRrLCBjb21wKSB7XHJcbiAgICBmb3IgKHZhciBpID0gZGssIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIGlmIChjb21wKHRlbXAsIHNxTGlzdFtpIC0gZGtdKSA8IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSBkazsgaiA+PSAwICYmIGNvbXAodGVtcCwgc3FMaXN0W2pdKSA8IDA7IGogLT0gZGspXHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIGRrXSA9IHNxTGlzdFtqXTtcclxuXHJcbiAgICAgICAgICAgIHNxTGlzdFtqICsgZGtdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNoZWxsU29ydChzcUxpc3QsIGNvbXApIHtcclxuICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIHZhciBkZWx0YSA9IGNyZWF0ZURlbHRhKHNxTGlzdC5sZW5ndGgpO1xyXG4gICAgLy9jb25zb2xlLmxvZyhkZWx0YSk7XHJcbiAgICBmb3IgKHZhciBrID0gMCwgdCA9IGRlbHRhLmxlbmd0aDsgayA8IHQ7ICsraykge1xyXG4gICAgICAgIHNoZWxsSW5zZXJ0KHNxTGlzdCwgZGVsdGFba10sIGNvbXApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc2hlbGxTb3J0ID0gc2hlbGxTb3J0O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRGVsdGEobikge1xyXG4gICAgdmFyIGFyciA9IFtdO1xyXG4gICAgdmFyIHQgPSAoTWF0aC5sb2cobiAtIDEpIC8gTWF0aC5sb2coMikpIHwgMDsgIC8vIE1hdGgubG9nKG4gLSAxKSAvIE1hdGgubG9nKDIpLCBNYXRoLmxvZyhuICsgMSkgLyBNYXRoLmxvZygyKVxyXG4gICAgZm9yKHZhciBrID0gMDsgayA8PSB0OyArK2spXHJcbiAgICAgICAgYXJyW2tdID0gTWF0aC5wb3coMiwgdCAtIGspICsgMTsgICAgLy8gTWF0aC5wb3coMiwgdCAtIGkgKyAxKSAtIDEsIE1hdGgucG93KDIsIHQgLSBpKSArIDFcclxuXHJcbiAgICBhcnJbYXJyLmxlbmd0aF0gPSAxO1xyXG5cclxuICAgIHJldHVybiBhcnI7XHJcbn1cclxuXHJcblxyXG5jb25zb2xlLmxvZygnXFxuXFxuU2hlbGwgU29ydDonKTtcclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxuc2hlbGxTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9Tb3J0L2luc2VydGlvbi9pbmRleC5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGxkcCBvbiAyMDE1LzIvNy5cclxuICovXHJcbmltcG9ydCBMaW5rZWRMaXN0IGZyb20gJy4uLy4uL0xpc3QvTGlua2VkTGlzdCc7XHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi8uLi9RdWV1ZS9RdWV1ZSc7XHJcbnZhciBkZWZhdWx0Q29tcGFyZSA9IHJlcXVpcmUoJy4uL2RlZmF1bHRDb21wYXJpc2lvbicpO1xyXG5cclxuLypcclxuIOW9kuW5tuaOkuW6j1xyXG5cclxuIOW9kuW5tihNZXJnaW5nKSDvvJrmmK/mjIflsIbkuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTmnInluo/luo/liJflkIjlubbmiJDkuIDkuKrmnInluo/luo/liJfjgILoi6Xph4fnlKjnur/mgKfooago5peg6K665piv6YKj56eN5a2Y5YKo57uT5p6EKeaYk+S6juWunueOsO+8jOWFtuaXtumXtOWkjeadguW6puS4uk8obStuKSDjgIJcclxuIOW9kuW5tuaAneaDs+WunuS+i++8muS4pOWghuaJkeWFi+eJjO+8jOmDveW3suS7juWwj+WIsOWkp+aOkuWlveW6j++8jOimgeWwhuS4pOWghuWQiOW5tuS4uuS4gOWghuS4lOimgeaxguS7juWwj+WIsOWkp+aOkuW6j+OAglxyXG4g4peGICDlsIbkuKTloIbmnIDkuIrpnaLnmoTmir3lh7oo6K6+5Li6QzHvvIxDMinmr5TovoPlpKflsI/vvIzlsIblsI/ogIXnva7kuo7kuIDovrnkvZzkuLrmlrDnmoTkuIDloIYo5LiN5aao6K6+QzE8QzIp77yb5YaN5LuO56ys5LiA5aCG5Lit5oq95Ye65LiA5byg57un57ut5LiOQzLov5vooYzmr5TovoPvvIzlsIbovoPlsI/nmoTmlL7nva7lnKjmlrDloIbnmoTmnIDkuIvpnaLvvJtcclxuIOKXhiDph43lpI3kuIrov7Dov4fnqIvvvIznm7TliLDmn5DkuIDloIblt7Lmir3lrozvvIznhLblkI7lsIbliankuIvkuIDloIbkuK3nmoTmiYDmnInniYzovaznp7vliLDmlrDloIbkuK3jgIJcclxuXHJcbiAxICAg5o6S5bqP5oCd5oOzXHJcbiDikaAgIOWIneWni+aXtu+8jOWwhuavj+S4quiusOW9leeci+aIkOS4gOS4quWNleeLrOeahOacieW6j+W6j+WIl++8jOWImW7kuKrlvoXmjpLluo/orrDlvZXlsLHmmK9u5Liq6ZW/5bqm5Li6MeeahOacieW6j+WtkOW6j+WIl++8m1xyXG4g4pGhICDlr7nmiYDmnInmnInluo/lrZDluo/liJfov5vooYzkuKTkuKTlvZLlubbvvIzlvpfliLDvg6luLzLvg7nkuKrplb/luqbkuLoy5oiWMeeahOacieW6j+WtkOW6j+WIl+KAlOKAlOS4gOi2n+W9kuW5tu+8m1xyXG4g4pGiICDph43lpI3ikaEg77yM55u05Yiw5b6X5Yiw6ZW/5bqm5Li6bueahOacieW6j+W6j+WIl+S4uuatouOAglxyXG5cclxuIOS4iui/sOaOkuW6j+i/h+eoi+S4re+8jOWtkOW6j+WIl+aAu+aYr+S4pOS4pOW9kuW5tu+8jOensOS4ujIt6Lev5b2S5bm25o6S5bqP44CC5YW25qC45b+D5piv5aaC5L2V5bCG55u46YK755qE5Lik5Liq5a2Q5bqP5YiX5b2S5bm25oiQ5LiA5Liq5a2Q5bqP5YiX44CC6K6+55u46YK755qE5Lik5Liq5a2Q5bqP5YiX5YiG5Yir5Li677yaXHJcbiB7UltrXSwgUltrKzFdLCDigKYsIFJbbV195ZKMe1JbbSsxXSwgUlttKzJdLOKApiwgUltoXX3vvIzlsIblroPku6zlvZLlubbkuLrkuIDkuKrmnInluo/nmoTlrZDluo/liJfvvJpcclxuIHtEUltsXSwgRFJbbCsxXSwg4oCmLCBEUlttXSwgRFJbbSsxXSwg4oCmLCBEUltoXSB9XHJcblxyXG4g5L6L77ya6K6+5pyJOeS4quW+heaOkuW6j+eahOiusOW9le+8jOWFs+mUruWtl+WIhuWIq+S4ujIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDHvvIzlvZLlubbmjpLluo/nmoTov4fnqIvjgIJcclxuIOWIneWni+WFs+mUruWtlzogWzIzXSAgIFszOF0gICBbMjJdICAgWzQ1XSAgIFsyM10gICBbNjddICAgWzMxXSAgIFsxNV0gICBbNDFdXHJcbiAgICAgICAgICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHxcclxuICAgICAgICAgICAgICAtLS0tLS0tLSAgICAgIC0tLS0tLS0tICAgICAgLS0tLS0tLS0gICAgICAtLS0tLS0tLVxyXG4g5LiA6Laf5b2S5bm25ZCOOiBbMjMgICAgMzhdICAgIFsyMiAgICAgNDVdICAgIFsyMyAgICAgNjddICAgIFsxNSAgICAgMzFdICAgWzQxXVxyXG4gICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLVxyXG4g5LqM6Laf5b2S5bm25ZCOOiBbMjIgICAgIDIzICAgICAgMzggICAgIDQ1XSAgICBbMTUgICAgIDIzICAgICAzMSAgICAgNjddICAgIFs0MV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuIOS4iei2n+W9kuW5tuWQjjogWzE1ICAgICAyMiAgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0NSAgICAgNjddICAgIFs0MV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiDlm5votp/lvZLlubblkI46IFsxNSAgICAgMjIgICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgICA2N1xyXG5cclxuXHJcbiAyICDkuIDotp/lvZLlubbmjpLluo9cclxuIOS4gOi2n+W9kuW5tuaOkuW6j+mDveaYr+S7juWJjeWIsOWQju+8jOS+neasoeWwhuebuOmCu+eahOS4pOS4quacieW6j+WtkOW6j+WIl+W9kuW5tuS4uuS4gOS4qu+8jOS4lOmZpOacgOWQjuS4gOS4quWtkOW6j+WIl+Wklu+8jOWFtuS9meavj+S4quWtkOW6j+WIl+eahOmVv+W6pumDveebuOWQjOOAguiuvui/meS6m+WtkOW6j+WIl+eahOmVv+W6puS4umTvvIzliJnkuIDotp/lvZLlubbmjpLluo/nmoTov4fnqIvmmK/vvJpcclxuIOS7jmo9MOW8gOWni++8jOS+neasoeWwhuebuOmCu+eahOS4pOS4quacieW6j+WtkOW6j+WIl1xyXG4gUltq4oCmaitkLTFd5ZKMUltqK2TigKZqKzJkLTFd6L+b6KGM5b2S5bm277yb5q+P5qyh5b2S5bm25Lik5Liq5a2Q5bqP5YiX5ZCO77yMauWQjuenu+WKqDJk5Liq5L2N572u77yM5Y2zXHJcbiBqPWorMmTvvJvoi6XliankuIvnmoTlhYPntKDkuI3otrPkuKTkuKrlrZDluo/liJfml7bvvIzliIbku6XkuIvkuKTnp43mg4XlhrXlpITnkIbvvJpcclxuIOKRoCAg5Ymp5LiL55qE5YWD57Sg5Liq5pWwPmTvvJrlho3osIPnlKjkuIDmrKHkuIrov7Dov4fnqIvvvIzlsIbkuIDkuKrplb/luqbkuLpk55qE5a2Q5bqP5YiX5ZKM5LiN6LazZOeahOWtkOW6j+WIl+i/m+ihjOW9kuW5tu+8m1xyXG4g4pGhICDliankuIvnmoTlhYPntKDkuKrmlbDiiaRk77ya5bCG5Ymp5LiL55qE5YWD57Sg5L6d5qyh5aSN5Yi25Yiw5b2S5bm25ZCO55qE5bqP5YiX5Lit44CCXHJcblxyXG5cclxuIDMu566X5rOV5YiG5p6QXHJcbuWFt+aciW7kuKrlvoXmjpLluo/orrDlvZXnmoTlvZLlubbmrKHmlbDmmK/jj5Iybu+8jOiAjOS4gOi2n+W9kuW5tueahOaXtumXtOWkjeadguW6puS4uk8obinvvIzliJnmlbTkuKrlvZLlubbmjpLluo/nmoTml7bpl7TlpI3mnYLluqbml6DorrrmmK/mnIDlpb3ov5jmmK/mnIDlnY/mg4XlhrXlnYfkuLpPKG7jj5IybinjgILlnKjmjpLluo/ov4fnqIvkuK3vvIzkvb/nlKjkuobovoXliqnlkJHph49EUu+8jOWkp+Wwj+S4juW+heaOkuW6j+iusOW9leepuumXtOebuOWQjO+8jOWImeepuumXtOWkjeadguW6puS4uk8obinjgILlvZLlubbmjpLluo/mmK/nqLPlrprnmoTjgIJcclxuXHJcbiAqL1xyXG5cclxudmFyIG5Db3VudCA9IDA7XHJcbnZhciBub25SZWN1cnNpdmVDb3VudCA9IDA7XHJcbnZhciByZWN1cnNpdmVDb3VudCA9IDA7XHJcblxyXG4vKipcclxuICog5bCG5pyJ5bqP55qEc3JbczEuLmUxXeWSjHNyW3MyLi5lMl3lvZLlubbkuLrmnInluo/nmoR0cltzMS4uZTJdXHJcbiAqIEBwYXJhbSBzclxyXG4gKiBAcGFyYW0gczFcclxuICogQHBhcmFtIGUxXHJcbiAqIEBwYXJhbSBlMlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2Uoc3IsIHMxLCBlMSwgZTIsIGNvbXApe1xyXG4gICAgdmFyIHRlbXAgPSBbXTtcclxuICAgIHZhciBpID0gczE7XHJcbiAgICB2YXIgaiA9IGUxICsgMTtcclxuICAgIHZhciBrID0gMDtcclxuXHJcbiAgICB3aGlsZShpIDw9IGUxICYmIGogPD0gZTIpe1xyXG4gICAgICAgIGlmKGNvbXAoc3JbaV0sIHNyW2pdKSA8IDApIHRlbXBbaysrXSA9IHNyW2krK107XHJcbiAgICAgICAgZWxzZSB0ZW1wW2srK10gPSBzcltqKytdO1xyXG4gICAgfVxyXG4gICAgd2hpbGUoaSA8PSBlMSkgdGVtcFtrKytdID0gc3JbaSsrXTtcclxuICAgIHdoaWxlKGogPD0gZTIpIHRlbXBbaysrXSA9IHNyW2orK107XHJcblxyXG4gICAgLy8g5aSN5Yi25Zue5Y67XHJcbiAgICBmb3IoaSA9IHMxLCBrID0gMDsgaSA8PSBlMjsgKytpLCArK2spIHNyW2ldID0gdGVtcFtrXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIDIt6Lev5b2S5bm25o6S5bqP6YCS5b2S566X5rOVXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZVNvcnRSZWN1cnNpdmUoc3IsIHMsIHQsIGNvbXApe1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgaWYocyA9PSBudWxsKSBzID0gMDtcclxuICAgIGlmKHQgPT0gbnVsbCkgdCA9IHNyLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgaWYocyA+PSB0KSByZXR1cm47XHJcblxyXG4gICAgLy8g5bCGc3Jbcy4udF3lubPliIbkuLpzcltzLi5tXeWSjHNyW20rMS4udF1cclxuICAgIHZhciBtID0gKHMgKyB0KSA+PiAxO1xyXG4gICAgLy8g6YCS5b2S5Zyw5bCGc3Jbcy4ubV3lvZLlubbkuLrmnInluo/nmoRzcltzLi5tXVxyXG4gICAgbWVyZ2VTb3J0UmVjdXJzaXZlKHNyLCBzLCBtLCBjb21wKTtcclxuICAgIC8vIOmAkuW9kuWcsOWwhnNyW20rMS4udF3lvZLlubbkuLrmnInluo/nmoRzclttKzEuLnRdXHJcbiAgICBtZXJnZVNvcnRSZWN1cnNpdmUoc3IsIG0gKyAxLCB0LCBjb21wKTtcclxuICAgIC8vIOWwhnNyW3MuLm1d5ZKMc3JbbSsxLi50XeW9kuW5tuWIsHNyW3MuLnRdO1xyXG4gICAgbWVyZ2Uoc3IsIHMsIG0sIHQsIGNvbXApO1xyXG59XHJcbmV4cG9ydHMubWVyZ2VTb3J0UmVjdXJzaXZlID0gbWVyZ2VTb3J0UmVjdXJzaXZlO1xyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdcXG5cXG5tZXJnZVNvcnRSZWN1cnNpdmU6Jyk7XHJcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XHJcbm1lcmdlU29ydFJlY3Vyc2l2ZShhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIG1lcmdlU29ydE5vblJlY3Vyc2l2ZShzciwgY29tcCl7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICB2YXIgaiwgaztcclxuICAgIGZvcih2YXIgZCA9IDEsIG4gPSBzci5sZW5ndGggLSAxOyBkIDwgbjsgZCAqPSAyKSB7XHJcbiAgICAgICAgLy8g5LiA6Laf5b2S5bm25o6S5bqP566X5rOVXHJcbiAgICAgICAgaiA9IDA7XHJcblxyXG4gICAgICAgIC8vIOWtkOW6j+WIl+S4pOS4pOW9kuW5tlxyXG4gICAgICAgIHdoaWxlKChrID0gKGogKyAyICogZCAtIDEpKSA8IG4pe1xyXG4gICAgICAgICAgICBtZXJnZShzciwgaiwgIGogKyBkIC0gMSwgaywgY29tcCk7XHJcbiAgICAgICAgICAgIGogPSBrICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWJqeS9meWFg+e0oOS4quaVsOi2hei/h+S4gOS4quWtkOW6j+WIl+mVv+W6plxyXG4gICAgICAgIGlmKGogKyBkIC0gMSA8IG4pIG1lcmdlKHNyLCBqLCBqICsgZCAtIDEsIG4sIGNvbXApO1xyXG4gICAgICAgIC8vIOWJqeS9meWtkOW6j+WIl+WkjeWItlxyXG4gICAgICAgIGVsc2UgbWVyZ2Uoc3IsIGosIG4sIG4sIGNvbXApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlID0gbWVyZ2VTb3J0Tm9uUmVjdXJzaXZlO1xyXG5cclxuY29uc29sZS5sb2coJ1xcbm1lcmdlU29ydE5vblJlY3Vyc2l2ZTonKTtcclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlKGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vLyDoh6rnhLblkIjlubbmjpLluo9cclxuLy8gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9saXVzaGFuZzA0MTkvYXJjaGl2ZS8yMDExLzA5LzE5LzIxODE0NzYuaHRtbFxyXG4vLyBodHRwOi8vd3d3LmNuYmxvZ3MuY29tL2xhbmtlL2FyY2hpdmUvMjAxMy8wMS8xNS8yODYwNDg3Lmh0bWxcclxuLypcclxu6Ieq54S25b2S5bm25piv5b2S5bm25o6S5bqP55qE5LiA5Liq5Y+Y5b2i77yM5pWI546H5pu06auY5LiA5Lqb77yM5Y+v5Lul5Zyo5b2S5bm25o6S5bqP6Z2e6YCS5b2S5a6e546w55qE5Z+656GA5LiK6L+b6KGM5L+u5pS5LuWvueS6juW3sue7j+S4gOS4quW3sue7j+e7meWumuaVsOe7hGEs6YCa5bi45a2Y5Zyo5aSa5Liq6ZW/5bqm5aSn5LqOMeeahOW3sue7j+iHqueEtuaOkuWlveeahOWtkOaVsOe7hOautSzlm6DmraTnlKjkuIDmrKHlr7nmlbDnu4Rh55qE57q/5oCn5omr5o+P5bCx5Y+v5Lul5om+5Ye65omA5pyJ6L+Z5Lqb5o6S5aW95bqP55qE5a2Q5pWw57uE5q61LOeEtuWQjuWGjeWvuei/meS6m+WtkOaVsOe7hOauteS/qeS/qeWQiOW5ti5cclxuICovXHJcblxyXG5cclxuLy8g5omr5o+P5b6X5Yiw5a2Q5Liy55qE5Ye95pWwXHJcbmZ1bmN0aW9uIHBhc3Moc3FMaXN0LCByZWMsIGNvbXApe1xyXG4gICAgdmFyIG51bSA9IDA7XHJcbiAgICByZWNbbnVtKytdID0gMDtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHJlY1tudW0rK10gPSBpICsgMTtcclxuICAgIH1cclxuICAgIHJlY1tudW0rK10gPSBsZW47XHJcblxyXG4gICAgcmV0dXJuIG51bTtcclxufVxyXG5cclxuZnVuY3Rpb24gbmF0dXJlTWVyZ2VTb3J0KHNxTGlzdCwgY29tcCl7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICB2YXIgcmVjID0gW107XHJcblxyXG4gICAgLy9udW09MuivtOaYjuW3sue7j+aOkuWlveW6j+S6hlxyXG4gICAgLy/mr4/lvqrnjq/kuIDmrKHvvIzov5vooYzkuIDmrKFwYXNzKCnmk43kvZxcclxuICAgIGZvcih2YXIgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCk7IG51bSAhPT0gMjsgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCkpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgKyAyIDwgbnVtOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgbWVyZ2Uoc3FMaXN0LCByZWNbaV0sIHJlY1tpICsgMV0gLSAxLCByZWNbaSArIDJdIC0gMSwgY29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnRzLm5hdHVyZU1lcmdlU29ydCA9IG5hdHVyZU1lcmdlU29ydDtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5uYXR1cmVNZXJnZVNvcnQ6Jyk7XHJcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XHJcbm5hdHVyZU1lcmdlU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuY29uc29sZS5sb2cocmVjdXJzaXZlQ291bnQpO1xyXG5jb25zb2xlLmxvZyhub25SZWN1cnNpdmVDb3VudCk7XHJcbmNvbnNvbGUubG9nKG5Db3VudCk7XHJcblxyXG4vLyDlj4zlkJHoh6rnhLblkIjlubbmjpLluo/nrpfms5VcclxuLypcclxu5Y+M5ZCR6Ieq54S25ZCI5bm25o6S5bqP5piv5qC55o2u5qyy5o6S5bqP5pWw5o2u5bGA6YOo5LiN5piv5Y2H5bqP5bCx5piv6ZmN5bqP55qE6Ieq54S25pyJ5bqP54m554K5LOWFiOe6v+aAp+aJq+aPj+WHuuiHqueEtuacieW6j+eahOWtkOaVsOe7hOautSzlho3ov5vooYzlkIjlubbmjpLluo8u5omr5o+P5pe255qE5pyJ5bqP5pWw5q616ZW/5bqm6LaK6ZW/LOauteaVsOi2iuWwkSzlr7nlupTlkIjlubbmoJHnmoTlsYLmlbDlsLHkvJrotorlsJEs566X5rOV55qE5pWI546H6LaK6auYLlxyXG4gKi9cclxudmFyIG5hdHVyYWxNZXJnZVNvcnQgPSAoZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBuYXR1cmFsTWVyZ2VTb3J0O1xyXG5cclxuICAgIGZ1bmN0aW9uIG5hdHVyYWxNZXJnZVNvcnQoYSwgY29tcCl7XHJcbiAgICAgICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgICAgIHZhciBiID0gW107XHJcbiAgICAgICAgdmFyIG4gPSBhLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSghbWVyZ2VSdW5zKGEsIGIsIG4sIGNvbXApKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVJ1bnMoYSwgYiwgbiwgY29tcCl7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICB2YXIgYXNjID0gdHJ1ZTtcclxuICAgICAgICB2YXIgeDtcclxuXHJcbiAgICAgICAgd2hpbGUoaSA8IG4pe1xyXG4gICAgICAgICAgICBrID0gaTtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5pyA5ZCO5LiA5Liq6YCS5aKe5bqP5YiX5YWD57SgXHJcbiAgICAgICAgICAgIGRvIHggPSBhW2krK107IHdoaWxlKGkgPCBuICYmIGNvbXAoeCwgYVtpXSkgPD0gMCk7XHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOacgOWQjuS4gOS4qumAkuWHj+W6j+WIl+WFg+e0oFxyXG4gICAgICAgICAgICB3aGlsZShpIDwgbiAmJiBjb21wKHgsIGFbaV0pID49IDApIHggPSBhW2krK107XHJcbiAgICAgICAgICAgIC8vIOW9kuW5tumAkuWinuW6j+WIl+WSjOmAkuWHj+W6j+WIl++8jOe7k+aenOWPr+iDvemAkuWinuaIlumAkuWHj1xyXG4gICAgICAgICAgICBtZXJnZShhLCBiLCBrLCBpIC0gMSwgYXNjLCBjb21wKTtcclxuICAgICAgICAgICAgYXNjID0gIWFzYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOW9k2vnrYnkuo4w5pe25Luj6KGoYeW3sue7j+aOkuWlveW6j+S6hlxyXG4gICAgICAgIHJldHVybiBrID09PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIsIGxvdywgaGlnaCwgYXNjLCBjb21wKXtcclxuICAgICAgICB2YXIgayA9IGFzYyA/IGxvdyA6IGhpZ2g7XHJcbiAgICAgICAgdmFyIGMgPSBhc2MgPyAxIDogLTE7XHJcbiAgICAgICAgdmFyIGkgPSBsb3c7XHJcbiAgICAgICAgdmFyIGogPSBoaWdoO1xyXG5cclxuICAgICAgICB3aGlsZShpIDw9IGope1xyXG4gICAgICAgICAgICBpZihjb21wKGFbaV0sIGFbal0pIDw9IDApIGJba10gPSBhW2krK107XHJcbiAgICAgICAgICAgIGVsc2UgYltrXSA9IGFbai0tXTtcclxuICAgICAgICAgICAgayArPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IoaSA9IGsgPSBsb3csIGogPSBoaWdoOyBpIDw9IGo7ICsraSwgKytrKSBhW2ldID0gYltrXTtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbmV4cG9ydHMubmF0dXJhbE1lcmdlU29ydCA9IG5hdHVyYWxNZXJnZVNvcnQ7XHJcblxyXG5jb25zb2xlLmxvZygnXFxubmF0dXJhbE1lcmdlU29ydDonKTtcclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxubmF0dXJhbE1lcmdlU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuLy8g6ZO+6KGo5a2Y5YKo57uT5p6E55qE6Ieq54S25ZCI5bm25o6S5bqPXHJcbnZhciBsaW5rZWRMaXN0TmF0dXJhbE1lcmdlU29ydCA9IChmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG1lcmdlU29ydDtcclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQobGlua2VkbGlzdCwgbmVlZFJlcGxhY2UsIGNvbXApe1xyXG4gICAgICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgICAgICBpZighbGlua2VkbGlzdCkgcmV0dXJuIGxpbmtlZGxpc3Q7XHJcblxyXG4gICAgICAgIHZhciBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHZhciBsaXN0ID0gbGlua2VkbGlzdC5oZWFkO1xyXG5cclxuICAgICAgICBpZighbGlzdCB8fCAhbGlzdC5uZXh0KSByZXR1cm4gbGlua2VkbGlzdDtcclxuXHJcbiAgICAgICAgbmVlZFJlcGxhY2UgPSBuZWVkUmVwbGFjZSA9PSBudWxsID8gdHJ1ZSA6IG5lZWRSZXBsYWNlO1xyXG4gICAgICAgIHZhciB1ID0gbGlzdDtcclxuICAgICAgICB2YXIgdCA9IGxpc3Q7XHJcbiAgICAgICAgdmFyIHY7XHJcbiAgICAgICAgLy8g5bCG6YCS5aKe55qE57uT54K55pS+5YWl5Yiw6Zif5YiX5Lit77yI5Lya6KKr5YiH5pat77yJXHJcbiAgICAgICAgZm9yKDsgdDsgdCA9IHUpe1xyXG4gICAgICAgICAgICB3aGlsZSh1ICYmIHUubmV4dCAmJiBjb21wKHUuZGF0YSwgdS5uZXh0LmRhdGEpIDw9IDApXHJcbiAgICAgICAgICAgICAgICB1ID0gdS5uZXh0O1xyXG4gICAgICAgICAgICB2ID0gdTtcclxuICAgICAgICAgICAgdSA9IHUubmV4dDtcclxuICAgICAgICAgICAgdi5uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgcXVldWUuZW5RdWV1ZSh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgLy8g5ZCI5bm257uT54K5XHJcbiAgICAgICAgd2hpbGUocXVldWUuc2l6ZSl7XHJcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUodCk7XHJcbiAgICAgICAgICAgIHZhciBhID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgdCA9IG1lcmdlKGEsIGIsIGNvbXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYobmVlZFJlcGxhY2UpIGxpbmtlZGxpc3QuaGVhZCA9IHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIsIGNvbXApe1xyXG4gICAgICAgIHZhciBjID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgICAgICB2YXIgaGVhZCA9IHtkYXRhOiBudWxsLCBuZXh0OiBudWxsfTtcclxuICAgICAgICBjLmhlYWQgPSBoZWFkO1xyXG4gICAgICAgIGMgPSBjLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlKGEgJiYgYil7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoYS5kYXRhLCBiLmRhdGEpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgYy5uZXh0ID0gYTtcclxuICAgICAgICAgICAgICAgIGMgPSBhO1xyXG4gICAgICAgICAgICAgICAgYSA9IGEubmV4dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMubmV4dCA9IGI7XHJcbiAgICAgICAgICAgICAgICBjID0gYjtcclxuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubmV4dCA9IGEgPyBhIDogYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhlYWQubmV4dDtcclxuICAgIH1cclxufSkoKTtcclxuZXhwb3J0cy5saW5rZWRMaXN0TmF0dXJhbE1lcmdlU29ydCA9IGxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0O1xyXG5cclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxudmFyIGxpbmtlZExpc3QgPSBuZXcgTGlua2VkTGlzdChhcnIpO1xyXG5saW5rZWRMaXN0TmF0dXJhbE1lcmdlU29ydChsaW5rZWRMaXN0KTtcclxuY29uc29sZS5sb2cobGlua2VkTGlzdCArICcnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9Tb3J0L21lcmdpbmcvaW5kZXguanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsdWtlIG9uIDIwMTUvMi8yLlxyXG4gKi9cclxuXHJcbnZhciBkZWZhdWx0Q29tcGFyZSA9IHJlcXVpcmUoJy4uL2RlZmF1bHRDb21wYXJpc2lvbicpO1xyXG5cclxuLypcclxu6YCJ5oup5o6S5bqPXHJcblxyXG7pgInmi6nmjpLluo8oU2VsZWN0aW9uIFNvcnQp55qE5Z+65pys5oCd5oOz5piv77ya5q+P5qyh5LuO5b2T5YmN5b6F5o6S5bqP55qE6K6w5b2V5Lit6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V6KGo77yM54S25ZCO5LiO5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX5Lit55qE56ys5LiA5Liq6K6w5b2V6L+b6KGM5Lqk5o2i77yM55u05Yiw5pW05Liq6K6w5b2V5bqP5YiX5pyJ5bqP5Li65q2i44CCXHJcblxyXG5cclxu566A5Y2V6YCJ5oup5o6S5bqPXHJcblxyXG7nroDljZXpgInmi6nmjpLluo8oU2ltcGxlIFNlbGVjdGlvbiBTb3J0IO+8jOWPiOensOS4uuebtOaOpemAieaLqeaOkuW6jynnmoTln7rmnKzmk43kvZzmmK/vvJrpgJrov4duLWnmrKHlhbPplK7lrZfpl7TnmoTmr5TovoPvvIzku45uLWkrMeS4quiusOW9leS4remAieWPluWFs+mUruWtl+acgOWwj+eahOiusOW9le+8jOeEtuWQjuWSjOesrGnkuKrorrDlvZXov5vooYzkuqTmjaLvvIxpPTEsIDIsIOKApiBuLTEg44CCXHJcbjEgIOaOkuW6j+ekuuS+i1xyXG7kvovvvJrorr7mnInlhbPplK7lrZfluo/liJfkuLrvvJo3LCA0LCAtMiwgMTksIDEzLCA277yM55u05o6l6YCJ5oup5o6S5bqP55qE6L+H56iL77yaXHJcbuWIneWni+iusOW9leeahOWFs+mUruWtl++8miAgNyAgICAgNCAgICAtMiAgICAgMTkgICAgMTMgICAgNlxyXG4gICAg56ys5LiA6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNyAgICAgMTkgICAgMTMgICAgNlxyXG4gICAg56ys5LqM6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNyAgICAgMTkgICAgMTMgICAgNlxyXG4gICAg56ys5LiJ6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgMTkgICAgMTMgICAgN1xyXG4gICAg56ys5Zub6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgNyAgICAgMTMgICAgMTlcclxuICAgIOesrOS6lOi2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDcgICAgIDEzICAgIDE5XHJcbiAgICDnrKzlha3otp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICA3ICAgICAxMyAgICAxOVxyXG5cclxuMi7nrpfms5XliIbmnpBcclxu5pW05Liq566X5rOV5piv5LqM6YeN5b6q546v77ya5aSW5b6q546v5o6n5Yi25o6S5bqP55qE6Laf5pWw77yM5a+5buS4quiusOW9lei/m+ihjOaOkuW6j+eahOi2n+aVsOS4um4tMei2n++8m+WGheW+queOr+aOp+WItuavj+S4gOi2n+eahOaOkuW6j+OAglxyXG7ov5vooYznrKxp6Laf5o6S5bqP5pe277yM5YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw5Li6bi1p77yM5YiZ77yaXHJcbuavlOi+g+asoeaVsO+8miBuKihuIC0gMSkgLyAyXHJcbuaXtumXtOWkjeadguW6puaYr++8mlQobik9TyhuMilcclxu56m66Ze05aSN5p2C5bqm5piv77yaUyhuKT1PKDEpXHJcbuS7juaOkuW6j+eahOeos+WumuaAp+adpeeci++8jOebtOaOpemAieaLqeaOkuW6j+aYr+S4jeeos+WumueahOOAglxyXG5cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gc2ltcGxlU2VsZWN0aW9uU29ydChzcUxpc3QsIGNvbXApIHtcclxuICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICBmb3IgKHZhciBrID0gaSwgaiA9IGsgKyAxOyBqIDwgbGVuOyArK2opXHJcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtqXSwgc3FMaXN0W2tdKSA8IDApIGsgPSBqO1xyXG5cclxuICAgICAgICBpZiAoayAhPT0gaSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtrXTtcclxuICAgICAgICAgICAgc3FMaXN0W2tdID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICBzcUxpc3RbaV0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNpbXBsZVNlbGVjdGlvblNvcnQgPSBzaW1wbGVTZWxlY3Rpb25Tb3J0O1xyXG5cclxudmFyIGFyciA9IFs3LCA0LCAtMiwgMTksIDEzLCA2XTtcclxuc2ltcGxlU2VsZWN0aW9uU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuLypcclxu5qCR5b2i6YCJ5oup5o6S5bqPXHJcblxyXG7pppblhYjlr7lu5Liq6K6w5b2V55qE5YWz6ZSu5a2X5Lik5Lik6L+b6KGM5q+U6L6D77yM6YCJ5Y+W74Opbi8y74O55Liq6L6D5bCP6ICF77yb54S25ZCO6L+Z74Opbi8y74O55Liq6L6D5bCP6ICF5Lik5Lik6L+b6KGM5q+U6L6D77yM6YCJ5Y+W74Opbi8074O55Liq6L6D5bCP6ICF4oCmIOWmguatpOmHjeWkje+8jOebtOWIsOWPquWJqTHkuKrlhbPplK7lrZfkuLrmraLjgIJcclxu6K+l6L+H56iL5Y+v55So5LiA5qO15pyJbuS4quWPtuWtkOe7k+eCueeahOWujOWFqOS6jOWPieagkeihqOekuu+8jOavj+S4quaenee7k+eCueeahOWFs+mUruWtl+mDveetieS6juWFtuW3puOAgeWPs+WtqeWtkOe7k+eCueS4rei+g+Wwj+eahOWFs+mUruWtl++8jOaguee7k+eCueeahOWFs+mUruWtl+WwseaYr+acgOWwj+eahOWFs+mUruWtl+OAglxyXG7ovpPlh7rmnIDlsI/lhbPplK7lrZflkI7vvIzmoLnmja7lhbPns7vnmoTlj6/kvKDpgJLmgKfvvIzmrLLpgInlj5bmrKHlsI/lhbPplK7lrZfvvIzlj6rpnIDlsIblj7blrZDnu5PngrnkuK3nmoTmnIDlsI/lhbPplK7lrZfmlLnkuLrigJzmnIDlpKflgLzigJ0g77yM54S25ZCO6YeN5aSN5LiK6L+w5q2l6aqk5Y2z5Y+v44CCXHJcbuWQq+aciW7kuKrlj7blrZDnu5PngrnnmoTlrozlhajkuozlj4nmoJHnmoTmt7HluqbkuLrvg6njj5Iybu+DuSsx77yM5YiZ5oC755qE5pe26Ze05aSN5p2C5bqm5Li6Tyhu44+SMm4pIOOAglxyXG5cclxu5L2G6L+Z56eN5o6S5bqP5pa55rOV5bCa5pyJ6L6F5Yqp5a2Y5YKo56m66Ze06L6D5aSaLOWSjOacgOWkp+WAvOi/m+ihjOWkmuS9meavlOi+g+etiee8uueCueOAguS4uuS6huW8peihpei/meS6m+e8uumZt++8jOWHuueOsOS6huWPpuS4gOenjemAieaLqeaOkuW6jy0tLeWghuaOkuW6j1xyXG4gKi9cclxuXHJcblxyXG5cclxuLypcclxu5aCG5o6S5bqPXHJcblxyXG4xICDloIbnmoTlrprkuYlcclxu5pivbuS4quWFg+e0oOeahOW6j+WIl0g9e2sxLCBrMiAsIOKApiBrbn0g77yM5ruh6Laz77yaXHJcbiAgICBraeKJpGsyaSAgICAgICDlvZMyaeKJpG7ml7ZcclxuICAgIGtp4omkazJpKzEgICDlvZMyaSsx4omkbuaXtlxyXG5cclxu55Sx5aCG55qE5a6a5LmJ55+l77yM5aCG5piv5LiA5qO15LulazHkuLrmoLnnmoTlrozlhajkuozlj4nmoJHjgILoi6Xlr7nor6Xkuozlj4nmoJHnmoTnu5Pngrnov5vooYznvJblj7co5LuO5LiK5Yiw5LiL77yM5LuO5bem5Yiw5Y+zKe+8jOW+l+WIsOeahOW6j+WIl+WwseaYr+WwhuS6jOWPieagkeeahOe7k+eCueS7pemhuuW6j+e7k+aehOWtmOaUvu+8jOWghueahOe7k+aehOato+WlveWSjOivpeW6j+WIl+e7k+aehOWujOWFqOS4gOiHtOOAglxyXG5cclxuMiAg5aCG55qE5oCn6LSoXHJcbiAgICAxKSAg5aCG5piv5LiA5qO16YeH55So6aG65bqP5a2Y5YKo57uT5p6E55qE5a6M5YWo5LqM5Y+J5qCR77yMIGsx5piv5qC557uT54K577ybXHJcbiAgICAyKSAg5aCG55qE5qC557uT54K55piv5YWz6ZSu5a2X5bqP5YiX5Lit55qE5pyA5bCPKOaIluacgOWkpynlgLzvvIzliIbliKvnp7DkuLrlsI8o5oiW5aSnKeagueWghu+8m1xyXG4gICAgMykgIOS7juaguee7k+eCueWIsOavj+S4gOWPtuWtkOe7k+eCuei3r+W+hOS4iueahOWFg+e0oOe7hOaIkOeahOW6j+WIl+mDveaYr+aMieWFg+e0oOWAvCjmiJblhbPplK7lrZflgLwp6Z2e6YCS5YePKOaIlumdnumAkuWininnmoTvvJtcclxuICAgIDQpICDloIbkuK3nmoTku7vkuIDlrZDmoJHkuZ/mmK/loIbjgIJcclxuXHJcbuWIqeeUqOWghumhtuiusOW9leeahOWFs+mUruWtl+WAvOacgOWwjyjmiJbmnIDlpKcp55qE5oCn6LSo77yM5LuO5b2T5YmN5b6F5o6S5bqP55qE6K6w5b2V5Lit5L6d5qyh6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCPKOaIluacgOWkpynnmoTorrDlvZXvvIzlsLHlj6/ku6Xlrp7njrDlr7nmlbDmja7orrDlvZXnmoTmjpLluo/vvIzov5nnp43mjpLluo/mlrnms5Xnp7DkuLrloIbmjpLluo/jgIJcclxuXHJcbjMgIOWghuaOkuW6j+aAneaDs1xyXG5cclxu4pGgICDlr7nkuIDnu4TlvoXmjpLluo/nmoTorrDlvZXvvIzmjInloIbnmoTlrprkuYnlu7rnq4vloIbvvJtcclxu4pGhICDlsIbloIbpobborrDlvZXlkozmnIDlkI7kuIDkuKrorrDlvZXkuqTmjaLkvY3nva7vvIzliJnliY1uLTHkuKrorrDlvZXmmK/ml6Dluo/nmoTvvIzogIzmnIDlkI7kuIDkuKrorrDlvZXmmK/mnInluo/nmoTvvJtcclxu4pGiICDloIbpobborrDlvZXooqvkuqTmjaLlkI7vvIzliY1uLTHkuKrorrDlvZXkuI3lho3mmK/loIbvvIzpnIDlsIbliY1uLTHkuKrlvoXmjpLluo/orrDlvZXph43mlrDnu4Tnu4fmiJDkuLrkuIDkuKrloIbvvIznhLblkI7lsIbloIbpobborrDlvZXlkozlgJLmlbDnrKzkuozkuKrorrDlvZXkuqTmjaLkvY3nva7vvIzljbPlsIbmlbTkuKrluo/liJfkuK3mrKHlsI/lhbPplK7lrZflgLznmoTorrDlvZXosIPmlbQo5o6S6ZmkKeWHuuaXoOW6j+WMuu+8m1xyXG7ikaMgIOmHjeWkjeS4iui/sOatpemqpO+8jOebtOWIsOWFqOmDqOiusOW9leaOkuWlveW6j+S4uuatouOAglxyXG5cclxu57uT6K6677ya5o6S5bqP6L+H56iL5Lit77yM6Iul6YeH55So5bCP5qC55aCG77yM5o6S5bqP5ZCO5b6X5Yiw55qE5piv6Z2e6YCS5YeP5bqP5YiX77yb6Iul6YeH55So5aSn5qC55aCG77yM5o6S5bqP5ZCO5b6X5Yiw55qE5piv6Z2e6YCS5aKe5bqP5YiX44CCXHJcblxyXG7loIbmjpLluo/nmoTlhbPplK5cclxu4pGgICDlpoLkvZXnlLHkuIDkuKrml6Dluo/luo/liJflu7rmiJDkuIDkuKrloIbvvJ9cclxu4pGhICDlpoLkvZXlnKjovpPlh7rloIbpobblhYPntKDkuYvlkI7vvIzosIPmlbTliankvZnlhYPntKDvvIzkvb/kuYvmiJDkuLrkuIDkuKrmlrDnmoTloIbvvJ9cclxuXHJcbjQgIOWghueahOiwg+aVtOKAlOKAlOetm+mAiVxyXG7ikbQg5aCG55qE6LCD5pW05oCd5oOzXHJcbui+k+WHuuWghumhtuWFg+e0oOS5i+WQju+8jOS7peWghuS4reacgOWQjuS4gOS4quWFg+e0oOabv+S7o+S5i++8m+eEtuWQjuWwhuaguee7k+eCueWAvOS4juW3puOAgeWPs+WtkOagkeeahOaguee7k+eCueWAvOi/m+ihjOavlOi+g++8jOW5tuS4juWFtuS4reWwj+iAhei/m+ihjOS6pOaNou+8m+mHjeWkjeS4iui/sOaTjeS9nO+8jOebtOWIsOaYr+WPtuWtkOe7k+eCueaIluWFtuWFs+mUruWtl+WAvOWwj+S6juetieS6juW3puOAgeWPs+WtkOagkeeahOWFs+mUruWtl+eahOWAvO+8jOWwhuW+l+WIsOaWsOeahOWghuOAguensOi/meS4quS7juWghumhtuiHs+WPtuWtkOeahOiwg+aVtOi/h+eoi+S4uuKAnOetm+mAieKAneOAglxyXG5cclxu5rOo5oSP77ya562b6YCJ6L+H56iL5Lit77yM5qC557uT54K555qE5bem44CB5Y+z5a2Q5qCR6YO95piv5aCG77yM5Zug5q2k77yM562b6YCJ5piv5LuO5qC557uT54K55Yiw5p+Q5Liq5Y+25a2Q57uT54K555qE5LiA5qyh6LCD5pW06L+H56iL44CCXHJcblxyXG41ICDloIbnmoTlu7rnq4tcclxu5Yip55So562b6YCJ566X5rOV77yM5Y+v5Lul5bCG5Lu75oSP5peg5bqP55qE6K6w5b2V5bqP5YiX5bu65oiQ5LiA5Liq5aCG77yM6K6+UlsxXSxSWzJdLCDigKYsUltuXeaYr+W+heaOkuW6j+eahOiusOW9leW6j+WIl+OAglxyXG7lsIbkuozlj4nmoJHnmoTmr4/mo7XlrZDmoJHpg73nrZvpgInmiJDkuLrloIbjgILlj6rmnInmoLnnu5PngrnnmoTmoJHmmK/loIbjgILnrKzijIpuLzLijIvkuKrnu5PngrnkuYvlkI7nmoTmiYDmnInnu5Pngrnpg73msqHmnInlrZDmoJHvvIzljbPku6XnrKzijIpuLzLijIvkuKrnu5PngrnkuYvlkI7nmoTnu5PngrnkuLrmoLnnmoTlrZDmoJHpg73mmK/loIbjgILlm6DmraTvvIzku6Xov5nkupvnu5PngrnkuLrlt6bjgIHlj7PlranlrZDnmoTnu5PngrnvvIzlhbblt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzliJnov5vooYzkuIDmrKHnrZvpgInlsLHlj6/ku6XmiJDkuLrloIbjgILlkIznkIbvvIzlj6ropoHlsIbov5nkupvnu5PngrnnmoTnm7TmjqXniLbnu5Pngrnov5vooYzkuIDmrKHnrZvpgInlsLHlj6/ku6XmiJDkuLrloIbigKbjgIJcclxu5Y+q6ZyA5LuO56ys4oyKbi8y4oyL5Liq6K6w5b2V5Yiw56ysMeS4quiusOW9leS+neasoei/m+ihjOetm+mAieWwseWPr+S7peW7uueri+WghuOAglxyXG5cclxuNiAgIOWghuaOkuW6j+eul+azleWunueOsFxyXG7loIbnmoTmoLnnu5PngrnmmK/lhbPplK7lrZfmnIDlsI/nmoTorrDlvZXvvIzovpPlh7rmoLnnu5PngrnlkI7vvIzmmK/ku6Xluo/liJfnmoTmnIDlkI7kuIDkuKrorrDlvZXkvZzkuLrmoLnnu5PngrnvvIzogIzljp/mnaXloIbnmoTlt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzliJnov5vooYzkuIDmrKHnrZvpgInlsLHlj6/ku6XmiJDkuLrloIbjgIJcclxuXHJcbjcgIOeul+azleWIhuaekFxyXG7kuLvopoHov4fnqIvvvJrliJ3lp4vlu7rloIblkozph43mlrDosIPmlbTmiJDloIbjgILorr7orrDlvZXmlbDkuLpu77yM5omA5a+55bqU55qE5a6M5YWo5LqM5Y+J5qCR5rex5bqm5Li6aCDjgIJcclxu4peGICDliJ3lp4vlu7rloIbvvJrmr4/kuKrpnZ7lj7blrZDnu5Pngrnpg73opoHku47kuIrliLDkuIvlgZrigJznrZvpgInigJ0g44CC56ysaeWxgue7k+eCueaVsOKJpDJpLTHvvIznu5PngrnkuIvnp7vnmoTmnIDlpKfmt7HluqbmmK9oLWnvvIzogIzmr4/kuIvnp7vkuIDlsYLopoHmr5TovoMy5qyh77yM5YiZ5q+U6L6D5qyh5pWwQzEobinkuLrvvJpcclxuQzEobiniiaQ0KG4t44+SMm4tMSlcclxu4peGICDnrZvpgInosIPmlbTvvJrmr4/mrKHnrZvpgInopoHlsIbmoLnnu5PngrnigJzkuIvmsonigJ3liLDkuIDkuKrlkIjpgILkvY3nva7jgILnrKxp5qyh562b6YCJ5pe277ya5aCG5Lit5YWD57Sg5Liq5pWw5Li6bi1pKzHvvJvloIbnmoTmt7HluqbmmK/vg6vjj5IyKG4taSsxKe+Duysx77yM5YiZ6L+b6KGMbi0x5qyh4oCc562b6YCJ4oCd55qE5q+U6L6D5qyh5pWwQzIobinkuLrvvJpcclxuQzIobik8Mm7jj5IyblxyXG7loIbmjpLluo/nmoTmr5TovoPmrKHmlbDnmoTmlbDph4/nuqfkuLrvvJogVChuKT1PKG7jj5IybinvvJvogIzpmYTliqDnqbrpl7TlsLHmmK/kuqTmjaLml7bmiYDnlKjnmoTkuLTml7bnqbrpl7TvvIzmlYXnqbrpl7TlpI3mnYLluqbkuLrvvJogUyhuKT1PKDEpIOOAglxyXG5cclxu5aCG5o6S5bqP6YCC5ZCI6K6w5b2V5pWw6L6D5aSn55qE5oOF5Ya1XHJcblxyXG5cclxuaHR0cDovL2Jsb2cuY3Nkbi5uZXQvenoxOTg4MDgvYXJ0aWNsZS9kZXRhaWxzLzc2NzgwNTVcclxuICovXHJcblxyXG4vKipcclxuICog5bey55+lc3FMaXN0W3MuLm1d5Lit6K6w5b2V55qE5YWz6ZSu5a2X6Zmkc3FMaXN0W3Nd5LmL5aSW5Z2H5ruh6Laz5aCG55qE5a6a5LmJ77yMXHJcbiAqIOacrOWHveaVsOiwg+aVtHNxTGlzdFtzXeeahOWFs+mUruWtl++8jOS9v3NxTGlzdFtzLi5tXeaIkOS4uuS4gOS4quWkp+Wghumhtu+8iOWvueWFtuS4reWFs+mUruWtl+iAjOiogO+8iVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcUxpc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1cclxuICovXHJcbmZ1bmN0aW9uIGhlYXBBZGp1c3Qoc3FMaXN0LCBzLCBtLCBjb21wKSB7XHJcbiAgICB2YXIgcmMgPSBzcUxpc3Rbc107XHJcblxyXG4gICAgLy8g5rK/5YWz6ZSu5a2X6L6D5aSn55qE5a2p5a2Q57uT54K55ZCR5LiL562b6YCJXHJcbiAgICBmb3IgKHZhciBqID0gMiAqIHMgKyAxOyBqIDw9IG07IGogPSBqICogMiArIDEpIHtcclxuICAgICAgICAvLyBq5Li65YWz6ZSu5a2X6L6D5aSn55qE6K6w5b2V5LiL5qCHXHJcbiAgICAgICAgaWYgKGogPCBtICYmIGNvbXAoc3FMaXN0W2pdLCBzcUxpc3RbaiArIDFdKSA8IDApICsrajtcclxuICAgICAgICAvLyByY+W6lOaPkuWFpeWcqOS9jee9rnPkuIpcclxuICAgICAgICBpZiAoY29tcChyYywgc3FMaXN0W2pdKSA+PSAwKSBicmVhaztcclxuICAgICAgICBzcUxpc3Rbc10gPSBzcUxpc3Rbal07XHJcbiAgICAgICAgcyA9IGo7XHJcbiAgICB9XHJcblxyXG4gICAgc3FMaXN0W3NdID0gcmM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhlYXBTb3J0KHNxTGlzdCwgY29tcCkge1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgdmFyIGxlbiA9IHNxTGlzdC5sZW5ndGg7XHJcbiAgICAvLyDlu7rnq4vlpKfloIbpobZcclxuICAgIGZvciAodmFyIGkgPSAobGVuID4+IDEpIC0gMTsgaSA+PSAwOyAtLWkpXHJcbiAgICAgICAgaGVhcEFkanVzdChzcUxpc3QsIGksIGxlbiAtIDEsIGNvbXApO1xyXG5cclxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPiAwOyAtLWkpIHtcclxuICAgICAgICAvLyDlsIbloIbpobborrDlvZXlkozlvZPliY3mnKrnu4/mjpLluo/lrZDluo/liJdzcUxpc3RbMC4uaV3kuK1cclxuICAgICAgICAvLyDmnIDlkI7kuIDkuKrorrDlvZXnm7jkupLkuqTmjaJcclxuICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbMF07XHJcbiAgICAgICAgc3FMaXN0WzBdID0gdGVtcDtcclxuXHJcbiAgICAgICAgLy8g5bCGc3FMaXN0WzAuLmkgLSAxXemHjeaWsOiwg+aVtOS4uuWkp+WghumhtlxyXG4gICAgICAgIGhlYXBBZGp1c3Qoc3FMaXN0LCAwLCBpIC0gMSwgY29tcCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5oZWFwU29ydCA9IGhlYXBTb3J0O1xyXG5cclxudmFyIGFyciA9IFsxLCAzLCA0LCA1LCA3LCAyLCA2LCA4LCAwXTtcclxuaGVhcFNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9Tb3J0L3NlbGVjdGlvbi9pbmRleC5qc1xuICoqLyIsIi8qKlxyXG4gKiDloIbliIbphY3lrZjlgqjooajnpLpcclxuICpcclxuICog6L+Z56eN5a2Y5YKo6KGo56S655qE54m554K55piv77yM5LuN5Lul5LiA57uE5Zyw5Z2A6L+e57ut55qE5a2Y5YKo5Y2V5YWD5a2Y5pS+5Liy5YC85a2X56ym5bqP5YiX77yM5L2G5a6D5Lus55qE5a2Y5YKo56m66Ze05piv5Zyo56iL5bqP5omn6KGM6L+H56iL5Lit5Yqo5oCB5YiG6YWN6ICM5b6X44CC5ZyoY+ivreiogOS4re+8jOWtmOWcqOS4gOS4quensOS5i+S4uuKAnOWghuKAneeahOiHqueUseWtmOWCqOWMuu+8jOW5tueUsWPor63oqIDnmoTliqjmgIHliIbphY3lh73mlbBtYWxsb2MoKeWSjGZyZWUoKeadpeeuoeeQhuOAguWIqeeUqOWHveaVsG1hbGxvYygp5Li65q+P5Liq5paw5Lqn55Sf55qE5Liy5YiG6YWN5LiA5Z2X5a6e6ZmF5Liy6ZW/5omA6ZyA55qE5a2Y5YKo56m66Ze044CCXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuY2ggPSB7fTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMSA8PSBwb3NpdGlvbiA8PSB0aGlzLmxlbmd0aC7lnKjkuLLnmoTnrKxwb3NpdGlvbuS4quWtl+espuS5i+WJjeaPkuWFpeS4snRIU3RyaW5nXHJcbiAgICBzdHJJbnNlcnQgKHBvc2l0aW9uLCB0SFN0cmluZykge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDEgfHwgcG9zaXRpb24gPiB0aGlzLmxlbmd0aCArIDEpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwb3NpdGlvbicpO1xyXG5cclxuICAgICAgICBpZiAodEhTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIOS4uuaPkuWFpXTogIzohb7lh7rkvY3nva5cclxuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxlbiA9IHBvc2l0aW9uIC0gMTsgaSA+PSBsZW47IC0taSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hbaSArIHRIU3RyaW5nLmxlbmd0aF0gPSB0aGlzLmNoW2ldO1xyXG5cclxuICAgICAgICAgICAgc3RyaW5nQ29weSh0aGlzLmNoLCB0SFN0cmluZy5jaCwgcG9zaXRpb24gLSAxLCB0SFN0cmluZy5sZW5ndGggLSAxLCAwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRIU3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdHJBc3NpZ24gKGNoYXJzKSB7XHJcbiAgICAgICAgc3RyaW5nQ29weSh0aGlzLmNoLCBjaGFycywgMCwgY2hhcnMubGVuZ3RoIC0gMSwgMCk7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjaGFycy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBzdHJMZW5ndGggKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIHN0ckNvbXBhcmUgKHRIU3RyaW5nKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuICYmIGkgPCB0SFN0cmluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hbaV0gIT09IHRIU3RyaW5nLmNoW2ldKSByZXR1cm4gdGhpcy5jaFtpXSAtIHRIU3RyaW5nLmNoW2ldO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0SFN0cmluZy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjbGVhclN0cmluZyAoKSB7XHJcbiAgICAgICAgdGhpcy5jaCA9IHt9O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGNvbmNhdCAocykge1xyXG4gICAgICAgIGxldCB0ID0gbmV3IEhTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgLy8gdC5jaFswLi50aGlzLmxlbmd0aCAtIDFdID0gdGhpcy5jaFswLi50aGlzLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgc3RyaW5nQ29weSh0LmNoLCB0aGlzLmNoLCAwLCB0aGlzLmxlbmd0aCAtIDEsIDApO1xyXG4gICAgICAgIHQubGVuZ3RoID0gdGhpcy5sZW5ndGggKyBzLmxlbmd0aDtcclxuICAgICAgICAvLyB0LmNoW3RoaXMubGVuZ3RoLi50Lmxlbmd0aCAtIDFdID0gcy5jaFswLi5zLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgc3RyaW5nQ29weSh0LmNoLCBzLmNoLCB0aGlzLmxlbmd0aCwgcy5sZW5ndGggLSAxLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICBzdWJzdHJpbmcgKHBvc2l0aW9uLCBsZW4pIHtcclxuICAgICAgICBwb3NpdGlvbiA9IH5+cG9zaXRpb24gfHwgMDtcclxuICAgICAgICBsZW4gPSB+fmxlbiB8fCB0aGlzLmxlbmd0aDtcclxuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpcy5sZW5ndGggLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpcy5sZW5ndGggLSBwb3NpdGlvbilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBhcmFtZXRlcicpO1xyXG5cclxuICAgICAgICBsZXQgc3ViID0gbmV3IEhTdHJpbmcoKTtcclxuICAgICAgICBzdHJpbmdDb3B5KHN1Yi5jaCwgdGhpcy5jaCwgMCwgbGVuIC0gMSwgcG9zaXRpb24pO1xyXG4gICAgICAgIHN1Yi5sZW5ndGggPSBsZW47XHJcblxyXG4gICAgICAgIHJldHVybiBzdWI7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgbGV0IHMgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBzICs9IHRoaXMuY2hbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdDb3B5KGRlc3RpbmF0aW9uLCB0YXJnZXQsIGRlc3RTdGFydCwgbGVuZ3RoLCB0YXJnZXRTdGFydCkge1xyXG4gICAgZGVzdFN0YXJ0ID0gZGVzdFN0YXJ0IHx8IDA7XHJcbiAgICBsZW5ndGggPSBsZW5ndGggfHwgdGFyZ2V0Lmxlbmd0aDtcclxuICAgIHRhcmdldFN0YXJ0ID0gdGFyZ2V0U3RhcnQgfHwgMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uW2Rlc3RTdGFydCArIGldID0gdGFyZ2V0W3RhcmdldFN0YXJ0ICsgaV07XHJcbiAgICB9XHJcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TdHJpbmcvSFN0cmluZy5qc1xuICoqLyIsIi8qKlxyXG4gKiDkuLLnmoTlnZfpk77lrZjlgqjooajnpLpcclxuICpcclxuICog5ZKM57q/5oCn6KGo55qE6ZO+5byP5a2Y5YKo57uT5p6E55u457G75Ly877yM5Lmf5Y+v6YeH55So6ZO+5byP5pa55byP5a2Y5YKo5Liy5YC844CC55Sx5LqO5Liy57uT5p6E55qE54m55q6K5oCnLS3nu5PmnoTkuK3nmoTmr4/kuKrmlbDmja7lhYPntKDmmK/kuIDkuKrlrZfnrKbvvIzliJnnlKjpk77ooajlrZjlgqjkuLLlgLzml7bvvIzlrZjlnKjkuIDkuKrigJznu5PngrnlpKflsI/igJ3nmoTpl67popjvvIzljbPmr4/kuKrnu5Pngrnlj6/ku6XlrZjmlL7kuIDkuKrlrZfnrKbvvIzkuZ/lj6/ku6XlrZjmlL7lpJrkuKrlrZfnrKbjgIJcclxuICog5LiL6Z2i5piv57uT54K55aSn5bCP5Li6NO+8iOWNs+avj+S4que7k+eCueWtmOaUvjTkuKrlrZfnrKbvvInnmoTpk77ooahcclxuICogaGVhZCAtLT4gKGEsYixjLGQpIC0tPiAoZSxmLGcsaCkgLS0+IChpIyMjKVxyXG4gKiDkuIvpnaLmmK/nu5PngrnlpKflsI/kuLox55qE6ZO+6KGoXHJcbiAqIGhlYWQgLS0+IChhKSAtLT4gKGIpIC0tPiAoYykgLS0+IC4uLiAtLT4gKGkpXHJcbiAqXHJcbiAqIOW9k+e7k+eCueWkp+Wwj+Wkp+S6jjHml7bvvIznlLHkuo7kuLLplb/kuI3kuIDlrprmmK/nu5PngrnlpKflsI/nmoTmlbTlgI3mlbDvvIzliJnpk77ooajkuK3nmoTmnIDlkI7kuIDkuKrnu5PngrnkuI3kuIDlrprlhajooqvkuLLlgLzljaDmu6HvvIzmraTml7bpgJrluLjooaXkuIrigJwj4oCd5oiW5YW25a6D6Z2e5Liy5YC85a2X56ym44CCXHJcbiAqIOS4uuS6huS+v+S6jui/m+ihjOS4sueahOaTjeS9nO+8jOW9k+S7pemTvuihqOWtmOWCqOS4suWAvOaXtu+8jOmZpOWktOaMh+mSiOWklui/mOWPr+mZhOiuvuS4gOS4quWwvuaMh+mSiOaMh+ekuumTvuihqOS4reeahOacgOWQjuS4gOS4que7k+eCue+8jOW5tue7meWHuuW9k+WJjeS4sueahOmVv+W6pu+8jOensOWmguatpOWumuS5ieeahOS4suWtmOWCqOe7k+aehOS4uuWdl+mTvue7k+aehOOAglxyXG4gKlxyXG4gKiDnlLHkuo7kuIDoiKzmg4XlhrXkuIvvvIzlr7nkuLLov5vooYzmk43kvZzml7bvvIzlj6rpnIDopoHku47lpLTlkJHlsL7pobrluo/miavmj4/ljbPlj6/vvIzliJnlr7nkuLLlgLzkuI3lv4Xlu7rnq4vlj4zlkJHpk77ooajjgILorr7lsL7mjIfpkojnmoTnm67nmoTmmK/kuLrkuobkvr/kuo7ov5vooYzov57mjqXmk43kvZzvvIzkvYblupTms6jmhI/ov57mjqXml7bpnIDlpITnkIbnrKzkuIDkuKrkuLLlsL7nmoTml6DmlYjlrZfnrKbjgIJcclxuICog5Zyo6ZO+5byP5a2Y5YKo5pa55byP5Lit77yM57uT54K55aSn5bCP55qE6YCJ5oup5ZKM6aG65bqP5a2Y5YKo5pa55byP55qE5qC85byP6YCJ5oup5LiA5qC36YO95b6I6YeN6KaB77yM5a6D55u05o6l5b2x5ZON5Yiw5Liy5aSE55CG55qE5pWI546H44CC5aaC5p6c5Liy5b6I6ZW/77yM6L+Z6KaB5rGC5oiR5Lus6ICD6JmR5Liy5YC855qE5a2Y5YKo5a+G5bqm77yaXHJcbiAqIOWtmOWCqOWvhuW6piA9IOS4suWAvOaJgOWNoOeahOWtmOWCqOS9jSAvIOWunumZheWIhumFjeeahOWtmOWCqOS9jVxyXG4gKlxyXG4gKiDkuLLlgLznmoTpk77lvI/lrZjlgqjnu5PmnoTlr7nmn5DkupvkuLLmk43kvZzvvIzlpoLov57mjqXmk43kvZznrYnmnInkuIDlrprmlrnkvr/kuYvlpITvvIzkvYbmgLvnmoTmnaXor7TkuI3lpoLlj6blpJbkuKTnp43lrZjlgqjnu5PmnoTngbXmtLvvvIzlroPljaDnlKjlrZjlgqjph4/lpKfkuJTmk43kvZzlpI3mnYLjgIJcclxuICovXHJcbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XHJcblxyXG5jbGFzcyBDaHVuayB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaHVua1NpemUgPSA0KSB7XHJcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemU7XHJcbiAgICAgICAgdGhpcy5jaCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNoW2ldID0gJyMnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0eXBlOiBDaHVua1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IoY2h1bmtTaXplID0gNCkge1xyXG4gICAgICAgIC8vIHR5cGUgQ2h1bmtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIC8vIHR5cGU6IGNodW5rXHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICAvLyDkuLLnmoTlvZPliY3plb/luqZcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5bCG5a2X56ym5Liy6L2s5o2i5oiQTFN0cmluZ+exu+Wei1xyXG4gICAgc3RyQXNzaWduIChjaGFycykge1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjaGFycy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjdXJyZW50LmNoW2kgJSB0aGlzLmNodW5rU2l6ZV0gPSBjaGFyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuICYmIChpICsgMSkgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gbmV3IENodW5rKCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50O1xyXG4gICAgfVxyXG4gICAgLy8g5a2X56ym5Liy5a+55q+UXHJcbiAgICAvLyBUT0RPIOaYr+WQpuWOu+aOiWNodW5rU2l6ZeeahOWvueavlFxyXG4gICAgc3RyQ29tcGFyZSAodExTdHJpbmcpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgY3VyVCA9IHRMU3RyaW5nLmhlYWQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdExTdHJpbmcubGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hbaV0gIT09IGN1clQuY2hbaV0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgY3VyVCA9IGN1clQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2xlYXJTdHJpbmcgKCkge1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgY29uY2F0ICh0TFN0aW5nKSB7XHJcbiAgICAgICAgaWYgKCF0TFN0aW5nLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcmV0ID0gbmV3IExTdHJpbmcodGhpcy5jaHVua1NpemUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0TFN0aW5nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXQuaGVhZCA9IHJldC50YWlsID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcclxuICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gcmV0LnRhaWwuY2guaW5kZXhPZignIycpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdExTdGluZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdExTdGluZywgcmV0LnRhaWwsIHRMU3RpbmcuaGVhZCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgc3Vic3RyaW5nIChwb3MsIGxlbikge1xyXG4gICAgICAgIHBvcyA9IH5+cG9zIHx8IDA7XHJcbiAgICAgICAgbGVuID0gfn5sZW4gfHwgdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGggLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpcy5sZW5ndGggLSBwb3MpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwYXJhbWV0ZXInKTtcclxuXHJcbiAgICAgICAgbGV0IHN1YiA9IG5ldyBMU3RyaW5nKHRoaXMuY2h1bmtTaXplKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IGZpbmRQb3NDaHVuayh0aGlzLCBwb3MpO1xyXG4gICAgICAgIGxldCBjdXJTID0gc3ViLmhlYWQgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBzdWIubGVuZ3RoID0gbGVuO1xyXG5cclxuICAgICAgICBvdXRlcmxvb3A6IHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBzaXplID0gdGhpcy5jaHVua1NpemU7IGogPCBzaXplOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcmxvb3A7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clMuY2hbal0gPSBjdXJyZW50LmNoWyhpICsgcG9zKSAlIHRoaXMuY2h1bmtTaXplXTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpICsgcG9zKSAlIHRoaXMuY2h1bmtTaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICUgdGhpcy5jaHVua1NpemUgPT09IDAgJiYgKGN1cnJlbnQuY2hbaV0gfHwgY3VycmVudC5uZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTLm5leHQgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTID0gY3VyUy5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YjtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHJldHVybiAnJztcclxuXHJcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBjdXJyZW50LmNoW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnIycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY3VycmVudC5jaFtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFBvc0NodW5rKGxTdHJpbmcsIHBvcykge1xyXG4gICAgbGV0IGN1cnJlbnQgPSBsU3RyaW5nLmhlYWQ7XHJcbiAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsU3RyaW5nLmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwb3MtLSA9PT0gMCkgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlTdHJpbmcoZGVzdGluYXRpb24sIHRhcmdldCwgY3VyRCwgY3VyclQsIG9mZnNldCkge1xyXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XHJcbiAgICBjdXJyVCA9IGN1cnJUIHx8IHRhcmdldC5oZWFkO1xyXG4gICAgY3VyRCA9IGN1ckQgfHwgZGVzdGluYXRpb24uaGVhZDtcclxuICAgIGxldCBrID0gMDtcclxuXHJcbiAgICB3aGlsZSAoY3VyclQpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGFyZ2V0LmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrLCBrKyspIHtcclxuICAgICAgICAgICAgbGV0IGogPSBrICUgY3VyRC5jaHVua1NpemUgKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGN1ckQuY2hbaiAlIGN1ckQuY2h1bmtTaXplXSA9IGN1cnJULmNoW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKChqICsgMSkgJSBjdXJELmNodW5rU2l6ZSA9PT0gMCAmJiAoY3VyclQuY2hbaSArIDFdIHx8IGN1cnJULm5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJELm5leHQgPSBuZXcgQ2h1bmsoZGVzdGluYXRpb24uY2h1bmtTaXplKTtcclxuICAgICAgICAgICAgICAgIGN1ckQgPSBjdXJELm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN1cnJUID0gY3VyclQubmV4dDtcclxuICAgIH1cclxuXHJcbiAgICBkZXN0aW5hdGlvbi50YWlsID0gY3VyRDtcclxuICAgIGRlc3RpbmF0aW9uLmxlbmd0aCArPSB0YXJnZXQubGVuZ3RoO1xyXG59XHJcblxyXG5sZXQgYSA9IG5ldyBMU3RyaW5nKCk7XHJcbmxldCBiID0gbmV3IExTdHJpbmcoKTtcclxubGV0IGMgPSBuZXcgTFN0cmluZygpO1xyXG5cclxuYS5zdHJBc3NpZ24oJ2FiY2RlZmcnKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuYi5zdHJBc3NpZ24oJ2hpamtsbW5vJyk7XHJcbmNvbnNvbGUubG9nKGIgKyAnJyk7XHJcbmMuc3RyQXNzaWduKCdhYmNkZWZnJyk7XHJcbmNvbnNvbGUubG9nKGEuc3RyQ29tcGFyZShiKSk7XHJcbmNvbnNvbGUubG9nKGEuc3RyQ29tcGFyZShjKSk7XHJcbmxldCB0ID0gYS5jb25jYXQoYik7XHJcbmNvbnNvbGUubG9nKHQgKyAnJyk7XHJcbnQgPSB0LnN1YnN0cmluZygyLCA1KTtcclxuY29uc29sZS5sb2codCArICcnKTtcclxuXHJcblxyXG4vLyDliKTmlq3mmK/lkKbkuLrlm57mloflrZfnrKbkuLJcclxuZnVuY3Rpb24gcGFsaW5kcm9tZShsU3RyKSB7XHJcbiAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgIGxldCBwID0gbFN0ci5oZWFkO1xyXG4gICAgbGV0IGkgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGsgPSAxOyBrIDw9IGxTdHIubGVuZ3RoOyArK2spIHtcclxuICAgICAgICBpZiAoayA8PSBsU3RyLmxlbmd0aCAvIDIpIHN0YWNrLnB1c2gocC5jaFtpXSk7XHJcbiAgICAgICAgZWxzZSBpZiAoayA+IChsU3RyLmxlbmd0aCArIDEpIC8gMikge1xyXG4gICAgICAgICAgICBsZXQgYyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBpZiAocC5jaFtpXSAhPT0gYykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCsraSA9PT0gbFN0ci5jaHVua1NpemUpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU3RyaW5nL0xTdHJpbmcuanNcbiAqKi8iLCIvKipcclxuICog5Liy77yIc3RyaW5n77yJ77yI5oiW5a2X56ym5Liy77yJ5piv55Sx6Zu25Liq5oiW5aSa5Liq5a2X56ym57uE5oiQ55qE5pyJ6ZmQ5bqP5YiX44CC5Liy5Lit5a2X56ym55qE5pWw55uu56ew5Li65Liy55qE6ZW/5bqm44CC6Zu25Liq5a2X56ym55qE5Liy56ew5Li656m65Liy77yIbnVsbCBzdHJpbmfvvInvvIzlroPnmoTplb/luqbkuLrpm7bjgIJcclxuICog5Liy5Lit5Lu75oSP5Liq6L+e57ut55qE5a2X56ym57uE5oiQ55qE5a2Q5bqP5YiX56ew5Li66K+l5Liy55qE5a2Q5Liy44CC5YyF5ZCr5a2Q5Liy55qE5Liy55u45bqU5Zyw56ew5Li65Li75Liy44CC6YCa5bi456ew5a2X56ym5Zyo5bqP5YiX5Lit55qE5bqP5Y+35Li66K+l5a2X56ym5Zyo5Liy5Lit55qE5L2N572u44CC5a2Q5Liy5Zyo5Li75Liy5Lit55qE5L2N572u5YiZ5Lul5a2Q5Liy55qE56ys5LiA5Liq5a2X56ym5Zyo5Li75Liy5Lit55qE5L2N572u5p2l6KGo56S644CCXHJcbiAqIOWPquacieW9k+S4pOS4quS4sueahOmVv+W6puebuOetie+8jOW5tuS4lOWQhOS4quWvueW6lOS9jee9rueahOWtl+espumDveebuOetieaXtuaJjeebuOetieOAglxyXG4gKlxyXG4gKiDkuLLmnIkz56eN5py65YaF6KGo56S65pa55rOV77yaXHJcbiAqIDEu5a6a6ZW/6aG65bqP5a2Y5YKo6KGo56S6XHJcbiAqIDIu5aCG5YiG6YWN5a2Y5YKo6KGo56S6XHJcbiAqIDMu5Liy55qE5Z2X6ZO+5a2Y5YKo6KGo56S6XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIOWumumVv+mhuuW6j+WtmOWCqOihqOekulxyXG4gKiDnsbvkvLzkuo7nur/mgKfooajnmoTpobrluo/lrZjlgqjnu5PmnoTvvIznlKjkuIDnu4TlnLDlnYDov57nu63nmoTlrZjlgqjljZXlhYPlrZjlgqjkuLLlgLzlvpflrZfnrKbluo/liJfjgILlnKjkuLLnmoTlrprplb/pobrluo/lrZjlgqjnu5PmnoTkuK3vvIzmjInnhafpooTlrprkuYnnmoTlpKflsI/vvIzkuLrmr4/kuKrlrprkuYnnmoTkuLLlj5jph4/liIbphY3kuIDkuKrlm7rlrprplb/luqbnmoTlrZjlgqjljLrvvIzliJnlj6/nlKjlrprplb/mlbDnu4TmnaXmj4/ov7DjgIJcclxuICog5Lul5LiL5qCH5Li6MOeahOaVsOe7hOWIhumHj+WtmOaUvuS4sueahOWunumZhemVv+W6puOAglxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3Ioc3RyKXtcclxuICAgICAgICB0aGlzLk1BWFNUUkxFTiA9IDEwO1xyXG4gICAgICAgIGlmIChzdHIpIHtcclxuICAgICAgICAgICAgdGhpc1swXSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHN0ci5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHN0cltpIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6L+U5Zue55SxczHlkoxzMui/nuaOpeiAjOaIkOeahOaWsOS4slxyXG4gICAgY29uY2F0IChzMikge1xyXG4gICAgICAgIGxldCB0ID0gbmV3IFNTdHJpbmcoKTtcclxuICAgICAgICAvLyDmnKrmiKrmlq1cclxuICAgICAgICBpZiAodGhpc1swXSArIHMyWzBdIDw9IHRoaXMuTUFYU1RSTEVOKSB7XHJcbiAgICAgICAgICAgIGNvcHlTdHIyVCh0aGlzKTtcclxuICAgICAgICAgICAgY29weVN0cjJUKHMyLCB0aGlzWzBdKTtcclxuICAgICAgICAgICAgdFswXSA9IHRoaXNbMF0gKyBzMlswXTtcclxuXHJcbiAgICAgICAgICAgIC8vIOaIquaWrVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1swXSA8IHRoaXMuTUFYU1RSTEVOKSB7XHJcbiAgICAgICAgICAgIGNvcHlTdHIyVCh0aGlzKTtcclxuICAgICAgICAgICAgY29weVN0cjJUKHMyLCB0aGlzWzBdLCB0aGlzLk1BWFNUUkxFTiAtIHRoaXNbMF0pO1xyXG4gICAgICAgICAgICB0WzBdID0gdGhpcy5NQVhTVFJMRU47XHJcblxyXG4gICAgICAgICAgICAvLyDmiKrmlq3vvIjku4Xlj5ZzMe+8iVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvcHlTdHIyVCh0aGlzLCAwLCB0aGlzLk1BWFNUUkxFTik7XHJcbiAgICAgICAgICAgIHRbMF0gPSB0aGlzWzBdID0gdGhpcy5NQVhTVFJMRU47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY29weVN0cjJUKHN0ciwgc3RhcnQgPSAwLCBlbmQgPSBzdHJbMF0pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGVuZCB8fCBzdHJbMF07IGkgPD0gbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRbc3RhcnQgKyBpXSA9IHN0cltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN1YnN0cmluZyAocG9zaXRpb24gPSAwLCBsZW4gPSB0aGlzWzBdKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSB+fnBvc2l0aW9uO1xyXG4gICAgICAgIGxlbiA9IH5+bGVuO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzWzBdIC0gMSB8fCBsZW4gPCAwIHx8IGxlbiA+IHRoaXNbMF0gLSBwb3NpdGlvbilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBhcmFtZXRlcicpO1xyXG5cclxuICAgICAgICBsZXQgc3ViID0gbmV3IFNTdHJpbmcoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBzdWJbaV0gPSB0aGlzW3Bvc2l0aW9uICsgaSAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJbMF0gPSBsZW47XHJcblxyXG4gICAgICAgIHJldHVybiBzdWI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIbkuLJz5Lit55qE5a2Q5LiydOabv+aNouS4unbvvIzov5Tlm57mm7/mjaLmrKHmlbBcclxuICAgICAqIHRvZG8gdG8gYmUgdGVzdGVkXHJcbiAgICAgKiBAcGFyYW0ge1NTdHJpbmd9IHRcclxuICAgICAqIEBwYXJhbSB7U1N0cmluZ30gdlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0g5pu/5o2i5qyh5pWwXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2UgKHQsIHYpIHtcclxuICAgICAgICBmb3IgKGxldCBuID0gMCwgaSA9IDE7IGkgPD0gdGhpc1swXSAtIHRbMF0gKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGksIGsgPSAxOyB0W2tdICYmIHRoaXNbal0gPT09IHRba107ICsraiwgKytrKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOS6huS4jnTljLnphY3nmoTlrZfkuLLvvJrliIbkuInnp43mg4XlhrXlpITnkIZcclxuICAgICAgICAgICAgaWYgKGsgPiB0WzBdKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbDtcclxuICAgICAgICAgICAgICAgIC8vIOaWsOWtl+S4sueahOmVv+W6puS4juWOn+WtkOS4suebuOWQjOaXtu+8jOebtOaOpeabv+aNolxyXG4gICAgICAgICAgICAgICAgaWYgKHRbMF0gPT09IHZbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAxOyBsIDw9IHRbMF07ICsrbCkgdGhpc1tpICsgbCAtIDFdID0gdltsXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOaWsOWtkOS4sumVv+W6puWkp+S6juWOn+WtkOS4suaXtu+8jOWFiOWwhuWQjumDqOWPs+enu1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodFswXSA8IHZbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSB0aGlzWzBdOyBsID49IGkgKyB0WzBdOyAtLWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbCArIHZbMF0gLSB0WzBdXSA9IHRoaXNbbF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDE7IGwgPD0gdlswXTsgKytsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2kgKyBsIC0gMV0gPSB2W2xdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOaWsOWtkOS4sumVv+W6puWwj+S6juWOn+WtkOS4suaXtu+8jOWFiOWwhuWQjumDqOW3puenu1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gaSArIHZbMF07IGwgPD0gdGhpc1swXSArIHZbMF0gLSB0WzBdOyArK2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbF0gPSB0aGlzW2wgLSB2WzBdICsgdFswXV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDE7IGwgPD0gdlswXTsgKytsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2kgKyBsIC0gMV0gPSB2W2xdO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzWzBdID0gdGhpc1swXSAtIHRbMF0gKyB2WzBdO1xyXG4gICAgICAgICAgICAgICAgaSArPSB2WzBdO1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyB0aGlzW2ldOyBpKyspIHtcclxuICAgICAgICAgICAgc3RyICs9IHRoaXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICAvLyDov5Tlm57lrZDkuLJzc3RyaW5n5Zyo5Li75Liy5Lit55qE56yscG9zaXRpb27kuKrlrZfnrKbkuYvlkI7nmoTkvY3nva5cclxuICAgIGluZGV4IChzc3RyaW5nLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGxldCBpID0gcG9zaXRpb24gfHwgMTtcclxuICAgICAgICBsZXQgaiA9IDE7XHJcblxyXG4gICAgICAgIHdoaWxlIChpIDw9IHRoaXNbMF0gJiYgaiA8PSBzc3RyaW5nWzBdKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBzc3RyaW5nW2pdKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpID0gaSAtIGogKyAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqID4gc3N0cmluZ1swXSA/IGkgLSBzc3RyaW5nWzBdIDogLTE7XHJcbiAgICB9XHJcbiAgICBrbXBJbmRleCAoc3N0cmluZywgcG9zaXRpb24pIHtcclxuICAgICAgICBsZXQgaSA9IHBvc2l0aW9uIHx8IDE7XHJcbiAgICAgICAgbGV0IGogPSAxO1xyXG4gICAgICAgIGxldCBuZXh0ID0gZ2V0TmV4dChzc3RyaW5nKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gdGhpc1swXSAmJiBqIDw9IHNzdHJpbmdbMF0pIHtcclxuICAgICAgICAgICAgaWYgKGogPT09IDAgfHwgdGhpc1tpXSA9PT0gc3N0cmluZ1tqXSkge1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgKytqO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaiA9IG5leHRbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqID4gc3N0cmluZ1swXSA/IGkgLSBzc3RyaW5nWzBdIDogLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5YyF5ZCr5Zyo5a2X56ym5Liy5Lit6ICMc3Ry5rKh5pyJ55qE5a2X56ym5LiyXHJcbiAgICBzdWJ0cmFjdCAoc3RyKSB7XHJcbiAgICAgICAgbGV0IHIgPSBuZXcgU1N0cmluZygpO1xyXG4gICAgICAgIHJbMF0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzWzBdOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IGMgPSB0aGlzW2ldO1xyXG4gICAgICAgICAgICAvLyDliKTmlq3lvZPliY3lrZfnrKZj5piv5ZCm56ys5LiA5qyh5Ye6546wXHJcbiAgICAgICAgICAgIGxldCBqID0gMTtcclxuICAgICAgICAgICAgZm9yICg7IGogPCBpICYmIHRoaXNbal0gIT09IGM7ICsraik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBqKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDliKTmlq3lvZPliY3lrZfnrKbmmK/lkKbljIXlkKvlnKhzdHLkuK1cclxuICAgICAgICAgICAgICAgIGxldCBrID0gMVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGsgPD0gc3RyWzBdICYmIHN0cltrXSAhPT0gYzsgKytrKTtcclxuICAgICAgICAgICAgICAgIGlmIChrID4gc3RyWzBdKSByWysrclswXV0gPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0b2RvIGJ1ZyBleGlzdHNcclxuICAgIGRlbGV0ZV9zdWJzdHJpbmcgKHN0cikge1xyXG4gICAgICAgIGxldCBuID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzWzBdIC0gc3RyWzBdICsgMTsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gMTtcclxuICAgICAgICAgICAgZm9yICg7IGogPD0gc3RyWzBdICYmIHRoaXNbaSArIGogLSAxXSA9PT0gc3RyW2pdOyArK2opO1xyXG4gICAgICAgICAgICBpZiAoaiA+IHN0clswXSAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBpOyBrIDw9IHRoaXNbMF0gLSBzdHJbMF07ICsraykgdGhpc1trXSA9IHRoaXNbayArIHN0clswXV07XHJcbiAgICAgICAgICAgICAgICB0aGlzWzBdIC09IHN0clswXTtcclxuICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE5leHQoc3N0cmluZykge1xyXG4gICAgbGV0IGkgPSAxO1xyXG4gICAgbGV0IG5leHQgPSB7MTogMH07XHJcbiAgICBsZXQgaiA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBzc3RyaW5nWzBdKSB7XHJcbiAgICAgICAgaWYgKGogPT09IDAgfHwgc3N0cmluZ1tpXSA9PT0gc3N0cmluZ1tqXSkge1xyXG4gICAgICAgICAgICBpZiAoc3N0cmluZ1srK2ldICE9PSBzc3RyaW5nWysral0pIHtcclxuICAgICAgICAgICAgICAgIG5leHRbaV0gPSBqO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV4dFtpXSA9IG5leHRbal07XHJcbiAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgICAgbmV4dFsrK2ldID0gKytqO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGogPSBuZXh0W2pdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxubGV0IGEgPSBuZXcgU1N0cmluZygpO1xyXG5sZXQgYiA9IG5ldyBTU3RyaW5nKCk7XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICBhW2kgKyAxXSA9IGkgKyAnJztcclxuICAgIGJbaSArIDFdID0gaSArICcnO1xyXG59XHJcbmFbMF0gPSBiWzBdID0gNDtcclxubGV0IHQgPSBhLmNvbmNhdChiKTtcclxuY29uc29sZS5sb2codCArICcnKTsgICAgICAgLy8gMDEyMzAxMjNcclxuXHJcbmxldCBkID0gbmV3IFNTdHJpbmcoJ2FjYWJhYWJhYWJjYWNhYWJjJyk7XHJcbmxldCBjID0gbmV3IFNTdHJpbmcoJ2FiYWFiYycpO1xyXG5cclxuY29uc29sZS5sb2coJ2luZGV4OiAnICsgZC5pbmRleChjKSk7XHJcbmNvbnNvbGUubG9nKCdrbXBJbmRleDogJyArIGQua21wSW5kZXgoYykpO1xyXG5cclxuYSA9IG5ldyBTU3RyaW5nKCdhYmNkZWZnJyk7XHJcbmIgPSBuZXcgU1N0cmluZygnYXNkZmcnKTtcclxuY29uc29sZS5sb2coYS5zdWJ0cmFjdChiKSArICcnKTtcclxuXHJcbmEgPSBuZXcgU1N0cmluZygnYWJjZGVmZ2gnKTtcclxuYiA9IG5ldyBTU3RyaW5nKCdjZGVmJyk7XHJcbmNvbnNvbGUubG9nKGEuZGVsZXRlX3N1YnN0cmluZyhiKSArICcnKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuXHJcbi8qXHJcbiDlnKjpobrluo/lrZjlgqjnu5PmnoTkuK3vvIzlrp7njrDkuLLmk43kvZznmoTljp/mk43kvZzkuLrigJzlrZfnrKbkuLLluo/liJfnmoTlpI3liLbigJ3vvIzmk43kvZzml7bpl7TlpI3mnYLluqbln7rkuo7lpI3liLbnmoTlrZfnrKbkuLLluo/liJfnmoTplb/luqbjgIJcclxuIOWPpuS4gOaTjeS9nOeJueeCueaYr++8jOWmguaenOWcqOaTjeS9nOS4reWHuueOsOS4suWAvOW6j+WIl+eahOmVv+W6pui2hei/h01BWFNUUkxFTuaXtu+8jOe6puWumueUqOaIquWwvuazleWkhOeQhu+8jOi/meenjeaDheWGteS4jeS7heWcqOaxgui/nuaOpeS4suaXtuWPr+iDveWPkeeUn++8jOWcqOS4sueahOWFtuS7luaTjeS9nOS4re+8jOWmguaPkuWFpe+8jOe9ruaNouetieS5n+WPr+iDveWPkeeUn++8jOWFi+acjei/meS4quW8iueXheWUr+acieS4jemZkOWumuS4sumVv+eahOacgOWkp+mVv+W6pu+8jOWNs+WKqOaAgeWIhumFjeS4suWAvOeahOWtmOWCqOepuumXtOOAglxyXG4gKi9cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TdHJpbmcvU1N0cmluZy5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGx1a2VsaW4gb24gMjAxNi80LzMwLlxyXG4gKi9cclxuXHJcbmlmKCFwcm9jZXNzLmJyb3dzZXIpe1xyXG4gICAgcmVxdWlyZSgnYmFiZWwtcmVnaXN0ZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBcnJheToge1xyXG4gICAgICAgIENyb3NzTGlzdDogcmVxdWlyZSgnLi9BcnJheS9Dcm9zc0xpc3QnKSxcclxuICAgICAgICBUU01hdHJpeDogcmVxdWlyZSgnLi9BcnJheS9UU01hdHJpeCcpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBCaW5hcnlUcmVlOiB7XHJcbiAgICAgICAgLy8gQmluYXJ5VGhyZWFkVHJlZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRocmVhZFRyZWUnKSxcclxuICAgICAgICBCaW5hcnlUcmVlOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvQmluYXJ5VHJlZScpLFxyXG4gICAgICAgIC8vIEVCVE5vZGU6IHJlcXVpcmUoJy4vQmluYXJ5VHJlZS9FQlROb2RlJyksXHJcbiAgICAgICAgaHVmZk1hbkNvZGluZzogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcnKSxcclxuICAgICAgICAvLyBNRlNldDogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL01GU2V0JyksXHJcbiAgICAgICAgLy8gUEJUTm9kZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL1BCVE5vZGUnKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgR2VuZXJhbGl6ZWRMaXN0OiB7XHJcbiAgICAgICAgR0xpc3Q6IHJlcXVpcmUoJy4vR2VuZXJhbGl6ZWRMaXN0L0dMaXN0JylcclxuICAgIH0sXHJcbiAgICBcclxuICAgIEdyYXBoOiB7XHJcbiAgICAgICAgQWRqYWNlbmN5TGlzdEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL0FkamFjZW5jeUxpc3RHcmFwaCcpLFxyXG4gICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoJyksXHJcbiAgICAgICAgQU1MR3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvQU1MR3JhcGgnKSxcclxuICAgICAgICBPTEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL09MR3JhcGgnKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgTGlzdDoge1xyXG4gICAgICAgIERvdWJsZUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vTGlzdC9Eb3VibGVMaW5rZWRMaXN0JyksXHJcbiAgICAgICAgTGluZWFyTGlzdDogcmVxdWlyZSgnLi9MaXN0L0xpbmVhckxpc3QnKSxcclxuICAgICAgICBTdGF0aWNMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0xpc3QvU3RhdGljTGlua2VkTGlzdCcpLFxyXG4gICAgICAgIExSVUNhY2hlOiByZXF1aXJlKCcuL0xpc3QvTFJVJykuZGVmYXVsdFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgUXVldWU6IHtcclxuICAgICAgICBDeWNsZVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL0N5Y2xlUXVldWUnKSxcclxuICAgICAgICBQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL1ByaW9yaXR5UXVldWUnKSxcclxuICAgICAgICBRdWV1ZTogcmVxdWlyZSgnLi9RdWV1ZS9RdWV1ZScpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBTZWFyY2g6IHtcclxuICAgICAgICBBVkxUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9BVkxUcmVlJyksXHJcbiAgICAgICAgYmluYXJ5U2VhcmNoOiByZXF1aXJlKCcuL1NlYXJjaC9CaW5hcnlTZWFyY2gnKSxcclxuICAgICAgICBCaW5hcnlTb3J0ZWRUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlJyksXHJcbiAgICAgICAgQlBsdXNUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CUGx1c1RyZWUnKSxcclxuICAgICAgICBCVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQlRyZWUnKSxcclxuICAgICAgICBEaWdpdGFsU2VhcmNoVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUnKSxcclxuICAgICAgICBmaWJvbmFjY2lTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaCcpLFxyXG4gICAgICAgIEhhc2hUYWJsZTogcmVxdWlyZSgnLi9TZWFyY2gvSGFzaFRhYmxlJyksXHJcbiAgICAgICAgUmVkQmxhY2tUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9SZWRCbGFja1RyZWUnKSxcclxuICAgICAgICBzZXF1ZW50aWFsU2VhcmNoOiByZXF1aXJlKCcuL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoJyksXHJcbiAgICAgICAgU09TVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvU09TVHJlZScpXHJcbiAgICB9LFxyXG5cclxuICAgIFNvcnQ6IHtcclxuICAgICAgICBkaXN0cmlidXRpb246IHJlcXVpcmUoJy4vU29ydC9kaXN0cmlidXRpb24vaW5kZXgnKSxcclxuICAgICAgICBleGNoYW5nZTogcmVxdWlyZSgnLi9Tb3J0L2V4Y2hhbmdlL2luZGV4JyksXHJcbiAgICAgICAgaW5zZXJ0aW9uOiByZXF1aXJlKCcuL1NvcnQvaW5zZXJ0aW9uL2luZGV4JyksXHJcbiAgICAgICAgbWVyZ2luZzogcmVxdWlyZSgnLi9Tb3J0L21lcmdpbmcvaW5kZXgnKSxcclxuICAgICAgICBzZWxlY3Rpb246IHJlcXVpcmUoJy4vU29ydC9zZWxlY3Rpb24vaW5kZXgnKVxyXG4gICAgfSxcclxuXHJcbiAgICBTdGFjazogcmVxdWlyZSgnLi9TdGFjay9pbmRleCcpLFxyXG5cclxuICAgIFN0cmluZzoge1xyXG4gICAgICAgIEhTdHJpbmc6IHJlcXVpcmUoJy4vU3RyaW5nL0hTdHJpbmcnKSxcclxuICAgICAgICBMU3RyaW5nOiByZXF1aXJlKCcuL1N0cmluZy9MU3RyaW5nJyksXHJcbiAgICAgICAgU1N0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvU1N0cmluZycpXHJcbiAgICB9XHJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvaW5kZXguanNcbiAqKi8iLCIvLyByZXF1aXJlZCB0byBzYWZlbHkgdXNlIGJhYmVsL3JlZ2lzdGVyIHdpdGhpbiBhIGJyb3dzZXJpZnkgY29kZWJhc2VcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcmVnaXN0ZXIvbGliL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pc0l0ZXJhYmxlMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XHJcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcclxuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3I7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIE9ic2VydmVyICA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyXG4gICwgcHJvY2VzcyAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBQcm9taXNlICAgPSBnbG9iYWwuUHJvbWlzZVxuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZShoZWFkKXtcbiAgICAgIGZuICAgPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICBpZihoZWFkKW5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmKGlzTm9kZSl7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICAgIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZH07XG4gICAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmKCFoZWFkKXtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcclxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICwgaSA9IDBcclxuICAgICwgUDtcclxuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpe1xuICAgIGlmKHNhZmUgJiYgdGFyZ2V0W2tleV0pdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xyXG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxyXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbkluc3RhbmNlICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBzZXRQcm90byAgICAgICAgICAgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXRcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCB0YXNrICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgbWljcm90YXNrICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIFBST01JU0UgICAgICAgICAgICA9ICdQcm9taXNlJ1xuICAsIFR5cGVFcnJvciAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsICRQcm9taXNlICAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICAgICAgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBlbXB0eSAgICAgICAgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgSW50ZXJuYWwsIEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgICAgID0gJFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgLCBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24oZXhlYyl7IGV4ZWMoZW1wdHksIGVtcHR5KTsgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyB3aXRoIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSA9PT0gJFByb21pc2UgJiYgYiA9PT0gV3JhcHBlcjtcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgcmV0dXJuIHNhbWVDb25zdHJ1Y3RvcigkUHJvbWlzZSwgQylcbiAgICA/IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgIDogbmV3IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xudmFyIHBlcmZvcm0gPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNSZWplY3Qpe1xuICBpZihwcm9taXNlLl9uKXJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgb2sgICAgPSBwcm9taXNlLl9zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgZG9tYWluICA9IHJlYWN0aW9uLmRvbWFpblxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvayl7XG4gICAgICAgICAgICBpZihwcm9taXNlLl9oID09IDIpb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGFuZGxlciA9PT0gdHJ1ZSlyZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSl7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKW9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIGFicnVwdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYoYWJydXB0KXRocm93IGFicnVwdC5lcnJvcjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIGlmKHByb21pc2UuX2ggPT0gMSlyZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fY1xuICAgICwgaSAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZihpc05vZGUpe1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKXtcbiAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdn0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYoIXByb21pc2UuX2EpcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHByb21pc2UgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7X3c6IHByb21pc2UsIF9kOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe193OiBwcm9taXNlLCBfZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIVVTRV9OQVRJVkUpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiAgICA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgICAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsICAgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9hKXRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9zKW5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwcm9taXNlICA9IG5ldyBJbnRlcm5hbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogJFByb21pc2V9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mICRQcm9taXNlICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIHZhciB2YWx1ZXMgICAgPSBbXVxuICAgICAgICAsIGluZGV4ICAgICA9IDBcbiAgICAgICAgLCByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgdmFyICRpbmRleCAgICAgICAgPSBpbmRleCsrXG4gICAgICAgICAgLCBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCAgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHZhciBEID0gZ09QRChpdCA9IHRvSU9iamVjdChpdCksIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIERFU0NSSVBUT1JTICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIWZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF9pdGVyYXRvcjIuZGVmYXVsdCB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSAodHlwZW9mIG1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobW9kdWxlKSkgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICBpZiAoX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KSB7XG4gICAgICAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIC8vIFRoaXMgaW52b2tlIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gaW4gYSBzdHlsZSB0aGF0IGFzc3VtZXMgc29tZVxuICAgIC8vIGNhbGxpbmcgZnVuY3Rpb24gKG9yIFByb21pc2UpIHdpbGwgaGFuZGxlIGV4Y2VwdGlvbnMuXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2VuZXJhdG9yW21ldGhvZF0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQgPyBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihpbnZva2VOZXh0LCBpbnZva2VUaHJvdykgOiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShwcm9jZXNzKSkgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgaW52b2tlTmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIHZhciBpbnZva2VUaHJvdyA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJ0aHJvd1wiKTtcbiAgICB2YXIgaW52b2tlUmV0dXJuID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInJldHVyblwiKTtcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbih0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShnbG9iYWwpKSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KSh3aW5kb3cpKSA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc2VsZikpID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHVuZGVmaW5lZCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9ydW50aW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLypnbG9iYWxzIHdpbmRvdyBfX3dlYnBhY2tfaGFzaF9fICovXHJcbmlmKG1vZHVsZS5ob3QpIHtcclxuXHR2YXIgbGFzdERhdGE7XHJcblx0dmFyIHVwVG9EYXRlID0gZnVuY3Rpb24gdXBUb0RhdGUoKSB7XHJcblx0XHRyZXR1cm4gbGFzdERhdGEuaW5kZXhPZihfX3dlYnBhY2tfaGFzaF9fKSA+PSAwO1xyXG5cdH07XHJcblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soKSB7XHJcblx0XHRtb2R1bGUuaG90LmNoZWNrKHRydWUsIGZ1bmN0aW9uKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0aWYobW9kdWxlLmhvdC5zdGF0dXMoKSBpbiB7XHJcblx0XHRcdFx0XHRcdGFib3J0OiAxLFxyXG5cdFx0XHRcdFx0XHRmYWlsOiAxXHJcblx0XHRcdFx0XHR9KSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSBDYW5ub3QgYXBwbHkgdXBkYXRlLiBOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSBVcGRhdGUgZmFpbGVkOiBcIiArIGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoIXVwZGF0ZWRNb2R1bGVzKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGZpbmQgdXBkYXRlLiBOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIpO1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIChQcm9iYWJseSBiZWNhdXNlIG9mIHJlc3RhcnRpbmcgdGhlIHdlYnBhY2stZGV2LXNlcnZlcilcIik7XHJcblx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoIXVwVG9EYXRlKCkpIHtcclxuXHRcdFx0XHRjaGVjaygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXF1aXJlKFwiLi9sb2ctYXBwbHktcmVzdWx0XCIpKHVwZGF0ZWRNb2R1bGVzLCB1cGRhdGVkTW9kdWxlcyk7XHJcblxyXG5cdFx0XHRpZih1cFRvRGF0ZSgpKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJbSE1SXSBBcHAgaXMgdXAgdG8gZGF0ZS5cIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9KTtcclxuXHR9O1xyXG5cdHZhciBhZGRFdmVudExpc3RlbmVyID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcblx0fSA6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuXHRcdHdpbmRvdy5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudE5hbWUsIGxpc3RlbmVyKTtcclxuXHR9O1xyXG5cdGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRpZih0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC5kYXRhLmluZGV4T2YoXCJ3ZWJwYWNrSG90VXBkYXRlXCIpID09PSAwKSB7XHJcblx0XHRcdGxhc3REYXRhID0gZXZlbnQuZGF0YTtcclxuXHRcdFx0aWYoIXVwVG9EYXRlKCkgJiYgbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gXCJpZGxlXCIpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIltITVJdIENoZWNraW5nIGZvciB1cGRhdGVzIG9uIHRoZSBzZXJ2ZXIuLi5cIik7XHJcblx0XHRcdFx0Y2hlY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGNvbnNvbGUubG9nKFwiW0hNUl0gV2FpdGluZyBmb3IgdXBkYXRlIHNpZ25hbCBmcm9tIFdEUy4uLlwiKTtcclxufSBlbHNlIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9ob3QvZGV2LXNlcnZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cGRhdGVkTW9kdWxlcywgcmVuZXdlZE1vZHVsZXMpIHtcclxuXHR2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdHJldHVybiByZW5ld2VkTW9kdWxlcyAmJiByZW5ld2VkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDA7XHJcblx0fSk7XHJcblxyXG5cdGlmKHVuYWNjZXB0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdGNvbnNvbGUud2FybihcIltITVJdIFRoZSBmb2xsb3dpbmcgbW9kdWxlcyBjb3VsZG4ndCBiZSBob3QgdXBkYXRlZDogKFRoZXkgd291bGQgbmVlZCBhIGZ1bGwgcmVsb2FkISlcIik7XHJcblx0XHR1bmFjY2VwdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybihcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRpZighcmVuZXdlZE1vZHVsZXMgfHwgcmVuZXdlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIltITVJdIE5vdGhpbmcgaG90IHVwZGF0ZWQuXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIltITVJdIFVwZGF0ZWQgbW9kdWxlczpcIik7XHJcblx0XHRyZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9