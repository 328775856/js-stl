(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DS"] = factory();
	else
		root["DS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	    Array: {
	        CrossList: __webpack_require__(138).default,
	        TSMatrix: __webpack_require__(139).default
	    },
	
	    BinaryTree: {
	        // BinaryThreadTree: require('./BinaryTree/BinaryThreadTree'),
	        BinaryTree: __webpack_require__(22),
	        // EBTNode: require('./BinaryTree/EBTNode'),
	        huffManCoding: __webpack_require__(140).default
	    },
	
	    // MFSet: require('./BinaryTree/MFSet'),
	    // PBTNode: require('./BinaryTree/PBTNode')
	    GeneralizedList: __webpack_require__(141).default,
	
	    Graph: {
	        AdjacencyListGraph: __webpack_require__(143).default,
	        AdjacencyMatrixGraph: __webpack_require__(144).default,
	        AMLGraph: __webpack_require__(142).default,
	        OLGraph: __webpack_require__(145).default
	    },
	
	    List: {
	        DoubleLinkedList: __webpack_require__(67).default,
	        LinearList: __webpack_require__(147),
	        StaticLinkedList: __webpack_require__(69).default,
	        LRUCache: __webpack_require__(146).default
	    },
	
	    Queue: {
	        CycleQueue: __webpack_require__(148).default,
	        PriorityQueue: __webpack_require__(149).default,
	        Queue: __webpack_require__(15).default
	    },
	
	    Search: {
	        AVLTree: __webpack_require__(150),
	        binarySearch: __webpack_require__(153),
	        BinarySortedTree: __webpack_require__(70).default,
	        BPlusTree: __webpack_require__(151),
	        BTree: __webpack_require__(152),
	        DigitalSearchTree: __webpack_require__(155),
	        fibonacciSearch: __webpack_require__(159).default,
	        HashTable: __webpack_require__(156),
	        RedBlackTree: __webpack_require__(157).default,
	        sequentialSearch: __webpack_require__(160).default,
	        SOSTree: __webpack_require__(158),
	        BloomFilter: __webpack_require__(154)
	    },
	
	    Sort: {
	        distribution: __webpack_require__(161),
	        exchange: __webpack_require__(71),
	        insertion: __webpack_require__(162),
	        merging: __webpack_require__(163),
	        selection: __webpack_require__(164)
	    },
	
	    Stack: __webpack_require__(23).default,
	
	    String: {
	        HString: __webpack_require__(165).default,
	        LString: __webpack_require__(166).default,
	        SString: __webpack_require__(167).default
	    }
	};

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(79);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 3 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(52)
	var ieee754 = __webpack_require__(72)
	var isArray = __webpack_require__(73)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(41)('wks')
	  , uid        = __webpack_require__(27)
	  , Symbol     = __webpack_require__(6).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 6 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(9)
	  , IE8_DOM_DEFINE = __webpack_require__(55)
	  , toPrimitive    = __webpack_require__(44)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(103)
	  , defined = __webpack_require__(33);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(19)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(6)
	  , core      = __webpack_require__(3)
	  , ctx       = __webpack_require__(32)
	  , hide      = __webpack_require__(13)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 12 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(7)
	  , createDesc = __webpack_require__(21);
	module.exports = __webpack_require__(10) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 队列Queue
	 *
	 * 队列是一种先进先出（first in first out, FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。
	 * 允许插入的一端叫队尾（rear），允许删除的一端叫队头（front）。
	 */
	
	// 链队列
	
	var Queue = function () {
	    function Queue() {
	        (0, _classCallCheck3.default)(this, Queue);
	
	        this.rear = this.front = null;
	        this.size = 0;
	    }
	
	    (0, _createClass3.default)(Queue, [{
	        key: "isEmpty",
	        value: function isEmpty() {
	            return this.rear === null;
	        }
	    }, {
	        key: "clear",
	        value: function clear() {
	            this.rear = this.front = null;
	            this.size = 0;
	        }
	    }, {
	        key: "getHead",
	        value: function getHead() {
	            return this.front ? this.front.data : null;
	        }
	    }, {
	        key: "enQueue",
	        value: function enQueue(elem) {
	            if (this.front === null) {
	                this.rear = this.front = { data: elem, next: null };
	            } else {
	                var p = { data: elem, next: null };
	                this.rear.next = p;
	                this.rear = p;
	            }
	            this.size++;
	        }
	    }, {
	        key: "deQueue",
	        value: function deQueue() {
	            if (this.front) {
	                var elem = this.front.data;
	                this.front = this.front.next;
	                if (this.front === null) {
	                    this.rear = null;
	                }
	                this.size--;
	                return elem;
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: "queueTraverse",
	        value: function queueTraverse(iterator) {
	            var current = this.front;
	            while (current) {
	                if (iterator(current.data)) break;
	                current = current.next;
	            }
	        }
	    }, {
	        key: "peekAt",
	        value: function peekAt() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	            if (index < this.size) {
	                var current = this.front;
	                for (var i = 0; i < index; i++) {
	                    current = current.next;
	                }
	                return current.data;
	            }
	
	            return null;
	        }
	    }, {
	        key: "toString",
	        value: function toString() {
	            if (this.front === null) {
	                return null;
	            }
	
	            var arr = [];
	            var current = this.front;
	
	            for (var i = 0, len = this.size; i < len; i++) {
	                arr[i] = current.data;
	                current = current.next;
	            }
	
	            return arr;
	        }
	    }]);
	    return Queue;
	}();
	
	exports.default = Queue;
	
	
	var queue = new Queue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));
	console.log(queue.peekAt(3));
	console.log(queue.toString().join());
	
	// 类似广度优先遍历
	function repaintColor(matrix, i, j, color) {
	    var old = matrix[i][j];
	    var queue = new Queue();
	    var m = matrix.length - 1;
	    var n = matrix[0].length - 1;
	
	    queue.enQueue({ x: i, y: j });
	
	    while (queue.rear) {
	        var a = queue.deQueue();
	        var x = a.x;
	        var y = a.y;
	
	        if (x >= 1) setColor(x - 1, y);
	        if (y >= 1) setColor(x, y - 1);
	        if (x < m) setColor(x + 1, y);
	        if (y < n) setColor(x, y + 1);
	    }
	
	    function setColor(x, y) {
	        if (matrix[x][y] === old) {
	            matrix[x][y] = color;
	            queue.enQueue({ x: x, y: y });
	        }
	    }
	}
	
	var matrix = [];
	
	for (var i = 0; i < 8; i++) {
	    matrix[i] = [];
	    for (var j = 0; j < 8; j++) {
	        matrix[i][j] = 0;
	    }
	}
	
	repaintColor(matrix, 4, 5, 1);
	console.log(matrix);

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(87), __esModule: true };

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(93), __esModule: true };

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ChildSiblingTree = exports.ChildTree = exports.ParentTree = exports.BinaryTree = undefined;
	
	var _getIterator2 = __webpack_require__(16);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _regenerator = __webpack_require__(30);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator2 = __webpack_require__(18);
	
	var _iterator3 = _interopRequireDefault(_iterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _index = __webpack_require__(23);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(15);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 树的一些概念
	 *
	 * 树（Tree）是n（n>=0）个结点的有限集。在任意一棵非空树中：
	 * （1）有且仅有一个特定的称为根（Root）的结点；
	 * （2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,T3,...Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。
	 *
	 * 例如，（a）是只有一个根结点的树；
	 * （b）是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。
	 *
	 * 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。例如，（b）中A的度为3，C的度为1，F的度为0.度为0的结点称为叶子（Leaf）或者终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。（b）的树的度为3.结点的子树的根称为该结点的孩子（Child）。相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。
	 * 结点的层次（Level）从根开始定义起，根为第一层，跟的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。例如，结点G与E，F,H,I,J互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。（b）的树的深度为4。
	 *
	 * 如果将树中结点的各子树看成从左至右是有次序的（即不能交换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
	 * 森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
	 *
	 *
	 */
	
	/**
	 * 二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）
	 *
	 * 二叉树的性质
	 * 1.在二叉树的第i层上至多有2的i-1次方个结点(i>=1)。
	 * 2.深度为k的二叉树至多有2的k次方-1个结点，(k>=1)。
	 * 3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1;
	 *      一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树。
	 *      深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。
	 * 下面是完全二叉树的两个特性
	 * 4.具有n个结点的完全二叉树的深度为Math.floor(log 2 n) + 1
	 * 5.如果对一棵有n个结点的完全二叉树（其深度为Math.floor(log 2 n) + 1）的结点按层序编号（从第1层到第Math.floor(2 n) + 1，每层从左到右），则对任一结点（1<=i<=n）有：
	 *     (1)如果i=1，则结点i、是二叉树的根，无双亲；如果i>1，则其双亲parent(i)是结点Math.floor(i/2)。
	 *     (2)如果2i > n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LChild(i)是结点2i.
	 *     (3)如果2i + 1 > n，则结点i无右孩子；否则其右孩子RChild(i)是结点2i + 1;
	 */
	
	/*
	 二叉树的存储结构
	
	 1.顺序存储结构
	 用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，即将二叉树上编号为i的结点元素存储在加上定义的一维数组中下标为i-1的分量中。“0”表示不存在此结点。这种顺序存储结构仅适用于完全二叉树。
	 因为，在最坏情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为2的n次方-1的一维数组。
	
	 2.链式存储结构
	 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左右指针域。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结构所得的二叉树的存储结构分别称之为二叉链表和三叉链表。
	 在含有n个结点的二叉链表中有n+1个空链域，我们可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构---线索链表。
	
	 先（根）序遍历：根左右
	 中（根）序遍历：左根右
	 后（根）序遍历：左右根
	
	 */
	
	// 顺序存储结构
	(function () {
	    // 顺序存储结构的遍历
	    var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	
	    console.log('preOrder:');
	    void function preOrderRecursive(x, visit) {
	        visit(tree[x]);
	        if (tree[2 * x + 1]) preOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) preOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('inOrder:');
	    void function inOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) inOrderRecursive(2 * x + 1, visit);
	        visit(tree[x]);
	        if (tree[2 * x + 2]) inOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('postOrder:');
	    void function postOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) postOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) postOrderRecursive(2 * x + 2, visit);
	        visit(tree[x]);
	    }(0, function (value) {
	        console.log(value);
	    });
	})();
	
	// 链式存储结构
	
	var BinaryTree = exports.BinaryTree = function () {
	    function BinaryTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var leftChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var rightChild = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, BinaryTree);
	
	        this.data = data;
	        // 左右孩子结点
	        this.leftChild = leftChild;
	        this.rightChild = rightChild;
	    }
	
	    // 判断两棵树是否相似
	
	
	    (0, _createClass3.default)(BinaryTree, [{
	        key: 'isSimilar',
	        value: function isSimilar(tree) {
	            return !!(tree && (this.leftChild && this.leftChild.isSimilar(tree.leftChild) || !this.leftChild && !tree.leftChild) && (this.rightChild && this.rightChild.isSimilar(tree.rightChild) || !this.rightChild && !tree.rightChild));
	        }
	    }, {
	        key: 'createBinaryTree',
	        value: function createBinaryTree(tree) {
	            void function preOrderRecursive(node, x, visit) {
	                visit(node, tree[x]);
	
	                var p = void 0;
	                if (tree[2 * x + 1]) {
	                    p = node.leftChild = new BinaryTree();
	                    preOrderRecursive(p, 2 * x + 1, visit);
	                }
	                if (tree[2 * x + 2]) {
	                    p = node.rightChild = new BinaryTree();
	                    preOrderRecursive(p, 2 * x + 2, visit);
	                }
	
	                if (p) p.parentNode = node;
	            }(this, 0, function (node, value) {
	                node.data = value;
	            });
	        }
	
	        /** Prefix iteration */
	
	    }, {
	        key: _iterator3.default,
	        value: _regenerator2.default.mark(function value() {
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return this.data;
	
	                        case 2:
	                            if (!this.leftChild) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            return _context.delegateYield(this.leftChild, 't0', 4);
	
	                        case 4:
	                            if (!this.rightChild) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            return _context.delegateYield(this.rightChild, 't1', 6);
	
	                        case 6:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	
	        // 先序遍历二叉树的非递归算法
	
	    }, {
	        key: 'preOrderNonRecursive',
	        value: function preOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            var p = this;
	
	            while (p || stack.length) {
	                // 向左走到尽头
	                if (p) {
	                    stack.push(p);
	                    p.data && visit(p.data);
	                    p = p.leftChild;
	                } else {
	                    p = stack.pop();
	                    p = p.rightChild;
	                }
	            }
	        }
	
	        // 中序非递归遍历
	
	    }, {
	        key: 'inOrderNonRecursive',
	        value: function inOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            var p = this;
	
	            while (p || stack.length) {
	                if (p) {
	                    stack.push(p);
	                    p = p.leftChild;
	                } else {
	                    p = stack.pop();
	                    p.data && visit(p.data);
	                    p = p.rightChild;
	                }
	            }
	        }
	
	        // 为了区分两次过栈的不同处理方式，在堆栈中增加一个mark域，
	        // mark=0表示刚刚访问此结点，mark=1表示左子树处理结束返回，
	        // mark=2表示右子树处理结束返回。每次根据栈顶的mark域决定做何动作
	
	    }, {
	        key: 'postOrderNonRecursive',
	        value: function postOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            stack.push([this, 0]);
	
	            while (stack.length) {
	                var a = stack.pop();
	                var node = a[0];
	
	                switch (a[1]) {
	                    case 0:
	                        stack.push([node, 1]); // 修改mark域
	                        if (node.leftChild) stack.push([node.leftChild, 0]); // 访问左子树
	                        break;
	                    case 1:
	                        stack.push([node, 2]);
	                        if (node.rightChild) stack.push([node.rightChild, 0]);
	                        break;
	                    case 2:
	                        node.data && visit(node.data);
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	    }, {
	        key: 'preOrderRecursive',
	        value: function preOrderRecursive(visit) {
	            visit(this.data);
	            if (this.leftChild) this.leftChild.preOrderRecursive(visit);
	            if (this.rightChild) this.rightChild.preOrderRecursive(visit);
	        }
	    }, {
	        key: 'inOrderRecursive',
	        value: function inOrderRecursive(visit) {
	            if (this.leftChild) this.leftChild.inOrderRecursive(visit);
	            visit(this.data);
	            if (this.rightChild) this.rightChild.inOrderRecursive(visit);
	        }
	    }, {
	        key: 'postOrderRecursive',
	        value: function postOrderRecursive(visit) {
	            if (this.leftChild) this.leftChild.postOrderRecursive(visit);
	            if (this.rightChild) this.rightChild.postOrderRecursive(visit);
	            visit(this.data);
	        }
	    }, {
	        key: 'levelOrderTraverse',
	        value: function levelOrderTraverse(visit) {
	            var queue = new _Queue2.default();
	            queue.enQueue(this);
	
	            while (queue.rear) {
	                var p = queue.deQueue();
	                p.data && visit(p.data);
	                p.leftChild && queue.enQueue(p.leftChild);
	                p.rightChild && queue.enQueue(p.rightChild);
	            }
	        }
	
	        // 求先序序列为k的结点的值
	
	    }, {
	        key: 'getPreSequence',
	        value: function getPreSequence(k) {
	            var count = 0;
	            var data = null;
	
	            void function recurse(node) {
	                if (node) {
	                    if (++count === k) data = node.data;else {
	                        recurse(node.leftChild);
	                        recurse(node.rightChild);
	                    }
	                }
	            }(this);
	
	            return data;
	        }
	
	        // 求二叉树中叶子结点的数目
	
	    }, {
	        key: 'countLeaves',
	        value: function countLeaves() {
	            return function recurse(node) {
	                if (!node) return 0;else if (!node.leftChild && !node.rightChild) return 1;else return recurse(node.leftChild) + recurse(node.rightChild);
	            }(this);
	        }
	
	        // 交换所有结点的左右子树
	
	    }, {
	        key: 'revoluteBinaryTree',
	        value: function revoluteBinaryTree() {
	            var _ref = [this.rightChild, this.leftChild];
	            this.leftChild = _ref[0];
	            this.rightChild = _ref[1];
	
	
	            if (this.leftChild) this.leftChild.revoluteBinaryTree();
	            if (this.rightChild) this.rightChild.revoluteBinaryTree();
	        }
	    }, {
	        key: 'revoluteNonRecursive',
	        value: function revoluteNonRecursive() {
	            var stack = [];
	            stack.push(this);
	
	            while (stack.length) {
	                var node = stack.pop();
	                var _ref2 = [node.rightChild, node.leftChild];
	                node.leftChild = _ref2[0];
	                node.rightChild = _ref2[1];
	
	
	                if (node.leftChild) stack.push(node.leftChild);
	                if (node.rightChild) stack.push(node.rightChild);
	            }
	        }
	
	        // 求二叉树中以值为x的结点为根的子树深度
	
	    }, {
	        key: 'getSubDepth',
	        value: function getSubDepth(x) {
	            var count = 0;
	            var stack = new _index2.default();
	            stack.push(this);
	
	            while (stack.length) {
	                var node = stack.pop();
	
	                if (node.data === x) {
	                    count = node.getDepth();
	                    break;
	                } else {
	                    if (node.leftChild) stack.push(node.leftChild);
	                    if (node.rightChild) stack.push(node.rightChild);
	                }
	            }
	
	            return count;
	        }
	    }, {
	        key: 'getDepth',
	        value: function getDepth() {
	            var m = this.leftChild && this.leftChild.getDepth() || 0;
	            var n = this.rightChild && this.rightChild.getDepth() || 0;
	            return (m > n ? m : n) + 1;
	        }
	
	        // 删除所有以元素x为根的子树
	
	    }, {
	        key: 'delSubX',
	        value: function delSubX(x) {
	            if (this.data === x) {
	                this.leftChild = null;
	                this.rightChild = null;
	            } else {
	                if (this.leftChild) this.leftChild.delSubX(x);
	                if (this.rightChild) this.rightChild.delSubX(x);
	            }
	        }
	
	        /**
	         * 非递归复制二叉树
	         * @param {Function} cb 拷贝过程中会执行的回调，可以用来拷贝其它自定义属性
	         * @returns {Cstr} 返回新的实例
	         */
	
	    }, {
	        key: 'copy',
	        value: function copy() {
	            var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
	
	            // 用来存放本体结点的栈
	            var stack1 = new _index2.default();
	            // 用来存放新二叉树结点的栈
	            var stack2 = new _index2.default();
	            stack1.push(this);
	            var Cstr = this.constructor;
	            var newTree = new Cstr();
	            var q = newTree;
	            stack2.push(newTree);
	            var p = void 0;
	
	            while (stack1.length) {
	                // 向左走到尽头
	                while (p = stack1.peek()) {
	                    if (p.leftChild) q.leftChild = new Cstr();
	                    q = q.leftChild;
	                    stack1.push(p.leftChild);
	                    stack2.push(q);
	                }
	
	                p = stack1.pop();
	                q = stack2.pop();
	
	                if (stack1.length) {
	                    p = stack1.pop();
	                    q = stack2.pop();
	                    if (p.rightChild) q.rightChild = new Cstr();
	                    q.data = p.data;
	                    cb(q, p);
	                    q = q.rightChild;
	                    stack1.push(p.rightChild); // 向右一步
	                    stack2.push(q);
	                }
	            }
	
	            return newTree;
	        }
	
	        // 求二叉树中结点p和q的最近祖先
	
	    }, {
	        key: 'findNearAncient',
	        value: function findNearAncient(pNode, qNode) {
	            var pathP = findPath(this, pNode, 0);
	            var pathQ = findPath(this, qNode, 0);
	
	            for (var i = 0; pathP[i] == pathQ[i] && pathP[i]; i++) {}
	            return pathP[--i];
	        }
	
	        // todo
	
	    }, {
	        key: 'toString',
	        value: function toString() {}
	
	        // 求一棵二叉树的繁茂度
	
	    }, {
	        key: 'lushDegree',
	        value: function lushDegree() {
	            var countArr = [];
	            var queue = new _Queue2.default();
	            queue.enQueue({
	                node: this,
	                layer: 0
	            });
	            // 利用层序遍历来统计各层的结点数
	            var r = void 0;
	            while (queue.rear) {
	                r = queue.deQueue();
	                countArr[r.layer] = (countArr[r.layer] || 0) + 1;
	
	                if (r.node.leftChild) queue.enQueue({
	                    node: r.node.leftChild,
	                    layer: r.layer + 1
	                });
	                if (r.node.rightChild) queue.enQueue({
	                    node: r.node.rightChild,
	                    layer: r.layer + 1
	                });
	            }
	
	            // 最后一个队列元素所在层就是树的高度
	            var height = r.layer;
	            var max = countArr[0];
	            for (var i = 1; countArr[i]; i++) {
	                // 求层最大结点数
	                if (countArr[i] > max) max = countArr[i];
	            }return height * max;
	        }
	
	        // 求树结点的子孙总数填入descNum域中，并返回
	
	    }, {
	        key: 'descNum',
	        value: function descNum() {
	            return function recurse(node) {
	                var d = void 0;
	                if (!node) return -1;else d = recurse(node.leftChild) + recurse(node.rightChild) + 2;
	
	                node.descNum = d;
	
	                return d;
	            }(this);
	        }
	
	        // 判断二叉树是否完全二叉树
	
	    }], [{
	        key: 'isFullBinaryTree',
	        value: function isFullBinaryTree(tree) {
	            var queue = new _Queue2.default();
	            var flag = 0;
	            queue.enQueue(tree);
	
	            while (queue.rear) {
	                var p = queue.deQueue();
	
	                if (!p) flag = 1;else if (flag) return false;else {
	                    queue.enQueue(p.leftChild);
	                    queue.enQueue(p.rightChild);
	                }
	            }
	
	            return true;
	        }
	    }]);
	    return BinaryTree;
	}();
	
	// 求从tree到node结点路径的递归算法
	
	
	function findPath(tree, node) {
	    var i = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    var path = [];
	    var found = false;
	
	    void function recurse(tree, i) {
	        if (tree == node) {
	            found = true;
	            return;
	        }
	
	        path[i] = tree;
	        if (tree.leftChild) recurse(tree.leftChild, i + 1);
	        if (tree.rightChild && !found) recurse(tree.rightChild, i + 1);
	        if (!found) path[i] = null;
	    }(tree, i);
	
	    return path;
	}
	
	var global = Function('return this;')();
	
	// 求深度等于树的高度减一的最靠左的结点
	function printPath_maxDepthS1(tree) {
	    var maxh = tree.getDepth();
	    var path = [];
	
	    if (maxh < 2) return false;
	    find_h(tree, 1);
	
	    function find_h(tree, h) {
	        path[h] = tree;
	
	        if (h == maxh - 1) {
	            var s = ' ';
	            for (var i = 1; path[i]; i++) {
	                s += path[i].data + (path[i + 1] ? ' -> ' : '');
	            }console.log(s);
	            return;
	        } else {
	            if (tree.leftChild) find_h(tree.leftChild, h + 1);
	            if (tree.rightChild) find_h(tree.rightChild, h + 1);
	        }
	
	        path[h] = null;
	    }
	}
	
	var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	var test = new BinaryTree();
	test.createBinaryTree(tree);
	
	console.log('iterator: ');
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;
	
	try {
	    for (var _iterator = (0, _getIterator3.default)(test), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var x = _step.value;
	
	        console.log(x);
	    }
	
	    /**
	     * 树的3种常用链表结构
	     */
	
	    // 1.双亲表示法
	    // 优点：parent(tree, x)操作可以在常量时间内实现
	    // 缺点：求结点的孩子时需要遍历整个结构
	} catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	        }
	    } finally {
	        if (_didIteratorError) {
	            throw _iteratorError;
	        }
	    }
	}
	
	var ParentTree = exports.ParentTree = function () {
	    function ParentTree() {
	        (0, _classCallCheck3.default)(this, ParentTree);
	
	        this.nodes = [];
	    }
	
	    (0, _createClass3.default)(ParentTree, [{
	        key: 'getDepth',
	        value: function getDepth() {
	            var maxDepth = 0;
	
	            for (var i = 0; i < this.nodes.length; i++) {
	                var dep = 0;
	                for (var j = i; j >= 0; j = this.nodes[i].parent) {
	                    dep++;
	                }if (dep > maxDepth) maxDepth = dep;
	            }
	
	            return maxDepth;
	        }
	    }]);
	    return ParentTree;
	}();
	
	var ParentTreeNode = function ParentTreeNode() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var parent = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    (0, _classCallCheck3.default)(this, ParentTreeNode);
	
	    // type: ParentTree
	    this.data = data;
	    // 双亲位置域 {Number}
	    this.parent = parent;
	};
	
	var pt = new ParentTree();
	pt.nodes.push(new ParentTreeNode('R', -1));
	pt.nodes.push(new ParentTreeNode('A', 0));
	pt.nodes.push(new ParentTreeNode('B', 0));
	pt.nodes.push(new ParentTreeNode('C', 0));
	pt.nodes.push(new ParentTreeNode('D', 1));
	pt.nodes.push(new ParentTreeNode('E', 1));
	pt.nodes.push(new ParentTreeNode('F', 3));
	pt.nodes.push(new ParentTreeNode('G', 6));
	pt.nodes.push(new ParentTreeNode('H', 6));
	pt.nodes.push(new ParentTreeNode('I', 6));
	
	// 孩子表示法
	
	var ChildTree = exports.ChildTree = function () {
	    function ChildTree() {
	        (0, _classCallCheck3.default)(this, ChildTree);
	
	        this.nodes = [];
	    }
	
	    (0, _createClass3.default)(ChildTree, [{
	        key: 'getDepth',
	        value: function getDepth() {
	            var self = this;
	            return function subDepth(rootIndex) {
	                if (!self.nodes[rootIndex]) return 1;
	
	                var sd = 1;
	                for (var p = self.nodes[rootIndex]; p; p = p.next) {
	                    var d = subDepth(p.child);
	                    if (d > sd) sd = d;
	                }
	
	                return sd + 1;
	            }(this.data[0]);
	        }
	    }]);
	    return ChildTree;
	}();
	/**
	 *
	 * @param {*} data
	 * @param {ChildTreeNode} firstChild 孩子链表头指针
	 * @constructor
	 */
	
	
	var ChildTreeBox = function ChildTreeBox() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeBox);
	
	    this.data = data;
	    this.firstChild = firstChild;
	};
	
	/**
	 * 孩子结点
	 *
	 * @param {Number} child
	 * @param {ChildTreeNode} next
	 * @constructor
	 */
	
	
	var ChildTreeNode = function ChildTreeNode() {
	    var child = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeNode);
	
	    this.child = child;
	    this.next = next;
	};
	
	/*
	 孩子表示法便于涉及孩子的操作的实现，但不适用于parent操作。
	 我们可以把双亲表示法和孩子表示法结合起来。
	 */
	
	// 孩子兄弟表示法(二叉树表示法)
	// 可增设一个parent域实现parent操作
	
	
	var ChildSiblingTree = exports.ChildSiblingTree = function () {
	    function ChildSiblingTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var nextSibling = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, ChildSiblingTree);
	
	        this.data = data;
	        this.firstChild = firstChild;
	        this.nextSibling = nextSibling;
	    }
	
	    // 输出孩子兄弟链表表示的树的各边
	
	
	    (0, _createClass3.default)(ChildSiblingTree, [{
	        key: 'print',
	        value: function print() {
	            for (var child = this.firstChild; child; child = child.nextSibling) {
	                console.log('%c %c', this.data, child.data);
	                child.print();
	            }
	        }
	
	        // 求孩子兄弟链表表示的树的叶子数目
	
	    }, {
	        key: 'leafCount',
	        value: function leafCount() {
	            if (!this.firstChild) return 1;else {
	                var count = 0;
	                for (var child = this.firstChild; child; child = child.nextSibling) {
	                    count += child.leafCount();
	                }
	                return count;
	            }
	        }
	
	        // 求树的度
	
	    }, {
	        key: 'getDegree',
	        value: function getDegree() {
	            if (!this.firstChild) return 0;else {
	                var degree = 0;
	                for (var p = this.firstChild; p; p = p.nextSibling) {
	                    degree++;
	                }for (var _p = this.firstChild; _p; _p = _p.nextSibling) {
	                    var d = _p.getDegree();
	                    if (d > degree) degree = d;
	                }
	
	                return degree;
	            }
	        }
	    }, {
	        key: 'getDepth',
	        value: function getDepth() {
	            if (this === global) return 0;else {
	                var maxd = 0;
	                for (var p = this.firstChild; p; p = p.nextSibling) {
	                    var d = p.getDepth();
	                    if (d > maxd) maxd = d;
	                }
	
	                return maxd + 1;
	            }
	        }
	    }]);
	    return ChildSiblingTree;
	}();

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 栈
	 *
	 * 是限定仅在表尾进行插入或删除操作的线性表。表尾为栈顶（top），表头为栈底（bottom），不含元素的空表为空栈。
	 * 栈又称为后进先出（last in first out）的线性表。
	 */
	
	/**
	 * 顺序栈
	 * 栈的顺序存储结构是利用一组地址连续的存储单元依次存放至栈底到栈顶的元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
	 *
	 */
	
	// 栈的链式表示
	
	var Stack = function () {
	    function Stack() {
	        (0, _classCallCheck3.default)(this, Stack);
	
	        this.top = null;
	        this.length = 0;
	    }
	
	    (0, _createClass3.default)(Stack, [{
	        key: 'isEmpty',
	        value: function isEmpty() {
	            return this.length === 0;
	        }
	    }, {
	        key: 'push',
	        value: function push(data) {
	            var node = {
	                data: data,
	                next: null
	            };
	
	            node.next = this.top;
	            this.top = node;
	            this.length++;
	        }
	    }, {
	        key: 'peek',
	        value: function peek() {
	            return this.top === null ? null : this.top.data;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            if (this.top === null) return null;
	
	            var out = this.top;
	            this.top = this.top.next;
	
	            if (this.length > 0) this.length--;
	
	            return out.data;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.top = null;
	            this.length = 0;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            if (this.top === null) return null;
	
	            var arr = [];
	            var current = this.top;
	
	            for (var i = 0, len = this.size; i < len; i++) {
	                arr[i] = current.data;
	                current = current.next;
	            }
	
	            return arr;
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.length;
	        }
	    }]);
	    return Stack;
	}();
	
	exports.default = Stack;
	
	
	var stack = new Stack();
	
	stack.push(1);
	stack.push('asd');
	
	stack.pop();
	stack.push({ a: 1 });
	console.log(stack);
	
	/**
	 * 这里用字符串train表示火车，H表示硬席，S表示软席
	 * @param {String} train
	 */
	function trainArrange(train) {
	    var stack = new Stack();
	    var q = [];
	    var i = 0;
	    var j = 0;
	
	    while (train[i]) {
	        if (train[i] === 'H') stack.push(train[i]);else q[j++] = train[i];
	        i++;
	    }
	
	    while (stack.length) {
	        var c = stack.pop();
	        q[j++] = c;
	    }
	
	    return q + '';
	}
	
	console.log('trainArrange: ' + trainArrange('HSSHSSSHHHHHS')); // trainArrange: S,S,S,S,S,S,H,H,H,H,H,H,H
	
	// 判断字符串中“&”前和“&”后部分是否为逆串，"@"表示结束符，是则返回true，否则返回false
	function isReverse(str) {
	    var stack = new Stack();
	    var i = 0;
	
	    while (str[i] !== '&') {
	        if (str[i] === '@') return false;
	        stack.push(str[i]);
	        i++;
	    }
	
	    i++;
	
	    while (str[i] !== '@') {
	        if (!stack.length) return false;
	
	        var s = stack.pop();
	        if (s !== str[i]) return false;
	        i++;
	    }
	
	    return !stack.length;
	}
	
	console.log('isReverse: ' + isReverse('abcd&dcba@a')); // true
	
	// 数值进制转换
	// 公式： N = (N / d) * d + N % d
	// N：十进制数值， d：需要转换的进制数
	function numTransform(number, rad) {
	    var s = new Stack();
	
	    while (number) {
	        s.push(number % rad);
	        number = parseInt(number / 8, 10);
	    }
	
	    var arr = [];
	    while (s.top) {
	        arr.push(s.pop());
	    }
	    console.log(arr.join(''));
	}
	
	numTransform(1348, 8);
	numTransform(1348, 2);
	
	// 括号匹配检查
	function bracketsMatch(str) {
	    var stack = new Stack();
	    var text = '';
	
	    for (var i = 0, len = str.length; i < len; i++) {
	        var c = str[i];
	        if (c === '[') {
	            stack.push(c);
	        } else if (c === ']') {
	            if (!stack.length || stack.pop() !== '[') throw new Error('unexpected brackets:' + c);
	        } else {
	            text += c;
	        }
	    }
	    console.log(text);
	}
	
	console.log(bracketsMatch('[asd]'));
	
	function Matcher(left, right) {
	    this.left = left;
	    this.right = right;
	    this.stack = new Stack();
	}
	Matcher.prototype = {
	    match: function match(str) {
	        var text = '';
	
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            if (c === this.left) {
	                this.stack.push(c);
	            } else if (c === this.right) {
	                if (!this.stack.length || this.stack.pop() !== this.left) {
	                    throw new Error('unexpected brackets:' + c);
	                } else {
	                    text += ',';
	                }
	            } else {
	                text += c;
	            }
	        }
	        console.log(text);
	        return text;
	    }
	};
	var m = new Matcher('{', '}');
	m.match('[{123}123');
	
	function LineEditor(str) {
	    this.stack = new Stack();
	    this.str = str || '';
	}
	LineEditor.prototype = {
	    getResult: function getResult() {
	        var stack = this.stack;
	        var str = this.str;
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            switch (c) {
	                case '#':
	                    stack.pop();
	                    break;
	                case '@':
	                    stack.clear();
	                    break;
	                default:
	                    stack.push(c);
	                    break;
	            }
	        }
	
	        var result = '';
	        var current = stack.length;
	        while (current) {
	            result = current.data + result;
	            current = current.next;
	        }
	
	        return result;
	    }
	};
	
	var le = new LineEditor('whli##ilr#e(s#*s)\
	    \noutcha@putchar(*s=#++)');
	console.log(le.getResult());
	
	var prioty = {
	    "+": 1,
	    "-": 1,
	    "%": 2,
	    "*": 2,
	    "/": 2,
	    "^": 3,
	    "(": 0,
	    ")": 0,
	    "`": -1
	};
	
	function doop(op, opn1, opn2) {
	    switch (op) {
	        case "+":
	            return opn1 + opn2;
	        case "-":
	            return opn1 - opn2;
	        case "*":
	            return opn1 * opn2;
	        case "/":
	            return opn1 / opn2;
	        case "%":
	            return opn1 % opn2;
	        case "^":
	            return Math.pow(opn1, opn2);
	        default:
	            return 0;
	    }
	}
	
	function opcomp(a, b) {
	    return prioty[a] - prioty[b];
	}
	
	function calInfixExpression(exp) {
	    var cs = [];
	    var ns = [];
	    exp = exp.replace(/\s/g, "");
	    exp += '`';
	    if (exp[0] === '-') {
	        exp = "0" + exp;
	    }
	    var c = void 0;
	    var op = void 0;
	    var opn1 = void 0;
	    var opn2 = void 0;
	    for (var i = 0; i < exp.length; ++i) {
	        c = exp[i];
	        // 如果是操作符
	        if (c in prioty) {
	            // 如果右边不是左括号且操作符栈的栈顶元素优先权比右边大
	            // 循环遍历进行连续运算
	            while (c != '(' && cs.length && opcomp(cs[cs.length - 1], c) >= 0) {
	                // 出栈的操作符
	                op = cs.pop();
	                // 如果不是左括号或者右括号，说明是运算符
	                if (op != '(' && op != ')') {
	                    // 出栈保存数字的栈的两个元素
	                    opn2 = ns.pop();
	                    opn1 = ns.pop();
	                    // 将与操作符运算后的结果保存到栈顶
	                    ns.push(doop(op, opn1, opn2));
	                }
	            }
	            // 如果右边不是右括号，保存到操作符栈中
	            if (c != ')') cs.push(c);
	        } else {
	            // 多位数的数字的情况
	            while (!(exp[i] in prioty)) {
	                i++;
	                c += exp[i];
	            }
	            ns.push(parseFloat(c));
	            i--;
	        }
	    }
	    return ns.length ? ns[0] : NaN;
	}
	
	var exp1 = calInfixExpression('5+3*4/2-2^3+5%2');
	console.log(exp1);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(81);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(49);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(51);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(51);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(60)
	  , enumBugKeys = __webpack_require__(34);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(115)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(56)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = defaultCompare;
	/**
	 * Created by ldp on 2015/4/12.
	 */
	
	function defaultCompare(a, b) {
	  return a - b;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(170);


/***/ },
/* 31 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(97);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(9)
	  , dPs         = __webpack_require__(112)
	  , enumBugKeys = __webpack_require__(34)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(54)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(102).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(38)
	  , createDesc     = __webpack_require__(21)
	  , toIObject      = __webpack_require__(8)
	  , toPrimitive    = __webpack_require__(44)
	  , has            = __webpack_require__(12)
	  , IE8_DOM_DEFINE = __webpack_require__(55)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(10) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(7).f
	  , has = __webpack_require__(12)
	  , TAG = __webpack_require__(5)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(41)('keys')
	  , uid    = __webpack_require__(27);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(6)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(33);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(20);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(6)
	  , core           = __webpack_require__(3)
	  , LIBRARY        = __webpack_require__(35)
	  , wksExt         = __webpack_require__(46)
	  , defineProperty = __webpack_require__(7).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(5);

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(120);
	var global        = __webpack_require__(6)
	  , hide          = __webpack_require__(13)
	  , Iterators     = __webpack_require__(14)
	  , TO_STRING_TAG = __webpack_require__(5)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(178);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(168);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(74)))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(90), __esModule: true };

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(95), __esModule: true };

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(18);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(50);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict'
	
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	function init () {
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i]
	    revLookup[code.charCodeAt(i)] = i
	  }
	
	  revLookup['-'.charCodeAt(0)] = 62
	  revLookup['_'.charCodeAt(0)] = 63
	}
	
	init()
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	
	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(31)
	  , TAG = __webpack_require__(5)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20)
	  , document = __webpack_require__(6).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(10) && !__webpack_require__(19)(function(){
	  return Object.defineProperty(__webpack_require__(54)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(35)
	  , $export        = __webpack_require__(11)
	  , redefine       = __webpack_require__(62)
	  , hide           = __webpack_require__(13)
	  , has            = __webpack_require__(12)
	  , Iterators      = __webpack_require__(14)
	  , $iterCreate    = __webpack_require__(107)
	  , setToStringTag = __webpack_require__(39)
	  , getPrototypeOf = __webpack_require__(59)
	  , ITERATOR       = __webpack_require__(5)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(60)
	  , hiddenKeys = __webpack_require__(34).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 58 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(12)
	  , toObject    = __webpack_require__(43)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(12)
	  , toIObject    = __webpack_require__(8)
	  , arrayIndexOf = __webpack_require__(99)(false)
	  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(11)
	  , core    = __webpack_require__(3)
	  , fails   = __webpack_require__(19);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(13);

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(42)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(53)
	  , ITERATOR  = __webpack_require__(5)('iterator')
	  , Iterators = __webpack_require__(14);
	module.exports = __webpack_require__(3).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(174)
	
	var md5 = toConstructor(__webpack_require__(133))
	var rmd160 = toConstructor(__webpack_require__(172))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	exports.UINT32 = __webpack_require__(136)
	exports.UINT64 = __webpack_require__(137)

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _regenerator = __webpack_require__(30);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator3 = __webpack_require__(18);
	
	var _iterator4 = _interopRequireDefault(_iterator3);
	
	var _getIterator2 = __webpack_require__(16);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 循环链表（circular linked list）
	 * 是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个表形成一个环。
	 * 循环链表的操作和线性链表基本一致，仅有细微差别。
	 */
	
	/**
	 * 双向链表
	 *
	 * 双向链表是为了克服单链表这种单向性的缺点。
	 * 双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋。
	 *
	 * 双向链表也可以有循环表。
	 */
	
	var Node = function Node(data) {
	    var prev = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var next = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.prev = prev;
	    this.next = next;
	};
	
	function defaultCompare(a, b) {
	    return a === b;
	}
	
	var DoubleLinkedList = function () {
	    function DoubleLinkedList(sqList) {
	        var compare = arguments.length <= 1 || arguments[1] === undefined ? defaultCompare : arguments[1];
	        (0, _classCallCheck3.default)(this, DoubleLinkedList);
	
	        this.head = null;
	        this.tail = null;
	        this.size = 0;
	        this.compare = compare;
	
	        if (sqList && sqList.length) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = (0, _getIterator3.default)(sqList), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var item = _step.value;
	
	                    this.push(item);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        }
	    }
	
	    (0, _createClass3.default)(DoubleLinkedList, [{
	        key: _iterator4.default,
	        value: _regenerator2.default.mark(function value() {
	            var current;
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            current = this.head;
	
	                        case 1:
	                            if (!current) {
	                                _context.next = 7;
	                                break;
	                            }
	
	                            _context.next = 4;
	                            return current.data;
	
	                        case 4:
	
	                            current = current.next;
	                            _context.next = 1;
	                            break;
	
	                        case 7:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.head = null;
	            this.tail = null;
	            this.size = 0;
	
	            return true;
	        }
	    }, {
	        key: 'push',
	        value: function push(data) {
	            if (typeof data === 'undefined') throw new Error('data argument required');
	
	            ++this.size;
	
	            if (!this.head) {
	                this.head = this.tail = new Node(data);
	            } else {
	                var node = new Node(data, this.tail, null);
	                this.tail.next = node;
	                this.tail = node;
	            }
	
	            return data;
	        }
	    }, {
	        key: 'unshift',
	        value: function unshift(data) {
	            if (typeof data === 'undefined') throw new Error('data argument required');
	
	            ++this.size;
	
	            if (!this.head) {
	                this.head = this.tail = new Node(data);
	            } else {
	                var node = new Node(data, null, this.head);
	                this.head.prev = node;
	                this.head = node;
	            }
	
	            return data;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            if (!this.tail) {
	                this.head = this.tail = null;
	                return;
	            }
	
	            --this.size;
	
	            this.tail.prev.next = null;
	            this.tail = this.tail.prev;
	        }
	    }, {
	        key: 'shift',
	        value: function shift() {
	            if (!this.head) {
	                this.head = this.tail = null;
	                return;
	            }
	
	            --this.size;
	
	            this.head.next.prev = null;
	            this.head = this.head.next;
	        }
	    }, {
	        key: 'update',
	        value: function update(index, data) {
	            var node = this.findByIndex(index, true);
	            node.data = data;
	            return this;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(data) {
	            if (typeof data === 'function') throw new Error('data argument required');
	
	            var current = this.head;
	
	            while (current) {
	                if (this.compare(data, current.data)) {
	                    --this.size;
	
	                    if (current === this.head) {
	                        this.head = this.head.next;
	
	                        if (this.head) {
	                            this.head.prev = null;
	                        } else {
	                            this.head = this.tail = null;
	                        }
	                    } else if (current === this.tail) {
	                        this.tail = this.tail.prev;
	
	                        if (this.tail) {
	                            this.tail.next = null;
	                        } else {
	                            this.head = this.tail = null;
	                        }
	                    } else {
	                        current.prev.next = current.next;
	                        current.next.prev = current.prev;
	                    }
	
	                    return current.data;
	                }
	
	                current = current.next;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(data) {
	            var current = this.head;
	            var index = -1;
	
	            while (current) {
	                ++index;
	                if (this.compare(data, current.data)) return index;
	
	                current = current.next;
	            }
	
	            return -1;
	        }
	    }, {
	        key: 'findByIndex',
	        value: function findByIndex() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            var returnNode = arguments[1];
	
	            var current = this.head;
	            var j = 0;
	
	            while (current) {
	                if (j++ === index) break;
	
	                current = current.next;
	            }
	
	            return returnNode ? current : current.data;
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach() {
	            var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	            if (typeof cb !== 'function') throw new Error('argument should be a function');
	
	            var current = this.head;
	
	            while (current) {
	                cb(current.data);
	
	                current = current.next;
	            }
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            var list = [];
	            var current = this.head;
	
	            while (current) {
	                list.push(current.data);
	
	                current = current.next;
	            }
	
	            return list;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.toJSON() + '';
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this.size;
	        }
	    }]);
	    return DoubleLinkedList;
	}();
	
	exports.default = DoubleLinkedList;
	
	
	var a = new DoubleLinkedList([2, 3]);
	a.unshift(1);
	a.push(4);
	console.log(a.indexOf(4));
	console.log(a.findByIndex(2));
	
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;
	
	try {
	    for (var _iterator2 = (0, _getIterator3.default)(a), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var item = _step2.value;
	
	        console.log(item);
	    }
	} catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	        }
	    } finally {
	        if (_didIteratorError2) {
	            throw _iteratorError2;
	        }
	    }
	}
	
	a.pop();
	a.shift();
	a.remove(2);
	a.remove(32);
	a.remove(3);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(78);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _regenerator = __webpack_require__(30);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator = __webpack_require__(18);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 由于链表在空间的合理利用上和插入，删除时不需要移动等的有点，因此在很多场合下，它是线性表的首选存储结构。然而，它也存在着实现某些基本操作，如求线性表长度时不如顺序存储结构的缺点；另一方面，由于在链表中，结点之间的关系使用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际出发重新定义线性链表及其基本操作
	 */
	
	var Node = function Node() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.next = next;
	};
	
	var LinkedList = function () {
	    function LinkedList(sqList) {
	        (0, _classCallCheck3.default)(this, LinkedList);
	
	        this.head = null;
	        this.tail = null;
	
	        if (sqList) {
	            for (var i = 0, len = sqList.length; i < len; ++i) {
	                this.push(sqList[i]);
	            }
	        }
	    }
	
	    (0, _createClass3.default)(LinkedList, [{
	        key: 'shift',
	
	
	        // delete first element and return it
	        value: function shift() {
	            var head = this.head;
	            this.head = this.head.next;
	            head.next = null;
	
	            if (this.head === null) this.tail = null;
	            return head;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            var current = this.head;
	            var previous = this.head;
	            var elem = void 0;
	
	            while (current !== null) {
	                if (this.tail === current) {
	                    if (current === this.head) {
	                        elem = this.tail.data;
	                        this.head = null;
	                        break;
	                    }
	
	                    this.tail = previous;
	
	                    previous.next = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                previous = current;
	                current = current.next;
	            }
	
	            if (this.head === null) this.tail = null;
	
	            return elem ? elem : false;
	        }
	
	        // append node
	
	    }, {
	        key: 'append',
	        value: function append(node) {
	            if (this.head !== null) {
	                this.tail.next = node;
	                this.tail = this.tail.next;
	            } else {
	                this.head = node;
	                this.tail = node;
	            }
	        }
	
	        // add data
	
	    }, {
	        key: 'push',
	        value: function push(data) {
	            if (this.head === null) {
	                this.head = new Node(data);
	                this.tail = this.head;
	            } else {
	                this.tail.next = new Node(data);
	                this.tail = this.tail.next;
	            }
	
	            this.tail.data = data;
	        }
	
	        // remove data
	
	    }, {
	        key: 'remove',
	        value: function remove(data) {
	            var current = this.head;
	            var previous = this.head;
	            var elem = void 0;
	
	            while (current !== null) {
	                if (data === current.data) {
	                    if (current === this.head) {
	                        this.head = current.next;
	                        elem = current.data;
	                        break;
	                    }
	
	                    if (current === this.tail) this.tail = previous;
	
	                    previous.next = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                previous = current;
	                current = current.next;
	            }
	
	            if (this.head === null) this.tail = null;
	
	            return elem ? elem : false;
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(data) {
	            var current = this.head;
	            var index = -1;
	            while (current !== null) {
	                ++index;
	                if (current.data === data) {
	                    return index;
	                }
	
	                current = current.next;
	            }
	
	            return index;
	        }
	    }, {
	        key: 'unshift',
	        value: function unshift(data) {
	            var temp = new Node(data);
	            temp.next = this.head;
	            this.head = temp;
	        }
	    }, {
	        key: 'insertAfter',
	        value: function insertAfter(target, data) {
	            var current = this.head;
	            while (current !== null) {
	                if (current.data === target) {
	                    var temp = new Node(data);
	                    temp.next = current.next;
	
	                    if (current === this.tail) this.tail = temp;
	
	                    current.next = temp;
	                    return;
	                }
	
	                current = current.next;
	            }
	        }
	    }, {
	        key: 'item',
	        value: function item(index) {
	            var current = this.head;
	
	            while (current !== null) {
	                if (--index === 0) return current;
	
	                current = current.next;
	            }
	
	            return null;
	        }
	    }, {
	        key: 'each',
	        value: function each(callback) {
	            if (typeof callback !== 'function') return;
	
	            for (var current = this.head; current; current = current.next) {
	                if (callback(current)) break;
	            }
	        }
	    }, {
	        key: _iterator2.default,
	        value: _regenerator2.default.mark(function value() {
	            var current;
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            current = this.head;
	
	                        case 1:
	                            if (!current) {
	                                _context.next = 7;
	                                break;
	                            }
	
	                            _context.next = 4;
	                            return current.data;
	
	                        case 4:
	                            current = current.next;
	                            _context.next = 1;
	                            break;
	
	                        case 7:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	    }, {
	        key: 'size',
	        value: function size() {
	            var current = this.head;
	            var size = 0;
	
	            while (current !== null) {
	                ++size;
	                current = current.next;
	            }
	
	            return size;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	
	            this.each(function (node) {
	                str += node.data + (node.next ? ',' : '');
	            });
	
	            return str;
	        }
	    }, {
	        key: 'orderInsert',
	        value: function orderInsert(data, cmp) {
	            cmp = typeof cmp === 'function' ? cmp : function (a, b) {
	                if (a > b) return 1;else if (a === b) return 0;else return -1;
	            };
	            var previous = this.head;
	            var current = this.head;
	
	            if (current === null) {
	                this.head = this.tail = new Node(data);
	                return;
	            }
	
	            var me = this;
	            while (current) {
	                var ret = cmp(data, current.data);
	                // 如果插入元素大于当前元素，准备下次遍历
	                if (ret > 0) {
	                    previous = current;
	                    current = current.next;
	
	                    // 如果等于，直接插入到后面
	                } else if (ret === 0) {
	                        return insertBetween(data, previous, current);
	
	                        // 如果小于则插入到前节点和当前节点中
	                        // 因为已经是排序了，所以不需要多余判断了
	                    } else {
	                            if (this.head === previous && previous === current) return this.unshift(data);else return insertBetween(data, previous, current);
	                        }
	            }
	
	            // 插入到最后一个结点
	            previous.next = new Node(data);
	            this.tail = previous.next;
	
	            function insertBetween(data, a, b) {
	                if (a == b) {
	                    if (a == me.head) return me.unshift(data);
	                } else {
	                    var temp = new Node(data);
	                    temp.next = b;
	                    a.next = temp;
	                    return true;
	                }
	            }
	        }
	
	        // 删除元素递增排列的链表中值大于min，且小于max的所有元素
	
	    }, {
	        key: 'delete_between',
	        value: function delete_between(min, max) {
	            var p = this.head;
	
	            // p是最后一个不大于min的元素
	            while (p.next && p.next.data <= min) {
	                p = p.next;
	            } // 如果还有比min更大的元素
	            var q = void 0;
	            if (p.next) {
	                q = p.next;
	                // q是第一个不小于max的元素
	                while (q && q.data < max) {
	                    q = q.next;
	                }p.next = q;
	            }
	
	            var last = q || p;
	            while (last.next) {
	                last = last.next;
	            }this.tail = last;
	        }
	
	        // 删除元素递增排列的链表的重复元素
	
	    }, {
	        key: 'delete_equal',
	        value: function delete_equal() {
	            var p = this.head;
	            var q = p.next;
	
	            while (p.next) {
	                // 当相邻两元素不相等时，p,q都向后移
	                if (p.data !== q.data) {
	                    p = p.next;
	                    q = p.next;
	                } else {
	                    while (q.data === p.data) {
	                        q = q.next;
	                    } // 删除
	                    p.next = q;
	                    p = q;
	                    q = p.next;
	                }
	            }
	        }
	    }, {
	        key: 'reverse',
	        value: function reverse() {
	            var p = this.head;
	            var q = p.next;
	            var s = q.next;
	            p.next = null;
	
	            while (s.next) {
	                q.next = p;
	                p = q;
	                q = s;
	                s = s.next;
	            }
	
	            q.next = p;
	            s.next = q;
	            this.head = s;
	        }
	    }], [{
	        key: 'mergeList',
	        value: function mergeList(a, b) {
	            var compare = arguments.length <= 2 || arguments[2] === undefined ? compFn : arguments[2];
	
	            var ha = a.head;
	            var hb = b.head;
	            var pa = ha;
	            var pb = hb;
	            var c = new LinkedList();
	            var q = void 0;
	
	            while (pa && pb) {
	                var data1 = pa.data;
	                var data2 = pb.data;
	
	                if (!compare(data1, data2)) {
	                    // delete head node
	                    q = a.shift();
	                    // append the node to c linkedList
	                    c.append(q);
	                    pa = a.head;
	                } else {
	                    q = b.shift();
	                    c.append(q);
	                    pb = b.head;
	                }
	            }
	
	            if (pa) c.append(pa);else c.append(pb);
	
	            return c;
	        }
	    }]);
	    return LinkedList;
	}();
	
	exports.default = LinkedList;
	
	
	function compFn(a, b) {
	    return a - b;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(list, bList) {
	    var cList = new LinkedList();
	
	    var p = list.head;
	    var q = bList.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (q.data > q.data) q = q.next;else {
	            cList.push(q.data);
	            p = p.next;
	            q = q.next;
	        }
	    }
	
	    return cList;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(list, bList) {
	    var p = list.head;
	    var q = bList.head;
	    var pc = list.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            pc.data = p.data;
	            p = p.next;
	            q = q.next;
	
	            if (!p || !q) {
	                pc.next = null;
	                list.tail = pc;
	            } else pc = pc.next;
	        }
	    }
	
	    pc.next = null;
	    list.tail = pc;
	}
	
	// a，b，c的元素均是非递减排列
	// 求a链表中非b链表和c链表的交集的元素。
	function intersect_delete(list, b, c) {
	    var p = b.head;
	    var q = c.head;
	    var r = list.head;
	
	    while (p && q && r) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            // 确定待删除元素
	            var elem = p.data;
	
	            if (r.data === elem && r === list.head) {
	                list.head = list.head.next;
	            } else {
	                // 确定最后一个小于elem的元素指针
	                while (r.next && r.next.data < elem) {
	                    r = r.next;
	                }if (r.next.data === elem) {
	                    var s = r.next;
	
	                    // 确定第一个大于elem的元素指针
	                    while (s && s.data === elem) {
	                        s = s.next;
	                    } // 删除r和s之间的元素
	                    r.next = s;
	                }
	            }
	
	            while (p && p.data === elem) {
	                p = p.next;
	            }while (q && q.data === elem) {
	                q = q.next;
	            }
	        }
	    }
	
	    list.tail = r;
	}
	
	var list = new LinkedList();
	list.push('b');
	list.unshift('a');
	list.insertAfter('b', 'c');
	console.log(list.item(2));
	console.log((0, _stringify2.default)(list));
	list.each(function (node) {
	    if (node.data === 'b') {
	        console.log('get b in each');
	    }
	});
	list.remove('c');
	list.remove('a');
	console.log(list);
	
	var list2 = new LinkedList();
	list2.push('c');
	list2.unshift('d');
	list2.insertAfter('d', 'b');
	console.log((0, _stringify2.default)(list2));
	
	var list3 = LinkedList.mergeList(list, list2);
	console.log(list3);
	
	var list = new LinkedList();
	
	list.orderInsert(5);
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	list.orderInsert(4);
	list.orderInsert(4);
	list.orderInsert(6);
	list.orderInsert(6);
	list.orderInsert(7);
	
	list.delete_between(5, 8);
	console.log('delete-between:  ');
	console.log(list);
	
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	
	list.delete_equal();
	console.log(list);
	
	list.reverse();
	console.log(list);
	
	var a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var b = new LinkedList();
	b.orderInsert(1);
	b.orderInsert(5);
	b.orderInsert(9);
	b.orderInsert(13);
	b.orderInsert(17);
	console.log(intersect(a, b));
	
	console.log(intersect_true(a, b));
	
	a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var test = new LinkedList();
	test.orderInsert(1);
	test.orderInsert(2);
	test.orderInsert(3);
	test.orderInsert(4);
	test.orderInsert(5);
	test.orderInsert(6);
	test.orderInsert(9);
	
	intersect_delete(test, a, b);
	console.log(test);
	
	var popTest = new LinkedList();
	popTest.push(1);
	popTest.push(2);
	popTest.pop();
	popTest.pop();

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 静态单链表
	/*
	 有时可借用一维数组来描述线性链表，这就是线性表的静态单链表存储结构。
	 在静态链表中，数组的一个分量表示一个结点，同时用游标（cur）代替指针指示结点在数组中的相对位置。
	 数组的第0分量可看成头结点，其指针域指示链表的第一个结点。
	 这种存储结构需要预先分配一个较大的空间，但在线性表的插入和删除操作时不需移动元素，
	 仅需要修改指针，故仍具有链式存储结构的主要优点
	 */
	
	var StaticLinkedList = function () {
	    function StaticLinkedList(MAXSIZE) {
	        (0, _classCallCheck3.default)(this, StaticLinkedList);
	
	        this[-1] = { cur: 0 };
	        this.length = 0;
	        this.MAXSIZE = MAXSIZE + 1 || 1000;
	    }
	
	    /**
	     * 在静态单链线性表L中查找第1个值为e的元素，
	     * 若找到，则返回它在L中的位序
	     * @param data
	     */
	
	
	    (0, _createClass3.default)(StaticLinkedList, [{
	        key: 'find',
	        value: function find(data) {
	            var i = this[0].cur;
	            while (i && this[i].data !== data) {
	                i = this[i].cur;
	            }
	            return i;
	        }
	        /**
	         * 将一维数组中各分量链成一个备用链表
	         * this[0].cur为头指针
	         */
	
	    }, {
	        key: 'init',
	        value: function init(len) {
	            len = len ? len + 1 : this.MAXSIZE;
	            for (var i = 0; i < len - 1; ++i) {
	                this[i] = this[i] || { data: null, cur: null };
	                this[i].cur = i + 1;
	            }
	
	            this[len - 1] = this[len - 1] || {};
	            this[len - 1].cur = 0;
	        }
	        /**
	         * 若备用链表非空，则返回分配的结点下标，反则返回0
	         * @returns {*}
	         */
	
	    }, {
	        key: 'malloc',
	        value: function malloc() {
	            var i = this[-1].cur;
	            if (typeof this[-1].cur !== 'undefined') this[-1].cur = this[i].cur;
	            return i;
	        }
	        /**
	         * 将下标为k的空闲结点回收到备用链表
	         * @param k
	         */
	
	    }, {
	        key: 'free',
	        value: function free(k) {
	            this[k].cur = this[0].cur;
	            this[0].cur = k;
	        }
	    }, {
	        key: 'create',
	        value: function create(sqList) {
	            // 初始化备用空间
	            this.init(sqList.length);
	            // 生成s的头结点
	            var s = this.malloc();
	            // r指向s的当前最后结点
	            var r = s;
	            var m = sqList.length;
	
	            // 建立集合A的链表
	            for (var j = 0; j < m; ++j) {
	                //分配结点
	                var i = this.malloc();
	                // 输入A元素的值
	                this[i].data = sqList[j];
	                // 插入到表尾
	                this[r].cur = i;
	                ++this.length;
	                r = i;
	            }
	            // 尾结点的指针为空
	            this[r].cur = 0;
	        }
	
	        // todo
	
	    }, {
	        key: 'add',
	        value: function add(index, elem) {}
	    }, {
	        key: 'remove',
	        value: function remove(index) {}
	    }]);
	    return StaticLinkedList;
	}();
	
	/**
	 * 在一维数组中建立表示集合(A-B)U(B-A)
	 * 的静态链表，s为其头指针。
	 * @returns {*}
	 */
	
	
	exports.default = StaticLinkedList;
	function difference(sllist, arr1, arr2) {
	    // 初始化备用空间
	    sllist.init();
	    // 生成s的头结点
	    var s = sllist.malloc();
	    // r指向s的当前最后结点
	    var r = s;
	    // 删除A和B的元素个数
	    var m = arr1.length;
	    var n = arr2.length;
	
	    // 建立集合A的链表
	    for (var j = 0; j < m; ++j) {
	        //分配结点
	        var i = sllist.malloc();
	        // 输入A元素的值
	        sllist[i].data = arr1[j];
	        // 插入到表尾
	        sllist[r].cur = i;
	        r = i;
	    }
	    // 尾结点的指针为空
	    sllist[r].cur = 0;
	
	    // 依次输入B的元素，若不在当前表中，则插入，
	    // 否则删除
	    for (var _j = 0; _j < n; ++_j) {
	        var b = arr2[_j];
	        var p = s;
	        // k指向集合中的第一个结点
	        var k = sllist[s].cur;
	        // 在当前表中查找
	        while (k !== sllist[r].cur && sllist[k].data !== b) {
	            p = k;
	            k = sllist[k].cur;
	        }
	        // 当前表中不存在该元素，插入在r所指结点之后，且r的位置不变
	        if (k === sllist[r].cur) {
	            var _i = sllist.malloc();
	            sllist[_i].data = b;
	            sllist[_i].cur = sllist[r].cur;
	            sllist[r].cur = _i;
	
	            // 该元素已在表中，删除之
	        } else {
	                sllist[p].cur = sllist[k].cur;
	                sllist.free(k);
	                // 若删除的是r所指结点，则需修改尾指针
	                if (r === k) r = p;
	            }
	    }
	}
	
	var sl = new StaticLinkedList(10);
	var ret = difference(sl, [1, 2, 3], [3, 4, 5]);
	console.log(sl);
	
	var test = new StaticLinkedList(10);
	test.create([49, 38, 65, 97, 76, 13, 27, 49]);
	console.log(test);

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(17);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(25);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(24);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinaryTree2 = __webpack_require__(22);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BSTNode = function (_BinaryTree) {
	    (0, _inherits3.default)(BSTNode, _BinaryTree);
	
	    function BSTNode() {
	        var _Object$getPrototypeO;
	
	        (0, _classCallCheck3.default)(this, BSTNode);
	
	        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
	            arg[_key] = arguments[_key];
	        }
	
	        return (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(BSTNode)).call.apply(_Object$getPrototypeO, [this].concat(arg)));
	    }
	
	    /**
	     * BST树的查找（递归）
	     * @param {*} key
	     * @returns {*}
	     */
	
	
	    (0, _createClass3.default)(BSTNode, [{
	        key: 'search',
	        value: function search(key) {
	            if (this.data != null) {
	                if (this.data === key) return this;else if (key < this.data) {
	                    if (this.leftChild) return this.leftChild.search(key);
	                } else {
	                    if (this.rightChild) return this.rightChild.search(key);
	                }
	            }
	
	            return null;
	        }
	
	        /**
	         * BST树的查找（非递归）
	         * @param {*} key
	         * @returns {*}
	         */
	
	    }, {
	        key: 'searchNonRecursive',
	        value: function searchNonRecursive(key) {
	            if (this.data == null) return null;
	
	            var p = this;
	            while (p && p.data !== key) {
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            if (!p || key !== p.data) return null;else return p;
	        }
	
	        /**
	         * BST树的插入（递归）
	         * @param {*} key
	         */
	
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            if (this.data == null) {
	                this.data = key;
	                return;
	            }
	            if (key === this.data) return;
	
	            var node = new BSTNode(key);
	            if (key < this.data) {
	                if (!this.leftChild) this.leftChild = node;
	                this.leftChild.insert(key);
	            } else {
	                if (!this.rightChild) this.rightChild = node;
	                this.rightChild.insert(key);
	            }
	        }
	
	        /**
	         * BST树的插入（非递归）
	         * @param {*} key
	         */
	
	    }, {
	        key: 'insertNonRecursive',
	        value: function insertNonRecursive(key) {
	            if (this.data == null) {
	                this.data = key;
	                return;
	            }
	
	            var p = this;
	            var q = void 0;
	            while (p) {
	                if (p.data === key) return;
	                // q作为p的父节点
	                q = p;
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            var node = new BSTNode(key);
	            if (key < q.data) q.leftChild = node;else q.rightChild = node;
	        }
	
	        /**
	         * 利用BST树的插入操作建立一棵BST树
	         * @param {Array} arr
	         * @param {Boolean|undefined} useNonRecursive 是否使用非递归
	         */
	
	    }, {
	        key: 'createBST',
	        value: function createBST(arr, useNonRecursive) {
	            var i = void 0;
	            if (useNonRecursive) {
	                for (i = 0; i < arr.length; ++i) {
	                    this.insertNonRecursive(arr[i]);
	                }
	            } else {
	                for (i = 0; i < arr.length; ++i) {
	                    this.insert(arr[i]);
	                }
	            }
	
	            return this;
	        }
	
	        /**
	         * 使用递归的方法删除与关键字符合的结点
	         * @param {*} key 需要查找的关键字
	         * @param {BSTNode} parent 父节点，内部调用需要用到
	         * @returns {Boolean}
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key, parent) {
	            // 空结点的情况
	            if (this.data == null) return false;
	
	            // 找到关键字
	            if (this.data === key) return deleteNode(this, parent);
	            // 查找左子树，如果有的话
	            else if (key < this.data) {
	                    if (this.leftChild) return this.leftChild.remove(key, this);
	                }
	                // 查找右子树，如果有的话
	                else {
	                        if (this.rightChild) return this.rightChild.remove(key, this);
	                    }
	
	            // 未找到
	            return false;
	        }
	
	        /**
	         * 非递归删除与关键字符合的结点
	         * @param {*} key 需要查找的关键字
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'removeNonRecursive',
	        value: function removeNonRecursive(key) {
	            var p = this;
	            var f = void 0;
	
	            while (p && p.data !== key) {
	                f = p;
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            // 没有要删除的结点
	            if (!p) return false;
	
	            // 找到了要删除的结点p
	            var s = p;
	            var q = void 0;
	            // 如果有左右子树
	            if (p.leftChild && p.rightChild) {
	                f = p;
	                s = p.leftChild;
	
	                // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                while (s.rightChild) {
	                    f = s;
	                    s = s.rightChild;
	                }
	
	                p.data = s.data;
	            }
	
	            // 若s有左子树，右子树为空
	            if (s.leftChild) q = s.leftChild;else q = s.rightChild;
	
	            // 只有一个根结点的情况
	            if (!f) this.data = null;else if (f.leftChild == s) f.leftChild = q;else f.rightChild = q;
	
	            return true;
	        }
	
	        /**
	         * 找到小于x的最大元素和大于x的最小元素
	         * @param {String|Number} x
	         * @returns {Array} [min, max]
	         */
	
	    }, {
	        key: 'findNeighborElem',
	        value: function findNeighborElem(x) {
	            var last = typeof this.data === 'number' ? -Infinity : 'a';
	            var ret = [];
	
	            void function recurse(tree, x) {
	                if (tree.leftChild) recurse(tree.leftChild, x);
	                if (last < x && tree.data >= x) ret[0] = last;
	                if (last <= x && tree.data > x) ret[1] = tree.data;
	                last = tree.data;
	                if (tree.rightChild) recurse(tree.rightChild, x);
	            }(this, x);
	
	            return ret;
	        }
	
	        /**
	         * 把二叉排序树bst合并到该树中
	         * @param {BSTNode} bst
	         */
	
	    }, {
	        key: 'merge',
	        value: function merge(bst) {
	            if (bst.leftChild) this.merge(bst.leftChild);
	            if (bst.rightChild) this.merge(bst.rightChild);
	            this.insert(bst.data);
	        }
	
	        /**
	         * 把结点插入到合适位置
	         * @param {BSTNode} node 待插入的结点
	         */
	
	    }, {
	        key: 'insertNode',
	        value: function insertNode(node) {
	            if (this.data == null) {
	                this.data = node.data;
	            } else {
	                if (node.data > this.data) {
	                    if (!this.rightChild) this.rightChild = node;else this.rightChild.insertNode(node);
	                } else if (node.data < this.data) {
	                    if (!this.leftChild) this.leftChild = node;else this.leftChild.insertNode(node);
	                }
	            }
	
	            node.leftChild = node.rightChild = null;
	        }
	
	        /**
	         * 分裂为两棵二叉排序树
	         * @param {*} x
	         * @returns {BSTNode[a, b]} a的元素全部小于等于x，b的元素全部大于x
	         */
	
	    }, {
	        key: 'split',
	        value: function split(x) {
	            var a = new BSTNode();
	            var b = new BSTNode();
	
	            void function split(tree, x) {
	                if (tree.leftChild) split(tree.leftChild, x);
	                if (tree.rightChild) split(tree.rightChild, x);
	                if (tree.data <= x) a.insertNode(tree);else b.insertNode(tree);
	            }(this, x);
	
	            return [a, b];
	        }
	
	        /**
	         * 判断tree是否是二叉排序树
	         * @param tree
	         */
	
	    }], [{
	        key: 'isBSTTree',
	        value: function isBSTTree(tree) {
	            var last = typeof tree.data === 'number' ? -Infinity : 'a';
	            var flag = true;
	
	            void function isBSTTree(tree) {
	                if (tree.leftChild && flag) isBSTTree(tree.leftChild);
	                if (tree.data < last) flag = false;
	                last = tree.data;
	                if (tree.rightChild && flag) isBSTTree(tree.rightChild);
	            }(tree);
	
	            return flag;
	        }
	    }]);
	    return BSTNode;
	}(_BinaryTree2.BinaryTree);
	
	/**
	 * 删除结点
	 * @param {BSTNode} p 要删除的结点
	 * @param {BSTNode} parent 要删除的结点的父节点
	 * @returns {boolean} 返回删除成功
	 */
	/*
	 动态查找
	
	 当查找表以线性表的形式组织时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。
	 利用树的形式组织查找表，可以对查找表进行动态高效的查找。
	
	
	 二叉排序树(BST)的定义
	
	 二叉排序树(Binary Sort Tree或Binary Search Tree) 的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。
	 (1) ：若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；
	 (2) ：若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；
	 (3) ：左、右子树都分别是二叉排序树。
	 结论：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。
	
	
	 BST树的查找
	 1  查找思想
	 首先将给定的K值与二叉排序树的根结点的关键字进行比较：若相等： 则查找成功；
	 ① 给定的K值小于BST的根结点的关键字：继续在该结点的左子树上进行查找；
	 ② 给定的K值大于BST的根结点的关键字：继续在该结点的右子树上进行查找。
	
	 在随机情况下，二叉排序树的平均查找长度ASL和㏒(n)(树的深度)是等数量级的。
	
	
	 BST树的插入
	
	 在BST树中插入一个新结点，要保证插入后仍满足BST的性质。
	
	 1 插入思想
	 在BST树中插入一个新结点x时，若BST树为空，则令新结点x为插入后BST树的根结点；否则，将结点x的关键字与根结点T的关键字进行比较：
	 ① 若相等： 不需要插入；
	 ②  若x.key<T->key：结点x插入到T的左子树中；
	 ③  若x.key>T->key：结点x插入到T的右子树中。
	
	 由结论知，对于一个无序序列可以通过构造一棵BST树而变成一个有序序列。
	 由算法知，每次插入的新结点都是BST树的叶子结点，即在插入时不必移动其它结点，仅需修改某个结点的指针。
	
	
	 BST树的删除
	
	 1  删除操作过程分析
	 从BST树上删除一个结点，仍然要保证删除后满足BST的性质。设被删除结点为p，其父结点为f ，删除情况如下：
	 ①  若p是叶子结点： 直接删除p。
	 ②  若p只有一棵子树(左子树或右子树)：直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树。
	 ③ 若p既有左子树又有右子树 ：处理方法有以下两种，可以任选其中一种。
	 ◆  用p的直接前驱结点代替p。即从p的左子树中选择值最大的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的左子树中的最右边的结点且没有右子树，对s的删除同②。
	 ◆ 用p的直接后继结点代替p。即从p的右子树中选择值最小的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的右子树中的最左边的结点且没有左子树，对s的删除同②。
	
	 */
	
	exports.default = BSTNode;
	function deleteNode(p, parent) {
	    // 叶子结点或只有一个结点
	    if (!p.leftChild && !p.rightChild) {
	        // 当前结点是其父结点的左子树还是右子树
	        var pos = parent && parent.leftChild == p ? 'leftChild' : 'rightChild';
	        if (parent) parent[pos] = null;
	        // 只有一个结点的情况
	        else p.data = null;
	    }
	    // 只有左子树
	    else if (!p.rightChild) {
	            p.data = p.leftChild.data;
	            p.leftChild = p.leftChild.leftChild;
	        }
	        // 只有右子树
	        else if (!p.leftChild) {
	                p.data = p.rightChild.data;
	                p.rightChild = p.rightChild.rightChild;
	            }
	            // 左右子树都有
	            else {
	                    var s = p.leftChild;
	                    // q为父结点
	                    var q = p;
	                    // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                    while (s.rightChild) {
	                        q = s;
	                        s = s.rightChild;
	                    }
	
	                    p.data = s.data;
	                    if (q != p) q.rightChild = s.leftChild;else q.leftChild = s.leftChild;
	                }
	
	    return true;
	}
	
	var bst = new BSTNode();
	bst.createBST([45, 24, 53, 12, 24, 90]);
	console.log(bst.search(12));
	console.log(bst.search(13));
	
	var bst2 = new BSTNode();
	bst2.createBST([45, 24, 53, 12, 24, 90], true);
	console.log(bst2.searchNonRecursive(12));
	console.log(bst2.searchNonRecursive(13));
	
	console.log('\nfindSiblingElem: ');
	console.log(bst.findNeighborElem(12) + '');
	console.log(bst.findNeighborElem(90) + '');
	console.log(bst.findNeighborElem(45) + '');
	
	console.log(bst.remove(45));
	console.log(bst.remove(1));
	console.log(bst.remove(53));
	console.log(bst.remove(12));
	console.log(bst.remove(90));
	console.log(bst.remove(24));
	console.log(bst.remove(2));
	
	//console.log(bst2.removeNonRecursive(45));
	//console.log(bst2.removeNonRecursive(1));
	//console.log(bst2.removeNonRecursive(53));
	//console.log(bst2.removeNonRecursive(12));
	//console.log(bst2.removeNonRecursive(90));
	//console.log(bst2.removeNonRecursive(24));
	//console.log(bst2.removeNonRecursive(2));
	
	console.log('\nisBSTTree: ');
	console.log(BSTNode.isBSTTree(bst));
	//console.log(BSTNode.isBSTTree(sosTree));
	
	/**
	 * 从大到小输出二叉排序树中所有不小于x的元素
	 * @param bst
	 * @param x
	 */
	function printNotLessThan(bst, x) {
	    if (bst.rightChild) printNotLessThan(bst.rightChild, x);
	    if (bst.data < x) return;
	    console.log(bst.data);
	    if (bst.leftChild) printNotLessThan(bst.leftChild, x);
	}
	
	console.log('\nprintNotLessThan: ');
	printNotLessThan(bst2, 90);
	console.log('\n');
	printNotLessThan(bst2, 12);
	
	bst.merge(bst2);
	
	var a1 = new BSTNode(5);
	var a2 = new BSTNode(91);
	bst2.insertNode(a1);
	bst2.insertNode(a2);
	
	bst2.split(45);

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.bubbleSort = bubbleSort;
	exports.bubbleSort2 = bubbleSort2;
	exports.cockTailSort = cockTailSort;
	exports.cockTailSort2 = cockTailSort2;
	exports.quickSortRecursive = quickSortRecursive;
	exports.quickSortRecursive2 = quickSortRecursive2;
	exports.quickSortNonRecursive = quickSortNonRecursive;
	exports.quickSort = quickSort;
	exports.oddEvenSort = oddEvenSort;
	
	var _defaultComparision = __webpack_require__(29);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 交换排序
	
	 是一类基于交换的排序，系统地交换反序的记录的偶对，直到不再有这样的偶对为止。其中最基本的是冒泡排序(Bubble Sort)。
	
	 冒泡排序
	 1  排序思想
	 依次比较相邻的两个记录的关键字，若两个记录是反序的(即前一个记录的关键字大于后前一个记录的关键字)，则进行交换，直到没有反序的记录为止。
	     ① 首先将L->R[1]与L->R[2]的关键字进行比较，若为反序(L->R[1]的关键字大于L->R[2]的关键字)，则交换两个记录；然后比较L->R[2]与L->R[3]的关键字，依此类推，直到L->R[n-1]与L->R[n]的关键字比较后为止，称为一趟冒泡排序，L->R[n]为关键字最大的记录。
	     ②  然后进行第二趟冒泡排序，对前n-1个记录进行同样的操作。
	 一般地，第i趟冒泡排序是对L->R[1 … n-i+1]中的记录进行的，因此，若待排序的记录有n个，则要经过n-1趟冒泡排序才能使所有的记录有序。
	
	 2  排序示例
	 设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41
	
	 初始关键字序列:  23    38     22     45     23     67     31     15    41
	 第一趟排序后:    23    22     38     23     45     31     15     41    67
	 第二趟排序后:    22    23     23     38     31     15     41     45    67
	 第三趟排序后:    22    23     23     31     15     38     41     45    67
	 第四趟排序后:    22    23     23     15     31     38     41     45    67
	 第五趟排序后:    22    23     15     23     31     38     41     45    67
	 第六趟排序后:    22    15     23     23     31     38     41     45    67
	 第七趟排序后:    15    22     23     23     31     38     41     45    67
	
	3.算法分析
	 时间复杂度
	 ◆  最好情况(正序)：比较次数：n-1；移动次数：0；
	 ◆  最坏情况(逆序)：
	 比较次数： n * (n - 1) / 2
	 移动次数： 3*n*(n - 1) / 2
	
	 故时间复杂度：T(n)=O(n²)
	 空间复杂度：S(n)=O(1)
	
	 */
	
	function bubbleSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var change = 0;
	
	        for (var j = 0; j <= len - i; ++j) {
	            if (comp(sqList[j + 1], sqList[j]) < 0) {
	                change = 1;
	                var temp = sqList[j];
	                sqList[j] = sqList[j + 1];
	                sqList[j + 1] = temp;
	            }
	        }
	
	        if (!change) break;
	    }
	} /**
	   * Created by Luke on 2015/2/2.
	   */
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort(arr);
	console.log('bubbleSort:\n' + arr + '');
	
	// 冒泡改进1
	function bubbleSort2(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var len = sqList.length;
	    var change = len - 1;
	
	    while (change) {
	        var c = 0;
	        for (var i = 0; i < change; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                // c指示这一趟冒泡中发生交换的元素
	                c = i + 1;
	            }
	        }
	
	        change = c;
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort2(arr);
	console.log('bubbleSort2:\n' + arr + '');
	
	// 相邻两趟反方向起泡的冒泡排序算法
	function cockTailSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var len = sqList.length;
	    // 冒泡上下界
	    var low = 0,
	        high = len - 1;
	    var change = 1;
	    var temp = void 0;
	
	    while (low < high && change) {
	        change = 0;
	
	        // 从上向下起泡
	        for (var i = low; i < high; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改上界
	        --high;
	
	        // 从下向上起泡
	        for (var _i = high; _i > low; --_i) {
	            if (comp(sqList[_i], sqList[_i - 1]) < 0) {
	                temp = sqList[_i];
	                sqList[_i] = sqList[_i - 1];
	                sqList[_i - 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改下界
	        ++low;
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort(arr);
	console.log('cockTailSort:\n' + arr + '');
	
	// 改进3
	function cockTailSort2(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var b = {};
	    var len = sqList.length;
	    // d为冒泡方向标识， 1为向上，-1为向下
	    var d = 1;
	    // b[0]为冒泡上界，b[2]为冒泡上界，b[1]无用
	    b[0] = 0;
	    b[2] = len - 1;
	    var change = 1;
	
	    while (b[0] < b[2] && change) {
	        change = 0;
	
	        // 统一的冒泡算法
	        for (var i = b[1 - d]; i !== b[1 + d]; i += d) {
	            // 注意这个交换条件
	            if (comp(sqList[i], sqList[i + d]) * d > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + d];
	                sqList[i + d] = temp;
	                change = 1;
	            }
	        }
	
	        // 修改边界
	        b[1 + d] -= d;
	        // 换个方向
	        d *= -1;
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort2(arr);
	console.log('cockTailSort2:\n' + arr + '');
	
	/*
	 快速排序
	
	 1  排序思想
	 通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录进行下一趟排序，以达到整个序列有序。
	
	 2  排序过程
	 设待排序的记录序列是R[s…t] ，在记录序列中任取一个记录(一般取R[s])作为参照(又称为基准或枢轴)，以R[s].key为基准重新排列其余的所有记录，方法是：
	     ◆ 所有关键字比基准小的放R[s]之前；
	     ◆ 所有关键字比基准大的放R[s]之后。
	 以R[s].key最后所在位置i作为分界，将序列R[s…t]分割成两个子序列，称为一趟快速排序。
	
	 3  一趟快速排序方法
	 从序列的两端交替扫描各个记录，将关键字小于基准关键字的记录依次放置到序列的前边；而将关键字大于基准关键字的记录从序列的最后端起，依次放置到序列的后边，直到扫描完所有的记录。
	
	 设置指针low，high，初值为第1个和最后一个记录的位置。
	 设两个变量i，j，初始时令i=low，j=high，以R[low].key作为基准(将R[low]保存在temp中) 。
	 ① 从j所指位置向前搜索：将temp与R[j].key进行比较：
	    ◆ 若temp≤R[j].key ：令j=j-1，然后继续进行比较， 直到i=j或temp>R[j].key为止；
	    ◆ 若temp>R[j].key ：R[j]R[i]，腾空R[j]的位置， 且令i=i+1；
	 ② 从i所指位置起向后搜索：将temp与R[i].key进行比较：
	    ◆ 若temp≥R[i].key ：令i=i+1，然后继续进行比较， 直到i=j或temp<R[i].key为止；
	    ◆ 若temp<R[i].key ：R[i]R[j]，腾空R[i]的位置， 且令j=j-1；
	 ③ 重复①、②，直至i=j为止，i就是temp(基准)所应放置的位置。
	
	 算法分析
	 快速排序的主要时间是花费在划分上，对长度为k的记录序列进行划分时关键字的比较次数是k-1 。设长度为n的记录序列进行排序的比较次数为C(n)，则C(n)=n-1+C(k)+C(n-k-1) 。
	 ◆  最好情况：每次划分得到的子序列大致相等，则
	 C(n)<=h×n+2h×C(n/2h) ，当n/2h=1时排序结束。
	 即C(n)≤O(n×㏒2n) ；
	 ◆  最坏情况：每次划分得到的子序列中有一个为空，另一个子序列的长度为n-1。即每次划分所选择的基准是当前待排序序列中的最小(或最大)关键字。
	 比较次数：:  即C(n)=O(n2)
	 ◆  一般情况： 对n个记录进行快速排序所需的时间T(n)组成是：
	     ① 对n个记录进行一趟划分所需的时间是：n×C ，C是常数；
	     ② 对所得到的两个子序列进行快速排序的时间：
	        Tavg(n)=C(n)+Tavg(k-1)+Tavg(n-k)          ……
	
	 快速排序的平均时间复杂度是：T(n)=O(n㏒2n)
	 从所需要的附加空间来看，快速排序算法是递归调用，系统内用堆栈保存递归参数，当每次划分比较均匀时，栈的最大深度为[㏒2n]+1 。
	
	 快速排序的空间复杂度是：S(n)=O(㏒2n)
	 从排序的稳定性来看，快速排序是不稳定的。
	
	 */
	
	function partition1(sqList, low, high) {
	    var temp = sqList[low];
	
	    while (low < high) {
	        while (low < high && sqList[high] >= temp) {
	            --high;
	        }sqList[low] = sqList[high];
	        while (low < high && sqList[low] <= temp) {
	            ++low;
	        }sqList[high] = sqList[low];
	    }
	
	    sqList[low] = temp;
	
	    return low;
	}
	
	// 优化一趟快速排序方法： 随机化partition
	// 最坏情况效率大幅提升，时间复杂度T(n)=O(n㏒2n)
	function partition2(sqList, low, high) {
	    var temp = void 0;
	    var n = high - low + 1;
	    var rand = Math.floor(Math.random() * n) + low;
	
	    //let rand = (low + high) >> 1;
	    temp = sqList[high];
	    sqList[high] = sqList[rand];
	    sqList[rand] = temp;
	
	    var i = low - 1;
	    var pivot = sqList[high];
	
	    for (var j = low; j < high; ++j) {
	        if (sqList[j] <= pivot) {
	            ++i;
	            temp = sqList[i];
	            sqList[i] = sqList[j];
	            sqList[j] = temp;
	        }
	    }
	
	    ++i;
	    sqList[high] = sqList[i];
	    sqList[i] = pivot;
	
	    return i;
	}
	
	function partition(sqList, low, high, comp) {
	    var temp = void 0;
	    var i = low;
	    var j = high + 1;
	    var rand = Math.floor(Math.random() * (high - low)) + low + 1;
	    //let rand = (low + high) >> 1;
	
	    temp = sqList[low];
	    sqList[low] = sqList[rand];
	    sqList[rand] = temp;
	
	    var x = sqList[low];
	
	    while (1) {
	        while (comp(sqList[++i], x) < 0 && i < high) {}
	        while (comp(sqList[--j], x) > 0) {}
	        if (i >= j) break;
	        temp = sqList[i];
	        sqList[i] = sqList[j];
	        sqList[j] = temp;
	    }
	
	    sqList[low] = sqList[j];
	    sqList[j] = x;
	
	    return j;
	}
	
	function quickSortRecursive() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    if (low >= high) return;
	
	    var k = partition(sqList, low, high, comp);
	    quickSortRecursive(sqList, low, k - 1, comp);
	    quickSortRecursive(sqList, k + 1, high, comp);
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive(arr);
	console.log('quickSortRecursive:\n' + arr + '');
	
	/*
	快排递归算法优化，在最坏情况下堆栈深度为O(logn)
	 */
	function quickSortRecursive2() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    while (low < high) {
	        var k = partition(sqList, low, high, comp);
	
	        // 对两个子数组中较小的一个子数组进行递归调用。
	        // 较小子数组的大小最多为原数组大小一半，
	        // 由于每次递归调用的数组大小至少减少一半，所以递归调用的次数
	        // 最多为O(logn)
	        if (k - low + 1 < high - k) {
	            quickSortRecursive2(sqList, low, k - 1, comp);
	            low = k + 1;
	        } else {
	            quickSortRecursive2(sqList, k + 1, high, comp);
	            high = k - 1;
	        }
	    }
	}
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive2(arr);
	console.log('quickSortRecursive2:\n' + arr + '');
	
	function quickSortNonRecursive() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    var stack = [];
	    var k = void 0;
	
	    do {
	        while (low < high) {
	            k = partition(sqList, low, high, comp);
	            // 第二个子序列的上,下界分别入栈
	            stack.push(high, k + 1);
	            //stack.push(k + 1);
	            high = k - 1;
	        }
	
	        if (!stack.length) return;
	
	        low = stack.pop();
	        high = stack.pop();
	    } while (1);
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortNonRecursive(arr);
	console.log('quickSortNonRecursive:\n' + arr + '');
	
	// 优化版本
	function quickSort() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    var stack = [];
	    var pivot = void 0;
	
	    do {
	        // 如果当前子序列长度大于3且尚未排好序
	        if (high - low > 2) {
	            // 进行一趟划分
	            pivot = partition(sqList, low, high, comp);
	
	            // 吧长的子序列边界入栈，
	            // 短的子序列留待下次排序
	            if (high - pivot > pivot - low) {
	                stack.push(high, pivot + 1);
	                //stack.push();
	                high = pivot - 1;
	            } else {
	                stack.push(pivot - 1, low);
	                //stack.push();
	                low = pivot + 1;
	            }
	        }
	        // 如果当前子序列长度小于3，且尚未排好序，
	        // 直接进行比较排序买当前子序列标志为已排好序
	        else if (low < high && high - low < 3) {
	                easySort(sqList, low, high, comp);
	                low = high;
	            }
	            // 如果当前子序列已排好序但栈中还有未排序的子序列
	            // 从栈中取出一个子序列
	            else {
	                    if (!stack.length) return;
	
	                    low = stack.pop();
	                    high = stack.pop();
	                }
	    } while (1);
	}
	
	function easySort(sqList, low, high, comp) {
	    var temp = void 0;
	
	    if (high - low === 1) {
	        if (comp(sqList[low], sqList[high]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[high];
	            sqList[high] = temp;
	        }
	    } else {
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	        if (comp(sqList[low + 1], sqList[high]) > 0) {
	            temp = sqList[low + 1];
	            sqList[low + 1] = sqList[high];
	            sqList[high] = temp;
	        }
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSort(arr);
	console.log('quickSort:\n' + arr + '');
	
	// 奇偶交换排序
	function oddEvenSort() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var change = 1;
	    var temp = void 0;
	    var len = sqList.length;
	
	    while (change) {
	        change = 0;
	        // 对所有奇数进行一趟比较
	        for (var i = 1; i < len - 1; i += 2) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	
	                change = 1;
	            }
	        }
	
	        // 对所有偶数进行一趟比较
	        for (var _i2 = 0; _i2 < len - 1; _i2 += 2) {
	            if (comp(sqList[_i2], sqList[_i2 + 1]) > 0) {
	                temp = sqList[_i2];
	                sqList[_i2] = sqList[_i2 + 1];
	                sqList[_i2 + 1] = temp;
	
	                change = 1;
	            }
	        }
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	oddEvenSort(arr);
	console.log('oddEvenSort:\n' + arr + '');
	
	/*
	把由三种颜色组成的序列重排为按照红白蓝的顺序排列，
	思路：
	设立三个指针，其中j表示当前元素；i以前的元素全部为红色；k以后的颜色全为蓝色。这样就可以根据j的颜色把其交换到序列的前面或者后面。
	 */
	var RED = 0;
	var WHITE = 1;
	var BLUE = 2;
	
	function flagArrange(colors) {
	    var i = 0;
	    var j = 0;
	    var k = colors.length - 1;
	    var temp = void 0;
	
	    while (j <= k) {
	        switch (colors[j]) {
	            case RED:
	                temp = colors[i];
	                colors[i] = colors[j];
	                colors[j] = temp;
	                ++i;
	                ++j;
	                break;
	            case WHITE:
	                ++j;
	                break;
	            case BLUE:
	                temp = colors[j];
	                colors[j] = colors[k];
	                colors[k] = temp;
	                --k;
	                break;
	            default:
	                break;
	        }
	    }
	}
	
	var arr = [2, 1, 0, 2, 1, 1, 0, 2, 0, 2, 1];
	flagArrange(arr);
	console.log(arr + '');

/***/ },
/* 72 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 73 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 74 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(86), __esModule: true };

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(88), __esModule: true };

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(89), __esModule: true };

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(91), __esModule: true };

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(92), __esModule: true };

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(94), __esModule: true };

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _getPrototypeOf = __webpack_require__(17);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _getOwnPropertyDescriptor = __webpack_require__(80);
	
	var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);
	
	  if (desc === undefined) {
	    var parent = (0, _getPrototypeOf2.default)(object);
	
	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;
	
	    if (getter === undefined) {
	      return undefined;
	    }
	
	    return getter.call(receiver);
	  }
	};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(77);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(16);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(76);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(52)
	var ieee754 = __webpack_require__(72)
	var isArray = __webpack_require__(73)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var foundIndex = -1
	  for (var i = byteOffset; i < arrLength; ++i) {
	    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	      if (foundIndex === -1) foundIndex = i
	      if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	    } else {
	      if (foundIndex !== -1) i -= i - foundIndex
	      foundIndex = -1
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  if (Buffer.isBuffer(val)) {
	    // special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(this, val, byteOffset, encoding)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset, encoding)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer, (function() { return this; }())))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(28);
	__webpack_require__(119);
	module.exports = __webpack_require__(3).Array.from;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(47);
	__webpack_require__(28);
	module.exports = __webpack_require__(117);

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(47);
	__webpack_require__(28);
	module.exports = __webpack_require__(118);

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(3)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(121);
	var $Object = __webpack_require__(3).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(122);
	var $Object = __webpack_require__(3).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(123);
	var $Object = __webpack_require__(3).Object;
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $Object.getOwnPropertyDescriptor(it, key);
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(124);
	module.exports = __webpack_require__(3).Object.getPrototypeOf;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(125);
	module.exports = __webpack_require__(3).Object.setPrototypeOf;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(127);
	__webpack_require__(126);
	__webpack_require__(128);
	__webpack_require__(129);
	module.exports = __webpack_require__(3).Symbol;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(28);
	__webpack_require__(47);
	module.exports = __webpack_require__(46).f('iterator');

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(8)
	  , toLength  = __webpack_require__(63)
	  , toIndex   = __webpack_require__(116);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(7)
	  , createDesc      = __webpack_require__(21);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(26)
	  , gOPS    = __webpack_require__(58)
	  , pIE     = __webpack_require__(38);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(6).document && document.documentElement;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(31);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(14)
	  , ITERATOR   = __webpack_require__(5)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(31);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(9);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(36)
	  , descriptor     = __webpack_require__(21)
	  , setToStringTag = __webpack_require__(39)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(13)(IteratorPrototype, __webpack_require__(5)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(5)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(26)
	  , toIObject = __webpack_require__(8);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(27)('meta')
	  , isObject = __webpack_require__(20)
	  , has      = __webpack_require__(12)
	  , setDesc  = __webpack_require__(7).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(19)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(7)
	  , anObject = __webpack_require__(9)
	  , getKeys  = __webpack_require__(26);
	
	module.exports = __webpack_require__(10) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(8)
	  , gOPN      = __webpack_require__(57).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(20)
	  , anObject = __webpack_require__(9);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(32)(Function.call, __webpack_require__(37).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(42)
	  , defined   = __webpack_require__(33);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(42)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(9)
	  , get      = __webpack_require__(64);
	module.exports = __webpack_require__(3).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(53)
	  , ITERATOR  = __webpack_require__(5)('iterator')
	  , Iterators = __webpack_require__(14);
	module.exports = __webpack_require__(3).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(32)
	  , $export        = __webpack_require__(11)
	  , toObject       = __webpack_require__(43)
	  , call           = __webpack_require__(106)
	  , isArrayIter    = __webpack_require__(104)
	  , toLength       = __webpack_require__(63)
	  , createProperty = __webpack_require__(100)
	  , getIterFn      = __webpack_require__(64);
	
	$export($export.S + $export.F * !__webpack_require__(108)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(98)
	  , step             = __webpack_require__(109)
	  , Iterators        = __webpack_require__(14)
	  , toIObject        = __webpack_require__(8);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(56)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(11)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(36)});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(11);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(10), 'Object', {defineProperty: __webpack_require__(7).f});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(8)
	  , $getOwnPropertyDescriptor = __webpack_require__(37).f;
	
	__webpack_require__(61)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(43)
	  , $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(61)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(11);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(114).set});

/***/ },
/* 126 */
/***/ function(module, exports) {



/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(6)
	  , has            = __webpack_require__(12)
	  , DESCRIPTORS    = __webpack_require__(10)
	  , $export        = __webpack_require__(11)
	  , redefine       = __webpack_require__(62)
	  , META           = __webpack_require__(111).KEY
	  , $fails         = __webpack_require__(19)
	  , shared         = __webpack_require__(41)
	  , setToStringTag = __webpack_require__(39)
	  , uid            = __webpack_require__(27)
	  , wks            = __webpack_require__(5)
	  , wksExt         = __webpack_require__(46)
	  , wksDefine      = __webpack_require__(45)
	  , keyOf          = __webpack_require__(110)
	  , enumKeys       = __webpack_require__(101)
	  , isArray        = __webpack_require__(105)
	  , anObject       = __webpack_require__(9)
	  , toIObject      = __webpack_require__(8)
	  , toPrimitive    = __webpack_require__(44)
	  , createDesc     = __webpack_require__(21)
	  , _create        = __webpack_require__(36)
	  , gOPNExt        = __webpack_require__(113)
	  , $GOPD          = __webpack_require__(37)
	  , $DP            = __webpack_require__(7)
	  , $keys          = __webpack_require__(26)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(38).f  = $propertyIsEnumerable;
	  __webpack_require__(58).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(35)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(13)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(45)('asyncIterator');

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(45)('observable');

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(65)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(135)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(65)
	
	exports.createHmac = __webpack_require__(130)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(134)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(131);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(169)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(183)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4).Buffer))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
		C-like unsigned 32 bits integers in Javascript
		Copyright (C) 2013, Pierre Curto
		MIT license
	 */
	;(function (root) {
	
		// Local cache for typical radices
		var radixPowerCache = {
			36: UINT32( Math.pow(36, 5) )
		,	16: UINT32( Math.pow(16, 7) )
		,	10: UINT32( Math.pow(10, 9) )
		,	2:  UINT32( Math.pow(2, 30) )
		}
		var radixCache = {
			36: UINT32(36)
		,	16: UINT32(16)
		,	10: UINT32(10)
		,	2:  UINT32(2)
		}
	
		/**
		 *	Represents an unsigned 32 bits integer
		 * @constructor
		 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
		 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
		 * @return 
		 */
		function UINT32 (l, h) {
			if ( !(this instanceof UINT32) )
				return new UINT32(l, h)
	
			this._low = 0
			this._high = 0
			this.remainder = null
			if (typeof h == 'undefined')
				return fromNumber.call(this, l)
	
			if (typeof l == 'string')
				return fromString.call(this, l, h)
	
			fromBits.call(this, l, h)
		}
	
		/**
		 * Set the current _UINT32_ object with its low and high bits
		 * @method fromBits
		 * @param {Number} low bits
		 * @param {Number} high bits
		 * @return ThisExpression
		 */
		function fromBits (l, h) {
			this._low = l | 0
			this._high = h | 0
	
			return this
		}
		UINT32.prototype.fromBits = fromBits
	
		/**
		 * Set the current _UINT32_ object from a number
		 * @method fromNumber
		 * @param {Number} number
		 * @return ThisExpression
		 */
		function fromNumber (value) {
			this._low = value & 0xFFFF
			this._high = value >>> 16
	
			return this
		}
		UINT32.prototype.fromNumber = fromNumber
	
		/**
		 * Set the current _UINT32_ object from a string
		 * @method fromString
		 * @param {String} integer as a string
		 * @param {Number} radix (optional, default=10)
		 * @return ThisExpression
		 */
		function fromString (s, radix) {
			var value = parseInt(s, radix || 10)
	
			this._low = value & 0xFFFF
			this._high = value >>> 16
	
			return this
		}
		UINT32.prototype.fromString = fromString
	
		/**
		 * Convert this _UINT32_ to a number
		 * @method toNumber
		 * @return {Number} the converted UINT32
		 */
		UINT32.prototype.toNumber = function () {
			return (this._high << 16) | this._low
		}
	
		/**
		 * Convert this _UINT32_ to a string
		 * @method toString
		 * @param {Number} radix (optional, default=10)
		 * @return {String} the converted UINT32
		 */
		UINT32.prototype.toString = function (radix) {
			radix = radix || 10
			var radixUint = radixCache[radix] || new UINT32(radix)
	
			if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)
	
			var self = this.clone()
			var res = new Array(32)
			for (var i = 31; i >= 0; i--) {
				self.div(radixUint)
				res[i] = self.remainder.toNumber().toString(radix)
				if ( !self.gt(radixUint) ) break
			}
			res[i-1] = self.toNumber().toString(radix)
	
			return res.join('')
		}
	
		/**
		 * Add two _UINT32_. The current _UINT32_ stores the result
		 * @method add
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.add = function (other) {
			var a00 = this._low + other._low
			var a16 = a00 >>> 16
	
			a16 += this._high + other._high
	
			this._low = a00 & 0xFFFF
			this._high = a16 & 0xFFFF
	
			return this
		}
	
		/**
		 * Subtract two _UINT32_. The current _UINT32_ stores the result
		 * @method subtract
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.subtract = function (other) {
			//TODO inline
			return this.add( other.clone().negate() )
		}
	
		/**
		 * Multiply two _UINT32_. The current _UINT32_ stores the result
		 * @method multiply
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.multiply = function (other) {
			/*
				a = a00 + a16
				b = b00 + b16
				a*b = (a00 + a16)(b00 + b16)
					= a00b00 + a00b16 + a16b00 + a16b16
	
				a16b16 overflows the 32bits
			 */
			var a16 = this._high
			var a00 = this._low
			var b16 = other._high
			var b00 = other._low
	
	/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
			// this == 0 or other == 1: nothing to do
			if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this
	
			// other == 0 or this == 1: this = other
			if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
				this._low = other._low
				this._high = other._high
				return this
			}
	*/
	
			var c16, c00
			c00 = a00 * b00
			c16 = c00 >>> 16
	
			c16 += a16 * b00
			c16 &= 0xFFFF		// Not required but improves performance
			c16 += a00 * b16
	
			this._low = c00 & 0xFFFF
			this._high = c16 & 0xFFFF
	
			return this
		}
	
		/**
		 * Divide two _UINT32_. The current _UINT32_ stores the result.
		 * The remainder is made available as the _remainder_ property on
		 * the _UINT32_ object. It can be null, meaning there are no remainder.
		 * @method div
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.div = function (other) {
			if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')
	
			// other == 1
			if (other._high == 0 && other._low == 1) {
				this.remainder = new UINT32(0)
				return this
			}
	
			// other > this: 0
			if ( other.gt(this) ) {
				this.remainder = this.clone()
				this._low = 0
				this._high = 0
				return this
			}
			// other == this: 1
			if ( this.eq(other) ) {
				this.remainder = new UINT32(0)
				this._low = 1
				this._high = 0
				return this
			}
	
			// Shift the divisor left until it is higher than the dividend
			var _other = other.clone()
			var i = -1
			while ( !this.lt(_other) ) {
				// High bit can overflow the default 16bits
				// Its ok since we right shift after this loop
				// The overflown bit must be kept though
				_other.shiftLeft(1, true)
				i++
			}
	
			// Set the remainder
			this.remainder = this.clone()
			// Initialize the current result to 0
			this._low = 0
			this._high = 0
			for (; i >= 0; i--) {
				_other.shiftRight(1)
				// If shifted divisor is smaller than the dividend
				// then subtract it from the dividend
				if ( !this.remainder.lt(_other) ) {
					this.remainder.subtract(_other)
					// Update the current result
					if (i >= 16) {
						this._high |= 1 << (i - 16)
					} else {
						this._low |= 1 << i
					}
				}
			}
	
			return this
		}
	
		/**
		 * Negate the current _UINT32_
		 * @method negate
		 * @return ThisExpression
		 */
		UINT32.prototype.negate = function () {
			var v = ( ~this._low & 0xFFFF ) + 1
			this._low = v & 0xFFFF
			this._high = (~this._high + (v >>> 16)) & 0xFFFF
	
			return this
		}
	
		/**
		 * Equals
		 * @method eq
		 * @param {Object} other UINT32
		 * @return {Boolean}
		 */
		UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
			return (this._low == other._low) && (this._high == other._high)
		}
	
		/**
		 * Greater than (strict)
		 * @method gt
		 * @param {Object} other UINT32
		 * @return {Boolean}
		 */
		UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
			if (this._high > other._high) return true
			if (this._high < other._high) return false
			return this._low > other._low
		}
	
		/**
		 * Less than (strict)
		 * @method lt
		 * @param {Object} other UINT32
		 * @return {Boolean}
		 */
		UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
			if (this._high < other._high) return true
			if (this._high > other._high) return false
			return this._low < other._low
		}
	
		/**
		 * Bitwise OR
		 * @method or
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.or = function (other) {
			this._low |= other._low
			this._high |= other._high
	
			return this
		}
	
		/**
		 * Bitwise AND
		 * @method and
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.and = function (other) {
			this._low &= other._low
			this._high &= other._high
	
			return this
		}
	
		/**
		 * Bitwise NOT
		 * @method not
		 * @return ThisExpression
		 */
		UINT32.prototype.not = function() {
			this._low = ~this._low & 0xFFFF
			this._high = ~this._high & 0xFFFF
	
			return this
		}
	
		/**
		 * Bitwise XOR
		 * @method xor
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.xor = function (other) {
			this._low ^= other._low
			this._high ^= other._high
	
			return this
		}
	
		/**
		 * Bitwise shift right
		 * @method shiftRight
		 * @param {Number} number of bits to shift
		 * @return ThisExpression
		 */
		UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
			if (n > 16) {
				this._low = this._high >> (n - 16)
				this._high = 0
			} else if (n == 16) {
				this._low = this._high
				this._high = 0
			} else {
				this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )
				this._high >>= n
			}
	
			return this
		}
	
		/**
		 * Bitwise shift left
		 * @method shiftLeft
		 * @param {Number} number of bits to shift
		 * @param {Boolean} allow overflow
		 * @return ThisExpression
		 */
		UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
			if (n > 16) {
				this._high = this._low << (n - 16)
				this._low = 0
				if (!allowOverflow) {
					this._high &= 0xFFFF
				}
			} else if (n == 16) {
				this._high = this._low
				this._low = 0
			} else {
				this._high = (this._high << n) | (this._low >> (16-n))
				this._low = (this._low << n) & 0xFFFF
				if (!allowOverflow) {
					// Overflow only allowed on the high bits...
					this._high &= 0xFFFF
				}
			}
	
			return this
		}
	
		/**
		 * Bitwise rotate left
		 * @method rotl
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
			var v = (this._high << 16) | this._low
			v = (v << n) | (v >>> (32 - n))
			this._low = v & 0xFFFF
			this._high = v >>> 16
	
			return this
		}
	
		/**
		 * Bitwise rotate right
		 * @method rotr
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
			var v = (this._high << 16) | this._low
			v = (v >>> n) | (v << (32 - n))
			this._low = v & 0xFFFF
			this._high = v >>> 16
	
			return this
		}
	
		/**
		 * Clone the current _UINT32_
		 * @method clone
		 * @return {Object} cloned UINT32
		 */
		UINT32.prototype.clone = function () {
			return new UINT32(this._low, this._high)
		}
	
		if (true) {
			// AMD / RequireJS
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return UINT32
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
		} else if (typeof module != 'undefined' && module.exports) {
			// Node.js
			module.exports = UINT32
		} else {
			// Browser
			root['UINT32'] = UINT32
		}
	
	})(this)


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
		C-like unsigned 64 bits integers in Javascript
		Copyright (C) 2013, Pierre Curto
		MIT license
	 */
	;(function (root) {
	
		// Local cache for typical radices
		var radixPowerCache = {
			16: UINT64( Math.pow(16, 5) )
		,	10: UINT64( Math.pow(10, 5) )
		,	2:  UINT64( Math.pow(2, 5) )
		}
		var radixCache = {
			16: UINT64(16)
		,	10: UINT64(10)
		,	2:  UINT64(2)
		}
	
		/**
		 *	Represents an unsigned 64 bits integer
		 * @constructor
		 * @param {Number} first low bits (8)
		 * @param {Number} second low bits (8)
		 * @param {Number} first high bits (8)
		 * @param {Number} second high bits (8)
		 * or
		 * @param {Number} low bits (32)
		 * @param {Number} high bits (32)
		 * or
		 * @param {String|Number} integer as a string 		 | integer as a number
		 * @param {Number|Undefined} radix (optional, default=10)
		 * @return 
		 */
		function UINT64 (a00, a16, a32, a48) {
			if ( !(this instanceof UINT64) )
				return new UINT64(a00, a16, a32, a48)
	
			this.remainder = null
			if (typeof a00 == 'string')
				return fromString.call(this, a00, a16)
	
			if (typeof a16 == 'undefined')
				return fromNumber.call(this, a00)
	
			fromBits.apply(this, arguments)
		}
	
		/**
		 * Set the current _UINT64_ object with its low and high bits
		 * @method fromBits
		 * @param {Number} first low bits (8)
		 * @param {Number} second low bits (8)
		 * @param {Number} first high bits (8)
		 * @param {Number} second high bits (8)
		 * or
		 * @param {Number} low bits (32)
		 * @param {Number} high bits (32)
		 * @return ThisExpression
		 */
		function fromBits (a00, a16, a32, a48) {
			if (typeof a32 == 'undefined') {
				this._a00 = a00 & 0xFFFF
				this._a16 = a00 >>> 16
				this._a32 = a16 & 0xFFFF
				this._a48 = a16 >>> 16
				return this
			}
	
			this._a00 = a00 | 0
			this._a16 = a16 | 0
			this._a32 = a32 | 0
			this._a48 = a48 | 0
	
			return this
		}
		UINT64.prototype.fromBits = fromBits
	
		/**
		 * Set the current _UINT64_ object from a number
		 * @method fromNumber
		 * @param {Number} number
		 * @return ThisExpression
		 */
		function fromNumber (value) {
			this._a00 = value & 0xFFFF
			this._a16 = value >>> 16
			this._a32 = 0
			this._a48 = 0
	
			return this
		}
		UINT64.prototype.fromNumber = fromNumber
	
		/**
		 * Set the current _UINT64_ object from a string
		 * @method fromString
		 * @param {String} integer as a string
		 * @param {Number} radix (optional, default=10)
		 * @return ThisExpression
		 */
		function fromString (s, radix) {
			radix = radix || 10
	
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
	
			/*
				In Javascript, bitwise operators only operate on the first 32 bits 
				of a number, even though parseInt() encodes numbers with a 53 bits 
				mantissa.
				Therefore UINT64(<Number>) can only work on 32 bits.
				The radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)
				maximum input value is m = 32bits as 1 = 2^32 - 1
				So the maximum substring length n is:
				36^(n+1) - 1 = 2^32 - 1
				36^(n+1) = 2^32
				(n+1)ln(36) = 32ln(2)
				n = 32ln(2)/ln(36) - 1
				n = 5.189644915687692
				n = 5
			 */
			var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) )
	
			for (var i = 0, len = s.length; i < len; i += 5) {
				var size = Math.min(5, len - i)
				var value = parseInt( s.slice(i, i + size), radix )
				this.multiply(
						size < 5
							? new UINT64( Math.pow(radix, size) )
							: radixUint
					)
					.add( new UINT64(value) )
			}
	
			return this
		}
		UINT64.prototype.fromString = fromString
	
		/**
		 * Convert this _UINT64_ to a number (last 32 bits are dropped)
		 * @method toNumber
		 * @return {Number} the converted UINT64
		 */
		UINT64.prototype.toNumber = function () {
			return (this._a16 << 16) | this._a00
		}
	
		/**
		 * Convert this _UINT64_ to a string
		 * @method toString
		 * @param {Number} radix (optional, default=10)
		 * @return {String} the converted UINT64
		 */
		UINT64.prototype.toString = function (radix) {
			radix = radix || 10
			var radixUint = radixCache[radix] || new UINT64(radix)
	
			if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)
	
			var self = this.clone()
			var res = new Array(64)
			for (var i = 63; i >= 0; i--) {
				self.div(radixUint)
				res[i] = self.remainder.toNumber().toString(radix)
				if ( !self.gt(radixUint) ) break
			}
			res[i-1] = self.toNumber().toString(radix)
	
			return res.join('')
		}
	
		/**
		 * Add two _UINT64_. The current _UINT64_ stores the result
		 * @method add
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.add = function (other) {
			var a00 = this._a00 + other._a00
	
			var a16 = a00 >>> 16
			a16 += this._a16 + other._a16
	
			var a32 = a16 >>> 16
			a32 += this._a32 + other._a32
	
			var a48 = a32 >>> 16
			a48 += this._a48 + other._a48
	
			this._a00 = a00 & 0xFFFF
			this._a16 = a16 & 0xFFFF
			this._a32 = a32 & 0xFFFF
			this._a48 = a48 & 0xFFFF
	
			return this
		}
	
		/**
		 * Subtract two _UINT64_. The current _UINT64_ stores the result
		 * @method subtract
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.subtract = function (other) {
			return this.add( other.clone().negate() )
		}
	
		/**
		 * Multiply two _UINT64_. The current _UINT64_ stores the result
		 * @method multiply
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.multiply = function (other) {
			/*
				a = a00 + a16 + a32 + a48
				b = b00 + b16 + b32 + b48
				a*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)
					= a00b00 + a00b16 + a00b32 + a00b48
					+ a16b00 + a16b16 + a16b32 + a16b48
					+ a32b00 + a32b16 + a32b32 + a32b48
					+ a48b00 + a48b16 + a48b32 + a48b48
	
				a16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits
				so it comes down to:
				a*b	= a00b00 + a00b16 + a00b32 + a00b48
					+ a16b00 + a16b16 + a16b32
					+ a32b00 + a32b16
					+ a48b00
					= a00b00
					+ a00b16 + a16b00
					+ a00b32 + a16b16 + a32b00
					+ a00b48 + a16b32 + a32b16 + a48b00
			 */
			var a00 = this._a00
			var a16 = this._a16
			var a32 = this._a32
			var a48 = this._a48
			var b00 = other._a00
			var b16 = other._a16
			var b32 = other._a32
			var b48 = other._a48
	
			var c00 = a00 * b00
	
			var c16 = c00 >>> 16
			c16 += a00 * b16
			var c32 = c16 >>> 16
			c16 &= 0xFFFF
			c16 += a16 * b00
	
			c32 += c16 >>> 16
			c32 += a00 * b32
			var c48 = c32 >>> 16
			c32 &= 0xFFFF
			c32 += a16 * b16
			c48 += c32 >>> 16
			c32 &= 0xFFFF
			c32 += a32 * b00
	
			c48 += c32 >>> 16
			c48 += a00 * b48
			c48 &= 0xFFFF
			c48 += a16 * b32
			c48 &= 0xFFFF
			c48 += a32 * b16
			c48 &= 0xFFFF
			c48 += a48 * b00
	
			this._a00 = c00 & 0xFFFF
			this._a16 = c16 & 0xFFFF
			this._a32 = c32 & 0xFFFF
			this._a48 = c48 & 0xFFFF
	
			return this
		}
	
		/**
		 * Divide two _UINT64_. The current _UINT64_ stores the result.
		 * The remainder is made available as the _remainder_ property on
		 * the _UINT64_ object. It can be null, meaning there are no remainder.
		 * @method div
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.div = function (other) {
			if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
				if (other._a00 == 0) throw Error('division by zero')
	
				// other == 1: this
				if (other._a00 == 1) {
					this.remainder = new UINT64(0)
					return this
				}
			}
	
			// other > this: 0
			if ( other.gt(this) ) {
				this.remainder = this.clone()
				this._a00 = 0
				this._a16 = 0
				this._a32 = 0
				this._a48 = 0
				return this
			}
			// other == this: 1
			if ( this.eq(other) ) {
				this.remainder = new UINT64(0)
				this._a00 = 1
				this._a16 = 0
				this._a32 = 0
				this._a48 = 0
				return this
			}
	
			// Shift the divisor left until it is higher than the dividend
			var _other = other.clone()
			var i = -1
			while ( !this.lt(_other) ) {
				// High bit can overflow the default 16bits
				// Its ok since we right shift after this loop
				// The overflown bit must be kept though
				_other.shiftLeft(1, true)
				i++
			}
	
			// Set the remainder
			this.remainder = this.clone()
			// Initialize the current result to 0
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			for (; i >= 0; i--) {
				_other.shiftRight(1)
				// If shifted divisor is smaller than the dividend
				// then subtract it from the dividend
				if ( !this.remainder.lt(_other) ) {
					this.remainder.subtract(_other)
					// Update the current result
					if (i >= 48) {
						this._a48 |= 1 << (i - 48)
					} else if (i >= 32) {
						this._a32 |= 1 << (i - 32)
					} else if (i >= 16) {
						this._a16 |= 1 << (i - 16)
					} else {
						this._a00 |= 1 << i
					}
				}
			}
	
			return this
		}
	
		/**
		 * Negate the current _UINT64_
		 * @method negate
		 * @return ThisExpression
		 */
		UINT64.prototype.negate = function () {
			var v = ( ~this._a00 & 0xFFFF ) + 1
			this._a00 = v & 0xFFFF
			v = (~this._a16 & 0xFFFF) + (v >>> 16)
			this._a16 = v & 0xFFFF
			v = (~this._a32 & 0xFFFF) + (v >>> 16)
			this._a32 = v & 0xFFFF
			this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF
	
			return this
		}
	
		/**
	
		 * @method eq
		 * @param {Object} other UINT64
		 * @return {Boolean}
		 */
		UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
			return (this._a48 == other._a48) && (this._a00 == other._a00)
				 && (this._a32 == other._a32) && (this._a16 == other._a16)
		}
	
		/**
		 * Greater than (strict)
		 * @method gt
		 * @param {Object} other UINT64
		 * @return {Boolean}
		 */
		UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
			if (this._a48 > other._a48) return true
			if (this._a48 < other._a48) return false
			if (this._a32 > other._a32) return true
			if (this._a32 < other._a32) return false
			if (this._a16 > other._a16) return true
			if (this._a16 < other._a16) return false
			return this._a00 > other._a00
		}
	
		/**
		 * Less than (strict)
		 * @method lt
		 * @param {Object} other UINT64
		 * @return {Boolean}
		 */
		UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
			if (this._a48 < other._a48) return true
			if (this._a48 > other._a48) return false
			if (this._a32 < other._a32) return true
			if (this._a32 > other._a32) return false
			if (this._a16 < other._a16) return true
			if (this._a16 > other._a16) return false
			return this._a00 < other._a00
		}
	
		/**
		 * Bitwise OR
		 * @method or
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.or = function (other) {
			this._a00 |= other._a00
			this._a16 |= other._a16
			this._a32 |= other._a32
			this._a48 |= other._a48
	
			return this
		}
	
		/**
		 * Bitwise AND
		 * @method and
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.and = function (other) {
			this._a00 &= other._a00
			this._a16 &= other._a16
			this._a32 &= other._a32
			this._a48 &= other._a48
	
			return this
		}
	
		/**
		 * Bitwise XOR
		 * @method xor
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.xor = function (other) {
			this._a00 ^= other._a00
			this._a16 ^= other._a16
			this._a32 ^= other._a32
			this._a48 ^= other._a48
	
			return this
		}
	
		/**
		 * Bitwise NOT
		 * @method not
		 * @return ThisExpression
		 */
		UINT64.prototype.not = function() {
			this._a00 = ~this._a00 & 0xFFFF
			this._a16 = ~this._a16 & 0xFFFF
			this._a32 = ~this._a32 & 0xFFFF
			this._a48 = ~this._a48 & 0xFFFF
	
			return this
		}
	
		/**
		 * Bitwise shift right
		 * @method shiftRight
		 * @param {Number} number of bits to shift
		 * @return ThisExpression
		 */
		UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
			n %= 64
			if (n >= 48) {
				this._a00 = this._a48 >> (n - 48)
				this._a16 = 0
				this._a32 = 0
				this._a48 = 0
			} else if (n >= 32) {
				n -= 32
				this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
				this._a16 = (this._a48 >> n) & 0xFFFF
				this._a32 = 0
				this._a48 = 0
			} else if (n >= 16) {
				n -= 16
				this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
				this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
				this._a32 = (this._a48 >> n) & 0xFFFF
				this._a48 = 0
			} else {
				this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF
				this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
				this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
				this._a48 = (this._a48 >> n) & 0xFFFF
			}
	
			return this
		}
	
		/**
		 * Bitwise shift left
		 * @method shiftLeft
		 * @param {Number} number of bits to shift
		 * @param {Boolean} allow overflow
		 * @return ThisExpression
		 */
		UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
			n %= 64
			if (n >= 48) {
				this._a48 = this._a00 << (n - 48)
				this._a32 = 0
				this._a16 = 0
				this._a00 = 0
			} else if (n >= 32) {
				n -= 32
				this._a48 = (this._a16 << n) | (this._a00 >> (16-n))
				this._a32 = (this._a00 << n) & 0xFFFF
				this._a16 = 0
				this._a00 = 0
			} else if (n >= 16) {
				n -= 16
				this._a48 = (this._a32 << n) | (this._a16 >> (16-n))
				this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
				this._a16 = (this._a00 << n) & 0xFFFF
				this._a00 = 0
			} else {
				this._a48 = (this._a48 << n) | (this._a32 >> (16-n))
				this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF
				this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
				this._a00 = (this._a00 << n) & 0xFFFF
			}
			if (!allowOverflow) {
				this._a48 &= 0xFFFF
			}
	
			return this
		}
	
		/**
		 * Bitwise rotate left
		 * @method rotl
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
			n %= 64
			if (n == 0) return this
			if (n >= 32) {
				// A.B.C.D
				// B.C.D.A rotl(16)
				// C.D.A.B rotl(32)
				var v = this._a00
				this._a00 = this._a32
				this._a32 = v
				v = this._a48
				this._a48 = this._a16
				this._a16 = v
				if (n == 32) return this
				n -= 32
			}
	
			var high = (this._a48 << 16) | this._a32
			var low = (this._a16 << 16) | this._a00
	
			var _high = (high << n) | (low >>> (32 - n))
			var _low = (low << n) | (high >>> (32 - n))
	
			this._a00 = _low & 0xFFFF
			this._a16 = _low >>> 16
			this._a32 = _high & 0xFFFF
			this._a48 = _high >>> 16
	
			return this
		}
	
		/**
		 * Bitwise rotate right
		 * @method rotr
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
			n %= 64
			if (n == 0) return this
			if (n >= 32) {
				// A.B.C.D
				// D.A.B.C rotr(16)
				// C.D.A.B rotr(32)
				var v = this._a00
				this._a00 = this._a32
				this._a32 = v
				v = this._a48
				this._a48 = this._a16
				this._a16 = v
				if (n == 32) return this
				n -= 32
			}
	
			var high = (this._a48 << 16) | this._a32
			var low = (this._a16 << 16) | this._a00
	
			var _high = (high >>> n) | (low << (32 - n))
			var _low = (low >>> n) | (high << (32 - n))
	
			this._a00 = _low & 0xFFFF
			this._a16 = _low >>> 16
			this._a32 = _high & 0xFFFF
			this._a48 = _high >>> 16
	
			return this
		}
	
		/**
		 * Clone the current _UINT64_
		 * @method clone
		 * @return {Object} cloned UINT64
		 */
		UINT64.prototype.clone = function () {
			return new UINT64(this._a00, this._a16, this._a32, this._a48)
		}
	
		if (true) {
			// AMD / RequireJS
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return UINT64
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
		} else if (typeof module != 'undefined' && module.exports) {
			// Node.js
			module.exports = UINT64
		} else {
			// Browser
			root['UINT64'] = UINT64
		}
	
	})(this)


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _slicedToArray2 = __webpack_require__(83);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _toConsumableArray2 = __webpack_require__(84);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 十字链表
	 *
	 * 当矩阵的非零个数和位置在操作过程中变化大时，就不宜采用顺序存储结构来表示三元组的线性表。例如，在作“将矩阵B加到矩阵A上”的操作时，由于非零元的插入或删除将会引起A.data中元素的移动。为此，对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。
	 *
	 * 在链表中，每个非零元可用一个含5个域的结点表示，其中i，j和e这3个域分别表示该非零元所在的行，列和非零元的值，向右域right用以链接同一行中下一个非零元，向下域down用以链接同一列中下一个非零元。同一行的非零元通过right域链接成一个线性表，同一列中的非零元通常down域链接成一个线性链表，每一个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表。
	 *
	 * 可用两个分别存储行链表的头指针和列链表的头指针的一维数组来表示。
	 */
	
	// 稀疏矩阵的十字链表存储表示
	
	var OLNode = function OLNode() {
	    var i = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var j = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var e = arguments[2];
	    (0, _classCallCheck3.default)(this, OLNode);
	
	    // 该非零元的行和列下标
	    this.i = i;
	    this.j = j;
	    this.e = e;
	    // 该非零元所在行表和列表的后继链域
	    this.right = null; // type: OLNode
	    this.down = null; // type: OLNode
	};
	
	var CrossList = function () {
	    function CrossList() {
	        (0, _classCallCheck3.default)(this, CrossList);
	
	        // 行和列链表头指针向量基址由CreateSMatrix分配
	        this.rhead = [];
	        this.chead = [];
	        // 稀疏矩阵的行数，列数
	        this.mu = 0;
	        this.nu = 0;
	        this.tu = 0;
	    }
	
	    /**
	     * 矩阵初始化
	     * @param m
	     * @param n
	     * @param t
	     * @param {Array} list 二维数组，每行的元素分别是[i, j, e]
	     */
	
	
	    (0, _createClass3.default)(CrossList, [{
	        key: "createSMatrix",
	        value: function createSMatrix(m, n, t, list) {
	            this.mu = m;
	            this.nu = n;
	            this.tu = t;
	
	            for (var row = 0; row < list.length; row++) {
	                var p = new (Function.prototype.bind.apply(OLNode, [null].concat((0, _toConsumableArray3.default)(list[row]))))();
	
	                var _list$row = (0, _slicedToArray3.default)(list[row], 2);
	
	                var i = _list$row[0];
	                var j = _list$row[1];
	
	                var q = void 0;
	
	                if (this.rhead[i] == null || this.rhead[i].j > j) {
	                    p.right = this.rhead[i];
	                    this.rhead[i] = p;
	                } else {
	                    // 查询在行表中的插入位置
	                    for (q = this.rhead[i]; q.right && q.right.j < j; q = q.right) {}
	                    p.right = q.right;
	                    q.right = p;
	                }
	
	                if (this.chead[j] == null || this.chead[j].i > i) {
	                    p.down = this.chead[j];
	                    this.chead[j] = p;
	                } else {
	                    for (q = this.chead[j]; q.down && q.down.i < i; q = q.down) {}
	                    p.down = q.down;
	                    q.down = p;
	                }
	            }
	        }
	
	        // 矩阵相加
	
	    }, {
	        key: "addMatrix",
	        value: function addMatrix(crossList) {
	            var hl = [];
	            //hl初始化
	            for (var j = 0; j <= this.nu; j++) {
	                hl[j] = this.chead[j];
	            }for (var i = 0; i <= this.mu; i++) {
	                //pa和pb指向每一行的第一个非0元结点，直至最后一行
	                var pa = this.rhead[i];
	                var pb = crossList.rhead[i];
	                var pre = null;
	
	                //处理B的一行，直至本行中无非0元素的结点
	                while (pb) {
	                    var p = void 0,
	                        q = void 0;
	                    // 新插入一个结点到pa的左侧
	                    if (!pa || pa.j > pb.j) {
	                        p = new OLNode(pb.i, pb.j, pb.e);
	
	                        //行表的指针变化
	                        if (!pre) this.rhead[p.i] = p;else pre.right = p;
	
	                        p.right = pa;
	                        pre = p;
	
	                        //列表的指针变化
	                        if (hl[p.j]) {
	                            // 从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                            for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                hl[p.j] = q;
	                            }
	                        }
	
	                        //在列表中插入新结点，根据行数判断插入前面还是后面
	                        if (!this.chead[p.j] || this.chead[p.j].i > p.i) {
	                            p.down = this.chead[p.j];
	                            this.chead[p.j] = p;
	                        } else {
	                            p.down = hl[p.j].down;
	                            hl[p.j].down = p;
	                        }
	
	                        hl[p.j] = p;
	                        pb = pb.right;
	                    } else if (pa.j < pb.j) {
	                        pre = pa;
	                        pa = pa.right;
	                    } else {
	                        //当pa.j === pb.j时，将B中当前结点的值加到A中当前结点上
	                        pa.e += pb.e;
	
	                        //当pa.e === 0时，删除该结点
	                        if (pa.e === 0) {
	                            // 若无前驱结点，将第一个非0元结点置为当前结点的后继结点，
	                            // 否则前驱结点的后继结点为当前结点的后继结点
	                            if (!pre) this.rhead[pa.i] = pa.right;else pre.right = pa.right;
	
	                            p = pa;
	                            pa = pa.right;
	
	                            //列表的指针变化
	                            if (hl[p.j]) {
	                                //从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                                for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                    hl[p.j] = q;
	                                }
	                            }
	
	                            if (this.chead[p.j] == p) this.chead[p.j] = hl[p.j] = p.down;else hl[p.j].down = p.down;
	                        }
	
	                        pb = pb.right;
	                    }
	                }
	            }
	        }
	    }]);
	    return CrossList;
	}();
	
	exports.default = CrossList;
	
	
	var lists = [[1, 4, 5], [2, 2, -1], [1, 1, 3], [3, 1, 2]];
	var a = new CrossList();
	a.createSMatrix(4, 4, 4, lists);
	console.log(a);
	
	var lists2 = [[1, 4, -5], [2, 3, 1], [1, 1, 3], [3, 2, 2]];
	var b = new CrossList();
	b.createSMatrix(4, 4, 4, lists2);
	console.log(b);
	
	a.addMatrix(b);
	console.log(a);

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.RLSMatrix = exports.TSMatrix = undefined;
	
	var _getPrototypeOf = __webpack_require__(17);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(25);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(24);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 系数矩阵的三元组顺序表存储表示
	 */
	
	var Triple = function Triple(i, j, elem) {
	    (0, _classCallCheck3.default)(this, Triple);
	
	    // 该非零元的行下标和列下标
	    this.i = i || 0;
	    this.j = j || 0;
	    this.e = elem || null;
	};
	
	var TSMatrix = exports.TSMatrix = function () {
	    function TSMatrix(mu, nu) {
	        (0, _classCallCheck3.default)(this, TSMatrix);
	
	        // 非零元三元组表
	        this.data = [];
	        // 矩阵的行数，列数
	        this.mu = mu || 0;
	        this.nu = nu || 0;
	    }
	
	    (0, _createClass3.default)(TSMatrix, [{
	        key: 'addTriple',
	        value: function addTriple(triple) {
	            if (triple instanceof Triple) {
	                if (triple.i >= this.mu) this.mu = triple.i + 1;
	                if (triple.j >= this.nu) this.nu = triple.j + 1;
	
	                this.data.push(triple);
	                return true;
	            }
	            return false;
	        }
	        // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	        // 按照b.data中三元组的次序依次在a.data中找到相应的三元组进行转置
	
	    }, {
	        key: 'transposeSMatrix',
	        value: function transposeSMatrix() {
	            var t = new TSMatrix();
	            t.mu = this.nu;
	            t.nu = this.mu;
	
	            if (this.data.length) {
	                var q = 0;
	                for (var col = 0; col < this.nu; col++) {
	                    for (var p = 0; p < this.data.length; p++) {
	                        if (this.data[p].j === col) t.data[q++] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                    }
	                }
	            }
	
	            return t;
	        }
	        // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	        /*
	         按照a.data中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置。
	         如果能预先确定矩阵M中每一列（即T中每一行）的第一个非零元在b.data中应有的位置，
	         那么在对a.data中的三元组依次做转置时，便可直接放到b.data中恰当的位置上去。
	         为了其额定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在b.data中应有的位置。
	         在此，需要设num和cpot两个变量。num[col]表示矩阵M中第col列中非零元的个数，
	         cpot[col]指示M中第col列的第一个非零元在b.data中的恰当位置。显然有：
	         cpot[0] = 1;
	         cpot[col] = cpot[col - 1] + num[col - 1]    2 <= col <= a.nu
	         */
	
	    }, {
	        key: 'fastTransposeSMatrix',
	        value: function fastTransposeSMatrix() {
	            var t = new TSMatrix();
	            t.mu = this.nu;
	            t.nu = this.mu;
	
	            if (this.data.length) {
	                var num = [];
	                for (var col = 0; col < this.nu; col++) {
	                    num[col] = 0;
	                }for (var i = 0; i < this.data.length; i++) {
	                    ++num[this.data[i].j];
	                } // 求矩阵中每一列含非零元个数
	                // 求第col列中第一个非零元在b.data中的序号
	                var cpot = [0];
	                for (var _col = 1; _col < this.nu; _col++) {
	                    // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                    cpot[_col] = cpot[_col - 1] + num[_col - 1];
	                }for (var p = 0; p < this.data.length; p++) {
	                    var _col2 = this.data[p].j;
	                    var q = cpot[_col2];
	                    t.data[q] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                    // 给该列的序号+1，用作相同列数的情况
	                    ++cpot[_col2];
	                }
	            }
	
	            return t;
	        }
	    }]);
	    return TSMatrix;
	}();
	
	var a1 = new Triple(1, 2, 12);
	var a2 = new Triple(1, 3, 9);
	var a3 = new Triple(3, 1, -3);
	var a4 = new Triple(3, 6, 14);
	var a5 = new Triple(4, 3, 24);
	var a6 = new Triple(5, 2, 18);
	var a7 = new Triple(6, 1, 15);
	var a8 = new Triple(6, 4, -7);
	
	var matrix = new TSMatrix();
	matrix.addTriple(a1);
	matrix.addTriple(a2);
	matrix.addTriple(a3);
	matrix.addTriple(a4);
	matrix.addTriple(a5);
	matrix.addTriple(a6);
	matrix.addTriple(a7);
	matrix.addTriple(a8);
	
	console.log(matrix.transposeSMatrix());
	console.log(matrix.fastTransposeSMatrix());
	
	/*
	 三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。
	 然而，若需按行号存取某一行的非零元，则从头开始进行查找。
	 */
	
	/**
	 * 行逻辑链接的顺序表
	 *
	 * 为了便于随机存取任意一行的非零元，则需知道每一行的第一个非零元在三元组表中的位置。
	 * 为此可将快速转置矩阵的算法中创建的，指示“行”信息的辅助数组cpot固定在稀疏矩阵的存储结构中。
	 * 称这种“带行链接信息”的三元组表为行逻辑链接的顺序表
	 */
	
	var RLSMatrix = exports.RLSMatrix = function (_TSMatrix) {
	    (0, _inherits3.default)(RLSMatrix, _TSMatrix);
	
	    function RLSMatrix() {
	        (0, _classCallCheck3.default)(this, RLSMatrix);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RLSMatrix).apply(this, arguments));
	
	        _this.rpos = [0];
	        return _this;
	    }
	    /**
	     * 求矩阵乘积Q = M * N，采用行逻辑链接存储表示
	     * @param nMatrix
	     * @returns {RLSMatrix}
	     */
	
	
	    (0, _createClass3.default)(RLSMatrix, [{
	        key: 'multSMatrix',
	        value: function multSMatrix(nMatrix) {
	            if (this.nu !== nMatrix.mu) throw Error('nu is not equivalent to mu');
	
	            // 初始化Q
	            var qMatrix = new RLSMatrix(this.mu, nMatrix.nu);
	            // Q是非零矩阵
	            if (this.data.length * nMatrix.data.length !== 0) {
	                // 处理M的每一行
	                for (var arow = 0; arow < this.mu; arow++) {
	                    // 当前行各元素累加器清零
	                    var ctemp = [];
	                    qMatrix.rpos[arow] = qMatrix.data.length + 1;
	                    var tp = void 0,
	                        ccol = void 0;
	
	                    if (arow < this.mu) tp = this.rpos[arow + 1];else tp = this.data.length + 1;
	
	                    //对当前行中每一个非零元找到对应元在N中的行号
	                    for (var p = this.rpos[arow]; p < tp; p++) {
	                        var brow = this.data[p].j;
	                        var t = void 0;
	                        if (brow < nMatrix.mu) t = nMatrix.rpos[brow + 1];else t = nMatrix.data.length + 1;
	
	                        for (var q = nMatrix.rpos[brow]; q < t; q++) {
	                            // 乘积元素在Q中的序号
	                            ccol = nMatrix.data[q].j;
	                            ctemp[ccol] = (ctemp[ccol] || 0) + this.data[p].e * nMatrix.data[q].e;
	                        }
	                    }
	
	                    // 压缩存储该行非零元
	                    for (ccol = 1; ccol < qMatrix.nu; ccol++) {
	                        if (ctemp[ccol]) {
	                            if (++qMatrix.data.length > RLSMatrix.MAXSIZE) throw Error('overflow');
	                            qMatrix.data[qMatrix.data.length - 1] = new Triple(arow, ccol, ctemp[ccol]);
	                        }
	                    }
	                }
	            }
	
	            return qMatrix;
	        }
	    }, {
	        key: '_calcPos',
	        value: function _calcPos() {
	            var num = [];
	            for (var col = 0; col < this.nu; col++) {
	                num[col] = 0;
	            }for (var i = 0; i < this.data.length; i++) {
	                ++num[this.data[i].j];
	            } // 求矩阵中每一列含非零元个数
	            // 求第col列中第一个非零元在b.data中的序号
	            for (var _col3 = 1; _col3 < this.nu; _col3++) {
	                // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                this.rpos[_col3] = this.rpos[_col3 - 1] + num[_col3 - 1];
	            }
	        }
	    }]);
	    return RLSMatrix;
	}(TSMatrix);
	
	RLSMatrix.MAXSIZE = 100;
	
	var b1 = new Triple(1, 1, 3);
	var b2 = new Triple(1, 3, 5);
	var b3 = new Triple(2, 2, -1);
	var b4 = new Triple(3, 1, 2);
	
	var t1 = new RLSMatrix();
	t1.addTriple(b1);
	t1.addTriple(b2);
	t1.addTriple(b3);
	t1.addTriple(b4);
	t1._calcPos();
	
	var c1 = new Triple(1, 2, 2);
	var c2 = new Triple(2, 1, 1);
	var c3 = new Triple(3, 1, -2);
	var c4 = new Triple(3, 2, 4);
	
	var t2 = new RLSMatrix();
	t2.addTriple(c1);
	t2.addTriple(c2);
	t2.addTriple(c3);
	t2.addTriple(c4);
	t2._calcPos();
	
	t1.multSMatrix(t2);

/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = huffManCoding;
	/**
	 * 赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树，有着广泛应用。
	 *
	 * 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
	 * 树的路径长度是从树根到每一个结点的路径之和。
	 * 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。
	 *
	 * 构造赫夫曼树的步骤：
	 * （1）根据给定的n个权值{w1,w2,...wn}构成n棵二叉树的集合F = {T1,T2,...Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
	 * （2）在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
	 * （3）在F中删除这两棵树，同时将新得到的二叉树加入F中。
	 * （4）重复（2）和（3），直到F只含一棵树为止。这棵树便是赫夫曼树。
	 */
	/*
	赫夫曼编码
	http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81
	
	假设电报需传送的电文为“A B A C C D A”，它只有4种字符只需两个字符串便可分辨。假设A,B,C,D的编码分别为00,01,10和11，则上述7个字符的电文便为“00010010101100”，对方接收时，可按二位一分进行译码。
	在传送电文时，希望总长尽可能地短。如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便可减少。
	如果涉及A,B,C,D的编码分别为0,00,1和01，则上述7个字符的电文可转换成总长为9的字符串“000011010”。但是，这样的电文无法翻译，因为可有多种译法。
	因此，若要设计长短不等的编码，则必须是任意个字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码。
	可利用二叉树来设计二进制的前缀编码。假设有一棵二叉树，其4个叶子结点分别表示A,B,C,D这4个字符，且约定左分支表示字符“0”，右分支表示字符“1”，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。所得二进制前缀编码分别为0,10,110,111.
	设计电文总长最短的二进制前缀编码即以n种字符出现的频率作权。
	 */
	
	// 赫夫曼树和赫夫曼编码的存储结构
	function HuffmanNode(weight, parent, leftChild, rightChild) {
	    this.weight = weight || 0;
	    this.parent = parent || 0;
	    this.leftChild = leftChild || 0;
	    this.rightChild = rightChild || 0;
	}
	function huffManCoding(weights) {
	    var n = weights.length;
	    if (n < 1) return;
	
	    var huffmanTree = buildHuffmanTree(weights, n);
	
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = calcHuffmanCode(huffmanTree, n);
	
	    return [huffmanTree, hc];
	}
	
	function calcHuffmanCode(huffmanTree, n) {
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = [];
	    var cd = [];
	    for (var i = 0; i < n; i++) {
	        var start = n - 1;
	        for (var c = i, f = huffmanTree[i].parent; f != 0; c = f, f = huffmanTree[f].parent) {
	            if (huffmanTree[f].leftChild == c) cd[--start] = '0';else cd[--start] = '1';
	        }
	
	        hc[i] = strCopy(cd, start);
	    }
	
	    return hc;
	}
	
	// 创建一棵叶子结点数为n的Huffman树
	function buildHuffmanTree(weights, n) {
	    n = n || weights.length;
	    var m = 2 * n - 1;
	    var huffmanTree = [];
	
	    // 初始化
	    var i = void 0;
	    for (i = 0; i < n; i++) {
	        huffmanTree[i] = new HuffmanNode(weights[i], 0, 0, 0);
	    }for (; i < m; i++) {
	        huffmanTree[i] = new HuffmanNode(0, 0, 0, 0);
	    }for (var _i = n; _i < m; _i++) {
	        // 在HT[1..i-1]选择parent为0且weight最小的两个结点，返回其序号为[s1, s2]
	        var ret = select(huffmanTree, _i);
	        var s1 = ret[0];
	        var s2 = ret[1];
	        huffmanTree[s1].parent = _i;
	        huffmanTree[s2].parent = _i;
	        huffmanTree[_i].leftChild = s1;
	        huffmanTree[_i].rightChild = s2;
	        huffmanTree[_i].weight = huffmanTree[s1].weight + huffmanTree[s2].weight;
	    }
	
	    return huffmanTree;
	}
	
	function strCopy(str, start) {
	    var s = '';
	    for (; str[start]; start++) {
	        s += str[start];
	    }
	    return s;
	}
	
	function select(huffmanTree, len) {
	    var ret = [];
	    for (var i = 0; i < len; i++) {
	        var node = huffmanTree[i];
	        if (node.parent !== 0) continue;
	
	        if (ret.length < 2) {
	            ret.push(i);
	        } else {
	            var index = huffmanTree[ret[0]].weight > huffmanTree[ret[1]].weight ? 0 : 1;
	
	            if (node.weight < huffmanTree[ret[index]].weight) ret[index] = i;
	        }
	    }
	
	    if (ret[0] > ret[1]) {
	        var temp = ret[0];
	        ret[0] = ret[1];
	        ret[1] = temp;
	    }
	
	    return ret;
	}
	
	console.log('-------huffman coding 1:------');
	console.log(huffManCoding([5, 29, 7, 8, 14, 23, 3, 11]));

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(50);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _Queue = __webpack_require__(15);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 广义表
	 *
	 * 广义表是线性表的推广。广泛用于人工智能的表处理语言Lisp，把广义表作为基本的数据结构。
	 * 广义表一般记作：
	 *      LS = (a1, a2, ..., an)
	 * LS是广义表的名称，n是它的长度，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头，称其余元素组成的表(a2, a3, ..., an)是LS的表尾。
	 *
	 * 下面列举一些广义表的例子：
	 * 1.A = () ---- A是一个空表，它的长度为0。
	 * 2.B = (e) ---- 列表B只有一个原子e，B的长度为1。
	 * 3.C = (a, (b, c, d)) ---- 列表C的长度为2，两个元素分别为原子a和子表(b, c, d)。
	 * 4.D = (A, B, C) ---- 列表D的长度为3,3个元素都是列表。显示，将子表的值代入后，则有D = ((), (e), (a, (b, c, d)))。
	 * 5.E = (a, E) ---- 这是一个递归的表，它的长度为2.E相当于一个无限的列表E = (a, (a, (a, ...)))。
	 *
	 * 1）列表的元素可以是子表，而子表的元素还可以是子表。由此，列表是一个多层次的结构，可以用图形象地表示。
	 * 2)列表可为其它列表所共享。列表A，B和C为D的子表，则在D中可以不必列出子表的值。
	 * 3）列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如列表E。
	 *
	 * 任何一个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。
	 *
	 */
	
	/*
	 广义表的递归算法
	
	 递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。
	
	 由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，应注意：
	 （1）首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的字问题，只要接口一致，便可进行递归调用。
	 （2）对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。
	 */
	
	/*
	 求广义表的深度
	
	 广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。
	 设非空广义表为:
	 LS = (a1, a2, ..., an)
	
	 其中ai(i = 1, 2, ..., n)或为原子或为LS的子表，则求LS的深度可分解为n个子问题，每个子问题为求ai的深度，若ai是原子，则由定义其深度为零，若ai是广义表，则递归处理，而LS的深度为各ai(i = 1, 2, ..., n)的深度最大值加1.空表也是广义表，且深度为1.
	
	 广义表的深度DEPTH(LS)的递归定义为：
	 基本项：    DEPTH(LS) = 1   当LS为空表时
	 DEPTH(LS) = 0   当LS为原子时
	 归纳项：    DEPTH(LS) = 1 + MAX{DEPTH(ai)}  1 <= i <= n
	 */
	
	var ATOM = (0, _symbol2.default)();
	var LIST = (0, _symbol2.default)();
	
	var global = Function('return this')();
	// 使用链队列
	
	
	// 广义表的头尾链表存储表示
	
	var GLNode = function () {
	    function GLNode() {
	        (0, _classCallCheck3.default)(this, GLNode);
	
	        // 公共部分，用于区分原子结点和表结点
	        this.tag = undefined;
	
	        // atom是原子结点的值域
	        this.atom = null;
	        // ptr是表结点的指针域
	        this.ptr = {
	            // ptr.hp和ptr.tp分别指向表头和表尾
	            hp: null,
	            tp: null
	        };
	    }
	
	    // 采用头尾链表存储结构，求广义表的深度
	
	
	    (0, _createClass3.default)(GLNode, [{
	        key: 'depth',
	        value: function depth() {
	            return getDepth(this);
	        }
	
	        // 复制广义表
	
	    }, {
	        key: 'copyList',
	        value: function copyList(gList) {
	            gList.tag = this.tag;
	
	            if (this.tag === ATOM) {
	                gList.atom = this.atom;
	            } else {
	                if (this.ptr.hp) {
	                    gList.ptr.hp = new GLNode();
	                    this.ptr.hp.copyList(gList.ptr.hp);
	                }
	                if (this.ptr.tp) {
	                    gList.ptr.tp = new GLNode();
	                    this.ptr.tp.copyList(gList.ptr.tp);
	                }
	            }
	        }
	
	        // 采用头尾链表存储结构，由广义表的书写形式串创建广义表
	
	    }, {
	        key: 'createGList',
	        value: function createGList(string) {
	            string = string.trim();
	
	            // 创建单原子广义表
	            var q = void 0;
	            if (isWord(string)) {
	                this.tag = ATOM;
	                this.atom = string;
	            } else {
	                this.tag = LIST;
	                var p = this;
	
	                // 脱外层括号
	                var sub = string.substr(1, string.length - 2);
	
	                do {
	                    var hsub = void 0;
	                    var n = sub.length;
	                    var i = 0;
	                    var k = 0;
	                    var ch = void 0;
	
	                    do {
	                        ch = sub[i++];
	                        if (ch == '(') ++k;else if (ch == ')') --k;
	                    } while (i < n && (ch != ',' || k != 0));
	
	                    // i为第一个逗号分隔索引
	                    if (i < n) {
	                        hsub = sub.substr(0, i - 1);
	                        sub = sub.substr(i, n - i);
	
	                        // 最后一组
	                    } else {
	                            hsub = sub;
	                            sub = '';
	                        }
	
	                    if (hsub === '()') p.ptr.hp = null;
	                    // 创建表头结点
	                    else {
	                            p.ptr.hp = new GLNode();
	                            p.ptr.hp.createGList(hsub);
	                        }
	
	                    q = p;
	
	                    // 创建表尾结点
	                    if (sub) {
	                        p = new GLNode();
	                        p.tag = LIST;
	                        q.ptr.tp = p;
	                    }
	                } while (sub);
	
	                q.ptr.tp = null;
	            }
	        }
	    }, {
	        key: 'reverse',
	
	
	        // 递归逆转广义表
	        value: function reverse() {
	            var ptr = [];
	            // 当A不为原子且表尾非空时才需逆转
	            if (this.tag === LIST && this.ptr.tp) {
	                var i = 0;
	                for (var p = this; p; p = p.ptr.tp, i++) {
	                    // 逆转各子表
	                    if (p.ptr.hp) p.ptr.hp.reverse();
	
	                    ptr[i] = p.ptr.hp;
	                }
	
	                // 重新按逆序排列各子表的顺序
	                for (var _p = this; _p; _p = _p.ptr.tp) {
	                    _p.ptr.hp = ptr[--i];
	                }
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	            if (this == global || this == null) str = '()';else if (this.tag === ATOM) str = this.atom; // 原子
	            else {
	                    str += '(';
	
	                    for (var p = this; p; p = p.ptr.tp) {
	                        str += this.toString.call(p.ptr.hp);
	                        if (p.ptr.tp) str += ', ';
	                    }
	                    str += ')';
	                }
	
	            return str;
	        }
	
	        // 按层序输出广义表
	        // 层序遍历的问题，一般都是借助队列来完成的，每次从队头
	        // 取出一个元素的同时把它下一层的孩子插入队尾，这是层序遍历的基本思想
	
	    }, {
	        key: 'orderPrint',
	        value: function orderPrint() {
	            var queue = [];
	            for (var p = this; p; p = p.ptr.tp) {
	                queue.push(p);
	            }while (queue.length) {
	                var r = queue.shift();
	                if (r.tag === ATOM) console.log(r.atom);else {
	                    for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                        queue.push(r);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'orderPrint2',
	        value: function orderPrint2() {
	            var queue = new _Queue2.default();
	
	            for (var p = this; p; p = p.ptr.tp) {
	                queue.enQueue(p);
	            }while (queue.size) {
	                var r = queue.deQueue();
	                if (r.tag === ATOM) console.log(r.atom);else {
	                    for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                        queue.enQueue(r);
	                    }
	                }
	            }
	        }
	    }], [{
	        key: 'equal',
	        value: function equal(gList1, gList2) {
	            // 空表时相等的
	            if (!gList1 && !gList2) return true;
	            if (gList1.tag === ATOM && gList2.tag === ATOM && gList1.atom === gList2.atom) return true;
	
	            if (gList1.tag === LIST && gList2.tag === LIST) {
	                // 表头表尾都相等
	                if (this.equal(gList1.ptr.hp, gList2.ptr.hp) && this.equal(gList1.ptr.tp, gList2.ptr.tp)) return true;
	            }
	
	            return false;
	        }
	    }]);
	    return GLNode;
	}();
	
	// 广义表的扩展线性链表存储表示
	
	
	exports.default = GLNode;
	
	var GLNode2 = function GLNode2() {
	    (0, _classCallCheck3.default)(this, GLNode2);
	
	    // 公共部分，用于区分原子结点和表结点
	    this.tag = undefined;
	
	    // 原子结点的值域
	    this.atom = null;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性链表的next，指向下一个元素结点
	    this.tp = null;
	};
	
	function getDepth(gList) {
	    if (!gList) return 1;else if (gList.tag === ATOM) return 0;
	
	    var m = getDepth(gList.ptr.hp) + 1;
	    var n = getDepth(gList.ptr.tp);
	
	    return m > n ? m : n;
	}
	
	function isWord(str) {
	    return (/^[\w-]+$/.test(str)
	    );
	}
	
	/*
	 m元多项式表示
	
	 如果用线性表来表示,则每个数据元素需要m+1个数据项，以存储一个系数和m个指数值，这将产生两个问题。
	 一是无论多项式中各项的变元数是多是少，若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便。二是对m值不同的多项式，线性表中的结点大小也不同，这同样引起存储管理的不便。
	 故不适于用线性表表示。
	
	 例如三元多项式：
	 P(x, y, z) = x(10)y(3)z(2) + 2x(6)y(3)z(2) + 3x(5)y(2)z(2) + x(4)y(4)z + 2yz + 15
	
	 如若改写为：
	 P(x, y, z) = ((x(10) + 2x(6))y(3) + 3x(5)y(2))z(2) + ((x(4) + 6x(3))y(4) + 2y)z + 15
	
	 用广义表表示：
	 P = z((A, 2), (B, 1), (15, 0))
	 A = y((C, 3), (D, 2))
	 B = y((E, 4), (F, 1))
	 C = x((1, 10), (2, 6))
	 D = x((3, 5))
	 E = x((1, 4), (6, 3))
	 F = x((2, 0))
	
	
	 */
	
	function MPNode() {
	    // 区分原子结点和表结点
	    this.tag = undefined;
	    // 指数域
	    this.exp = 0;
	
	    // 系数域
	    this.coef = 0;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性表的next，指向下一个元素结点
	    this.tp = null;
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 邻接多重表
	
	 邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。
	
	 邻接表是无向图的一种有效的存储结构，在无向图的邻接表中，一条边(v,w)的两个表结点分别初选在以v和w为头结点的链表中，很容易求得顶点和边的信息，但在涉及到边的操作会带来不便。
	
	 邻接多重表的结构和十字链表类似，每条边用一个结点表示；邻接多重表中的顶点结点结构与邻接表中的完全相同，而表结点包括六个域。
	
	 ◆  Data域：存储和顶点相关的信息；
	 ◆ 指针域firstedge：指向依附于该顶点的第一条边所对应的表结点；
	 ◆ 标志域mark：用以标识该条边是否被访问过；
	 ◆ ivex和jvex域：分别保存该边所依附的两个顶点在图中的位置；
	 ◆ info域：保存该边的相关信息；
	 ◆ 指针域ilink：指向下一条依附于顶点ivex的边；
	 ◆ 指针域jlink：指向下一条依附于顶点jvex的边；
	
	 邻接多重表与邻接表的区别：
	 后者的同一条边用两个表结点表示，而前者只用一个表结点表示；除标志域外，邻接多重表与邻接表表达的信息是相同的，因此，操作的实现也基本相似。
	
	 */
	
	var UNVISITED = 0;
	var VISITED = 1;
	
	var EBox =
	/**
	 * 边的结点表示
	 * @param {Number} mark 访问标记 0 -- 未访问  1 == 已访问
	 * @param {Number} ivex 该边依附的两个顶点的位置
	 * @param {Number} jvex 该边依附的两个顶点的位置
	 * @param {EBox} ilink 分别指向依附这两个顶点的下一条边
	 * @param {EBox} jlink 分别指向依附这两个顶点的下一条边
	 * @param {*} info 该边信息
	 * @constructor
	 */
	function EBox(mark, ivex, jvex, ilink, jlink, info) {
	    (0, _classCallCheck3.default)(this, EBox);
	
	    this.mark = mark || UNVISITED;
	    this.ivex = ivex || 0;
	    this.jvex = jvex || 0;
	    this.ilink = ilink || null;
	    this.jlink = jlink || null;
	    this.info = info || null;
	};
	
	var AMLVexBox =
	/**
	 * 顶点的结点表示
	 * @param {*} data
	 * @param {EBox} firstEdge 指向第一条依附该顶点的边
	 * @constructor
	 */
	function AMLVexBox(data, firstEdge) {
	    (0, _classCallCheck3.default)(this, AMLVexBox);
	
	    this.data = data || null;
	    this.firstEdge = firstEdge || null;
	};
	
	var AMLGraph = function () {
	    /**
	     *
	     * @param {Array | AMLVexBox} adjMulist
	     * @param {Number} vexnum
	     * @param {Number} edgenum
	     * @constructor
	     */
	
	    function AMLGraph(adjMulist, vexnum, edgenum) {
	        (0, _classCallCheck3.default)(this, AMLGraph);
	
	        this.adjMulist = adjMulist || [];
	        this.vexnum = vexnum || 0;
	        this.edgenum = edgenum || 0;
	    }
	
	    (0, _createClass3.default)(AMLGraph, [{
	        key: 'locateVex',
	        value: function locateVex(v) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.adjMulist[i].data === v) return i;
	            }
	            return -1;
	        }
	    }, {
	        key: 'deleteArc',
	        value: function deleteArc(v, w) {
	            var i = this.locateVex(v);
	            var j = this.locateVex(w);
	
	            if (i < 0 || j < 0) throw new Error('Vertex not found!');
	
	            var p;
	            // 在i链表中删除该边
	            if (this.adjMulist[i].firstEdge.jvex === j) {
	                this.adjMulist[i].firstEdge = this.adjMulist[i].firstEdge.ilink;
	            } else {
	                for (p = this.adjMulist[i].firstEdge; p && p.ilink.jvex !== j; p = p.ilink) {}
	                if (!p) throw new Error('edge not found!');
	                p.ilink = p.ilink.ilink;
	            }
	
	            // 在j链表中删除该边
	            if (this.adjMulist[j].firstEdge.ivex === i) {
	                this.adjMulist[j].firstEdge = this.adjMulist[j].firstEdge.jlink;
	            } else {
	                for (p = this.adjMulist[j].firstEdge; p && p.jlink.ivex !== i; p = p.jlink) {}
	                if (!p) throw new Error('edge not found!');
	                p.jlink = p.jlink.jlink;
	            }
	
	            this.edgenum--;
	            return true;
	        }
	    }, {
	        key: 'createGraph',
	        value: function createGraph() {
	            var vexnum = +prompt('vexnum: ');
	            this.vexnum = vexnum;
	            var edgenum = +prompt('edgenum: ');
	            this.edgenum = edgenum;
	
	            for (var m = 0; m < vexnum; ++m) {
	                this.adjMulist[m] = new AMLVexBox(prompt('data: '), null);
	            }
	
	            for (m = 0; m < edgenum; ++m) {
	                var t = prompt('tailVex: ');
	                var h = prompt('headVex: ');
	                var i = this.locateVex(t);
	                var j = this.locateVex(h);
	
	                if (i < 0 || j < 0) {
	                    console.error('vertex not found! Try again:');
	                    m--;
	                    continue;
	                }
	
	                var p = new EBox(0, i, j, null, null);
	                var q, r;
	
	                // 插入i链表尾部
	                if (!this.adjMulist[i].firstEdge) {
	                    this.adjMulist[i].firstEdge = p;
	                } else {
	                    q = this.adjMulist[i].firstEdge;
	                    while (q) {
	                        r = q;
	                        if (q.ivex === i) q = q.ilink;else q = q.jlink;
	                    }
	                    if (r.ivex === i) r.ilink = p;else r.jlink = p;
	                }
	
	                // 插入j链表尾部
	                if (!this.adjMulist[j].firstEdge) {
	                    this.adjMulist[j].firstEdge = p;
	                } else {
	                    q = this.adjMulist[j].firstEdge;
	                    while (q) {
	                        r = q;
	                        if (q.jvex === j) q = q.jlink;else q = q.ilink;
	                    }
	                    if (r.jvex === j) r.jlink = p;else r.ilink = p;
	                }
	            }
	        }
	    }]);
	    return AMLGraph;
	}();
	
	//var g = new AMLGraph();
	//g.createGraph();
	//console.log(g);
	
	
	exports.default = AMLGraph;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(23);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(15);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(22);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* Create By Luke */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	/*
	 邻接链表法
	
	 基本思想：对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。
	
	 第i个单链表表示依附于顶点Vi的边(对有向图是以顶点Vi为头或尾的弧)。
	
	 1  结点结构与邻接链表示例
	
	 链表中的结点称为表结点，每个结点由三个域组成。其中邻接点域(adjvex)指示与顶点Vi邻接的顶点在图中的位置(顶点编号)，链域(nextarc)指向下一个与顶点Vi邻接的表结点，数据域(info)存储和边或弧相关的信息，如权值等。对于无权图，如果没有与边相关的其他信息，可省略此域。
	
	 每个链表设一个表头结点(称为顶点结点)，由两个域组成。链域(firstarc)指向链表中的第一个结点，数据域(data) 存储顶点名或其他信息。
	
	 在图的邻接链表表示中，所有顶点结点用一个向量 以顺序结构形式存储，可以随机访问任意顶点的链表，该向量称为表头向量，向量的下标指示顶点的序号。
	
	 用邻接链表存储图时，对无向图，其邻接链表是唯一的；对有向图，其邻接链表有两种形式。
	
	
	 2  邻接表法的特点
	
	 ◆ 表头向量中每个分量就是一个单链表的头结点，分量个数就是图中的顶点数目；
	 ◆ 在边或弧稀疏的条件下，用邻接表表示比用邻接矩阵表示节省存储空间；
	 ◆ 在无向图，顶点Vi的度是第i个链表的结点数；
	 ◆ 对有向图可以建立正邻接表或逆邻接表。正邻接表是以顶点Vi为出度(即为弧的起点)而建立的邻接表；逆邻接表是以顶点Vi为入度(即为弧的终点)而建立的邻接表；
	 ◆ 在有向图中，第i个链表中的结点数是顶点Vi的出 (或入)度；求入 (或出)度，须遍历整个邻接表；
	 ◆ 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点；
	
	 */
	
	var ArcNode =
	/**
	 *
	 * @param {Number} adjVex
	 * @param {ArcNode} nextArc
	 * @param {*} info
	 * @constructor
	 */
	function ArcNode() {
	    var adjVex = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var nextArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, ArcNode);
	
	    // 该弧所指向的顶点的位置
	    this.adjVex = adjVex;
	    // 指向下一条弧的指针
	    this.nextArc = nextArc;
	    // 该弧相关信息的指针
	    this.info = info;
	};
	
	var VexNode =
	/**
	 *
	 * @param {*} data
	 * @param {ArcNode} firstArc
	 * @param {Number} indegree
	 * @constructor
	 */
	function VexNode(data) {
	    var firstArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var indegree = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    (0, _classCallCheck3.default)(this, VexNode);
	
	    // 顶点信息
	    this.data = data;
	    // 指向第一条依附该顶点的弧的指针
	    this.firstArc = firstArc;
	    //  顶点的度, 有向图是入度或出度或没有
	    this.indegree = indegree;
	};
	
	var AdjacencyListGraph = function () {
	    /**
	     *
	     * @param {Array | VexNode} vertices
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	
	    function AdjacencyListGraph() {
	        var vertices = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var vexnum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var arcnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var kind = arguments.length <= 3 || arguments[3] === undefined ? DG : arguments[3];
	        (0, _classCallCheck3.default)(this, AdjacencyListGraph);
	
	        this.vertices = vertices;
	        // 图的当前顶点数和弧数
	        this.vexnum = vexnum;
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    // 查找顶点位置
	
	
	    (0, _createClass3.default)(AdjacencyListGraph, [{
	        key: 'locateVex',
	        value: function locateVex(vp) {
	            for (var _i = 0; _i < this.vexnum; ++_i) {
	                if (this.vertices[_i].data === vp) return _i;
	            }
	
	            return -1;
	        }
	
	        // 添加顶点
	
	    }, {
	        key: 'addVertex',
	        value: function addVertex(vp) {
	            if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	            this.vertices[this.vexnum++] = new VexNode(vp, null, 0);
	            return this.vexnum;
	        }
	
	        /**
	         * 添加弧
	         * 如果是无向图或者无向网,arc1和arc2无顺序要求
	         * 如果是有向图或者有向网，只会添加arc1，因此正邻接表和逆邻接表的顺序需要注意
	         * @param {String} arc1
	         * @param {String} arc2
	         * @param {*} info
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'addArc',
	        value: function addArc(arc1, arc2, info) {
	            var k = this.locateVex(arc1);
	            var j = this.locateVex(arc2);
	
	            if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	            // 边的起始表结点赋值
	            var p = new ArcNode(k, null, info);
	            // 边的末尾表结点赋值
	            var q = new ArcNode(j, null, info);
	
	            // 是无向图，用头插入法插入到两个单链表
	            if (this.kind === UDG || this.kind === UDN) {
	                q.nextArc = this.vertices[k].firstArc;
	                this.vertices[k].firstArc = q;
	                p.nextArc = this.vertices[j].firstArc;
	                this.vertices[j].firstArc = p;
	            }
	            // 建立有向图的邻接链表，用头插入法
	            else {
	                    p.nextArc = this.vertices[j].firstArc;
	                    this.vertices[j].firstArc = p;
	                }
	
	            ++this.arcnum;
	
	            return true;
	        }
	
	        // TODO 其他图类型的创建暂时没弄
	
	    }, {
	        key: 'createGraph',
	        value: function createGraph() {
	            this.vexnum = +prompt('vexnum: ');
	            this.arcnum = +prompt('arcnum: ');
	            // incInfo为0则各弧不含其他信息
	            var incInfo = +prompt('incInfo: ');
	
	            for (var _m = 0; _m < this.vexnum; ++_m) {
	                this.vertices[_m] = new VexNode();
	                this.vertices[_m].data = prompt('vertex: ');
	            }
	
	            for (m = 0; m < this.arcnum; ++m) {
	                var h = prompt('弧头: ');
	                var t = prompt('弧尾: ');
	                var _i2 = this.locateVex(t);
	                var j = this.locateVex(h);
	
	                if (_i2 < 0 || j < 0) {
	                    alert('顶点为找到，请重新输入！');
	                    m--;
	                    continue;
	                }
	
	                var p = new ArcNode(j, null, incInfo && prompt('info: '));
	
	                if (!this.vertices[_i2].firstArc) this.vertices[_i2].firstArc = p;else {
	                    for (var _q = this.vertices[_i2].firstArc; _q.nextArc; _q = _q.nextArc) {}
	                    q.nextArc = p;
	                }
	            }
	        }
	
	        // 判断一个邻接表存储的有向图是否可传递
	
	    }, {
	        key: 'isPass',
	        value: function isPass() {
	            if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	            for (var x = 0; x < this.vexnum; ++x) {
	                for (var p = this.vertices[x].firstArc; p; p = p.nextArc) {
	                    var y = p.adjVex;
	                    for (var _q2 = this.vertices[y].firstArc; _q2; _q2 = _q2.nextArc) {
	                        var z = _q2.adjVex;
	                        if (z !== x && this.isAdj(x, z)) return false;
	                    }
	                }
	            }
	
	            return true;
	        }
	
	        // 判断有向图是否存在边(m,n)
	
	    }, {
	        key: 'isAdj',
	        value: function isAdj(m, n) {
	            for (var p = this.vertices[m].firstArc; p; p = p.nextArc) {
	                if (p.adjVex === n) return true;
	            }
	            return false;
	        }
	
	        /**
	         * 深度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	         * @param {String} i
	         * @param {String} j
	         */
	
	    }, {
	        key: 'exist_path_DFS',
	        value: function exist_path_DFS(i, j) {
	            var visited = [];
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	
	            if (i < 0 || j < 0) throw new Error('vertex not found!');
	
	            return exist_path(this, i, j);
	
	            function exist_path(graph, i, j) {
	                if (i === j) return true;
	
	                visited[i] = true;
	                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (!visited[k] && exist_path(graph, k, j)) return true;
	                }
	
	                return false;
	            }
	        }
	
	        /**
	         * 广度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	         * @param {String} i
	         * @param {String} j
	         */
	
	    }, {
	        key: 'exist_path_BFS',
	        value: function exist_path_BFS(i, j) {
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	            var visited = [];
	            var queue = new _Queue2.default();
	            queue.enQueue(i);
	
	            while (queue.rear) {
	                var u = queue.deQueue();
	                visited[u] = 1;
	
	                for (var p = this.vertices[i].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (k === j) return true;
	                    if (!visited[k]) queue.enQueue(k);
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * 判断邻接表方式存储的有向图的顶点i到j是否存在长度为k的简单路径
	         * @param {String} i
	         * @param {String} j
	         * @param {Number} k
	         */
	
	    }, {
	        key: 'exist_path_len',
	        value: function exist_path_len(i, j, k) {
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	            var visited = [];
	
	            return function recurse(graph, i, j, k) {
	                // 找到了一条路径，且长度符合
	                if (i === j && k === 0) return true;else if (k > 0) {
	                    visited[i] = 1;
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        if (!visited[l]) {
	                            // 剩余路径长度减一
	                            if (recurse(graph, l, j, k - 1)) return true;
	                        }
	                    }
	                    // 允许曾经被访问过的结点出现在另一条路径上
	                    visited[i] = 0;
	                }
	
	                return false;
	            }(this, i, j, k);
	        }
	
	        /**
	         * 求有向图中顶点u到v之间的所有简单路径，k为当前路径长度
	         * @param {String} u
	         * @param {String} v
	         * @param {Number} k
	         *
	         * @example
	         *  graph.find_all_path('v1', 'v2', 0);
	         */
	
	    }, {
	        key: 'find_all_path',
	        value: function find_all_path(u, v, k) {
	            u = this.locateVex(u);
	            v = this.locateVex(v);
	            var path = [];
	            var visited = [];
	
	            findPath(this, u, v, k);
	
	            function findPath(graph, u, v, k) {
	                // 加入当前路径中
	                path[k] = u;
	                visited[u] = 1;
	
	                // 找到一条简单路径
	                if (u === v) {
	                    console.log('Found one path!');
	                    for (var _i3 = 0; path[_i3]; ++_i3) {
	                        console.log(path[_i3]);
	                    }
	                } else {
	                    for (var p = graph.vertices[u].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        // 继续寻找
	                        if (!visited[l]) findPath(graph, l, v, k + 1);
	                    }
	                }
	
	                visited[u] = 0;
	                // 回溯
	                path[k] = 0;
	            }
	        }
	
	        /**
	         * 求有向图的顶点之间长度为len的简单路径条数
	         * @param {String} i
	         * @param {String} j
	         * @param {Number} len
	         */
	
	    }, {
	        key: 'getPathNum_len',
	        value: function getPathNum_len(i, j, len) {
	            var visited = [];
	
	            return function recurse(graph, i, j, len) {
	                if (i === j && len === 0) return 1;else if (len > 0) {
	                    var sum = 0;
	                    visited[i] = 1;
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        if (!visited[l]) sum += recurse(l, j, len - 1);
	                    }
	                    visited[i] = 0;
	                    return sum;
	                }
	            }(this, i, j, len);
	        }
	
	        /**
	         * 求有向无环图的根
	         */
	
	    }, {
	        key: 'getRoot',
	        value: function getRoot() {
	            var visited = [];
	
	            for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                // 每次都要将访问数组清零
	                for (var _w = 0; _w < this.vexnum; ++_w) {
	                    visited[_w] = false;
	                } // 从顶点i出发进行深度优先遍历
	                dfs(this, _i4);
	
	                var flag = true;
	                for (w = 0; w < this.vexnum; ++w) {
	                    // 如果i是根，则深度优先遍历可以访问到所有结点
	                    if (!visited[w]) flag = false;
	                }
	
	                if (flag) console.log('Found a root vertex: %d', _i4);
	            }
	
	            function dfs(graph, v) {
	                visited[v] = true;
	
	                for (var p = graph.vertices[v].firstArc; p; p = p.nextArc) {
	                    var _w2 = p.adjVex;
	                    if (!visited[_w2]) dfs(graph, _w2);
	                }
	            }
	        }
	
	        /**
	         * 求一个有向无环图中最长的路径
	         */
	
	    }, {
	        key: 'getLongestPath',
	        value: function getLongestPath() {
	            var mlp = [];
	            var path = [];
	            var visited = [];
	            var maxLen = 0;
	
	            this.countIndegree();
	
	            for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                for (var j = 0; j < this.vexnum; ++j) {
	                    visited[j] = false;
	                } // 从每一个零入度结点开始深度优先遍历
	                if (this.vertices[_i5].indegree === 0) dfs(this, _i5, 0);
	            }
	
	            console.log('Longest Path:');
	            // 输出最长路径
	            for (i = 0; mlp[i]; ++i) {
	                console.log(mlp.join(','));
	            }function dfs(graph, i, len) {
	                visited[i] = true;
	                path[len] = i;
	
	                // 新的最长路径
	                if (len > maxLen && !graph.vertices[i].firstArc) {
	                    // 保存下来
	                    for (var _j = 0; _j <= len; ++_j) {
	                        mlp[_j] = path[_j];
	                    }maxLen = len;
	                } else {
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var _w3 = p.adjVex;
	                        if (!visited[_w3]) dfs(graph, _w3, len + 1);
	                    }
	                }
	
	                path[i] = 0;
	                visited[i] = false;
	            }
	        }
	
	        // 邻接表的递归式深度优先遍历
	
	    }, {
	        key: 'DFSTraverse',
	        value: function DFSTraverse(visitFn) {
	            var visited = [];
	            for (var _i6 = 0; _i6 < this.vexnum; ++_i6) {
	                visited[_i6] = false;
	            }for (var _i7 = 0; _i7 < this.vexnum; ++_i7) {
	                if (!visited[_i7]) dfs(this, _i7);
	            }
	
	            function dfs(graph, v) {
	                visited[v] = true;
	                visitFn.call(graph, v);
	
	                var p = graph.vertices[v].firstArc;
	                while (p) {
	                    if (!visited[p.adjVex]) dfs(graph, p.adjVex);
	
	                    p = p.nextArc;
	                }
	            }
	        }
	
	        // 邻接表的非递归深度优先搜索
	
	    }, {
	        key: 'DFSTraverse_NonRecurse',
	        value: function DFSTraverse_NonRecurse(visitFn) {
	            var visited = [];
	            var stack = new _index2.default();
	            for (var _i8 = 0; _i8 < this.vexnum; ++_i8) {
	                visited[_i8] = false;
	            }for (var _i9 = 0; _i9 < this.vexnum; ++_i9) {
	                if (!visited[_i9]) {
	                    stack.push(_i9);
	                    visited[_i9] = true;
	                    visitFn.call(this, _i9);
	
	                    var v = void 0;
	                    while ((v = stack.peek()) != null) {
	                        var p = this.vertices[v].firstArc;
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                visitFn.call(this, p.adjVex);
	                                stack.push(p.adjVex);
	                            } else stack.pop();
	
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	        }
	
	        // 邻接表的广度优先搜索
	
	    }, {
	        key: 'BFSTraverse',
	        value: function BFSTraverse(visitFn) {
	            var queue = new _Queue2.default();
	            var visited = [];
	            for (var _i10 = 0; _i10 < this.vexnum; ++_i10) {
	                visited[_i10] = false;
	            }for (var _i11 = 0; _i11 < this.vexnum; ++_i11) {
	                if (!visited[_i11]) {
	                    queue.enQueue(_i11);
	                    visited[_i11] = true;
	                    visitFn.call(this, _i11);
	
	                    while (queue.rear) {
	                        var _w4 = queue.deQueue();
	                        var p = this.vertices[_w4].firstArc;
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                visitFn.call(this, p.adjVex);
	                                queue.enQueue(p.adjVex);
	                            }
	
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	        }
	
	        // 建立无向图的深度优先生成森林的孩子兄弟链表树
	
	    }, {
	        key: 'createDFSForest',
	        value: function createDFSForest() {
	            var tree = null;
	            var visited = [];
	            for (var _i12 = 0; _i12 < this.vexnum; ++_i12) {
	                visited[_i12] = false;
	            }var q = void 0;
	            for (var _i13 = 0; _i13 < this.vexnum; ++_i13) {
	                if (!visited[_i13]) {
	                    // 新的生成树的根结点
	                    var p = new _BinaryTree.ChildSiblingTree(this.vertices[_i13].data);
	
	                    // 第一棵生成树的根
	                    if (!tree) tree = p;
	                    // 其它生成树的根
	                    else q.nextSibling = p;
	
	                    // q为当前生成树的根
	                    q = p;
	                    // 建立以p为根的生成树
	                    DFSTree(this, _i13, p);
	                }
	            }
	
	            return tree;
	
	            // 以第v个顶点触发深度优先遍历图，建立以tree为根的生成树
	            function DFSTree(graph, v, tree) {
	                visited[v] = true;
	                var first = true;
	                var w = graph.vertices[v].firstArc;
	                var q = void 0;
	
	                while (w) {
	                    if (!visited[w.adjVex]) {
	                        visited[w.adjVex] = true;
	                        var _p = new _BinaryTree.ChildSiblingTree(graph.vertices[w.adjVex].data);
	
	                        // w是v的第一个未被访问的邻接结点
	                        if (first) {
	                            tree.firstChild = _p;
	                            first = false;
	                        }
	                        // w是v的其它未被访问的邻接顶点
	                        else q.nextSibling = _p;
	
	                        q = _p;
	
	                        DFSTree(graph, w.adjVex, q);
	                    }
	
	                    w = w.nextArc;
	                }
	            }
	        }
	    }, {
	        key: 'createBFSForest',
	        value: function createBFSForest() {
	            var tree = null;
	            var visited = [];
	            var queue = new _Queue2.default();
	            for (var _i14 = 0; _i14 < this.vexnum; ++_i14) {
	                visited[_i14] = false;
	            }var q = void 0;
	            for (var _i15 = 0; _i15 < this.vexnum; ++_i15) {
	                if (!visited[_i15]) {
	                    visited[_i15] = true;
	                    queue.enQueue(_i15);
	
	                    var node = new _BinaryTree.ChildSiblingTree(this.vertices[_i15].data);
	                    if (!tree) tree = node;else q.nextSibling = node;
	
	                    q = node;
	
	                    while (queue.rear) {
	                        var _w5 = queue.deQueue();
	                        var p = this.vertices[_w5].firstArc;
	                        var first = true;
	                        var pre = void 0;
	
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                queue.enQueue(p.adjVex);
	
	                                var node2 = new _BinaryTree.ChildSiblingTree(this.vertices[p.adjVex].data);
	
	                                if (first) {
	                                    node.firstChild = node2;
	                                    first = false;
	                                } else pre.nextSibling = node2;
	
	                                pre = node2;
	                            }
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	
	            return tree;
	        }
	    }, {
	        key: 'findArticul',
	        value: function findArticul() {
	            var visited = [];
	            var count = 1;
	            var low = [];
	            low[0] = count;
	            visited[0] = 1;
	            for (var _i16 = 1; _i16 < this.vexnum; ++_i16) {
	                visited[_i16] = 0;
	            }var p = this.vertices[0].firstArc;
	            var v = p.adjVex;
	
	            DFSArticul(this, v);
	            if (count < this.vexnum) {
	                console.log(0 + '  ' + this.vertices[0].data);
	                while (p.nextArc) {
	                    p = p.nextArc;
	                    v = p.adjVex;
	                    if (visited[v] === 0) DFSArticul(this, v);
	                }
	            }
	
	            function DFSArticul(graph, v0) {
	                var min = visited[v0] = ++count;
	                for (var _p2 = graph.vertices[v0].firstArc; _p2; _p2 = _p2.nextArc) {
	                    var _w6 = _p2.adjVex;
	                    if (visited[_w6] === 0) {
	                        DFSArticul(graph, _w6);
	                        if (low[_w6] < min) min = low[_w6];
	                        if (low[_w6] >= visited[v0]) console.log(v0 + '  ' + graph.vertices[v0].data);
	                    } else if (visited[_w6] < min) min = visited[_w6];
	                }
	                low[v0] = min;
	            }
	        }
	
	        // 统计各顶点入度的函数
	
	    }, {
	        key: 'countIndegree',
	        value: function countIndegree() {
	            for (var k = 0; k < this.vexnum; ++k) {
	                this.vertices[k].indegree = 0;
	            }for (var _k = 0; _k < this.vexnum; ++_k) {
	                for (var p = this.vertices[_k].firstArc; p; p = p.nextArc) {
	                    ++this.vertices[p.adjVex].indegree;
	                }
	            }
	        }
	
	        // 拓扑排序算法
	
	    }, {
	        key: 'topologicSort',
	        value: function topologicSort() {
	            var stack = new _index2.default();
	            this.topologicalOrder = [];
	            this.countIndegree();
	
	            for (var _i17 = 0; _i17 < this.vexnum; ++_i17) {
	                if (this.vertices[_i17].indegree === 0) stack.push(_i17);
	            }
	
	            var count = 0;
	            while (stack.length) {
	                var _i18 = stack.pop();
	                this.topologicalOrder.push(_i18);
	                console.log(this.vertices[_i18].data);
	                ++count;
	                for (var p = this.vertices[_i18].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (--this.vertices[k].indegree === 0) stack.push(k);
	                }
	            }
	
	            return count >= this.vexnum;
	        }
	
	        // 输出有向图的各项关键活动
	
	    }, {
	        key: 'criticalPath',
	        value: function criticalPath() {
	            if (!this.topologicSort()) throw new Error('AOE网中存在回路！');
	
	            var ve = [];
	            // 事件最早发生时间初始化
	            for (var j = 0; j < this.vexnum; ++j) {
	                ve[j] = 0;
	            } // 计算每个事件的最早发生时间ve值
	            for (var _m2 = 0; _m2 < this.vexnum; ++_m2) {
	                var _j2 = this.topologicalOrder[_m2];
	                for (var p = this.vertices[_j2].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (ve[_j2] + p.info > ve[k]) ve[k] = ve[_j2] + p.info;
	                }
	            }
	            var vl = [];
	            // 事件最晚发生时间初始化
	            for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	                vl[_j3] = ve[this.vexnum - 1];
	            } // 计算每个事件的最晚发生时间vl的值
	            for (var _m3 = this.vexnum - 1; _m3 >= 0; --_m3) {
	                var _j4 = this.topologicalOrder[_m3];
	                for (var _p3 = this.vertices[_j4].firstArc; _p3; _p3 = _p3.nextArc) {
	                    var _k2 = _p3.adjVex;
	                    if (vl[_k2] - _p3.info < vl[_j4]) vl[_j4] = vl[_k2] - _p3.info;
	                }
	            }
	            // 输出所有关键活动
	            for (var _m4 = 0; _m4 < this.vexnum; ++_m4) {
	                for (var _p4 = this.vertices[_m4].firstArc; _p4; _p4 = _p4.nextArc) {
	                    var _k3 = _p4.adjVex;
	                    if (ve[_m4] + _p4.info === vl[_k3]) console.log('<%d, %d>', _m4, _k3);
	                }
	            }
	        }
	    }, {
	        key: 'shortestPath_Dijkstra',
	        value: function shortestPath_Dijkstra(v0) {
	            var dist = [];
	            var pre = [];
	            var final = [];
	            var w = void 0;
	
	            for (var _v = 0; _v < this.vexnum; ++_v) {
	                dist[_v] = Infinity;
	            }for (var p = this.vertices[v0].firstArc; p; p = p.nextArc) {
	                dist[p.adjVex] = p.info;
	            }var v = void 0;
	            for (v = 0; v < this.vexnum; ++v) {
	                final[v] = false;
	                pre[v] = pre[v] || [];
	                for (w = 0; w < this.vexnum; ++w) {
	                    pre[v][w] = false;
	                }if (dist[v] < Infinity) {
	                    pre[v][v0] = true;
	                    pre[v][v] = true;
	                }
	            }
	
	            dist[v0] = 0;
	            final[v0] = true;
	
	            for (var _i19 = 1; _i19 < this.vexnum; ++_i19) {
	                var min = Infinity;
	                for (w = 0; w < this.vexnum; ++w) {
	                    if (!final[w] && dist[w] < min) {
	                        v = w;
	                        min = dist[w];
	                    }
	                }
	
	                final[v] = true;
	
	                for (var _p5 = this.vertices[v].firstArc; _p5; _p5 = _p5.nextArc) {
	                    w = _p5.adjVex;
	                    if (!final[w] && min + _p5.info < dist[w]) {
	                        dist[w] = min + _p5.info;
	                        pre[w] = pre[v];
	                        pre[w][w] = true;
	                    }
	                }
	            }
	
	            console.log(final);
	            console.log(pre);
	            console.log(dist);
	
	            return {
	                final: final,
	                pre: pre,
	                dist: dist
	            };
	        }
	    }]);
	    return AdjacencyListGraph;
	}();
	
	// 无向图的邻接表
	
	
	exports.default = AdjacencyListGraph;
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v1', 'v2');
	adjListGraph.addArc('v1', 'v3');
	adjListGraph.addArc('v1', 'v4');
	adjListGraph.addArc('v2', 'v3');
	adjListGraph.addArc('v3', 'v4');
	adjListGraph.addArc('v3', 'v5');
	adjListGraph.addArc('v4', 'v5');
	
	console.log(adjListGraph);
	
	// 有向图的逆邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v1', 'v2');
	g.addArc('v1', 'v4');
	g.addArc('v3', 'v2');
	g.addArc('v3', 'v1');
	g.addArc('v4', 'v3');
	g.addArc('v3', 'v5');
	g.addArc('v5', 'v4');
	
	console.log(g);
	
	// 有向图的正邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v2', 'v1');
	g.addArc('v4', 'v1');
	g.addArc('v2', 'v3');
	g.addArc('v1', 'v3');
	g.addArc('v3', 'v4');
	g.addArc('v5', 'v3');
	g.addArc('v4', 'v5');
	
	console.log(g);
	
	console.log('adjListGraph DFSTraverse: ');
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v5', 'v4');
	adjListGraph.addArc('v3', 'v2');
	adjListGraph.addArc('v2', 'v1');
	adjListGraph.addArc('v3', 'v1');
	
	adjListGraph.DFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph DFSTraverse_NonRecurse: ');
	adjListGraph.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph BFSTraverse: ');
	var g2 = new AdjacencyListGraph([], 0, 0, DG);
	g2.addVertex('v1');
	g2.addVertex('v2');
	g2.addVertex('v3');
	g2.addVertex('v4');
	g2.addVertex('v5');
	
	g2.addArc('v4', 'v1');
	g2.addArc('v2', 'v1');
	g2.addArc('v5', 'v3');
	g2.addArc('v2', 'v3');
	g2.addArc('v1', 'v3');
	g2.addArc('v3', 'v4');
	g2.addArc('v4', 'v5');
	
	g2.BFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('DFS: expect false: ' + adjListGraph.exist_path_DFS('v1', 'v4'));
	console.log('DFS: expect true: ' + adjListGraph.exist_path_DFS('v1', 'v2'));
	
	console.log('BFS : expect false: ' + adjListGraph.exist_path_BFS('v1', 'v4'));
	console.log('BFS :expect true: ' + adjListGraph.exist_path_BFS('v1', 'v2'));
	
	/*
	 图的连通性问题
	
	 无向图的连通分量与生成树
	
	 1 无向图的连通分量和生成树
	 对于无向图，对其进行遍历时：
	 ◆ 若是连通图：仅需从图中任一顶点出发，就能访问图中的所有顶点；
	 ◆ 若是非连通图：需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集；
	
	 ⑴ 若G=(V,E)是无向连通图， 顶点集和边集分别是V(G) ，E(G) 。若从G中任意点出发遍历时， E(G)被分成两个互不相交的集合：
	 T(G) ：遍历过程中所经过的边的集合；
	 B(G) ：遍历过程中未经过的边的集合；
	 显然： E(G)=T(G)∪B(G) ，T(G)∩B(G)=Ø
	 显然，图G’=(V, T(G))是G的极小连通子图，且G’是一棵树。G’称为图G的一棵生成树。
	 从任意点出发按DFS算法得到生成树G’称为深度优先生成树；按BFS算法得到的G’称为广度优先生成树。
	
	 ⑵  若G=(V,E)是无向非连通图，对图进行遍历时得到若干个连通分量的顶点集：V1(G) ,V2(G) ,…,Vn(G)和相应所经过的边集：T1(G) ,T2(G) , …,Tn(G) 。
	 则对应的顶点集和边集的二元组：Gi=(Vi(G),Ti(G))
	 (1≦i≦n)是对应分量的生成树，所有这些生成树构成了原来非连通图的生成森林。
	
	 说明：当给定无向图要求画出其对应的生成树或生成森林时，必须先给出相应的邻接表，然后才能根据邻接表画出其对应的生成树或生成森林。
	
	
	 2  图的生成树和生成森林算法
	
	 对图的深度优先搜索遍历DFS(或BFS)算法稍作修改，就可得到构造图的DFS生成树算法。
	 在算法中，树的存储结构采用孩子—兄弟表示法。首先建立从某个顶点V出发，建立一个树结点，然后再分别以V的邻接点为起始点，建立相应的子生成树，并将其作为V 结点的子树链接到V结点上。显然，算法是一个递归算法。
	
	 */
	
	console.log(adjListGraph.createDFSForest());
	
	console.log(adjListGraph.createBFSForest());
	
	/*
	 在某图中，若删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。一个没有关节点的连通图称为重连通图。
	 在重连通图中，任意一对顶点之间至少存在两条路径，则再删去某个顶点即相关各边后也不破坏图的连通性。若在图的连通图上删去k个节点才能破坏图的连通性，则称K为此图的连通度。
	 他们常常在通信网络的图或航空网中应用，K越大，系统越稳定，反之，战争中若要摧毁敌方的运输线，只须破坏其运输网中的关节点即可。
	 */
	
	var articulTest = new AdjacencyListGraph([], 0, 0, UDG);
	articulTest.addVertex('A');
	articulTest.addVertex('B');
	articulTest.addVertex('C');
	articulTest.addVertex('D');
	articulTest.addVertex('E');
	articulTest.addVertex('F');
	articulTest.addVertex('G');
	articulTest.addVertex('H');
	articulTest.addVertex('I');
	articulTest.addVertex('J');
	articulTest.addVertex('K');
	articulTest.addVertex('L');
	articulTest.addVertex('M');
	
	articulTest.addArc('A', 'B');
	articulTest.addArc('A', 'C');
	articulTest.addArc('A', 'F');
	articulTest.addArc('A', 'L');
	articulTest.addArc('C', 'B');
	articulTest.addArc('D', 'B');
	articulTest.addArc('G', 'B');
	articulTest.addArc('H', 'B');
	articulTest.addArc('M', 'B');
	articulTest.addArc('D', 'E');
	articulTest.addArc('G', 'H');
	articulTest.addArc('G', 'I');
	articulTest.addArc('G', 'K');
	articulTest.addArc('H', 'K');
	articulTest.addArc('J', 'L');
	articulTest.addArc('J', 'M');
	articulTest.addArc('L', 'M');
	
	articulTest.findArticul();
	
	/*
	 有向无环图及其应用
	
	 有向无环图(Directed Acycling Graph)：是图中没有回路(环)的有向图。是一类具有代表性的图，主要用于研究工程项目的工序问题、工程时间进度问题等。
	
	 一个工程(project)都可分为若干个称为活动(active)的子工程(或工序)，各个子工程受到一定的条件约束：某个子工程必须开始于另一个子工程完成之后；整个工程有一个开始点(起点)和一个终点。人们关心：
	 ◆ 工程能否顺利完成?影响工程的关键活动是什么?
	 ◆ 估算整个工程完成所必须的最短时间是多少?
	
	 对工程的活动加以抽象：图中顶点表示活动，有向边表示活动之间的优先关系，这样的有向图称为顶点表示活动的网(Activity On Vertex Network ，AOV网) 。
	
	
	 拓扑排序
	
	 1 定义
	 拓扑排序(Topological Sort) ：由某个集合上的一个偏序得到该集合上的一个全序的操作。
	
	 ◆ 集合上的关系：集合A上的关系是从A到A的关系(AA) 。
	 ◆ 关系的自反性：若a∈A有(a，a)∈R，称集合A上的关系R是自反的。
	 ◆ 关系的对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。
	 ◆ 关系的对称性与反对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。如果对于a，b∈A ，仅当a=b时有(a，b)∈R和(b，a)∈R ，称集合A上的关系R是反对称的。
	 ◆ 关系的传递性：若a，b，c∈A，若(a，b)∈R，并且(b，c)∈R ，则(a，c)∈R ，称集合A上的关系R是传递的。
	 ◆ 偏序：若集合A上的关系R是自反的，反对称的和传递的，则称R是集合A上的偏序关系。
	 ◆ 全序：设R是集合A上的偏序关系，a，b∈A，必有aRb或bRa， 则称R是集合A上的全序关系。
	
	 即偏序是指集合中仅有部分元素之间可以比较，而全序是指集合中任意两个元素之间都可以比较。
	 在AOV网中，若有有向边<i, j>，则i是j的直接前驱，j是i的直接后继；推而广之，若从顶点i到顶点j有有向路径，则i是j的前驱，j是i的后继。
	 在AOV网中，不能有环，否则，某项活动能否进行是以自身的完成作为前提条件。
	 检查方法：对有向图的顶点进行拓扑排序，若所有顶点都在其拓扑有序序列中，则无环。
	 有向图的拓扑排序：构造AOV网中顶点的一个拓扑线性序列(v’1,v’2, ⋯,v’n)，使得该线性序列不仅保持原来有向图中顶点之间的优先关系，而且对原图中没有优先关系的顶点之间也建立一种(人为的)优先关系。
	
	 2 拓扑排序算法
	 算法思想
	
	 ① 在AOV网中选择一个没有前驱的顶点且输出；
	 ② 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧)所有有向弧(边) ；
	 ③ 重复①、②，直到图中全部顶点都已输出(图中无环)或图中不存在无前驱的顶点(图中必有环)。
	
	 3  算法实现说明
	 ◆ 采用正邻接链作为AOV网的存储结构；
	 ◆ 设立堆栈，用来暂存入度为0的顶点；
	 ◆ 删除顶点以它为尾的弧：弧头顶点的入度减1。
	
	 整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var topologicTest = new AdjacencyListGraph([], 0, 0, DG);
	topologicTest.addVertex('v1');
	topologicTest.addVertex('v2');
	topologicTest.addVertex('v3');
	topologicTest.addVertex('v4');
	topologicTest.addVertex('v5');
	topologicTest.addVertex('v6');
	
	topologicTest.addArc('v2', 'v1');
	topologicTest.addArc('v4', 'v1');
	topologicTest.addArc('v3', 'v1');
	topologicTest.addArc('v2', 'v3');
	topologicTest.addArc('v5', 'v3');
	topologicTest.addArc('v4', 'v6');
	topologicTest.addArc('v5', 'v4');
	topologicTest.addArc('v5', 'v6');
	
	console.log('topologicSort: ');
	console.log(topologicTest.topologicSort());
	
	/*
	 关键路径(Critical Path)
	
	 与AOV网相对应的是AOE(Activity On Edge) ，是边表示活动的有向无环图，如图7-24所示。图中顶点表示事件(Event)，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的时间或费用。
	
	 1 与AOE有关的研究问题
	 ◆ 完成整个工程至少需要多少时间?
	 ◆ 哪些活动是影响工程进度(费用)的关键?
	 工程完成最短时间：从起点到终点的最长路径长度(路径上各活动持续时间之和) 。长度最长的路径称为关键路径，关键路径上的活动称为关键活动。关键活动是影响整个工程的关键。
	 设v0是起点，从v0到vi的最长路径长度称为事件vi的最早发生时间，即是以vi为尾的所有活动的最早发生时间。
	 若活动ai是弧<j, k>，持续时间是dut(<j, k>)，设：
	 ◆ e(i)：表示活动ai的最早开始时间；
	 ◆ l(i)：在不影响进度的前提下，表示活动ai的最晚开始时间； 则l(i)-e(i)表示活动ai的时间余量，若l(i)-e(i)=0，表示活动ai是关键活动。
	 ◆ ve(i)：表示事件vi的最早发生时间，即从起点到顶点vi的最长路径长度；
	 ◆ vl(i)：表示事件vi的最晚发生时间。则有以下关系：
	 e(i)=ve(j)
	 l(i)= vl(k)-dut(<j, k>)
	 0    j=0，表示vj是起点
	 ve(j)=
	 Max{ve(i)+dut(<i, j>)|<vi, vj>是网中的弧}
	
	 含义是：源点事件的最早发生时间设为0；除源点外，只有进入顶点vj的所有弧所代表的活动全部结束后，事件vj才能发生。即只有vj的所有前驱事件vi的最早发生时间ve(i)计算出来后，才能计算ve(j) 。
	 方法是：对所有事件进行拓扑排序，然后依次按拓扑顺序计算每个事件的最早发生时间。
	 ve(n-1)    j=n-1，表示vj是终点
	 vl(j)=
	 Min{vl(k)-dut(<j, k>)|<vj, vk>是网中的弧}
	 含义是：只有vj的所有后继事件vk的最晚发生时间vl(k)计算出来后，才能计算vl(j) 。
	 方法是：按拓扑排序的逆顺序，依次计算每个事件的最晚发生时间。
	
	
	 2 求AOE中关键路径和关键活动
	 ⑴ 算法思想
	 ① 利用拓扑排序求出AOE网的一个拓扑序列；
	 ②  从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个事件的最早发生时间ve(i) ；
	 ③  从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；
	
	 设AOE网有n个事件，e个活动，则算法的主要执行是：
	 ◆ 进行拓扑排序：时间复杂度是O(n+e) ；
	 ◆ 求每个事件的ve值和vl值：时间复杂度是O(n+e) ；
	 ◆ 根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；
	 因此，整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var criticalPathTest = new AdjacencyListGraph([], 0, 0, DG);
	criticalPathTest.addVertex('v0');
	criticalPathTest.addVertex('v1');
	criticalPathTest.addVertex('v2');
	criticalPathTest.addVertex('v3');
	criticalPathTest.addVertex('v4');
	criticalPathTest.addVertex('v5');
	criticalPathTest.addVertex('v6');
	criticalPathTest.addVertex('v7');
	criticalPathTest.addVertex('v8');
	
	criticalPathTest.addArc('v1', 'v0', 3);
	criticalPathTest.addArc('v2', 'v0', 10);
	criticalPathTest.addArc('v4', 'v1', 13);
	criticalPathTest.addArc('v4', 'v2', 12);
	criticalPathTest.addArc('v3', 'v1', 9);
	criticalPathTest.addArc('v5', 'v2', 7);
	criticalPathTest.addArc('v7', 'v4', 6);
	criticalPathTest.addArc('v7', 'v3', 4);
	criticalPathTest.addArc('v7', 'v5', 11);
	criticalPathTest.addArc('v6', 'v3', 8);
	criticalPathTest.addArc('v8', 'v7', 5);
	criticalPathTest.addArc('v8', 'v6', 2);
	
	criticalPathTest.criticalPath();
	
	var dijTest = new AdjacencyListGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('1', '0', 20);
	dijTest.addArc('4', '0', 10);
	dijTest.addArc('2', '0', 60);
	dijTest.addArc('5', '0', 65);
	dijTest.addArc('2', '1', 30);
	dijTest.addArc('3', '2', 40);
	dijTest.addArc('2', '5', 15);
	dijTest.addArc('5', '4', 20);
	dijTest.addArc('4', '3', 35);
	dijTest.addArc('3', '1', 70);
	
	dijTest.shortestPath_Dijkstra(0);
	
	(function () {
	    /**
	     * 输出有向无环图形式表示的逆波兰式
	     */
	    function niBoLan_DAG(graph) {
	        graph.countIndegree();
	        for (var _i20 = 0; _i20 < graph.vexnum; ++_i20) {
	            // 找到有向无环图的根
	            if (graph.vertices[_i20].indegree === 0) {
	                printNiBoLan(graph, _i20);
	                break;
	            }
	        }
	
	        return false;
	    }
	
	    function printNiBoLan(graph, i) {
	        var c = graph.vertices[i].data;
	        var p = graph.vertices[i].firstArc;
	
	        // 子表达式
	        if (p) {
	            printNiBoLan(graph, p.adjVex);
	            printNiBoLan(graph, p.nextArc.adjVex);
	        }
	
	        console.log(c + '');
	    }
	
	    /**
	     * 给有向无环图表示的表达式求值
	     */
	    function evaluate_DAG(graph) {
	        graph.countIndegree();
	        for (var _i21 = 0; _i21 < graph.vexnum; ++_i21) {
	            if (!graph.vertices[_i21].indegree) return evaluate_imp(graph, _i21);
	        }
	    }
	
	    function evaluate_imp(g, i) {
	        if (/^\d+$/.test(g.vertices[i].data)) return g.vertices[i].data;else {
	            var p = g.vertices[i].firstArc;
	            var v1 = evaluate_imp(g, p.adjVex);
	            var v2 = evaluate_imp(g, p.nextArc.adjVex);
	            return calculate(v1, g.vertices[i].data, v2);
	        }
	    }
	
	    function calculate(a, operation, b) {
	        // 偷一下懒..
	        return eval(a + operation + b);
	    }
	
	    // ((1 + 2) * (2 * (3 + 4)) + (3 + 4) * 5) * ((3 + 4) * 5)
	    var dag = new AdjacencyListGraph([], 0, 0, DG);
	
	    var a1 = new String('*');
	    var a2 = new String('+');
	    var a3 = new String('*');
	    var a4 = new String('*');
	    var a5 = new String('+');
	    var a6 = new String('*');
	    var a7 = new String('+');
	
	    // 12
	    dag.addVertex(a1);
	    dag.addVertex(a2);
	    dag.addVertex(a3);
	    dag.addVertex(a4);
	    dag.addVertex(a5);
	    dag.addVertex(a6);
	    dag.addVertex(a7);
	    dag.addVertex(1);
	    dag.addVertex(2);
	    dag.addVertex(3);
	    dag.addVertex(4);
	    dag.addVertex(5);
	
	    // 14
	    dag.addArc(a2, a1);
	    dag.addArc(a4, a1);
	    dag.addArc(a3, a2);
	    dag.addArc(a4, a2);
	    dag.addArc(a5, a3);
	    dag.addArc(a6, a3);
	    dag.addArc(a7, a6);
	    dag.addArc(a7, a4);
	    dag.addArc(5, a4);
	    dag.addArc(1, a5);
	    dag.addArc(2, a5);
	    dag.addArc(2, a6);
	    dag.addArc(3, a7);
	    dag.addArc(4, a7);
	
	    console.log('niBoLan_DAG: ');
	    niBoLan_DAG(dag);
	    console.log('evaluate_DAG: ' + evaluate_DAG(dag)); // 2695
	})();

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(23);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(15);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(22);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* create by Luke */
	/**
	 * 图(Graph)
	 *
	 * 图(Graph)是一种比线性表和树更为复杂的数据结构。
	 *
	 * 线性结构：是研究数据元素之间的一对一关系。在这种结构中，除第一个和最后一个元素外，任何一个元素都有唯一的一个直接前驱和直接后继。
	 *
	 * 树结构：是研究数据元素之间的一对多的关系。在这种结构中，每个元素对下(层)可以有0个或多个元素相联系，对上(层)只有唯一的一个元素相关，数据元素之间有明显的层次关系。
	 *
	 * 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。
	 *
	 * 图的应用极为广泛，已渗入到诸如语言学、逻辑学、物理、化学、电讯、计算机科学以及数学的其它分支。
	 *
	 * 图的基本概念
	 *
	 * 一个图(G)定义为一个偶对(V,E) ，记为G=(V,E) 。其中： V是顶点(Vertex)的非空有限集合，记为V(G)；E是无序集V&V的一个子集，记为E(G) ，其元素是图的弧(Arc)。
	 * 将顶点集合为空的图称为空图。其形式化定义为：
	 G=(V ，E)
	 V={v|v∈data object}
	 E={<v,w>| v,w∈V∧p(v,w)}
	 P(v,w)表示从顶点v到顶点w有一条直接通路。
	 *
	 * 弧(Arc) ：表示两个顶点v和w之间存在一个关系，用顶点偶对<v,w>表示。通常根据图的顶点偶对将图分为有向图和无向图。
	 * 有向图(Digraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是有序的，称图G是有向图。
	 *   在有向图中，若 <v,w>∈E(G) ，表示从顶点v到顶点w有一条弧。 其中：v称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) 。
	 * 无向图(Undigraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是无序的，称图G是无向图。
	 *   在无向图中，若<v,w>∈E(G) ，有<w,v>∈E(G) ，即E(G)是对称，则用无序对(v,w) 表示v和w之间的一条边(Edge)，因此(v,w) 和(w,v)代表的是同一条边。
	 *
	 * 例1：设有有向图G1和无向图G2，形式化定义分别是：
	 G1=(V1 ，E1)
	 V1={a,b,c,d,e}
	 E1={<a,b>,<a,c>, <a,e>,<c,d>,<c,e> ,<d,a>,<d,b>,<e,d>}
	 G2=(V2 ，E2)
	 V2={a,b,c,d}
	 E2={(a,b), (a,c), (a,d), (b,d), (b,c), (c,d)}
	 *
	 * 完全无向图：对于无向图，若图中顶点数为n ，用e表示边的数目，则e ∈[0，n(n-1)/2] 。具有n(n-1)/2条边的无向图称为完全无向图。
	 完全无向图另外的定义是：
	 * 对于无向图G=(V，E)，若vi，vj ∈V ，当vi≠vj时，有(vi ,vj)∈E，即图中任意两个不同的顶点间都有一条无向边，这样的无向图称为完全无向图。
	 *
	 * 完全有向图：对于有向图，若图中顶点数为n ，用e表示弧的数目，则e∈[0，n(n-1)] 。具有n(n-1)条边的有向图称为完全有向图。
	 完全有向图另外的定义是：
	 * 对于有向图G=(V，E)，若vi，vj∈V ，当vi ≠vj时，有<vi ,vj>∈E∧<vj , vi >∈E ，即图中任意两个不同的顶点间都有一条弧，这样的有向图称为完全有向图。
	 *
	 * 有很少边或弧的图（e<n㏒n）的图称为稀疏图，反之称为稠密图。
	 * 权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。
	 *
	 * 子图和生成子图：设有图G=(V，E)和G’=(V’，E’)，若V’∈V且E’∈E ，则称图G’是G的子图；若V’=V且E’∈E，则称图G’是G的一个生成子图。
	 * 顶点的邻接(Adjacent)：对于无向图G=(V，E)，若边(v,w)∈E，则称顶点v和w 互为邻接点，即v和w相邻接。边(v,w)依附(incident)与顶点v和w 。
	 * 对于有向图G=(V ，E)，若有向弧<v,w>∈E，则称顶点v “邻接到”顶点w，顶点w “邻接自”顶点v ，弧<v,w> 与顶点v和w “相关联” 。
	 *
	 * 顶点的度、入度、出度：对于无向图G=(V，E)， vi∈V，图G中依附于vi的边的数目称为顶点vi的度(degree)，记为TD(vi)。
	 显然，在无向图中，所有顶点度的和是图中边的2倍。 即   ∑TD(vi)=2e      i=1, 2, …, n ，e为图的边数。
	 对有向图G=(V，E)，若vi ∈V ，图G中以vi作为起点的有向边(弧)的数目称为顶点vi的出度(Outdegree)，记为OD(vi) ；以vi作为终点的有向边(弧)的数目称为顶点vi的入度(Indegree)，记为ID(vi) 。顶点vi的出度与入度之和称为vi的度，记为TD(vi) 。即
	 TD(vi)=OD(vi)+ID(vi)
	 *
	 * 路径(Path)、路径长度、回路(Cycle) ：对无向图G=(V，E)，若从顶点vi经过若干条边能到达vj，称顶点vi和vj是连通的，又称顶点vi到vj有路径。
	 对有向图G=(V，E)，从顶点vi到vj有有向路径，指的是从顶点vi经过若干条有向边(弧)能到达vj。
	 或路径是图G中连接两顶点之间所经过的顶点序列。即
	 Path=vi0vi1…vim ，vij∈V且(vij-1, vij)∈E   j=1,2, …,m
	 或
	 Path=vi0vi1 …vim ，vij∈V且<vij-1, vij>∈E  j=1,2, …,m
	 路径上边或有向边(弧)的数目称为该路径的长度。
	 在一条路径中，若没有重复相同的顶点，该路径称为简单路径；第一个顶点和最后一个顶点相同的路径称为回路(环)；在一个回路中，若除第一个与最后一个顶点外，其余顶点不重复出现的回路称为简单回路(简单环)。
	 *
	 * 连通图、图的连通分量：对无向图G=(V，E)，若vi ，vj ∈V，vi和vj都是连通的，则称图G是连通图，否则称为非连通图。若G是非连通图，则极大的连通子图称为G的连通分量。
	 对有向图G=(V，E)，若vi ，vj ∈V，都有以vi为起点， vj 为终点以及以vj为起点，vi为终点的有向路径，称图G是强连通图，否则称为非强连通图。若G是非强连通图，则极大的强连通子图称为G的强连通分量。
	 “极大”的含义：指的是对子图再增加图G中的其它顶点，子图就不再连通。
	 生成树、生成森林：一个连通图(无向图)的生成树是一个极小连通子图，它含有图中全部n个顶点和只有足以构成一棵树的n-1条边，称为图的生成树。
	 关于无向图的生成树的几个结论：
	 ◆ 一棵有n个顶点的生成树有且仅有n-1条边；
	 ◆ 如果一个图有n个顶点和小于n-1条边，则是非连通图；
	 ◆ 如果多于n-1条边，则一定有环；
	 ◆ 有n-1条边的图不一定是生成树。
	
	 有向图的生成森林是这样一个子图，由若干棵有向树组成，含有图中全部顶点。
	 有向树是只有一个顶点的入度为0 ，其余顶点的入度均为1的有向图。
	
	 *
	 * 网：每个边(或弧)都附加一个权值的图，称为带权图。带权的连通图(包括弱连通的有向图)称为网或网络。网络是工程上常用的一个概念，用来表示一个工程或某种流程
	 */
	
	/**
	 * 图的存储结构
	 *
	 图的存储结构比较复杂，其复杂性主要表现在：
	 ◆ 任意顶点之间可能存在联系，无法以数据元素在存储区中的物理位置来表示元素之间的关系。
	 ◆ 图中顶点的度不一样，有的可能相差很大，若按度数最大的顶点设计结构，则会浪费很多存储单元，反之按每个顶点自己的度设计不同的结构，又会影响操作。
	 图的常用的存储结构有：邻接矩阵、邻接链表、十字链表、邻接多重表和边表。
	 */
	
	/*
	 邻接矩阵(数组)表示法
	
	 基本思想：对于有n个顶点的图，用一维数组vexs[n]存储顶点信息，用二维数组A[n][n]存储顶点之间关系的信息。该二维数组称为邻接矩阵。在邻接矩阵中，以顶点在vexs数组中的下标代表顶点，邻接矩阵中的元素A[i][j]存放的是顶点i到顶点j之间关系的信息。
	
	 1  无向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 无向无权图G=(V，E)有n(n≧1)个顶点，其邻接矩阵是n阶对称方阵。其元素的定义如下：
	            -- 1   若(vi , vj)∈E，即vi , vj邻接
	 A[i][j]=
	             -- 0   若(vi , vj)∉E，即vi , vj不邻接
	
	 (2)  带权图的邻接矩阵
	 无向带权图G=(V，E) 的邻接矩阵。其元素的定义如下：
	            -- Wij    若(vi , vj)∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	
	            -- ∞   若(vi , vj)∉E，即vi , vj不邻接时
	
	 (3)  无向图邻接矩阵的特性
	 ◆ 邻接矩阵是对称方阵
	 ◆ 对于顶点vi，其度数是第i行的非0元素的个数；
	 ◆ 无向图的边数是上(或下)三角形矩阵中非0元素个数。
	
	 2  有向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 若有向无权图G=(V，E)有n(n≧1)个顶点，则其邻接矩阵是n阶对称方阵。元素定义如下：
	            -- 1   若<vi, vj>∈E，从vi到vj有弧
	 A[i][j]=
	            -- 0   若<vi , vj>∉E  从vi到vj 没有弧
	
	 (2)  带权图的邻接矩阵
	 有向带权图G=(V，E)的邻接矩阵。其元素的定义如下：
	            -- wij    若<vi,vj>∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	            ∞   若<vi,vj>∉E，即vi , vj不邻接时
	
	 ⑶ 有向图邻接矩阵的特性
	 ◆ 对于顶点vi，第i行的非0元素的个数是其出度OD(vi)；第i列的非0元素的个数是其入度ID(vi) 。
	 ◆ 邻接矩阵中非0元素的个数就是图的弧的数目。
	
	 3  图的邻接矩阵的操作
	
	 图的邻接矩阵的实现比较容易，定义两个数组分别存储顶点信息(数据元素)和边或弧的信息(数据元素之间的关系) 。
	
	 */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	var ArcCell =
	/**
	 *
	 * @param {Number} adj
	 * @param {*} info
	 * @constructor
	 */
	function ArcCell(adj) {
	    var info = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ArcCell);
	
	    // 顶点类型。对于无权图，用1或0表示相邻否；对带权图，则为权值类型
	    this.adj = typeof adj === 'number' ? adj : Infinity;
	    // 该弧相关信息
	    this.info = info;
	};
	
	var AdjacencyMatrixGraph = function () {
	    /**
	     *
	     * @param {Array} vexs 顶点向量
	     * @param {Array | ArcCell} arcs 邻接矩阵
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	
	    function AdjacencyMatrixGraph() {
	        var vexs = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var arcs = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	        var vexnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var arcnum = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	        var kind = arguments.length <= 4 || arguments[4] === undefined ? DG : arguments[4];
	        (0, _classCallCheck3.default)(this, AdjacencyMatrixGraph);
	
	        // 顶点向量
	        this.vexs = vexs;
	        // 邻接矩阵
	        this.arcs = arcs;
	        // 图的当前顶点数
	        this.vexnum = vexnum;
	        // 图的当前弧数
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    (0, _createClass3.default)(AdjacencyMatrixGraph, [{
	        key: 'createGraph',
	        value: function createGraph() {
	            switch (this.kind) {
	                case DG:
	                    return createDG(this); // 构造有向图
	                case DN:
	                    return createDN(this); // 构造有向网
	                case UDG:
	                    return createUDG(this); // 构造无向图
	                case UDN:
	                    return createUDN(this); // 构造无向网
	                default:
	                    throw new Error('非有效的图类型');
	            }
	        }
	
	        /**
	         * 查找顶点
	         * @param {*} vp 顶点向量
	         * @returns {number}
	         */
	
	    }, {
	        key: 'locateVex',
	        value: function locateVex(vp) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.vexs[i] === vp) return i;
	            }
	
	            return -1;
	        }
	
	        /**
	         * 向图中增加顶点
	         * @param {*} vp 顶点向量
	         */
	
	    }, {
	        key: 'addVertex',
	        value: function addVertex(vp) {
	            if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	            var k = this.vexnum;
	            this.vexs[this.vexnum++] = vp;
	
	            var value = this.kind === DG || this.kind === UDG ? 0 : Infinity;
	            for (var j = 0; j < this.vexnum; ++j) {
	                this.arcs[j] = this.arcs[j] || [];
	                this.arcs[k] = this.arcs[k] || [];
	                this.arcs[j][k] = this.arcs[j][k] || new ArcCell();
	                this.arcs[k][j] = this.arcs[k][j] || new ArcCell();
	                this.arcs[j][k].adj = this.arcs[k][j].adj = value;
	            }
	        }
	
	        /**
	         * 向图中增加一条弧
	         * @param {*} vex1 顶点1向量
	         * @param {*} vex2 顶点2向量
	         * @param {ArcCell} arc
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'addArc',
	        value: function addArc(vex1, vex2, arc) {
	            arc = arc || new ArcCell(this.kind === DG || this.kind === UDG ? 1 : 'weight');
	            var k = this.locateVex(vex1);
	            var j = this.locateVex(vex2);
	
	            if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	            this.arcs[k][j].adj = arc.adj;
	            this.arcs[k][j].info = arc.info;
	            // 无向图或无向网
	            if (this.kind === UDG || this.kind === UDN) {
	                this.arcs[j][k].adj = arc.adj;
	                this.arcs[j][k].info = arc.info;
	            }
	
	            ++this.arcnum;
	
	            return true;
	        }
	
	        /**
	         * 删除顶点
	         * @param {String} vex 要删除的顶点
	         */
	
	    }, {
	        key: 'deleteVex',
	        value: function deleteVex(vex) {
	            var n = this.vexnum - 1;
	            var m = this.locateVex(vex);
	
	            if (m < 0) return false;
	
	            // 将待删除顶点交换到最后一个顶点
	            var temp = this.vexs[m];
	            this.vexs[m] = this.vexs[n];
	            this.vexs[n] = temp;
	
	            // 将边的关系随之交换
	            for (var i = 0; i <= n; ++i) {
	                this.arcs[i][m] = this.arcs[i][n];
	                this.arcs[m][i] = this.arcs[n][i];
	            }
	
	            this.arcs[m][m].adj = 0;
	            this.vexs.length = --this.vexnum;
	            return true;
	        }
	
	        /**
	         * 删除边(v, w)
	         * @param {String} v
	         * @param {String} w
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'deleteArc',
	        value: function deleteArc(v, w) {
	            var i = this.locateVex(v);
	            var j = this.locateVex(w);
	
	            if (i < 0 || j < 0) return false;
	
	            if (this.arcs[i][j].adj) {
	                this.arcs[i][j].adj = 0;
	                this.arcnum--;
	            }
	
	            return true;
	        }
	
	        // 判断一个邻接矩阵存储的有向图是否可传递
	
	    }, {
	        key: 'isPass',
	        value: function isPass() {
	            if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	            for (var x = 0; x < this.vexnum; ++x) {
	                for (var y = 0; y < this.vexnum; ++y) {
	                    if (this.arcs[x][y]) {
	                        for (var z = 0; z < this.vexnum; ++z) {
	                            if (z !== x && this.arcs[y][z] && !this.arcs[x][z]) return false;
	                        }
	                    }
	                }
	            }
	
	            return true;
	        }
	    }, {
	        key: 'firstAdjVex',
	        value: function firstAdjVex(v) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	            }
	
	            return -1;
	        }
	    }, {
	        key: 'nextAdjVex',
	        value: function nextAdjVex(v, w) {
	            for (var i = w + 1; i < this.vexnum; ++i) {
	                if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	            }
	
	            return -1;
	        }
	
	        // 对邻接矩阵图作递归式深度优先遍历
	
	    }, {
	        key: 'DFSTraverse',
	        value: function DFSTraverse(visitFn) {
	            var visited = [];
	            // 访问标志数组初始化
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i = 0; _i < this.vexnum; ++_i) {
	                if (!visited[_i]) dfs(this, _i);
	            }
	
	            function dfs(graph, vertex) {
	                visited[vertex] = true;
	                visitFn.call(graph, vertex);
	
	                for (var j = 0; j < graph.vexnum; ++j) {
	                    if (graph.arcs[vertex][j].adj !== 0 && graph.arcs[vertex][j].adj !== Infinity && !visited[j]) dfs(graph, j);
	                }
	            }
	        }
	
	        // 非递归
	
	    }, {
	        key: 'DFSTraverse_NonRecurse',
	        value: function DFSTraverse_NonRecurse(visitFn) {
	            var visited = [];
	            var stack = new _index2.default();
	            var me = this;
	            // 访问标志数组初始化
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i2 = 0; _i2 < this.vexnum; ++_i2) {
	                if (!visited[_i2]) {
	                    stack.push(_i2);
	                    visited[_i2] = true;
	                    visitFn.call(me, _i2);
	
	                    var vertex = void 0;
	                    while ((vertex = stack.peek()) != null) {
	                        for (var j = 0; j < this.vexnum; ++j) {
	                            if (this.arcs[vertex][j].adj !== 0 && this.arcs[vertex][j].adj !== Infinity && !visited[j]) {
	                                visitFn.call(me, j);
	                                visited[j] = true;
	                                stack.push(j);
	                            } else stack.pop();
	                        }
	                    }
	                }
	            }
	        }
	
	        // 对邻接矩阵图作广度优先遍历
	
	    }, {
	        key: 'BFSTraverse',
	        value: function BFSTraverse(visitFn) {
	            var visited = [];
	            var queue = new _Queue2.default();
	
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i3 = 0; _i3 < this.vexnum; ++_i3) {
	                if (!visited[_i3]) {
	                    visited[_i3] = true;
	                    visitFn.call(this, _i3);
	                    queue.enQueue(_i3);
	
	                    while (queue.rear) {
	                        var u = queue.deQueue();
	
	                        for (var j = 0; j < this.vexnum; ++j) {
	                            if (this.arcs[u][j].adj !== 0 && this.arcs[u][j].adj !== Infinity && !visited[j]) {
	                                visited[j] = true;
	                                visitFn.call(this, j);
	                                queue.enQueue(j);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'minSpanTree_PRIM',
	        value: function minSpanTree_PRIM(u) {
	            var closedge = [];
	
	            // 初始化
	            for (var j = 0; j < this.vexnum; ++j) {
	                closedge[j] = { adjvex: u, lowcost: +this.arcs[j][u].adj };
	            }
	            closedge[u].lowcost = 0;
	
	            var te = [];
	            // 选择其余this.vexnum - 1个顶点
	            for (var _j = 0; _j < this.vexnum - 1; ++_j) {
	                var min = Infinity;
	                var k = void 0;
	                for (var v = 0; v < this.vexnum; ++v) {
	                    if (closedge[v].lowcost !== 0 && closedge[v].lowcost < min) {
	                        min = closedge[v].lowcost;
	                        k = v;
	                    }
	                }
	
	                te[_j] = {
	                    vex1: closedge[k].adjvex,
	                    vex2: k,
	                    weight: closedge[k].lowcost
	                };
	                closedge[k].lowcost = 0;
	                for (var _v = 0; _v < this.vexnum; ++_v) {
	                    if (this.arcs[_v][k].adj < closedge[_v].lowcost) {
	                        closedge[_v].lowcost = this.arcs[_v][k].adj;
	                        closedge[_v].adjvex = k;
	                    }
	                }
	            }
	
	            return te;
	        }
	    }, {
	        key: 'minSpanTree_Kruskal',
	        value: function minSpanTree_Kruskal() {
	            var set = [];
	            var te = [];
	
	            for (var i = 0; i < this.vexnum; ++i) {
	                set[i] = i;
	            }var k = 0;
	            var min = Infinity;
	            var a = 0;
	            var b = 0;
	            while (k < this.vexnum - 1) {
	                for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                    for (var j = _i4 + 1; j < this.vexnum; ++j) {
	                        if (this.arcs[_i4][j].adj < min) {
	                            min = this.arcs[_i4][j].adj;
	                            a = _i4;
	                            b = j;
	                        }
	                    }
	                }
	
	                if (set[a] !== set[b]) {
	                    te[k++] = {
	                        vex1: a,
	                        vex2: b,
	                        weight: this.arcs[a][b].adj
	                    };
	
	                    for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                        if (set[_i5] === set[b] && _i5 !== b) set[_i5] = set[a];
	                    }
	                    set[b] = set[a];
	                }
	
	                min = this.arcs[a][b].adj = Infinity;
	            }
	
	            return te;
	        }
	
	        /**
	         * 用Dijkstra算法求有向网的v0顶点到其余顶点v的最短路径pre[v]及其带权长度dist[v]。
	         * 若pre[v][w]为true，则w是从v0到v当前求得最短路径上的顶点。
	         * final[v]为true当且仅当v∈S，即已经求得v0到v的最短路径
	         * @param v0
	         */
	
	    }, {
	        key: 'shortestPath_Dijkstra',
	        value: function shortestPath_Dijkstra(v0) {
	            var pre = [];
	            var dist = [];
	            var final = [];
	            var w = void 0,
	                v = void 0;
	
	            for (var _v2 = 0; _v2 < this.vexnum; ++_v2) {
	                final[_v2] = false;
	                dist[_v2] = this.arcs[v0][_v2].adj;
	                pre[_v2] = pre[_v2] || [];
	                // 设空路径
	                for (w = 0; w < this.vexnum; ++w) {
	                    pre[_v2][w] = false;
	                }if (dist[_v2] < Infinity) {
	                    pre[_v2][v0] = true;
	                    pre[_v2][_v2] = true;
	                }
	            }
	
	            // 初始化，v0顶点属于S集
	            dist[v0] = 0;
	            final[v0] = true;
	
	            // 开始主循环，每次求得v0到某个v顶点的最短路径，并加v到S集
	
	            // 其余的顶点
	            for (var i = 1; i < this.vexnum; ++i) {
	                var min = Infinity;
	                // 当前所指离v0顶点的最近距离
	                for (w = 0; w < this.vexnum; ++w) {
	                    // w顶点在V - S中
	                    // 且w顶点离v0顶点更近
	                    if (!final[w] && dist[w] < min) {
	                        v = w;
	                        min = dist[w];
	                    }
	                }
	
	                // 离v0顶点最近的v加入S集
	                final[v] = true;
	                // 更新当前最短路径及距离
	                for (w = 0; w < this.vexnum; ++w) {
	                    if (!final[w] && min + this.arcs[v][w].adj < dist[w]) {
	                        dist[w] = min + this.arcs[v][w].adj;
	                        pre[w] = pre[v];
	                        pre[w][w] = true;
	                    }
	                }
	            }
	
	            console.log(final);
	            console.log(pre);
	            console.log(dist);
	
	            return {
	                final: final,
	                pre: pre,
	                dist: dist
	            };
	        }
	    }, {
	        key: 'shortestPath_FLOYD',
	        value: function shortestPath_FLOYD() {
	            var a = [];
	            var path = [];
	
	            for (var j = 0; j < this.vexnum; ++j) {
	                a[j] = a[j] || [];
	                path[j] = path[j] || [];
	                for (var k = 0; k < this.vexnum; ++k) {
	                    if (j === k) a[j][k] = 0;else a[j][k] = this.arcs[j][k].adj;
	                    path[j][k] = -1;
	                }
	            }
	
	            for (var m = 0; m < this.vexnum; ++m) {
	                for (var _j2 = 0; _j2 < this.vexnum; ++_j2) {
	                    for (var _k = 0; _k < this.vexnum; ++_k) {
	                        if (a[_j2][m] + a[m][_k] < a[_j2][_k]) {
	                            a[_j2][_k] = a[_j2][m] + a[m][_k];
	                            path[_j2][_k] = m;
	                        }
	                    }
	                }
	            }
	
	            for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	                for (var _k2 = 0; _k2 < this.vexnum; ++_k2) {
	                    if (_j3 !== _k2) {
	                        console.log('%d到%d的最短路径为：', _j3, _k2);
	                        console.log('%d ', _j3);prn_pass(_j3, _k2);
	                        console.log('%d ', _k2);
	                        console.log('最短路径长度为： %d', a[_j3][_k2]);
	                    }
	                }
	            }
	
	            function prn_pass(j, k) {
	                if (path[j][k] !== -1) {
	                    prn_pass(j, path[j][k]);
	                    console.log(', %d', path[j][k]);
	                    prn_pass(path[j][k], k);
	                }
	            }
	        }
	    }]);
	    return AdjacencyMatrixGraph;
	}();
	
	exports.default = AdjacencyMatrixGraph;
	
	
	var createDG = createGraph(DG);
	var createDN = createGraph(DN);
	var createUDG = createGraph(UDG);
	var createUDN = createGraph(UDN);
	
	function createGraph(kind) {
	    var adj = void 0;
	    var setMatrixValue = void 0;
	
	    if (kind === 2 || kind === 4) {
	        adj = Infinity;
	        setMatrixValue = function setMatrixValue() {
	            return prompt('weight: ');
	        };
	    } else {
	        adj = 0;
	        setMatrixValue = function setMatrixValue() {
	            return 1;
	        };
	    }
	
	    return function (AdjacencyMatrixGraph) {
	        AdjacencyMatrixGraph.vexnum = parseInt(prompt('vexnum: '), 10);
	        AdjacencyMatrixGraph.arcnum = parseInt(prompt('arcnum: '), 10);
	        // incInfo为0则各弧不含其他信息
	        var incInfo = parseInt(prompt('incInfo: '), 10);
	
	        // 构造顶点向量
	        var i = void 0,
	            j = void 0;
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            AdjacencyMatrixGraph.vexs[i] = prompt('顶点向量vex: ');
	        } // 初始化邻接矩阵
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            for (j = 0; j < AdjacencyMatrixGraph.vexnum; ++j) {
	                AdjacencyMatrixGraph.arcs[i] = AdjacencyMatrixGraph.arcs[i] || [];
	                AdjacencyMatrixGraph.arcs[i][j] = new ArcCell(adj, null);
	            }
	        }
	
	        // 构造邻接矩阵
	        for (var k = 0; k < AdjacencyMatrixGraph.arcnum; ++k) {
	            // 输入一条边依附的顶点及权值
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            // 确定v1，v2在G中的位置
	            i = AdjacencyMatrixGraph.locateVex(v1);
	            j = AdjacencyMatrixGraph.locateVex(v2);
	
	            var w = setMatrixValue();
	            // 弧<v1, v2>的权值
	            AdjacencyMatrixGraph.arcs[i][j].adj = w;
	            if (incInfo) AdjacencyMatrixGraph.arcs[i][j].info = prompt('info: ');
	            if (kind === 3 || kind === 4) AdjacencyMatrixGraph.arcs[j][i] = AdjacencyMatrixGraph.arcs[i][j];
	        }
	    };
	}
	
	// 第一种创建图方法
	var vexs = ['a', 'b', 'c', 'd', 'e'];
	var arcs = [[{ "adj": Infinity, "info": null }, { "adj": "6", "info": null }, { "adj": "2", "info": null }, { "adj": Infinity, "info": null }, { "adj": Infinity, "info": null }], [{ "adj": "6", "info": null }, { "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": "4", "info": null }, { "adj": "3", "info": null }], [{ "adj": "2", "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "4", "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }, { "adj": Infinity, "info": null }]];
	var udn = new AdjacencyMatrixGraph(vexs, arcs, 5, 7, 4);
	
	// 第二种创建图方法
	var dn = new AdjacencyMatrixGraph([], [], 0, 0, 2);
	dn.addVertex('a');
	dn.addVertex('b');
	dn.addVertex('c');
	dn.addVertex('d');
	dn.addVertex('e');
	
	dn.addArc('a', 'b', {
	    adj: 6
	});
	dn.addArc('a', 'c', {
	    adj: 2
	});
	dn.addArc('c', 'b', {
	    adj: 3
	});
	dn.addArc('c', 'd', {
	    adj: 1
	});
	dn.addArc('d', 'b', {
	    adj: 4
	});
	dn.addArc('b', 'e', {
	    adj: 3
	});
	dn.addArc('d', 'e', {
	    adj: 5
	});
	
	console.log(dn);
	
	/*
	
	 // 第三种创建图方法
	 let g = new AdjacencyMatrixGraph();
	 g.kind = DN;
	 g.createGraph();
	 console.log(g);
	
	 */
	
	/*
	 图的遍历
	
	 图的遍历(Travering Graph)：从图的某一顶点出发，访遍图中的其余顶点，且每个顶点仅被访问一次。图的遍历算法是各种图的操作的基础。
	
	 ◆ 复杂性：图的任意顶点可能和其余的顶点相邻接，可能在访问了某个顶点后，沿某条路径搜索后又回到原顶点。
	 ◆ 解决办法：在遍历过程中记下已被访问过的顶点。设置一个辅助向量Visited[1…n](n为顶点数)，其初值为0，一旦访问了顶点vi后，使Visited[i]为1或为访问的次序号。
	 图的遍历算法有深度优先搜索算法和广度优先搜索算法。
	
	 深度优先搜索(Depth First Search--DFS)遍历类似树的先序遍历，是树的先序遍历的推广。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；然后找到vi的一个邻接顶点vi1 ；
	 ⑵：从vi1出发，深度优先搜索访问和vi1相邻接且未被访问的所有顶点；
	 ⑶：转⑴ ，直到和vi相邻接的所有顶点都被访问为止
	 ⑷ ：继续选取图中未被访问顶点vj作为起始顶点，转(1)，直到图中所有顶点都被访问为止。
	
	
	 广度优先搜索(Breadth First Search--BFS)遍历类似树的按层次遍历的过程。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；
	 ⑵：访问vi的所有相邻接且未被访问的所有顶点vi1，vi2，…，vim；
	 ⑶：以vi1，vi2， …，vim的次序，以vij(1≦j≦m)依此作为vi ，转⑴；
	 ⑷ ：继续选取图中未被访问顶点vk作为起始顶点，转⑴，直到图中所有顶点都被访问为止。
	
	 用广度优先搜索算法遍历图与深度优先搜索算法遍历图的唯一区别是邻接点搜索次序不同.
	 */
	
	console.log('DFSTraverse: udn');
	
	var g1 = new AdjacencyMatrixGraph([], [], 0, 0, UDG);
	g1.addVertex('v1');
	g1.addVertex('v3');
	g1.addVertex('v2');
	g1.addVertex('v4');
	g1.addVertex('v5');
	
	g1.addArc('v5', 'v4');
	g1.addArc('v3', 'v1');
	g1.addArc('v2', 'v1');
	g1.addArc('v3', 'v2');
	
	g1.DFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('DFSTraverse_NonRecurse: udn');
	g1.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('BFSTraverse: ');
	var bsfG = new AdjacencyMatrixGraph([], [], 0, 0, DG);
	bsfG.addVertex('v1');
	bsfG.addVertex('v2');
	bsfG.addVertex('v3');
	bsfG.addVertex('v4');
	bsfG.addVertex('v5');
	
	bsfG.addArc('v1', 'v4');
	bsfG.addArc('v1', 'v2');
	bsfG.addArc('v3', 'v5');
	bsfG.addArc('v3', 'v2');
	bsfG.addArc('v3', 'v1');
	bsfG.addArc('v4', 'v3');
	bsfG.addArc('v5', 'v4');
	
	bsfG.BFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	/*
	 最小生成树
	
	 如果连通图是一个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。
	
	 最小生成树(Minimum Spanning Tree) ：带权连通图中代价最小的生成树称为最小生成树。
	
	 最小生成树在实际中具有重要用途，如设计通信网。设图的顶点表示城市，边表示两个城市之间的通信线路，边的权值表示建造通信线路的费用。n个城市之间最多可以建n(n-1)/2条线路，如何选择其中的n-1条，使总的建造费用最低?
	
	 构造最小生成树的算法有许多，基本原则是：
	 ◆ 尽可能选取权值最小的边，但不能构成回路；
	 ◆ 选择n-1条边构成最小生成树。
	 以上的基本原则是基于MST的如下性质：
	 设G=(V，E)是一个带权连通图，U是顶点集V的一个非空子集。若u∈U ，v∈V-U，且(u, v)是U中顶点到V-U中顶点之间权值最小的边，则必存在一棵包含边(u, v)的最小生成树。
	
	 证明： 用反证法证明。
	 设图G的任何一棵最小生成树都不包含边(u,v)。设T是G的一棵生成树，则T是连通的，从u到v必有一条路径(u,…,v)，当将边(u,v)加入到T中时就构成了回路。则路径(u, …,v)中必有一条边(u’,v’) ，满足u’∈U ，v’∈V-U 。删去边(u’,v’) 便可消除回路，同时得到另一棵生成树T’。
	 由于(u,v)是U中顶点到V-U中顶点之间权值最小的边，故(u,v)的权值不会高于(u’,v’)的权值，T’的代价也不会高于T， T’是包含(u,v) 的一棵最小生成树，与假设矛盾。
	
	 */
	
	/*
	 普里姆(Prim)算法
	
	 适合边稠密的网
	
	 从连通网N=(U，E)中找最小生成树T=(U，TE) 。
	
	 1 算法思想
	 ⑴  若从顶点v0出发构造，U={v0}，TE={}；
	 ⑵ 先找权值最小的边(u，v)，其中u∈U且v∈V-U，并且子图不构成环，则U= U∪{v}，TE=TE∪{(u，v)} ；
	 ⑶ 重复⑵ ，直到U=V为止。则TE中必有n-1条边， T=(U，TE)就是最小生成树。
	
	 2.算法实现说明
	 为便于算法实现，设置一个一维数组closedge[n]，用来保存V- U中各顶点到U中顶点具有权值最小的边。
	 closedge[j].adjvex=k，表明边(vj, vk)是V-U中顶点vj到U中权值最小的边，而顶点vk是该边所依附的U中的顶点。 closedge[j].lowcost存放该边的权值。
	 假设从顶点vs开始构造最小生成树。初始时令：
	 Closedge[s].lowcost=0 ：表明顶点vs首先加入到U中；
	 Closedge[k].adjvex=s ，Closedge[k].lowcost=cost(k, s)
	 表示V-U中的各顶点到U中权值最小的边(k≠s) ，cost(k, s)表示边(vk, vs) 权值。
	
	 3.算法步骤
	 ⑴  从closedge中选择一条权值(不为0)最小的边(vk, vj) ，然后做：
	 ① 置closedge[k].lowcost为0 ，表示vk已加入到U中。
	 ②  根据新加入vk的更新closedge中每个元素：
	 vi∈V-U ，若cost(i, k)≦colsedge[i].lowcost，表明在U中新加入顶点vk后， (vi, vk)成为vi到U中权值最小的边，置：
	 Closedge[i].lowcost=cost(i, k)
	 Closedge[i].adjvex=k
	 ⑵  重复⑴n-1次就得到最小生成树。
	
	 算法分析：
	 设带权连通图有n个顶点，则算法的主要执行是二重循环： 求closedge中权值最小的边，频度为n-1； 修改closedge数组，频度为n 。因此，整个算法的时间复杂度是O(n2)，与边的数目无关。
	
	 */
	
	udn = new AdjacencyMatrixGraph([], [], 0, 0, 4);
	udn.addVertex('v1');
	udn.addVertex('v2');
	udn.addVertex('v3');
	udn.addVertex('v4');
	udn.addVertex('v5');
	udn.addVertex('v6');
	
	udn.addArc('v1', 'v2', { adj: 6 });
	udn.addArc('v1', 'v3', { adj: 1 });
	udn.addArc('v1', 'v4', { adj: 5 });
	udn.addArc('v2', 'v3', { adj: 5 });
	udn.addArc('v2', 'v5', { adj: 3 });
	udn.addArc('v3', 'v4', { adj: 5 });
	udn.addArc('v3', 'v5', { adj: 6 });
	udn.addArc('v3', 'v6', { adj: 4 });
	udn.addArc('v4', 'v6', { adj: 2 });
	udn.addArc('v5', 'v6', { adj: 6 });
	
	console.log('minSpanTree_PRIM: ');
	console.log(udn.minSpanTree_PRIM(0));
	
	/*
	 克鲁斯卡尔(Kruskal)算法
	
	 适合边稀疏的网
	
	 1 算法思想
	 设G=(V, E)是具有n个顶点的连通网，T=(U, TE)是其最小生成树。初值：U=V，TE={} 。
	 对G中的边按权值大小从小到大依次选取。
	 ⑴   选取权值最小的边(vi，vj)，若边(vi，vj)加入到TE后形成回路，则舍弃该边(边(vi，vj) ；否则，将该边并入到TE中，即TE=TE∪{(vi，vj)} 。
	 ⑵ 重复⑴ ，直到TE中包含有n-1条边为止。
	 如图7-22所提示。
	
	 2 算法实现说明
	 Kruskal算法实现的关键是：当一条边加入到TE的集合后，如何判断是否构成回路?
	 简单的解决方法是：定义一个一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。
	 ◆ 初值：Vset[i]=i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。
	 ◆ 当往T中增加一条边(vi，vj) 时，先检查Vset[i]和Vset[j]值：
	 ☆ 若Vset[i]=Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路；
	 ☆ 若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。
	 ◆ 加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号。
	
	 */
	
	console.log('minSpanTree_Kruskal: ');
	console.log(udn.minSpanTree_Kruskal());
	
	/*
	 最短路径
	
	 若用带权图表示交通网，图中顶点表示地点，边代表两地之间有直接道路，边上的权值表示路程(或所花费用或时间) 。从一个地方到另一个地方的路径长度表示该路径上各边的权值之和。问题：
	 ◆ 两地之间是否有通路?
	 ◆ 在有多条通路的情况下，哪条最短?
	 考虑到交通网的有向性，直接讨论的是带权有向图的最短路径问题，但解决问题的算法也适用于无向图。
	 将一个路径的起始顶点称为源点，最后一个顶点称为终点。
	
	
	 单源点最短路径
	
	 对于给定的有向图G=(V，E)及单个源点Vs，求Vs到G的其余各顶点的最短路径。
	 针对单源点的最短路径问题，Dijkstra提出了一种按路径长度递增次序产生最短路径的算法，即迪杰斯特拉(Dijkstra)算法。
	
	 1 基本思想
	 从图的给定源点到其它各个顶点之间客观上应存在一条最短路径，在这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。
	 即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，依此类推，直到求出长度最长的最短路径。
	
	 2 算法思想说明
	 设给定源点为Vs，S为已求得最短路径的终点集，开始时令S={Vs} 。当求得第一条最短路径(Vs ，Vi)后，S为{Vs，Vi} 。根据以下结论可求下一条最短路径。
	 设下一条最短路径终点为Vj ，则Vj只有：
	 ◆  源点到终点有直接的弧<Vs，Vj>；
	 ◆ 从Vs 出发到Vj 的这条最短路径所经过的所有中间顶点必定在S中。即只有这条最短路径的最后一条弧才是从S内某个顶点连接到S外的顶点Vj 。
	 若定义一个数组dist[n]，其每个dist[i]分量保存从Vs 出发中间只经过集合S中的顶点而到达Vi的所有路径中长度最小的路径长度值，则下一条最短路径的终点Vj必定是不在S中且值最小的顶点，即：
	 dist[i]=Min{ dist[k]| Vk∈V-S }
	 利用上述公式就可以依次找出下一条最短路径。
	
	 3  算法步骤
	 ① 令S={Vs} ，用带权的邻接矩阵表示有向图，对图中每个顶点Vi按以下原则置初值：
	 0    i =s
	 dist[i] =   Wsi     i≠s且<vs,vi>∈E， wsi为弧上的权值
	 ∞   i≠s且<vs,vi>不属于E
	 ② 选择一个顶点Vj ，使得：
	 dist[j]=Min{ dist[k]| Vk∈V-S }
	 Vj就是求得的下一条最短路径终点，将Vj 并入到S中，即S=S∪{Vj} 。
	 ③ 对V-S中的每个顶点Vk ，修改dist[k]，方法是：
	 若dist[j]+Wjk<dist[k]，则修改为：
	 dist[k]=dist[j]+Wjk (Vk∈V-S )
	 ④ 重复②，③，直到S=V为止。
	
	 4 算法实现
	 用带权的邻接矩阵表示有向图， 对Prim算法略加改动就成了Dijkstra算法，将Prim算法中求每个顶点Vk的lowcost值用dist[k]代替即可。
	 ◆  设数组pre[n]保存从Vs到其它顶点的最短路径。若pre[i]=k，表示从Vs 到Vi的最短路径中，Vi的前一个顶点是Vk，即最短路径序列是(Vs , …, Vk  , Vi) 。
	 ◆ 设数组final[n]，标识一个顶点是否已加入S中。
	
	 5  算法分析
	 Dijkstra算法的主要执行是：
	 ◆ 数组变量的初始化：时间复杂度是O(n) ；
	 ◆ 求最短路径的二重循环：时间复杂度是O(n2) ；
	 因此，整个算法的时间复杂度是O(n2) 。
	
	 */
	
	var dijTest = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('0', '1', { adj: 20 });
	dijTest.addArc('0', '4', { adj: 10 });
	dijTest.addArc('0', '2', { adj: 60 });
	dijTest.addArc('0', '5', { adj: 65 });
	dijTest.addArc('1', '2', { adj: 30 });
	dijTest.addArc('2', '3', { adj: 40 });
	dijTest.addArc('5', '2', { adj: 15 });
	dijTest.addArc('4', '5', { adj: 20 });
	dijTest.addArc('3', '4', { adj: 35 });
	dijTest.addArc('1', '3', { adj: 70 });
	
	dijTest.shortestPath_Dijkstra(0);
	
	/*
	 每一对顶点间的最短路径
	
	 用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。方法是：每次以一个不同的顶点为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，时间复杂度是O(n3) 。
	
	 弗罗伊德(Floyd)提出了另一个算法，其时间复杂度仍是O(n3) ， 但算法形式更为简明。
	
	 1 算法思想
	
	 设顶点集S(初值为空)，用数组A的每个元素A[i][j]保存从Vi只经过S中的顶点到达Vj的最短路径长度，其思想是：
	 ① 初始时令S={ } ， A[i][j]的赋初值方式是：
	 0    i =j时
	 A[i][j]=    Wij     i≠j且<vi,vj>∈E， wij为弧上的权值
	 ∞   i≠j且<vi,vj>不属于E
	 ② 将图中一个顶点Vk 加入到S中，修改A[i][j]的值，修改方法是：
	 A[i][j]=Min{A[i][j] , (A[i][k]+A[k][j]) }
	 原因： 从Vj只经过S中的顶点(Vk)到达Vj的路径长度可能比原来不经过Vk的路径更短。
	 ③ 重复②，直到G的所有顶点都加入到S中为止。
	
	 2 算法实现
	
	 ◆  定义二维数组Path[n][n](n为图的顶点数) ，元素Path[i][j]保存从Vi到Vj的最短路径所经过的顶点。
	 ◆ 若Path[i][j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径子序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i][k]和Path[k][j]的值再找到该路径上所经过的其它顶点，…依此类推。
	 ◆ 初始化为Path[i][j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i][j]变小时，令Path[i][j]=k。
	
	
	 */
	
	var floyd = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	floyd.addVertex('v0');
	floyd.addVertex('v1');
	floyd.addVertex('v2');
	floyd.addArc('v0', 'v2', { adj: 8 });
	floyd.addArc('v0', 'v1', { adj: 2 });
	floyd.addArc('v1', 'v2', { adj: 4 });
	floyd.addArc('v2', 'v0', { adj: 5 });
	
	floyd.shortestPath_FLOYD();
	
	// http://blog.csdn.net/hguisu/article/details/7719428
	// 添加《图的应用详解-数据结构》

/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = OLGraph;
	/*
	 十字链表法
	
	 十字链表(Orthogonal List)是有向图的另一种链式存储结构，是将有向图的正邻接表和逆邻接表结合起来得到的一种链表。
	
	 在这种结构中，每条弧的弧头结点和弧尾结点都存放在链表中，并将弧结点分别组织到以弧尾结点为头(顶点)结点和以弧头结点为头(顶点)结点的链表中。
	
	 ◆  data域：存储和顶点相关的信息；
	 ◆ 指针域firstin：指向以该顶点为弧头的第一条弧所对应的弧结点；
	 ◆ 指针域firstout：指向以该顶点为弧尾的第一条弧所对应的弧结点；
	 ◆ 尾域tailvex：指示弧尾顶点在图中的位置；
	 ◆ 头域headvex：指示弧头顶点在图中的位置；
	 ◆ 指针域hlink：指向弧头相同的下一条弧；
	 ◆ 指针域tlink：指向弧尾相同的下一条弧；
	 ◆ Info域：指向该弧的相关信息；
	
	 从这种存储结构图可以看出，从一个顶点结点的firstout出发，沿表结点的tlink指针构成了正邻接表的链表结构，而从一个顶点结点的firstin出发，沿表结点的hlink指针构成了逆邻接表的链表结构。
	
	 */
	
	/**
	 *
	 * @param {Number} headVex 弧的头顶点的位置
	 * @param {Number} tailVex 弧的尾顶点位置
	 * @param {ArcBox} hLink 弧头相同的弧的链域
	 * @param {ArcBox} tLink 弧尾相同的弧的链域
	 * @param {*} info
	 * @constructor
	 */
	function ArcBox(tailVex, headVex, hLink, tLink, info) {
	    this.headVex = headVex || 0;
	    this.tailVex = tailVex || 0;
	    this.hLink = hLink || null;
	    this.tLink = tLink || null;
	    this.info = info || null;
	}
	
	/**
	 *
	 * @param {*} data
	 * @param {ArcBox} firstIn 该顶点第一条入弧
	 * @param {ArcBox} firstOut 该顶点第一条出弧
	 * @constructor
	 */
	function OLVexNode(data, firstIn, firstOut) {
	    this.data = data || null;
	    this.firstIn = firstIn || null;
	    this.firstOut = firstOut || null;
	}
	
	/**
	 *
	 * @param {Array | OLVexNode} xList 表头向量
	 * @param {Number} vexnum 有向图的当前顶点数
	 * @param {Number} arcnum 有向图的当前弧数
	 * @constructor
	 */
	function OLGraph(xList, vexnum, arcnum) {
	    this.xList = xList || [];
	    this.vexnum = vexnum || 0;
	    this.arcnum = arcnum || 0;
	}
	OLGraph.prototype = {
	    constructor: OLGraph,
	
	    locateVex: function locateVex(vp) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.xList[i].data === vp) return i;
	        }
	
	        return -1;
	    },
	
	    // 删除顶点
	    deleteVertex: function deleteVertex(v) {
	        var m = this.locateVex(v);
	
	        if (m < 0) throw new Error('vertex not found!');
	
	        var n = this.vexnum;
	        var q, i, p;
	        // 删除所有以v为头的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是头链上的第一个结点
	            if (this.xList[i].firstIn.tailVex === m) {
	                q = this.xList[i].firstIn;
	                this.xList[i].firstIn = q.hLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstIn; p && p.hLink.tailVex !== m; p = p.hLink) {}
	                if (p) {
	                    q = p.hLink;
	                    p.hLink = q.hLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 删除所有以v为尾的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是尾链上的第一个结点
	            if (this.xList[i].firstOut.headVex === m) {
	                q = this.xList[i].firstOut;
	                this.xList[i].firstOut = q.tLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstOut; p && p.tLink.headVex !== m; p = p.tLink) {}
	                if (p) {
	                    q = p.tLink;
	                    p.tLink = q.tLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 顺次用结点m之后的顶点取代前一个顶点
	        for (i = m; i < n; ++i) {
	            // 修改表头向量
	            this.xList[i] = this.xList[i + 1];
	            for (p = this.xList[i].firstIn; p; p = p.hLink) {
	                p.headVex--;
	            }for (p = this.xList[i].firstOut; p; p = p.tLink) {
	                p.tailVex--;
	            }
	        }
	
	        this.vexnum--;
	        return true;
	    },
	
	    createDG: function createDG() {
	        this.vexnum = prompt('Vexnum: ');
	        this.arcnum = prompt('Arcnum: ');
	        // IncInfo为0则各弧不含其他信息
	        var incInfo = +prompt('IncInfo: ');
	
	        // 输入顶点值
	        for (var i = 0; i < this.vexnum; ++i) {
	            this.xList[i] = new OLVexNode(prompt('data: '), null, null);
	        }
	
	        for (var k = 0; k < this.arcnum; ++k) {
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            i = this.locateVex(v1);
	            var j = this.locateVex(v2);
	
	            if (i === -1 || j === -1) {
	                alert('无此顶点，请重新输入!');
	                k--;
	                continue;
	            }
	
	            var p = new ArcBox(i, j, this.xList[j].firstIn, this.xList[i].firstOut, incInfo && prompt('info: '));
	            this.xList[j].firstIn = this.xList[i].firstOut = p;
	        }
	    },
	
	    /**
	     * 求有向图的强连通分量
	     */
	    getSGraph: function getSGraph() {
	        var visited = [];
	        var finished = [];
	        var count = 0;
	
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第一次深度优先遍历建立finished数组
	        for (i = 0; i < this.vexnum; ++i) {
	            if (!visited[i]) dfs1(this, i);
	        }
	        // 清空visited数组
	        for (i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第二次逆向的深度优先遍历
	        for (var len = this.vexnum - 1; len >= 0; --len) {
	            i = finished[i];
	            if (!visited[i]) dfs2(this, i);
	        }
	
	        function dfs1(graph, v) {
	            visited[v] = true;
	            for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	                var w = p.headVex;
	                if (!visited[w]) dfs1(graph, w);
	            }
	            finished[++count] = v;
	        }
	
	        function dfs2(graph, v) {
	            visited[v] = true;
	            console.log('%d', v);
	            for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	                var w = p.tailVex;
	                if (!visited[w]) dfs2(graph, w);
	            }
	        }
	    }
	};
	
	//var g = new OLGraph();
	//g.createDG();
	//console.log(g);
	
	/*
	 有向图的强连通分量
	
	 对于有向图，在其每一个强连通分量中，任何两个顶点都是可达的。 V∈G，与V可相互到达的所有顶点就是包含V的强连通分量的所有顶点。
	
	 设从V可到达 (以V为起点的所有有向路径的终点)的顶点集合为T1(G)，而到达V (以V为终点的所有有向路径的起点)的顶点集合为T2(G)，则包含V的强连通分量的顶点集合是： T1(G)∩T2(G) 。
	
	 求有向图G的强连通分量的基本步骤是：
	 ⑴ 对G进行深度优先遍历，生成G的深度优先生成森林T。
	 ⑵  对森林T的顶点按中序遍历顺序进行编号。
	 ⑶  改变G中每一条弧的方向，构成一个新的有向图G’。
	 ⑷  按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。
	 ⑸  重复步骤⑷ ，直到G’中的所有顶点都被访问。
	
	 在算法实现时，建立一个数组in_order[n]存放深度优先生成森林的中序遍历序列。对每个顶点v，在调用DFS函数结束时，将顶点依次存放在数组in_order[n]中。图采用十字链表作为存储结构最合适。
	
	 */
	
	// todo to be tested
	OLGraph.prototype.connected_DG = function () {
	    var visited = [];
	    var in_order = [];
	    var count = 0;
	
	    for (var i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图正向遍历
	    for (i = 0; i < this.vexnum; ++i) {
	        if (!visited[i]) {
	            dfs(this, i, in_order);
	        }
	    }
	
	    for (i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图逆向遍历
	    var k = 1;
	    for (var j = this.vexnum - 1; j >= 0; --j) {
	        var v = in_order[j];
	        if (!visited[v]) {
	            console.log('第' + k++ + '个连通分量顶点');
	            rev_dfs(this, v);
	        }
	    }
	
	    function dfs(graph, v) {
	        visited[v] = true;
	
	        for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	            if (!visited[p.headVex]) {
	                dfs(graph, p.headVex);
	            }
	        }
	
	        in_order[count++] = v;
	    }
	
	    function rev_dfs(graph, v) {
	        visited[v] = true;
	        console.log('顶点：' + v);
	
	        for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	            if (!visited[p.tailVex]) {
	                rev_dfs(graph, p.tailVex);
	            }
	        }
	    }
	};

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(16);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _iterator2 = __webpack_require__(18);
	
	var _iterator3 = _interopRequireDefault(_iterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _DoubleLinkedList = __webpack_require__(67);
	
	var _DoubleLinkedList2 = _interopRequireDefault(_DoubleLinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIMIT = 20; /**
	                 * LRU( Least recently used )
	                 */
	
	var LRUCache = function () {
	    function LRUCache(sqList) {
	        var limit = arguments.length <= 1 || arguments[1] === undefined ? LIMIT : arguments[1];
	        (0, _classCallCheck3.default)(this, LRUCache);
	
	        this.limit = limit;
	        sqList = sqList && sqList.length ? sqList && sqList.length.slice(0, this.limit) : [];
	        this.__cache = new _DoubleLinkedList2.default(sqList, function (a, b) {
	            return a.key === b.key;
	        });
	    }
	
	    (0, _createClass3.default)(LRUCache, [{
	        key: _iterator3.default,
	        value: function value() {
	            return (0, _getIterator3.default)(this.__cache);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            return this.__cache.remove({ key: key });
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            return this.___cache.clear();
	        }
	    }, {
	        key: 'get',
	        value: function get(key) {
	            var index = this.__cache.indexOf({ key: key });
	
	            if (index >= 0) {
	                var data = this.__cache.findByIndex(index);
	                this.__cache.remove(data);
	                this.__cache.unshift(data);
	
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'add',
	        value: function add(key, value) {
	            var data = this.get(key);
	            if (data) {
	                data.value = value;
	            } else {
	                if (this.size === this.limit) {
	                    this.__cache.pop();
	                }
	
	                this.__cache.unshift({
	                    key: key,
	                    value: value
	                });
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var arr = [];
	            this.__cache.forEach(function (data) {
	                arr.push(data.key + ':' + data.value);
	            });
	
	            return arr.join(' > ');
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            return this.__cache.toJSON();
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.__cache.size;
	        }
	    }]);
	    return LRUCache;
	}();
	
	exports.default = LRUCache;
	
	
	console.log('LRUCache');
	
	var a = new LRUCache([], 3);
	a.add('adam', 29);
	a.add('john', 26);
	a.add('angela', 24);
	console.log(a + '');
	a.get('john');
	console.log(a + '');
	a.add('zorro', 141);
	console.log(a + '');
	console.log(a.toJSON());
	
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;
	
	try {
	    for (var _iterator = (0, _getIterator3.default)(a), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var item = _step.value;
	
	        console.log(item);
	    }
	} catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	        }
	    } finally {
	        if (_didIteratorError) {
	            throw _iteratorError;
	        }
	    }
	}
	
	a.remove('zorro');
	a.remove('john');
	a.remove('angela');
	console.log(a + '');
	
	// test case:
	// Input:
	// 2,[add(2,1),add(1,1),add(2,3),add(4,1),get(1),get(2)]
	// Expected:
	// [ false, { key: 2, value: 3 } ]
	console.log('add');
	
	var b = new LRUCache([], 2);
	b.add(2, 1);
	b.add(1, 1);
	b.add(2, 3);
	b.add(4, 1);
	console.log([b.get(1), b.get(2)]);
	
	console.log('~add');
	
	console.log('LRUCacheEnd');

/***/ },
/* 147 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.union = union;
	exports.mergeList = mergeList;
	exports.insert = insert;
	exports.del = del;
	exports.listComp = listComp;
	exports.reverse = reverse;
	exports.intersect = intersect;
	exports.intersect_true = intersect_true;
	exports.intersect_delete = intersect_delete;
	/**
	 * 线性表
	 */
	
	// 线性表的类型定义
	// 将所有在数组b中但不在数组a的数据元素插入到a中
	
	var a = [1, 2, 3, 4, 5];
	var b = [1, 3, 5, 7, 9];
	
	function union(a, b) {
	    var elem, equal;
	
	    for (var i = 0, bLen = b.length; i < bLen; i++) {
	        elem = b[i];
	        equal = false;
	
	        for (var j = 0, aLen = a.length; j < aLen; j++) {
	            if (elem === a[j]) {
	                equal = true;
	                break;
	            }
	        }
	
	        if (!equal) a.push(elem);
	    }
	}
	
	union(a, b);
	console.log(a);
	// [1, 2, 3, 4, 5, 7, 9]
	
	// 时间复杂度：O(aLen * bLen)
	
	// 已知数组a和数组b中的数据元素按值非递减排列
	// 归并a和b得到新的数组c，c的数据元素也按值非递减排列
	var a = [3, 5, 8, 11];
	var b = [2, 6, 8, 9, 11, 15, 20];
	
	function mergeList(a, b) {
	    var c = [],
	        aElem,
	        bElem;
	    var i = 0,
	        j = 0,
	        k = 0;
	    var aLen = a.length;
	    var bLen = b.length;
	
	    while (i < aLen && j < bLen) {
	        aElem = a[i];
	        bElem = b[j];
	
	        if (aElem < bElem) {
	            c[k++] = aElem;
	            i++;
	        } else {
	            c[k++] = bElem;
	            j++;
	        }
	    }
	
	    while (i < aLen) {
	        c[k++] = a[i++];
	    }
	
	    while (j < bLen) {
	        c[k++] = b[j++];
	    }
	
	    return c;
	}
	
	var c = mergeList(a, b);
	console.log(c);
	// [2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20]
	
	// 时间复杂度： O(aLen + bLen)
	
	// 线性表的顺序表示和实现
	// 使用伪数组模拟线性表插入操作的前后数据元素在存储空间中的位置变化
	var a = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 };
	a.length = 6;
	
	function insert(a, i, elem) {
	    if (!elem) return;
	
	    var len = a.length;
	    if (i >= len) {
	        while (len < i) {
	            a[len++] = undefined;
	            a.length++;
	        }
	        a[i] = elem;
	    } else {
	        while (len > i) {
	            a[len--] = a[len];
	        }
	        a[i] = elem;
	    }
	    a.length++;
	}
	
	insert(a, 3, 8);
	insert(a, 10, 10);
	console.log(a);
	
	// 使用伪数组模拟线性表删除操作的前后数据元素在存储空间中的位置变化
	
	function del(a, i) {
	    var temp = a[i];
	    var j = i + 1;
	    var len = a.length;
	
	    while (j < len) {
	        a[j - 1] = a[j++];
	    }
	    a.length--;
	    delete a[len - 1];
	
	    return temp;
	}
	
	del(a, 3);
	console.log(a);
	del(a, 10);
	console.log(a);
	
	// 时间复杂度： O(a.length)
	
	// 比较字符表A和B，并用返回值表示结果，值为1，表示A>B，值为-1，表示A<B，值为0，表示A=B
	function listComp(aList, bList) {
	    for (var i = 0; i < aList.length && i < bList.length; i++) {
	        if (aList[i] !== bList[i]) return aList[i] > bList[i] ? 1 : -1;
	    }
	
	    if (aList.length == bList.length) return 0;
	
	    return aList.length > bList.length ? 1 : -1;
	}
	
	function reverse(list) {
	    for (var i = 0, j = list.length - 1; i <= j; i++, j--) {
	        var temp = list[i];
	        list[i] = list[j];
	        list[j] = temp;
	    }
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(aList, bList) {
	    var cList = [];
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (aList[i] && bList[j]) {
	        if (aList[i] < bList[j]) i++;else if (aList[i] > bList[j]) j++;else {
	            cList[k++] = aList[i];
	            i++;
	            j++;
	        }
	    }
	
	    return cList;
	}
	
	console.log(intersect([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(a, b) {
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (a[i] && b[j]) {
	        if (a[i] < b[j]) i++;else if (a[i] > b[j]) j++;else {
	            a[k++] = a[i];
	            i++;
	            j++;
	        }
	    }
	
	    while (a[k]) {
	        a.splice(k, 1);
	    }return a;
	}
	
	console.log(intersect_true([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// a，b，c的元素均是非递减排列
	// 求a数组中非b数组和c数组的交集的元素。
	function intersect_delete(a, b, c) {
	    var i = 0,
	        j = 0,
	        k = 0,
	        m = 0;
	
	    while (i < a.length && j < b.length && k < c.length) {
	        if (b[j] < c[k]) j++;else if (b[j] > c[k]) k++;else {
	            // 找到了相同元素same
	            var same = b[j];
	
	            // j，k后移到新的元素
	            while (b[j] === same) {
	                j++;
	            }while (c[k] === same) {
	                k++;
	            } // 需保留的元素移动到新位置
	            while (i < a.length && a[i] < same) {
	                a[m++] = a[i++];
	            } // 跳过相同的元素
	            while (i < a.length && a[i] === same) {
	                i++;
	            }
	        }
	    }
	
	    // a的剩余元素重新存储
	    while (i < a.length) {
	        a[m++] = a[i++];
	    }a.length = m;
	
	    return a;
	}
	
	console.log(intersect_delete([1, 2, 3, 4, 5, 6, 9], [1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by ldp on 2015/1/19.
	 */
	
	// 循环队列
	
	var CycleQueue = function () {
	    function CycleQueue() {
	        var maxsize = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
	        (0, _classCallCheck3.default)(this, CycleQueue);
	
	        this.base = {};
	        this.front = this.rear = 0;
	        this.MAXQSIZE = maxsize;
	    }
	
	    (0, _createClass3.default)(CycleQueue, [{
	        key: 'enQueue',
	        value: function enQueue(data) {
	            if ((this.rear + 1) % this.MAXQSIZE === 0) throw new Error('cycleQueue is already full!');
	
	            this.base[this.rear] = data;
	            this.rear = (this.rear + 1) % this.MAXQSIZE;
	        }
	    }, {
	        key: 'deQueue',
	        value: function deQueue() {
	            if (this.front === this.rear) throw new Error('cycleQueue is already empty');
	
	            var elem = this.base[this.front];
	            this.front = (this.front + 1) % this.MAXQSIZE;
	
	            return elem;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.base = {};
	            this.front = this.rear = 0;
	        }
	    }, {
	        key: 'peekAt',
	        value: function peekAt() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	            index = (index + this.MAXQSIZE) % this.MAXQSIZE;
	
	            return this.base[index + this.front] || null;
	        }
	    }, {
	        key: 'getHead',
	        value: function getHead() {
	            var elem = this.base[this.front];
	            return elem ? elem : null;
	        }
	    }, {
	        key: 'queueTraverse',
	        value: function queueTraverse(iterator) {
	            for (var i = this.front, len = this.rear = this.front; i < len; i++) {
	                if (iterator(this.base[i], i)) break;
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var base = [].slice.call(this.base);
	
	            return base.slice(this.front, this.rear - this.front);
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return (this.rear - this.front + this.MAXQSIZE) % this.MAXQSIZE;
	        }
	    }]);
	    return CycleQueue;
	}();
	
	exports.default = CycleQueue;
	
	
	var queue = new CycleQueue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/2/26.
	 */
	
	/*
	优先队列(priority queue)
	
	普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。
	
	优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.
	
	
	入队操作
	①：完全二叉树的构建操作是“从上到下，从左到右”的形式，所以入队的节点是放在数组的最后，也就是树中叶子层的有序最右边空位。
	②：当节点插入到最后时，有可能破坏了堆的性质，此时我们要进行“上滤操作”，当然时间复杂度为O(lgN)。
	
	出队操作
	出队操作时，我们采取的方案是：弹出堆顶元素，然后将叶子层中的最右子节点赋给堆顶，同样这时也会可能存在破坏堆的性质，最后我们要被迫进行下滤操作。
	 */
	
	// 用堆实现优先队列
	
	var PriorityQueue = function () {
	    function PriorityQueue() {
	        (0, _classCallCheck3.default)(this, PriorityQueue);
	
	        this.heap = [];
	    }
	
	    (0, _createClass3.default)(PriorityQueue, [{
	        key: 'enQueue',
	        value: function enQueue(value) {
	            var priority = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	            if (typeof value === 'undefined') throw new Error('argument required');
	
	            // 将当前节点追加到堆尾
	            this.heap.push({
	                value: value,
	                priority: priority
	            });
	
	            // 如果只有一个节点，则不需要进行筛选操作
	            if (this.heap.length === 1) return;
	
	            // 获取最后一个非叶子节点，并进行堆调整
	            upHeapAdjust(this.heap, (this.heap.length >> 1) - 1);
	        }
	    }, {
	        key: 'deQueue',
	        value: function deQueue() {
	            if (!this.heap.length) return null;
	
	            var heap = this.heap;
	            // 出队列操作，弹出数据头元素
	            var data = heap[0];
	            // 用尾元素填充头元素
	            heap[0] = heap[heap.length - 1];
	            // 删除尾节点
	            heap.pop();
	
	            //然后从根节点下滤堆
	            downHeapAdjust(heap, 0);
	
	            return data;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.heap = [];
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.heap.length;
	        }
	    }]);
	    return PriorityQueue;
	}();
	
	// 对堆进行上滤操作，使得满足堆性质
	
	
	exports.default = PriorityQueue;
	function upHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (parent >= 0) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        // 如果parent节点小于它的某个子节点的话，此时筛选操作
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            // 继续进行更上一层的过滤
	            parent = Math.ceil(parent / 2) - 1;
	        } else break;
	    }
	}
	
	// 对堆进行下滤操作，使得满足堆性质
	function downHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (2 * parent + 1 < len) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            parent = max;
	        } else break;
	    }
	}
	
	var test = new PriorityQueue();
	test.enQueue(8, 5);
	test.enQueue(7, 2);
	test.enQueue(6, 1);
	test.enQueue(5, 4);
	test.enQueue(4, 7);
	test.enQueue(3, 3);
	test.enQueue(2, 8);
	test.enQueue(1, 10);
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());

/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * AVL TREE Class
	 *
	 * @author Brice Chevalier
	 *
	 *
	 * @desc
	 *
	 *    Method                Time Complexity
	 *    ___________________________________
	 *
	 *    add                    O(log2(n))
	 *    remove                O(log2(n))
	 *    getFirst            O(1)
	 *    getLast                O(1)
	 *    getCount            O(1)
	 *    apply                O(n)
	 *    clear                O(n)
	 *
	 *    Memory Complexity in O(n)
	 */
	
	function Node(obj) {
	    this.object = obj;
	    this.height = 1;
	    this.left = null;
	    this.right = null;
	    this.previous = null;
	    this.next = null;
	    this.parent = null;
	}
	
	function AvlTree() {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	}
	AvlTree.cmp = function (a, b) {
	    if (a > b) return 1;else if (a < b) return -1;else return 0;
	};
	
	AvlTree.prototype._addLeft = function (node, parent) {
	    node.previous = parent.previous;
	    node.next = parent;
	    node.parent = parent;
	
	    parent.left = node;
	    parent.previous = node;
	
	    if (node.previous) {
	        node.previous.next = node;
	    }
	
	    if (parent === this.first) {
	        this.first = node;
	    }
	};
	
	AvlTree.prototype._addRight = function (node, parent) {
	    node.previous = parent;
	    node.next = parent.next;
	    node.parent = parent;
	
	    parent.right = node;
	    parent.next = node;
	
	    if (node.next) {
	        node.next.previous = node;
	    }
	
	    if (parent === this.last) {
	        this.last = node;
	    }
	};
	
	AvlTree.prototype.add = function (obj) {
	    this.count += 1;
	    var newNode = new Node(obj);
	
	    if (this.root === null) {
	        this.root = newNode;
	        this.first = this.root;
	        this.last = this.root;
	        return newNode;
	    }
	
	    var current = this.root;
	
	    while (true) {
	
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            // Adding to the left
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else {
	                current = current.left;
	            }
	        } else if (cmp > 0) {
	            // Adding to the right
	            if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                current = current.right;
	            }
	        } else {
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                if (current.right.height < current.left.height) {
	                    current = current.right;
	                } else {
	                    current = current.left;
	                }
	            }
	        }
	    }
	
	    this._balance(newNode.parent);
	
	    return newNode;
	};
	
	AvlTree.prototype._balanceLeftRight = function (node) {
	    var left = node.left;
	    var a = left.left;
	    var b = left.right.left;
	
	    left.right.left = left;
	    node.left = left.right;
	    left = node.left;
	    left.parent = node;
	
	    var leftLeft = left.left;
	    leftLeft.parent = left;
	    leftLeft.left = a;
	    leftLeft.right = b;
	    if (a !== null) {
	        a.parent = leftLeft;
	    }
	    if (b !== null) {
	        b.parent = leftLeft;
	    }
	
	    left.height = leftLeft.height + 1;
	};
	
	AvlTree.prototype._balanceLeftLeft = function (node) {
	    var left = node.left;
	    var c = left.right;
	
	    if (node === this.root) {
	        this.root = left;
	    } else {
	        if (node.parent.right === node) {
	            node.parent.right = left;
	        } else {
	            node.parent.left = left;
	        }
	    }
	
	    left.right = node;
	    left.parent = node.parent;
	    node.parent = left;
	    node.left = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balanceRightLeft = function (node) {
	    var right = node.right;
	    var a = right.right;
	    var b = right.left.right;
	
	    right.left.right = right;
	    node.right = right.left;
	    right = node.right;
	    right.parent = node;
	
	    var rightRight = right.right;
	    rightRight.parent = right;
	    rightRight.right = a;
	    rightRight.left = b;
	    if (a !== null) {
	        a.parent = rightRight;
	    }
	    if (b !== null) {
	        b.parent = rightRight;
	    }
	
	    node.right.height = rightRight.height + 1;
	};
	
	AvlTree.prototype._balanceRightRight = function (node) {
	    var right = node.right;
	    var c = right.left;
	
	    if (node === this.root) {
	        this.root = right;
	    } else {
	        if (node.parent.left === node) {
	            node.parent.left = right;
	        } else {
	            node.parent.right = right;
	        }
	    }
	
	    right.left = node;
	    right.parent = node.parent;
	    node.parent = right;
	    node.right = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balance = function (node) {
	    // Balancing the tree
	    var current = node;
	    while (current !== null) {
	        var leftHeight = current.left === null ? 0 : current.left.height;
	        var rightHeight = current.right === null ? 0 : current.right.height;
	        var newHeight = 1 + Math.max(leftHeight, rightHeight);
	
	        if (newHeight > current.height) {
	            current.height = newHeight;
	            if (leftHeight - rightHeight > 1) {
	
	                // Left case
	                if (current.left.right !== null && (current.left.left === null || current.left.left.height < current.left.right.height)) {
	                    // Left Right Case
	                    this._balanceLeftRight(current);
	                }
	
	                // Left Left Case
	                this._balanceLeftLeft(current);
	
	                // The tree has been balanced
	                break;
	            } else if (rightHeight - leftHeight > 1) {
	
	                // Right case
	                if (current.right.left !== null && (current.right.right === null || current.right.right.height < current.right.left.height)) {
	                    // Right Left Case
	                    this._balanceRightLeft(current);
	                }
	
	                // Right Right Case
	                this._balanceRightRight(current);
	
	                // The tree has been balanced
	                break;
	            } else {
	                // Node is balanced
	                current = current.parent;
	            }
	        } else {
	            break;
	        }
	    }
	};
	
	AvlTree.prototype.remove = function (obj) {
	    this._remove(obj, this.root);
	};
	
	AvlTree.prototype._remove = function (obj, node) {
	    var current = node;
	
	    while (current !== null) {
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            current = current.left;
	        } else if (cmp > 0) {
	            current = current.right;
	        } else {
	            if (obj === current.object) {
	
	                // Node removal
	                this.count -= 1;
	
	                if (current.previous === null) {
	                    this.first = current.next;
	                } else {
	                    current.previous.next = current.next;
	                }
	                if (current.next === null) {
	                    this.last = current.previous;
	                } else {
	                    current.next.previous = current.previous;
	                }
	
	                // Replacing the node by the smallest element greater than it
	                var parent = current.parent;
	                var left = current.left;
	                var right = current.right;
	
	                if (current.right === null) {
	                    if (parent === null) {
	                        this.root = left;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = left;
	                        } else {
	                            parent.left = left;
	                        }
	                    }
	
	                    if (left !== null) {
	                        left.parent = parent;
	                    }
	
	                    this._balance(parent);
	                    return 1;
	                }
	
	                var replacement = current.right;
	                var balanceFrom;
	
	                if (replacement.left === null) {
	                    balanceFrom = replacement;
	
	                    if (left !== null) {
	                        left.parent = replacement;
	                    }
	                    replacement.left = left;
	
	                    if (parent === null) {
	                        this.root = replacement;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = replacement;
	                        } else {
	                            parent.left = replacement;
	                        }
	                    }
	                    replacement.parent = parent;
	
	                    this._balance(balanceFrom);
	
	                    return 1;
	                }
	
	                replacement = replacement.left;
	                while (replacement.left !== null) {
	                    replacement = replacement.left;
	                }
	
	                if (replacement.right !== null) {
	                    replacement.right.parent = replacement.parent;
	                }
	                replacement.parent.left = replacement.right;
	
	                if (right !== null) {
	                    right.parent = replacement;
	                }
	                replacement.right = right;
	
	                balanceFrom = replacement.parent;
	
	                if (left !== null) {
	                    left.parent = replacement;
	                }
	                replacement.left = left;
	
	                if (parent === null) {
	                    this.root = replacement;
	                } else {
	                    if (parent.right === current) {
	                        parent.right = replacement;
	                    } else {
	                        parent.left = replacement;
	                    }
	                }
	                replacement.parent = parent;
	
	                this._balance(balanceFrom);
	
	                return 1;
	            } else {
	                if (!this._remove(obj, current.left)) {
	                    this._remove(obj, current.right);
	                }
	            }
	        }
	    }
	
	    return 0;
	};
	
	AvlTree.prototype.removeByRef = function (node) {
	    // Node removal
	    this.count -= 1;
	
	    if (node.previous === null) {
	        this.first = node.next;
	    } else {
	        node.previous.next = node.next;
	    }
	    if (node.next === null) {
	        this.last = node.previous;
	    } else {
	        node.next.previous = node.previous;
	    }
	
	    // Replacing the node by the smallest element greater than it
	    var parent = node.parent;
	    var left = node.left;
	    var right = node.right;
	
	    if (node.right === null) {
	        if (parent === null) {
	            this.root = left;
	        } else {
	            if (parent.right === node) {
	                parent.right = left;
	            } else {
	                parent.left = left;
	            }
	        }
	
	        if (left !== null) {
	            left.parent = parent;
	        }
	
	        this._balance(parent);
	        return 1;
	    }
	
	    var replacement = node.right;
	    var balanceFrom;
	
	    if (replacement.left === null) {
	        balanceFrom = replacement;
	
	        if (left !== null) {
	            left.parent = replacement;
	        }
	        replacement.left = left;
	
	        if (parent === null) {
	            this.root = replacement;
	        } else {
	            if (parent.right === node) {
	                parent.right = replacement;
	            } else {
	                parent.left = replacement;
	            }
	        }
	        replacement.parent = parent;
	
	        this._balance(balanceFrom);
	
	        return 1;
	    }
	
	    replacement = replacement.left;
	    while (replacement.left !== null) {
	        replacement = replacement.left;
	    }
	
	    if (replacement.right !== null) {
	        replacement.right.parent = replacement.parent;
	    }
	    replacement.parent.left = replacement.right;
	
	    if (right !== null) {
	        right.parent = replacement;
	    }
	    replacement.right = right;
	
	    balanceFrom = replacement.parent;
	
	    if (left !== null) {
	        left.parent = replacement;
	    }
	    replacement.left = left;
	
	    if (parent === null) {
	        this.root = replacement;
	    } else {
	        if (parent.right === node) {
	            parent.right = replacement;
	        } else {
	            parent.left = replacement;
	        }
	    }
	    replacement.parent = parent;
	
	    this._balance(balanceFrom);
	
	    return 1;
	};
	
	AvlTree.prototype.getFirst = function () {
	    return this.first;
	};
	
	AvlTree.prototype.getLast = function () {
	    return this.last;
	};
	
	AvlTree.prototype.getHeight = function () {
	    return this.root.height;
	};
	
	AvlTree.prototype.getRoot = function () {
	    return this.root;
	};
	
	AvlTree.prototype.getCount = function () {
	    return this.count;
	};
	
	AvlTree.prototype.forEach = function (processingFunc, params) {
	    for (var current = this.first; current; current = current.next) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.forEachReverse = function (processingFunc, params) {
	    for (var current = this.last; current; current = current.previous) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.clear = function () {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	};
	
	module.exports = AvlTree;
	
	console.log('\nAVL tree insert2: ');
	var test = new AvlTree();
	test.add(3);
	test.add(14);
	test.add(25);
	test.add(81);
	test.add(44);
	
	/*
	 14
	 /    \
	 3       44
	 /   \
	 25     81
	 */
	
	console.log('remove_Recursive 2:');
	
	test.remove(81);
	test.remove(3);
	test.remove(14);
	test.remove(25);
	test.remove(44);
	
	var str = 'cknobfjtlpqaegrmdhs';
	//var str = 'ckbfjlaegmdh';
	
	test = new AvlTree();
	for (var i = 0; i < str.length; ++i) {
	    test.add(str[i]);
	}
	
	test.remove('e');
	test.remove('h');
	test.remove('b');
	test.remove('l');
	test.remove('f');
	test.remove('j');
	test.remove('g');
	test.remove('d');
	test.remove('k');
	test.remove('a');
	test.remove('m');
	test.remove('n');
	test.remove('o');
	test.remove('p');
	test.remove('q');
	test.remove('r');
	test.remove('s');
	test.remove('t');
	test.remove('c');

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	var _create = __webpack_require__(49);
	
	var _create2 = _interopRequireDefault(_create);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 MIT License
	 Copyright (c) 2012 Santanu Basu
	 Copyright (c) 2013 Daniel Wirtz
	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:
	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.
	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	// Based on Santanu Basu's BPlusJS
	// https://github.com/santanubasu/BPlusJS
	// Modified for stand-alone use
	
	/**
	 * @license BTree.js
	 * Released under the MIT License
	 * see: https://github.com/dcodeIO/BTree.js for details
	 */
	(function (global) {
	
	    function isDefined(v) {
	        return typeof v != 'undefined';
	    }
	
	    var Node = function Node(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.data = [];
	    };
	
	    Node.prototype.getLeftPeer = function () {
	        return this.leftPeer;
	    };
	
	    Node.prototype.setLeftPeer = function (leftPeer) {
	        this.leftPeer = leftPeer;
	    };
	
	    Node.prototype.getRightPeer = function () {
	        return this.rightPeer;
	    };
	
	    Node.prototype.setRightPeer = function (rightPeer) {
	        this.rightPeer = rightPeer;
	    };
	
	    Node.prototype.getData = function () {
	        return this.data;
	    };
	
	    Node.prototype.getSurplus = function () {
	        return Math.max(0, Math.floor((this.data.length - this.mergeThreshold) / 2));
	    };
	
	    Node.prototype.getRightSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(this.data.length - surplus);
	    };
	
	    Node.prototype.getLeftSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(0, surplus);
	    };
	
	    var InternalNode = function InternalNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    InternalNode.prototype = (0, _create2.default)(Node.prototype);
	
	    InternalNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        var left = 0;
	        var right = data.length - 1;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left < right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return right;
	        }
	    };
	
	    InternalNode.prototype.findChild = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        if (element.key <= key) {
	            child = element.right;
	        } else {
	            child = element.left;
	        }
	        return child;
	    };
	
	    InternalNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        var newNodes, leftElement, rightElement;
	        if (element.key <= key) {
	            child = element.right;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: element.key,
	                    left: element.left,
	                    right: newNodes[0]
	                };
	                rightElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        } else {
	            child = element.left;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                rightElement = {
	                    key: element.key,
	                    left: newNodes[2],
	                    right: element.right
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        }
	        return newNodes;
	    };
	
	    InternalNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new InternalNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new InternalNode({
	            data: this.data.slice(splitIndex + 1, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    InternalNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var mergeIndex = -1;
	        var child;
	        var retval;
	        if (element.key <= key) {
	            child = element.right;
	            retval = child.remove(key, element.left, index < this.data.length - 1 ? child.getRightPeer() : undefined);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index + 1;
	                } else {
	                    mergeIndex = index;
	                }
	            }
	        } else {
	            child = element.left;
	            retval = child.remove(key, index > 0 ? child.getLeftPeer() : undefined, element.right);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index;
	                } else {
	                    mergeIndex = index - 1;
	                }
	            }
	        }
	        if (mergeIndex >= 0) {
	            var mergeElement = this.data[mergeIndex];
	            if (retval.length == 5) {
	                mergeElement.key = retval[3];
	                return [retval[0]];
	            } else {
	                if (mergeIndex > 0) {
	                    this.data[mergeIndex - 1].right = retval[3];
	                }
	                if (mergeIndex < this.data.length - 1) {
	                    this.data[mergeIndex + 1].left = retval[3];
	                }
	                this.data.splice(mergeIndex, 1);
	                return [retval[0]].concat(this.merge(leftMergeOption, rightMergeOption));
	            }
	        } else {
	            return [retval[0]];
	        }
	    };
	
	    InternalNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.slice(1).concat([{
	                key: this.data[0].left.getData()[0].key,
	                left: leftSurplusData[leftSurplusData.length - 1].right,
	                right: this.data[0].left
	            }], this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = leftSurplusData[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat([{
	                key: rightSurplusData[0].left.getData()[0].key,
	                left: this.data[this.data.length - 1].right,
	                right: rightSurplusData[0].left
	            }], rightSurplusData.slice(0, rightSurplusData.length - 1));
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightSurplusData[rightSurplusData.length - 1].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedInternalNode;
	            if (!isDefined(leftData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    InternalNode.prototype.find = function (key) {
	        return this.findChild(key).find(key);
	    };
	
	    InternalNode.prototype.range = function (start, end) {
	        return this.findChild(start).range(start, end);
	    };
	
	    InternalNode.prototype.toString = function (indent) {
	        return this.data.map(function (element) {
	            return [indent + "[key=" + element.key, "\n" + indent + "    LEFT\n" + element.left.toString(indent + "    "), "\n" + indent + "    RIGHT\n" + element.right.toString(indent + "    ") + "\n" + indent + "]"];
	        }).join(",\n");
	    };
	
	    var LeafNode = function LeafNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    LeafNode.prototype = (0, _create2.default)(Node.prototype);
	
	    LeafNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        if (data.length == 0) {
	            return 0;
	        }
	        var left = 0;
	        var right = data.length;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left !== right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return left;
	        }
	    };
	
	    LeafNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index == this.data.length) {
	            this.data.push({
	                key: key,
	                value: value
	            });
	        } else if (element.key === key) {
	            if (clobber) {
	                element.value = value;
	            } else {
	                return [element.value];
	            }
	            // This condition may never occur, given the way findIndex is written
	        } else if (element.key < key) {
	                this.data.splice(index + 1, 0, {
	                    key: key,
	                    value: value
	                });
	            } else {
	                this.data.splice(index, 0, {
	                    key: key,
	                    value: value
	                });
	            }
	        return this.split();
	    };
	
	    LeafNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new LeafNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new LeafNode({
	            data: this.data.slice(splitIndex, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    LeafNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            this.data.splice(index, 1);
	            return [element.value].concat(this.merge(leftMergeOption, rightMergeOption));
	        } else {
	            return [undefined];
	        }
	    };
	
	    LeafNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.concat(this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = this.data[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat(rightSurplusData);
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightMergeOption.getData()[0].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedLeafNode;
	            if (!isDefined(leftData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    LeafNode.prototype.find = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            return element.value;
	        }
	    };
	
	    LeafNode.prototype.range = function (start, end) {
	        var node = this;
	        var range = [];
	        while (isDefined(node)) {
	            var startIndex = node.findIndex(start);
	            var endIndex = node.findIndex(end);
	            var nodeData = node.getData();
	            if (startIndex < nodeData.length) {
	                for (var i = startIndex; i < endIndex; i++) {
	                    range.push(nodeData[i].value);
	                }
	            }
	            if (endIndex == nodeData.length) {
	                node = node.getRightPeer();
	            } else {
	                break;
	            }
	        }
	        return range;
	    };
	
	    LeafNode.prototype.toString = function (indent) {
	        return indent + "[" + this.data.map(function (element) {
	            return element.key;
	        }).toString() + "]";
	    };
	
	    var Tree = function Tree(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.root = new LeafNode({
	            order: this.order,
	            mergeThreshold: this.mergeThreshold,
	            data: []
	        });
	    };
	
	    Tree.prototype.toString = function () {
	        return this.root.toString("");
	    };
	
	    Tree.prototype.insert = function (key, value, clobber) {
	        var newNodes = this.root.insert(key, value, clobber);
	        if (newNodes.length == 3) {
	            this.root = new InternalNode({
	                order: this.order,
	                mergeThreshold: this.mergeThreshold,
	                data: [{
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                }]
	            });
	        } else if (newNodes.length == 1) {
	            return newNodes[0];
	        }
	        return value;
	    };
	
	    Tree.prototype.remove = function (key) {
	        var retval = this.root.remove(key);
	        if (retval.length == 2) {
	            this.root = retval[1];
	        }
	        return retval[0];
	    };
	
	    Tree.prototype.find = function (key) {
	        return this.root.find(key);
	    };
	
	    Tree.prototype.range = function (start, end) {
	        return this.root.range(start, end);
	    };
	
	    // Expose all types on top
	    Tree.Node = Node;
	    Tree.InternalNode = InternalNode;
	    Tree.LeafNode = LeafNode;
	
	    // Enable module loading if available
	    if (typeof module != 'undefined' && module["exports"]) {
	        // CommonJS
	        module["exports"] = Tree;
	    } else if ("function" != 'undefined' && __webpack_require__(179)["amd"]) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Tree;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Shim
	        if (!global["dcodeIO"]) {
	            global["dcodeIO"] = {};
	        }
	        global["dcodeIO"]["BPlusTree"] = Tree;
	    }
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(75)(module)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	/*
	 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	 http://www.apache.org/licenses/LICENSE-2.0
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: http://github.com/dcodeIO/btree.js for details
	 */
	(function (module, console) {
	    'use strict';
	
	    /**
	     * Concatenates multiple arrays into a new one.
	     * @param {...[Array]} var_args
	     * @returns {Array}
	     * @private
	     */
	
	    function concat(var_args) {
	        // Array#concat behaves strangely for empty arrays, so...
	        var a = [];
	        for (var i = 0; i < arguments.length; i++) {
	            Array.prototype.push.apply(a, arguments[i]);
	        }
	        return a;
	    }
	
	    /**
	     * Searches an array for the specified value.
	     * @param {Array} a
	     * @param {*} v
	     * @returns {number} Index or -1 if not found
	     * @private
	     */
	    function asearch(a, v) {
	        // This is faster than Array#indexOf because it's raw. However, we
	        // cannot use binary search because nodes do not have a comparable
	        // key. If the compiler is smart, it will inline this.
	        for (var i = 0; i < a.length; i++) {
	            if (a[i] === v) return i;
	        }
	        return -i;
	    }
	
	    /**
	     * btree namespace.
	     * @type {Object.<string,*>}
	     */
	    var btree = {};
	
	    /**
	     * Strictly compares two strings, character by character. No locales, no number extension.
	     * @param {string} a
	     * @param {string} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.strcmp = function strcmp(a, b) {
	        /** @type {number} */
	        var ac;
	        /** @type {number} */
	        var bc;
	        for (var i = 0; i < a.length; i++) {
	            if (i >= b.length) {
	                return 1;
	            }
	            if ((ac = a.charCodeAt(i)) < (bc = b.charCodeAt(i))) {
	                return -1;
	            } else if (ac > bc) {
	                return 1;
	            }
	            // If same, continue
	        }
	        return a.length == b.length ? 0 : -1;
	    };
	
	    /**
	     * Compares two numbers.
	     * @param {number} a
	     * @param {number} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.numcmp = function intcmp(a, b) {
	        return a < b ? -1 : a > b ? 1 : 0;
	    };
	
	    /**
	     * Creates a BTree class using the given order.
	     * Note that this method returns a class, not an instance.
	     * @param {number=} order Defaults to 2
	     * @param {function(?, ?):number=} compare Compare implementation to use on keys
	     * @returns {Function}
	     * @expose
	     */
	    btree.create = function (order, compare) {
	
	        // Validate order
	        if (typeof order == 'undefined') {
	            order = 52; // Benchmarks proofed that this is close to the optimum
	        } else if (typeof order == 'number') {
	                order = Math.floor(order);
	            } else {
	                order = parseInt(order, 10);
	            }
	        if (order < 1) order = 1;
	        var minOrder = order > 1 ? Math.floor(order / 2) : 1;
	
	        // Use numcmp by default
	        if (typeof compare != 'function') {
	            compare = btree.numcmp;
	        }
	
	        /**
	         * Validates a node and prints debugging info if something went wrong.
	         * @param {!TreeNode|!Tree} node
	         * @private
	         */
	        function validate(node) {
	            // This function will be stripped by the compiler
	            if (node instanceof Tree) return;
	            if (node.leaves.length + 1 != node.nodes.length) {
	                console.log("ERROR: Illegal leaf/node count in " + node + ": " + node.leaves.length + "/" + node.nodes.length);
	            }
	            for (var i = 0; i < node.leaves.length; i++) {
	                if (!node.leaves[i]) {
	                    console.log("ERROR: Illegal leaf in " + node + " at " + i + ": " + node.leaves[i]);
	                }
	            }
	            for (i = 0; i < node.nodes.length; i++) {
	                if (typeof node.nodes[i] == 'undefined') {
	                    console.log("ERROR: Illegal node in " + node + " at " + i + ": undefined");
	                }
	            }
	        }
	
	        /**
	         * Constructs a new TreeNode.
	         * @class A TreeNode.
	         * @param {!(TreeNode|Tree)} parent Parent node
	         * @param {Array.<!Leaf>=} leaves Leaf nodes
	         * @param {Array.<TreeNode>=} nodes Child nodes
	         * @constructor
	         */
	        var TreeNode = function TreeNode(parent, leaves, nodes) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode|!Tree}
	             */
	            this.parent = parent;
	
	            /**
	             * Leaf nodes (max. order).
	             * @type {!Array.<!Leaf>}
	             */
	            this.leaves = leaves || [];
	            this.leaves.forEach(function (leaf) {
	                leaf.parent = this;
	            }, this);
	
	            /**
	             * Child nodes (max. order+1).
	             * @type {!Array.<TreeNode>}
	             */
	            this.nodes = nodes || [null];
	            this.nodes.forEach(function (node) {
	                if (node !== null) node.parent = this;
	            }, this);
	        };
	
	        /**
	         * Searches for the node that would contain the specified key.
	         * @param {!*} key
	         * @returns {{leaf: !Leaf, index: number}|{node: !TreeNode, index: number}} Leaf if the key exists, else the insertion node
	         */
	        TreeNode.prototype.search = function (key) {
	            if (this.leaves.length > 0) {
	                var a = this.leaves[0];
	                if (compare(a.key, key) == 0) return { leaf: a, index: 0 };
	                if (compare(key, a.key) < 0) {
	                    if (this.nodes[0] !== null) {
	                        return this.nodes[0].search(key); // Left
	                    }
	                    return { node: this, index: 0 };
	                }
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(b.key, key) == 0) return { leaf: b, index: i };
	                    if (compare(key, b.key) < 0) {
	                        if (this.nodes[i] !== null) {
	                            return this.nodes[i].search(key); // Inner
	                        }
	                        return { node: this, index: i };
	                    }
	                    a = b;
	                }
	                if (this.nodes[i] !== null) {
	                    return this.nodes[i].search(key); // Right
	                }
	                return { node: this, index: i };
	            }
	            return { node: this, index: 0 };
	        };
	
	        /**
	         * Gets the value for the given key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         */
	        TreeNode.prototype.get = function (key) {
	            var result = this.search(key);
	            if (result.leaf) return result.leaf.value;
	            return undefined;
	        };
	
	        /**
	         * Inserts a key/value pair into this node.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if successfully set, false if already present and overwrite is `false`
	         */
	        TreeNode.prototype.put = function (key, value, overwrite) {
	            var result = this.search(key);
	            if (result.leaf) {
	                if (typeof overwrite !== 'undefined' && !overwrite) {
	                    return false;
	                }
	                result.leaf.value = value;
	                return true;
	            } // Key already exists
	            var node = result.node,
	                index = result.index;
	            node.leaves.splice(index, 0, new Leaf(node, key, value));
	            node.nodes.splice(index + 1, 0, null);
	            if (node.leaves.length > order) {
	                // Rebalance
	                node.split();
	            }
	            return true;
	        };
	
	        /**
	         * Deletes a key from this node.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         */
	        TreeNode.prototype.del = function (key) {
	            var result = this.search(key);
	            if (!result.leaf) return false;
	            var leaf = result.leaf,
	                node = leaf.parent,
	                index = result.index,
	                left = node.nodes[index];
	            if (left === null) {
	                node.leaves.splice(index, 1);
	                node.nodes.splice(index, 1);
	                node.balance();
	            } else {
	                var max = left.leaves[left.leaves.length - 1];
	                left.del(max.key);
	                max.parent = node;
	                node.leaves.splice(index, 1, max);
	            }
	            return true;
	        };
	
	        /**
	         * Balances this node to fulfill all conditions.
	         */
	        TreeNode.prototype.balance = function () {
	            if (this.parent instanceof Tree) {
	                // Special case: Root has just a single child and no leaves
	                if (this.leaves.length == 0 && this.nodes[0] !== null) {
	                    this.parent.root = this.nodes[0];
	                    this.parent.root.parent = this.parent;
	                }
	                return;
	            }
	            if (this.leaves.length >= minOrder) {
	                return;
	            }
	            var index = asearch(this.parent.nodes, this),
	                left = index > 0 ? this.parent.nodes[index - 1] : null,
	                right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null;
	            var sep, leaf, rest;
	            if (right !== null && right.leaves.length > minOrder) {
	                // Append the seperator from parent to this
	                sep = this.parent.leaves[index];
	                sep.parent = this;
	                this.leaves.push(sep);
	                // Replace the blank with the first right leaf
	                leaf = right.leaves.shift();
	                leaf.parent = this.parent;
	                this.parent.leaves[index] = leaf;
	                // Append the right rest to this
	                rest = right.nodes.shift();
	                if (rest !== null) rest.parent = this;
	                this.nodes.push(rest);
	            } else if (left !== null && left.leaves.length > minOrder) {
	                // Prepend the seperator from parent to this
	                sep = this.parent.leaves[index - 1];
	                sep.parent = this;
	                this.leaves.unshift(sep);
	                // Replace the blank with the last left leaf
	                leaf = left.leaves.pop();
	                leaf.parent = this.parent;
	                this.parent.leaves[index - 1] = leaf;
	                // Prepend the left rest to this
	                rest = left.nodes.pop();
	                if (rest !== null) rest.parent = this;
	                this.nodes.unshift(rest);
	            } else {
	                var subst;
	                if (right !== null) {
	                    // Combine this + seperator from the parent + right
	                    sep = this.parent.leaves[index];
	                    subst = new TreeNode(this.parent, concat(this.leaves, [sep], right.leaves), concat(this.nodes, right.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index, 2, subst);
	                } else if (left !== null) {
	                    // Combine left + seperator from parent + this
	                    sep = this.parent.leaves[index - 1];
	                    subst = new TreeNode(this.parent, concat(left.leaves, [sep], this.leaves), concat(left.nodes, this.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index - 1, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index - 1, 2, subst);
	                } else {
	                    // We should never end here
	                    throw new Error("Internal error: " + this.toString(true) + " has neither a left nor a right sibling");
	                }
	                this.parent.balance();
	            }
	            // validate(this);
	            // validate(this.parent);
	        };
	
	        /**
	         * Unsplits a child.
	         * @param {!Leaf} leaf
	         * @param {!TreeNode} rest
	         */
	        TreeNode.prototype.unsplit = function (leaf, rest) {
	            leaf.parent = this;
	            rest.parent = this;
	            var a = this.leaves[0];
	            if (compare(leaf.key, a.key) < 0) {
	                this.leaves.unshift(leaf);
	                this.nodes.splice(1, 0, rest);
	            } else {
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(leaf.key, b.key) < 0) {
	                        this.leaves.splice(i, 0, leaf);
	                        this.nodes.splice(i + 1, 0, rest);
	                        break;
	                    }
	                }
	                if (i == this.leaves.length) {
	                    this.leaves.push(leaf);
	                    this.nodes.push(rest);
	                }
	            }
	            if (this.leaves.length > order) {
	                this.split();
	            }
	        };
	
	        /**
	         * Splits this node.
	         */
	        TreeNode.prototype.split = function () {
	            var index = Math.floor(this.leaves.length / 2);
	            if (this.parent instanceof Tree) {
	                this.nodes = [new TreeNode(this, this.leaves.slice(0, index), this.nodes.slice(0, index + 1)), new TreeNode(this, this.leaves.slice(index + 1), this.nodes.slice(index + 1))];
	                this.leaves = [this.leaves[index]];
	            } else {
	                var leaf = this.leaves[index];
	                var rest = new TreeNode(this.parent, this.leaves.slice(index + 1), this.nodes.slice(index + 1));
	                this.leaves = this.leaves.slice(0, index);
	                this.nodes = this.nodes.slice(0, index + 1);
	                this.parent.unsplit(leaf, rest);
	            }
	        };
	
	        /**
	         * Returns a string representation of this node.
	         * @param {boolean=} includeNodes Whether to include sub-nodes or not
	         * @returns {string}
	         */
	        TreeNode.prototype.toString = function (includeNodes) {
	            var val = [];
	            for (var i = 0; i < this.leaves.length; i++) {
	                val.push(this.leaves[i].key);
	            }
	            var s = "[" + val.toString() + "]" + (this.parent instanceof Tree ? ":*" : ":" + this.parent);
	            if (includeNodes) {
	                for (i = 0; i < this.nodes.length; i++) {
	                    s += " -> " + this.nodes[i];
	                }
	            }
	            return s;
	        };
	
	        /**
	         * Prints out the nodes leaves and nodes.
	         * @param {number} indent
	         */
	        TreeNode.prototype.print = function (indent) {
	            var space = "";
	            for (var i = 0; i < indent; i++) {
	                space += " ";
	            }for (i = this.leaves.length - 1; i >= 0; i--) {
	                if (this.nodes[i + 1] !== null) this.nodes[i + 1].print(indent + 2);
	                console.log(space + this.leaves[i].key + (this.parent instanceof Tree ? "*" : ""));
	            }
	            if (this.nodes[0] !== null) this.nodes[0].print(indent + 2);
	        };
	
	        /**
	         * Constructs a new Leaf containing a value.
	         * @class A Leaf.
	         * @param {!TreeNode} parent
	         * @param {!*} key
	         * @param {*} value
	         * @constructor
	         */
	        var Leaf = function Leaf(parent, key, value) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode}
	             */
	            this.parent = parent;
	
	            /**
	             * Key.
	             * @type {!*}
	             */
	            this.key = key;
	
	            /**
	             * Value.
	             * @type {*}
	             */
	            this.value = value;
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Leaf.prototype.toString = function () {
	            return "" + this.key;
	        };
	
	        /**
	         * Constructs a new Tree.
	         * @class A Tree.
	         * @constructor
	         */
	        function Tree() {
	            this.root = new TreeNode(this);
	        }
	
	        /**
	         * Inserts a key/value pair into the tree.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if set, false if already present and overwrite is `false`
	         * @throws {Error} If the key is undefined or null or the value is undefined
	         * @expose
	         */
	        Tree.prototype.put = function (key, value, overwrite) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            if (typeof value === 'undefined') throw new Error("Illegal value: " + value);
	            return this.root.put(key, value, overwrite);
	        };
	
	        /**
	         * Gets the value of the specified key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         * @throws {Error} If the key is undefined or null
	         * @expose
	         */
	        Tree.prototype.get = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.get(key);
	        };
	
	        /**
	         * Deletes a key from the tree.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         * @expose
	         */
	        Tree.prototype.del = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.del(key);
	        };
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in ascending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkAsc = function (minKey, maxKey, callback) {
	            if (this.root.leaves.length == 0) {
	                return;
	            }
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (minKey === null) {
	                // If there is no minimum limit
	                ptr = this.root; // set ptr to the outer left node
	                while (ptr.nodes[0] !== null) {
	                    ptr = ptr.nodes[0];
	                }
	                index = 0; // and start at its first leaf
	            } else {
	                    // Else lookup
	                    var result = this.root.search(minKey);
	                    if (result.leaf) {
	                        // If the minimum key itself exists
	                        ptr = result.leaf.parent; // set ptr to the containing node
	                        index = asearch(ptr.leaves, result.leaf); // and start at its index
	                    } else {
	                            // If the key does not exist
	                            ptr = result.node; // set ptr to the insertion node
	                            index = result.index; // and start at the insertion index (key > minKey)
	                            if (index >= ptr.leaves.length) {
	                                // on overrun, begin at the separator in the parent
	                                if (ptr.parent instanceof Tree) {
	                                    return; // empty range
	                                }
	                                index = asearch(ptr.parent.nodes, ptr);
	                                if (index >= ptr.parent.leaves.length) {
	                                    return; // empty range
	                                }
	                                ptr = ptr.parent;
	                            }
	                        }
	                }
	            // ptr/index now points at our first result
	            while (true) {
	                if (maxKey !== null && compare(ptr.leaves[index].key, maxKey) > 0) {
	                    break; // if there are no more keys less than maxKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index + 1] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index + 1];
	                    index = 0;
	                    while (ptr.nodes[0] !== null) {
	                        ptr = ptr.nodes[0];
	                    }
	                } else if (ptr.leaves.length > index + 1) {
	                    // Next
	                    index++;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr);
	                        ptr = ptr.parent;
	                    } while (index >= ptr.leaves.length);
	                }
	            }
	        };
	
	        /**
	         * Alias of {@link Tree#walkAsc}.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|(function(*, *):(boolean|undefined)))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walk = Tree.prototype.walkAsc;
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in descending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or null, walks till the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or null, starts at the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkDesc = function (minKey, maxKey, callback) {
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (maxKey === null) {
	                // If there is no maximum limit
	                ptr = this.root; // set ptr to the outer right node
	                while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                    ptr = ptr.nodes[ptr.nodes.length - 1];
	                }
	                index = ptr.leaves.length - 1; // and start at its last leaf
	            } else {
	                    // Else lookup
	                    var result = this.root.search(maxKey);
	                    if (result.leaf) {
	                        // If the maximum key itself exists
	                        ptr = result.leaf.parent; // set ptr to the containing node
	                        index = asearch(ptr.leaves, result.leaf); // and start at its index
	                    } else {
	                            // If the key does not exist
	                            ptr = result.node; // set ptr to the insertion node
	                            index = result.index - 1; // and start at the insertion index-1 (key < maxKey)
	                            while (index < 0) {
	                                // on underrun, begin at the separator in the parent
	                                if (ptr.parent instanceof Tree) {
	                                    return; // empty range
	                                }
	                                index = asearch(ptr.parent.nodes, ptr) - 1;
	                                if (index < 0) {
	                                    return; // empty range
	                                }
	                                ptr = ptr.parent;
	                            }
	                        }
	                }
	            // ptr/index now points at our first result
	            while (true) {
	                if (minKey !== null && compare(ptr.leaves[index].key, minKey) < 0) {
	                    break; // if there are no more keys bigger than minKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index];
	                    while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                        ptr = ptr.nodes[ptr.nodes.length - 1];
	                    }
	                    index = ptr.leaves.length - 1;
	                } else if (index > 0) {
	                    // Next
	                    index--;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr) - 1;
	                        ptr = ptr.parent;
	                    } while (index < 0);
	                }
	            }
	        };
	
	        /**
	         * Counts the number of keys between minKey and maxKey (both inclusive).
	         * @param {*=} minKey If omitted, counts from the start
	         * @param {*=} maxKey If omitted, counts till the end
	         * @returns {number}
	         * @expose
	         */
	        Tree.prototype.count = function (minKey, maxKey) {
	            var n = 0;
	            this.walk(typeof minKey != 'undefined' ? minKey : null, typeof maxKey != 'undefined' ? maxKey : null, function (key, value) {
	                n++;
	            });
	            return n;
	        };
	
	        /**
	         * Prints out all nodes in the tree.
	         * @expose
	         */
	        Tree.prototype.print = function () {
	            this.root.print(0);
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Tree.prototype.toString = function () {
	            return "Tree(" + order + ") " + this.root.toString();
	        };
	
	        return Tree;
	    };
	
	    module.exports = btree;
	})(module, console);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(75)(module)))

/***/ },
/* 153 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.binarySearch = binarySearch;
	exports.binarySearchRecursive = binarySearchRecursive;
	/*
	 折半查找(Binary Search)
	
	 折半查找又称为二分查找，是一种效率较高的查找方法。
	 前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。
	 查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。
	
	 1  查找思想
	 用Low、High和Mid表示待查找区间的下界、上界和中间位置指针，初值为Low=0，High=n - 1。
	 ⑴  取中间位置Mid：Mid=Math.floor((Low+High)/2)；
	 ⑵  比较中间位置记录的关键字与给定的K值：
	 ①  相等： 查找成功；
	 ②  大于：待查记录在区间的前半段，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段，修改下界指针：Low=Mid+1，转⑴ ；
	 直到越界(Low>High)，查找失败。
	
	 2  算法分析
	 ①  查找时每经过一次比较，查找范围就缩小一半，该过程可用一棵二叉树表示：
	 ◆ 根结点就是第一次进行比较的中间位置的记录；
	 ◆ 排在中间位置前面的作为左子树的结点；
	 ◆ 排在中间位置后面的作为右子树的结点；
	 对各子树来说都是相同的。这样所得到的二叉树称为判定树(Decision Tree)。
	 ②  将二叉判定树的第Math.floor(Math.log(2, n))+1层上的结点补齐就成为一棵满二叉树，深度不变，h= Math.floor(Math.log(2, n + 1)) 。
	 ③  由满二叉树性质知，第i 层上的结点数为Math.pow(2, i-1)(i<=h) ，设表中每个记录的查找概率相等，即Pi=1/n，查找成功时的平均查找长度ASL：
	 (n+1)/n*Math.log(2,n+1)-1
	 当n很大 (n>50)时， ASL≈ Math.log(2,n+1)-1。
	
	
	 时间复杂度O(logn)
	 */
	
	// 非递归式
	function binarySearch(sTable, key) {
	    var low = 0;
	    var high = sTable.length - 1;
	
	    while (low <= high) {
	        var mid = low + high >> 1;
	        var elem = sTable[mid];
	
	        if (elem === key) return mid;else if (elem < key) low = mid + 1;else high = mid - 1;
	    }
	
	    return -1;
	}
	
	console.log('binarySearch: ');
	console.log(binarySearch([1, 2, 3, 4, 5], 1)); // 0
	
	// 递归式
	function binarySearchRecursive(sTable, key) {
	    var low = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var high = arguments.length <= 3 || arguments[3] === undefined ? sTable.length - 1 : arguments[3];
	
	    if (low > high) return -1;
	
	    var mid = low + high >> 1;
	    var elem = sTable[mid];
	
	    if (elem === key) return mid;else if (elem < key) return binarySearchRecursive(sTable, key, mid + 1, high);else return binarySearchRecursive(sTable, key, low, mid - 1);
	}
	
	console.log('binarySearchRecursive: ');
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 1)); // 0
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(17);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(25);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(82);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(24);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _getIterator2 = __webpack_require__(16);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _xxhashjs = __webpack_require__(180);
	
	var _crypto = __webpack_require__(132);
	
	var _crypto2 = _interopRequireDefault(_crypto);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。
	
	 为了降低冲突的概念，Bloom Filter使用了多个哈希函数，而不是一个。
	
	 Bloom Filter算法如下：
	 创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为h（i，str），且h（i，str）的范围是0到m-1 。
	
	 (1) 加入字符串过程
	 下面是每个字符串处理的过程，首先是将字符串str“记录”到BitSet中的过程：
	 对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后将BitSet的第h（1，str）、h（2，str）…… h（k，str）位设为1。
	
	 (2) 检查字符串是否存在的过程
	 下面是检查字符串str是否被BitSet记录过的过程：
	 对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。
	 若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）
	 　但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive。
	
	 (3) 删除字符串过程
	 字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。
	
	 Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。
	
	 Bloom Filter参数选择
	 (1)哈希函数选择
	 　　哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。
	
	 (2) m,n,k值，我们如何取值
	 我们定义：
	 可能把不属于这个集合的元素误认为属于这个集合（False Positive）
	 不会把属于这个集合的元素误认为不属于这个集合（False Negative）。
	
	 哈希函数的个数k、位数组大小m、加入的字符串数量n的关系。哈希函数个数k取10，位数组大小m设为字符串个数n的20倍时，false positive发生的概率是0.0000889 ，即10万次的判断中，会存在9次误判，对于一天1亿次的查询，误判的次数为9000次。
	
	 Bloomfilter 的应用场景
	 1.黑名单
	 最典型的一个应用就是黑名单功能，对用户名称或者IP或者Email进行过滤，每次检查时用key进行hash后，如果不在黑名单内的，肯定可以通行，如果在的则不允许通过，误判情况增加一个排除名单来进行排除。
	 误判情况：将正常用户判定为黑名单用户
	
	 2.爬虫重复URL检测
	 在爬取网站URL时，要检测这条URL是否已经访问过。
	 误判情况：没有访问过的误判为访问过
	
	 3.字典纠错
	 检查单词拼写是否正确
	 误判情况：错误的单词误判为正确。
	
	 4.磁盘文件检测
	 将磁盘中或者数据库中数据key存入该结构中，检测要访问的数据是否在磁盘或数据库中，然后再发起访问，避免空查询造成磁盘或数据库压力。
	 误判情况：不存在该数据却误判为有该数据。
	
	 5.CDN（squid）代理缓存技术
	 先查找本地有无cache，如果没有则到其他兄弟 cache服务器上去查找。为了避免无谓的查询，在每个cache服务器上保存其兄弟服务器的缓存关键字，以bloomfilter方式存储，再去其他cache服务器查找之前，先检查该结构是否有url，如果有存在url，再去对应服务器查找。
	 误判情况： 对应服务器不存在该URL的缓存。
	
	 Thanks to:
	 http://allenkim67.github.io/2016/05/17/nodejs-buffer-tutorial.html
	 https://github.com/ceejbot/xx-bloom
	 https://github.com/pierrec/js-xxhash
	 */
	
	var LN2_SQUARED = Math.LN2 * Math.LN2;
	
	var BloomFilter = function () {
	    function BloomFilter() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        (0, _classCallCheck3.default)(this, BloomFilter);
	
	        this.init(options);
	    }
	
	    (0, _createClass3.default)(BloomFilter, [{
	        key: 'init',
	        value: function init(options) {
	            if (options.seeds) {
	                this.seeds = options.seeds;
	                this.hashes = options.seeds.length;
	            } else {
	                this.seeds = [];
	                this.hashes = options.hashes || 0;
	
	                this._generateSeeds();
	            }
	
	            this.bits = options.bits || 1024;
	            this.buffer = Buffer.alloc(Math.ceil(this.bits / 8));
	
	            this.clear();
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            //  buf.fill(0) to initialize a Buffer to zeroes
	            this.buffer.fill(0);
	        }
	    }, {
	        key: '_generateSeeds',
	        value: function _generateSeeds() {
	            if (!this.seeds) this.seeds = [];
	
	            for (var i = 0; i < this.hashes; ++i) {
	                // Generates cryptographically strong pseudo-random data. Generate 4 bytes.
	                var buf = _crypto2.default.randomBytes(4);
	                // Reads an unsigned 32-bit integer from the Buffer from index 0
	                this.seeds[i] = buf.readUInt32LE(0);
	
	                // Make sure we don't end up with two identical seeds,
	                // which is unlikely but possible.
	                for (var j = 0; j < i; ++j) {
	                    if (this.seeds[i] === this.seeds[j]) {
	                        --i;
	                        break;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'add',
	        value: function add(buf) {
	            if (Array.isArray(buf)) {
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;
	
	                try {
	                    for (var _iterator = (0, _getIterator3.default)(buf), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                        var item = _step.value;
	
	                        this.add(item);
	                    }
	                } catch (err) {
	                    _didIteratorError = true;
	                    _iteratorError = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion && _iterator.return) {
	                            _iterator.return();
	                        }
	                    } finally {
	                        if (_didIteratorError) {
	                            throw _iteratorError;
	                        }
	                    }
	                }
	            } else {
	                buf = Buffer.from(buf);
	
	                for (var i = 0; i < this.hashes; ++i) {
	                    var hash = (0, _xxhashjs.h32)(buf, this.seeds[i]).toString();
	                    var bit = hash % this.bits;
	                    this._setBit(bit);
	                }
	            }
	        }
	    }, {
	        key: 'has',
	        value: function has(item) {
	            item = Buffer.from(item);
	
	            for (var i = 0; i < this.hashes; ++i) {
	                var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
	                var bit = hash % this.bits;
	
	                var isInSet = this._getBit(bit);
	                if (!isInSet) return false;
	            }
	
	            return true;
	        }
	    }, {
	        key: '_setBit',
	        value: function _setBit(bit) {
	            var pos = Math.floor(bit / 8);
	            var shift = bit % 8;
	
	            var bitField = this.buffer[pos];
	            bitField |= 0x1 << shift;
	            this.buffer[pos] = bitField;
	        }
	    }, {
	        key: '_getBit',
	        value: function _getBit(bit) {
	            var pos = Math.floor(bit / 8);
	            var shift = bit % 8;
	
	            var bitField = this.buffer[pos];
	
	            return (bitField & 0x1 << shift) !== 0;
	        }
	    }], [{
	        key: 'optimize',
	        value: function optimize(itemCount) {
	            var errorRate = arguments.length <= 1 || arguments[1] === undefined ? 0.005 : arguments[1];
	
	            var bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED);
	            var hashes = Math.round(bits / itemCount * Math.LN2);
	
	            return {
	                bits: bits,
	                hashes: hashes
	            };
	        }
	    }, {
	        key: 'createOptimal',
	        value: function createOptimal(itemCount, errorRate) {
	            var opts = this.optimize(itemCount, errorRate);
	
	            return new this(opts);
	        }
	    }]);
	    return BloomFilter;
	}();
	
	exports.default = BloomFilter;
	
	
	var filter = new BloomFilter({ hashes: 8, bits: 1024 });
	filter.add(['cat', 'dog', 'coati', 'red panda']);
	console.log(filter.has('cat'));
	console.log(filter.has('coat'));
	console.log(filter.has('null'));
	
	var CountingBloomFilter = function (_BloomFilter) {
	    (0, _inherits3.default)(CountingBloomFilter, _BloomFilter);
	
	    function CountingBloomFilter() {
	        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        (0, _classCallCheck3.default)(this, CountingBloomFilter);
	        return (0, _possibleConstructorReturn3.default)(this, (CountingBloomFilter.__proto__ || (0, _getPrototypeOf2.default)(CountingBloomFilter)).call(this, opts));
	    }
	
	    (0, _createClass3.default)(CountingBloomFilter, [{
	        key: 'init',
	        value: function init(opts) {
	            if (opts.seeds) {
	                this.seeds = opts.seeds;
	                this.hashes = opts.seeds.length;
	            } else {
	                this.hashes = opts.hashes || 8;
	                this._generateSeeds();
	            }
	
	            this.bits = opts.bits || 1024;
	            this.buffer = Buffer.alloc(this.bits);
	
	            this.clear();
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            (0, _get3.default)(CountingBloomFilter.prototype.__proto__ || (0, _getPrototypeOf2.default)(CountingBloomFilter.prototype), 'clear', this).call(this);
	
	            this.overflow = 0;
	        }
	    }, {
	        key: '_setBit',
	        value: function _setBit(bit) {
	            // no-op at overflow
	            if (this.buffer[bit] === 255) {
	                ++this.overflow;
	                return;
	            }
	
	            ++this.buffer[bit];
	        }
	    }, {
	        key: '_unSetBit',
	        value: function _unSetBit(bit) {
	            if (this.buffer[bit] === 255 || this.buffer[bit] === 0) return;
	
	            --this.buffer[bit];
	        }
	    }, {
	        key: '_getBit',
	        value: function _getBit(bit) {
	            return this.buffer[bit] !== 0;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(item) {
	            if (!Buffer.isBuffer(item)) item = Buffer.from(item);
	
	            for (var i = 0; i < this.seeds.length; ++i) {
	                var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
	                var bit = hash % this.bits;
	
	                this._unSetBit(bit);
	            }
	        }
	    }, {
	        key: 'hasOverflowed',
	        get: function get() {
	            return this.overflow > 0;
	        }
	    }], [{
	        key: 'createOptimal',
	        value: function createOptimal(itemCount, errorRate) {
	            var opts = BloomFilter.optimize(itemCount, errorRate);
	            return new this(opts);
	        }
	    }]);
	    return CountingBloomFilter;
	}(BloomFilter);
	
	console.log('CountingBloomFilter');
	var filter = new CountingBloomFilter({ hashes: 8, bits: 1024 });
	filter.add(['cat', 'dog', 'coati', 'red panda']);
	console.log(filter.has('cat'));
	filter.remove('cat');
	console.log(filter.has('cat'));
	console.log(filter.has('coat'));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TrieTree = exports.DoubleLinkedTree = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/1/11.
	 */
	
	/*
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，也叫字典树，来表示这样的字符串的集合。
	
	 概念
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。键树又称为数字查找树（Digital Search Tree)或Trie树(trie为retrieve中间4个字符)，其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A,B,C,....Z的单词所在页,再对各部分标出第二字母为A,B,C,...Z的单词所在的页, ....等等。
	
	 键树是一种特殊的查找树，它的某个节点不是包含一个或多个关键字，而是只包含组成关键字的一部分（字符或数字），比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。
	
	 根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。事实上，还可以赋予“字符串”更广泛的含义，它可以是任何类型的对象组成的串。
	
	
	 键树的存储
	 1）双链树表示
	 2) 多重链表表示
	
	
	 键树的应用场景
	
	 Trie是一种非常简单高效的数据结构，但有大量的应用实例。
	 （1） 字符串检索
	 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
	 举例：
	 @  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
	 @  给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。
	
	 （2）字符串最长公共前缀
	 Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
	 举例：
	 @ 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？
	 解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
	 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
	 1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
	 2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；
	 （关于并查集，Tarjan算法，RMQ问题，网上有很多资料。）
	
	 （3）排序
	 Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
	 举例：
	 @ 给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。
	
	 （4） 作为其他数据结构和算法的辅助结构
	 如后缀树，AC自动机等
	 */
	
	/*
	 双链树表示
	
	 以树的孩子兄弟链表来表示键树，则每个分支结点包括三个域：
	 symbol域：存储关键字的一个字符；
	 first域：存储指向第一棵子树根的指针；
	 next域：存储指向右兄弟的指针。
	
	 同时，叶子结点不含first域，它的infoptr域存储指向该关键字记录的指针。
	 此时的键树又称双链树。
	 在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。
	 结点的结构中可以设置一个枚举变量表示结点的类型，叶子结点和分支结点。
	 叶子结点和分支结点都有symbol域和next域。不同的一个域可以用联合表示，叶子结点包含infoptr指向记录，而分支结点是first域指向其第一棵子树。
	
	
	 双链树的查找
	
	 假设给定值为K.ch(0..num-1), 其中K.ch[0]至 K.ch[num-2]表示待查关键字中num-1个字符， K.ch[num-1]为结束符$。
	 从双链树的根指针出发，顺first指针找到第一棵子树的根结点，以K.ch[0]和此结点的symbol域比较，若相等，则顺first域再比较下一字符，否则沿next域顺序查找。
	 若直至空仍比较不等，则查找不成功。
	
	 // 相关资料
	 http://www.cnblogs.com/rollenholt/archive/2012/04/24/2468932.html
	 http://blog.csdn.net/v_july_v/article/details/6897097
	 http://www.raychase.net/1783
	 */
	
	var LEAF = 'leaf';
	var BRANCH = 'branch';
	var TERMINAL = new String('$');
	
	var DoubleLinkedTree = exports.DoubleLinkedTree = function () {
	    function DoubleLinkedTree() {
	        var symbol = arguments.length <= 0 || arguments[0] === undefined ? 'root' : arguments[0];
	        var kind = arguments.length <= 1 || arguments[1] === undefined ? BRANCH : arguments[1];
	        var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, DoubleLinkedTree);
	
	        this.symbol = symbol;
	        this.next = null;
	        this.kind = kind;
	        this.info = info;
	        this.first = null;
	    }
	
	    (0, _createClass3.default)(DoubleLinkedTree, [{
	        key: 'synoSearch',
	        value: function synoSearch(key) {
	            var p = this.first;
	
	            for (var i = 0; p && i < key.length; ++i) {
	                if (p && p.kind === LEAF) break;
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) p = p.first;else p = null;
	            }
	
	            return p && p.kind === LEAF ? p.info : null;
	        }
	    }, {
	        key: 'search',
	        value: function search(key) {
	            var p = this.first;
	
	            for (var i = 0; p && i < key.length; ++i) {
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) p = p.first;else p = null;
	            }
	
	            return p && p.kind === LEAF ? p.info : null;
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key, value) {
	            key += '';
	            var cur = this;
	
	            for (var i = 0; i < key.length; ++i) {
	                var c = key[i];
	                var p = cur;
	                cur = cur.first;
	                var node = new DoubleLinkedTree(c, BRANCH);
	
	                // 如果没有子结点则将新结点作为子结点
	                if (!cur) {
	                    p.first = node;
	                    node.parent = p;
	                    cur = node;
	                } else {
	                    // 在兄弟结点中找到对应结点
	                    if (c < cur.symbol) {
	                        node.parent = cur.parent;
	                        node.next = cur;
	                        node.parent.first = node;
	                        cur = node;
	                    } else if (c > cur.symbol) {
	                        var b = void 0;
	                        while (cur) {
	                            // 如果相等，退出该循环查找下一字符
	                            if (c === cur.symbol) break;
	                            // 如果小于当前字符，则插入到当前结点前面
	                            else if (c < cur.symbol) {
	                                    node.parent = cur.parent;
	                                    node.next = cur;
	                                    b.next = node;
	                                    cur = node;
	                                    break;
	                                } else {
	                                    b = cur;
	                                    cur = cur.next;
	                                }
	                        }
	
	                        // 如果没有兄弟结点则插入到兄弟结点
	                        if (!cur) {
	                            b.next = node;
	                            node.parent = b.parent;
	                            cur = node;
	                        }
	                    }
	                }
	            }
	
	            // 生成叶子结点
	            var success = false;
	            if (cur.kind === BRANCH) {
	                var child = cur.first;
	
	                // 如果不存在关键字则说明插入成功，否则插入失败
	                if (!(child && child.symbol === TERMINAL)) {
	                    cur.first = new DoubleLinkedTree(TERMINAL, LEAF, value != null ? value : key);
	                    cur.first.parent = cur;
	                    cur.first.next = child;
	                    success = true;
	                }
	            }
	
	            return success;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            var p = this.first;
	            var i = 0;
	
	            while (p && i < key.length) {
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) {
	                    p = p.first;
	                    ++i;
	                } else return false;
	            }
	
	            var data = p.info;
	            while (!p.next && p.parent) {
	                p = p.parent;
	            }var top = p;
	
	            if (top == this) {
	                this.first = null;
	                return data;
	            }
	
	            p = top.parent;
	            if (p) {
	                p = p.first;
	                while (p) {
	                    var pre = void 0;
	                    if (p == top) {
	                        // 删除在first域上的子树结点
	                        if (!pre) top.parent.first = top.parent.first.next;
	                        // 删除在next域的兄弟结点
	                        else pre.next = pre.next.next;
	
	                        return data;
	                    } else {
	                        pre = p;
	                        p = p.next;
	                    }
	                }
	            }
	
	            return false;
	        }
	    }]);
	    return DoubleLinkedTree;
	}();
	
	var test = new DoubleLinkedTree();
	test.insert('CAI');
	test.insert('LAN');
	test.insert('CAO');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CHAO');
	test.insert('CHEN');
	test.insert('LI');
	test.insert('LIU');
	test.insert('ZHAO');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('CAI'));
	console.log(test.search('CHA'));
	console.log(test.search('CHANG'));
	console.log(test.search('ZHAOx'));
	
	console.log('\nremove:');
	console.log(test.remove('CAI'));
	console.log(test.remove('CAI'));
	console.log(test.remove('LAN'));
	console.log(test.remove('CAO'));
	console.log(test.remove('CHA'));
	console.log(test.remove('CHANG'));
	console.log(test.remove('CHAO'));
	console.log(test.remove('CHEN'));
	console.log(test.remove('LI'));
	console.log(test.remove('LIU'));
	console.log(test.remove('ZHAO'));
	
	/*
	 多重链表表示
	
	 若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树。
	 （Trie是从检索retrieve中取中间四个字符的，读音同try）。
	 若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。
	 在Trie树中有两种结点：
	 分支结点：含有d个指针域和一个指示该结点中非空指针域的个数的整数域。在分支结点中不设数据域，每个分支结点所表示的字符均有其父结点中指向该结点的指针所在位置决定。
	 叶子结点：含有关键字域和指向记录的指针域。
	
	
	 在Trie树上进行查找
	
	 从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功，若分支结点中和给定值相应的指针为空，或叶子结点中的关键字和给定值不相等，则查找不成功。
	
	
	 优化Trie树的深度
	
	 我们可对关键字集选择一种合适的分割。先按首字符不通分成多个子集之后，然后按最后一个字符不同分割每个子集，再按第二个字符。。。前后交叉分割。一缩减Trie树的深度
	 */
	// 求字符在字母表中的序号
	function order(c) {
	    return c ? c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1 : 0;
	}
	
	// 通过回溯法清理Trie树的函数
	function removeNode(trieNode, order, clear) {
	    trieNode.branch.nodes[order] = null;
	    --trieNode.branch.num;
	
	    if (!clear) return;
	
	    var nodes = trieNode.branch.nodes;
	    var parent = trieNode.parent;
	    var pre = trieNode;
	
	    while (parent) {
	        for (var i in nodes) {
	            if (nodes.hasOwnProperty(i) && nodes[i]) return;
	        }
	
	        var index = void 0;
	        var parentNodes = parent.branch.nodes;
	        for (var _i in parentNodes) {
	            if (parentNodes.hasOwnProperty(_i) && parentNodes[_i] && parentNodes[_i] == pre) index = _i;
	        }
	        parent.branch.nodes[index] = null;
	        --parent.branch.num;
	
	        pre = parent;
	        nodes = parent.branch.nodes;
	        parent = parent.parent;
	    }
	}
	
	var TrieTree = exports.TrieTree = function () {
	    function TrieTree() {
	        var kind = arguments.length <= 0 || arguments[0] === undefined ? BRANCH : arguments[0];
	        (0, _classCallCheck3.default)(this, TrieTree);
	
	        this.kind = kind;
	        this.parent = null;
	
	        if (kind === LEAF) {
	            this.leaf = {
	                key: null,
	                info: null
	            };
	        } else {
	            this.branch = {
	                // “$”为第一个字符，后续为26个字母
	                nodes: new Array(27),
	                num: 0
	            };
	        }
	    }
	
	    (0, _createClass3.default)(TrieTree, [{
	        key: 'search',
	        value: function search(key) {
	            var p = this,
	                i = 0;
	            for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {}
	
	            if (p) {
	                if (p.kind === LEAF && p.leaf.key === key) return p.leaf.info;
	                // 同义词
	                else if (p.kind === BRANCH) {
	                        p = p.branch.nodes[0];
	                        if (p && p.leaf.key === key) return p.leaf.info;
	                    }
	            }
	
	            return null;
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key, value) {
	            // 建叶子结点
	            var q = new TrieTree(LEAF);
	            q.leaf.key = key;
	            q.leaf.info = value;
	
	            // 自上而下查找
	            var last = void 0;
	            var p = this,
	                i = 0;
	            for (; p && p.kind === BRANCH && i < key.length && p.branch.nodes[order(key[i])]; p = p.branch.nodes[order(key[i])], ++i) {
	                last = p;
	            } // 如果最后落到分支结点（无同义词）
	            // 直接连上叶子
	            if (p.kind === BRANCH) {
	                p.branch.nodes[order(key[i])] = q;
	                q.parent = p;
	                ++p.branch.num;
	            }
	            // 如果最后落到叶子结点（有同义词）
	            else {
	                    if (p.leaf.key === key) return false;
	
	                    // 建立新的分支结点
	                    var r = new TrieTree(BRANCH);
	                    // 用新的分支结点取代老叶子结点和上一层的联系
	                    last.branch.nodes[order(key[i - 1])] = r;
	                    r.parent = last;
	                    r.branch.num = 2;
	                    r.branch.nodes[order(key[i])] = q;
	                    q.parent = r;
	                    // 新分支结点与新老两个叶子结点相连
	                    r.branch.nodes[order(p.leaf.key[i])] = p;
	                    p.parent = r;
	                }
	
	            return true;
	        }
	
	        /**
	         *
	         * @param key
	         * @param {Boolean} clear 是否需要清理结点
	         * @returns {*} 如果删除成功返回info数据否则返回false
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key, clear) {
	            var last = void 0;
	            var p = this,
	                i = 0;
	            // 查找待删除元素
	            for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {
	                last = p;
	            }if (!p) return false;
	
	            clear = typeof clear !== 'undefined' ? clear : true;
	            var data = null;
	
	            if (p.kind === LEAF && p.leaf.key === key) {
	                data = p.leaf.info;
	                removeNode(last, order(key[i - 1]), clear);
	                return data;
	            } else if (p.kind === BRANCH) {
	                p = p.branch.nodes[0];
	                if (p && p.leaf.key === key) {
	                    data = p.leaf.info;
	                    removeNode(p.parent, 0, clear);
	                    return data;
	                }
	            }
	
	            return false;
	        }
	    }]);
	    return TrieTree;
	}();
	
	var test = new TrieTree();
	
	test.insert('CHA');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CAI');
	test.insert('CHEN');
	test.insert('CAO');
	test.insert('CHAO');
	test.insert('LONG');
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');
	test.insert('WANG');
	test.insert('WEN');
	test.insert('WU');
	test.insert('YANG');
	test.insert('YUN');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('YUN'));
	console.log(test.search('ZHAO'));
	console.log(test.search('CHA'));
	
	test.remove('LAN');
	test.remove('LIU');
	test.remove('WANG');
	test.remove('WEN');
	test.remove('WU');
	test.remove('YANG');
	test.remove('YUN');
	test.remove('ZHAO');
	test.remove('CHA');
	test.remove('CHANG');
	test.remove('CAI');
	test.remove('CHEN');
	test.remove('CAO');
	test.remove('CHAO');
	test.remove('LONG');
	test.remove('LI');
	
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LinkedListHashTable = exports.HashTable = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LinkedList = __webpack_require__(68);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hashSize = buildHashSize(977, 20); /**
	                                        * HashTable
	                                        * Created by Luke on 2014/12/30.
	                                        */
	
	/**
	哈希(散列)查找
	
	基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。
	
	基本概念
	
	哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数。
	哈希函数是一种映象，是从关键字空间到存储地址空间的一种映象。可写成：addr(ai)=H(ki) ，其中i是表中一个元素，addr(ai)是ai的地址， ki是ai的关键字。
	
	哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表。
	
	哈希查找(又叫散列查找)：利用哈希函数进行查找的过程叫哈希查找。
	
	冲突：对于不同的关键字ki、kj，若kikj，但H(ki)=H(kj)的现象叫冲突(collision) 。
	
	同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。
	哈希函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；当冲突发生时，应该有处理冲突的方法。设计一个散列表应包括：
	①  散列表的空间范围，即确定散列函数的值域；
	②  构造合适的散列函数，使得对于所有可能的元素(记录的关键字)，函数值均在散列表的地址空间范围内，且出现冲突的可能尽量小；
	③  处理冲突的方法。即当冲突出现时如何解决。
	
	
	哈希函数的构造
	
	哈希函数是一种映象，其设定很灵活，只要使任何关键字的哈希函数值都落在表长允许的范围之内即可。哈希函数“好坏”的主要评价因素有：
	◆ 散列函数的构造简单；
	◆ 能“均匀”地将散列表中的关键字映射到地址空间。所谓“均匀”(uniform)是指发生冲突的可能性尽可能最少。
	
	1  直接定址法
	取关键字或关键字的某个线性函数作哈希地址，即H(key)=key    或   H(key)=a·key+b(a,b为常数)
	特点：直接定址法所得地址集合与关键字集合大小相等，不会发生冲突，但实际中很少使用。
	
	2  数字分析法
	对关键字进行分析，取关键字的若干位或组合作为哈希地址。
	适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。
	例： 设有80个记录，关键字为8位十进制数，哈希地址为2位十进制数。
	           
	8  1  3  4  6  5  3  2
	8  1  3  7  2  2  4  2
	8  1  3  8  7  4  2  2
	8  1  3  0  1  3  6  7
	8  1  3  2  2  8  1  7
	8  1  3  3  8  9  6  7
	8  1  3  6  8  5  3  7
	8  1  4  1  9  3  5  5
	分析：  只取8
	       只取1
	       只取3、4
	       只取2、7、5
	      数字分布近乎随机
	所以：取任意两位或两位与另两位的叠加作哈希地址
	
	3  平方取中法
	将关键字平方后取中间几位作为哈希地址。
	一个数平方后中间几位和数的每一位都有关，则由随机分布的关键字得到的散列地址也是随机的。散列函数所取的位数由散列表的长度决定。这种方法适于不知道全部关键字情况，是一种较为常用的方法。
	
	4  折叠法
	将关键字分割成位数相同的几部分(最后一部分可以不同)，然后取这几部分的叠加和作为哈希地址。
	数位叠加有移位叠加和间界叠加两种。
	◆ 移位叠加：将分割后的几部分低位对齐相加。
	◆ 间界叠加：从一端到另一端沿分割界来回折迭，然后对齐相加。
	适于关键字位数很多，且每一位上数字分布大致均匀情况。
	例： 设关键字为0442205864，哈希地址位数为4 。两种不同的地址计算方法如下：
	    5864                        5864
	    4220                        0224
	      04       移位叠加            04           间界叠加
	 ---------                  -------------
	   10088                        6091
	
	5  除留余数法
	取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p     (p<=m)
	是一种简单、常用的哈希函数构造方法。
	利用这种方法的关键是p的选取，p选的不好，容易产生同义词。p的选取的分析：
	◆  选取p=2i(p<=m)：运算便于用移位来实现，但等于将关键字的高位忽略而仅留下低位二进制数。高位不同而低位相同的关键字是同义词。
	◆ 选取p=q*f(q、f都是质因数，p<=m)：则所有含有q或f因子的关键字的散列地址均是q或f的倍数。
	◆ 选取p为素数或p=q*f(q、f是质数且均大于20，p<=m)：常用的选取方法，能减少冲突出现的可能性。
	
	6  随机数法
	取关键字的随机函数值作哈希地址，即H(key)=random(key)
	当散列表中关键字长度不等时，该方法比较合适。
	
	
	
	选取哈希函数，考虑以下因素
	◆ 计算哈希函数所需时间；
	◆ 关键字的长度；
	◆ 哈希表长度（哈希地址范围）；
	◆ 关键字分布情况；
	◆ 记录的查找频率。
	
	
	
	冲突处理的方法
	冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。
	
	1  开放定址法
	基本方法：当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。散列地址的计算公式是：
	Hi(key)=(H(key)+di)  MOD m，i=1, 2, …, k(k<=m-1)
	
	其中：H(key)：哈希函数；m：散列表长度；
	di：第i次探测时的增量序列；
	Hi(key) ：经第i次探测后得到的散列地址。
	
	⑴  线性探测法
	将散列表T[0 …m-1]看成循环向量。当发生冲突时，从初次发生冲突的位置依次向后探测其他的地址。
	增量序列为：di=1, 2, 3, …, m-1
	设初次发生冲突的地址是h，则依次探测T[h+1]，T[h+2]…，直到T[m-1]时又循环到表头，再次探测T[0]，T[1]…，直到T[h-1]。探测过程终止的情况是：
	◆ 探测到的地址为空：表中没有记录。若是查找则失败；若是插入则将记录写入到该地址；
	◆ 探测到的地址有给定的关键字：若是查找则成功；若是插入则失败；
	◆ 直到T[h]：仍未探测到空地址或给定的关键字，散列表满。
	
	例1 ：设散列表长为7，记录关键字组为：15, 14, 28, 26, 56, 23，散列函数：H(key)=key   MOD  7，冲突处理采用线性探测法。
	H(15)=15  MOD 7=1
	H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0  冲突   H1(28)=1  又冲突
	H2(28)=2           H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=2   又冲突    H3(56)=3
	H(23)=23  MOD 7=2     冲突      H1(23)=3     又冲突
	H3(23)=4
	
	0     1      2      3      4       5     6
	14    15     28     56     23      26
	
	线性探测法的特点
	◆ 优点：只要散列表未满，总能找到一个不冲突的散列地址；
	◆ 缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而又增加了更多的冲突机会(这种现象称为冲突的“聚集”)。
	
	⑵  二次探测法
	增量序列为：di=1²,-1²,2²,-2²,3²,……±k²  (k<=⌊m/2⌋)
	
	上述例题若采用二次探测法进行冲突处理，则：
	H(15)=15  MOD 7=1         H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0     冲突      H1(28)=1     又冲突
	H2(28)=4
	H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=0   又冲突    H3(56)=4    又冲突
	H4(56)=2
	H(23)=23  MOD 7=2      冲突
	H1(23)=3
	
	二次探测法的特点
	◆ 优点：探测序列跳跃式地散列到整个表中，不易产生冲突的“聚集”现象；
	◆ 缺点：不能保证探测到散列表的所有地址。
	
	⑶   伪随机探测法
	增量序列使用一个伪随机函数来产生一个落在闭区间[1，m-1]的随机序列。
	
	例2 ： 表长为11的哈希表中已填有关键字为17，60，29的记录，散列函数为H(key)=key  MOD  11 。 现有第4个记录，其关键字为38，按三种处理冲突的方法，将它填入表中。
	
	(1)  H(38)=38 MOD 11=5    冲突
	     H1=(5+1) MOD 11=6    冲突
	     H2=(5+2) MOD 11=7    冲突
	     H3=(5+3) MOD 11=8    不冲突
	(2)  H(38)=38 MOD 11=5      冲突
	     H1=(5+1²) MOD 11=6    冲突
	     H2=(5-1²) MOD 11=4     不冲突
	(3)  H(38)=38 MOD 11=5    冲突
	     设伪随机数序列为9，则H1=(5+9) MOD 11=3 不冲突
	
	
	2  再哈希法
	构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即：Hi=RHi(key)     i=1, 2, …, k
	RHi ：一组不同的哈希函数。第一次发生冲突时，用RH1计算，第二次发生冲突时，用RH2计算…依此类推知道得到某个Hi不再冲突为止。
	◆  优点：不易产生冲突的“聚集”现象；
	◆  缺点：计算时间增加。
	
	
	3  链地址法
	方法：将所有关键字为同义词(散列地址相同)的记录存储在一个单链表中，并用一维数组存放链表的头指针。
	设散列表长为m，定义一个一维指针数组：
	RecNode *linkhash[m]，其中RecNode是结点类型，每个分量的初值为空。凡散列地址为k的记录都插入到以linkhash[k]为头指针的链表中，插入位置可以在表头或表尾或按关键字排序插入。
	
	例： 已知一组关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79) ，哈希函数为：H(key)=key MOD 13，用链地址法处理冲突:
	
	 0
	 1  --> 14 -> 1 -> 27 -> 79
	 2
	 3  --> 68 -> 55
	 4
	 5
	 6  --> 19 -> 84
	 7  --> 20
	 8
	 9
	 10 --> 23 -> 10
	 11 --> 11
	 12
	
	 优点：不易产生冲突的“聚集”；删除记录也很简单。
	
	
	 4  建立公共溢出区
	 方法：在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。
	 设散列表长为m，设立基本散列表hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。
	
	 例： 已知一组关键字(15, 4, 18, 7, 37, 47) ，散列表长度为7 ，哈希函数为：H(key)=key MOD 7，用建立公共溢出区法处理冲突。得到的基本表和溢出表如下：
	                    散列地址    0     1     2     3     4     5     6
	 Hashtable表：
	                    关键字     7     15    37          4     47
	
	                    溢出地址    0     1     2     3     4     5     6
	 overtable表：
	                     关键字    18
	
	
	
	
	 哈希查找过程及分析
	
	 1   哈希查找过程
	 哈希表的主要目的是用于快速查找，且插入和删除操作都要用到查找。由于散列表的特殊组织形式，其查找有特殊的方法。
	
	 给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定关键字相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直到哈希表中某个位置为空或者表中所填记录的关键字等于给定值时为止。
	
	
	
	 哈希查找分析
	
	 从哈希查找过程可见：尽管散列表在关键字与记录的存储地址之间建立了直接映象，但由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用ASL。
	 哈希查找时关键字与给定值比较的次数取决于：
	 ◆ 哈希函数；
	 ◆ 处理冲突的方法；
	 ◆ 哈希表的填满因子α 。填满因子α的定义是：
	
	 α = 表中填入的记录数 / 哈希表长度
	
	
	 各种散列函数所构造的散列表的ASL如下：
	
	 ⑴   线性探测法的平均查找长度是：
	 S成功 约等于 1 / 2 * (1 + 1 / (1 - α))
	 S失败 约等于 1 / 2 * (1 + 1 / (1 - α) * (1 - α))
	
	 ⑵   二次探测、伪随机探测、再哈希法的平均查找长度是：
	 S成功 约等于 -1 / α * ln(1 - α)
	 S失败 约等于 1 / (1 - α)
	
	 ⑶   用链地址法解决冲突的平均查找长度是：
	 S成功 约等于 1 + α / 2
	 S失败 约等于 α + e的-α次幂
	
	
	 */
	
	var HashTable = exports.HashTable = function () {
	    function HashTable() {
	        (0, _classCallCheck3.default)(this, HashTable);
	
	        this.data = [];
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	    }
	
	    // 使用线性探测法解决冲突
	
	
	    (0, _createClass3.default)(HashTable, [{
	        key: 'search',
	        value: function search(key) {
	            var max = hashSize[this.sizeIndex];
	            var p = hash(key, max);
	            var c = 0;
	
	            while (p < max && this.data[p] != null && key !== this.data[p]) {
	                p = collision(key, ++c, max);
	            }
	
	            return {
	                success: key === this.data[p],
	                collisionTimes: c,
	                index: p
	            };
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            var max = hashSize[this.sizeIndex];
	            if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	            var ret = this.search(key);
	            var p = ret.index;
	            var c = ret.collisionTimes;
	
	            if (ret.success) return false;else if (c < hashSize[this.sizeIndex] / 2) {
	                this.data[p] = key;
	                ++this.count;
	                return true;
	            } else {
	                this.recreateHashTable();
	                return false;
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            if (!this.count) return false;
	
	            var max = hashSize[this.sizeIndex];
	            var p = hash(key, max);
	            var c = 0;
	
	            while (key !== this.data[p]) {
	                p = collision(key, ++c, max);
	            }if (key === this.data[p]) {
	                var data = this.data[p];
	                this.data.splice(p, 1);
	                --this.count;
	
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'recreateHashTable',
	        value: function recreateHashTable() {
	            return ++this.sizeIndex < hashSize.length;
	        }
	    }]);
	    return HashTable;
	}();
	
	;
	
	// ELFhash字符串散列函数
	function hash(str, max) {
	    var hash = 0;
	    for (var i = 0; i < str.length; i++) {
	        hash = (hash << 5) + hash + str.charCodeAt(i);
	        hash = hash & hash; // Convert to 32bit integer
	        hash = Math.abs(hash);
	    }
	    return hash % max;
	}
	
	function collision(key, times, max) {
	    // 线性探测法
	    return (hash(key, max) + times) % max;
	}
	
	function isPrime(n) {
	    if (n <= 3) return n > 1;
	    if (n % 2 === 0 || n % 3 === 0) return false;
	    for (var i = 5; i * i <= n; i += 6) {
	        if (n % i === 0 || n % (i + 2) === 0) return false;
	    }
	
	    return true;
	}
	
	function buildHashSize(begin, length) {
	    var hashSize = [];
	
	    while (1) {
	        if (hashSize.length >= length) break;
	        if (isPrime(begin)) hashSize.push(begin);
	        ++begin;
	    }
	
	    return hashSize;
	}
	
	// 开放定址法
	//hashSize = [5, 7]; // for test. will be deleted
	var test = new HashTable();
	test.insert('17');
	test.insert('60');
	test.insert('29');
	test.insert('38');
	test.insert('39');
	test.insert('40');
	
	test.remove('17');
	test.remove('60');
	test.remove('29');
	test.remove('38');
	test.remove('39');
	test.remove('40');
	
	// 使用链地址法解决冲突的哈希表
	
	var LinkedListHashTable = exports.LinkedListHashTable = function () {
	    function LinkedListHashTable() {
	        (0, _classCallCheck3.default)(this, LinkedListHashTable);
	
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	        this.hNodes = [];
	    }
	
	    (0, _createClass3.default)(LinkedListHashTable, [{
	        key: 'search',
	        value: function search(key) {
	            var max = hashSize[this.sizeIndex];
	            var i = hash(key, max);
	            var t = this.hNodes;
	
	            if (t[i] == null) return { success: false, index: i };
	
	            var p = t[i];
	            var data = null;
	
	            p.each(function (node) {
	                if (node.data === key) {
	                    data = node.data;
	                    return true;
	                }
	            });
	
	            return { success: data === key, index: i };
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            var max = hashSize[this.sizeIndex];
	            if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	            var ret = this.search(key);
	            var index = ret.index;
	
	            if (ret.success) return false;
	
	            if (!this.hNodes[index]) this.hNodes[index] = new _LinkedList2.default();
	
	            if (this.hNodes[index].size() < hashSize[this.sizeIndex] / 2) {
	                this.hNodes[index].orderInsert(key);
	                ++this.count;
	                return true;
	            } else {
	                this.recreateHashTable();
	                return false;
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            if (!this.count) return false;
	
	            var ret = this.search(key);
	
	            if (ret.success) {
	                var index = ret.index;
	                var data = ret.data;
	                this.hNodes[index]['remove'](key);
	                --this.count;
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'recreateHashTable',
	        value: function recreateHashTable() {
	            return ++this.sizeIndex < hashSize.length;
	        }
	    }]);
	    return LinkedListHashTable;
	}();
	
	;
	
	var test2 = new LinkedListHashTable();
	test2.insert('17');
	test2.insert('60');
	test2.insert('29');
	test2.insert('38');
	test2.insert('39');
	test2.insert('40');
	
	test2.remove('17');
	test2.remove('60');
	test2.remove('29');
	test2.remove('38');
	test2.remove('39');
	test2.remove('40');

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _getPrototypeOf = __webpack_require__(17);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(25);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(24);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinarySortedTree = __webpack_require__(70);
	
	var _BinarySortedTree2 = _interopRequireDefault(_BinarySortedTree);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RED = 'red'; /**
	                  * Red Black Tree
	                  * Created by Luke on 2014/12/30.
	                  */
	/*
	 http://blog.csdn.net/v_july_v/article/details/6105630
	
	 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
	 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
	
	 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。
	
	 红黑树的5个性质：
	 1.每个结点要么是红的要么是黑的。
	 2.根结点是黑的。
	 3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
	 4.如果一个结点是红的，那么它的两个儿子都是黑的。
	 5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
	
	 正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。
	
	
	 树的旋转
	
	当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。
	
	树的旋转分为左旋和右旋
	
	树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。
	
	
	红黑树的插入
	
	如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。
	但当遇到下述3种情况时又该如何调整呢？
	● 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况
	对此，我们的解决策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	于是，插入修复情况1转换成了插入修复情况2
	
	● 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	从而插入修复情况2转换成了插入修复情况3。
	
	● 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。
	
	经过上面情况3、情况4、情况5等3种插入修复情况的操作示意图，读者自会发现，后面的情况4、情况5都是针对情况3插入节点4以后，进行的一系列插入修复情况操作，不过，指向当前节点N指针一直在变化。所以，你可以想当然的认为：整个下来，情况3、4、5就是一个完整的插入修复情况的操作流程
	
	
	红黑树的删除
	
	在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。
	
	上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。
	
	 如果是以下情况，恢复比较简单：
	 a)当前节点是红+黑色
	 解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
	 b)当前节点是黑+黑且是根节点， 解法：什么都不做，结束。
	
	 但如果是以下情况呢？：
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
	 此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。
	
	 下面，咱们便来分别处理这4种删除修复情况。
	
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。
	
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变）
	
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持
	
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	
	
	 最后值得一提的是上述删除修复的情况1~4都只是树的局部，并非树的整体全部，且删除修复情况3、4在经过上面的调整后，调整还没结束,还得继续调整直至重新恢复平衡
	*/
	
	var BLACK = 'black';
	
	var RedBlackNode = function (_BSTNode) {
	    (0, _inherits3.default)(RedBlackNode, _BSTNode);
	
	    function RedBlackNode() {
	        var _Object$getPrototypeO;
	
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        (0, _classCallCheck3.default)(this, RedBlackNode);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(RedBlackNode)).call.apply(_Object$getPrototypeO, [this, data].concat(rest)));
	
	        _this.leftChild = null;
	        _this.rightChild = null;
	        _this.parent = null;
	
	        _this.color = RED;
	        _this.data = data;
	        return _this;
	    }
	
	    return RedBlackNode;
	}(_BinarySortedTree2.default);
	
	var RedBlackLeaf = function RedBlackLeaf() {
	    (0, _classCallCheck3.default)(this, RedBlackLeaf);
	
	    this.color = BLACK;
	    this.leftChild = this;
	    this.rightChild = this;
	};
	
	var RedBlackTree = function () {
	    function RedBlackTree() {
	        (0, _classCallCheck3.default)(this, RedBlackTree);
	
	        // 哨兵
	        this.nil = new RedBlackLeaf();
	        this.root = this.nil;
	    }
	
	    /**
	     * 红黑树的递归查找算法
	     * @param data
	     */
	
	
	    (0, _createClass3.default)(RedBlackTree, [{
	        key: 'find',
	        value: function find(data) {
	            var z = this.root;
	            var me = this;
	
	            return function find(z, data) {
	                if (z == me.nil || data === z.data) return z;
	
	                if (data < z.data) return find(z.leftChild, data);else return find(z.rightChild, data);
	            }(z, data);
	        }
	
	        /**
	         * 红黑树的插入
	         * @param {*} data
	         */
	
	    }, {
	        key: 'add',
	        value: function add(data) {
	            var z = new RedBlackNode(data);
	            z.leftChild = this.nil;
	            z.rightChild = this.nil;
	            var y = this.nil;
	            var x = this.root;
	
	            // 找到要插入位置的结点y
	            while (x != this.nil) {
	                y = x;
	
	                if (z.data < x.data) x = x.leftChild;else x = x.rightChild;
	            }
	
	            z.parent = y;
	
	            // 如果y不是根结点，根据大小插入到左或右子树
	            if (y != this.nil) {
	                if (z.data < y.data) y.leftChild = z;else y.rightChild = z;
	            }
	            // 否则插入到根结点
	            else this.root = z == this.nil ? null : z;
	
	            // 插入修复操作
	            this._addFixup(z);
	        }
	
	        /**
	         * 插入算法修复
	         * @param {RedBlackNode} z 待插入的结点
	         * @private
	         */
	
	    }, {
	        key: '_addFixup',
	        value: function _addFixup(z) {
	
	            while (z != this.root && z.parent.color === RED) {
	                if (z.parent == z.parent.parent.leftChild) leftAddFixup(this, z);else rightAddFixup(this, z);
	            }
	
	            // 最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡
	            this.root.color = BLACK;
	        }
	
	        /**
	         * 红黑树的删除算法
	         * @param {RedBlackNode} z 待删除结点
	         */
	
	    }, {
	        key: 'removeNode',
	        value: function removeNode(z) {
	            var x = void 0,
	                y = void 0;
	
	            // 找到待删除结点的父结点或相邻待替换结点
	            if (z.leftChild == this.nil || z.rightChild == this.nil) y = z;else y = this.successor(z);
	
	            if (y.leftChild != this.nil) x = y.leftChild;else x = y.rightChild;
	
	            x.parent = y.parent;
	
	            // 删除操作
	            if (y.parent == this.nil) this.root = x;else if (y == y.parent.leftChild) y.parent.leftChild = x;else y.parent.rightChild = x;
	
	            if (y != z) z.data = y.data;
	
	            // 删除修复
	            if (y.color === BLACK) this._removeFixup(x);
	        }
	
	        // 算法导论上的删除结点
	
	    }, {
	        key: 'removeNode2',
	        value: function removeNode2(z) {
	            var y = z;
	            var originalYColor = y.color;
	            var x = void 0;
	
	            if (z.leftChild == this.nil) {
	                x = z.rightChild;
	                this._transplant(z, z.rightChild);
	            } else if (z.rightChild == this.nil) {
	                x = z.leftChild;
	                this._transplant(z, z.leftChild);
	            } else {
	                y = this.min(z.rightChild);
	                originalYColor = y.color;
	                x = y.rightChild;
	
	                if (y.parent == z) x.parent = y;else {
	                    this._transplant(y, y.rightChild);
	                    y.rightChild = z.rightChild;
	                    y.rightChild.parent = y;
	                }
	
	                this._transplant(z, y);
	                y.leftChild = z.leftChild;
	                y.leftChild.parent = y;
	                y.color = z.color;
	            }
	
	            if (originalYColor === BLACK) this._removeFixup(x);
	        }
	    }, {
	        key: '_transplant',
	        value: function _transplant(u, v) {
	            if (u.parent == this.nil) this.root = v;else if (u == u.parent.leftChild) u.parent.leftChild = v;else u.parent.rightChild = v;
	
	            v.parent = u.parent;
	        }
	
	        /**
	         * 删除修复
	         * @param {RedBlackNode} z
	         * @private
	         */
	
	    }, {
	        key: '_removeFixup',
	        value: function _removeFixup(z) {
	            while (z !== this.root && z.color === BLACK) {
	                if (z == z.parent.leftChild) leftRemoveFixup(this, z);else rightRemoveFixup(this, z);
	            }
	
	            z.color = BLACK;
	        }
	    }, {
	        key: 'successor',
	        value: function successor(z) {
	            if (z.rightChild != this.nil) return this.min(z.rightChild);
	
	            var y = z.parent;
	
	            while (y != this.nil && z == y.rightChild) {
	                z = y;
	                y = y.parent;
	            }
	
	            return y;
	        }
	    }, {
	        key: 'min',
	        value: function min(z) {
	            while (z.leftChild != this.nil) {
	                z = z.leftChild;
	            }
	
	            return z;
	        }
	
	        /**
	         * 根据key值删除结点
	         * @param {*} key
	         * @returns {*}
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            var z = this.find(key);
	
	            if (z == this.nil) return false;
	
	            return this.removeNode(z);
	        }
	    }]);
	    return RedBlackTree;
	}();
	
	exports.default = RedBlackTree;
	
	
	RedBlackTree.prototype._rotateLeft = rotate('left');
	RedBlackTree.prototype._rotateRight = rotate('right');
	
	function rotate(dir) {
	    var c1 = void 0,
	        c2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	    }
	
	    return function (x) {
	        var y = x[c1];
	        x[c1] = y[c2];
	
	        if (y[c2] != this.nil) y[c2].parent = x;
	        y.parent = x.parent;
	
	        if (x.parent == this.nil) this.root = y;else if (x == x.parent[c2]) x.parent[c2] = y;else x.parent[c1] = y;
	
	        y[c2] = x;
	        x.parent = y;
	    };
	}
	
	function addFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        rotate1 = void 0,
	        rotate2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        rotate1 = '_rotateLeft';
	        rotate2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        rotate1 = '_rotateRight';
	        rotate2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var y = z.parent.parent[c1];
	
	        // 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	        // 将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	        if (y.color === RED) {
	            z.parent.color = BLACK;
	            y.color = BLACK;
	            z.parent.parent.color = RED;
	            z = z.parent.parent;
	        } else {
	            // 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	            // 解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	            // 从而插入修复情况2转换成了插入修复情况3。
	            if (z === z.parent[c1]) {
	                z = z.parent;
	                tree[rotate1](z);
	            }
	
	            // 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	            // 解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	            z.parent.color = BLACK;
	            z.parent.parent.color = RED;
	            tree[rotate2](z.parent.parent);
	        }
	    };
	}
	
	var leftAddFixup = addFixup('left');
	var rightAddFixup = addFixup('right');
	var leftRemoveFixup = removeFixup('left');
	var rightRemoveFixup = removeFixup('right');
	
	function removeFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        r1 = void 0,
	        r2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        r1 = '_rotateLeft';
	        r2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        r1 = '_rotateRight';
	        r2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var w = z.parent[c1];
	
	        // 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	        // 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法
	        if (w.color === RED) {
	            w.color = BLACK;
	            z.parent.color = RED;
	            tree[r1](z.parent);
	            w = z.parent[c1];
	        }
	
	        // 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	        // 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。
	        if (w[c2].color === BLACK && w[c1].color === BLACK) {
	            w.color = RED;
	            z = z.parent;
	        } else {
	            // 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	            // 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。
	            if (w[c1].color === BLACK) {
	                w[c2].color = BLACK;
	                w.color = RED;
	                tree[r2](w);
	                w = z.parent[c1];
	            }
	
	            // 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	            // 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	            w.color = z.parent.color;
	            z.parent.color = BLACK;
	            w[c1].color = BLACK;
	            tree[r1](z.parent);
	            z = tree.root;
	        }
	    };
	}
	
	var test = new RedBlackTree();
	test.add(13);
	test.add(8);
	test.add(17);
	test.add(1);
	test.add(6);
	test.add(11);
	test.add(15);
	test.add(22);
	test.add(25);
	test.add(27);
	
	test.remove(13);
	test.remove(8);
	test.remove(17);
	test.remove(1);
	test.remove(6);
	test.remove(11);
	test.remove(15);
	test.remove(22);
	test.remove(25);
	test.remove(27);

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.secondOptimal = secondOptimal;
	exports.createSOSTree = createSOSTree;
	
	var _BinaryTree = __webpack_require__(22);
	
	/**
	 * 由有序表sTable[low..high]及其累计权值表weights递归构造次优查找树
	 * @param {BinaryTree} tree
	 * @param {Array} sTable
	 * @param {Array} sWeights
	 * @param {Number} low
	 * @param {Number} high
	 */
	function secondOptimal(tree, sTable, sWeights, low, high) {
	    var i = low;
	    var min = Math.abs(sWeights[high] - sWeights[low]);
	    var dw = sWeights[high] + (sWeights[low - 1] || 0);
	
	    // 选择最小的△Pi值
	    for (var j = low + 1; j <= high; ++j) {
	        var t = Math.abs(dw - sWeights[j] - sWeights[j - 1]);
	        if (t < min) {
	            i = j;
	            min = t;
	        }
	    }
	
	    // 调整树根权，选择邻近权值较大的关键字
	    var a = 0,
	        b = void 0,
	        c = 0;
	    if (i - 1 >= low) b = sWeights[i] - sWeights[i - 1];
	    if (i - 2 >= low) a = sWeights[i - 1] - sWeights[i - 2];
	    if (i + 1 < high) c = sWeights[i + 1] - sWeights[i];
	    if (typeof b === 'number') {
	        if (a > c && a > b) --i;else if (a < c && c > b) ++i;
	    }
	
	    tree.data = sTable[i];
	    //左子树
	    if (i === low) tree.leftChild = null;else {
	        tree.leftChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.leftChild, sTable, sWeights, low, i - 1);
	    }
	    // 右子树
	    if (i === high) tree.rightChild = null;else {
	        tree.rightChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.rightChild, sTable, sWeights, i + 1, high);
	    }
	} /*
	   静态次优查找树
	  
	   适合各记录的查找概率不等的情况
	  
	   查找效率最高即平均查找长度最小，我们可以给出有序表在非等概率情况下应遵循的两个原则：
	   1、最先访问的结点应是访问概率最大的结点；
	   2、每次访问应使结点两边尚未访问的结点的被访概率之和尽可能相等。
	  
	  
	   这两个原则可用一句话来表示，即判定树为带权内路径长度之和最小的二叉树，亦即：PH = ∑wihi  最小，其中 n 为有序表长度，hi 为第 i 个结点在判定树上的层次数，wi = cpi，c 为某个常数，pi 为第 i 个结点的查找概率。
	  
	  
	   这样的树称为静态最优查找树（static optimal search tree），构造这样一棵树的时间代价太大，亦即时间复杂度很大，因此我们通常是构造次优查找树（nearly optimal search tree），构造它的时间代价远远低于构造最优查找树，但查找性能只比最优查找树差1%~2%，很少差3%以上。
	  
	   次优查找树的构造：
	  
	   设有序表每个记录的权值为 wl,wl+1,…,wh，第一个应访问的结点号为 i ，则有：
	   Δpi =   ∑wj - ∑wj   最小，即 Δpi = Min {Δpj }
	   再分别对 {rl,rl+1,…,ri-1} 和 {ri+1,ri+2,…,rh} 分别构造次优查找树
	   */
	
	
	var tree = new _BinaryTree.BinaryTree();
	secondOptimal(tree, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'], [1, 2, 4, 9, 12, 16, 20, 23, 28], 0, 8);
	console.log(tree);
	
	/**
	 * 由有序表构造一棵次优查找树
	 * @param {Object} obj 有序表，数据元素含有权域weight
	 */
	function createSOSTree(obj) {
	    var tree = void 0;
	    if (obj.elems.length === 0) tree = null;else {
	        // 求累计权值表
	        var sw = findSW(obj.weights);
	        tree = new _BinaryTree.BinaryTree();
	        secondOptimal(tree, obj.elems, sw, 0, obj.elems.length - 1);
	    }
	
	    return tree;
	}
	
	function findSW(sTable) {
	    var sw = [sTable[0]];
	
	    for (var i = 1; i < sTable.length; ++i) {
	        sw[i] = sw[i - 1] + sTable[i];
	    }
	
	    return sw;
	}
	
	var sosTree = createSOSTree({
	    elems: ['A', 'B', 'C', 'D', 'E'],
	    weights: [1, 30, 2, 29, 3]
	});
	sosTree.inOrderRecursive(function (value) {
	    console.log('inOrder: ' + value);
	});

/***/ },
/* 159 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = fibonacciSearch;
	/*
	 Fibonacci查找
	
	 Fibonacci查找方法是根据Fibonacci数列的特点对查找表进行分割。Fibonacci数列的定义是：
	 F(0)=0，F(1)=1，F(j)=F(j-1)+F(j-2) 。
	
	 1  查找思想
	 设查找表中的记录数比某个Fibonacci数小1，即设n=F(j)-1。用Low、High和Mid表示待查找区间的下界、上界和分割位置，初值为Low=0，High=n - 1。
	 ⑴   取分割位置Mid：Mid=F(j-1) ；
	 ⑵   比较分割位置记录的关键字与给定的K值：
	 ① 相等： 查找成功；
	 ②  大于：待查记录在区间的前半段(区间长度为F(j-1)-1)，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段(区间长度为F(j-2)-1)，修改下界指针：Low=Mid+1，转⑴ ；直到越界(Low>High)，查找失败。
	
	 2  算法实现
	 在算法实现时，为了避免频繁计算Fibonacci数，可用两个变量f1和f2保存当前相邻的两个Fibonacci数，这样在以后的计算中可以依次递推计算出。
	
	 3  算法分析
	 由算法知，Fibonacci查找在最坏情况下性能比折半查找差，但平均搜索次数少于折半查找，而且折半查找要求记录按关键字有序；Fibonacci查找的优点是分割时只需进行加、减运算。
	
	 */
	
	function fib(n) {
	    if (n === 0) return 0;
	    if (n === 1) return 1;
	    var f = void 0;
	    var f0 = 0;
	    var f1 = 1;
	    for (var i = 2; i <= n; ++i) {
	        f = f0 + f1;
	        f0 = f1;
	        f1 = f;
	    }
	    return f;
	}
	
	/**
	 * 在有序表ST中用Fibonacci方法查找关键字为key的记录
	 * @param sTable
	 * @param key
	 * @param n
	 */
	function fibonacciSearch(sTable, key) {
	    var n = arguments.length <= 2 || arguments[2] === undefined ? sTable.length : arguments[2];
	
	    var low = 0;
	    var high = n - 1;
	    var f1 = fib(n);
	    var f2 = fib(n - 1);
	
	    while (low <= high) {
	        var mid = low + f1 - 1;
	        if (sTable[mid] === key) return mid;else if (key < sTable[mid]) {
	            high = mid - 1;
	            f2 = f1 - f2;
	            f1 = f1 - f2;
	        } else {
	            low = mid + 1;
	            f1 = f1 - f2;
	            f2 = f2 - f1;
	        }
	    }
	    return -1;
	}
	
	console.log('fibonacciSearch: ');
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 5)); // 4
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 160 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = sequentialSearch;
	/*
	 静态查找
	
	 线性表是查找表最简单的一种组织方式
	
	 顺序查找(Sequential Search)
	 1  查找思想
	 从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。
	
	 2  算法分析
	 不失一般性，设查找每个记录成功的概率相等，即Pi=1/n；查找第i个元素成功的比较次数Ci=n-i；
	 ◆ 查找成功时的平均查找长度ASL：(n+1)/2
	 ◆ 包含查找不成功时：查找失败的比较次数为n，若成功与不成功的概率相等，对每个记录的查找概率为Pi=1/(2n)，则平均查找长度ASL：3（n+1）/4
	 */
	
	function sequentialSearch(sTable, key) {
	  for (var i = sTable.length - 1; i >= 0 && sTable[i] !== key; --i) {}
	  return i;
	}
	
	console.log(sequentialSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.countSort = countSort;
	exports.radixSort = radixSort;
	
	var _index = __webpack_require__(71);
	
	/*
	 计数排序
	
	 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。
	
	 计数排序的特征
	
	 当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
	 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
	 通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：
	 1.找出待排序的数组中最大和最小的元素
	 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项
	 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
	 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
	 
	 简要分析：
	 1.计数排序仅适合于小范围的数据进行排序
	 2.不能对浮点数进行排序
	 3.时间复杂度为 O(n)
	 4.计数排序是稳定的（排序后值相同的元素相对于原先的位置是不会发生变化的）
	 */
	
	function maxElem(arr) {
	    var max = arr[0];
	
	    for (var i = 1, len = arr.length; i < len; ++i) {
	        if (max < arr[i]) max = arr[i];
	    }return max;
	}
	
	/**
	 *
	 * @param {Array} sqList 要排序的数组
	 * @param {Number} k 数组中最大的元素值
	 * @returns {Array}
	 */
	/**
	 * Created by ldp on 2015/2/18.
	 */
	
	function countSort() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var k = arguments.length <= 1 || arguments[1] === undefined ? maxElem(sqList) : arguments[1];
	
	    var len = sqList.length;
	    var c = [];
	    var b = [];
	
	    // 初始化辅助数组
	    for (var i = 0; i <= k; ++i) {
	        c[i] = 0;
	    } // 计数数组A中值等于C数组下标的个数
	    for (var _i = 0; _i < len; ++_i) {
	        c[sqList[_i]]++;
	    } // 计数数组A中值小于等于C数组下标的个数
	    for (var _i2 = 1; _i2 <= k; ++_i2) {
	        c[_i2] += c[_i2 - 1];
	    }for (var _i3 = len - 1; _i3 >= 0; --_i3) {
	        b[c[sqList[_i3]] - 1] = sqList[_i3];
	        --c[sqList[_i3]];
	    }
	
	    for (var _i4 = 0; _i4 < len; ++_i4) {
	        sqList[_i4] = b[_i4];
	    }
	}
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	countSort(arr, 100);
	console.log(arr + '');
	
	/*
	 基数排序
	
	 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。
	 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
	 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。
	
	 效率
	
	 基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，k的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。
	 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k = logB(N)，N是待排序数据类型全集的势。虽然有B个不同的数字，需要B个不同的桶，但在每一轮处理中，判断每个待排序数据项只需要一次计算确定对应数位的值，因此在每一轮处理的时候都需要平均n次操作来把整数放到合适的桶中去，所以就有：
	 k约等于logB(N)
	 所以，基数排序的平均时间T就是：
	 T～= logB(N)·n
	 其中前一项是一个与输入数据无关的常数，当然该项不一定小于logn
	 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且在适当选择的B之下，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。
	
	 假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。
	
	 基数排序的简单描述就是将数字拆分为个位十位百位，每个位依次排序。因为这对算法稳定要求高，所以我们对数位排序用到上一个排序方法计数排序。因为基数排序要经过d (数据长度)次排序， 每次使用计数排序， 计数排序的复杂度为 On),  d 相当于常量和N无关，所以基数排序也是 O(n)。基数排序虽然是线性复杂度， 即对n个数字处理了n次，但是每一次代价都比较高， 而且使用计数排序的基数排序不能进行原地排序，需要更多的内存， 并且快速排序可能更好地利用硬件的缓存， 所以比较起来，像快速排序这些原地排序算法更可取。对于一个位数有限的十进制数，我们可以把它看作一个多元组，从高位到低位关键字重要程度依次递减。可以使用基数排序对一些位数有限的十进制数排序。
	 */
	
	// 求数据的最大位数
	function maxBit(arr) {
	    var d = 1;
	    var p = 10;
	
	    for (var i = 0, n = arr.length; i < n; ++i) {
	        while (arr[i] >= p) {
	            p *= 10;
	            ++d;
	        }
	    }
	
	    return d;
	}
	
	function radixSort() {
	    var arr = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var d = arguments.length <= 1 || arguments[1] === undefined ? maxBit(arr) : arguments[1];
	
	    var n = arr.length;
	    var temp = [];
	    // 计数器
	    var count = [];
	    var radix = 1;
	
	    // 进行d次排序
	    for (var i = 1; i <= d; ++i) {
	        // 每次分配前清空计数器
	        for (var j = 0; j < 10; ++j) {
	            count[j] = 0;
	        } // 统计每个桶中的记录数
	        for (var _j = 0; _j < n; ++_j) {
	            var k = Math.floor(arr[_j] / radix) % 10;
	            ++count[k];
	        }
	        for (var _j2 = 1; _j2 < 10; ++_j2) {
	            count[_j2] += count[_j2 - 1];
	        } // 将所有桶中记录依次收集到tmp中
	        for (var _j3 = n - 1; _j3 >= 0; --_j3) {
	            var _k = Math.floor(arr[_j3] / radix) % 10;
	            temp[--count[_k]] = arr[_j3];
	        }
	        //将临时数组的内容复制到arr中
	        for (var _j4 = 0; _j4 < n; ++_j4) {
	            arr[_j4] = temp[_j4];
	        }radix *= 10;
	    }
	}
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	radixSort(arr, 100);
	console.log(arr + '');
	
	/*
	 桶排序
	
	 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。
	
	 基本思想
	
	 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
	 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。
	
	 分析
	
	 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
	 对N个关键字进行桶排序的时间复杂度分为两个部分：
	     (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
	     (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。
	 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
	     (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
	     (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。
	
	 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
	 O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
	 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。
	
	 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
	 */
	
	var BUCKETSNUM = 10;
	
	function bucketSort(sqList) {
	    var n = sqList.length;
	    var bucketA = [];
	    var b = [];
	
	    // 初始化桶
	    for (var i = 0; i < BUCKETSNUM; ++i) {
	        b[i] = [];
	        bucketA[i] = 0;
	
	        for (var j = 0; j < n; ++j) {
	            b[i][j] = Infinity;
	        }
	    }
	
	    // 给桶填装数据
	    for (var _i5 = 0; _i5 < n; ++_i5) {
	        var data = sqList[_i5];
	        // noto: 这里的映射函数是针对1-100之间的实数
	        var bucket = Math.floor(data / BUCKETSNUM);
	        b[bucket][bucketA[bucket]] = data;
	        ++bucketA[bucket];
	    }
	
	    // 针对每个桶进行快速排序
	    for (var _i6 = 0; _i6 < BUCKETSNUM; ++_i6) {
	        if (bucketA[_i6] !== 0) {
	            (0, _index.quickSort)(b[_i6], 0, bucketA[_i6] - 1);
	            //for(let j = 1; j < bucketA[i]; ++j){
	            //    let p = b[i][j];
	            //    let k;
	            //    for(k = j - 1; k >= 0 && p < b[i][k]; --k){
	            //        b[i][k + 1] = b[i][k];
	            //    }
	            //    b[i][k + 1] = p;
	            //}
	        }
	    }
	
	    //console.log(b);
	    //console.log(bucketA);
	
	    // 复制回去
	    var num = 0;
	    for (var _i7 = 0; _i7 < BUCKETSNUM; ++_i7) {
	        if (bucketA[_i7] !== 0) {
	            for (var _j5 = 0; _j5 < bucketA[_i7]; ++_j5) {
	                sqList[num++] = b[_i7][_j5];
	            }
	        }
	    }
	}
	exports.bucketSort = bucketSort;
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95];
	bucketSort(arr);
	console.log(arr + '');
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95, Infinity, Infinity, Infinity];
	(0, _index.quickSort)(arr);
	console.log(arr + '');
	
	/*
	 性能分析
	 很明显，基数排序的性能比桶排序要略差。每一次关键字的桶分配都需要O(N)的时间复杂度，而且分配之后得到新的关键字序列又需要O(N)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2N) ，当然d要远远小于N，因此基本上还是线性级别的。基数排序的空间复杂度为O(N+M)，其中M为桶的数量。一般来说N>>M，因此额外空间需要大概N个左右。
	 但是，对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，基数排序的应用范围更加广泛。
	 */

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.straightInsertSort = straightInsertSort;
	exports.binaryInsertSort = binaryInsertSort;
	exports.path2InsertSort = path2InsertSort;
	exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
	exports.shellSort = shellSort;
	
	var _StaticLinkedList = __webpack_require__(69);
	
	var _StaticLinkedList2 = _interopRequireDefault(_StaticLinkedList);
	
	var _defaultComparision = __webpack_require__(29);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 插入排序
	
	 采用的是以 “玩桥牌者”的方法为基础的。即在考察记录Ri之前，设以前的所有记录R1, R2 ,…., Ri-1已排好序，然后将Ri插入到已排好序的诸记录的适当位置
	
	 最基本的插入排序是直接插入排序(Straight Insertion Sort) 。
	
	
	 直接插入排序
	
	 1  排序思想
	 将待排序的记录Ri，插入到已排好序的记录表R1, R2 ,…., Ri-1中，得到一个新的、记录数增加1的有序表。 直到所有的记录都插入完为止。
	 设待排序的记录顺序存放在数组R[1…n]中，在排序的某一时刻，将记录序列分成两部分：
	 ◆ R[1…i-1]：已排好序的有序部分；
	 ◆ R[i…n]：未排好序的无序部分。
	 显然，在刚开始排序时，R[1]是已经排好序的。
	
	 2.算法实现
	
	 3.算法分析
	 ⑴ 最好情况：若待排序记录按关键字从小到大排列(正序)，算法中的内循环无须执行，则一趟排序时：关键字比较次数1次，记录移动次数2次(R[i]→R[0], R[0]→R[j+1])。
	 则整个排序的关键字比较次数和记录移动次数分别是：
	 比较次数：n - 1          移动次数： 2 * (n - 1)
	
	 ⑵ 最坏情况：若待排序记录按关键字从大到小排列(逆序)，则一趟排序时：算法中的内循环体执行i-1，关键字比较次数i次，记录移动次数i+1。
	 则就整个排序而言：
	 比较次数： (n - 1) * (n + 1) / 2     移动次数: (n - 1) * (n + 4) / 2
	
	 一般地，认为待排序的记录可能出现的各种排列的概率相同，则取以上两种情况的平均值，作为排序的关键字比较次数和记录移动次数，约为n2/4，则复杂度为O(n2) 。
	
	
	 */
	
	/**
	 * Created by Luke on 2015/2/2.
	 */
	
	function straightInsertSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        // 设置哨兵, 当设置sqList[-1] = sqList[i]时，经测试效率更慢
	        // 因为js里面的变量作用域在函数内的
	        var temp = sqList[i];
	        // 查找插入位置，并将记录后移
	        var j = i - 1;
	        for (; j >= 0 && comp(temp, sqList[j]) < 0; --j) {
	            sqList[j + 1] = sqList[j];
	        } // 插入到正确位置
	        sqList[j + 1] = temp;
	    }
	}
	
	var a = [7, 4, -2, 19, 13, 6];
	straightInsertSort(a);
	console.log(a + '');
	
	/*
	 其它插入排序
	
	 1  折半插入排序
	 当将待排序的记录R[i] 插入到已排好序的记录子表R[1…i-1]中时，由于R1, R2 ,…, Ri-1已排好序，则查找插入位置可以用“折半查找”实现，则直接插入排序就变成为折半插入排序。
	
	 从时间上比较，折半插入排序仅仅减少了关键字的比较次数，却没有减少记录的移动次数，故时间复杂度仍然为O(n2) 。
	
	
	 */
	
	function binaryInsertSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        var low = 0;
	        var high = i - 1;
	
	        while (low <= high) {
	            var mid = low + high >> 1;
	
	            if (comp(temp, sqList[mid]) < 0) high = mid - 1;else low = mid + 1;
	        }
	
	        for (var j = i - 1; j >= high + 1; --j) {
	            sqList[j + 1] = sqList[j];
	        }
	
	        sqList[high + 1] = temp;
	    }
	}
	
	var b = [30, 13, 70, 85, 39, 42, 6, 20];
	binaryInsertSort(b);
	console.log(b + '');
	
	/*
	 2-路插入排序
	
	 是对折半插入排序的改进，以减少排序过程中移动记录的次数。附加n个记录的辅助空间，方法是：
	 ①  另设一个数组d，L[1]赋给d[1]，将d[1]看成是排好序的序列中中间位置的记录；
	 ②  分别将L[ ]中的第i个记录依次插入到d[1]之前或之后的有序序列中，具体方法：
	 ◆  L[i].key<d[1].key： L[i]插入到d[1]之前的有序表中；
	 ◆ L[i].key≥d[1].key： L[i]插入到d[1]之后的有序表中；
	 关键点：实现时将向量d看成是循环向量，并设两个指针first和final分别指示排序过程中得到的有序序列中的第一个和最后一个记录。
	
	 在2-路插入排序中，移动记录的次数约为n2/8 。但当L[1]是待排序记录中关键字最大或最小的记录时，2-路插入排序就完全失去了优越性。
	 */
	
	function path2InsertSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var d = [sqList[0]];
	    // first、final分别指示d中排好序的记录的第1个和最后1个记录的位置。
	    var first = 0;
	    var final = 0;
	    var len = sqList.length;
	
	    for (var i = 1; i < len; ++i) {
	        var item = sqList[i];
	
	        // 待插入记录小于d中最小值，插入到d[first]之前（不需移动d数组的元素）。
	        if (comp(item, d[first]) < 0) {
	            first = (first - 1) % len;
	            d[first] = item;
	        }
	        // 待插入记录大于d中最小值，插入到d[final]之后（不需移动d数组的元素）。
	        else if (comp(item, d[final]) > 0) {
	                d[++final] = item;
	            }
	            // 待插入记录大于d中最小值，小于d中最大值，插入到d的中间（需要移动d数组的元素）。
	            else {
	                    // 移动d尾部元素以便按序插入记录。
	                    var j = final++;
	                    while (comp(item, d[j]) < 0) {
	                        d[(j + 1) % len] = d[j];
	                        j = (j - 1) % len;
	                    }
	                    d[(j + 1) % len] = item;
	                }
	    }
	
	    // 循环把d赋给sqList
	    for (var _i = 0; _i < len; ++_i) {
	        sqList[_i] = d[(_i + first) % len];
	    }
	}
	
	var c = [49, 38, 65, 13, 97, 27, 76, 5, 100, 78, 15, 15, 20];
	path2InsertSort(c);
	console.log(c + '');
	
	/*
	表插入排序
	
	前面的插入排序不可避免地要移动记录，若不移动记录就需要改变数据结构。
	初始化：下标值为0的分量作为表头结点，关键字取为最大值，各分量的指针值为空；
	①  将静态链表中数组下标值为1的分量(结点)与表头结点构成一个循环链表；
	② i=2 ，将分量R[i]按关键字递减插入到循环链表；
	③  增加i ，重复②，直到全部分量插入到循环链表。
	
	和直接插入排序相比，不同的是修改2n次指针值以代替移动记录，而关键字的比较次数相同，故时间复杂度为O(n2)。
	
	表插入排序得到一个有序链表，对其可以方便地进行顺序查找，但不能实现随机查找。为了能实现有序表的折半查找根据需要，可以对记录进行重排.
	
	重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。
	
	例子中，链表中第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记录应移至数组的第一个分量，则将list[1]和list[6]互换，并为了不中断静态链表中的链，即在继续顺链表扫描时仍能找到互换之前在list[1]中的结点，令互换之后的list[1]中的游标改为6
	
	推广至一般情况，若第i个最小关键字的结点是数组中下标为p且p > i的分量，则互换list[i]和list[p]，且令list[i]中的游标改为p；
	由于此时数组中所有小于i的分量中已是到位记录，则当p<i时，应顺链继续查找直到p>=i为止。
	 */
	
	// 表插入排序
	function staticLinkedListInsertSort(sllist) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    // 构成循环链表
	    sllist[0].cur = 1;
	    sllist[1].cur = 0;
	
	    var p = void 0,
	        q = void 0;
	    for (var i = 2, len = sllist.length; i <= len; ++i) {
	        p = 0;
	        var x = sllist[i].data;
	
	        while (sllist[p].cur && comp(sllist[sllist[p].cur].data, x) < 0) {
	            p = sllist[p].cur;
	        } // 当遇到大于当前关键字的下标时，插入到其前驱和后继的中间
	        q = sllist[p].cur;
	        sllist[p].cur = i;
	        sllist[i].cur = q;
	    }
	}
	exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
	
	// 重排静态链表，静态链表下标已排好序
	function arrange(sllist) {
	    var p = sllist[0].cur;
	
	    for (var i = 1, len = sllist.length; i < len; ++i) {
	        // 第i个记录在list中的当前位置应不小于i
	        // 找到第i个记录，并用p指示其在list中当前位置
	        while (p < i) {
	            p = sllist[p].cur;
	        } // q指向尚未调整的表尾
	        var q = sllist[p].cur;
	
	        if (p !== i) {
	            // 交换记录，使第i个记录到位
	            var temp = sllist[p];
	            sllist[p] = sllist[i];
	            sllist[i] = temp;
	            // 指向被移走的记录，使得以后可有while循环找到
	            sllist[i].cur = p;
	        }
	
	        // p指向尚未调整的表尾
	        p = q;
	    }
	}
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 52];
	var d = new _StaticLinkedList2.default();
	d.create(arr);
	staticLinkedListInsertSort(d);
	console.log(d);
	arrange(d);
	console.log(d);
	
	/*
	希尔排序
	
	希尔排序(Shell Sort，又称缩小增量法)是一种分组插入排序方法。
	
	1  排序思想
	①   先取一个正整数d1(d1<n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；
	②   取新的增量d2<d1，重复①的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。
	
	2  排序示例
	设有10个待排序的记录，关键字分别为9, 13, 8, 2, 5, 13, 7, 1, 15, 11，增量序列是5, 3, 1，希尔排序的过程:
	初始关键字序列:    9     13     8      2      5      13      7      1      15      11
	第一趟排序后:      9     7      1      2      5      13      13     8      15      11
	第二趟排序后:      2     5      1      9      7      13      11     8      15      13
	第三趟排序后:      1     2      5      7      8      9      11     13      13      15
	
	
	希尔排序的分析比较复杂，涉及一些数学上的问题，其时间是所取的“增量”序列的函数。
	
	希尔排序特点
	子序列的构成不是简单的“逐段分割”，而是将相隔某个增量的记录组成一个子序列。
	希尔排序可提高排序速度，原因是：
	◆ 分组后n值减小，n²更小，而T(n)=O(n²),所以T(n)从总体上看是减小了；
	◆ 关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序。
	
	增量序列取法
	◆ 无除1以外的公因子；
	◆ 最后一个增量值必须为1。
	
	相关资料： http://wenku.baidu.com/link?url=q7kzOxXqc0BLaGUVDY43FQOh2aX1UqBHkkYd3VMwJhJo6rv4SiU686RW3kQCSqGEKytl12S8fBOpwhq-runhX_pbZcg6BeD-miYMPgDhXxK
	 */
	
	function shellInsert(sqList, dk, comp) {
	    for (var i = dk, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        if (comp(temp, sqList[i - dk]) < 0) {
	            var j = i - dk;
	            for (; j >= 0 && comp(temp, sqList[j]) < 0; j -= dk) {
	                sqList[j + dk] = sqList[j];
	            }sqList[j + dk] = temp;
	        }
	    }
	}
	
	function shellSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var delta = createDelta(sqList.length);
	    //console.log(delta);
	    for (var k = 0, t = delta.length; k < t; ++k) {
	        shellInsert(sqList, delta[k], comp);
	    }
	}
	
	function createDelta(n) {
	    var arr = [];
	    var t = Math.log(n - 1) / Math.log(2) | 0; // Math.log(n - 1) / Math.log(2), Math.log(n + 1) / Math.log(2)
	    for (var k = 0; k <= t; ++k) {
	        arr[k] = Math.pow(2, t - k) + 1;
	    } // Math.pow(2, t - i + 1) - 1, Math.pow(2, t - i) + 1
	
	    arr[arr.length] = 1;
	
	    return arr;
	}
	
	console.log('\n\nShell Sort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	shellSort(arr);
	console.log(arr + '');

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.linkedListNaturalMergeSort = exports.naturalMergeSort = undefined;
	exports.mergeSortRecursive = mergeSortRecursive;
	exports.mergeSortNonRecursive = mergeSortNonRecursive;
	exports.natureMergeSort = natureMergeSort;
	
	var _LinkedList = __webpack_require__(68);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	var _Queue = __webpack_require__(15);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _defaultComparision = __webpack_require__(29);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 归并排序
	
	 归并(Merging) ：是指将两个或两个以上的有序序列合并成一个有序序列。若采用线性表(无论是那种存储结构)易于实现，其时间复杂度为O(m+n) 。
	 归并思想实例：两堆扑克牌，都已从小到大排好序，要将两堆合并为一堆且要求从小到大排序。
	 ◆  将两堆最上面的抽出(设为C1，C2)比较大小，将小者置于一边作为新的一堆(不妨设C1<C2)；再从第一堆中抽出一张继续与C2进行比较，将较小的放置在新堆的最下面；
	 ◆ 重复上述过程，直到某一堆已抽完，然后将剩下一堆中的所有牌转移到新堆中。
	
	 1   排序思想
	 ①  初始时，将每个记录看成一个单独的有序序列，则n个待排序记录就是n个长度为1的有序子序列；
	 ②  对所有有序子序列进行两两归并，得到n/2个长度为2或1的有序子序列——一趟归并；
	 ③  重复② ，直到得到长度为n的有序序列为止。
	
	 上述排序过程中，子序列总是两两归并，称为2-路归并排序。其核心是如何将相邻的两个子序列归并成一个子序列。设相邻的两个子序列分别为：
	 {R[k], R[k+1], …, R[m]}和{R[m+1], R[m+2],…, R[h]}，将它们归并为一个有序的子序列：
	 {DR[l], DR[l+1], …, DR[m], DR[m+1], …, DR[h] }
	
	 例：设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41，归并排序的过程。
	 初始关键字: [23]   [38]   [22]   [45]   [23]   [67]   [31]   [15]   [41]
	              |      |      |      |      |      |      |      |
	              --------      --------      --------      --------
	 一趟归并后: [23    38]    [22     45]    [23     67]    [15     31]   [41]
	                 |              |             |              |
	                 ---------------               ---------------
	 二趟归并后: [22     23      38     45]    [15     23     31     67]    [41]
	                        |                              |
	                        --------------------------------
	 三趟归并后: [15     22      23     23     31     38     45     67]    [41]
	                                       |                                |
	                                       ----------------------------------
	 四趟归并后: [15     22      23     23     31     38     41     45     67
	
	
	 2  一趟归并排序
	 一趟归并排序都是从前到后，依次将相邻的两个有序子序列归并为一个，且除最后一个子序列外，其余每个子序列的长度都相同。设这些子序列的长度为d，则一趟归并排序的过程是：
	 从j=0开始，依次将相邻的两个有序子序列
	 R[j…j+d-1]和R[j+d…j+2d-1]进行归并；每次归并两个子序列后，j后移动2d个位置，即
	 j=j+2d；若剩下的元素不足两个子序列时，分以下两种情况处理：
	 ①  剩下的元素个数>d：再调用一次上述过程，将一个长度为d的子序列和不足d的子序列进行归并；
	 ②  剩下的元素个数≤d：将剩下的元素依次复制到归并后的序列中。
	
	
	 3.算法分析
	具有n个待排序记录的归并次数是㏒2n，而一趟归并的时间复杂度为O(n)，则整个归并排序的时间复杂度无论是最好还是最坏情况均为O(n㏒2n)。在排序过程中，使用了辅助向量DR，大小与待排序记录空间相同，则空间复杂度为O(n)。归并排序是稳定的。
	
	 */
	
	var nCount = 0; /**
	                 * Created by ldp on 2015/2/7.
	                 */
	
	var nonRecursiveCount = 0;
	var recursiveCount = 0;
	
	/**
	 * 将有序的sr[s1..e1]和sr[s2..e2]归并为有序的tr[s1..e2]
	 * @param sr
	 * @param s1
	 * @param e1
	 * @param e2
	 */
	function merge(sr, s1, e1, e2) {
	    var comp = arguments.length <= 4 || arguments[4] === undefined ? _defaultComparision2.default : arguments[4];
	
	    var temp = [];
	    var i = s1;
	    var j = e1 + 1;
	    var k = 0;
	
	    while (i <= e1 && j <= e2) {
	        if (comp(sr[i], sr[j]) < 0) temp[k++] = sr[i++];else temp[k++] = sr[j++];
	    }
	    while (i <= e1) {
	        temp[k++] = sr[i++];
	    }while (j <= e2) {
	        temp[k++] = sr[j++];
	    } // 复制回去
	    for (i = s1, k = 0; i <= e2; ++i, ++k) {
	        sr[i] = temp[k];
	    }
	}
	
	/**
	 * 2-路归并排序递归算法
	 * @param {Array} sr
	 * @param {Number} s
	 * @param {Number} t
	 */
	function mergeSortRecursive(sr) {
	    var s = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var t = arguments.length <= 2 || arguments[2] === undefined ? sr.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    if (s >= t) return;
	
	    // 将sr[s..t]平分为sr[s..m]和sr[m+1..t]
	    var m = s + t >> 1;
	    // 递归地将sr[s..m]归并为有序的sr[s..m]
	    mergeSortRecursive(sr, s, m, comp);
	    // 递归地将sr[m+1..t]归并为有序的sr[m+1..t]
	    mergeSortRecursive(sr, m + 1, t, comp);
	    // 将sr[s..m]和sr[m+1..t]归并到sr[s..t];
	    merge(sr, s, m, t, comp);
	}
	
	console.log('\n\nmergeSortRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortRecursive(arr);
	console.log(arr + '');
	
	function mergeSortNonRecursive(sr) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var j = void 0,
	        k = void 0;
	    for (var d = 1, n = sr.length - 1; d < n; d *= 2) {
	        // 一趟归并排序算法
	        j = 0;
	
	        // 子序列两两归并
	        while ((k = j + 2 * d - 1) < n) {
	            merge(sr, j, j + d - 1, k, comp);
	            j = k + 1;
	        }
	
	        // 剩余元素个数超过一个子序列长度
	        if (j + d - 1 < n) merge(sr, j, j + d - 1, n, comp);
	        // 剩余子序列复制
	        else merge(sr, j, n, n, comp);
	    }
	}
	
	console.log('\nmergeSortNonRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortNonRecursive(arr);
	console.log(arr + '');
	
	// 自然合并排序
	// http://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html
	// http://www.cnblogs.com/lanke/archive/2013/01/15/2860487.html
	/*
	自然归并是归并排序的一个变形，效率更高一些，可以在归并排序非递归实现的基础上进行修改.对于已经一个已经给定数组a,通常存在多个长度大于1的已经自然排好的子数组段,因此用一次对数组a的线性扫描就可以找出所有这些排好序的子数组段,然后再对这些子数组段俩俩合并.
	 */
	
	// 扫描得到子串的函数
	function pass(sqList, rec, comp) {
	    var num = 0;
	    rec[num++] = 0;
	    var len = sqList.length;
	
	    for (var i = 1; i < len; ++i) {
	        if (comp(sqList[i], sqList[i + 1]) > 0) rec[num++] = i + 1;
	    }
	    rec[num++] = len;
	
	    return num;
	}
	
	function natureMergeSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var rec = [];
	
	    //num=2说明已经排好序了
	    //每循环一次，进行一次pass()操作
	    for (var num = pass(sqList, rec, comp); num !== 2; num = pass(sqList, rec, comp)) {
	        for (var i = 0; i + 2 < num; i += 2) {
	            merge(sqList, rec[i], rec[i + 1] - 1, rec[i + 2] - 1, comp);
	        }
	    }
	}
	
	console.log('\nnatureMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	natureMergeSort(arr);
	console.log(arr + '');
	
	console.log(recursiveCount);
	console.log(nonRecursiveCount);
	console.log(nCount);
	
	// 双向自然合并排序算法
	/*
	双向自然合并排序是根据欲排序数据局部不是升序就是降序的自然有序特点,先线性扫描出自然有序的子数组段,再进行合并排序.扫描时的有序数段长度越长,段数越少,对应合并树的层数就会越少,算法的效率越高.
	 */
	var naturalMergeSort = exports.naturalMergeSort = function () {
	    return naturalMergeSort;
	
	    function naturalMergeSort(a) {
	        var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	        var b = [];
	        var n = a.length;
	        while (!mergeRuns(a, b, n, comp)) {}
	    }
	
	    function mergeRuns(a, b, n, comp) {
	        var i = 0;
	        var k = 0;
	        var asc = true;
	        var x = void 0;
	
	        while (i < n) {
	            k = i;
	            // 找到最后一个递增序列元素
	            do {
	                x = a[i++];
	            } while (i < n && comp(x, a[i]) <= 0);
	            // 找到最后一个递减序列元素
	            while (i < n && comp(x, a[i]) >= 0) {
	                x = a[i++];
	            } // 归并递增序列和递减序列，结果可能递增或递减
	            merge(a, b, k, i - 1, asc, comp);
	            asc = !asc;
	        }
	
	        // 当k等于0时代表a已经排好序了
	        return k === 0;
	    }
	
	    function merge(a, b, low, high, asc, comp) {
	        var k = asc ? low : high;
	        var c = asc ? 1 : -1;
	        var i = low;
	        var j = high;
	
	        while (i <= j) {
	            if (comp(a[i], a[j]) <= 0) b[k] = a[i++];else b[k] = a[j--];
	            k += c;
	        }
	        for (i = k = low, j = high; i <= j; ++i, ++k) {
	            a[i] = b[k];
	        }
	    }
	}();
	
	console.log('\nnaturalMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	naturalMergeSort(arr);
	console.log(arr + '');
	
	// 链表存储结构的自然合并排序
	var linkedListNaturalMergeSort = exports.linkedListNaturalMergeSort = function () {
	    return mergeSort;
	
	    function mergeSort(linkedlist) {
	        var needReplace = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	        var comp = arguments.length <= 2 || arguments[2] === undefined ? _defaultComparision2.default : arguments[2];
	
	        if (!linkedlist) return linkedlist;
	
	        var queue = new _Queue2.default();
	        var list = linkedlist.head;
	
	        if (!list || !list.next) return linkedlist;
	
	        var u = list;
	        var t = list;
	        var v = void 0;
	        // 将递增的结点放入到队列中（会被切断）
	        for (; t; t = u) {
	            while (u && u.next && comp(u.data, u.next.data) <= 0) {
	                u = u.next;
	            }v = u;
	            u = u.next;
	            v.next = null;
	            queue.enQueue(t);
	        }
	
	        t = queue.deQueue();
	        // 合并结点
	        while (queue.size) {
	            queue.enQueue(t);
	            var a = queue.deQueue();
	            var b = queue.deQueue();
	            t = merge(a, b, comp);
	        }
	
	        if (needReplace) linkedlist.head = t;
	
	        return t;
	    }
	
	    function merge(a, b, comp) {
	        var c = new _LinkedList2.default();
	        var head = { data: null, next: null };
	        c.head = head;
	        c = c.head;
	
	        while (a && b) {
	            if (comp(a.data, b.data) < 0) {
	                c.next = a;
	                c = a;
	                a = a.next;
	            } else {
	                c.next = b;
	                c = b;
	                b = b.next;
	            }
	        }
	
	        c.next = a ? a : b;
	
	        return head.next;
	    }
	}();
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	var linkedList = new _LinkedList2.default(arr);
	linkedListNaturalMergeSort(linkedList);
	console.log(linkedList + '');

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.simpleSelectionSort = simpleSelectionSort;
	exports.heapSort = heapSort;
	
	var _defaultComparision = __webpack_require__(29);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	选择排序
	
	选择排序(Selection Sort)的基本思想是：每次从当前待排序的记录中选取关键字最小的记录表，然后与待排序的记录序列中的第一个记录进行交换，直到整个记录序列有序为止。
	
	
	简单选择排序
	
	简单选择排序(Simple Selection Sort ，又称为直接选择排序)的基本操作是：通过n-i次关键字间的比较，从n-i+1个记录中选取关键字最小的记录，然后和第i个记录进行交换，i=1, 2, … n-1 。
	1  排序示例
	例：设有关键字序列为：7, 4, -2, 19, 13, 6，直接选择排序的过程：
	初始记录的关键字：  7     4    -2     19    13    6
	    第一趟排序：  -2     4     7     19    13    6
	    第二趟排序：  -2     4     7     19    13    6
	    第三趟排序：  -2     4     6     19    13    7
	    第四趟排序：  -2     4     6     7     13    19
	    第五趟排序：  -2     4     6     7     13    19
	    第六趟排序：  -2     4     6     7     13    19
	
	2.算法分析
	整个算法是二重循环：外循环控制排序的趟数，对n个记录进行排序的趟数为n-1趟；内循环控制每一趟的排序。
	进行第i趟排序时，关键字的比较次数为n-i，则：
	比较次数： n*(n - 1) / 2
	时间复杂度是：T(n)=O(n2)
	空间复杂度是：S(n)=O(1)
	从排序的稳定性来看，直接选择排序是不稳定的。
	
	 */
	
	function simpleSelectionSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 0, len = sqList.length; i < len; ++i) {
	        var k = i;
	        for (var j = k + 1; j < len; ++j) {
	            if (comp(sqList[j], sqList[k]) < 0) k = j;
	        }if (k !== i) {
	            var temp = sqList[k];
	            sqList[k] = sqList[i];
	            sqList[i] = temp;
	        }
	    }
	} /**
	   * Created by luke on 2015/2/2.
	   */
	
	var arr = [7, 4, -2, 19, 13, 6];
	simpleSelectionSort(arr);
	console.log(arr + '');
	
	/*
	树形选择排序
	
	首先对n个记录的关键字两两进行比较，选取n/2个较小者；然后这n/2个较小者两两进行比较，选取n/4个较小者… 如此重复，直到只剩1个关键字为止。
	该过程可用一棵有n个叶子结点的完全二叉树表示，每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点的关键字就是最小的关键字。
	输出最小关键字后，根据关系的可传递性，欲选取次小关键字，只需将叶子结点中的最小关键字改为“最大值” ，然后重复上述步骤即可。
	含有n个叶子结点的完全二叉树的深度为㏒2n+1，则总的时间复杂度为O(n㏒2n) 。
	
	但这种排序方法尚有辅助存储空间较多,和最大值进行多余比较等缺点。为了弥补这些缺陷，出现了另一种选择排序---堆排序
	 */
	
	/*
	堆排序
	
	1  堆的定义
	是n个元素的序列H={k1, k2 , … kn} ，满足：
	    ki≤k2i       当2i≤n时
	    ki≤k2i+1   当2i+1≤n时
	
	由堆的定义知，堆是一棵以k1为根的完全二叉树。若对该二叉树的结点进行编号(从上到下，从左到右)，得到的序列就是将二叉树的结点以顺序结构存放，堆的结构正好和该序列结构完全一致。
	
	2  堆的性质
	    1)  堆是一棵采用顺序存储结构的完全二叉树， k1是根结点；
	    2)  堆的根结点是关键字序列中的最小(或最大)值，分别称为小(或大)根堆；
	    3)  从根结点到每一叶子结点路径上的元素组成的序列都是按元素值(或关键字值)非递减(或非递增)的；
	    4)  堆中的任一子树也是堆。
	
	利用堆顶记录的关键字值最小(或最大)的性质，从当前待排序的记录中依次选取关键字最小(或最大)的记录，就可以实现对数据记录的排序，这种排序方法称为堆排序。
	
	3  堆排序思想
	
	①  对一组待排序的记录，按堆的定义建立堆；
	②  将堆顶记录和最后一个记录交换位置，则前n-1个记录是无序的，而最后一个记录是有序的；
	③  堆顶记录被交换后，前n-1个记录不再是堆，需将前n-1个待排序记录重新组织成为一个堆，然后将堆顶记录和倒数第二个记录交换位置，即将整个序列中次小关键字值的记录调整(排除)出无序区；
	④  重复上述步骤，直到全部记录排好序为止。
	
	结论：排序过程中，若采用小根堆，排序后得到的是非递减序列；若采用大根堆，排序后得到的是非递增序列。
	
	堆排序的关键
	①  如何由一个无序序列建成一个堆？
	②  如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？
	
	4  堆的调整——筛选
	⑴ 堆的调整思想
	输出堆顶元素之后，以堆中最后一个元素替代之；然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；重复上述操作，直到是叶子结点或其关键字值小于等于左、右子树的关键字的值，将得到新的堆。称这个从堆顶至叶子的调整过程为“筛选”。
	
	注意：筛选过程中，根结点的左、右子树都是堆，因此，筛选是从根结点到某个叶子结点的一次调整过程。
	
	5  堆的建立
	利用筛选算法，可以将任意无序的记录序列建成一个堆，设R[1],R[2], …,R[n]是待排序的记录序列。
	将二叉树的每棵子树都筛选成为堆。只有根结点的树是堆。第⌊n/2⌋个结点之后的所有结点都没有子树，即以第⌊n/2⌋个结点之后的结点为根的子树都是堆。因此，以这些结点为左、右孩子的结点，其左、右子树都是堆，则进行一次筛选就可以成为堆。同理，只要将这些结点的直接父结点进行一次筛选就可以成为堆…。
	只需从第⌊n/2⌋个记录到第1个记录依次进行筛选就可以建立堆。
	
	6   堆排序算法实现
	堆的根结点是关键字最小的记录，输出根结点后，是以序列的最后一个记录作为根结点，而原来堆的左、右子树都是堆，则进行一次筛选就可以成为堆。
	
	7  算法分析
	主要过程：初始建堆和重新调整成堆。设记录数为n，所对应的完全二叉树深度为h 。
	◆  初始建堆：每个非叶子结点都要从上到下做“筛选” 。第i层结点数≤2i-1，结点下移的最大深度是h-i，而每下移一层要比较2次，则比较次数C1(n)为：
	C1(n)≤4(n-㏒2n-1)
	◆  筛选调整：每次筛选要将根结点“下沉”到一个合适位置。第i次筛选时：堆中元素个数为n-i+1；堆的深度是㏒2(n-i+1)+1，则进行n-1次“筛选”的比较次数C2(n)为：
	C2(n)<2n㏒2n
	堆排序的比较次数的数量级为： T(n)=O(n㏒2n)；而附加空间就是交换时所用的临时空间，故空间复杂度为： S(n)=O(1) 。
	
	堆排序适合记录数较大的情况
	
	
	http://blog.csdn.net/zz198808/article/details/7678055
	 */
	
	/**
	 * 已知sqList[s..m]中记录的关键字除sqList[s]之外均满足堆的定义，
	 * 本函数调整sqList[s]的关键字，使sqList[s..m]成为一个大堆顶（对其中关键字而言）
	 * @param {Array} sqList
	 * @param {Number} s
	 * @param {Number} m
	 */
	function heapAdjust(sqList, s, m, comp) {
	    var rc = sqList[s];
	
	    // 沿关键字较大的孩子结点向下筛选
	    for (var j = 2 * s + 1; j <= m; j = j * 2 + 1) {
	        // j为关键字较大的记录下标
	        if (j < m && comp(sqList[j], sqList[j + 1]) < 0) ++j;
	        // rc应插入在位置s上
	        if (comp(rc, sqList[j]) >= 0) break;
	        sqList[s] = sqList[j];
	        s = j;
	    }
	
	    sqList[s] = rc;
	}
	
	function heapSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var len = sqList.length;
	    // 建立大堆顶
	    for (var i = (len >> 1) - 1; i >= 0; --i) {
	        heapAdjust(sqList, i, len - 1, comp);
	    }for (var _i = len - 1; _i > 0; --_i) {
	        // 将堆顶记录和当前未经排序子序列sqList[0..i]中
	        // 最后一个记录相互交换
	        var temp = sqList[_i];
	        sqList[_i] = sqList[0];
	        sqList[0] = temp;
	
	        // 将sqList[0..i - 1]重新调整为大堆顶
	        heapAdjust(sqList, 0, _i - 1, comp);
	    }
	}
	
	var arr = [1, 3, 4, 5, 7, 2, 6, 8, 0];
	heapSort(arr);
	console.log(arr + '');

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 堆分配存储表示
	 *
	 * 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在c语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间。
	 */
	
	var HString = function () {
	    function HString() {
	        (0, _classCallCheck3.default)(this, HString);
	
	        this.ch = {};
	        this.length = 0;
	    }
	
	    // 1 <= position <= this.length.在串的第position个字符之前插入串tHString
	
	
	    (0, _createClass3.default)(HString, [{
	        key: 'strInsert',
	        value: function strInsert(position, tHString) {
	            if (position < 1 || position > this.length + 1) throw new Error('unexpected position');
	
	            if (tHString.length) {
	                // 为插入t而腾出位置
	                var i = this.length - 1;
	                for (var len = position - 1; i >= len; --i) {
	                    this.ch[i + tHString.length] = this.ch[i];
	                }stringCopy(this.ch, tHString.ch, position - 1, tHString.length - 1, 0);
	
	                this.length += tHString.length;
	            }
	        }
	    }, {
	        key: 'strAssign',
	        value: function strAssign(chars) {
	            stringCopy(this.ch, chars, 0, chars.length - 1, 0);
	            this.length = chars.length;
	        }
	    }, {
	        key: 'strLength',
	        value: function strLength() {
	            return this.length;
	        }
	    }, {
	        key: 'strCompare',
	        value: function strCompare(tHString) {
	            for (var i = 0, len = this.length; i < len && i < tHString.length; i++) {
	                if (this.ch[i] !== tHString.ch[i]) return this.ch[i] - tHString.ch[i];
	            }return this.length - tHString.length;
	        }
	    }, {
	        key: 'clearString',
	        value: function clearString() {
	            this.ch = {};
	            this.length = 0;
	        }
	    }, {
	        key: 'concat',
	        value: function concat(s) {
	            var t = new HString();
	
	            // t.ch[0..this.length - 1] = this.ch[0..this.length - 1]
	            stringCopy(t.ch, this.ch, 0, this.length - 1, 0);
	            t.length = this.length + s.length;
	            // t.ch[this.length..t.length - 1] = s.ch[0..s.length - 1]
	            stringCopy(t.ch, s.ch, this.length, s.length - 1, 0);
	
	            return t;
	        }
	    }, {
	        key: 'substring',
	        value: function substring(position, len) {
	            position = ~~position || 0;
	            len = ~~len || this.length;
	            if (position < 0 || position > this.length - 1 || len < 0 || len > this.length - position) throw new Error('unexpected parameter');
	
	            var sub = new HString();
	            stringCopy(sub.ch, this.ch, 0, len - 1, position);
	            sub.length = len;
	
	            return sub;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var s = '';
	            for (var i = 0, len = this.length; i < len; i++) {
	                s += this.ch[i];
	            }
	            return s;
	        }
	    }]);
	    return HString;
	}();
	
	exports.default = HString;
	
	
	function stringCopy(destination, target, destStart, length, targetStart) {
	    destStart = destStart || 0;
	    length = length || target.length;
	    targetStart = targetStart || 0;
	
	    for (var i = 0; i <= length; i++) {
	        destination[destStart + i] = target[targetStart + i];
	    }
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(23);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Chunk = function Chunk() {
	    var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	    (0, _classCallCheck3.default)(this, Chunk);
	
	    this.chunkSize = chunkSize;
	    this.ch = [];
	    for (var i = 0; i < this.chunkSize; i++) {
	        this.ch[i] = '#';
	    }
	    // type: Chunk
	    this.next = null;
	}; /**
	    * 串的块链存储表示
	    *
	    * 和线性表的链式存储结构相类似，也可采用链式方式存储串值。由于串结构的特殊性--结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。
	    * 下面是结点大小为4（即每个结点存放4个字符）的链表
	    * head --> (a,b,c,d) --> (e,f,g,h) --> (i###)
	    * 下面是结点大小为1的链表
	    * head --> (a) --> (b) --> (c) --> ... --> (i)
	    *
	    * 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其它非串值字符。
	    * 为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度，称如此定义的串存储结构为块链结构。
	    *
	    * 由于一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行连接操作，但应注意连接时需处理第一个串尾的无效字符。
	    * 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响到串处理的效率。如果串很长，这要求我们考虑串值的存储密度：
	    * 存储密度 = 串值所占的存储位 / 实际分配的存储位
	    *
	    * 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。
	    */
	
	
	var LString = function () {
	    function LString() {
	        var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	        (0, _classCallCheck3.default)(this, LString);
	
	        // type Chunk
	        this.head = null;
	        // type: chunk
	        this.tail = null;
	        // 串的当前长度
	        this.length = 0;
	        this.chunkSize = chunkSize;
	    }
	
	    // 将字符串转换成LString类型
	
	
	    (0, _createClass3.default)(LString, [{
	        key: 'strAssign',
	        value: function strAssign(chars) {
	            this.head = this.tail = new Chunk(this.chunkSize);
	            this.length = chars.length;
	
	            var current = this.head;
	            for (var i = 0, len = chars.length; i < len; i++) {
	                current.ch[i % this.chunkSize] = chars[i];
	                if (i + 1 < len && (i + 1) % this.chunkSize === 0) {
	                    current.next = new Chunk();
	                    current = current.next;
	                }
	            }
	
	            this.tail = current;
	        }
	        // 字符串对比
	        // TODO 是否去掉chunkSize的对比
	
	    }, {
	        key: 'strCompare',
	        value: function strCompare(tLString) {
	            var current = this.head;
	            var curT = tLString.head;
	
	            if (this.length !== tLString.length) return false;
	
	            while (current) {
	                for (var i = 0; i < this.chunkSize; i++) {
	                    if (current.ch[i] !== curT.ch[i]) return false;
	                }
	
	                current = current.next;
	                curT = curT.next;
	            }
	
	            return true;
	        }
	    }, {
	        key: 'clearString',
	        value: function clearString() {
	            this.head = this.tail = null;
	            this.length = 0;
	        }
	    }, {
	        key: 'concat',
	        value: function concat(tLSting) {
	            if (!tLSting.length) return;
	
	            var ret = new LString(this.chunkSize);
	
	            if (this.head === null) {
	                copyString(ret, tLSting);
	            } else {
	                ret.head = ret.tail = new Chunk(this.chunkSize);
	                copyString(ret, this);
	
	                var index = ret.tail.ch.indexOf('#');
	                if (index === -1) {
	                    copyString(ret, tLSting);
	                } else {
	                    copyString(ret, tLSting, ret.tail, tLSting.head, index);
	                }
	            }
	
	            return ret;
	        }
	    }, {
	        key: 'substring',
	        value: function substring(pos, len) {
	            pos = ~~pos || 0;
	            len = ~~len || this.length;
	            if (pos < 0 || pos > this.length - 1 || len < 0 || len > this.length - pos) throw new Error('unexpected parameter');
	
	            var sub = new LString(this.chunkSize);
	            var current = findPosChunk(this, pos);
	            var curS = sub.head = new Chunk(this.chunkSize);
	            var i = 0;
	            sub.length = len;
	
	            outerloop: while (current) {
	                for (var j = 0, size = this.chunkSize; j < size; j++) {
	                    if (i === len) {
	                        break outerloop;
	                    } else {
	                        curS.ch[j] = current.ch[(i + pos) % this.chunkSize];
	                        i++;
	                        if ((i + pos) % this.chunkSize === 0) {
	                            current = current.next;
	                        }
	                        if (i % this.chunkSize === 0 && (current.ch[i] || current.next)) {
	                            curS.next = new Chunk(this.chunkSize);
	                            curS = curS.next;
	                        }
	                    }
	                }
	            }
	
	            return sub;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var current = this.head;
	
	            if (current === null) return '';
	
	            var str = '';
	            while (current) {
	                for (var i = 0, len = this.chunkSize; i < len; i++) {
	                    var ch = current.ch[i];
	                    if (ch === '#') {
	                        return str;
	                    } else {
	                        str += current.ch[i];
	                    }
	                }
	                current = current.next;
	            }
	
	            return str;
	        }
	    }]);
	    return LString;
	}();
	
	exports.default = LString;
	
	
	function findPosChunk(lString, pos) {
	    var current = lString.head;
	    while (current) {
	        for (var i = 0, len = lString.chunkSize; i < len; i++) {
	            if (pos-- === 0) return current;
	        }
	        current = current.next;
	    }
	}
	
	function copyString(destination, target, curD, currT, offset) {
	    offset = offset || 0;
	    currT = currT || target.head;
	    curD = curD || destination.head;
	    var k = 0;
	
	    while (currT) {
	        for (var i = 0, len = target.chunkSize; i < len; i++, k++) {
	            var j = k % curD.chunkSize + offset;
	            curD.ch[j % curD.chunkSize] = currT.ch[i];
	
	            if ((j + 1) % curD.chunkSize === 0 && (currT.ch[i + 1] || currT.next)) {
	                curD.next = new Chunk(destination.chunkSize);
	                curD = curD.next;
	            }
	        }
	
	        currT = currT.next;
	    }
	
	    destination.tail = curD;
	    destination.length += target.length;
	}
	
	var a = new LString();
	var b = new LString();
	var c = new LString();
	
	a.strAssign('abcdefg');
	console.log(a + '');
	b.strAssign('hijklmno');
	console.log(b + '');
	c.strAssign('abcdefg');
	console.log(a.strCompare(b));
	console.log(a.strCompare(c));
	var t = a.concat(b);
	console.log(t + '');
	t = t.substring(2, 5);
	console.log(t + '');
	
	// 判断是否为回文字符串
	function palindrome(lStr) {
	    var stack = new _index2.default();
	    var p = lStr.head;
	    var i = 0;
	
	    for (var k = 1; k <= lStr.length; ++k) {
	        if (k <= lStr.length / 2) stack.push(p.ch[i]);else if (k > (lStr.length + 1) / 2) {
	            var _c = stack.pop();
	            if (p.ch[i] !== _c) return false;
	        }
	
	        if (++i === lStr.chunkSize) {
	            p = p.next;
	            i = 0;
	        }
	    }
	
	    return true;
	}

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 串（string）（或字符串）是由零个或多个字符组成的有限序列。串中字符的数目称为串的长度。零个字符的串称为空串（null string），它的长度为零。
	 * 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。
	 * 只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。
	 *
	 * 串有3种机内表示方法：
	 * 1.定长顺序存储表示
	 * 2.堆分配存储表示
	 * 3.串的块链存储表示
	 */
	
	/**
	 * 定长顺序存储表示
	 * 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组来描述。
	 * 以下标为0的数组分量存放串的实际长度。
	 */
	
	var SString = function () {
	    function SString(str) {
	        (0, _classCallCheck3.default)(this, SString);
	
	        this.MAXSTRLEN = 10;
	        if (str) {
	            this[0] = str.length;
	            for (var i = 1; i <= str.length; ++i) {
	                this[i] = str[i - 1];
	            }
	        }
	    }
	
	    // 返回由s1和s2连接而成的新串
	
	
	    (0, _createClass3.default)(SString, [{
	        key: 'concat',
	        value: function concat(s2) {
	            var t = new SString();
	            // 未截断
	            if (this[0] + s2[0] <= this.MAXSTRLEN) {
	                copyStr2T(this);
	                copyStr2T(s2, this[0]);
	                t[0] = this[0] + s2[0];
	
	                // 截断
	            } else if (this[0] < this.MAXSTRLEN) {
	                    copyStr2T(this);
	                    copyStr2T(s2, this[0], this.MAXSTRLEN - this[0]);
	                    t[0] = this.MAXSTRLEN;
	
	                    // 截断（仅取s1）
	                } else {
	                        copyStr2T(this, 0, this.MAXSTRLEN);
	                        t[0] = this[0] = this.MAXSTRLEN;
	                    }
	
	            return t;
	
	            function copyStr2T(str) {
	                var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	                var end = arguments.length <= 2 || arguments[2] === undefined ? str[0] : arguments[2];
	
	                for (var i = 1, len = end || str[0]; i <= len; i++) {
	                    t[start + i] = str[i];
	                }
	            }
	        }
	    }, {
	        key: 'substring',
	        value: function substring() {
	            var position = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            var len = arguments.length <= 1 || arguments[1] === undefined ? this[0] : arguments[1];
	
	            position = ~~position;
	            len = ~~len;
	            if (position < 0 || position > this[0] - 1 || len < 0 || len > this[0] - position) throw new Error('unexpected parameter');
	
	            var sub = new SString();
	            for (var i = 1; i <= len; i++) {
	                sub[i] = this[position + i - 1];
	            }
	            sub[0] = len;
	
	            return sub;
	        }
	
	        /**
	         * 将串s中的子串t替换为v，返回替换次数
	         * todo to be tested
	         * @param {SString} t
	         * @param {SString} v
	         * @returns {number} 替换次数
	         */
	
	    }, {
	        key: 'replace',
	        value: function replace(t, v) {
	            for (var _n = 0, i = 1; i <= this[0] - t[0] + 1; i++) {
	                for (var j = i, _k = 1; t[_k] && this[j] === t[_k]; ++j, ++_k) {}
	
	                // 找到了与t匹配的字串：分三种情况处理
	                if (k > t[0]) {
	                    var l = void 0;
	                    // 新字串的长度与原子串相同时，直接替换
	                    if (t[0] === v[0]) {
	                        for (l = 1; l <= t[0]; ++l) {
	                            this[i + l - 1] = v[l];
	                        }
	                    }
	                    // 新子串长度大于原子串时，先将后部右移
	                    else if (t[0] < v[0]) {
	                            for (l = this[0]; l >= i + t[0]; --l) {
	                                this[l + v[0] - t[0]] = this[l];
	                            }for (l = 1; l <= v[0]; ++l) {
	                                this[i + l - 1] = v[l];
	                            }
	                        }
	                        // 新子串长度小于原子串时，先将后部左移
	                        else {
	                                for (l = i + v[0]; l <= this[0] + v[0] - t[0]; ++l) {
	                                    this[l] = this[l - v[0] + t[0]];
	                                }for (l = 1; l <= v[0]; ++l) {
	                                    this[i + l - 1] = v[l];
	                                }
	                            }
	
	                    this[0] = this[0] - t[0] + v[0];
	                    i += v[0];
	                    ++_n;
	                }
	            }
	
	            return n;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	            for (var i = 1; this[i]; i++) {
	                str += this[i];
	            }
	            return str;
	        }
	        // 返回子串sstring在主串中的第position个字符之后的位置
	
	    }, {
	        key: 'index',
	        value: function index(sstring, position) {
	            var i = position || 1;
	            var j = 1;
	
	            while (i <= this[0] && j <= sstring[0]) {
	                if (this[i] === sstring[j]) {
	                    i++;
	                    j++;
	                } else {
	                    i = i - j + 2;
	                    j = 1;
	                }
	            }
	
	            return j > sstring[0] ? i - sstring[0] : -1;
	        }
	    }, {
	        key: 'kmpIndex',
	        value: function kmpIndex(sstring, position) {
	            var i = position || 1;
	            var j = 1;
	            var next = getNext(sstring);
	
	            while (i <= this[0] && j <= sstring[0]) {
	                if (j === 0 || this[i] === sstring[j]) {
	                    ++i;
	                    ++j;
	                } else {
	                    j = next[j];
	                }
	            }
	
	            return j > sstring[0] ? i - sstring[0] : -1;
	        }
	
	        // 求包含在字符串中而str没有的字符串
	
	    }, {
	        key: 'subtract',
	        value: function subtract(str) {
	            var r = new SString();
	            r[0] = 0;
	
	            for (var i = 1; i <= this[0]; ++i) {
	                var _c = this[i];
	                // 判断当前字符c是否第一次出现
	                var j = 1;
	                for (; j < i && this[j] !== _c; ++j) {}
	                if (i === j) {
	                    // 判断当前字符是否包含在str中
	                    var _k2 = 1;
	                    for (; _k2 <= str[0] && str[_k2] !== _c; ++_k2) {}
	                    if (_k2 > str[0]) r[++r[0]] = _c;
	                }
	            }
	
	            return r;
	        }
	
	        // todo bug exists
	
	    }, {
	        key: 'delete_substring',
	        value: function delete_substring(str) {
	            var n = 0;
	            for (var i = 1; i <= this[0] - str[0] + 1; ++i) {
	                var j = 1;
	                for (; j <= str[0] && this[i + j - 1] === str[j]; ++j) {}
	                if (j > str[0] - 1) {
	                    for (var _k3 = i; _k3 <= this[0] - str[0]; ++_k3) {
	                        this[_k3] = this[_k3 + str[0]];
	                    }this[0] -= str[0];
	                    ++n;
	                }
	            }
	
	            return n;
	        }
	    }]);
	    return SString;
	}();
	
	exports.default = SString;
	
	
	function getNext(sstring) {
	    var i = 1;
	    var next = { 1: 0 };
	    var j = 0;
	
	    while (i < sstring[0]) {
	        if (j === 0 || sstring[i] === sstring[j]) {
	            if (sstring[++i] !== sstring[++j]) {
	                next[i] = j;
	            } else {
	                next[i] = next[j];
	            }
	            //                next[++i] = ++j;
	        } else {
	                j = next[j];
	            }
	    }
	
	    return next;
	}
	
	var a = new SString();
	var b = new SString();
	for (var i = 0; i < 4; i++) {
	    a[i + 1] = i + '';
	    b[i + 1] = i + '';
	}
	a[0] = b[0] = 4;
	var t = a.concat(b);
	console.log(t + ''); // 01230123
	
	var d = new SString('acabaabaabcacaabc');
	var c = new SString('abaabc');
	
	console.log('index: ' + d.index(c));
	console.log('kmpIndex: ' + d.kmpIndex(c));
	
	a = new SString('abcdefg');
	b = new SString('asdfg');
	console.log(a.subtract(b) + '');
	
	a = new SString('abcdefgh');
	b = new SString('cdef');
	console.log(a.delete_substring(b) + '');
	console.log(a + '');
	
	/*
	 在顺序存储结构中，实现串操作的原操作为“字符串序列的复制”，操作时间复杂度基于复制的字符串序列的长度。
	 另一操作特点是，如果在操作中出现串值序列的长度超过MAXSTRLEN时，约定用截尾法处理，这种情况不仅在求连接串时可能发生，在串的其他操作中，如插入，置换等也可能发生，克服这个弊病唯有不限定串长的最大长度，即动态分配串值的存储空间。
	 */

/***/ },
/* 168 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(171);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(74)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(85).Buffer
	var Hash   = __webpack_require__(173)(Buffer)
	
	exports.sha1 = __webpack_require__(175)(Buffer, Hash)
	exports.sha256 = __webpack_require__(176)(Buffer, Hash)
	exports.sha512 = __webpack_require__(177)(Buffer, Hash)


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(48).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(48).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(48).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		h32: __webpack_require__(181)
	,	h64: __webpack_require__(182)
	}


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	xxHash implementation in pure Javascript
	
	Copyright (C) 2013, Pierre Curto
	MIT license
	*/
	var UINT32 = __webpack_require__(66).UINT32
	
	/*
		Merged this sequence of method calls as it speeds up
		the calculations by a factor of 2
	 */
	// this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
	UINT32.prototype.xxh_update = function (low, high) {
		var b00 = PRIME32_2._low
		var b16 = PRIME32_2._high
	
		var c16, c00
		c00 = low * b00
		c16 = c00 >>> 16
	
		c16 += high * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += low * b16
	
		var a00 = this._low + (c00 & 0xFFFF)
		var a16 = a00 >>> 16
	
		a16 += this._high + (c16 & 0xFFFF)
	
		var v = (a16 << 16) | (a00 & 0xFFFF)
		v = (v << 13) | (v >>> 19)
	
		a00 = v & 0xFFFF
		a16 = v >>> 16
	
		b00 = PRIME32_1._low
		b16 = PRIME32_1._high
	
		c00 = a00 * b00
		c16 = c00 >>> 16
	
		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16
	
		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF
	}
	
	/*
	 * Constants
	 */
	var PRIME32_1 = UINT32( '2654435761' )
	var PRIME32_2 = UINT32( '2246822519' )
	var PRIME32_3 = UINT32( '3266489917' )
	var PRIME32_4 = UINT32(  '668265263' )
	var PRIME32_5 = UINT32(  '374761393' )
	
	/**
	* Convert string to proper UTF-8 array
	* @param str Input string
	* @returns {Uint8Array} UTF8 array is returned as uint8 array
	*/
	function toUTF8Array (str) {
		var utf8 = []
		for (var i=0, n=str.length; i < n; i++) {
			var charcode = str.charCodeAt(i)
			if (charcode < 0x80) utf8.push(charcode)
			else if (charcode < 0x800) {
				utf8.push(0xc0 | (charcode >> 6),
				0x80 | (charcode & 0x3f))
			}
			else if (charcode < 0xd800 || charcode >= 0xe000) {
				utf8.push(0xe0 | (charcode >> 12),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
			// surrogate pair
			else {
				i++;
				// UTF-16 encodes 0x10000-0x10FFFF by
				// subtracting 0x10000 and splitting the
				// 20 bits of 0x0-0xFFFFF into two halves
				charcode = 0x10000 + (((charcode & 0x3ff)<<10)
				| (str.charCodeAt(i) & 0x3ff))
				utf8.push(0xf0 | (charcode >>18),
				0x80 | ((charcode>>12) & 0x3f),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
		}
	
		return new Uint8Array(utf8)
	}
	
	/**
	 * XXH object used as a constructor or a function
	 * @constructor
	 * or
	 * @param {Object|String} input data
	 * @param {Number|UINT32} seed
	 * @return ThisExpression
	 * or
	 * @return {UINT32} xxHash
	 */
	function XXH () {
		if (arguments.length == 2)
			return new XXH( arguments[1] ).update( arguments[0] ).digest()
	
		if (!(this instanceof XXH))
			return new XXH( arguments[0] )
	
		init.call(this, arguments[0])
	}
	
	/**
	 * Initialize the XXH instance with the given seed
	 * @method init
	 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
	 * @return ThisExpression
	 */
	 function init (seed) {
		this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed)
		this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2)
		this.v2 = this.seed.clone().add(PRIME32_2)
		this.v3 = this.seed.clone()
		this.v4 = this.seed.clone().subtract(PRIME32_1)
		this.total_len = 0
		this.memsize = 0
		this.memory = null
	
		return this
	}
	XXH.prototype.init = init
	
	/**
	 * Add data to be computed for the XXH hash
	 * @method update
	 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
	 * @return ThisExpression
	 */
	XXH.prototype.update = function (input) {
		var isString = typeof input == 'string'
		var isArrayBuffer
	
		// Convert all strings to utf-8 first (issue #5)
		if (isString) {
			input = toUTF8Array(input)
			isString = false
			isArrayBuffer = true
		}
	
		if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
		{
			isArrayBuffer = true
			input = new Uint8Array(input);
		}
	
		var p = 0
		var len = input.length
		var bEnd = p + len
	
		if (len == 0) return this
	
		this.total_len += len
	
		if (this.memsize == 0)
		{
			if (isString) {
				this.memory = ''
			} else if (isArrayBuffer) {
				this.memory = new Uint8Array(16)
			} else {
				this.memory = new Buffer(16)
			}
		}
	
		if (this.memsize + len < 16)   // fill in tmp buffer
		{
			// XXH_memcpy(this.memory + this.memsize, input, len)
			if (isString) {
				this.memory += input
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, len), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, len )
			}
	
			this.memsize += len
			return this
		}
	
		if (this.memsize > 0)   // some data left from previous update
		{
			// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
			if (isString) {
				this.memory += input.slice(0, 16 - this.memsize)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, 16 - this.memsize )
			}
	
			var p32 = 0
			if (isString) {
				this.v1.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v2.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v3.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v4.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
			} else {
				this.v1.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v2.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v3.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v4.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
			}
	
			p += 16 - this.memsize
			this.memsize = 0
			if (isString) this.memory = ''
		}
	
		if (p <= bEnd - 16)
		{
			var limit = bEnd - 16
	
			do
			{
				if (isString) {
					this.v1.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v2.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v3.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v4.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
				} else {
					this.v1.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v2.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v3.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v4.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
				}
				p += 4
			} while (p <= limit)
		}
	
		if (p < bEnd)
		{
			// XXH_memcpy(this.memory, p, bEnd-p);
			if (isString) {
				this.memory += input.slice(p)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(p, bEnd), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, p, bEnd )
			}
	
			this.memsize = bEnd - p
		}
	
		return this
	}
	
	/**
	 * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
	 * @method digest
	 * @return {UINT32} xxHash
	 */
	XXH.prototype.digest = function () {
		var input = this.memory
		var isString = typeof input == 'string'
		var p = 0
		var bEnd = this.memsize
		var h32, h
		var u = new UINT32
	
		if (this.total_len >= 16)
		{
			h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) )
		}
		else
		{
			h32  = this.seed.clone().add( PRIME32_5 )
		}
	
		h32.add( u.fromNumber(this.total_len) )
	
		while (p <= bEnd - 4)
		{
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
			}
			h32
				.add( u.multiply(PRIME32_3) )
				.rotl(17)
				.multiply( PRIME32_4 )
			p += 4
		}
	
		while (p < bEnd)
		{
			u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 )
			h32
				.add( u.multiply(PRIME32_5) )
				.rotl(11)
				.multiply(PRIME32_1)
		}
	
		h = h32.clone().shiftRight(15)
		h32.xor(h).multiply(PRIME32_2)
	
		h = h32.clone().shiftRight(13)
		h32.xor(h).multiply(PRIME32_3)
	
		h = h32.clone().shiftRight(16)
		h32.xor(h)
	
		// Reset the state
		this.init( this.seed )
	
		return h32
	}
	
	module.exports = XXH
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	xxHash64 implementation in pure Javascript
	
	Copyright (C) 2016, Pierre Curto
	MIT license
	*/
	var UINT64 = __webpack_require__(66).UINT64
	
	/*
	 * Constants
	 */
	var PRIME64_1 = UINT64( '11400714785074694791' )
	var PRIME64_2 = UINT64( '14029467366897019727' )
	var PRIME64_3 = UINT64(  '1609587929392839161' )
	var PRIME64_4 = UINT64(  '9650029242287828579' )
	var PRIME64_5 = UINT64(  '2870177450012600261' )
	
	/**
	* Convert string to proper UTF-8 array
	* @param str Input string
	* @returns {Uint8Array} UTF8 array is returned as uint8 array
	*/
	function toUTF8Array (str) {
		var utf8 = []
		for (var i=0, n=str.length; i < n; i++) {
			var charcode = str.charCodeAt(i)
			if (charcode < 0x80) utf8.push(charcode)
			else if (charcode < 0x800) {
				utf8.push(0xc0 | (charcode >> 6),
				0x80 | (charcode & 0x3f))
			}
			else if (charcode < 0xd800 || charcode >= 0xe000) {
				utf8.push(0xe0 | (charcode >> 12),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
			// surrogate pair
			else {
				i++;
				// UTF-16 encodes 0x10000-0x10FFFF by
				// subtracting 0x10000 and splitting the
				// 20 bits of 0x0-0xFFFFF into two halves
				charcode = 0x10000 + (((charcode & 0x3ff)<<10)
				| (str.charCodeAt(i) & 0x3ff))
				utf8.push(0xf0 | (charcode >>18),
				0x80 | ((charcode>>12) & 0x3f),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
		}
	
		return new Uint8Array(utf8)
	}
	
	/**
	 * XXH64 object used as a constructor or a function
	 * @constructor
	 * or
	 * @param {Object|String} input data
	 * @param {Number|UINT64} seed
	 * @return ThisExpression
	 * or
	 * @return {UINT64} xxHash
	 */
	function XXH64 () {
		if (arguments.length == 2)
			return new XXH64( arguments[1] ).update( arguments[0] ).digest()
	
		if (!(this instanceof XXH64))
			return new XXH64( arguments[0] )
	
		init.call(this, arguments[0])
	}
	
	/**
	 * Initialize the XXH64 instance with the given seed
	 * @method init
	 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
	 * @return ThisExpression
	 */
	 function init (seed) {
		this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed)
		this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2)
		this.v2 = this.seed.clone().add(PRIME64_2)
		this.v3 = this.seed.clone()
		this.v4 = this.seed.clone().subtract(PRIME64_1)
		this.total_len = 0
		this.memsize = 0
		this.memory = null
	
		return this
	}
	XXH64.prototype.init = init
	
	/**
	 * Add data to be computed for the XXH64 hash
	 * @method update
	 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
	 * @return ThisExpression
	 */
	XXH64.prototype.update = function (input) {
		var isString = typeof input == 'string'
		var isArrayBuffer
	
		// Convert all strings to utf-8 first (issue #5)
		if (isString) {
			input = toUTF8Array(input)
			isString = false
			isArrayBuffer = true
		}
	
		if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
		{
			isArrayBuffer = true
			input = new Uint8Array(input);
		}
	
		var p = 0
		var len = input.length
		var bEnd = p + len
	
		if (len == 0) return this
	
		this.total_len += len
	
		if (this.memsize == 0)
		{
			if (isString) {
				this.memory = ''
			} else if (isArrayBuffer) {
				this.memory = new Uint8Array(32)
			} else {
				this.memory = new Buffer(32)
			}
		}
	
		if (this.memsize + len < 32)   // fill in tmp buffer
		{
			// XXH64_memcpy(this.memory + this.memsize, input, len)
			if (isString) {
				this.memory += input
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, len), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, len )
			}
	
			this.memsize += len
			return this
		}
	
		if (this.memsize > 0)   // some data left from previous update
		{
			// XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);
			if (isString) {
				this.memory += input.slice(0, 32 - this.memsize)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, 32 - this.memsize )
			}
	
			var p64 = 0
			if (isString) {
				var other
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			} else {
				var other
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			}
	
			p += 32 - this.memsize
			this.memsize = 0
			if (isString) this.memory = ''
		}
	
		if (p <= bEnd - 32)
		{
			var limit = bEnd - 32
	
			do
			{
				if (isString) {
					var other
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				} else {
					var other
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				}
				p += 8
			} while (p <= limit)
		}
	
		if (p < bEnd)
		{
			// XXH64_memcpy(this.memory, p, bEnd-p);
			if (isString) {
				this.memory += input.slice(p)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(p, bEnd), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, p, bEnd )
			}
	
			this.memsize = bEnd - p
		}
	
		return this
	}
	
	/**
	 * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed
	 * @method digest
	 * @return {UINT64} xxHash
	 */
	XXH64.prototype.digest = function () {
		var input = this.memory
		var isString = typeof input == 'string'
		var p = 0
		var bEnd = this.memsize
		var h64, h
		var u = new UINT64
	
		if (this.total_len >= 32)
		{
			h64 = this.v1.clone().rotl(1)
			h64.add( this.v2.clone().rotl(7) )
			h64.add( this.v3.clone().rotl(12) )
			h64.add( this.v4.clone().rotl(18) )
	
			h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
	
			h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
	
			h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
	
			h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
		}
		else
		{
			h64  = this.seed.clone().add( PRIME64_5 )
		}
	
		h64.add( u.fromNumber(this.total_len) )
	
		while (p <= bEnd - 8)
		{
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
				,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				,	(input[p+5] << 8) | input[p+4]
				,	(input[p+7] << 8) | input[p+6]
				)
			}
			u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1)
			h64
				.xor(u)
				.rotl(27)
				.multiply( PRIME64_1 )
				.add( PRIME64_4 )
			p += 8
		}
	
		if (p + 4 <= bEnd) {
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				,	0
				,	0
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				,	0
				,	0
				)
			}
			h64
				.xor( u.multiply(PRIME64_1) )
				.rotl(23)
				.multiply( PRIME64_2 )
				.add( PRIME64_3 )
			p += 4
		}
	
		while (p < bEnd)
		{
			u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 )
			h64
				.xor( u.multiply(PRIME64_5) )
				.rotl(11)
				.multiply(PRIME64_1)
		}
	
		h = h64.clone().shiftRight(33)
		h64.xor(h).multiply(PRIME64_2)
	
		h = h64.clone().shiftRight(29)
		h64.xor(h).multiply(PRIME64_3)
	
		h = h64.clone().shiftRight(32)
		h64.xor(h)
	
		// Reset the state
		this.init( this.seed )
	
		return h64
	}
	
	module.exports = XXH64
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))

/***/ },
/* 183 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA3ZmMzNzY2N2ViMmM2NDU0ZWZhOSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25vZGUtbGlicy1icm93c2VyL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1ZXVlL1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2RlZmF1bHRDb21wYXJpc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL34vYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcnlwdG8tYnJvd3NlcmlmeS9jcmVhdGUtaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2N1aW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0RvdWJsZUxpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9TdGF0aWNMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQmluYXJ5U29ydGVkVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9leGNoYW5nZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyeXB0by1icm93c2VyaWZ5L2NyZWF0ZS1obWFjLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvbWQ1LmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvcGJrZGYyLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwid2VicGFjazovLy8uL34vY3VpbnQvbGliL3VpbnQzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L2N1aW50L2xpYi91aW50NjQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FycmF5L0Nyb3NzTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXJyYXkvVFNNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR2VuZXJhbGl6ZWRMaXN0L0dMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BTUxHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoLmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BZGphY2VuY3lNYXRyaXhHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvT0xHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTGluZWFyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVldWUvQ3ljbGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVldWUvUHJpb3JpdHlRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0FWTFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0JpbmFyeVNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0Jsb29tRmlsdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9IYXNoVGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9SZWRCbGFja1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9TT1NUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvZmlib25hY2NpU2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvc2VxdWVudGlhbFNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kaXN0cmlidXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvaW5zZXJ0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L21lcmdpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvc2VsZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9TdHJpbmcvSFN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RyaW5nL0xTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0cmluZy9TU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3Bia2RmMi1jb21wYXQvcGJrZGYyLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzIiwid2VicGFjazovLy8uL34vc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhMS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8uL34vdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3h4aGFzaGpzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h4aGFzaGpzL2xpYi94eGhhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi94eGhhc2hqcy9saWIveHhoYXNoNjQuanMiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNyRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNSQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRzs7Ozs7O0FDMUJELDhCQUE2QjtBQUM3QixzQ0FBcUMsZ0M7Ozs7OztBQ0RyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EseUJBQXdCLFFBQVE7QUFDaEM7QUFDQSxzQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxVQUFVLEtBQUssV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUE4QztBQUM5Qyw2RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyx1REFBdUQ7QUFDM0YsY0FBYTtBQUNiOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUI7Ozs7OztBQ2hpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsU0FBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7O0FDbkZBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDMUpBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7Ozs7QUN6QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxxQkFBcUI7QUFDakMsYUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQVksT0FBTztBQUNuQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixjQUFh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QUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBEOzs7Ozs7QUM5SEE7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLFVBQVU7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0Msc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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Q0E7O0FBRUE7O0FBRUEsMERBQXlELEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RCxFQUFDLEk7Ozs7OztBQ3h5Q0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0wsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFlBQVc7QUFDWCxhQUFZO0FBQ1osYUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsZ0JBQWdCO0FBQy9CLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDO0FBQzFDO0FBQ0EsMkNBQTBDO0FBQzFDO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsRUFBRTtBQUNyQixzQkFBcUI7QUFDckI7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLEVBQUU7QUFDckI7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLEVBQUU7QUFDckIsb0JBQW1CLEVBQUU7QUFDckIsb0JBQW1CLFFBQVE7QUFDM0Isc0JBQXFCO0FBQ3JCOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsc0JBQXFCO0FBQ3JCOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1QyxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0Esd0NBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0EsY0FBYSxnQkFBZ0Isa0JBQWtCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQSxjQUFhLGlCQUFpQixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBLGNBQWEsaUJBQWlCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QyxnQ0FBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0EsZ0NBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxtQkFBbUI7QUFDcEQsMENBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQSxnQ0FBK0IsaUJBQWlCO0FBQ2hELDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1QyxrQ0FBaUMsbUJBQW1CO0FBQ3BELHFDQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQTZCLG1CQUFtQjtBQUNoRCxrQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQSxVQUFTO0FBQ1Qsb0JBQW1CLGlDQUFpQztBQUNwRCx3QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWMsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDLEdBQUcsZ0NBQWdDLEtBQUssMkJBQTJCLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEtBQUssMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDLEtBQUssZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEtBQUssZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDO0FBQ3h6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQWtCLEdBQUcsTUFBTTtBQUMzQiw4Q0FBNkMsRUFBRSxRQUFRLE1BQU07QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTO0FBQ2pDLHlCQUF3QixTQUFTOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQSwrRUFBOEUsUUFBUTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCLEdBQUcseUJBQXlCLE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQSxRQUFPLEdBQUc7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixtQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTtBQUNwQywyQkFBMEIsVUFBVTs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVUsRUFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixTQUFTO0FBQ25DLDJCQUEwQixTQUFTO0FBQ25DLDJCQUEwQixTQUFTO0FBQ25DLDJCQUEwQixTQUFTOztBQUVuQzs7QUFFQTtBQUNBLG1COzs7Ozs7QUMzakNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsa0JBQWtCO0FBQzdCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixnREFBK0MsNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixpREFBZ0QsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBLDRDQUEyQyxHQUFHO0FBQzlDO0FBQ0EsY0FBYSxnQ0FBZ0MsR0FBRztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBLFVBQVM7QUFDVCxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQSxVQUFTO0FBQ1Qsd0NBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0EsTUFBSztBQUNMLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQSxNQUFLO0FBQ0w7QUFDQSxrQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEMsR0FBRztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDdlJBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXdDLFdBQVc7QUFDbkQ7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLCtDQUE4QyxXQUFXOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUE4RCxnRUFBZ0U7QUFDOUg7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEI7Ozs7OztBQ2pMQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBb0MsVUFBVTtBQUM5QztBQUNBOztBQUVBLHlDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBLCtGOzs7Ozs7QUNoUEE7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLG1FQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7OztBQ3hHQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQStDLFdBQVcsbUVBQW1FOzs7QUFHN0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qjs7Ozs7O0FDcEtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsMEJBQTBCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0I7Ozs7OztpRUN2bEJBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsYTs7Ozs7OztBQ3B0QkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsRUFBRTtBQUNqQixrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0Esd0JBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsdUJBQXVCO0FBQ3RDLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QixVQUFTO0FBQ1Q7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQyxvQkFBbUIsZUFBZTtBQUNsQyxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLEdBQUc7QUFDdEIsdUJBQXNCLDJCQUEyQixFQUFFLGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0EsZ0NBQStCLHdCQUF3QjtBQUN2RDtBQUNBLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsOERBQTZEO0FBQzdEO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0EscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsR0FBRztBQUN0QixzQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixHQUFHO0FBQ3RCLG9CQUFtQixFQUFFO0FBQ3JCLG9CQUFtQixTQUFTO0FBQzVCLHNCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLEdBQUc7QUFDdEIsc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QixvQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLGdDQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUIsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EsY0FBYSxnQ0FBZ0MsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixVQUFVO0FBQzdCLG9CQUFtQixHQUFHO0FBQ3RCLG9CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLEdBQUc7QUFDdEIsb0JBQW1CLEVBQUU7QUFDckIsb0JBQW1CLFNBQVM7QUFDNUIsc0JBQXFCLFFBQVE7QUFDN0IscUJBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixHQUFHO0FBQ3RCLHNCQUFxQixZQUFZO0FBQ2pDLHFCQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLEdBQUc7QUFDdEIsc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIscUNBQXFDO0FBQ3hELG9CQUFtQix3Q0FBd0M7QUFDM0Qsb0JBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQsa0VBQWlFO0FBQ2pFLHNCQUFxQjtBQUNyQjtBQUNBLCtDQUE4QztBQUM5QyxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixtQkFBbUI7QUFDeEMsb0JBQW1CLHFDQUFxQztBQUN4RCxvQkFBbUIsMENBQTBDO0FBQzdELG9CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixxQ0FBcUM7QUFDeEQsb0JBQW1CLHdDQUF3QztBQUMzRCxvQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsK0NBQThDO0FBQzlDLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCxrRUFBaUU7QUFDakUsc0JBQXFCO0FBQ3JCO0FBQ0EsK0NBQThDO0FBQzlDLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsR0FBRztBQUN0QixvQkFBbUIsR0FBRztBQUN0QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBQyxtQjs7Ozs7OztBQ3p0QkQ7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLG1DQUFtQztBQUN4RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFpQyw4RUFBOEU7QUFDL0c7O0FBRUE7QUFDQSx3REFBdUQ7QUFDdkQsd0RBQXVELE07Ozs7OztBQ3ZFdkQ7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0VBQThFO0FBQzlFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWdGLGdFQUFnRTtBQUNoSjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQSxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7OztBQUdBLCtCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLHVDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ2hXQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQiwwQ0FBMEM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0Esa0JBQWlCLDBDQUEwQztBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsMENBQTBDOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLDJFQUEyRTtBQUM3RjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isc0JBQXFCLEVBQUU7QUFDdkI7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQiwwQ0FBMEM7QUFDNUQ7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0I7Ozs7OztBQzdmQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rix1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxNQUFLO0FBQ0wsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxcEJBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtkQUFpZCwrQkFBK0I7QUFDaGY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0IsWUFBWTtBQUM1QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMxTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFZLE9BQU8sT0FBTyxZQUFZLE9BQU8sT0FBTyxPQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNMQSw4QkFBNkIsbURBQW1EOzs7Ozs7O0FDQWhGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3BZQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGNBQWM7QUFDekIsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQzNiQSxnQiIsImZpbGUiOiIuL0RTLWRlYnVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRFNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRFNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDdmYzM3NjY3ZWIyYzY0NTRlZmE5XG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBcnJheToge1xuICAgICAgICBDcm9zc0xpc3Q6IHJlcXVpcmUoJy4vQXJyYXkvQ3Jvc3NMaXN0JykuZGVmYXVsdCxcbiAgICAgICAgVFNNYXRyaXg6IHJlcXVpcmUoJy4vQXJyYXkvVFNNYXRyaXgnKS5kZWZhdWx0XG4gICAgfSxcblxuICAgIEJpbmFyeVRyZWU6IHtcbiAgICAgICAgLy8gQmluYXJ5VGhyZWFkVHJlZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRocmVhZFRyZWUnKSxcbiAgICAgICAgQmluYXJ5VHJlZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnKSxcbiAgICAgICAgLy8gRUJUTm9kZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0VCVE5vZGUnKSxcbiAgICAgICAgaHVmZk1hbkNvZGluZzogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcnKS5kZWZhdWx0XG4gICAgfSxcblxuICAgIC8vIE1GU2V0OiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvTUZTZXQnKSxcbiAgICAvLyBQQlROb2RlOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvUEJUTm9kZScpXG4gICAgR2VuZXJhbGl6ZWRMaXN0OiByZXF1aXJlKCcuL0dlbmVyYWxpemVkTGlzdC9HTGlzdCcpLmRlZmF1bHQsXG5cbiAgICBHcmFwaDoge1xuICAgICAgICBBZGphY2VuY3lMaXN0R3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoJykuZGVmYXVsdCxcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvQWRqYWNlbmN5TWF0cml4R3JhcGgnKS5kZWZhdWx0LFxuICAgICAgICBBTUxHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9BTUxHcmFwaCcpLmRlZmF1bHQsXG4gICAgICAgIE9MR3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvT0xHcmFwaCcpLmRlZmF1bHRcbiAgICB9LFxuXG4gICAgTGlzdDoge1xuICAgICAgICBEb3VibGVMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0xpc3QvRG91YmxlTGlua2VkTGlzdCcpLmRlZmF1bHQsXG4gICAgICAgIExpbmVhckxpc3Q6IHJlcXVpcmUoJy4vTGlzdC9MaW5lYXJMaXN0JyksXG4gICAgICAgIFN0YXRpY0xpbmtlZExpc3Q6IHJlcXVpcmUoJy4vTGlzdC9TdGF0aWNMaW5rZWRMaXN0JykuZGVmYXVsdCxcbiAgICAgICAgTFJVQ2FjaGU6IHJlcXVpcmUoJy4vTGlzdC9MUlUnKS5kZWZhdWx0XG4gICAgfSxcblxuICAgIFF1ZXVlOiB7XG4gICAgICAgIEN5Y2xlUXVldWU6IHJlcXVpcmUoJy4vUXVldWUvQ3ljbGVRdWV1ZScpLmRlZmF1bHQsXG4gICAgICAgIFByaW9yaXR5UXVldWU6IHJlcXVpcmUoJy4vUXVldWUvUHJpb3JpdHlRdWV1ZScpLmRlZmF1bHQsXG4gICAgICAgIFF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL1F1ZXVlJykuZGVmYXVsdFxuICAgIH0sXG5cbiAgICBTZWFyY2g6IHtcbiAgICAgICAgQVZMVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQVZMVHJlZScpLFxuICAgICAgICBiaW5hcnlTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL0JpbmFyeVNlYXJjaCcpLFxuICAgICAgICBCaW5hcnlTb3J0ZWRUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlJykuZGVmYXVsdCxcbiAgICAgICAgQlBsdXNUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CUGx1c1RyZWUnKSxcbiAgICAgICAgQlRyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL0JUcmVlJyksXG4gICAgICAgIERpZ2l0YWxTZWFyY2hUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9EaWdpdGFsU2VhcmNoVHJlZScpLFxuICAgICAgICBmaWJvbmFjY2lTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaCcpLmRlZmF1bHQsXG4gICAgICAgIEhhc2hUYWJsZTogcmVxdWlyZSgnLi9TZWFyY2gvSGFzaFRhYmxlJyksXG4gICAgICAgIFJlZEJsYWNrVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvUmVkQmxhY2tUcmVlJykuZGVmYXVsdCxcbiAgICAgICAgc2VxdWVudGlhbFNlYXJjaDogcmVxdWlyZSgnLi9TZWFyY2gvc2VxdWVudGlhbFNlYXJjaCcpLmRlZmF1bHQsXG4gICAgICAgIFNPU1RyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL1NPU1RyZWUnKSxcbiAgICAgICAgQmxvb21GaWx0ZXI6IHJlcXVpcmUoJy4vU2VhcmNoL0Jsb29tRmlsdGVyJylcbiAgICB9LFxuXG4gICAgU29ydDoge1xuICAgICAgICBkaXN0cmlidXRpb246IHJlcXVpcmUoJy4vU29ydC9kaXN0cmlidXRpb24vaW5kZXgnKSxcbiAgICAgICAgZXhjaGFuZ2U6IHJlcXVpcmUoJy4vU29ydC9leGNoYW5nZS9pbmRleCcpLFxuICAgICAgICBpbnNlcnRpb246IHJlcXVpcmUoJy4vU29ydC9pbnNlcnRpb24vaW5kZXgnKSxcbiAgICAgICAgbWVyZ2luZzogcmVxdWlyZSgnLi9Tb3J0L21lcmdpbmcvaW5kZXgnKSxcbiAgICAgICAgc2VsZWN0aW9uOiByZXF1aXJlKCcuL1NvcnQvc2VsZWN0aW9uL2luZGV4JylcbiAgICB9LFxuXG4gICAgU3RhY2s6IHJlcXVpcmUoJy4vU3RhY2svaW5kZXgnKS5kZWZhdWx0LFxuXG4gICAgU3RyaW5nOiB7XG4gICAgICAgIEhTdHJpbmc6IHJlcXVpcmUoJy4vU3RyaW5nL0hTdHJpbmcnKS5kZWZhdWx0LFxuICAgICAgICBMU3RyaW5nOiByZXF1aXJlKCcuL1N0cmluZy9MU3RyaW5nJykuZGVmYXVsdCxcbiAgICAgICAgU1N0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvU1N0cmluZycpLmRlZmF1bHRcbiAgICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIik7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIOmYn+WIl1F1ZXVlXHJcbiAqXHJcbiAqIOmYn+WIl+aYr+S4gOenjeWFiOi/m+WFiOWHuu+8iGZpcnN0IGluIGZpcnN0IG91dCwgRklGT++8ieeahOe6v+aAp+ihqOOAguWug+WPquWFgeiuuOWcqOihqOeahOS4gOerr+i/m+ihjOaPkuWFpe+8jOiAjOWcqOWPpuS4gOerr+WIoOmZpOWFg+e0oOOAglxyXG4gKiDlhYHorrjmj5LlhaXnmoTkuIDnq6/lj6vpmJ/lsL7vvIhyZWFy77yJ77yM5YWB6K645Yig6Zmk55qE5LiA56uv5Y+r6Zif5aS077yIZnJvbnTvvInjgIJcclxuICovXG5cbi8vIOmTvumYn+WIl1xuXG52YXIgUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFF1ZXVlKTtcblxuICAgICAgICB0aGlzLnJlYXIgPSB0aGlzLmZyb250ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShRdWV1ZSwgW3tcbiAgICAgICAga2V5OiBcImlzRW1wdHlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFyID09PSBudWxsO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0SGVhZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb250ID8gdGhpcy5mcm9udC5kYXRhIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVuUXVldWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuUXVldWUoZWxlbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYXIgPSB0aGlzLmZyb250ID0geyBkYXRhOiBlbGVtLCBuZXh0OiBudWxsIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwID0geyBkYXRhOiBlbGVtLCBuZXh0OiBudWxsIH07XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFyLm5leHQgPSBwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhciA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlUXVldWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlUXVldWUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9udCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5mcm9udC5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLmZyb250Lm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicXVldWVUcmF2ZXJzZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcXVldWVUcmF2ZXJzZShpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmZyb250O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IoY3VycmVudC5kYXRhKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInBlZWtBdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGVla0F0KCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmZyb250O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5mcm9udDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFF1ZXVlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBRdWV1ZTtcblxuXG52YXIgcXVldWUgPSBuZXcgUXVldWUoKTtcbnF1ZXVlLmVuUXVldWUoMSk7XG5xdWV1ZS5kZVF1ZXVlKCk7XG5xdWV1ZS5lblF1ZXVlKDIpO1xucXVldWUuZW5RdWV1ZSgzKTtcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgwKSk7XG5jb25zb2xlLmxvZyhxdWV1ZS5wZWVrQXQoMSkpO1xuY29uc29sZS5sb2cocXVldWUucGVla0F0KDIpKTtcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgzKSk7XG5jb25zb2xlLmxvZyhxdWV1ZS50b1N0cmluZygpLmpvaW4oKSk7XG5cbi8vIOexu+S8vOW5v+W6puS8mOWFiOmBjeWOhlxuZnVuY3Rpb24gcmVwYWludENvbG9yKG1hdHJpeCwgaSwgaiwgY29sb3IpIHtcbiAgICB2YXIgb2xkID0gbWF0cml4W2ldW2pdO1xuICAgIHZhciBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgIHZhciBtID0gbWF0cml4Lmxlbmd0aCAtIDE7XG4gICAgdmFyIG4gPSBtYXRyaXhbMF0ubGVuZ3RoIC0gMTtcblxuICAgIHF1ZXVlLmVuUXVldWUoeyB4OiBpLCB5OiBqIH0pO1xuXG4gICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcbiAgICAgICAgdmFyIGEgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgIHZhciB4ID0gYS54O1xuICAgICAgICB2YXIgeSA9IGEueTtcblxuICAgICAgICBpZiAoeCA+PSAxKSBzZXRDb2xvcih4IC0gMSwgeSk7XG4gICAgICAgIGlmICh5ID49IDEpIHNldENvbG9yKHgsIHkgLSAxKTtcbiAgICAgICAgaWYgKHggPCBtKSBzZXRDb2xvcih4ICsgMSwgeSk7XG4gICAgICAgIGlmICh5IDwgbikgc2V0Q29sb3IoeCwgeSArIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENvbG9yKHgsIHkpIHtcbiAgICAgICAgaWYgKG1hdHJpeFt4XVt5XSA9PT0gb2xkKSB7XG4gICAgICAgICAgICBtYXRyaXhbeF1beV0gPSBjb2xvcjtcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoeyB4OiB4LCB5OiB5IH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgbWF0cml4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgbWF0cml4W2ldID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgbWF0cml4W2ldW2pdID0gMDtcbiAgICB9XG59XG5cbnJlcGFpbnRDb2xvcihtYXRyaXgsIDQsIDUsIDEpO1xuY29uc29sZS5sb2cobWF0cml4KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1F1ZXVlL1F1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5DaGlsZFNpYmxpbmdUcmVlID0gZXhwb3J0cy5DaGlsZFRyZWUgPSBleHBvcnRzLlBhcmVudFRyZWUgPSBleHBvcnRzLkJpbmFyeVRyZWUgPSB1bmRlZmluZWQ7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvcicpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yJyk7XG5cbnZhciBfcmVnZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVnZW5lcmF0b3IpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3InKTtcblxudmFyIF9pdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoJy4uL1N0YWNrL2luZGV4Jyk7XG5cbnZhciBfaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgpO1xuXG52YXIgX1F1ZXVlID0gcmVxdWlyZSgnLi4vUXVldWUvUXVldWUnKTtcblxudmFyIF9RdWV1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9RdWV1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiDmoJHnmoTkuIDkupvmpoLlv7VcclxuICpcclxuICog5qCR77yIVHJlZe+8ieaYr27vvIhuPj0w77yJ5Liq57uT54K555qE5pyJ6ZmQ6ZuG44CC5Zyo5Lu75oSP5LiA5qO16Z2e56m65qCR5Lit77yaXHJcbiAqIO+8iDHvvInmnInkuJTku4XmnInkuIDkuKrnibnlrprnmoTnp7DkuLrmoLnvvIhSb29077yJ55qE57uT54K577ybXHJcbiAqIO+8iDLvvInlvZNuPjHml7bvvIzlhbbkvZnnu5Pngrnlj6/liIbkuLptKG0+MCnkuKrkupLkuI3nm7jkuqTnmoTmnInpmZDpm4ZUMSxUMixUMywuLi5Ube+8jOWFtuS4reavj+S4gOS4qumbhuWQiOacrOi6q+WPiOaYr+S4gOajteagke+8jOW5tuS4lOensOS4uuagueeahOWtkOagke+8iFN1YnRyZWXvvInjgIJcclxuICpcclxuICog5L6L5aaC77yM77yIYe+8ieaYr+WPquacieS4gOS4quaguee7k+eCueeahOagke+8m1xyXG4gKiDvvIhi77yJ5piv5pyJMTPkuKrnu5PngrnnmoTmoJHvvIzlhbbkuK1B5piv5qC577yM5YW25L2Z57uT54K55YiG5oiQM+S4quS6kuS4jeebuOS6pOeahOWtkOmbhu+8mlQxPXtCLEUsRixLLEx9LHQyPXtELEgsSSxKLE19O1QxLFQy5ZKMVDPpg73mmK/moLlB55qE5a2Q5qCR77yM5LiU5pys6Lqr5Lmf5piv5LiA5qO15qCR44CCXHJcbiAqXHJcbiAqIOagkeeahOe7k+eCueWMheWQq+S4gOS4quaVsOaNruWFg+e0oOWPiuiLpeW5suaMh+WQkeWFtuWtkOagkeeahOWIhuaUr+OAgue7k+eCueaLpeacieeahOWtkOagkeaVsOensOS4uue7k+eCueeahOW6pu+8iERlZ3JlZe+8ieOAguS+i+Wmgu+8jO+8iGLvvInkuK1B55qE5bqm5Li6M++8jEPnmoTluqbkuLox77yMRueahOW6puS4ujAu5bqm5Li6MOeahOe7k+eCueensOS4uuWPtuWtkO+8iExlYWbvvInmiJbogIXnu4jnq6/nu5PngrnjgILluqbkuI3kuLow55qE57uT54K556ew5Li66Z2e57uI56uv57uT54K55oiW5YiG5pSv57uT54K544CC5qCR55qE5bqm5piv5qCR5YaF5ZCE57uT54K555qE5bqm55qE5pyA5aSn5YC844CC77yIYu+8ieeahOagkeeahOW6puS4ujMu57uT54K555qE5a2Q5qCR55qE5qC556ew5Li66K+l57uT54K555qE5a2p5a2Q77yIQ2hpbGTvvInjgILnm7jlupTnmoTvvIzor6Xnu5Pngrnnp7DkuLrlranlrZDnmoTlj4zkurLvvIhQYXJlbnTvvInjgILlkIzkuIDkuKrlj4zkurLnmoTlranlrZDkuYvpl7TkupLnp7DlhYTlvJ/vvIhTaWJsaW5n77yJ44CC57uT54K555qE56WW5YWI5piv5LuO5qC55Yiw6K+l57uT54K55omA57uP5YiG5pSv5LiK55qE5omA5pyJ57uT54K544CC5Y+N5LmL77yM5Lul5p+Q57uT54K55Li65qC555qE5a2Q5qCR5Lit55qE5Lu75LiA57uT54K56YO956ew5Li66K+l57uT54K555qE5a2Q5a2Z44CCXHJcbiAqIOe7k+eCueeahOWxguasoe+8iExldmVs77yJ5LuO5qC55byA5aeL5a6a5LmJ6LW377yM5qC55Li656ys5LiA5bGC77yM6Lef55qE5a2p5a2Q5Li656ys5LqM5bGC44CC6Iul5p+Q57uT54K55Zyo56ysbOWxgu+8jOWImeWFtuWtkOagkeeahOagueWwseWcqOesrGwrMeWxguOAguWFtuWPjOS6suWcqOWQjOS4gOWxgueahOe7k+eCueS6kuS4uuWgguWFhOW8n+OAguS+i+Wmgu+8jOe7k+eCuUfkuI5F77yMRixILEksSuS6kuS4uuWgguWFhOW8n+OAguagkeS4ree7k+eCueeahOacgOWkp+WxguasoeensOS4uuagkeeahOa3seW6pu+8iERlcHRo77yJ5oiW6auY5bqm44CC77yIYu+8ieeahOagkeeahOa3seW6puS4ujTjgIJcclxuICpcclxuICog5aaC5p6c5bCG5qCR5Lit57uT54K555qE5ZCE5a2Q5qCR55yL5oiQ5LuO5bem6Iez5Y+z5piv5pyJ5qyh5bqP55qE77yI5Y2z5LiN6IO95Lqk5o2i77yJ77yM5YiZ56ew6K+l5qCR5Li65pyJ5bqP5qCR77yM5ZCm5YiZ56ew5Li65peg5bqP5qCR44CC5Zyo5pyJ5bqP5qCR5Lit5pyA5bem6L6555qE5a2Q5qCR55qE5qC556ew5Li656ys5LiA5Liq5a2p5a2Q77yM5pyA5Y+z6L6555qE56ew5Li65pyA5ZCO5LiA5Liq5a2p5a2Q44CCXHJcbiAqIOajruael++8iEZvcmVzdO+8ieaYr23vvIhtPj0w77yJ5qO15LqS5LiN55u45Lqk55qE5qCR55qE6ZuG5ZCI44CC5a+55qCR5Lit5q+P5Liq57uT54K56ICM6KiA77yM5YW25a2Q5qCR55qE6ZuG5ZCI5Y2z5Li65qOu5p6X44CCXHJcbiAqXHJcbiAqXHJcbiAqL1xuXG4vKipcclxuICog5LqM5Y+J5qCR77yIQmluYXJ5IFRyZWXvvInmmK/lj6bkuIDnp43moJHlnovnu5PmnoTvvIzlroPnmoTnibnngrnmmK/mr4/kuKrnu5Pngrnoh7PlpJrlj6rmnInkuKTmo7XlrZDmoJHvvIjljbPkuozlj4nmoJHkuK3kuI3lrZjlnKjluqblpKfkuo4y55qE57uT54K577yJ77yM5bm25LiU77yM5LqM5Y+J5qCR55qE5a2Q5qCR5pyJ5bem5Y+z5LmL5YiG77yI5YW25qyh5bqP5LiN6IO95Lu75oSP6aKg5YCS44CC77yJXHJcbiAqXHJcbiAqIOS6jOWPieagkeeahOaAp+i0qFxyXG4gKiAxLuWcqOS6jOWPieagkeeahOesrGnlsYLkuIroh7PlpJrmnIky55qEaS0x5qyh5pa55Liq57uT54K5KGk+PTEp44CCXHJcbiAqIDIu5rex5bqm5Li6a+eahOS6jOWPieagkeiHs+WkmuaciTLnmoRr5qyh5pa5LTHkuKrnu5PngrnvvIwoaz49MSnjgIJcclxuICogMy7lr7nku7vkvZXkuIDmo7Xkuozlj4nmoJFU77yM5aaC5p6c5YW257uI56uv57uT54K55pWw5Li6bjDvvIzluqbkuLoy55qE57uT54K55pWw5Li6bjLvvIzliJluMCA9IG4yICsgMTtcclxuICogICAgICDkuIDmo7Xmt7HluqbkuLpr5LiU5pyJMueahGvmrKHmlrktMeS4que7k+eCueeahOS6jOWPieagkeensOS4uua7oeS6jOWPieagkeOAglxyXG4gKiAgICAgIOa3seW6puS4umvnmoTvvIzmnIlu5Liq57uT54K555qE5LqM5Y+J5qCR77yM5b2T5LiU5LuF5b2T5YW25q+P5LiA5Liq57uT54K56YO95LiO5rex5bqm5Li6a+eahOa7oeS6jOWPieagkeS4ree8luWPt+S7jjHoh7Nu55qE57uT54K55LiA5LiA5a+55bqU5pe277yM56ew5LmL5Li65a6M5YWo5LqM5Y+J5qCR44CCXHJcbiAqIOS4i+mdouaYr+WujOWFqOS6jOWPieagkeeahOS4pOS4queJueaAp1xyXG4gKiA0LuWFt+aciW7kuKrnu5PngrnnmoTlrozlhajkuozlj4nmoJHnmoTmt7HluqbkuLpNYXRoLmZsb29yKGxvZyAyIG4pICsgMVxyXG4gKiA1LuWmguaenOWvueS4gOajteaciW7kuKrnu5PngrnnmoTlrozlhajkuozlj4nmoJHvvIjlhbbmt7HluqbkuLpNYXRoLmZsb29yKGxvZyAyIG4pICsgMe+8ieeahOe7k+eCueaMieWxguW6j+e8luWPt++8iOS7juesrDHlsYLliLDnrKxNYXRoLmZsb29yKDIgbikgKyAx77yM5q+P5bGC5LuO5bem5Yiw5Y+z77yJ77yM5YiZ5a+55Lu75LiA57uT54K577yIMTw9aTw9bu+8ieacie+8mlxyXG4gKiAgICAgKDEp5aaC5p6caT0x77yM5YiZ57uT54K5aeOAgeaYr+S6jOWPieagkeeahOague+8jOaXoOWPjOS6su+8m+WmguaenGk+Me+8jOWImeWFtuWPjOS6snBhcmVudChpKeaYr+e7k+eCuU1hdGguZmxvb3IoaS8yKeOAglxyXG4gKiAgICAgKDIp5aaC5p6cMmkgPiBu77yM5YiZ57uT54K5aeaXoOW3puWtqeWtkO+8iOe7k+eCuWnkuLrlj7blrZDnu5PngrnvvInvvJvlkKbliJnlhbblt6blranlrZBMQ2hpbGQoaSnmmK/nu5PngrkyaS5cclxuICogICAgICgzKeWmguaenDJpICsgMSA+IG7vvIzliJnnu5Pngrlp5peg5Y+z5a2p5a2Q77yb5ZCm5YiZ5YW25Y+z5a2p5a2QUkNoaWxkKGkp5piv57uT54K5MmkgKyAxO1xyXG4gKi9cblxuLypcclxuIOS6jOWPieagkeeahOWtmOWCqOe7k+aehFxyXG5cclxuIDEu6aG65bqP5a2Y5YKo57uT5p6EXHJcbiDnlKjkuIDnu4Tov57nu63nmoTlrZjlgqjljZXlhYPkvp3mrKHoh6rkuIrogIzkuIvvvIzoh6rlt6boh7Plj7PlrZjlgqjlrozlhajkuozlj4nmoJHkuIrnmoTnu5PngrnlhYPntKDvvIzljbPlsIbkuozlj4nmoJHkuIrnvJblj7fkuLpp55qE57uT54K55YWD57Sg5a2Y5YKo5Zyo5Yqg5LiK5a6a5LmJ55qE5LiA57u05pWw57uE5Lit5LiL5qCH5Li6aS0x55qE5YiG6YeP5Lit44CC4oCcMOKAneihqOekuuS4jeWtmOWcqOatpOe7k+eCueOAgui/meenjemhuuW6j+WtmOWCqOe7k+aehOS7hemAgueUqOS6juWujOWFqOS6jOWPieagkeOAglxyXG4g5Zug5Li677yM5Zyo5pyA5Z2P5oOF5Ya15LiL77yM5LiA5Liq5rex5bqm5Li6a+S4lOWPquaciWvkuKrnu5PngrnnmoTljZXmlK/moJHvvIjmoJHkuK3kuI3lrZjlnKjluqbkuLoy55qE57uT54K577yJ5Y206ZyA6KaB6ZW/5bqm5Li6MueahG7mrKHmlrktMeeahOS4gOe7tOaVsOe7hOOAglxyXG5cclxuIDIu6ZO+5byP5a2Y5YKo57uT5p6EXHJcbiDkuozlj4nmoJHnmoTnu5PngrnnlLHkuIDkuKrmlbDmja7lhYPntKDlkozliIbliKvmjIflkJHlhbblt6blj7PlrZDmoJHnmoTkuKTkuKrliIbmlK/mnoTmiJDvvIzliJnooajnpLrkuozlj4nmoJHnmoTpk77ooajkuK3nmoTnu5Pngrnoh7PlsJHljIXlkKvkuInkuKrln5/vvJrmlbDmja7ln5/lkozlt6blj7PmjIfpkojln5/jgILmnInml7bvvIzkuLrkuobkvr/kuo7mib7liLDnu5PngrnnmoTlj4zkurLvvIzliJnov5jlj6/lnKjnu5Pngrnnu5PmnoTkuK3lop7liqDkuIDkuKrmjIflkJHlhbblj4zkurLnu5PngrnnmoTmjIfpkojln5/jgILliKnnlKjov5nkuKTnp43nu5PmnoTmiYDlvpfnmoTkuozlj4nmoJHnmoTlrZjlgqjnu5PmnoTliIbliKvnp7DkuYvkuLrkuozlj4npk77ooajlkozkuInlj4npk77ooajjgIJcclxuIOWcqOWQq+aciW7kuKrnu5PngrnnmoTkuozlj4npk77ooajkuK3mnIluKzHkuKrnqbrpk77ln5/vvIzmiJHku6zlj6/ku6XliKnnlKjov5nkupvnqbrpk77ln5/lrZjlgqjlhbbku5bmnInnlKjkv6Hmga/vvIzku47ogIzlvpfliLDlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoQtLS3nur/ntKLpk77ooajjgIJcclxuXHJcbiDlhYjvvIjmoLnvvInluo/pgY3ljobvvJrmoLnlt6blj7NcclxuIOS4re+8iOague+8ieW6j+mBjeWOhu+8muW3puagueWPs1xyXG4g5ZCO77yI5qC577yJ5bqP6YGN5Y6G77ya5bem5Y+z5qC5XHJcblxyXG4gKi9cblxuLy8g6aG65bqP5a2Y5YKo57uT5p6EXG4oZnVuY3Rpb24gKCkge1xuICAgIC8vIOmhuuW6j+WtmOWCqOe7k+aehOeahOmBjeWOhlxuICAgIHZhciB0cmVlID0gWzEsIDIsIDMsIDQsIDUsLCA2LCwsIDddO1xuXG4gICAgY29uc29sZS5sb2coJ3ByZU9yZGVyOicpO1xuICAgIHZvaWQgZnVuY3Rpb24gcHJlT3JkZXJSZWN1cnNpdmUoeCwgdmlzaXQpIHtcbiAgICAgICAgdmlzaXQodHJlZVt4XSk7XG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMV0pIHByZU9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMSwgdmlzaXQpO1xuICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSBwcmVPcmRlclJlY3Vyc2l2ZSgyICogeCArIDIsIHZpc2l0KTtcbiAgICB9KDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZygnaW5PcmRlcjonKTtcbiAgICB2b2lkIGZ1bmN0aW9uIGluT3JkZXJSZWN1cnNpdmUoeCwgdmlzaXQpIHtcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgaW5PcmRlclJlY3Vyc2l2ZSgyICogeCArIDEsIHZpc2l0KTtcbiAgICAgICAgdmlzaXQodHJlZVt4XSk7XG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMl0pIGluT3JkZXJSZWN1cnNpdmUoMiAqIHggKyAyLCB2aXNpdCk7XG4gICAgfSgwLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ3Bvc3RPcmRlcjonKTtcbiAgICB2b2lkIGZ1bmN0aW9uIHBvc3RPcmRlclJlY3Vyc2l2ZSh4LCB2aXNpdCkge1xuICAgICAgICBpZiAodHJlZVsyICogeCArIDFdKSBwb3N0T3JkZXJSZWN1cnNpdmUoMiAqIHggKyAxLCB2aXNpdCk7XG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMl0pIHBvc3RPcmRlclJlY3Vyc2l2ZSgyICogeCArIDIsIHZpc2l0KTtcbiAgICAgICAgdmlzaXQodHJlZVt4XSk7XG4gICAgfSgwLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIH0pO1xufSkoKTtcblxuLy8g6ZO+5byP5a2Y5YKo57uT5p6EXG5cbnZhciBCaW5hcnlUcmVlID0gZXhwb3J0cy5CaW5hcnlUcmVlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeVRyZWUoKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGxlZnRDaGlsZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciByaWdodENoaWxkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQmluYXJ5VHJlZSk7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8g5bem5Y+z5a2p5a2Q57uT54K5XG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gbGVmdENoaWxkO1xuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkO1xuICAgIH1cblxuICAgIC8vIOWIpOaWreS4pOajteagkeaYr+WQpuebuOS8vFxuXG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCaW5hcnlUcmVlLCBbe1xuICAgICAgICBrZXk6ICdpc1NpbWlsYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTaW1pbGFyKHRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh0cmVlICYmICh0aGlzLmxlZnRDaGlsZCAmJiB0aGlzLmxlZnRDaGlsZC5pc1NpbWlsYXIodHJlZS5sZWZ0Q2hpbGQpIHx8ICF0aGlzLmxlZnRDaGlsZCAmJiAhdHJlZS5sZWZ0Q2hpbGQpICYmICh0aGlzLnJpZ2h0Q2hpbGQgJiYgdGhpcy5yaWdodENoaWxkLmlzU2ltaWxhcih0cmVlLnJpZ2h0Q2hpbGQpIHx8ICF0aGlzLnJpZ2h0Q2hpbGQgJiYgIXRyZWUucmlnaHRDaGlsZCkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjcmVhdGVCaW5hcnlUcmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJpbmFyeVRyZWUodHJlZSkge1xuICAgICAgICAgICAgdm9pZCBmdW5jdGlvbiBwcmVPcmRlclJlY3Vyc2l2ZShub2RlLCB4LCB2aXNpdCkge1xuICAgICAgICAgICAgICAgIHZpc2l0KG5vZGUsIHRyZWVbeF0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHAgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gbm9kZS5sZWZ0Q2hpbGQgPSBuZXcgQmluYXJ5VHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmVPcmRlclJlY3Vyc2l2ZShwLCAyICogeCArIDEsIHZpc2l0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gbm9kZS5yaWdodENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlT3JkZXJSZWN1cnNpdmUocCwgMiAqIHggKyAyLCB2aXNpdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHApIHAucGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9KHRoaXMsIDAsIGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogUHJlZml4IGl0ZXJhdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IF9pdGVyYXRvcjMuZGVmYXVsdCxcbiAgICAgICAgdmFsdWU6IF9yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIHZhbHVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxlZnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmRlbGVnYXRlWWllbGQodGhpcy5sZWZ0Q2hpbGQsICd0MCcsIDQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJpZ2h0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKHRoaXMucmlnaHRDaGlsZCwgJ3QxJywgNik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvLyDlhYjluo/pgY3ljobkuozlj4nmoJHnmoTpnZ7pgJLlvZLnrpfms5VcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHJlT3JkZXJOb25SZWN1cnNpdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJlT3JkZXJOb25SZWN1cnNpdmUodmlzaXQpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBfaW5kZXgyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcztcblxuICAgICAgICAgICAgd2hpbGUgKHAgfHwgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8g5ZCR5bem6LWw5Yiw5bC95aS0XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5kYXRhICYmIHZpc2l0KHAuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5Lit5bqP6Z2e6YCS5b2S6YGN5Y6GXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2luT3JkZXJOb25SZWN1cnNpdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5PcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gbmV3IF9pbmRleDIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzO1xuXG4gICAgICAgICAgICB3aGlsZSAocCB8fCBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAucmlnaHRDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDkuLrkuobljLrliIbkuKTmrKHov4fmoIjnmoTkuI3lkIzlpITnkIbmlrnlvI/vvIzlnKjloIbmoIjkuK3lop7liqDkuIDkuKptYXJr5Z+f77yMXG4gICAgICAgIC8vIG1hcms9MOihqOekuuWImuWImuiuv+mXruatpOe7k+eCue+8jG1hcms9MeihqOekuuW3puWtkOagkeWkhOeQhue7k+adn+i/lOWbnu+8jFxuICAgICAgICAvLyBtYXJrPTLooajnpLrlj7PlrZDmoJHlpITnkIbnu5PmnZ/ov5Tlm57jgILmr4/mrKHmoLnmja7moIjpobbnmoRtYXJr5Z+f5Yaz5a6a5YGa5L2V5Yqo5L2cXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Bvc3RPcmRlck5vblJlY3Vyc2l2ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0T3JkZXJOb25SZWN1cnNpdmUodmlzaXQpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBfaW5kZXgyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goW3RoaXMsIDBdKTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBhWzBdO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goW25vZGUsIDFdKTsgLy8g5L+u5pS5bWFya+Wfn1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdENoaWxkKSBzdGFjay5wdXNoKFtub2RlLmxlZnRDaGlsZCwgMF0pOyAvLyDorr/pl67lt6blrZDmoJFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtub2RlLCAyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKFtub2RlLnJpZ2h0Q2hpbGQsIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgJiYgdmlzaXQobm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwcmVPcmRlclJlY3Vyc2l2ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVPcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQucHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLnByZU9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5PcmRlclJlY3Vyc2l2ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbk9yZGVyUmVjdXJzaXZlKHZpc2l0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLmluT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncG9zdE9yZGVyUmVjdXJzaXZlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5wb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XG4gICAgICAgICAgICB2aXNpdCh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZXZlbE9yZGVyVHJhdmVyc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGV2ZWxPcmRlclRyYXZlcnNlKHZpc2l0KSB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBuZXcgX1F1ZXVlMi5kZWZhdWx0KCk7XG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHRoaXMpO1xuXG4gICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xuICAgICAgICAgICAgICAgIHAubGVmdENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHAucmlnaHRDaGlsZCAmJiBxdWV1ZS5lblF1ZXVlKHAucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmsYLlhYjluo/luo/liJfkuLpr55qE57uT54K555qE5YC8XG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFByZVNlcXVlbmNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZVNlcXVlbmNlKGspIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICAgICAgICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGspIGRhdGEgPSBub2RlLmRhdGE7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlKG5vZGUubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0odGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5rGC5LqM5Y+J5qCR5Lit5Y+25a2Q57uT54K555qE5pWw55uuXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvdW50TGVhdmVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvdW50TGVhdmVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSkgcmV0dXJuIDA7ZWxzZSBpZiAoIW5vZGUubGVmdENoaWxkICYmICFub2RlLnJpZ2h0Q2hpbGQpIHJldHVybiAxO2Vsc2UgcmV0dXJuIHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpICsgcmVjdXJzZShub2RlLnJpZ2h0Q2hpbGQpO1xuICAgICAgICAgICAgfSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOS6pOaNouaJgOaciee7k+eCueeahOW3puWPs+WtkOagkVxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXZvbHV0ZUJpbmFyeVRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmV2b2x1dGVCaW5hcnlUcmVlKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBbdGhpcy5yaWdodENoaWxkLCB0aGlzLmxlZnRDaGlsZF07XG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IF9yZWZbMF07XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSBfcmVmWzFdO1xuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQucmV2b2x1dGVCaW5hcnlUcmVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQucmV2b2x1dGVCaW5hcnlUcmVlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jldm9sdXRlTm9uUmVjdXJzaXZlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJldm9sdXRlTm9uUmVjdXJzaXZlKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjIgPSBbbm9kZS5yaWdodENoaWxkLCBub2RlLmxlZnRDaGlsZF07XG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0Q2hpbGQgPSBfcmVmMlswXTtcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0Q2hpbGQgPSBfcmVmMlsxXTtcblxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdENoaWxkKSBzdGFjay5wdXNoKG5vZGUubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKG5vZGUucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmsYLkuozlj4nmoJHkuK3ku6XlgLzkuLp455qE57uT54K55Li65qC555qE5a2Q5qCR5rex5bqmXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFN1YkRlcHRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN1YkRlcHRoKHgpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgX2luZGV4Mi5kZWZhdWx0KCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSBub2RlLmdldERlcHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2gobm9kZS5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RGVwdGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVwdGgoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmdldERlcHRoKCkgfHwgMDtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5nZXREZXB0aCgpIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gKG0gPiBuID8gbSA6IG4pICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOaJgOacieS7peWFg+e0oHjkuLrmoLnnmoTlrZDmoJFcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVsU3ViWCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxTdWJYKHgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT09IHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5kZWxTdWJYKHgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5kZWxTdWJYKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6Z2e6YCS5b2S5aSN5Yi25LqM5Y+J5qCRXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2Ig5ou36LSd6L+H56iL5Lit5Lya5omn6KGM55qE5Zue6LCD77yM5Y+v5Lul55So5p2l5ou36LSd5YW25a6D6Ieq5a6a5LmJ5bGe5oCnXHJcbiAgICAgICAgICogQHJldHVybnMge0NzdHJ9IOi/lOWbnuaWsOeahOWunuS+i1xyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb3B5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICAgICAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgLy8g55So5p2l5a2Y5pS+5pys5L2T57uT54K555qE5qCIXG4gICAgICAgICAgICB2YXIgc3RhY2sxID0gbmV3IF9pbmRleDIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8g55So5p2l5a2Y5pS+5paw5LqM5Y+J5qCR57uT54K555qE5qCIXG4gICAgICAgICAgICB2YXIgc3RhY2syID0gbmV3IF9pbmRleDIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgc3RhY2sxLnB1c2godGhpcyk7XG4gICAgICAgICAgICB2YXIgQ3N0ciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB2YXIgbmV3VHJlZSA9IG5ldyBDc3RyKCk7XG4gICAgICAgICAgICB2YXIgcSA9IG5ld1RyZWU7XG4gICAgICAgICAgICBzdGFjazIucHVzaChuZXdUcmVlKTtcbiAgICAgICAgICAgIHZhciBwID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2sxLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIOWQkeW3pui1sOWIsOWwveWktFxuICAgICAgICAgICAgICAgIHdoaWxlIChwID0gc3RhY2sxLnBlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC5sZWZ0Q2hpbGQpIHEubGVmdENoaWxkID0gbmV3IENzdHIoKTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubGVmdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBzdGFjazEucHVzaChwLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAgPSBzdGFjazEucG9wKCk7XG4gICAgICAgICAgICAgICAgcSA9IHN0YWNrMi5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGFjazEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBzdGFjazEucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBzdGFjazIucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnJpZ2h0Q2hpbGQpIHEucmlnaHRDaGlsZCA9IG5ldyBDc3RyKCk7XG4gICAgICAgICAgICAgICAgICAgIHEuZGF0YSA9IHAuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY2IocSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAucmlnaHRDaGlsZCk7IC8vIOWQkeWPs+S4gOatpVxuICAgICAgICAgICAgICAgICAgICBzdGFjazIucHVzaChxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5rGC5LqM5Y+J5qCR5Lit57uT54K5cOWSjHHnmoTmnIDov5HnpZblhYhcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmluZE5lYXJBbmNpZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROZWFyQW5jaWVudChwTm9kZSwgcU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXRoUCA9IGZpbmRQYXRoKHRoaXMsIHBOb2RlLCAwKTtcbiAgICAgICAgICAgIHZhciBwYXRoUSA9IGZpbmRQYXRoKHRoaXMsIHFOb2RlLCAwKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHBhdGhQW2ldID09IHBhdGhRW2ldICYmIHBhdGhQW2ldOyBpKyspIHt9XG4gICAgICAgICAgICByZXR1cm4gcGF0aFBbLS1pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7fVxuXG4gICAgICAgIC8vIOaxguS4gOajteS6jOWPieagkeeahOe5geiMguW6plxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsdXNoRGVncmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGx1c2hEZWdyZWUoKSB7XG4gICAgICAgICAgICB2YXIgY291bnRBcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IG5ldyBfUXVldWUyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoe1xuICAgICAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8g5Yip55So5bGC5bqP6YGN5Y6G5p2l57uf6K6h5ZCE5bGC55qE57uT54K55pWwXG4gICAgICAgICAgICB2YXIgciA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XG4gICAgICAgICAgICAgICAgciA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgICAgICAgICBjb3VudEFycltyLmxheWVyXSA9IChjb3VudEFycltyLmxheWVyXSB8fCAwKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoci5ub2RlLmxlZnRDaGlsZCkgcXVldWUuZW5RdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHIubm9kZS5sZWZ0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyLm5vZGUucmlnaHRDaGlsZCkgcXVldWUuZW5RdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHIubm9kZS5yaWdodENoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogci5sYXllciArIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5pyA5ZCO5LiA5Liq6Zif5YiX5YWD57Sg5omA5Zyo5bGC5bCx5piv5qCR55qE6auY5bqmXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gci5sYXllcjtcbiAgICAgICAgICAgIHZhciBtYXggPSBjb3VudEFyclswXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBjb3VudEFycltpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8g5rGC5bGC5pyA5aSn57uT54K55pWwXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50QXJyW2ldID4gbWF4KSBtYXggPSBjb3VudEFycltpXTtcbiAgICAgICAgICAgIH1yZXR1cm4gaGVpZ2h0ICogbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5rGC5qCR57uT54K555qE5a2Q5a2Z5oC75pWw5aGr5YWlZGVzY051beWfn+S4re+8jOW5tui/lOWbnlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZXNjTnVtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2NOdW0oKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gLTE7ZWxzZSBkID0gcmVjdXJzZShub2RlLmxlZnRDaGlsZCkgKyByZWN1cnNlKG5vZGUucmlnaHRDaGlsZCkgKyAyO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5kZXNjTnVtID0gZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIpOaWreS6jOWPieagkeaYr+WQpuWujOWFqOS6jOWPieagkVxuXG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2lzRnVsbEJpbmFyeVRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNGdWxsQmluYXJ5VHJlZSh0cmVlKSB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBuZXcgX1F1ZXVlMi5kZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgZmxhZyA9IDA7XG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHRyZWUpO1xuXG4gICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcXVldWUuZGVRdWV1ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwKSBmbGFnID0gMTtlbHNlIGlmIChmbGFnKSByZXR1cm4gZmFsc2U7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQmluYXJ5VHJlZTtcbn0oKTtcblxuLy8g5rGC5LuOdHJlZeWIsG5vZGXnu5Pngrnot6/lvoTnmoTpgJLlvZLnrpfms5VcblxuXG5mdW5jdGlvbiBmaW5kUGF0aCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzJdO1xuXG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZSh0cmVlLCBpKSB7XG4gICAgICAgIGlmICh0cmVlID09IG5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhbaV0gPSB0cmVlO1xuICAgICAgICBpZiAodHJlZS5sZWZ0Q2hpbGQpIHJlY3Vyc2UodHJlZS5sZWZ0Q2hpbGQsIGkgKyAxKTtcbiAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCAmJiAhZm91bmQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCBpICsgMSk7XG4gICAgICAgIGlmICghZm91bmQpIHBhdGhbaV0gPSBudWxsO1xuICAgIH0odHJlZSwgaSk7XG5cbiAgICByZXR1cm4gcGF0aDtcbn1cblxudmFyIGdsb2JhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpczsnKSgpO1xuXG4vLyDmsYLmt7HluqbnrYnkuo7moJHnmoTpq5jluqblh4/kuIDnmoTmnIDpnaDlt6bnmoTnu5PngrlcbmZ1bmN0aW9uIHByaW50UGF0aF9tYXhEZXB0aFMxKHRyZWUpIHtcbiAgICB2YXIgbWF4aCA9IHRyZWUuZ2V0RGVwdGgoKTtcbiAgICB2YXIgcGF0aCA9IFtdO1xuXG4gICAgaWYgKG1heGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgZmluZF9oKHRyZWUsIDEpO1xuXG4gICAgZnVuY3Rpb24gZmluZF9oKHRyZWUsIGgpIHtcbiAgICAgICAgcGF0aFtoXSA9IHRyZWU7XG5cbiAgICAgICAgaWYgKGggPT0gbWF4aCAtIDEpIHtcbiAgICAgICAgICAgIHZhciBzID0gJyAnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IHBhdGhbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHMgKz0gcGF0aFtpXS5kYXRhICsgKHBhdGhbaSArIDFdID8gJyAtPiAnIDogJycpO1xuICAgICAgICAgICAgfWNvbnNvbGUubG9nKHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSBmaW5kX2godHJlZS5sZWZ0Q2hpbGQsIGggKyAxKTtcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIGZpbmRfaCh0cmVlLnJpZ2h0Q2hpbGQsIGggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhbaF0gPSBudWxsO1xuICAgIH1cbn1cblxudmFyIHRyZWUgPSBbMSwgMiwgMywgNCwgNSwsIDYsLCwgN107XG52YXIgdGVzdCA9IG5ldyBCaW5hcnlUcmVlKCk7XG50ZXN0LmNyZWF0ZUJpbmFyeVRyZWUodHJlZSk7XG5cbmNvbnNvbGUubG9nKCdpdGVyYXRvcjogJyk7XG52YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG52YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbnZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxudHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KSh0ZXN0KSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgeCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKHgpO1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICog5qCR55qEM+enjeW4uOeUqOmTvuihqOe7k+aehFxyXG4gICAgICovXG5cbiAgICAvLyAxLuWPjOS6suihqOekuuazlVxuICAgIC8vIOS8mOeCue+8mnBhcmVudCh0cmVlLCB4KeaTjeS9nOWPr+S7peWcqOW4uOmHj+aXtumXtOWGheWunueOsFxuICAgIC8vIOe8uueCue+8muaxgue7k+eCueeahOWtqeWtkOaXtumcgOimgemBjeWOhuaVtOS4que7k+aehFxufSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xufSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIFBhcmVudFRyZWUgPSBleHBvcnRzLlBhcmVudFRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyZW50VHJlZSgpIHtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgUGFyZW50VHJlZSk7XG5cbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFBhcmVudFRyZWUsIFt7XG4gICAgICAgIGtleTogJ2dldERlcHRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgICAgICAgICAgdmFyIG1heERlcHRoID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPj0gMDsgaiA9IHRoaXMubm9kZXNbaV0ucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcCsrO1xuICAgICAgICAgICAgICAgIH1pZiAoZGVwID4gbWF4RGVwdGgpIG1heERlcHRoID0gZGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF4RGVwdGg7XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFBhcmVudFRyZWU7XG59KCk7XG5cbnZhciBQYXJlbnRUcmVlTm9kZSA9IGZ1bmN0aW9uIFBhcmVudFRyZWVOb2RlKCkge1xuICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBQYXJlbnRUcmVlTm9kZSk7XG5cbiAgICAvLyB0eXBlOiBQYXJlbnRUcmVlXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyDlj4zkurLkvY3nva7ln58ge051bWJlcn1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn07XG5cbnZhciBwdCA9IG5ldyBQYXJlbnRUcmVlKCk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnUicsIC0xKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnQScsIDApKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdCJywgMCkpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0MnLCAwKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRCcsIDEpKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdFJywgMSkpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0YnLCAzKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRycsIDYpKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdIJywgNikpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0knLCA2KSk7XG5cbi8vIOWtqeWtkOihqOekuuazlVxuXG52YXIgQ2hpbGRUcmVlID0gZXhwb3J0cy5DaGlsZFRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hpbGRUcmVlKCkge1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBDaGlsZFRyZWUpO1xuXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShDaGlsZFRyZWUsIFt7XG4gICAgICAgIGtleTogJ2dldERlcHRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN1YkRlcHRoKHJvb3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5ub2Rlc1tyb290SW5kZXhdKSByZXR1cm4gMTtcblxuICAgICAgICAgICAgICAgIHZhciBzZCA9IDE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IHNlbGYubm9kZXNbcm9vdEluZGV4XTsgcDsgcCA9IHAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHN1YkRlcHRoKHAuY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IHNkKSBzZCA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNkICsgMTtcbiAgICAgICAgICAgIH0odGhpcy5kYXRhWzBdKTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ2hpbGRUcmVlO1xufSgpO1xuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gKiBAcGFyYW0ge0NoaWxkVHJlZU5vZGV9IGZpcnN0Q2hpbGQg5a2p5a2Q6ZO+6KGo5aS05oyH6ZKIXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cblxuXG52YXIgQ2hpbGRUcmVlQm94ID0gZnVuY3Rpb24gQ2hpbGRUcmVlQm94KCkge1xuICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ2hpbGRUcmVlQm94KTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5maXJzdENoaWxkID0gZmlyc3RDaGlsZDtcbn07XG5cbi8qKlxyXG4gKiDlranlrZDnu5PngrlcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNoaWxkXHJcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gbmV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5cblxudmFyIENoaWxkVHJlZU5vZGUgPSBmdW5jdGlvbiBDaGlsZFRyZWVOb2RlKCkge1xuICAgIHZhciBjaGlsZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5leHQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzFdO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIENoaWxkVHJlZU5vZGUpO1xuXG4gICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xuICAgIHRoaXMubmV4dCA9IG5leHQ7XG59O1xuXG4vKlxyXG4g5a2p5a2Q6KGo56S65rOV5L6/5LqO5raJ5Y+K5a2p5a2Q55qE5pON5L2c55qE5a6e546w77yM5L2G5LiN6YCC55So5LqOcGFyZW505pON5L2c44CCXHJcbiDmiJHku6zlj6/ku6Xmiorlj4zkurLooajnpLrms5XlkozlranlrZDooajnpLrms5Xnu5PlkIjotbfmnaXjgIJcclxuICovXG5cbi8vIOWtqeWtkOWFhOW8n+ihqOekuuazlSjkuozlj4nmoJHooajnpLrms5UpXG4vLyDlj6/lop7orr7kuIDkuKpwYXJlbnTln5/lrp7njrBwYXJlbnTmk43kvZxcblxuXG52YXIgQ2hpbGRTaWJsaW5nVHJlZSA9IGV4cG9ydHMuQ2hpbGRTaWJsaW5nVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGlsZFNpYmxpbmdUcmVlKCkge1xuICAgICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ2hpbGRTaWJsaW5nVHJlZSk7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIC8vIOi+k+WHuuWtqeWtkOWFhOW8n+mTvuihqOihqOekuueahOagkeeahOWQhOi+uVxuXG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShDaGlsZFNpYmxpbmdUcmVlLCBbe1xuICAgICAgICBrZXk6ICdwcmludCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gdGhpcy5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCclYyAlYycsIHRoaXMuZGF0YSwgY2hpbGQuZGF0YSk7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOaxguWtqeWtkOWFhOW8n+mTvuihqOihqOekuueahOagkeeahOWPtuWtkOaVsOebrlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZWFmQ291bnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVhZkNvdW50KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpcnN0Q2hpbGQpIHJldHVybiAxO2Vsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hpbGQgPSB0aGlzLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGNoaWxkLmxlYWZDb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmsYLmoJHnmoTluqZcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RGVncmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZ3JlZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMDtlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gdGhpcy5maXJzdENoaWxkOyBwOyBwID0gcC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWdyZWUrKztcbiAgICAgICAgICAgICAgICB9Zm9yICh2YXIgX3AgPSB0aGlzLmZpcnN0Q2hpbGQ7IF9wOyBfcCA9IF9wLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX3AuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkID4gZGVncmVlKSBkZWdyZWUgPSBkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldERlcHRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMgPT09IGdsb2JhbCkgcmV0dXJuIDA7ZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heGQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSB0aGlzLmZpcnN0Q2hpbGQ7IHA7IHAgPSBwLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gcC5nZXREZXB0aCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IG1heGQpIG1heGQgPSBkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtYXhkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ2hpbGRTaWJsaW5nVHJlZTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiDmoIhcclxuICpcclxuICog5piv6ZmQ5a6a5LuF5Zyo6KGo5bC+6L+b6KGM5o+S5YWl5oiW5Yig6Zmk5pON5L2c55qE57q/5oCn6KGo44CC6KGo5bC+5Li65qCI6aG277yIdG9w77yJ77yM6KGo5aS05Li65qCI5bqV77yIYm90dG9t77yJ77yM5LiN5ZCr5YWD57Sg55qE56m66KGo5Li656m65qCI44CCXHJcbiAqIOagiOWPiOensOS4uuWQjui/m+WFiOWHuu+8iGxhc3QgaW4gZmlyc3Qgb3V077yJ55qE57q/5oCn6KGo44CCXHJcbiAqL1xuXG4vKipcclxuICog6aG65bqP5qCIXHJcbiAqIOagiOeahOmhuuW6j+WtmOWCqOe7k+aehOaYr+WIqeeUqOS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeWtmOaUvuiHs+agiOW6leWIsOagiOmhtueahOWFg+e0oO+8jOWQjOaXtumZhOiuvuaMh+mSiHRvcOaMh+ekuuagiOmhtuWFg+e0oOWcqOmhuuW6j+agiOS4reeahOS9jee9ruOAglxyXG4gKlxyXG4gKi9cblxuLy8g5qCI55qE6ZO+5byP6KGo56S6XG5cbnZhciBTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGFjaygpIHtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3RhY2spO1xuXG4gICAgICAgIHRoaXMudG9wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFN0YWNrLCBbe1xuICAgICAgICBrZXk6ICdpc0VtcHR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3B1c2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgdGhpcy50b3AgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGVlaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSBudWxsID8gbnVsbCA6IHRoaXMudG9wLmRhdGE7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BvcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b3AgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgb3V0ID0gdGhpcy50b3A7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wLm5leHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMubGVuZ3RoLS07XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQuZGF0YTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xlYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnRvcDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpemUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gU3RhY2s7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0YWNrO1xuXG5cbnZhciBzdGFjayA9IG5ldyBTdGFjaygpO1xuXG5zdGFjay5wdXNoKDEpO1xuc3RhY2sucHVzaCgnYXNkJyk7XG5cbnN0YWNrLnBvcCgpO1xuc3RhY2sucHVzaCh7IGE6IDEgfSk7XG5jb25zb2xlLmxvZyhzdGFjayk7XG5cbi8qKlxyXG4gKiDov5nph4znlKjlrZfnrKbkuLJ0cmFpbuihqOekuueBq+i9pu+8jEjooajnpLrnoazluK3vvIxT6KGo56S66L2v5bitXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFpblxyXG4gKi9cbmZ1bmN0aW9uIHRyYWluQXJyYW5nZSh0cmFpbikge1xuICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIHZhciBxID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHdoaWxlICh0cmFpbltpXSkge1xuICAgICAgICBpZiAodHJhaW5baV0gPT09ICdIJykgc3RhY2sucHVzaCh0cmFpbltpXSk7ZWxzZSBxW2orK10gPSB0cmFpbltpXTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgcVtqKytdID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gcSArICcnO1xufVxuXG5jb25zb2xlLmxvZygndHJhaW5BcnJhbmdlOiAnICsgdHJhaW5BcnJhbmdlKCdIU1NIU1NTSEhISEhTJykpOyAvLyB0cmFpbkFycmFuZ2U6IFMsUyxTLFMsUyxTLEgsSCxILEgsSCxILEhcblxuLy8g5Yik5pat5a2X56ym5Liy5Lit4oCcJuKAneWJjeWSjOKAnCbigJ3lkI7pg6jliIbmmK/lkKbkuLrpgIbkuLLvvIxcIkBcIuihqOekuue7k+adn+espu+8jOaYr+WImei/lOWbnnRydWXvvIzlkKbliJnov5Tlm55mYWxzZVxuZnVuY3Rpb24gaXNSZXZlcnNlKHN0cikge1xuICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChzdHJbaV0gIT09ICcmJykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnQCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhY2sucHVzaChzdHJbaV0pO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaSsrO1xuXG4gICAgd2hpbGUgKHN0cltpXSAhPT0gJ0AnKSB7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKHMgIT09IHN0cltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuICFzdGFjay5sZW5ndGg7XG59XG5cbmNvbnNvbGUubG9nKCdpc1JldmVyc2U6ICcgKyBpc1JldmVyc2UoJ2FiY2QmZGNiYUBhJykpOyAvLyB0cnVlXG5cbi8vIOaVsOWAvOi/m+WItui9rOaNolxuLy8g5YWs5byP77yaIE4gPSAoTiAvIGQpICogZCArIE4gJSBkXG4vLyBO77ya5Y2B6L+b5Yi25pWw5YC877yMIGTvvJrpnIDopoHovazmjaLnmoTov5vliLbmlbBcbmZ1bmN0aW9uIG51bVRyYW5zZm9ybShudW1iZXIsIHJhZCkge1xuICAgIHZhciBzID0gbmV3IFN0YWNrKCk7XG5cbiAgICB3aGlsZSAobnVtYmVyKSB7XG4gICAgICAgIHMucHVzaChudW1iZXIgJSByYWQpO1xuICAgICAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIgLyA4LCAxMCk7XG4gICAgfVxuXG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHdoaWxlIChzLnRvcCkge1xuICAgICAgICBhcnIucHVzaChzLnBvcCgpKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coYXJyLmpvaW4oJycpKTtcbn1cblxubnVtVHJhbnNmb3JtKDEzNDgsIDgpO1xubnVtVHJhbnNmb3JtKDEzNDgsIDIpO1xuXG4vLyDmi6zlj7fljLnphY3mo4Dmn6VcbmZ1bmN0aW9uIGJyYWNrZXRzTWF0Y2goc3RyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgdmFyIHRleHQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHJbaV07XG4gICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCB8fCBzdGFjay5wb3AoKSAhPT0gJ1snKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJhY2tldHM6JyArIGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCArPSBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKHRleHQpO1xufVxuXG5jb25zb2xlLmxvZyhicmFja2V0c01hdGNoKCdbYXNkXScpKTtcblxuZnVuY3Rpb24gTWF0Y2hlcihsZWZ0LCByaWdodCkge1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgU3RhY2soKTtcbn1cbk1hdGNoZXIucHJvdG90eXBlID0ge1xuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChzdHIpIHtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0cltpXTtcbiAgICAgICAgICAgIGlmIChjID09PSB0aGlzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2sucG9wKCkgIT09IHRoaXMubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJhY2tldHM6JyArIGMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG59O1xudmFyIG0gPSBuZXcgTWF0Y2hlcigneycsICd9Jyk7XG5tLm1hdGNoKCdbezEyM30xMjMnKTtcblxuZnVuY3Rpb24gTGluZUVkaXRvcihzdHIpIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgdGhpcy5zdHIgPSBzdHIgfHwgJyc7XG59XG5MaW5lRWRpdG9yLnByb3RvdHlwZSA9IHtcbiAgICBnZXRSZXN1bHQ6IGZ1bmN0aW9uIGdldFJlc3VsdCgpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuc3RyO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0cltpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgY3VycmVudCA9IHN0YWNrLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnQuZGF0YSArIHJlc3VsdDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbnZhciBsZSA9IG5ldyBMaW5lRWRpdG9yKCd3aGxpIyNpbHIjZShzIypzKVxcXHJcbiAgICBcXG5vdXRjaGFAcHV0Y2hhcigqcz0jKyspJyk7XG5jb25zb2xlLmxvZyhsZS5nZXRSZXN1bHQoKSk7XG5cbnZhciBwcmlvdHkgPSB7XG4gICAgXCIrXCI6IDEsXG4gICAgXCItXCI6IDEsXG4gICAgXCIlXCI6IDIsXG4gICAgXCIqXCI6IDIsXG4gICAgXCIvXCI6IDIsXG4gICAgXCJeXCI6IDMsXG4gICAgXCIoXCI6IDAsXG4gICAgXCIpXCI6IDAsXG4gICAgXCJgXCI6IC0xXG59O1xuXG5mdW5jdGlvbiBkb29wKG9wLCBvcG4xLCBvcG4yKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgKyBvcG4yO1xuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgLSBvcG4yO1xuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgKiBvcG4yO1xuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgLyBvcG4yO1xuICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgJSBvcG4yO1xuICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KG9wbjEsIG9wbjIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvcGNvbXAoYSwgYikge1xuICAgIHJldHVybiBwcmlvdHlbYV0gLSBwcmlvdHlbYl07XG59XG5cbmZ1bmN0aW9uIGNhbEluZml4RXhwcmVzc2lvbihleHApIHtcbiAgICB2YXIgY3MgPSBbXTtcbiAgICB2YXIgbnMgPSBbXTtcbiAgICBleHAgPSBleHAucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xuICAgIGV4cCArPSAnYCc7XG4gICAgaWYgKGV4cFswXSA9PT0gJy0nKSB7XG4gICAgICAgIGV4cCA9IFwiMFwiICsgZXhwO1xuICAgIH1cbiAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICB2YXIgb3AgPSB2b2lkIDA7XG4gICAgdmFyIG9wbjEgPSB2b2lkIDA7XG4gICAgdmFyIG9wbjIgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYyA9IGV4cFtpXTtcbiAgICAgICAgLy8g5aaC5p6c5piv5pON5L2c56ymXG4gICAgICAgIGlmIChjIGluIHByaW90eSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5Y+z6L655LiN5piv5bem5ous5Y+35LiU5pON5L2c56ym5qCI55qE5qCI6aG25YWD57Sg5LyY5YWI5p2D5q+U5Y+z6L655aSnXG4gICAgICAgICAgICAvLyDlvqrnjq/pgY3ljobov5vooYzov57nu63ov5DnrpdcbiAgICAgICAgICAgIHdoaWxlIChjICE9ICcoJyAmJiBjcy5sZW5ndGggJiYgb3Bjb21wKGNzW2NzLmxlbmd0aCAtIDFdLCBjKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8g5Ye65qCI55qE5pON5L2c56ymXG4gICAgICAgICAgICAgICAgb3AgPSBjcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkuI3mmK/lt6bmi6zlj7fmiJbogIXlj7Pmi6zlj7fvvIzor7TmmI7mmK/ov5DnrpfnrKZcbiAgICAgICAgICAgICAgICBpZiAob3AgIT0gJygnICYmIG9wICE9ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAvLyDlh7rmoIjkv53lrZjmlbDlrZfnmoTmoIjnmoTkuKTkuKrlhYPntKBcbiAgICAgICAgICAgICAgICAgICAgb3BuMiA9IG5zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBvcG4xID0gbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWwhuS4juaTjeS9nOespui/kOeul+WQjueahOe7k+aenOS/neWtmOWIsOagiOmhtlxuICAgICAgICAgICAgICAgICAgICBucy5wdXNoKGRvb3Aob3AsIG9wbjEsIG9wbjIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlpoLmnpzlj7PovrnkuI3mmK/lj7Pmi6zlj7fvvIzkv53lrZjliLDmk43kvZznrKbmoIjkuK1cbiAgICAgICAgICAgIGlmIChjICE9ICcpJykgY3MucHVzaChjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOWkmuS9jeaVsOeahOaVsOWtl+eahOaDheWGtVxuICAgICAgICAgICAgd2hpbGUgKCEoZXhwW2ldIGluIHByaW90eSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYyArPSBleHBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBucy5wdXNoKHBhcnNlRmxvYXQoYykpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBucy5sZW5ndGggPyBuc1swXSA6IE5hTjtcbn1cblxudmFyIGV4cDEgPSBjYWxJbmZpeEV4cHJlc3Npb24oJzUrMyo0LzItMl4zKzUlMicpO1xuY29uc29sZS5sb2coZXhwMSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9TdGFjay9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcclxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0Q29tcGFyZTtcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGxkcCBvbiAyMDE1LzQvMTIuXHJcbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9Tb3J0L2RlZmF1bHRDb21wYXJpc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cclxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XHJcblxyXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXHJcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcclxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xyXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXHJcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxyXG4gICAgLCBndCAgICAgPSAnPidcclxuICAgICwgaWZyYW1lRG9jdW1lbnQ7XHJcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxyXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XHJcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xyXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LkY9T2JqZWN0PC9zY3JpcHQnICsgZ3QpO1xyXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XHJcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XHJcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xyXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xyXG4gIHZhciByZXN1bHQ7XHJcbiAgaWYoTyAhPT0gbnVsbCl7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XHJcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcclxuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcclxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xyXG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XHJcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcclxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXHJcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcclxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xyXG4gIE8gPSB0b0lPYmplY3QoTyk7XHJcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xyXG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XHJcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcclxuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XHJcbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxyXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcclxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXHJcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxyXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XHJcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXRpbC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXVxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xufVxuXG5pbml0KClcblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYXNlNjQtanMvbGliL2I2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXHJcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcclxuXHJcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxyXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xyXG4gIE8gPSB0b09iamVjdChPKTtcclxuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcclxuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcclxuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBtZDUgPSB0b0NvbnN0cnVjdG9yKHJlcXVpcmUoJy4vbWQ1JykpXG52YXIgcm1kMTYwID0gdG9Db25zdHJ1Y3RvcihyZXF1aXJlKCdyaXBlbWQxNjAnKSlcblxuZnVuY3Rpb24gdG9Db25zdHJ1Y3RvciAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdXG4gICAgdmFyIG09IHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICAgICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKVxuICAgICAgICB2YXIgciA9IGZuKGJ1ZilcbiAgICAgICAgYnVmZmVycyA9IG51bGxcbiAgICAgICAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhbGcpIHtcbiAgaWYoJ21kNScgPT09IGFsZykgcmV0dXJuIG5ldyBtZDUoKVxuICBpZigncm1kMTYwJyA9PT0gYWxnKSByZXR1cm4gbmV3IHJtZDE2MCgpXG4gIHJldHVybiBjcmVhdGVIYXNoKGFsZylcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L2NyZWF0ZS1oYXNoLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuVUlOVDMyID0gcmVxdWlyZSgnLi9saWIvdWludDMyJylcbmV4cG9ydHMuVUlOVDY0ID0gcmVxdWlyZSgnLi9saWIvdWludDY0JylcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jdWludC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWdlbmVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3InKTtcblxudmFyIF9yZWdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWdlbmVyYXRvcik7XG5cbnZhciBfaXRlcmF0b3IzID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvcicpO1xuXG52YXIgX2l0ZXJhdG9yNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yMyk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvcicpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICog5b6q546v6ZO+6KGo77yIY2lyY3VsYXIgbGlua2VkIGxpc3TvvIlcclxuICog5piv5Y+m5LiA56eN5b2i5byP55qE6ZO+5byP5a2Y5YKo57uT5p6E44CC5a6D55qE54m554K55piv6KGo5Lit5pyA5ZCO5LiA5Liq57uT54K555qE5oyH6ZKI5Z+f5oyH5ZCR5aS057uT54K577yM5pW05Liq6KGo5b2i5oiQ5LiA5Liq546v44CCXHJcbiAqIOW+queOr+mTvuihqOeahOaTjeS9nOWSjOe6v+aAp+mTvuihqOWfuuacrOS4gOiHtO+8jOS7heaciee7huW+ruW3ruWIq+OAglxyXG4gKi9cblxuLyoqXHJcbiAqIOWPjOWQkemTvuihqFxyXG4gKlxyXG4gKiDlj4zlkJHpk77ooajmmK/kuLrkuoblhYvmnI3ljZXpk77ooajov5nnp43ljZXlkJHmgKfnmoTnvLrngrnjgIJcclxuICog5Y+M5ZCR6ZO+6KGo55qE57uT54K55Lit5pyJ5Lik5Liq5oyH6ZKI5Z+f77yM5YW25LiA5oyH5ZCR55u05o6l5ZCO57un77yM5Y+m5LiA5oyH5ZCR55u05o6l5YmN6LaL44CCXHJcbiAqXHJcbiAqIOWPjOWQkemTvuihqOS5n+WPr+S7peacieW+queOr+ihqOOAglxyXG4gKi9cblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgICB2YXIgcHJldiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIG5leHQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE5vZGUpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgIHRoaXMubmV4dCA9IG5leHQ7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5cbnZhciBEb3VibGVMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvdWJsZUxpbmtlZExpc3Qoc3FMaXN0KSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbXBhcmUgOiBhcmd1bWVudHNbMV07XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIERvdWJsZUxpbmtlZExpc3QpO1xuXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG5cbiAgICAgICAgaWYgKHNxTGlzdCAmJiBzcUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShzcUxpc3QpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShEb3VibGVMaW5rZWRMaXN0LCBbe1xuICAgICAgICBrZXk6IF9pdGVyYXRvcjQuZGVmYXVsdCxcbiAgICAgICAgdmFsdWU6IF9yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yMi5kZWZhdWx0LndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfSlcbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NsZWFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHVzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZGF0YSBhcmd1bWVudCByZXF1aXJlZCcpO1xuXG4gICAgICAgICAgICArK3RoaXMuc2l6ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShkYXRhLCB0aGlzLnRhaWwsIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5zaGlmdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZGF0YSBhcmd1bWVudCByZXF1aXJlZCcpO1xuXG4gICAgICAgICAgICArK3RoaXMuc2l6ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShkYXRhLCBudWxsLCB0aGlzLmhlYWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC0tdGhpcy5zaXplO1xuXG4gICAgICAgICAgICB0aGlzLnRhaWwucHJldi5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaGlmdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC0tdGhpcy5zaXplO1xuXG4gICAgICAgICAgICB0aGlzLmhlYWQubmV4dC5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1cGRhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGluZGV4LCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZmluZEJ5SW5kZXgoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGFyZ3VtZW50IHJlcXVpcmVkJyk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoZGF0YSwgY3VycmVudC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wcmV2Lm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldiA9IGN1cnJlbnQucHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbmRleE9mJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoZGF0YSwgY3VycmVudC5kYXRhKSkgcmV0dXJuIGluZGV4O1xuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaW5kQnlJbmRleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQnlJbmRleCgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgcmV0dXJuTm9kZSA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgaiA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGorKyA9PT0gaW5kZXgpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldHVybk5vZGUgPyBjdXJyZW50IDogY3VycmVudC5kYXRhO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmb3JFYWNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goKSB7XG4gICAgICAgICAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNiKGN1cnJlbnQuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0pTT04nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChjdXJyZW50LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCkgKyAnJztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGVuZ3RoJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBEb3VibGVMaW5rZWRMaXN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEb3VibGVMaW5rZWRMaXN0O1xuXG5cbnZhciBhID0gbmV3IERvdWJsZUxpbmtlZExpc3QoWzIsIDNdKTtcbmEudW5zaGlmdCgxKTtcbmEucHVzaCg0KTtcbmNvbnNvbGUubG9nKGEuaW5kZXhPZig0KSk7XG5jb25zb2xlLmxvZyhhLmZpbmRCeUluZGV4KDIpKTtcblxudmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbnZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbnZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbnRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKGEpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgY29uc29sZS5sb2coaXRlbSk7XG4gICAgfVxufSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG59IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmEucG9wKCk7XG5hLnNoaWZ0KCk7XG5hLnJlbW92ZSgyKTtcbmEucmVtb3ZlKDMyKTtcbmEucmVtb3ZlKDMpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvTGlzdC9Eb3VibGVMaW5rZWRMaXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N0cmluZ2lmeSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeScpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvcicpO1xuXG52YXIgX3JlZ2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlZ2VuZXJhdG9yKTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3InKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICog55Sx5LqO6ZO+6KGo5Zyo56m66Ze055qE5ZCI55CG5Yip55So5LiK5ZKM5o+S5YWl77yM5Yig6Zmk5pe25LiN6ZyA6KaB56e75Yqo562J55qE5pyJ54K577yM5Zug5q2k5Zyo5b6I5aSa5Zy65ZCI5LiL77yM5a6D5piv57q/5oCn6KGo55qE6aaW6YCJ5a2Y5YKo57uT5p6E44CC54S26ICM77yM5a6D5Lmf5a2Y5Zyo552A5a6e546w5p+Q5Lqb5Z+65pys5pON5L2c77yM5aaC5rGC57q/5oCn6KGo6ZW/5bqm5pe25LiN5aaC6aG65bqP5a2Y5YKo57uT5p6E55qE57y654K577yb5Y+m5LiA5pa56Z2i77yM55Sx5LqO5Zyo6ZO+6KGo5Lit77yM57uT54K55LmL6Ze055qE5YWz57O75L2/55So5oyH6ZKI5p2l6KGo56S677yM5YiZ5pWw5o2u5YWD57Sg5Zyo57q/5oCn6KGo5Lit55qE4oCc5L2N5bqP4oCd55qE5qaC5b+15bey5reh5YyW77yM6ICM6KKr5pWw5o2u5YWD57Sg5Zyo57q/5oCn6ZO+6KGo5Lit55qE4oCc5L2N572u4oCd5omA5Luj5pu/44CC5Li65q2k77yM5LuO5a6e6ZmF5Ye65Y+R6YeN5paw5a6a5LmJ57q/5oCn6ZO+6KGo5Y+K5YW25Z+65pys5pON5L2cXHJcbiAqL1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBuZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBOb2RlKTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5uZXh0ID0gbmV4dDtcbn07XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3Qoc3FMaXN0KSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIExpbmtlZExpc3QpO1xuXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHNxTGlzdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChzcUxpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoTGlua2VkTGlzdCwgW3tcbiAgICAgICAga2V5OiAnc2hpZnQnLFxuXG5cbiAgICAgICAgLy8gZGVsZXRlIGZpcnN0IGVsZW1lbnQgYW5kIHJldHVybiBpdFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICAgICAgaGVhZC5uZXh0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gbnVsbCkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwb3AnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YWlsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzLnRhaWwuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHByZXZpb3VzO1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0gOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGVuZCBub2RlXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FwcGVuZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQobm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGRhdGFcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHVzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbmV3IE5vZGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGFpbC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBkYXRhXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gY3VycmVudC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLnRhaWwpIHRoaXMudGFpbCA9IHByZXZpb3VzO1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0gOiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5kZXhPZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YSA9PT0gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1bnNoaWZ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgIHRlbXAubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2luc2VydEFmdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHRhcmdldCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLm5leHQgPSBjdXJyZW50Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMudGFpbCkgdGhpcy50YWlsID0gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXRlbScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpdGVtKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS1pbmRleCA9PT0gMCkgcmV0dXJuIGN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWFjaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgICAgICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY3VycmVudCkpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IF9pdGVyYXRvcjIuZGVmYXVsdCxcbiAgICAgICAgdmFsdWU6IF9yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yMi5kZWZhdWx0LndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH0pXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHZhciBzaXplID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICArK3NpemU7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gbm9kZS5kYXRhICsgKG5vZGUubmV4dCA/ICcsJyA6ICcnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvcmRlckluc2VydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcmRlckluc2VydChkYXRhLCBjbXApIHtcbiAgICAgICAgICAgIGNtcCA9IHR5cGVvZiBjbXAgPT09ICdmdW5jdGlvbicgPyBjbXAgOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7ZWxzZSBpZiAoYSA9PT0gYikgcmV0dXJuIDA7ZWxzZSByZXR1cm4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5oZWFkO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE5vZGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY21wKGRhdGEsIGN1cnJlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5o+S5YWl5YWD57Sg5aSn5LqO5b2T5YmN5YWD57Sg77yM5YeG5aSH5LiL5qyh6YGN5Y6GXG4gICAgICAgICAgICAgICAgaWYgKHJldCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOetieS6ju+8jOebtOaOpeaPkuWFpeWIsOWQjumdolxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOWwj+S6juWImeaPkuWFpeWIsOWJjeiKgueCueWSjOW9k+WJjeiKgueCueS4rVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5Zug5Li65bey57uP5piv5o6S5bqP5LqG77yM5omA5Lul5LiN6ZyA6KaB5aSa5L2Z5Yik5pat5LqGXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gcHJldmlvdXMgJiYgcHJldmlvdXMgPT09IGN1cnJlbnQpIHJldHVybiB0aGlzLnVuc2hpZnQoZGF0YSk7ZWxzZSByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOaPkuWFpeWIsOacgOWQjuS4gOS4que7k+eCuVxuICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldmlvdXMubmV4dDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QmV0d2VlbihkYXRhLCBhLCBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT0gYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PSBtZS5oZWFkKSByZXR1cm4gbWUudW5zaGlmdChkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLm5leHQgPSBiO1xuICAgICAgICAgICAgICAgICAgICBhLm5leHQgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDliKDpmaTlhYPntKDpgJLlop7mjpLliJfnmoTpk77ooajkuK3lgLzlpKfkuo5taW7vvIzkuJTlsI/kuo5tYXjnmoTmiYDmnInlhYPntKBcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVsZXRlX2JldHdlZW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlX2JldHdlZW4obWluLCBtYXgpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgICAvLyBw5piv5pyA5ZCO5LiA5Liq5LiN5aSn5LqObWlu55qE5YWD57SgXG4gICAgICAgICAgICB3aGlsZSAocC5uZXh0ICYmIHAubmV4dC5kYXRhIDw9IG1pbikge1xuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICB9IC8vIOWmguaenOi/mOacieavlG1pbuabtOWkp+eahOWFg+e0oFxuICAgICAgICAgICAgdmFyIHEgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgcSA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICAvLyBx5piv56ys5LiA5Liq5LiN5bCP5LqObWF455qE5YWD57SgXG4gICAgICAgICAgICAgICAgd2hpbGUgKHEgJiYgcS5kYXRhIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHQ7XG4gICAgICAgICAgICAgICAgfXAubmV4dCA9IHE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXN0ID0gcSB8fCBwO1xuICAgICAgICAgICAgd2hpbGUgKGxhc3QubmV4dCkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgICAgICAgICB9dGhpcy50YWlsID0gbGFzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOWFg+e0oOmAkuWinuaOkuWIl+eahOmTvuihqOeahOmHjeWkjeWFg+e0oFxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZWxldGVfZXF1YWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlX2VxdWFsKCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgcSA9IHAubmV4dDtcblxuICAgICAgICAgICAgd2hpbGUgKHAubmV4dCkge1xuICAgICAgICAgICAgICAgIC8vIOW9k+ebuOmCu+S4pOWFg+e0oOS4jeebuOetieaXtu+8jHAscemDveWQkeWQjuenu1xuICAgICAgICAgICAgICAgIGlmIChwLmRhdGEgIT09IHEuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICBxID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxLmRhdGEgPT09IHAuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyDliKDpmaRcbiAgICAgICAgICAgICAgICAgICAgcC5uZXh0ID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXZlcnNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHZhciBxID0gcC5uZXh0O1xuICAgICAgICAgICAgdmFyIHMgPSBxLm5leHQ7XG4gICAgICAgICAgICBwLm5leHQgPSBudWxsO1xuXG4gICAgICAgICAgICB3aGlsZSAocy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgcS5uZXh0ID0gcDtcbiAgICAgICAgICAgICAgICBwID0gcTtcbiAgICAgICAgICAgICAgICBxID0gcztcbiAgICAgICAgICAgICAgICBzID0gcy5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxLm5leHQgPSBwO1xuICAgICAgICAgICAgcy5uZXh0ID0gcTtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHM7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnbWVyZ2VMaXN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlTGlzdChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGNvbXBGbiA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgICAgdmFyIGhhID0gYS5oZWFkO1xuICAgICAgICAgICAgdmFyIGhiID0gYi5oZWFkO1xuICAgICAgICAgICAgdmFyIHBhID0gaGE7XG4gICAgICAgICAgICB2YXIgcGIgPSBoYjtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgICAgIHZhciBxID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAocGEgJiYgcGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YTEgPSBwYS5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhMiA9IHBiLmRhdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUoZGF0YTEsIGRhdGEyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgaGVhZCBub2RlXG4gICAgICAgICAgICAgICAgICAgIHEgPSBhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgbm9kZSB0byBjIGxpbmtlZExpc3RcbiAgICAgICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XG4gICAgICAgICAgICAgICAgICAgIHBhID0gYS5oZWFkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBiLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMuYXBwZW5kKHEpO1xuICAgICAgICAgICAgICAgICAgICBwYiA9IGIuaGVhZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYSkgYy5hcHBlbmQocGEpO2Vsc2UgYy5hcHBlbmQocGIpO1xuXG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGlua2VkTGlzdDtcblxuXG5mdW5jdGlvbiBjb21wRm4oYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXG5mdW5jdGlvbiBpbnRlcnNlY3QobGlzdCwgYkxpc3QpIHtcbiAgICB2YXIgY0xpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuXG4gICAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gICAgdmFyIHEgPSBiTGlzdC5oZWFkO1xuXG4gICAgd2hpbGUgKHAgJiYgcSkge1xuICAgICAgICBpZiAocC5kYXRhIDwgcS5kYXRhKSBwID0gcC5uZXh0O2Vsc2UgaWYgKHEuZGF0YSA+IHEuZGF0YSkgcSA9IHEubmV4dDtlbHNlIHtcbiAgICAgICAgICAgIGNMaXN0LnB1c2gocS5kYXRhKTtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICBxID0gcS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNMaXN0O1xufVxuXG4vLyDmsYLlhYPntKDpgJLlop7mjpLliJfnmoTnur/mgKfooahB5ZKMQueahOWFg+e0oOeahOS6pOmbhuW5tuWtmOWFpeWbnmFcbmZ1bmN0aW9uIGludGVyc2VjdF90cnVlKGxpc3QsIGJMaXN0KSB7XG4gICAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gICAgdmFyIHEgPSBiTGlzdC5oZWFkO1xuICAgIHZhciBwYyA9IGxpc3QuaGVhZDtcblxuICAgIHdoaWxlIChwICYmIHEpIHtcbiAgICAgICAgaWYgKHAuZGF0YSA8IHEuZGF0YSkgcCA9IHAubmV4dDtlbHNlIGlmIChwLmRhdGEgPiBxLmRhdGEpIHEgPSBxLm5leHQ7ZWxzZSB7XG4gICAgICAgICAgICBwYy5kYXRhID0gcC5kYXRhO1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgIHEgPSBxLm5leHQ7XG5cbiAgICAgICAgICAgIGlmICghcCB8fCAhcSkge1xuICAgICAgICAgICAgICAgIHBjLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxpc3QudGFpbCA9IHBjO1xuICAgICAgICAgICAgfSBlbHNlIHBjID0gcGMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBjLm5leHQgPSBudWxsO1xuICAgIGxpc3QudGFpbCA9IHBjO1xufVxuXG4vLyBh77yMYu+8jGPnmoTlhYPntKDlnYfmmK/pnZ7pgJLlh4/mjpLliJdcbi8vIOaxgmHpk77ooajkuK3pnZ5i6ZO+6KGo5ZKMY+mTvuihqOeahOS6pOmbhueahOWFg+e0oOOAglxuZnVuY3Rpb24gaW50ZXJzZWN0X2RlbGV0ZShsaXN0LCBiLCBjKSB7XG4gICAgdmFyIHAgPSBiLmhlYWQ7XG4gICAgdmFyIHEgPSBjLmhlYWQ7XG4gICAgdmFyIHIgPSBsaXN0LmhlYWQ7XG5cbiAgICB3aGlsZSAocCAmJiBxICYmIHIpIHtcbiAgICAgICAgaWYgKHAuZGF0YSA8IHEuZGF0YSkgcCA9IHAubmV4dDtlbHNlIGlmIChwLmRhdGEgPiBxLmRhdGEpIHEgPSBxLm5leHQ7ZWxzZSB7XG4gICAgICAgICAgICAvLyDnoa7lrprlvoXliKDpmaTlhYPntKBcbiAgICAgICAgICAgIHZhciBlbGVtID0gcC5kYXRhO1xuXG4gICAgICAgICAgICBpZiAoci5kYXRhID09PSBlbGVtICYmIHIgPT09IGxpc3QuaGVhZCkge1xuICAgICAgICAgICAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyDnoa7lrprmnIDlkI7kuIDkuKrlsI/kuo5lbGVt55qE5YWD57Sg5oyH6ZKIXG4gICAgICAgICAgICAgICAgd2hpbGUgKHIubmV4dCAmJiByLm5leHQuZGF0YSA8IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHIubmV4dDtcbiAgICAgICAgICAgICAgICB9aWYgKHIubmV4dC5kYXRhID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gci5uZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIOehruWumuesrOS4gOS4quWkp+S6jmVsZW3nmoTlhYPntKDmjIfpkohcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMgJiYgcy5kYXRhID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IC8vIOWIoOmZpHLlkoxz5LmL6Ze055qE5YWD57SgXG4gICAgICAgICAgICAgICAgICAgIHIubmV4dCA9IHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgfXdoaWxlIChxICYmIHEuZGF0YSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRhaWwgPSByO1xufVxuXG52YXIgbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5saXN0LnB1c2goJ2InKTtcbmxpc3QudW5zaGlmdCgnYScpO1xubGlzdC5pbnNlcnRBZnRlcignYicsICdjJyk7XG5jb25zb2xlLmxvZyhsaXN0Lml0ZW0oMikpO1xuY29uc29sZS5sb2coKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKGxpc3QpKTtcbmxpc3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLmRhdGEgPT09ICdiJykge1xuICAgICAgICBjb25zb2xlLmxvZygnZ2V0IGIgaW4gZWFjaCcpO1xuICAgIH1cbn0pO1xubGlzdC5yZW1vdmUoJ2MnKTtcbmxpc3QucmVtb3ZlKCdhJyk7XG5jb25zb2xlLmxvZyhsaXN0KTtcblxudmFyIGxpc3QyID0gbmV3IExpbmtlZExpc3QoKTtcbmxpc3QyLnB1c2goJ2MnKTtcbmxpc3QyLnVuc2hpZnQoJ2QnKTtcbmxpc3QyLmluc2VydEFmdGVyKCdkJywgJ2InKTtcbmNvbnNvbGUubG9nKCgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KShsaXN0MikpO1xuXG52YXIgbGlzdDMgPSBMaW5rZWRMaXN0Lm1lcmdlTGlzdChsaXN0LCBsaXN0Mik7XG5jb25zb2xlLmxvZyhsaXN0Myk7XG5cbnZhciBsaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblxubGlzdC5vcmRlckluc2VydCg1KTtcbmxpc3Qub3JkZXJJbnNlcnQoMik7XG5saXN0Lm9yZGVySW5zZXJ0KDMpO1xubGlzdC5vcmRlckluc2VydCgxKTtcbmxpc3Qub3JkZXJJbnNlcnQoNCk7XG5saXN0Lm9yZGVySW5zZXJ0KDQpO1xubGlzdC5vcmRlckluc2VydCg2KTtcbmxpc3Qub3JkZXJJbnNlcnQoNik7XG5saXN0Lm9yZGVySW5zZXJ0KDcpO1xuXG5saXN0LmRlbGV0ZV9iZXR3ZWVuKDUsIDgpO1xuY29uc29sZS5sb2coJ2RlbGV0ZS1iZXR3ZWVuOiAgJyk7XG5jb25zb2xlLmxvZyhsaXN0KTtcblxubGlzdC5vcmRlckluc2VydCgyKTtcbmxpc3Qub3JkZXJJbnNlcnQoMyk7XG5saXN0Lm9yZGVySW5zZXJ0KDEpO1xuXG5saXN0LmRlbGV0ZV9lcXVhbCgpO1xuY29uc29sZS5sb2cobGlzdCk7XG5cbmxpc3QucmV2ZXJzZSgpO1xuY29uc29sZS5sb2cobGlzdCk7XG5cbnZhciBhID0gbmV3IExpbmtlZExpc3QoKTtcbmEub3JkZXJJbnNlcnQoMSk7XG5hLm9yZGVySW5zZXJ0KDMpO1xuYS5vcmRlckluc2VydCg1KTtcbmEub3JkZXJJbnNlcnQoNyk7XG5hLm9yZGVySW5zZXJ0KDkpO1xuXG52YXIgYiA9IG5ldyBMaW5rZWRMaXN0KCk7XG5iLm9yZGVySW5zZXJ0KDEpO1xuYi5vcmRlckluc2VydCg1KTtcbmIub3JkZXJJbnNlcnQoOSk7XG5iLm9yZGVySW5zZXJ0KDEzKTtcbmIub3JkZXJJbnNlcnQoMTcpO1xuY29uc29sZS5sb2coaW50ZXJzZWN0KGEsIGIpKTtcblxuY29uc29sZS5sb2coaW50ZXJzZWN0X3RydWUoYSwgYikpO1xuXG5hID0gbmV3IExpbmtlZExpc3QoKTtcbmEub3JkZXJJbnNlcnQoMSk7XG5hLm9yZGVySW5zZXJ0KDMpO1xuYS5vcmRlckluc2VydCg1KTtcbmEub3JkZXJJbnNlcnQoNyk7XG5hLm9yZGVySW5zZXJ0KDkpO1xuXG52YXIgdGVzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG50ZXN0Lm9yZGVySW5zZXJ0KDEpO1xudGVzdC5vcmRlckluc2VydCgyKTtcbnRlc3Qub3JkZXJJbnNlcnQoMyk7XG50ZXN0Lm9yZGVySW5zZXJ0KDQpO1xudGVzdC5vcmRlckluc2VydCg1KTtcbnRlc3Qub3JkZXJJbnNlcnQoNik7XG50ZXN0Lm9yZGVySW5zZXJ0KDkpO1xuXG5pbnRlcnNlY3RfZGVsZXRlKHRlc3QsIGEsIGIpO1xuY29uc29sZS5sb2codGVzdCk7XG5cbnZhciBwb3BUZXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbnBvcFRlc3QucHVzaCgxKTtcbnBvcFRlc3QucHVzaCgyKTtcbnBvcFRlc3QucG9wKCk7XG5wb3BUZXN0LnBvcCgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvTGlzdC9MaW5rZWRMaXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8g6Z2Z5oCB5Y2V6ZO+6KGoXG4vKlxyXG4g5pyJ5pe25Y+v5YCf55So5LiA57u05pWw57uE5p2l5o+P6L+w57q/5oCn6ZO+6KGo77yM6L+Z5bCx5piv57q/5oCn6KGo55qE6Z2Z5oCB5Y2V6ZO+6KGo5a2Y5YKo57uT5p6E44CCXHJcbiDlnKjpnZnmgIHpk77ooajkuK3vvIzmlbDnu4TnmoTkuIDkuKrliIbph4/ooajnpLrkuIDkuKrnu5PngrnvvIzlkIzml7bnlKjmuLjmoIfvvIhjdXLvvInku6Pmm7/mjIfpkojmjIfnpLrnu5PngrnlnKjmlbDnu4TkuK3nmoTnm7jlr7nkvY3nva7jgIJcclxuIOaVsOe7hOeahOesrDDliIbph4/lj6/nnIvmiJDlpLTnu5PngrnvvIzlhbbmjIfpkojln5/mjIfnpLrpk77ooajnmoTnrKzkuIDkuKrnu5PngrnjgIJcclxuIOi/meenjeWtmOWCqOe7k+aehOmcgOimgemihOWFiOWIhumFjeS4gOS4qui+g+Wkp+eahOepuumXtO+8jOS9huWcqOe6v+aAp+ihqOeahOaPkuWFpeWSjOWIoOmZpOaTjeS9nOaXtuS4jemcgOenu+WKqOWFg+e0oO+8jFxyXG4g5LuF6ZyA6KaB5L+u5pS55oyH6ZKI77yM5pWF5LuN5YW35pyJ6ZO+5byP5a2Y5YKo57uT5p6E55qE5Li76KaB5LyY54K5XHJcbiAqL1xuXG52YXIgU3RhdGljTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNMaW5rZWRMaXN0KE1BWFNJWkUpIHtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3RhdGljTGlua2VkTGlzdCk7XG5cbiAgICAgICAgdGhpc1stMV0gPSB7IGN1cjogMCB9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuTUFYU0laRSA9IE1BWFNJWkUgKyAxIHx8IDEwMDA7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiDlnKjpnZnmgIHljZXpk77nur/mgKfooahM5Lit5p+l5om+56ysMeS4quWAvOS4umXnmoTlhYPntKDvvIxcclxuICAgICAqIOiLpeaJvuWIsO+8jOWImei/lOWbnuWug+WcqEzkuK3nmoTkvY3luo9cclxuICAgICAqIEBwYXJhbSBkYXRhXHJcbiAgICAgKi9cblxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoU3RhdGljTGlua2VkTGlzdCwgW3tcbiAgICAgICAga2V5OiAnZmluZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpc1swXS5jdXI7XG4gICAgICAgICAgICB3aGlsZSAoaSAmJiB0aGlzW2ldLmRhdGEgIT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpID0gdGhpc1tpXS5jdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICAvKipcclxuICAgICAgICAgKiDlsIbkuIDnu7TmlbDnu4TkuK3lkITliIbph4/pk77miJDkuIDkuKrlpIfnlKjpk77ooahcclxuICAgICAgICAgKiB0aGlzWzBdLmN1cuS4uuWktOaMh+mSiFxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbml0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQobGVuKSB7XG4gICAgICAgICAgICBsZW4gPSBsZW4gPyBsZW4gKyAxIDogdGhpcy5NQVhTSVpFO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gdGhpc1tpXSB8fCB7IGRhdGE6IG51bGwsIGN1cjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIHRoaXNbaV0uY3VyID0gaSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNbbGVuIC0gMV0gPSB0aGlzW2xlbiAtIDFdIHx8IHt9O1xuICAgICAgICAgICAgdGhpc1tsZW4gLSAxXS5jdXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiLpeWkh+eUqOmTvuihqOmdnuepuu+8jOWImei/lOWbnuWIhumFjeeahOe7k+eCueS4i+agh++8jOWPjeWImei/lOWbnjBcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFsbG9jJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hbGxvYygpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpc1stMV0uY3VyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzWy0xXS5jdXIgIT09ICd1bmRlZmluZWQnKSB0aGlzWy0xXS5jdXIgPSB0aGlzW2ldLmN1cjtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWwhuS4i+agh+S4umvnmoTnqbrpl7Lnu5Pngrnlm57mlLbliLDlpIfnlKjpk77ooahcclxuICAgICAgICAgKiBAcGFyYW0ga1xyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyZWUoaykge1xuICAgICAgICAgICAgdGhpc1trXS5jdXIgPSB0aGlzWzBdLmN1cjtcbiAgICAgICAgICAgIHRoaXNbMF0uY3VyID0gaztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JlYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShzcUxpc3QpIHtcbiAgICAgICAgICAgIC8vIOWIneWni+WMluWkh+eUqOepuumXtFxuICAgICAgICAgICAgdGhpcy5pbml0KHNxTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgLy8g55Sf5oiQc+eahOWktOe7k+eCuVxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLm1hbGxvYygpO1xuICAgICAgICAgICAgLy8gcuaMh+WQkXPnmoTlvZPliY3mnIDlkI7nu5PngrlcbiAgICAgICAgICAgIHZhciByID0gcztcbiAgICAgICAgICAgIHZhciBtID0gc3FMaXN0Lmxlbmd0aDtcblxuICAgICAgICAgICAgLy8g5bu656uL6ZuG5ZCIQeeahOmTvuihqFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgICAgICAvL+WIhumFjee7k+eCuVxuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5tYWxsb2MoKTtcbiAgICAgICAgICAgICAgICAvLyDovpPlhaVB5YWD57Sg55qE5YC8XG4gICAgICAgICAgICAgICAgdGhpc1tpXS5kYXRhID0gc3FMaXN0W2pdO1xuICAgICAgICAgICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxuICAgICAgICAgICAgICAgIHRoaXNbcl0uY3VyID0gaTtcbiAgICAgICAgICAgICAgICArK3RoaXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHIgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5bC+57uT54K555qE5oyH6ZKI5Li656m6XG4gICAgICAgICAgICB0aGlzW3JdLmN1ciA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaW5kZXgsIGVsZW0pIHt9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGluZGV4KSB7fVxuICAgIH1dKTtcbiAgICByZXR1cm4gU3RhdGljTGlua2VkTGlzdDtcbn0oKTtcblxuLyoqXHJcbiAqIOWcqOS4gOe7tOaVsOe7hOS4reW7uueri+ihqOekuumbhuWQiChBLUIpVShCLUEpXHJcbiAqIOeahOmdmeaAgemTvuihqO+8jHPkuLrlhbblpLTmjIfpkojjgIJcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRpY0xpbmtlZExpc3Q7XG5mdW5jdGlvbiBkaWZmZXJlbmNlKHNsbGlzdCwgYXJyMSwgYXJyMikge1xuICAgIC8vIOWIneWni+WMluWkh+eUqOepuumXtFxuICAgIHNsbGlzdC5pbml0KCk7XG4gICAgLy8g55Sf5oiQc+eahOWktOe7k+eCuVxuICAgIHZhciBzID0gc2xsaXN0Lm1hbGxvYygpO1xuICAgIC8vIHLmjIflkJFz55qE5b2T5YmN5pyA5ZCO57uT54K5XG4gICAgdmFyIHIgPSBzO1xuICAgIC8vIOWIoOmZpEHlkoxC55qE5YWD57Sg5Liq5pWwXG4gICAgdmFyIG0gPSBhcnIxLmxlbmd0aDtcbiAgICB2YXIgbiA9IGFycjIubGVuZ3RoO1xuXG4gICAgLy8g5bu656uL6ZuG5ZCIQeeahOmTvuihqFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIC8v5YiG6YWN57uT54K5XG4gICAgICAgIHZhciBpID0gc2xsaXN0Lm1hbGxvYygpO1xuICAgICAgICAvLyDovpPlhaVB5YWD57Sg55qE5YC8XG4gICAgICAgIHNsbGlzdFtpXS5kYXRhID0gYXJyMVtqXTtcbiAgICAgICAgLy8g5o+S5YWl5Yiw6KGo5bC+XG4gICAgICAgIHNsbGlzdFtyXS5jdXIgPSBpO1xuICAgICAgICByID0gaTtcbiAgICB9XG4gICAgLy8g5bC+57uT54K555qE5oyH6ZKI5Li656m6XG4gICAgc2xsaXN0W3JdLmN1ciA9IDA7XG5cbiAgICAvLyDkvp3mrKHovpPlhaVC55qE5YWD57Sg77yM6Iul5LiN5Zyo5b2T5YmN6KGo5Lit77yM5YiZ5o+S5YWl77yMXG4gICAgLy8g5ZCm5YiZ5Yig6ZmkXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47ICsrX2opIHtcbiAgICAgICAgdmFyIGIgPSBhcnIyW19qXTtcbiAgICAgICAgdmFyIHAgPSBzO1xuICAgICAgICAvLyBr5oyH5ZCR6ZuG5ZCI5Lit55qE56ys5LiA5Liq57uT54K5XG4gICAgICAgIHZhciBrID0gc2xsaXN0W3NdLmN1cjtcbiAgICAgICAgLy8g5Zyo5b2T5YmN6KGo5Lit5p+l5om+XG4gICAgICAgIHdoaWxlIChrICE9PSBzbGxpc3Rbcl0uY3VyICYmIHNsbGlzdFtrXS5kYXRhICE9PSBiKSB7XG4gICAgICAgICAgICBwID0gaztcbiAgICAgICAgICAgIGsgPSBzbGxpc3Rba10uY3VyO1xuICAgICAgICB9XG4gICAgICAgIC8vIOW9k+WJjeihqOS4reS4jeWtmOWcqOivpeWFg+e0oO+8jOaPkuWFpeWcqHLmiYDmjIfnu5PngrnkuYvlkI7vvIzkuJRy55qE5L2N572u5LiN5Y+YXG4gICAgICAgIGlmIChrID09PSBzbGxpc3Rbcl0uY3VyKSB7XG4gICAgICAgICAgICB2YXIgX2kgPSBzbGxpc3QubWFsbG9jKCk7XG4gICAgICAgICAgICBzbGxpc3RbX2ldLmRhdGEgPSBiO1xuICAgICAgICAgICAgc2xsaXN0W19pXS5jdXIgPSBzbGxpc3Rbcl0uY3VyO1xuICAgICAgICAgICAgc2xsaXN0W3JdLmN1ciA9IF9pO1xuXG4gICAgICAgICAgICAvLyDor6XlhYPntKDlt7LlnKjooajkuK3vvIzliKDpmaTkuYtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbGxpc3RbcF0uY3VyID0gc2xsaXN0W2tdLmN1cjtcbiAgICAgICAgICAgICAgICBzbGxpc3QuZnJlZShrKTtcbiAgICAgICAgICAgICAgICAvLyDoi6XliKDpmaTnmoTmmK9y5omA5oyH57uT54K577yM5YiZ6ZyA5L+u5pS55bC+5oyH6ZKIXG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IGspIHIgPSBwO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNsID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoMTApO1xudmFyIHJldCA9IGRpZmZlcmVuY2Uoc2wsIFsxLCAyLCAzXSwgWzMsIDQsIDVdKTtcbmNvbnNvbGUubG9nKHNsKTtcblxudmFyIHRlc3QgPSBuZXcgU3RhdGljTGlua2VkTGlzdCgxMCk7XG50ZXN0LmNyZWF0ZShbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5XSk7XG5jb25zb2xlLmxvZyh0ZXN0KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0xpc3QvU3RhdGljTGlua2VkTGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmluYXJ5VHJlZTIgPSByZXF1aXJlKCcuLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEJTVE5vZGUgPSBmdW5jdGlvbiAoX0JpbmFyeVRyZWUpIHtcbiAgICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShCU1ROb2RlLCBfQmluYXJ5VHJlZSk7XG5cbiAgICBmdW5jdGlvbiBCU1ROb2RlKCkge1xuICAgICAgICB2YXIgX09iamVjdCRnZXRQcm90b3R5cGVPO1xuXG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEJTVE5vZGUpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmcgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChfT2JqZWN0JGdldFByb3RvdHlwZU8gPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShCU1ROb2RlKSkuY2FsbC5hcHBseShfT2JqZWN0JGdldFByb3RvdHlwZU8sIFt0aGlzXS5jb25jYXQoYXJnKSkpO1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogQlNU5qCR55qE5p+l5om+77yI6YCS5b2S77yJXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cblxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoQlNUTm9kZSwgW3tcbiAgICAgICAga2V5OiAnc2VhcmNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlYXJjaChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAoa2V5IDwgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgcmV0dXJuIHRoaXMubGVmdENoaWxkLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHJldHVybiB0aGlzLnJpZ2h0Q2hpbGQuc2VhcmNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJTVOagkeeahOafpeaJvu+8iOmdnumAkuW9ku+8iVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlYXJjaE5vblJlY3Vyc2l2ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2hOb25SZWN1cnNpdmUoa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgIT09IGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcCB8fCBrZXkgIT09IHAuZGF0YSkgcmV0dXJuIG51bGw7ZWxzZSByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmAkuW9ku+8iVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2luc2VydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnQoa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5kYXRhKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IEJTVE5vZGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2hpbGQuaW5zZXJ0KGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQgPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDaGlsZC5pbnNlcnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmdnumAkuW9ku+8iVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2luc2VydE5vblJlY3Vyc2l2ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb25SZWN1cnNpdmUoa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAuZGF0YSA9PT0ga2V5KSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gceS9nOS4unDnmoTniLboioLngrlcbiAgICAgICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7ZWxzZSBwID0gcC5yaWdodENoaWxkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBCU1ROb2RlKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5IDwgcS5kYXRhKSBxLmxlZnRDaGlsZCA9IG5vZGU7ZWxzZSBxLnJpZ2h0Q2hpbGQgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yip55SoQlNU5qCR55qE5o+S5YWl5pON5L2c5bu656uL5LiA5qO1QlNU5qCRXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufHVuZGVmaW5lZH0gdXNlTm9uUmVjdXJzaXZlIOaYr+WQpuS9v+eUqOmdnumAkuW9klxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjcmVhdGVCU1QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQlNUKGFyciwgdXNlTm9uUmVjdXJzaXZlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VOb25SZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9uUmVjdXJzaXZlKGFycltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGFycltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOS9v+eUqOmAkuW9kueahOaWueazleWIoOmZpOS4juWFs+mUruWtl+espuWQiOeahOe7k+eCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5IOmcgOimgeafpeaJvueahOWFs+mUruWtl1xyXG4gICAgICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gcGFyZW50IOeItuiKgueCue+8jOWGhemDqOiwg+eUqOmcgOimgeeUqOWIsFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSwgcGFyZW50KSB7XG4gICAgICAgICAgICAvLyDnqbrnu5PngrnnmoTmg4XlhrVcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAvLyDmib7liLDlhbPplK7lrZdcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIGRlbGV0ZU5vZGUodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIC8vIOafpeaJvuW3puWtkOagke+8jOWmguaenOacieeahOivnVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IDwgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgcmV0dXJuIHRoaXMubGVmdENoaWxkLnJlbW92ZShrZXksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDmn6Xmib7lj7PlrZDmoJHvvIzlpoLmnpzmnInnmoTor51cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHJldHVybiB0aGlzLnJpZ2h0Q2hpbGQucmVtb3ZlKGtleSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5pyq5om+5YiwXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiDpnZ7pgJLlvZLliKDpmaTkuI7lhbPplK7lrZfnrKblkIjnmoTnu5PngrlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSDpnIDopoHmn6Xmib7nmoTlhbPplK7lrZdcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlTm9uUmVjdXJzaXZlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU5vblJlY3Vyc2l2ZShrZXkpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcztcbiAgICAgICAgICAgIHZhciBmID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgIT09IGtleSkge1xuICAgICAgICAgICAgICAgIGYgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOayoeacieimgeWIoOmZpOeahOe7k+eCuVxuICAgICAgICAgICAgaWYgKCFwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIOaJvuWIsOS6huimgeWIoOmZpOeahOe7k+eCuXBcbiAgICAgICAgICAgIHZhciBzID0gcDtcbiAgICAgICAgICAgIHZhciBxID0gdm9pZCAwO1xuICAgICAgICAgICAgLy8g5aaC5p6c5pyJ5bem5Y+z5a2Q5qCRXG4gICAgICAgICAgICBpZiAocC5sZWZ0Q2hpbGQgJiYgcC5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZiA9IHA7XG4gICAgICAgICAgICAgICAgcyA9IHAubGVmdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgLy8g5om+5Yiw5bem5a2Q5qCR55qE5pyA5aSn5Y+z5a2Q5qCR77yM5Y2z5LuF5bCP5LqO5bem5a2Q5qCR55qE5YC855qE57uT54K5XG4gICAgICAgICAgICAgICAgd2hpbGUgKHMucmlnaHRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gcztcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMucmlnaHRDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOiLpXPmnInlt6blrZDmoJHvvIzlj7PlrZDmoJHkuLrnqbpcbiAgICAgICAgICAgIGlmIChzLmxlZnRDaGlsZCkgcSA9IHMubGVmdENoaWxkO2Vsc2UgcSA9IHMucmlnaHRDaGlsZDtcblxuICAgICAgICAgICAgLy8g5Y+q5pyJ5LiA5Liq5qC557uT54K555qE5oOF5Ya1XG4gICAgICAgICAgICBpZiAoIWYpIHRoaXMuZGF0YSA9IG51bGw7ZWxzZSBpZiAoZi5sZWZ0Q2hpbGQgPT0gcykgZi5sZWZ0Q2hpbGQgPSBxO2Vsc2UgZi5yaWdodENoaWxkID0gcTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmib7liLDlsI/kuo5455qE5pyA5aSn5YWD57Sg5ZKM5aSn5LqOeOeahOacgOWwj+WFg+e0oFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0geFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gW21pbiwgbWF4XVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaW5kTmVpZ2hib3JFbGVtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROZWlnaGJvckVsZW0oeCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB0eXBlb2YgdGhpcy5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICAgICAgdm9pZCBmdW5jdGlvbiByZWN1cnNlKHRyZWUsIHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5sZWZ0Q2hpbGQpIHJlY3Vyc2UodHJlZS5sZWZ0Q2hpbGQsIHgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0IDwgeCAmJiB0cmVlLmRhdGEgPj0geCkgcmV0WzBdID0gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA8PSB4ICYmIHRyZWUuZGF0YSA+IHgpIHJldFsxXSA9IHRyZWUuZGF0YTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdHJlZS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCB4KTtcbiAgICAgICAgICAgIH0odGhpcywgeCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmiorkuozlj4nmjpLluo/moJFic3TlkIjlubbliLDor6XmoJHkuK1cclxuICAgICAgICAgKiBAcGFyYW0ge0JTVE5vZGV9IGJzdFxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtZXJnZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShic3QpIHtcbiAgICAgICAgICAgIGlmIChic3QubGVmdENoaWxkKSB0aGlzLm1lcmdlKGJzdC5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKGJzdC5yaWdodENoaWxkKSB0aGlzLm1lcmdlKGJzdC5yaWdodENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGJzdC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaKiue7k+eCueaPkuWFpeWIsOWQiOmAguS9jee9rlxyXG4gICAgICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gbm9kZSDlvoXmj5LlhaXnmoTnu5PngrlcclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5zZXJ0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA+IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkID0gbm9kZTtlbHNlIHRoaXMucmlnaHRDaGlsZC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5kYXRhIDwgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkID0gbm9kZTtlbHNlIHRoaXMubGVmdENoaWxkLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLmxlZnRDaGlsZCA9IG5vZGUucmlnaHRDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliIboo4LkuLrkuKTmo7Xkuozlj4nmjpLluo/moJFcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHhcclxuICAgICAgICAgKiBAcmV0dXJucyB7QlNUTm9kZVthLCBiXX0gYeeahOWFg+e0oOWFqOmDqOWwj+S6juetieS6jnjvvIxi55qE5YWD57Sg5YWo6YOo5aSn5LqOeFxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzcGxpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdCh4KSB7XG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBCU1ROb2RlKCk7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCU1ROb2RlKCk7XG5cbiAgICAgICAgICAgIHZvaWQgZnVuY3Rpb24gc3BsaXQodHJlZSwgeCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgc3BsaXQodHJlZS5sZWZ0Q2hpbGQsIHgpO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHNwbGl0KHRyZWUucmlnaHRDaGlsZCwgeCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuZGF0YSA8PSB4KSBhLmluc2VydE5vZGUodHJlZSk7ZWxzZSBiLmluc2VydE5vZGUodHJlZSk7XG4gICAgICAgICAgICB9KHRoaXMsIHgpO1xuXG4gICAgICAgICAgICByZXR1cm4gW2EsIGJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5patdHJlZeaYr+WQpuaYr+S6jOWPieaOkuW6j+agkVxyXG4gICAgICAgICAqIEBwYXJhbSB0cmVlXHJcbiAgICAgICAgICovXG5cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnaXNCU1RUcmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQlNUVHJlZSh0cmVlKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHR5cGVvZiB0cmVlLmRhdGEgPT09ICdudW1iZXInID8gLUluZmluaXR5IDogJ2EnO1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuXG4gICAgICAgICAgICB2b2lkIGZ1bmN0aW9uIGlzQlNUVHJlZSh0cmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkICYmIGZsYWcpIGlzQlNUVHJlZSh0cmVlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuZGF0YSA8IGxhc3QpIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdHJlZS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQgJiYgZmxhZykgaXNCU1RUcmVlKHRyZWUucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICB9KHRyZWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmxhZztcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQlNUTm9kZTtcbn0oX0JpbmFyeVRyZWUyLkJpbmFyeVRyZWUpO1xuXG4vKipcclxuICog5Yig6Zmk57uT54K5XHJcbiAqIEBwYXJhbSB7QlNUTm9kZX0gcCDopoHliKDpmaTnmoTnu5PngrlcclxuICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg6KaB5Yig6Zmk55qE57uT54K555qE54i26IqC54K5XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSDov5Tlm57liKDpmaTmiJDlip9cclxuICovXG4vKlxyXG4g5Yqo5oCB5p+l5om+XHJcblxyXG4g5b2T5p+l5om+6KGo5Lul57q/5oCn6KGo55qE5b2i5byP57uE57uH5pe277yM6Iul5a+55p+l5om+6KGo6L+b6KGM5o+S5YWl44CB5Yig6Zmk5oiW5o6S5bqP5pON5L2c77yM5bCx5b+F6aG756e75Yqo5aSn6YeP55qE6K6w5b2V77yM5b2T6K6w5b2V5pWw5b6I5aSa5pe277yM6L+Z56eN56e75Yqo55qE5Luj5Lu35b6I5aSn44CCXHJcbiDliKnnlKjmoJHnmoTlvaLlvI/nu4Tnu4fmn6Xmib7ooajvvIzlj6/ku6Xlr7nmn6Xmib7ooajov5vooYzliqjmgIHpq5jmlYjnmoTmn6Xmib7jgIJcclxuXHJcblxyXG4g5LqM5Y+J5o6S5bqP5qCRKEJTVCnnmoTlrprkuYlcclxuXHJcbiDkuozlj4nmjpLluo/moJEoQmluYXJ5IFNvcnQgVHJlZeaIlkJpbmFyeSBTZWFyY2ggVHJlZSkg55qE5a6a5LmJ5Li677ya5LqM5Y+J5o6S5bqP5qCR5oiW6ICF5piv56m65qCR77yM5oiW6ICF5piv5ruh6Laz5LiL5YiX5oCn6LSo55qE5LqM5Y+J5qCR44CCXHJcbiAoMSkg77ya6Iul5bem5a2Q5qCR5LiN5Li656m677yM5YiZ5bem5a2Q5qCR5LiK5omA5pyJ57uT54K555qE5YC8KOWFs+mUruWtlynpg73lsI/kuo7moLnnu5PngrnnmoTlgLzvvJtcclxuICgyKSDvvJroi6Xlj7PlrZDmoJHkuI3kuLrnqbrvvIzliJnlj7PlrZDmoJHkuIrmiYDmnInnu5PngrnnmoTlgLwo5YWz6ZSu5a2XKemDveWkp+S6juaguee7k+eCueeahOWAvO+8m1xyXG4gKDMpIO+8muW3puOAgeWPs+WtkOagkemDveWIhuWIq+aYr+S6jOWPieaOkuW6j+agkeOAglxyXG4g57uT6K6677ya6Iul5oyJ5Lit5bqP6YGN5Y6G5LiA5qO15LqM5Y+J5o6S5bqP5qCR77yM5omA5b6X5Yiw55qE57uT54K55bqP5YiX5piv5LiA5Liq6YCS5aKe5bqP5YiX44CCXHJcblxyXG5cclxuIEJTVOagkeeahOafpeaJvlxyXG4gMSAg5p+l5om+5oCd5oOzXHJcbiDpppblhYjlsIbnu5nlrprnmoRL5YC85LiO5LqM5Y+J5o6S5bqP5qCR55qE5qC557uT54K555qE5YWz6ZSu5a2X6L+b6KGM5q+U6L6D77ya6Iul55u4562J77yaIOWImeafpeaJvuaIkOWKn++8m1xyXG4g4pGgIOe7meWumueahEvlgLzlsI/kuo5CU1TnmoTmoLnnu5PngrnnmoTlhbPplK7lrZfvvJrnu6fnu63lnKjor6Xnu5PngrnnmoTlt6blrZDmoJHkuIrov5vooYzmn6Xmib7vvJtcclxuIOKRoSDnu5nlrprnmoRL5YC85aSn5LqOQlNU55qE5qC557uT54K555qE5YWz6ZSu5a2X77ya57un57ut5Zyo6K+l57uT54K555qE5Y+z5a2Q5qCR5LiK6L+b6KGM5p+l5om+44CCXHJcblxyXG4g5Zyo6ZqP5py65oOF5Ya15LiL77yM5LqM5Y+J5o6S5bqP5qCR55qE5bmz5Z2H5p+l5om+6ZW/5bqmQVNM5ZKM44+SKG4pKOagkeeahOa3seW6pinmmK/nrYnmlbDph4/nuqfnmoTjgIJcclxuXHJcblxyXG4gQlNU5qCR55qE5o+S5YWlXHJcblxyXG4g5ZyoQlNU5qCR5Lit5o+S5YWl5LiA5Liq5paw57uT54K577yM6KaB5L+d6K+B5o+S5YWl5ZCO5LuN5ruh6LazQlNU55qE5oCn6LSo44CCXHJcblxyXG4gMSDmj5LlhaXmgJ3mg7NcclxuIOWcqEJTVOagkeS4reaPkuWFpeS4gOS4quaWsOe7k+eCuXjml7bvvIzoi6VCU1TmoJHkuLrnqbrvvIzliJnku6TmlrDnu5Pngrl45Li65o+S5YWl5ZCOQlNU5qCR55qE5qC557uT54K577yb5ZCm5YiZ77yM5bCG57uT54K5eOeahOWFs+mUruWtl+S4juaguee7k+eCuVTnmoTlhbPplK7lrZfov5vooYzmr5TovoPvvJpcclxuIOKRoCDoi6Xnm7jnrYnvvJog5LiN6ZyA6KaB5o+S5YWl77ybXHJcbiDikaEgIOiLpXgua2V5PFQtPmtlee+8mue7k+eCuXjmj5LlhaXliLBU55qE5bem5a2Q5qCR5Lit77ybXHJcbiDikaIgIOiLpXgua2V5PlQtPmtlee+8mue7k+eCuXjmj5LlhaXliLBU55qE5Y+z5a2Q5qCR5Lit44CCXHJcblxyXG4g55Sx57uT6K6655+l77yM5a+55LqO5LiA5Liq5peg5bqP5bqP5YiX5Y+v5Lul6YCa6L+H5p6E6YCg5LiA5qO1QlNU5qCR6ICM5Y+Y5oiQ5LiA5Liq5pyJ5bqP5bqP5YiX44CCXHJcbiDnlLHnrpfms5Xnn6XvvIzmr4/mrKHmj5LlhaXnmoTmlrDnu5Pngrnpg73mmK9CU1TmoJHnmoTlj7blrZDnu5PngrnvvIzljbPlnKjmj5LlhaXml7bkuI3lv4Xnp7vliqjlhbblroPnu5PngrnvvIzku4XpnIDkv67mlLnmn5DkuKrnu5PngrnnmoTmjIfpkojjgIJcclxuXHJcblxyXG4gQlNU5qCR55qE5Yig6ZmkXHJcblxyXG4gMSAg5Yig6Zmk5pON5L2c6L+H56iL5YiG5p6QXHJcbiDku45CU1TmoJHkuIrliKDpmaTkuIDkuKrnu5PngrnvvIzku43nhLbopoHkv53or4HliKDpmaTlkI7mu6HotrNCU1TnmoTmgKfotKjjgILorr7ooqvliKDpmaTnu5PngrnkuLpw77yM5YW254i257uT54K55Li6ZiDvvIzliKDpmaTmg4XlhrXlpoLkuIvvvJpcclxuIOKRoCAg6IulcOaYr+WPtuWtkOe7k+eCue+8miDnm7TmjqXliKDpmaRw44CCXHJcbiDikaEgIOiLpXDlj6rmnInkuIDmo7XlrZDmoJEo5bem5a2Q5qCR5oiW5Y+z5a2Q5qCRKe+8muebtOaOpeeUqHDnmoTlt6blrZDmoJEo5oiW5Y+z5a2Q5qCRKeWPluS7o3DnmoTkvY3nva7ogIzmiJDkuLpm55qE5LiA5qO15a2Q5qCR44CC5Y2z5Y6f5p2lcOaYr2bnmoTlt6blrZDmoJHvvIzliJlw55qE5a2Q5qCR5oiQ5Li6ZueahOW3puWtkOagke+8m+WOn+adpXDmmK9m55qE5Y+z5a2Q5qCR77yM5YiZcOeahOWtkOagkeaIkOS4umbnmoTlj7PlrZDmoJHjgIJcclxuIOKRoiDoi6Vw5pei5pyJ5bem5a2Q5qCR5Y+I5pyJ5Y+z5a2Q5qCRIO+8muWkhOeQhuaWueazleacieS7peS4i+S4pOenje+8jOWPr+S7peS7u+mAieWFtuS4reS4gOenjeOAglxyXG4g4peGICDnlKhw55qE55u05o6l5YmN6amx57uT54K55Luj5pu/cOOAguWNs+S7jnDnmoTlt6blrZDmoJHkuK3pgInmi6nlgLzmnIDlpKfnmoTnu5Pngrlz5pS+5ZyocOeahOS9jee9rijnlKjnu5Pngrlz55qE5YaF5a655pu/5o2i57uT54K5cOWGheWuuSnvvIznhLblkI7liKDpmaTnu5Pngrlz44CCc+aYr3DnmoTlt6blrZDmoJHkuK3nmoTmnIDlj7PovrnnmoTnu5PngrnkuJTmsqHmnInlj7PlrZDmoJHvvIzlr7lz55qE5Yig6Zmk5ZCM4pGh44CCXHJcbiDil4Yg55SocOeahOebtOaOpeWQjue7p+e7k+eCueS7o+abv3DjgILljbPku45w55qE5Y+z5a2Q5qCR5Lit6YCJ5oup5YC85pyA5bCP55qE57uT54K5c+aUvuWcqHDnmoTkvY3nva4o55So57uT54K5c+eahOWGheWuueabv+aNoue7k+eCuXDlhoXlrrkp77yM54S25ZCO5Yig6Zmk57uT54K5c+OAgnPmmK9w55qE5Y+z5a2Q5qCR5Lit55qE5pyA5bem6L6555qE57uT54K55LiU5rKh5pyJ5bem5a2Q5qCR77yM5a+5c+eahOWIoOmZpOWQjOKRoeOAglxyXG5cclxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJTVE5vZGU7XG5mdW5jdGlvbiBkZWxldGVOb2RlKHAsIHBhcmVudCkge1xuICAgIC8vIOWPtuWtkOe7k+eCueaIluWPquacieS4gOS4que7k+eCuVxuICAgIGlmICghcC5sZWZ0Q2hpbGQgJiYgIXAucmlnaHRDaGlsZCkge1xuICAgICAgICAvLyDlvZPliY3nu5PngrnmmK/lhbbniLbnu5PngrnnmoTlt6blrZDmoJHov5jmmK/lj7PlrZDmoJFcbiAgICAgICAgdmFyIHBvcyA9IHBhcmVudCAmJiBwYXJlbnQubGVmdENoaWxkID09IHAgPyAnbGVmdENoaWxkJyA6ICdyaWdodENoaWxkJztcbiAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50W3Bvc10gPSBudWxsO1xuICAgICAgICAvLyDlj6rmnInkuIDkuKrnu5PngrnnmoTmg4XlhrVcbiAgICAgICAgZWxzZSBwLmRhdGEgPSBudWxsO1xuICAgIH1cbiAgICAvLyDlj6rmnInlt6blrZDmoJFcbiAgICBlbHNlIGlmICghcC5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICBwLmRhdGEgPSBwLmxlZnRDaGlsZC5kYXRhO1xuICAgICAgICAgICAgcC5sZWZ0Q2hpbGQgPSBwLmxlZnRDaGlsZC5sZWZ0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5Y+q5pyJ5Y+z5a2Q5qCRXG4gICAgICAgIGVsc2UgaWYgKCFwLmxlZnRDaGlsZCkge1xuICAgICAgICAgICAgICAgIHAuZGF0YSA9IHAucmlnaHRDaGlsZC5kYXRhO1xuICAgICAgICAgICAgICAgIHAucmlnaHRDaGlsZCA9IHAucmlnaHRDaGlsZC5yaWdodENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5bem5Y+z5a2Q5qCR6YO95pyJXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gceS4uueItue7k+eCuVxuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIC8vIOaJvuWIsOW3puWtkOagkeeahOacgOWkp+WPs+WtkOagke+8jOWNs+S7heWwj+S6juW3puWtkOagkeeahOWAvOeahOe7k+eCuVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocy5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxICE9IHApIHEucmlnaHRDaGlsZCA9IHMubGVmdENoaWxkO2Vsc2UgcS5sZWZ0Q2hpbGQgPSBzLmxlZnRDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGJzdCA9IG5ldyBCU1ROb2RlKCk7XG5ic3QuY3JlYXRlQlNUKFs0NSwgMjQsIDUzLCAxMiwgMjQsIDkwXSk7XG5jb25zb2xlLmxvZyhic3Quc2VhcmNoKDEyKSk7XG5jb25zb2xlLmxvZyhic3Quc2VhcmNoKDEzKSk7XG5cbnZhciBic3QyID0gbmV3IEJTVE5vZGUoKTtcbmJzdDIuY3JlYXRlQlNUKFs0NSwgMjQsIDUzLCAxMiwgMjQsIDkwXSwgdHJ1ZSk7XG5jb25zb2xlLmxvZyhic3QyLnNlYXJjaE5vblJlY3Vyc2l2ZSgxMikpO1xuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTMpKTtcblxuY29uc29sZS5sb2coJ1xcbmZpbmRTaWJsaW5nRWxlbTogJyk7XG5jb25zb2xlLmxvZyhic3QuZmluZE5laWdoYm9yRWxlbSgxMikgKyAnJyk7XG5jb25zb2xlLmxvZyhic3QuZmluZE5laWdoYm9yRWxlbSg5MCkgKyAnJyk7XG5jb25zb2xlLmxvZyhic3QuZmluZE5laWdoYm9yRWxlbSg0NSkgKyAnJyk7XG5cbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoNDUpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMSkpO1xuY29uc29sZS5sb2coYnN0LnJlbW92ZSg1MykpO1xuY29uc29sZS5sb2coYnN0LnJlbW92ZSgxMikpO1xuY29uc29sZS5sb2coYnN0LnJlbW92ZSg5MCkpO1xuY29uc29sZS5sb2coYnN0LnJlbW92ZSgyNCkpO1xuY29uc29sZS5sb2coYnN0LnJlbW92ZSgyKSk7XG5cbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNDUpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMSkpO1xuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSg1MykpO1xuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgxMikpO1xuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSg5MCkpO1xuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgyNCkpO1xuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgyKSk7XG5cbmNvbnNvbGUubG9nKCdcXG5pc0JTVFRyZWU6ICcpO1xuY29uc29sZS5sb2coQlNUTm9kZS5pc0JTVFRyZWUoYnN0KSk7XG4vL2NvbnNvbGUubG9nKEJTVE5vZGUuaXNCU1RUcmVlKHNvc1RyZWUpKTtcblxuLyoqXHJcbiAqIOS7juWkp+WIsOWwj+i+k+WHuuS6jOWPieaOkuW6j+agkeS4reaJgOacieS4jeWwj+S6jnjnmoTlhYPntKBcclxuICogQHBhcmFtIGJzdFxyXG4gKiBAcGFyYW0geFxyXG4gKi9cbmZ1bmN0aW9uIHByaW50Tm90TGVzc1RoYW4oYnN0LCB4KSB7XG4gICAgaWYgKGJzdC5yaWdodENoaWxkKSBwcmludE5vdExlc3NUaGFuKGJzdC5yaWdodENoaWxkLCB4KTtcbiAgICBpZiAoYnN0LmRhdGEgPCB4KSByZXR1cm47XG4gICAgY29uc29sZS5sb2coYnN0LmRhdGEpO1xuICAgIGlmIChic3QubGVmdENoaWxkKSBwcmludE5vdExlc3NUaGFuKGJzdC5sZWZ0Q2hpbGQsIHgpO1xufVxuXG5jb25zb2xlLmxvZygnXFxucHJpbnROb3RMZXNzVGhhbjogJyk7XG5wcmludE5vdExlc3NUaGFuKGJzdDIsIDkwKTtcbmNvbnNvbGUubG9nKCdcXG4nKTtcbnByaW50Tm90TGVzc1RoYW4oYnN0MiwgMTIpO1xuXG5ic3QubWVyZ2UoYnN0Mik7XG5cbnZhciBhMSA9IG5ldyBCU1ROb2RlKDUpO1xudmFyIGEyID0gbmV3IEJTVE5vZGUoOTEpO1xuYnN0Mi5pbnNlcnROb2RlKGExKTtcbmJzdDIuaW5zZXJ0Tm9kZShhMik7XG5cbmJzdDIuc3BsaXQoNDUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU2VhcmNoL0JpbmFyeVNvcnRlZFRyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJ1YmJsZVNvcnQgPSBidWJibGVTb3J0O1xuZXhwb3J0cy5idWJibGVTb3J0MiA9IGJ1YmJsZVNvcnQyO1xuZXhwb3J0cy5jb2NrVGFpbFNvcnQgPSBjb2NrVGFpbFNvcnQ7XG5leHBvcnRzLmNvY2tUYWlsU29ydDIgPSBjb2NrVGFpbFNvcnQyO1xuZXhwb3J0cy5xdWlja1NvcnRSZWN1cnNpdmUgPSBxdWlja1NvcnRSZWN1cnNpdmU7XG5leHBvcnRzLnF1aWNrU29ydFJlY3Vyc2l2ZTIgPSBxdWlja1NvcnRSZWN1cnNpdmUyO1xuZXhwb3J0cy5xdWlja1NvcnROb25SZWN1cnNpdmUgPSBxdWlja1NvcnROb25SZWN1cnNpdmU7XG5leHBvcnRzLnF1aWNrU29ydCA9IHF1aWNrU29ydDtcbmV4cG9ydHMub2RkRXZlblNvcnQgPSBvZGRFdmVuU29ydDtcblxudmFyIF9kZWZhdWx0Q29tcGFyaXNpb24gPSByZXF1aXJlKCcuLi9kZWZhdWx0Q29tcGFyaXNpb24nKTtcblxudmFyIF9kZWZhdWx0Q29tcGFyaXNpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdENvbXBhcmlzaW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcclxuIOS6pOaNouaOkuW6j1xyXG5cclxuIOaYr+S4gOexu+WfuuS6juS6pOaNoueahOaOkuW6j++8jOezu+e7n+WcsOS6pOaNouWPjeW6j+eahOiusOW9leeahOWBtuWvue+8jOebtOWIsOS4jeWGjeaciei/meagt+eahOWBtuWvueS4uuatouOAguWFtuS4reacgOWfuuacrOeahOaYr+WGkuazoeaOkuW6jyhCdWJibGUgU29ydCnjgIJcclxuXHJcbiDlhpLms6HmjpLluo9cclxuIDEgIOaOkuW6j+aAneaDs1xyXG4g5L6d5qyh5q+U6L6D55u46YK755qE5Lik5Liq6K6w5b2V55qE5YWz6ZSu5a2X77yM6Iul5Lik5Liq6K6w5b2V5piv5Y+N5bqP55qEKOWNs+WJjeS4gOS4quiusOW9leeahOWFs+mUruWtl+Wkp+S6juWQjuWJjeS4gOS4quiusOW9leeahOWFs+mUruWtlynvvIzliJnov5vooYzkuqTmjaLvvIznm7TliLDmsqHmnInlj43luo/nmoTorrDlvZXkuLrmraLjgIJcclxuICAgICDikaAg6aaW5YWI5bCGTC0+UlsxXeS4jkwtPlJbMl3nmoTlhbPplK7lrZfov5vooYzmr5TovoPvvIzoi6XkuLrlj43luo8oTC0+UlsxXeeahOWFs+mUruWtl+Wkp+S6jkwtPlJbMl3nmoTlhbPplK7lrZcp77yM5YiZ5Lqk5o2i5Lik5Liq6K6w5b2V77yb54S25ZCO5q+U6L6DTC0+UlsyXeS4jkwtPlJbM13nmoTlhbPplK7lrZfvvIzkvp3mraTnsbvmjqjvvIznm7TliLBMLT5SW24tMV3kuI5MLT5SW25d55qE5YWz6ZSu5a2X5q+U6L6D5ZCO5Li65q2i77yM56ew5Li65LiA6Laf5YaS5rOh5o6S5bqP77yMTC0+UltuXeS4uuWFs+mUruWtl+acgOWkp+eahOiusOW9leOAglxyXG4gICAgIOKRoSAg54S25ZCO6L+b6KGM56ys5LqM6Laf5YaS5rOh5o6S5bqP77yM5a+55YmNbi0x5Liq6K6w5b2V6L+b6KGM5ZCM5qC355qE5pON5L2c44CCXHJcbiDkuIDoiKzlnLDvvIznrKxp6Laf5YaS5rOh5o6S5bqP5piv5a+5TC0+UlsxIOKApiBuLWkrMV3kuK3nmoTorrDlvZXov5vooYznmoTvvIzlm6DmraTvvIzoi6XlvoXmjpLluo/nmoTorrDlvZXmnIlu5Liq77yM5YiZ6KaB57uP6L+Hbi0x6Laf5YaS5rOh5o6S5bqP5omN6IO95L2/5omA5pyJ55qE6K6w5b2V5pyJ5bqP44CCXHJcblxyXG4gMiAg5o6S5bqP56S65L6LXHJcbiDorr7mnIk55Liq5b6F5o6S5bqP55qE6K6w5b2V77yM5YWz6ZSu5a2X5YiG5Yir5Li6MjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MVxyXG5cclxuIOWIneWni+WFs+mUruWtl+W6j+WIlzogIDIzICAgIDM4ICAgICAyMiAgICAgNDUgICAgIDIzICAgICA2NyAgICAgMzEgICAgIDE1ICAgIDQxXHJcbiDnrKzkuIDotp/mjpLluo/lkI46ICAgIDIzICAgIDIyICAgICAzOCAgICAgMjMgICAgIDQ1ICAgICAzMSAgICAgMTUgICAgIDQxICAgIDY3XHJcbiDnrKzkuozotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMzggICAgIDMxICAgICAxNSAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzkuInotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMzEgICAgIDE1ICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzlm5votp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMTUgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzkupTotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAxNSAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzlha3otp/mjpLluo/lkI46ICAgIDIyICAgIDE1ICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcbiDnrKzkuIPotp/mjpLluo/lkI46ICAgIDE1ICAgIDIyICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XHJcblxyXG4zLueul+azleWIhuaekFxyXG4g5pe26Ze05aSN5p2C5bqmXHJcbiDil4YgIOacgOWlveaDheWGtSjmraPluo8p77ya5q+U6L6D5qyh5pWw77yabi0x77yb56e75Yqo5qyh5pWw77yaMO+8m1xyXG4g4peGICDmnIDlnY/mg4XlhrUo6YCG5bqPKe+8mlxyXG4g5q+U6L6D5qyh5pWw77yaIG4gKiAobiAtIDEpIC8gMlxyXG4g56e75Yqo5qyh5pWw77yaIDMqbioobiAtIDEpIC8gMlxyXG5cclxuIOaVheaXtumXtOWkjeadguW6pu+8mlQobik9TyhuwrIpXHJcbiDnqbrpl7TlpI3mnYLluqbvvJpTKG4pPU8oMSlcclxuXHJcbiAqL1xuXG5mdW5jdGlvbiBidWJibGVTb3J0KHNxTGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gbGVuIC0gaTsgKytqKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaiArIDFdLCBzcUxpc3Rbal0pIDwgMCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3Rbal07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2pdID0gc3FMaXN0W2ogKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hhbmdlKSBicmVhaztcbiAgICB9XG59IC8qKlxyXG4gICAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMi5cclxuICAgKi9cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbmJ1YmJsZVNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKCdidWJibGVTb3J0OlxcbicgKyBhcnIgKyAnJyk7XG5cbi8vIOWGkuazoeaUuei/mzFcbmZ1bmN0aW9uIGJ1YmJsZVNvcnQyKHNxTGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2UgPSBsZW4gLSAxO1xuXG4gICAgd2hpbGUgKGNoYW5nZSkge1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICAvLyBj5oyH56S66L+Z5LiA6Laf5YaS5rOh5Lit5Y+R55Sf5Lqk5o2i55qE5YWD57SgXG4gICAgICAgICAgICAgICAgYyA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlID0gYztcbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5idWJibGVTb3J0MihhcnIpO1xuY29uc29sZS5sb2coJ2J1YmJsZVNvcnQyOlxcbicgKyBhcnIgKyAnJyk7XG5cbi8vIOebuOmCu+S4pOi2n+WPjeaWueWQkei1t+azoeeahOWGkuazoeaOkuW6j+eul+azlVxuZnVuY3Rpb24gY29ja1RhaWxTb3J0KHNxTGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuICAgIC8vIOWGkuazoeS4iuS4i+eVjFxuICAgIHZhciBsb3cgPSAwLFxuICAgICAgICBoaWdoID0gbGVuIC0gMTtcbiAgICB2YXIgY2hhbmdlID0gMTtcbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcblxuICAgIHdoaWxlIChsb3cgPCBoaWdoICYmIGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSAwO1xuXG4gICAgICAgIC8vIOS7juS4iuWQkeS4i+i1t+azoVxuICAgICAgICBmb3IgKHZhciBpID0gbG93OyBpIDwgaGlnaDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOS/ruaUueS4iueVjFxuICAgICAgICAtLWhpZ2g7XG5cbiAgICAgICAgLy8g5LuO5LiL5ZCR5LiK6LW35rOhXG4gICAgICAgIGZvciAodmFyIF9pID0gaGlnaDsgX2kgPiBsb3c7IC0tX2kpIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtfaV0sIHNxTGlzdFtfaSAtIDFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W19pXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbX2ldID0gc3FMaXN0W19pIC0gMV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W19pIC0gMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+u5pS55LiL55WMXG4gICAgICAgICsrbG93O1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbmNvY2tUYWlsU29ydChhcnIpO1xuY29uc29sZS5sb2coJ2NvY2tUYWlsU29ydDpcXG4nICsgYXJyICsgJycpO1xuXG4vLyDmlLnov5szXG5mdW5jdGlvbiBjb2NrVGFpbFNvcnQyKHNxTGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBiID0ge307XG4gICAgdmFyIGxlbiA9IHNxTGlzdC5sZW5ndGg7XG4gICAgLy8gZOS4uuWGkuazoeaWueWQkeagh+ivhu+8jCAx5Li65ZCR5LiK77yMLTHkuLrlkJHkuItcbiAgICB2YXIgZCA9IDE7XG4gICAgLy8gYlswXeS4uuWGkuazoeS4iueVjO+8jGJbMl3kuLrlhpLms6HkuIrnlYzvvIxiWzFd5peg55SoXG4gICAgYlswXSA9IDA7XG4gICAgYlsyXSA9IGxlbiAtIDE7XG4gICAgdmFyIGNoYW5nZSA9IDE7XG5cbiAgICB3aGlsZSAoYlswXSA8IGJbMl0gJiYgY2hhbmdlKSB7XG4gICAgICAgIGNoYW5nZSA9IDA7XG5cbiAgICAgICAgLy8g57uf5LiA55qE5YaS5rOh566X5rOVXG4gICAgICAgIGZvciAodmFyIGkgPSBiWzEgLSBkXTsgaSAhPT0gYlsxICsgZF07IGkgKz0gZCkge1xuICAgICAgICAgICAgLy8g5rOo5oSP6L+Z5Liq5Lqk5o2i5p2h5Lu2XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgZF0pICogZCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIGRdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgZF0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDkv67mlLnovrnnlYxcbiAgICAgICAgYlsxICsgZF0gLT0gZDtcbiAgICAgICAgLy8g5o2i5Liq5pa55ZCRXG4gICAgICAgIGQgKj0gLTE7XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xuY29ja1RhaWxTb3J0MihhcnIpO1xuY29uc29sZS5sb2coJ2NvY2tUYWlsU29ydDI6XFxuJyArIGFyciArICcnKTtcblxuLypcclxuIOW/q+mAn+aOkuW6j1xyXG5cclxuIDEgIOaOkuW6j+aAneaDs1xyXG4g6YCa6L+H5LiA6Laf5o6S5bqP77yM5bCG5b6F5o6S5bqP6K6w5b2V5YiG5Ymy5oiQ54us56uL55qE5Lik6YOo5YiG77yM5YW25Lit5LiA6YOo5YiG6K6w5b2V55qE5YWz6ZSu5a2X5Z2H5q+U5Y+m5LiA6YOo5YiG6K6w5b2V55qE5YWz6ZSu5a2X5bCP77yM5YaN5YiG5Yir5a+56L+Z5Lik6YOo5YiG6K6w5b2V6L+b6KGM5LiL5LiA6Laf5o6S5bqP77yM5Lul6L6+5Yiw5pW05Liq5bqP5YiX5pyJ5bqP44CCXHJcblxyXG4gMiAg5o6S5bqP6L+H56iLXHJcbiDorr7lvoXmjpLluo/nmoTorrDlvZXluo/liJfmmK9SW3PigKZ0XSDvvIzlnKjorrDlvZXluo/liJfkuK3ku7vlj5bkuIDkuKrorrDlvZUo5LiA6Iis5Y+WUltzXSnkvZzkuLrlj4Lnhaco5Y+I56ew5Li65Z+65YeG5oiW5p6i6L20Ke+8jOS7pVJbc10ua2V55Li65Z+65YeG6YeN5paw5o6S5YiX5YW25L2Z55qE5omA5pyJ6K6w5b2V77yM5pa55rOV5piv77yaXHJcbiAgICAg4peGIOaJgOacieWFs+mUruWtl+avlOWfuuWHhuWwj+eahOaUvlJbc13kuYvliY3vvJtcclxuICAgICDil4Yg5omA5pyJ5YWz6ZSu5a2X5q+U5Z+65YeG5aSn55qE5pS+UltzXeS5i+WQjuOAglxyXG4g5LulUltzXS5rZXnmnIDlkI7miYDlnKjkvY3nva5p5L2c5Li65YiG55WM77yM5bCG5bqP5YiXUltz4oCmdF3liIblibLmiJDkuKTkuKrlrZDluo/liJfvvIznp7DkuLrkuIDotp/lv6vpgJ/mjpLluo/jgIJcclxuXHJcbiAzICDkuIDotp/lv6vpgJ/mjpLluo/mlrnms5VcclxuIOS7juW6j+WIl+eahOS4pOerr+S6pOabv+aJq+aPj+WQhOS4quiusOW9le+8jOWwhuWFs+mUruWtl+Wwj+S6juWfuuWHhuWFs+mUruWtl+eahOiusOW9leS+neasoeaUvue9ruWIsOW6j+WIl+eahOWJjei+ue+8m+iAjOWwhuWFs+mUruWtl+Wkp+S6juWfuuWHhuWFs+mUruWtl+eahOiusOW9leS7juW6j+WIl+eahOacgOWQjuerr+i1t++8jOS+neasoeaUvue9ruWIsOW6j+WIl+eahOWQjui+ue+8jOebtOWIsOaJq+aPj+WujOaJgOacieeahOiusOW9leOAglxyXG5cclxuIOiuvue9ruaMh+mSiGxvd++8jGhpZ2jvvIzliJ3lgLzkuLrnrKwx5Liq5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V55qE5L2N572u44CCXHJcbiDorr7kuKTkuKrlj5jph49p77yMau+8jOWIneWni+aXtuS7pGk9bG9377yMaj1oaWdo77yM5LulUltsb3ddLmtleeS9nOS4uuWfuuWHhijlsIZSW2xvd13kv53lrZjlnKh0ZW1w5LitKSDjgIJcclxuIOKRoCDku45q5omA5oyH5L2N572u5ZCR5YmN5pCc57Si77ya5bCGdGVtcOS4jlJbal0ua2V56L+b6KGM5q+U6L6D77yaXHJcbiAgICDil4Yg6IuldGVtcOKJpFJbal0ua2V5IO+8muS7pGo9ai0x77yM54S25ZCO57un57ut6L+b6KGM5q+U6L6D77yMIOebtOWIsGk9auaIlnRlbXA+UltqXS5rZXnkuLrmraLvvJtcclxuICAgIOKXhiDoi6V0ZW1wPlJbal0ua2V5IO+8mlJbal3vg55SW2ld77yM6IW+56m6UltqXeeahOS9jee9ru+8jCDkuJTku6RpPWkrMe+8m1xyXG4g4pGhIOS7jmnmiYDmjIfkvY3nva7otbflkJHlkI7mkJzntKLvvJrlsIZ0ZW1w5LiOUltpXS5rZXnov5vooYzmr5TovoPvvJpcclxuICAgIOKXhiDoi6V0ZW1w4omlUltpXS5rZXkg77ya5LukaT1pKzHvvIznhLblkI7nu6fnu63ov5vooYzmr5TovoPvvIwg55u05YiwaT1q5oiWdGVtcDxSW2ldLmtleeS4uuatou+8m1xyXG4gICAg4peGIOiLpXRlbXA8UltpXS5rZXkg77yaUltpXe+DnlJbal3vvIzohb7nqbpSW2ld55qE5L2N572u77yMIOS4lOS7pGo9ai0x77ybXHJcbiDikaIg6YeN5aSN4pGg44CB4pGh77yM55u06IezaT1q5Li65q2i77yMaeWwseaYr3RlbXAo5Z+65YeGKeaJgOW6lOaUvue9rueahOS9jee9ruOAglxyXG5cclxuIOeul+azleWIhuaekFxyXG4g5b+r6YCf5o6S5bqP55qE5Li76KaB5pe26Ze05piv6Iqx6LS55Zyo5YiS5YiG5LiK77yM5a+56ZW/5bqm5Li6a+eahOiusOW9leW6j+WIl+i/m+ihjOWIkuWIhuaXtuWFs+mUruWtl+eahOavlOi+g+asoeaVsOaYr2stMSDjgILorr7plb/luqbkuLpu55qE6K6w5b2V5bqP5YiX6L+b6KGM5o6S5bqP55qE5q+U6L6D5qyh5pWw5Li6QyhuKe+8jOWImUMobik9bi0xK0MoaykrQyhuLWstMSkg44CCXHJcbiDil4YgIOacgOWlveaDheWGte+8muavj+asoeWIkuWIhuW+l+WIsOeahOWtkOW6j+WIl+Wkp+iHtOebuOetie+8jOWImVxyXG4gQyhuKTw9aMOXbisyaMOXQyhuLzJoKSDvvIzlvZNuLzJoPTHml7bmjpLluo/nu5PmnZ/jgIJcclxuIOWNs0MobiniiaRPKG7Dl+OPkjJuKSDvvJtcclxuIOKXhiAg5pyA5Z2P5oOF5Ya177ya5q+P5qyh5YiS5YiG5b6X5Yiw55qE5a2Q5bqP5YiX5Lit5pyJ5LiA5Liq5Li656m677yM5Y+m5LiA5Liq5a2Q5bqP5YiX55qE6ZW/5bqm5Li6bi0x44CC5Y2z5q+P5qyh5YiS5YiG5omA6YCJ5oup55qE5Z+65YeG5piv5b2T5YmN5b6F5o6S5bqP5bqP5YiX5Lit55qE5pyA5bCPKOaIluacgOWkpynlhbPplK7lrZfjgIJcclxuIOavlOi+g+asoeaVsO+8mjogIOWNs0Mobik9TyhuMilcclxuIOKXhiAg5LiA6Iis5oOF5Ya177yaIOWvuW7kuKrorrDlvZXov5vooYzlv6vpgJ/mjpLluo/miYDpnIDnmoTml7bpl7RUKG4p57uE5oiQ5piv77yaXHJcbiAgICAg4pGgIOWvuW7kuKrorrDlvZXov5vooYzkuIDotp/liJLliIbmiYDpnIDnmoTml7bpl7TmmK/vvJpuw5dDIO+8jEPmmK/luLjmlbDvvJtcclxuICAgICDikaEg5a+55omA5b6X5Yiw55qE5Lik5Liq5a2Q5bqP5YiX6L+b6KGM5b+r6YCf5o6S5bqP55qE5pe26Ze077yaXHJcbiAgICAgICAgVGF2ZyhuKT1DKG4pK1Rhdmcoay0xKStUYXZnKG4taykgICAgICAgICAg4oCm4oCmXHJcblxyXG4g5b+r6YCf5o6S5bqP55qE5bmz5Z2H5pe26Ze05aSN5p2C5bqm5piv77yaVChuKT1PKG7jj5IybilcclxuIOS7juaJgOmcgOimgeeahOmZhOWKoOepuumXtOadpeeci++8jOW/q+mAn+aOkuW6j+eul+azleaYr+mAkuW9kuiwg+eUqO+8jOezu+e7n+WGheeUqOWghuagiOS/neWtmOmAkuW9kuWPguaVsO+8jOW9k+avj+asoeWIkuWIhuavlOi+g+Wdh+WMgOaXtu+8jOagiOeahOacgOWkp+a3seW6puS4ulvjj5Iybl0rMSDjgIJcclxuXHJcbiDlv6vpgJ/mjpLluo/nmoTnqbrpl7TlpI3mnYLluqbmmK/vvJpTKG4pPU8o44+SMm4pXHJcbiDku47mjpLluo/nmoTnqLPlrprmgKfmnaXnnIvvvIzlv6vpgJ/mjpLluo/mmK/kuI3nqLPlrprnmoTjgIJcclxuXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24xKHNxTGlzdCwgbG93LCBoaWdoKSB7XG4gICAgdmFyIHRlbXAgPSBzcUxpc3RbbG93XTtcblxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoICYmIHNxTGlzdFtoaWdoXSA+PSB0ZW1wKSB7XG4gICAgICAgICAgICAtLWhpZ2g7XG4gICAgICAgIH1zcUxpc3RbbG93XSA9IHNxTGlzdFtoaWdoXTtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2ggJiYgc3FMaXN0W2xvd10gPD0gdGVtcCkge1xuICAgICAgICAgICAgKytsb3c7XG4gICAgICAgIH1zcUxpc3RbaGlnaF0gPSBzcUxpc3RbbG93XTtcbiAgICB9XG5cbiAgICBzcUxpc3RbbG93XSA9IHRlbXA7XG5cbiAgICByZXR1cm4gbG93O1xufVxuXG4vLyDkvJjljJbkuIDotp/lv6vpgJ/mjpLluo/mlrnms5XvvJog6ZqP5py65YyWcGFydGl0aW9uXG4vLyDmnIDlnY/mg4XlhrXmlYjnjoflpKfluYXmj5DljYfvvIzml7bpl7TlpI3mnYLluqZUKG4pPU8obuOPkjJuKVxuZnVuY3Rpb24gcGFydGl0aW9uMihzcUxpc3QsIGxvdywgaGlnaCkge1xuICAgIHZhciB0ZW1wID0gdm9pZCAwO1xuICAgIHZhciBuID0gaGlnaCAtIGxvdyArIDE7XG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuKSArIGxvdztcblxuICAgIC8vbGV0IHJhbmQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICB0ZW1wID0gc3FMaXN0W2hpZ2hdO1xuICAgIHNxTGlzdFtoaWdoXSA9IHNxTGlzdFtyYW5kXTtcbiAgICBzcUxpc3RbcmFuZF0gPSB0ZW1wO1xuXG4gICAgdmFyIGkgPSBsb3cgLSAxO1xuICAgIHZhciBwaXZvdCA9IHNxTGlzdFtoaWdoXTtcblxuICAgIGZvciAodmFyIGogPSBsb3c7IGogPCBoaWdoOyArK2opIHtcbiAgICAgICAgaWYgKHNxTGlzdFtqXSA8PSBwaXZvdCkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICArK2k7XG4gICAgc3FMaXN0W2hpZ2hdID0gc3FMaXN0W2ldO1xuICAgIHNxTGlzdFtpXSA9IHBpdm90O1xuXG4gICAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCkge1xuICAgIHZhciB0ZW1wID0gdm9pZCAwO1xuICAgIHZhciBpID0gbG93O1xuICAgIHZhciBqID0gaGlnaCArIDE7XG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpICsgbG93ICsgMTtcbiAgICAvL2xldCByYW5kID0gKGxvdyArIGhpZ2gpID4+IDE7XG5cbiAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbcmFuZF07XG4gICAgc3FMaXN0W3JhbmRdID0gdGVtcDtcblxuICAgIHZhciB4ID0gc3FMaXN0W2xvd107XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgICB3aGlsZSAoY29tcChzcUxpc3RbKytpXSwgeCkgPCAwICYmIGkgPCBoaWdoKSB7fVxuICAgICAgICB3aGlsZSAoY29tcChzcUxpc3RbLS1qXSwgeCkgPiAwKSB7fVxuICAgICAgICBpZiAoaSA+PSBqKSBicmVhaztcbiAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2pdO1xuICAgICAgICBzcUxpc3Rbal0gPSB0ZW1wO1xuICAgIH1cblxuICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2pdO1xuICAgIHNxTGlzdFtqXSA9IHg7XG5cbiAgICByZXR1cm4gajtcbn1cblxuZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlKCkge1xuICAgIHZhciBzcUxpc3QgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG93ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaGlnaCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHNxTGlzdC5sZW5ndGggLSAxIDogYXJndW1lbnRzWzJdO1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1szXTtcblxuICAgIGlmIChsb3cgPj0gaGlnaCkgcmV0dXJuO1xuXG4gICAgdmFyIGsgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xuICAgIHF1aWNrU29ydFJlY3Vyc2l2ZShzcUxpc3QsIGxvdywgayAtIDEsIGNvbXApO1xuICAgIHF1aWNrU29ydFJlY3Vyc2l2ZShzcUxpc3QsIGsgKyAxLCBoaWdoLCBjb21wKTtcbn1cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbnF1aWNrU29ydFJlY3Vyc2l2ZShhcnIpO1xuY29uc29sZS5sb2coJ3F1aWNrU29ydFJlY3Vyc2l2ZTpcXG4nICsgYXJyICsgJycpO1xuXG4vKlxyXG7lv6vmjpLpgJLlvZLnrpfms5XkvJjljJbvvIzlnKjmnIDlnY/mg4XlhrXkuIvloIbmoIjmt7HluqbkuLpPKGxvZ24pXHJcbiAqL1xuZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlMigpIHtcbiAgICB2YXIgc3FMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvdyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGhpZ2ggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBzcUxpc3QubGVuZ3RoIC0gMSA6IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbM107XG5cbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgayA9IHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCk7XG5cbiAgICAgICAgLy8g5a+55Lik5Liq5a2Q5pWw57uE5Lit6L6D5bCP55qE5LiA5Liq5a2Q5pWw57uE6L+b6KGM6YCS5b2S6LCD55So44CCXG4gICAgICAgIC8vIOi+g+Wwj+WtkOaVsOe7hOeahOWkp+Wwj+acgOWkmuS4uuWOn+aVsOe7hOWkp+Wwj+S4gOWNiu+8jFxuICAgICAgICAvLyDnlLHkuo7mr4/mrKHpgJLlvZLosIPnlKjnmoTmlbDnu4TlpKflsI/oh7PlsJHlh4/lsJHkuIDljYrvvIzmiYDku6XpgJLlvZLosIPnlKjnmoTmrKHmlbBcbiAgICAgICAgLy8g5pyA5aSa5Li6Tyhsb2duKVxuICAgICAgICBpZiAoayAtIGxvdyArIDEgPCBoaWdoIC0gaykge1xuICAgICAgICAgICAgcXVpY2tTb3J0UmVjdXJzaXZlMihzcUxpc3QsIGxvdywgayAtIDEsIGNvbXApO1xuICAgICAgICAgICAgbG93ID0gayArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWlja1NvcnRSZWN1cnNpdmUyKHNxTGlzdCwgayArIDEsIGhpZ2gsIGNvbXApO1xuICAgICAgICAgICAgaGlnaCA9IGsgLSAxO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbnF1aWNrU29ydFJlY3Vyc2l2ZTIoYXJyKTtcbmNvbnNvbGUubG9nKCdxdWlja1NvcnRSZWN1cnNpdmUyOlxcbicgKyBhcnIgKyAnJyk7XG5cbmZ1bmN0aW9uIHF1aWNrU29ydE5vblJlY3Vyc2l2ZSgpIHtcbiAgICB2YXIgc3FMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvdyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGhpZ2ggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBzcUxpc3QubGVuZ3RoIC0gMSA6IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgayA9IHZvaWQgMDtcblxuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGsgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xuICAgICAgICAgICAgLy8g56ys5LqM5Liq5a2Q5bqP5YiX55qE5LiKLOS4i+eVjOWIhuWIq+WFpeagiFxuICAgICAgICAgICAgc3RhY2sucHVzaChoaWdoLCBrICsgMSk7XG4gICAgICAgICAgICAvL3N0YWNrLnB1c2goayArIDEpO1xuICAgICAgICAgICAgaGlnaCA9IGsgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBsb3cgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaGlnaCA9IHN0YWNrLnBvcCgpO1xuICAgIH0gd2hpbGUgKDEpO1xufVxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xucXVpY2tTb3J0Tm9uUmVjdXJzaXZlKGFycik7XG5jb25zb2xlLmxvZygncXVpY2tTb3J0Tm9uUmVjdXJzaXZlOlxcbicgKyBhcnIgKyAnJyk7XG5cbi8vIOS8mOWMlueJiOacrFxuZnVuY3Rpb24gcXVpY2tTb3J0KCkge1xuICAgIHZhciBzcUxpc3QgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG93ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaGlnaCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHNxTGlzdC5sZW5ndGggLSAxIDogYXJndW1lbnRzWzJdO1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBwaXZvdCA9IHZvaWQgMDtcblxuICAgIGRvIHtcbiAgICAgICAgLy8g5aaC5p6c5b2T5YmN5a2Q5bqP5YiX6ZW/5bqm5aSn5LqOM+S4lOWwmuacquaOkuWlveW6j1xuICAgICAgICBpZiAoaGlnaCAtIGxvdyA+IDIpIHtcbiAgICAgICAgICAgIC8vIOi/m+ihjOS4gOi2n+WIkuWIhlxuICAgICAgICAgICAgcGl2b3QgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xuXG4gICAgICAgICAgICAvLyDlkKfplb/nmoTlrZDluo/liJfovrnnlYzlhaXmoIjvvIxcbiAgICAgICAgICAgIC8vIOefreeahOWtkOW6j+WIl+eVmeW+heS4i+asoeaOkuW6j1xuICAgICAgICAgICAgaWYgKGhpZ2ggLSBwaXZvdCA+IHBpdm90IC0gbG93KSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChoaWdoLCBwaXZvdCArIDEpO1xuICAgICAgICAgICAgICAgIC8vc3RhY2sucHVzaCgpO1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBwaXZvdCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGl2b3QgLSAxLCBsb3cpO1xuICAgICAgICAgICAgICAgIC8vc3RhY2sucHVzaCgpO1xuICAgICAgICAgICAgICAgIGxvdyA9IHBpdm90ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzlvZPliY3lrZDluo/liJfplb/luqblsI/kuo4z77yM5LiU5bCa5pyq5o6S5aW95bqP77yMXG4gICAgICAgIC8vIOebtOaOpei/m+ihjOavlOi+g+aOkuW6j+S5sOW9k+WJjeWtkOW6j+WIl+agh+W/l+S4uuW3suaOkuWlveW6j1xuICAgICAgICBlbHNlIGlmIChsb3cgPCBoaWdoICYmIGhpZ2ggLSBsb3cgPCAzKSB7XG4gICAgICAgICAgICAgICAgZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xuICAgICAgICAgICAgICAgIGxvdyA9IGhpZ2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlpoLmnpzlvZPliY3lrZDluo/liJflt7LmjpLlpb3luo/kvYbmoIjkuK3ov5jmnInmnKrmjpLluo/nmoTlrZDluo/liJdcbiAgICAgICAgICAgIC8vIOS7juagiOS4reWPluWHuuS4gOS4quWtkOW6j+WIl1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgbG93ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfSB3aGlsZSAoMSk7XG59XG5cbmZ1bmN0aW9uIGVhc3lTb3J0KHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKSB7XG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG5cbiAgICBpZiAoaGlnaCAtIGxvdyA9PT0gMSkge1xuICAgICAgICBpZiAoY29tcChzcUxpc3RbbG93XSwgc3FMaXN0W2hpZ2hdKSA+IDApIHtcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbbG93XTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2hpZ2hdO1xuICAgICAgICAgICAgc3FMaXN0W2hpZ2hdID0gdGVtcDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbbG93ICsgMV0pID4gMCkge1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xuICAgICAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbbG93ICsgMV07XG4gICAgICAgICAgICBzcUxpc3RbbG93ICsgMV0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtsb3cgKyAxXSwgc3FMaXN0W2hpZ2hdKSA+IDApIHtcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbbG93ICsgMV07XG4gICAgICAgICAgICBzcUxpc3RbbG93ICsgMV0gPSBzcUxpc3RbaGlnaF07XG4gICAgICAgICAgICBzcUxpc3RbaGlnaF0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbbG93ICsgMV0pID4gMCkge1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xuICAgICAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbbG93ICsgMV07XG4gICAgICAgICAgICBzcUxpc3RbbG93ICsgMV0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xucXVpY2tTb3J0KGFycik7XG5jb25zb2xlLmxvZygncXVpY2tTb3J0OlxcbicgKyBhcnIgKyAnJyk7XG5cbi8vIOWlh+WBtuS6pOaNouaOkuW6j1xuZnVuY3Rpb24gb2RkRXZlblNvcnQoKSB7XG4gICAgdmFyIHNxTGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBjaGFuZ2UgPSAxO1xuICAgIHZhciB0ZW1wID0gdm9pZCAwO1xuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSAwO1xuICAgICAgICAvLyDlr7nmiYDmnInlpYfmlbDov5vooYzkuIDotp/mr5TovoNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW4gLSAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIDFdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgMV0gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWvueaJgOacieWBtuaVsOi/m+ihjOS4gOi2n+avlOi+g1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsZW4gLSAxOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W19pMl0sIHNxTGlzdFtfaTIgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtfaTJdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtfaTJdID0gc3FMaXN0W19pMiArIDFdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtfaTIgKyAxXSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xub2RkRXZlblNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKCdvZGRFdmVuU29ydDpcXG4nICsgYXJyICsgJycpO1xuXG4vKlxyXG7miornlLHkuInnp43popzoibLnu4TmiJDnmoTluo/liJfph43mjpLkuLrmjInnhafnuqLnmb3ok53nmoTpobrluo/mjpLliJfvvIxcclxu5oCd6Lev77yaXHJcbuiuvueri+S4ieS4quaMh+mSiO+8jOWFtuS4rWrooajnpLrlvZPliY3lhYPntKDvvJtp5Lul5YmN55qE5YWD57Sg5YWo6YOo5Li657qi6Imy77yba+S7peWQjueahOminOiJsuWFqOS4uuiTneiJsuOAgui/meagt+WwseWPr+S7peagueaNrmrnmoTpopzoibLmiorlhbbkuqTmjaLliLDluo/liJfnmoTliY3pnaLmiJbogIXlkI7pnaLjgIJcclxuICovXG52YXIgUkVEID0gMDtcbnZhciBXSElURSA9IDE7XG52YXIgQkxVRSA9IDI7XG5cbmZ1bmN0aW9uIGZsYWdBcnJhbmdlKGNvbG9ycykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGsgPSBjb2xvcnMubGVuZ3RoIC0gMTtcbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcblxuICAgIHdoaWxlIChqIDw9IGspIHtcbiAgICAgICAgc3dpdGNoIChjb2xvcnNbal0pIHtcbiAgICAgICAgICAgIGNhc2UgUkVEOlxuICAgICAgICAgICAgICAgIHRlbXAgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgY29sb3JzW2ldID0gY29sb3JzW2pdO1xuICAgICAgICAgICAgICAgIGNvbG9yc1tqXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV0hJVEU6XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCTFVFOlxuICAgICAgICAgICAgICAgIHRlbXAgPSBjb2xvcnNbal07XG4gICAgICAgICAgICAgICAgY29sb3JzW2pdID0gY29sb3JzW2tdO1xuICAgICAgICAgICAgICAgIGNvbG9yc1trXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgLS1rO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGFyciA9IFsyLCAxLCAwLCAyLCAxLCAxLCAwLCAyLCAwLCAyLCAxXTtcbmZsYWdBcnJhbmdlKGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9Tb3J0L2V4Y2hhbmdlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaWVlZTc1NC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9ICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMi5kZWZhdWx0KShvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICBmb3IgKHZhciBpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYnVmZmVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpXG4gICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgcmV0dXJuICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XHJcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcclxuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xyXG4gIGFuT2JqZWN0KE8pO1xyXG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIFA7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xyXG4gIHJldHVybiBPO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXHJcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCcuL2NyZWF0ZS1oYXNoJylcblxudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKDEyOClcbnplcm9CdWZmZXIuZmlsbCgwKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhtYWNcblxuZnVuY3Rpb24gSG1hYyAoYWxnLCBrZXkpIHtcbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpIHJldHVybiBuZXcgSG1hYyhhbGcsIGtleSlcbiAgdGhpcy5fb3BhZCA9IG9wYWRcbiAgdGhpcy5fYWxnID0gYWxnXG5cbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInKSA/IDEyOCA6IDY0XG5cbiAga2V5ID0gdGhpcy5fa2V5ID0gIUJ1ZmZlci5pc0J1ZmZlcihrZXkpID8gbmV3IEJ1ZmZlcihrZXkpIDoga2V5XG5cbiAgaWYoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoa2V5KS5kaWdlc3QoKVxuICB9IGVsc2UgaWYoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgemVyb0J1ZmZlcl0sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gdGhpcy5faXBhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShpcGFkKVxufVxuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEsIGVuYylcbiAgcmV0dXJuIHRoaXNcbn1cblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgcmV0dXJuIGNyZWF0ZUhhc2godGhpcy5fYWxnKS51cGRhdGUodGhpcy5fb3BhZCkudXBkYXRlKGgpLmRpZ2VzdChlbmMpXG59XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L2NyZWF0ZS1obWFjLmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaGFzaDogaGFzaCB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vcm5nJylcblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY3JlYXRlSGFzaCA9IHJlcXVpcmUoJy4vY3JlYXRlLWhhc2gnKVxuXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSByZXF1aXJlKCcuL2NyZWF0ZS1obWFjJylcblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKHNpemUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdW5kZWZpbmVkLCBuZXcgQnVmZmVyKHJuZyhzaXplKSkpXG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycikgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHJuZyhzaXplKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoKGEsIGYpIHtcbiAgZm9yKHZhciBpIGluIGEpXG4gICAgZihhW2ldLCBpKVxufVxuXG5leHBvcnRzLmdldEhhc2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFsnc2hhMScsICdzaGEyNTYnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXVxufVxuXG52YXIgcCA9IHJlcXVpcmUoJy4vcGJrZGYyJykoZXhwb3J0cylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlQ2lwaGVyJ1xuLCAnY3JlYXRlQ2lwaGVyaXYnXG4sICdjcmVhdGVEZWNpcGhlcidcbiwgJ2NyZWF0ZURlY2lwaGVyaXYnXG4sICdjcmVhdGVTaWduJ1xuLCAnY3JlYXRlVmVyaWZ5J1xuLCAnY3JlYXRlRGlmZmllSGVsbG1hbidcbl0sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX21kNSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xuXG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWQ1KGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9tZDUsIDE2KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwYmtkZjJFeHBvcnQgPSByZXF1aXJlKCdwYmtkZjItY29tcGF0L3Bia2RmMicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNyeXB0bywgZXhwb3J0cykge1xuICBleHBvcnRzID0gZXhwb3J0cyB8fCB7fVxuXG4gIHZhciBleHBvcnRlZCA9IHBia2RmMkV4cG9ydChjcnlwdG8pXG5cbiAgZXhwb3J0cy5wYmtkZjIgPSBleHBvcnRlZC5wYmtkZjJcbiAgZXhwb3J0cy5wYmtkZjJTeW5jID0gZXhwb3J0ZWQucGJrZGYyU3luY1xuXG4gIHJldHVybiBleHBvcnRzXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9wYmtkZjIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB3aW5kb3cgPyBnbG9iYWwgOiB3aW5kb3cpIHx8IHt9XG4gIF9jcnlwdG8gPSAoXG4gICAgZy5jcnlwdG8gfHwgZy5tc0NyeXB0byB8fCByZXF1aXJlKCdjcnlwdG8nKVxuICApXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIC8vIE1vZGVybiBCcm93c2Vyc1xuICAgIGlmKF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgQnVmZmVyKHNpemUpOyAvL2luIGJyb3dzZXJpZnksIHRoaXMgaXMgYW4gZXh0ZW5kZWQgVWludDhBcnJheVxuICAgICAgLyogVGhpcyB3aWxsIG5vdCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgICovXG4gICAgXG4gICAgICBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9jcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIHJldHVybiBfY3J5cHRvLnJhbmRvbUJ5dGVzKHNpemUpXG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcXG4nK1xuICAgICAgICAndXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMSdcbiAgICAgIClcbiAgfVxufSgpKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcblx0Qy1saWtlIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlcnMgaW4gSmF2YXNjcmlwdFxuXHRDb3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuXHRNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uIChyb290KSB7XG5cblx0Ly8gTG9jYWwgY2FjaGUgZm9yIHR5cGljYWwgcmFkaWNlc1xuXHR2YXIgcmFkaXhQb3dlckNhY2hlID0ge1xuXHRcdDM2OiBVSU5UMzIoIE1hdGgucG93KDM2LCA1KSApXG5cdCxcdDE2OiBVSU5UMzIoIE1hdGgucG93KDE2LCA3KSApXG5cdCxcdDEwOiBVSU5UMzIoIE1hdGgucG93KDEwLCA5KSApXG5cdCxcdDI6ICBVSU5UMzIoIE1hdGgucG93KDIsIDMwKSApXG5cdH1cblx0dmFyIHJhZGl4Q2FjaGUgPSB7XG5cdFx0MzY6IFVJTlQzMigzNilcblx0LFx0MTY6IFVJTlQzMigxNilcblx0LFx0MTA6IFVJTlQzMigxMClcblx0LFx0MjogIFVJTlQzMigyKVxuXHR9XG5cblx0LyoqXG5cdCAqXHRSZXByZXNlbnRzIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE51bWJlcn0gbG93IGJpdHMgICAgIHwgaW50ZWdlciBhcyBhIHN0cmluZyBcdFx0IHwgaW50ZWdlciBhcyBhIG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcnxOdW1iZXJ8VW5kZWZpbmVkfSBoaWdoIGJpdHMgfCByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gXG5cdCAqL1xuXHRmdW5jdGlvbiBVSU5UMzIgKGwsIGgpIHtcblx0XHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIFVJTlQzMikgKVxuXHRcdFx0cmV0dXJuIG5ldyBVSU5UMzIobCwgaClcblxuXHRcdHRoaXMuX2xvdyA9IDBcblx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdHRoaXMucmVtYWluZGVyID0gbnVsbFxuXHRcdGlmICh0eXBlb2YgaCA9PSAndW5kZWZpbmVkJylcblx0XHRcdHJldHVybiBmcm9tTnVtYmVyLmNhbGwodGhpcywgbClcblxuXHRcdGlmICh0eXBlb2YgbCA9PSAnc3RyaW5nJylcblx0XHRcdHJldHVybiBmcm9tU3RyaW5nLmNhbGwodGhpcywgbCwgaClcblxuXHRcdGZyb21CaXRzLmNhbGwodGhpcywgbCwgaClcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IHdpdGggaXRzIGxvdyBhbmQgaGlnaCBiaXRzXG5cdCAqIEBtZXRob2QgZnJvbUJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvdyBiaXRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIGJpdHNcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbUJpdHMgKGwsIGgpIHtcblx0XHR0aGlzLl9sb3cgPSBsIHwgMFxuXHRcdHRoaXMuX2hpZ2ggPSBoIHwgMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21CaXRzID0gZnJvbUJpdHNcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UMzJfIG9iamVjdCBmcm9tIGEgbnVtYmVyXG5cdCAqIEBtZXRob2QgZnJvbU51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21OdW1iZXIgKHZhbHVlKSB7XG5cdFx0dGhpcy5fbG93ID0gdmFsdWUgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdmFsdWUgPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQzMi5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZyb21OdW1iZXJcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UMzJfIG9iamVjdCBmcm9tIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgZnJvbVN0cmluZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZWdlciBhcyBhIHN0cmluZ1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tU3RyaW5nIChzLCByYWRpeCkge1xuXHRcdHZhciB2YWx1ZSA9IHBhcnNlSW50KHMsIHJhZGl4IHx8IDEwKVxuXG5cdFx0dGhpcy5fbG93ID0gdmFsdWUgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdmFsdWUgPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQzMi5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZyb21TdHJpbmdcblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UMzJfIHRvIGEgbnVtYmVyXG5cdCAqIEBtZXRob2QgdG9OdW1iZXJcblx0ICogQHJldHVybiB7TnVtYmVyfSB0aGUgY29udmVydGVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UMzJfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJhZGl4ID0gcmFkaXggfHwgMTBcblx0XHR2YXIgcmFkaXhVaW50ID0gcmFkaXhDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQzMihyYWRpeClcblxuXHRcdGlmICggIXRoaXMuZ3QocmFkaXhVaW50KSApIHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cblx0XHR2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKVxuXHRcdHZhciByZXMgPSBuZXcgQXJyYXkoMzIpXG5cdFx0Zm9yICh2YXIgaSA9IDMxOyBpID49IDA7IGktLSkge1xuXHRcdFx0c2VsZi5kaXYocmFkaXhVaW50KVxuXHRcdFx0cmVzW2ldID0gc2VsZi5yZW1haW5kZXIudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblx0XHRcdGlmICggIXNlbGYuZ3QocmFkaXhVaW50KSApIGJyZWFrXG5cdFx0fVxuXHRcdHJlc1tpLTFdID0gc2VsZi50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0cmV0dXJuIHJlcy5qb2luKCcnKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR2YXIgYTAwID0gdGhpcy5fbG93ICsgb3RoZXIuX2xvd1xuXHRcdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cblx0XHRhMTYgKz0gdGhpcy5faGlnaCArIG90aGVyLl9oaWdoXG5cblx0XHR0aGlzLl9sb3cgPSBhMDAgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gYTE2ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBzdWJ0cmFjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvL1RPRE8gaW5saW5lXG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBvdGhlci5jbG9uZSgpLm5lZ2F0ZSgpIClcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgbXVsdGlwbHlcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0Lypcblx0XHRcdGEgPSBhMDAgKyBhMTZcblx0XHRcdGIgPSBiMDAgKyBiMTZcblx0XHRcdGEqYiA9IChhMDAgKyBhMTYpKGIwMCArIGIxNilcblx0XHRcdFx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMTZiMDAgKyBhMTZiMTZcblxuXHRcdFx0YTE2YjE2IG92ZXJmbG93cyB0aGUgMzJiaXRzXG5cdFx0ICovXG5cdFx0dmFyIGExNiA9IHRoaXMuX2hpZ2hcblx0XHR2YXIgYTAwID0gdGhpcy5fbG93XG5cdFx0dmFyIGIxNiA9IG90aGVyLl9oaWdoXG5cdFx0dmFyIGIwMCA9IG90aGVyLl9sb3dcblxuLyogUmVtb3ZlZCB0byBpbmNyZWFzZSBzcGVlZCB1bmRlciBub3JtYWwgY2lyY3Vtc3RhbmNlcyAoaS5lLiBub3QgbXVsdGlwbHlpbmcgYnkgMCBvciAxKVxuXHRcdC8vIHRoaXMgPT0gMCBvciBvdGhlciA9PSAxOiBub3RoaW5nIHRvIGRvXG5cdFx0aWYgKChhMDAgPT0gMCAmJiBhMTYgPT0gMCkgfHwgKGIwMCA9PSAxICYmIGIxNiA9PSAwKSkgcmV0dXJuIHRoaXNcblxuXHRcdC8vIG90aGVyID09IDAgb3IgdGhpcyA9PSAxOiB0aGlzID0gb3RoZXJcblx0XHRpZiAoKGIwMCA9PSAwICYmIGIxNiA9PSAwKSB8fCAoYTAwID09IDEgJiYgYTE2ID09IDApKSB7XG5cdFx0XHR0aGlzLl9sb3cgPSBvdGhlci5fbG93XG5cdFx0XHR0aGlzLl9oaWdoID0gb3RoZXIuX2hpZ2hcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuKi9cblxuXHRcdHZhciBjMTYsIGMwMFxuXHRcdGMwMCA9IGEwMCAqIGIwMFxuXHRcdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRcdGMxNiArPSBhMTYgKiBiMDBcblx0XHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0XHRjMTYgKz0gYTAwICogYjE2XG5cblx0XHR0aGlzLl9sb3cgPSBjMDAgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gYzE2ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZSB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0LlxuXHQgKiBUaGUgcmVtYWluZGVyIGlzIG1hZGUgYXZhaWxhYmxlIGFzIHRoZSBfcmVtYWluZGVyXyBwcm9wZXJ0eSBvblxuXHQgKiB0aGUgX1VJTlQzMl8gb2JqZWN0LiBJdCBjYW4gYmUgbnVsbCwgbWVhbmluZyB0aGVyZSBhcmUgbm8gcmVtYWluZGVyLlxuXHQgKiBAbWV0aG9kIGRpdlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKCAob3RoZXIuX2xvdyA9PSAwKSAmJiAob3RoZXIuX2hpZ2ggPT0gMCkgKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG5cblx0XHQvLyBvdGhlciA9PSAxXG5cdFx0aWYgKG90aGVyLl9oaWdoID09IDAgJiYgb3RoZXIuX2xvdyA9PSAxKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UMzIoMClcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgPiB0aGlzOiAwXG5cdFx0aWYgKCBvdGhlci5ndCh0aGlzKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Ly8gb3RoZXIgPT0gdGhpczogMVxuXHRcdGlmICggdGhpcy5lcShvdGhlcikgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UMzIoMClcblx0XHRcdHRoaXMuX2xvdyA9IDFcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdC8vIFNoaWZ0IHRoZSBkaXZpc29yIGxlZnQgdW50aWwgaXQgaXMgaGlnaGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0dmFyIF9vdGhlciA9IG90aGVyLmNsb25lKClcblx0XHR2YXIgaSA9IC0xXG5cdFx0d2hpbGUgKCAhdGhpcy5sdChfb3RoZXIpICkge1xuXHRcdFx0Ly8gSGlnaCBiaXQgY2FuIG92ZXJmbG93IHRoZSBkZWZhdWx0IDE2Yml0c1xuXHRcdFx0Ly8gSXRzIG9rIHNpbmNlIHdlIHJpZ2h0IHNoaWZ0IGFmdGVyIHRoaXMgbG9vcFxuXHRcdFx0Ly8gVGhlIG92ZXJmbG93biBiaXQgbXVzdCBiZSBrZXB0IHRob3VnaFxuXHRcdFx0X290aGVyLnNoaWZ0TGVmdCgxLCB0cnVlKVxuXHRcdFx0aSsrXG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSByZW1haW5kZXJcblx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgcmVzdWx0IHRvIDBcblx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0dGhpcy5faGlnaCA9IDBcblx0XHRmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdF9vdGhlci5zaGlmdFJpZ2h0KDEpXG5cdFx0XHQvLyBJZiBzaGlmdGVkIGRpdmlzb3IgaXMgc21hbGxlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdFx0Ly8gdGhlbiBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBkaXZpZGVuZFxuXHRcdFx0aWYgKCAhdGhpcy5yZW1haW5kZXIubHQoX290aGVyKSApIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIuc3VidHJhY3QoX290aGVyKVxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcmVzdWx0XG5cdFx0XHRcdGlmIChpID49IDE2KSB7XG5cdFx0XHRcdFx0dGhpcy5faGlnaCB8PSAxIDw8IChpIC0gMTYpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fbG93IHw9IDEgPDwgaVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBOZWdhdGUgdGhlIGN1cnJlbnQgX1VJTlQzMl9cblx0ICogQG1ldGhvZCBuZWdhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHYgPSAoIH50aGlzLl9sb3cgJiAweEZGRkYgKSArIDFcblx0XHR0aGlzLl9sb3cgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9ICh+dGhpcy5faGlnaCArICh2ID4+PiAxNikpICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEVxdWFsc1xuXHQgKiBAbWV0aG9kIGVxXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZXF1YWxzID0gVUlOVDMyLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiAodGhpcy5fbG93ID09IG90aGVyLl9sb3cpICYmICh0aGlzLl9oaWdoID09IG90aGVyLl9oaWdoKVxuXHR9XG5cblx0LyoqXG5cdCAqIEdyZWF0ZXIgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGd0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBVSU5UMzIucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2hpZ2ggPiBvdGhlci5faGlnaCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fbG93ID4gb3RoZXIuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIExlc3MgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubGVzc1RoYW4gPSBVSU5UMzIucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2hpZ2ggPCBvdGhlci5faGlnaCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fbG93IDwgb3RoZXIuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgT1Jcblx0ICogQG1ldGhvZCBvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9sb3cgfD0gb3RoZXIuX2xvd1xuXHRcdHRoaXMuX2hpZ2ggfD0gb3RoZXIuX2hpZ2hcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBBTkRcblx0ICogQG1ldGhvZCBhbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyAmPSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCAmPSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE5PVFxuXHQgKiBAbWV0aG9kIG5vdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xvdyA9IH50aGlzLl9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gfnRoaXMuX2hpZ2ggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBYT1Jcblx0ICogQG1ldGhvZCB4b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyBePSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCBePSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IHJpZ2h0XG5cdCAqIEBtZXRob2Qgc2hpZnRSaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2ggPj4gKG4gLSAxNilcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIGlmIChuID09IDE2KSB7XG5cdFx0XHR0aGlzLl9sb3cgPSB0aGlzLl9oaWdoXG5cdFx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9sb3cgPSAodGhpcy5fbG93ID4+IG4pIHwgKCAodGhpcy5faGlnaCA8PCAoMTYtbikpICYgMHhGRkZGIClcblx0XHRcdHRoaXMuX2hpZ2ggPj49IG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgbGVmdFxuXHQgKiBAbWV0aG9kIHNoaWZ0TGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyBvdmVyZmxvd1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFVJTlQzMi5wcm90b3R5cGUuc2hpZnRsID0gZnVuY3Rpb24gKG4sIGFsbG93T3ZlcmZsb3cpIHtcblx0XHRpZiAobiA+IDE2KSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gdGhpcy5fbG93IDw8IChuIC0gMTYpXG5cdFx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdFx0dGhpcy5faGlnaCAmPSAweEZGRkZcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3dcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlnaCA9ICh0aGlzLl9oaWdoIDw8IG4pIHwgKHRoaXMuX2xvdyA+PiAoMTYtbikpXG5cdFx0XHR0aGlzLl9sb3cgPSAodGhpcy5fbG93IDw8IG4pICYgMHhGRkZGXG5cdFx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdFx0Ly8gT3ZlcmZsb3cgb25seSBhbGxvd2VkIG9uIHRoZSBoaWdoIGJpdHMuLi5cblx0XHRcdFx0dGhpcy5faGlnaCAmPSAweEZGRkZcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIGxlZnRcblx0ICogQG1ldGhvZCByb3RsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5yb3RsID0gZnVuY3Rpb24gKG4pIHtcblx0XHR2YXIgdiA9ICh0aGlzLl9oaWdoIDw8IDE2KSB8IHRoaXMuX2xvd1xuXHRcdHYgPSAodiA8PCBuKSB8ICh2ID4+PiAoMzIgLSBuKSlcblx0XHR0aGlzLl9sb3cgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHYgPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIHJpZ2h0XG5cdCAqIEBtZXRob2Qgcm90clxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnJvdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2ID4+PiBuKSB8ICh2IDw8ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhlIGN1cnJlbnQgX1VJTlQzMl9cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGNsb25lZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBVSU5UMzIodGhpcy5fbG93LCB0aGlzLl9oaWdoKVxuXHR9XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRCAvIFJlcXVpcmVKU1xuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFVJTlQzMlxuXHRcdH0pXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuanNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFVJTlQzMlxuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRyb290WydVSU5UMzInXSA9IFVJTlQzMlxuXHR9XG5cbn0pKHRoaXMpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jdWludC9saWIvdWludDMyLmpzXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcblx0Qy1saWtlIHVuc2lnbmVkIDY0IGJpdHMgaW50ZWdlcnMgaW4gSmF2YXNjcmlwdFxuXHRDb3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuXHRNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uIChyb290KSB7XG5cblx0Ly8gTG9jYWwgY2FjaGUgZm9yIHR5cGljYWwgcmFkaWNlc1xuXHR2YXIgcmFkaXhQb3dlckNhY2hlID0ge1xuXHRcdDE2OiBVSU5UNjQoIE1hdGgucG93KDE2LCA1KSApXG5cdCxcdDEwOiBVSU5UNjQoIE1hdGgucG93KDEwLCA1KSApXG5cdCxcdDI6ICBVSU5UNjQoIE1hdGgucG93KDIsIDUpIClcblx0fVxuXHR2YXIgcmFkaXhDYWNoZSA9IHtcblx0XHQxNjogVUlOVDY0KDE2KVxuXHQsXHQxMDogVUlOVDY0KDEwKVxuXHQsXHQyOiAgVUlOVDY0KDIpXG5cdH1cblxuXHQvKipcblx0ICpcdFJlcHJlc2VudHMgYW4gdW5zaWduZWQgNjQgYml0cyBpbnRlZ2VyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBoaWdoIGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgaGlnaCBiaXRzICg4KVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHMgKDMyKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzICgzMilcblx0ICogb3Jcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpbnRlZ2VyIGFzIGEgc3RyaW5nIFx0XHQgfCBpbnRlZ2VyIGFzIGEgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFVuZGVmaW5lZH0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFxuXHQgKi9cblx0ZnVuY3Rpb24gVUlOVDY0IChhMDAsIGExNiwgYTMyLCBhNDgpIHtcblx0XHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIFVJTlQ2NCkgKVxuXHRcdFx0cmV0dXJuIG5ldyBVSU5UNjQoYTAwLCBhMTYsIGEzMiwgYTQ4KVxuXG5cdFx0dGhpcy5yZW1haW5kZXIgPSBudWxsXG5cdFx0aWYgKHR5cGVvZiBhMDAgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gZnJvbVN0cmluZy5jYWxsKHRoaXMsIGEwMCwgYTE2KVxuXG5cdFx0aWYgKHR5cGVvZiBhMTYgPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRyZXR1cm4gZnJvbU51bWJlci5jYWxsKHRoaXMsIGEwMClcblxuXHRcdGZyb21CaXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IHdpdGggaXRzIGxvdyBhbmQgaGlnaCBiaXRzXG5cdCAqIEBtZXRob2QgZnJvbUJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgaGlnaCBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGhpZ2ggYml0cyAoOClcblx0ICogb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvdyBiaXRzICgzMilcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0cyAoMzIpXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21CaXRzIChhMDAsIGExNiwgYTMyLCBhNDgpIHtcblx0XHRpZiAodHlwZW9mIGEzMiA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5fYTAwID0gYTAwICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSBhMDAgPj4+IDE2XG5cdFx0XHR0aGlzLl9hMzIgPSBhMTYgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9IGExNiA+Pj4gMTZcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0dGhpcy5fYTAwID0gYTAwIHwgMFxuXHRcdHRoaXMuX2ExNiA9IGExNiB8IDBcblx0XHR0aGlzLl9hMzIgPSBhMzIgfCAwXG5cdFx0dGhpcy5fYTQ4ID0gYTQ4IHwgMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21CaXRzID0gZnJvbUJpdHNcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCBmcm9tIGEgbnVtYmVyXG5cdCAqIEBtZXRob2QgZnJvbU51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21OdW1iZXIgKHZhbHVlKSB7XG5cdFx0dGhpcy5fYTAwID0gdmFsdWUgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSB2YWx1ZSA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3QgZnJvbSBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIGZyb21TdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVnZXIgYXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAocywgcmFkaXgpIHtcblx0XHRyYWRpeCA9IHJhZGl4IHx8IDEwXG5cblx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0dGhpcy5fYTE2ID0gMFxuXHRcdHRoaXMuX2EzMiA9IDBcblx0XHR0aGlzLl9hNDggPSAwXG5cblx0XHQvKlxuXHRcdFx0SW4gSmF2YXNjcmlwdCwgYml0d2lzZSBvcGVyYXRvcnMgb25seSBvcGVyYXRlIG9uIHRoZSBmaXJzdCAzMiBiaXRzIFxuXHRcdFx0b2YgYSBudW1iZXIsIGV2ZW4gdGhvdWdoIHBhcnNlSW50KCkgZW5jb2RlcyBudW1iZXJzIHdpdGggYSA1MyBiaXRzIFxuXHRcdFx0bWFudGlzc2EuXG5cdFx0XHRUaGVyZWZvcmUgVUlOVDY0KDxOdW1iZXI+KSBjYW4gb25seSB3b3JrIG9uIDMyIGJpdHMuXG5cdFx0XHRUaGUgcmFkaXggbWF4aW11bSB2YWx1ZSBpcyAzNiAoYXMgcGVyIEVDTUEgc3BlY3MpICgyNiBsZXR0ZXJzICsgMTAgZGlnaXRzKVxuXHRcdFx0bWF4aW11bSBpbnB1dCB2YWx1ZSBpcyBtID0gMzJiaXRzIGFzIDEgPSAyXjMyIC0gMVxuXHRcdFx0U28gdGhlIG1heGltdW0gc3Vic3RyaW5nIGxlbmd0aCBuIGlzOlxuXHRcdFx0MzZeKG4rMSkgLSAxID0gMl4zMiAtIDFcblx0XHRcdDM2XihuKzEpID0gMl4zMlxuXHRcdFx0KG4rMSlsbigzNikgPSAzMmxuKDIpXG5cdFx0XHRuID0gMzJsbigyKS9sbigzNikgLSAxXG5cdFx0XHRuID0gNS4xODk2NDQ5MTU2ODc2OTJcblx0XHRcdG4gPSA1XG5cdFx0ICovXG5cdFx0dmFyIHJhZGl4VWludCA9IHJhZGl4UG93ZXJDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQ2NCggTWF0aC5wb3cocmFkaXgsIDUpIClcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA1KSB7XG5cdFx0XHR2YXIgc2l6ZSA9IE1hdGgubWluKDUsIGxlbiAtIGkpXG5cdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUludCggcy5zbGljZShpLCBpICsgc2l6ZSksIHJhZGl4IClcblx0XHRcdHRoaXMubXVsdGlwbHkoXG5cdFx0XHRcdFx0c2l6ZSA8IDVcblx0XHRcdFx0XHRcdD8gbmV3IFVJTlQ2NCggTWF0aC5wb3cocmFkaXgsIHNpemUpIClcblx0XHRcdFx0XHRcdDogcmFkaXhVaW50XG5cdFx0XHRcdClcblx0XHRcdFx0LmFkZCggbmV3IFVJTlQ2NCh2YWx1ZSkgKVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZ1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQ2NF8gdG8gYSBudW1iZXIgKGxhc3QgMzIgYml0cyBhcmUgZHJvcHBlZClcblx0ICogQG1ldGhvZCB0b051bWJlclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb252ZXJ0ZWQgVUlOVDY0XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAodGhpcy5fYTE2IDw8IDE2KSB8IHRoaXMuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDY0XyB0byBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGNvbnZlcnRlZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcblx0XHRyYWRpeCA9IHJhZGl4IHx8IDEwXG5cdFx0dmFyIHJhZGl4VWludCA9IHJhZGl4Q2FjaGVbcmFkaXhdIHx8IG5ldyBVSU5UNjQocmFkaXgpXG5cblx0XHRpZiAoICF0aGlzLmd0KHJhZGl4VWludCkgKSByZXR1cm4gdGhpcy50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLmNsb25lKClcblx0XHR2YXIgcmVzID0gbmV3IEFycmF5KDY0KVxuXHRcdGZvciAodmFyIGkgPSA2MzsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHNlbGYuZGl2KHJhZGl4VWludClcblx0XHRcdHJlc1tpXSA9IHNlbGYucmVtYWluZGVyLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cdFx0XHRpZiAoICFzZWxmLmd0KHJhZGl4VWludCkgKSBicmVha1xuXHRcdH1cblx0XHRyZXNbaS0xXSA9IHNlbGYudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblxuXHRcdHJldHVybiByZXMuam9pbignJylcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dmFyIGEwMCA9IHRoaXMuX2EwMCArIG90aGVyLl9hMDBcblxuXHRcdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cdFx0YTE2ICs9IHRoaXMuX2ExNiArIG90aGVyLl9hMTZcblxuXHRcdHZhciBhMzIgPSBhMTYgPj4+IDE2XG5cdFx0YTMyICs9IHRoaXMuX2EzMiArIG90aGVyLl9hMzJcblxuXHRcdHZhciBhNDggPSBhMzIgPj4+IDE2XG5cdFx0YTQ4ICs9IHRoaXMuX2E0OCArIG90aGVyLl9hNDhcblxuXHRcdHRoaXMuX2EwMCA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IGExNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IGEzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IGE0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdCB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2Qgc3VidHJhY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBvdGhlci5jbG9uZSgpLm5lZ2F0ZSgpIClcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgbXVsdGlwbHlcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0Lypcblx0XHRcdGEgPSBhMDAgKyBhMTYgKyBhMzIgKyBhNDhcblx0XHRcdGIgPSBiMDAgKyBiMTYgKyBiMzIgKyBiNDhcblx0XHRcdGEqYiA9IChhMDAgKyBhMTYgKyBhMzIgKyBhNDgpKGIwMCArIGIxNiArIGIzMiArIGI0OClcblx0XHRcdFx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMDBiMzIgKyBhMDBiNDhcblx0XHRcdFx0KyBhMTZiMDAgKyBhMTZiMTYgKyBhMTZiMzIgKyBhMTZiNDhcblx0XHRcdFx0KyBhMzJiMDAgKyBhMzJiMTYgKyBhMzJiMzIgKyBhMzJiNDhcblx0XHRcdFx0KyBhNDhiMDAgKyBhNDhiMTYgKyBhNDhiMzIgKyBhNDhiNDhcblxuXHRcdFx0YTE2YjQ4LCBhMzJiMzIsIGE0OGIxNiwgYTQ4YjMyIGFuZCBhNDhiNDggb3ZlcmZsb3cgdGhlIDY0IGJpdHNcblx0XHRcdHNvIGl0IGNvbWVzIGRvd24gdG86XG5cdFx0XHRhKmJcdD0gYTAwYjAwICsgYTAwYjE2ICsgYTAwYjMyICsgYTAwYjQ4XG5cdFx0XHRcdCsgYTE2YjAwICsgYTE2YjE2ICsgYTE2YjMyXG5cdFx0XHRcdCsgYTMyYjAwICsgYTMyYjE2XG5cdFx0XHRcdCsgYTQ4YjAwXG5cdFx0XHRcdD0gYTAwYjAwXG5cdFx0XHRcdCsgYTAwYjE2ICsgYTE2YjAwXG5cdFx0XHRcdCsgYTAwYjMyICsgYTE2YjE2ICsgYTMyYjAwXG5cdFx0XHRcdCsgYTAwYjQ4ICsgYTE2YjMyICsgYTMyYjE2ICsgYTQ4YjAwXG5cdFx0ICovXG5cdFx0dmFyIGEwMCA9IHRoaXMuX2EwMFxuXHRcdHZhciBhMTYgPSB0aGlzLl9hMTZcblx0XHR2YXIgYTMyID0gdGhpcy5fYTMyXG5cdFx0dmFyIGE0OCA9IHRoaXMuX2E0OFxuXHRcdHZhciBiMDAgPSBvdGhlci5fYTAwXG5cdFx0dmFyIGIxNiA9IG90aGVyLl9hMTZcblx0XHR2YXIgYjMyID0gb3RoZXIuX2EzMlxuXHRcdHZhciBiNDggPSBvdGhlci5fYTQ4XG5cblx0XHR2YXIgYzAwID0gYTAwICogYjAwXG5cblx0XHR2YXIgYzE2ID0gYzAwID4+PiAxNlxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblx0XHR2YXIgYzMyID0gYzE2ID4+PiAxNlxuXHRcdGMxNiAmPSAweEZGRkZcblx0XHRjMTYgKz0gYTE2ICogYjAwXG5cblx0XHRjMzIgKz0gYzE2ID4+PiAxNlxuXHRcdGMzMiArPSBhMDAgKiBiMzJcblx0XHR2YXIgYzQ4ID0gYzMyID4+PiAxNlxuXHRcdGMzMiAmPSAweEZGRkZcblx0XHRjMzIgKz0gYTE2ICogYjE2XG5cdFx0YzQ4ICs9IGMzMiA+Pj4gMTZcblx0XHRjMzIgJj0gMHhGRkZGXG5cdFx0YzMyICs9IGEzMiAqIGIwMFxuXG5cdFx0YzQ4ICs9IGMzMiA+Pj4gMTZcblx0XHRjNDggKz0gYTAwICogYjQ4XG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhMTYgKiBiMzJcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGEzMiAqIGIxNlxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTQ4ICogYjAwXG5cblx0XHR0aGlzLl9hMDAgPSBjMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBjMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSBjMzIgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBjNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDY0XyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fYTE2ID09IDApICYmIChvdGhlci5fYTMyID09IDApICYmIChvdGhlci5fYTQ4ID09IDApICkge1xuXHRcdFx0aWYgKG90aGVyLl9hMDAgPT0gMCkgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKVxuXG5cdFx0XHQvLyBvdGhlciA9PSAxOiB0aGlzXG5cdFx0XHRpZiAob3RoZXIuX2EwMCA9PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQ2NCgwKVxuXHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG90aGVyID4gdGhpczogMFxuXHRcdGlmICggb3RoZXIuZ3QodGhpcykgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Ly8gb3RoZXIgPT0gdGhpczogMVxuXHRcdGlmICggdGhpcy5lcShvdGhlcikgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UNjQoMClcblx0XHRcdHRoaXMuX2EwMCA9IDFcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2EwMCA9IDBcblx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblx0XHRmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdF9vdGhlci5zaGlmdFJpZ2h0KDEpXG5cdFx0XHQvLyBJZiBzaGlmdGVkIGRpdmlzb3IgaXMgc21hbGxlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdFx0Ly8gdGhlbiBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBkaXZpZGVuZFxuXHRcdFx0aWYgKCAhdGhpcy5yZW1haW5kZXIubHQoX290aGVyKSApIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIuc3VidHJhY3QoX290aGVyKVxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcmVzdWx0XG5cdFx0XHRcdGlmIChpID49IDQ4KSB7XG5cdFx0XHRcdFx0dGhpcy5fYTQ4IHw9IDEgPDwgKGkgLSA0OClcblx0XHRcdFx0fSBlbHNlIGlmIChpID49IDMyKSB7XG5cdFx0XHRcdFx0dGhpcy5fYTMyIHw9IDEgPDwgKGkgLSAzMilcblx0XHRcdFx0fSBlbHNlIGlmIChpID49IDE2KSB7XG5cdFx0XHRcdFx0dGhpcy5fYTE2IHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hMDAgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDY0X1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2EwMCAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2EwMCA9IHYgJiAweEZGRkZcblx0XHR2ID0gKH50aGlzLl9hMTYgJiAweEZGRkYpICsgKHYgPj4+IDE2KVxuXHRcdHRoaXMuX2ExNiA9IHYgJiAweEZGRkZcblx0XHR2ID0gKH50aGlzLl9hMzIgJiAweEZGRkYpICsgKHYgPj4+IDE2KVxuXHRcdHRoaXMuX2EzMiA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSAofnRoaXMuX2E0OCArICh2ID4+PiAxNikpICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cblx0ICogQG1ldGhvZCBlcVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmVxdWFscyA9IFVJTlQ2NC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2E0OCA9PSBvdGhlci5fYTQ4KSAmJiAodGhpcy5fYTAwID09IG90aGVyLl9hMDApXG5cdFx0XHQgJiYgKHRoaXMuX2EzMiA9PSBvdGhlci5fYTMyKSAmJiAodGhpcy5fYTE2ID09IG90aGVyLl9hMTYpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQ2NC5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5fYTQ4ID4gb3RoZXIuX2E0OCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTQ4IDwgb3RoZXIuX2E0OCkgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2EzMiA+IG90aGVyLl9hMzIpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2EzMiA8IG90aGVyLl9hMzIpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMTYgPiBvdGhlci5fYTE2KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMTYgPCBvdGhlci5fYTE2KSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYTAwID4gb3RoZXIuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIExlc3MgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubGVzc1RoYW4gPSBVSU5UNjQucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2E0OCA8IG90aGVyLl9hNDgpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2E0OCA+IG90aGVyLl9hNDgpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMzIgPCBvdGhlci5fYTMyKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMzIgPiBvdGhlci5fYTMyKSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTE2IDwgb3RoZXIuX2ExNikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTE2ID4gb3RoZXIuX2ExNikgcmV0dXJuIGZhbHNlXG5cdFx0cmV0dXJuIHRoaXMuX2EwMCA8IG90aGVyLl9hMDBcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE9SXG5cdCAqIEBtZXRob2Qgb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwIHw9IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgfD0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiB8PSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4IHw9IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBBTkRcblx0ICogQG1ldGhvZCBhbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCAmPSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2ICY9IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgJj0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCAmPSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgWE9SXG5cdCAqIEBtZXRob2QgeG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgXj0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiBePSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyIF49IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggXj0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE5PVFxuXHQgKiBAbWV0aG9kIG5vdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2EwMCA9IH50aGlzLl9hMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSB+dGhpcy5fYTE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gfnRoaXMuX2EzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IH50aGlzLl9hNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCByaWdodFxuXHQgKiBAbWV0aG9kIHNoaWZ0UmlnaHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRSaWdodCA9IFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRyID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPj0gNDgpIHtcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2E0OCA+PiAobiAtIDQ4KVxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAzMikge1xuXHRcdFx0biAtPSAzMlxuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMTYpIHtcblx0XHRcdG4gLT0gMTZcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2ExNiA+PiBuKSB8ICh0aGlzLl9hMzIgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMDAgPj4gbikgfCAodGhpcy5fYTE2IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKCAodGhpcy5fYTE2ID4+IG4pIHwgKHRoaXMuX2EzMiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IGxlZnRcblx0ICogQG1ldGhvZCBzaGlmdExlZnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3cgb3ZlcmZsb3dcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zaGlmdExlZnQgPSBVSU5UNjQucHJvdG90eXBlLnNoaWZ0bCA9IGZ1bmN0aW9uIChuLCBhbGxvd092ZXJmbG93KSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID49IDQ4KSB7XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMDAgPDwgKG4gLSA0OClcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMzIpIHtcblx0XHRcdG4gLT0gMzJcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMTYpIHtcblx0XHRcdG4gLT0gMTZcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hMzIgPDwgbikgfCAodGhpcy5fYTE2ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hNDggPDwgbikgfCAodGhpcy5fYTMyID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2EzMiA8PCBuKSB8ICh0aGlzLl9hMTYgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTAwID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdH1cblx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdHRoaXMuX2E0OCAmPSAweEZGRkZcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIGxlZnRcblx0ICogQG1ldGhvZCByb3RsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gVUlOVDY0LnByb3RvdHlwZS5yb3RsID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPT0gMCkgcmV0dXJuIHRoaXNcblx0XHRpZiAobiA+PSAzMikge1xuXHRcdFx0Ly8gQS5CLkMuRFxuXHRcdFx0Ly8gQi5DLkQuQSByb3RsKDE2KVxuXHRcdFx0Ly8gQy5ELkEuQiByb3RsKDMyKVxuXHRcdFx0dmFyIHYgPSB0aGlzLl9hMDBcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2EzMlxuXHRcdFx0dGhpcy5fYTMyID0gdlxuXHRcdFx0diA9IHRoaXMuX2E0OFxuXHRcdFx0dGhpcy5fYTQ4ID0gdGhpcy5fYTE2XG5cdFx0XHR0aGlzLl9hMTYgPSB2XG5cdFx0XHRpZiAobiA9PSAzMikgcmV0dXJuIHRoaXNcblx0XHRcdG4gLT0gMzJcblx0XHR9XG5cblx0XHR2YXIgaGlnaCA9ICh0aGlzLl9hNDggPDwgMTYpIHwgdGhpcy5fYTMyXG5cdFx0dmFyIGxvdyA9ICh0aGlzLl9hMTYgPDwgMTYpIHwgdGhpcy5fYTAwXG5cblx0XHR2YXIgX2hpZ2ggPSAoaGlnaCA8PCBuKSB8IChsb3cgPj4+ICgzMiAtIG4pKVxuXHRcdHZhciBfbG93ID0gKGxvdyA8PCBuKSB8IChoaWdoID4+PiAoMzIgLSBuKSlcblxuXHRcdHRoaXMuX2EwMCA9IF9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBfbG93ID4+PiAxNlxuXHRcdHRoaXMuX2EzMiA9IF9oaWdoICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gX2hpZ2ggPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIHJpZ2h0XG5cdCAqIEBtZXRob2Qgcm90clxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBVSU5UNjQucHJvdG90eXBlLnJvdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA9PSAwKSByZXR1cm4gdGhpc1xuXHRcdGlmIChuID49IDMyKSB7XG5cdFx0XHQvLyBBLkIuQy5EXG5cdFx0XHQvLyBELkEuQi5DIHJvdHIoMTYpXG5cdFx0XHQvLyBDLkQuQS5CIHJvdHIoMzIpXG5cdFx0XHR2YXIgdiA9IHRoaXMuX2EwMFxuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTMyXG5cdFx0XHR0aGlzLl9hMzIgPSB2XG5cdFx0XHR2ID0gdGhpcy5fYTQ4XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMTZcblx0XHRcdHRoaXMuX2ExNiA9IHZcblx0XHRcdGlmIChuID09IDMyKSByZXR1cm4gdGhpc1xuXHRcdFx0biAtPSAzMlxuXHRcdH1cblxuXHRcdHZhciBoaWdoID0gKHRoaXMuX2E0OCA8PCAxNikgfCB0aGlzLl9hMzJcblx0XHR2YXIgbG93ID0gKHRoaXMuX2ExNiA8PCAxNikgfCB0aGlzLl9hMDBcblxuXHRcdHZhciBfaGlnaCA9IChoaWdoID4+PiBuKSB8IChsb3cgPDwgKDMyIC0gbikpXG5cdFx0dmFyIF9sb3cgPSAobG93ID4+PiBuKSB8IChoaWdoIDw8ICgzMiAtIG4pKVxuXG5cdFx0dGhpcy5fYTAwID0gX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IF9sb3cgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gX2hpZ2ggJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBfaGlnaCA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhlIGN1cnJlbnQgX1VJTlQ2NF9cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGNsb25lZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBVSU5UNjQodGhpcy5fYTAwLCB0aGlzLl9hMTYsIHRoaXMuX2EzMiwgdGhpcy5fYTQ4KVxuXHR9XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRCAvIFJlcXVpcmVKU1xuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFVJTlQ2NFxuXHRcdH0pXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuanNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFVJTlQ2NFxuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRyb290WydVSU5UNjQnXSA9IFVJTlQ2NFxuXHR9XG5cbn0pKHRoaXMpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jdWludC9saWIvdWludDY0LmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2xpY2VkVG9BcnJheTIpO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIik7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Db25zdW1hYmxlQXJyYXkyKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICog5Y2B5a2X6ZO+6KGoXHJcbiAqXHJcbiAqIOW9k+efqemYteeahOmdnumbtuS4quaVsOWSjOS9jee9ruWcqOaTjeS9nOi/h+eoi+S4reWPmOWMluWkp+aXtu+8jOWwseS4jeWunOmHh+eUqOmhuuW6j+WtmOWCqOe7k+aehOadpeihqOekuuS4ieWFg+e7hOeahOe6v+aAp+ihqOOAguS+i+Wmgu+8jOWcqOS9nOKAnOWwhuefqemYtULliqDliLDnn6npmLVB5LiK4oCd55qE5pON5L2c5pe277yM55Sx5LqO6Z2e6Zu25YWD55qE5o+S5YWl5oiW5Yig6Zmk5bCG5Lya5byV6LW3QS5kYXRh5Lit5YWD57Sg55qE56e75Yqo44CC5Li65q2k77yM5a+56L+Z56eN57G75Z6L55qE55+p6Zi177yM6YeH55So6ZO+5byP5a2Y5YKo57uT5p6E6KGo56S65LiJ5YWD57uE55qE57q/5oCn6KGo5pu05Li65oGw5b2T44CCXHJcbiAqXHJcbiAqIOWcqOmTvuihqOS4re+8jOavj+S4qumdnumbtuWFg+WPr+eUqOS4gOS4quWQqzXkuKrln5/nmoTnu5PngrnooajnpLrvvIzlhbbkuK1p77yMauWSjGXov5kz5Liq5Z+f5YiG5Yir6KGo56S66K+l6Z2e6Zu25YWD5omA5Zyo55qE6KGM77yM5YiX5ZKM6Z2e6Zu25YWD55qE5YC877yM5ZCR5Y+z5Z+fcmlnaHTnlKjku6Xpk77mjqXlkIzkuIDooYzkuK3kuIvkuIDkuKrpnZ7pm7blhYPvvIzlkJHkuIvln59kb3du55So5Lul6ZO+5o6l5ZCM5LiA5YiX5Lit5LiL5LiA5Liq6Z2e6Zu25YWD44CC5ZCM5LiA6KGM55qE6Z2e6Zu25YWD6YCa6L+HcmlnaHTln5/pk77mjqXmiJDkuIDkuKrnur/mgKfooajvvIzlkIzkuIDliJfkuK3nmoTpnZ7pm7blhYPpgJrluLhkb3du5Z+f6ZO+5o6l5oiQ5LiA5Liq57q/5oCn6ZO+6KGo77yM5q+P5LiA5Liq6Z2e6Zu25YWD5pei5piv5p+Q5Liq6KGM6ZO+6KGo5Lit55qE5LiA5Liq57uT54K577yM5Y+I5piv5p+Q5Liq5YiX6ZO+6KGo5Lit55qE5LiA5Liq57uT54K577yM5pW05Liq55+p6Zi15p6E5oiQ5LqG5LiA5Liq5Y2B5a2X5Lqk5Y+J55qE6ZO+6KGo44CCXHJcbiAqXHJcbiAqIOWPr+eUqOS4pOS4quWIhuWIq+WtmOWCqOihjOmTvuihqOeahOWktOaMh+mSiOWSjOWIl+mTvuihqOeahOWktOaMh+mSiOeahOS4gOe7tOaVsOe7hOadpeihqOekuuOAglxyXG4gKi9cblxuLy8g56iA55aP55+p6Zi155qE5Y2B5a2X6ZO+6KGo5a2Y5YKo6KGo56S6XG5cbnZhciBPTE5vZGUgPSBmdW5jdGlvbiBPTE5vZGUoKSB7XG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBqID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZSA9IGFyZ3VtZW50c1syXTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBPTE5vZGUpO1xuXG4gICAgLy8g6K+l6Z2e6Zu25YWD55qE6KGM5ZKM5YiX5LiL5qCHXG4gICAgdGhpcy5pID0gaTtcbiAgICB0aGlzLmogPSBqO1xuICAgIHRoaXMuZSA9IGU7XG4gICAgLy8g6K+l6Z2e6Zu25YWD5omA5Zyo6KGM6KGo5ZKM5YiX6KGo55qE5ZCO57un6ZO+5Z+fXG4gICAgdGhpcy5yaWdodCA9IG51bGw7IC8vIHR5cGU6IE9MTm9kZVxuICAgIHRoaXMuZG93biA9IG51bGw7IC8vIHR5cGU6IE9MTm9kZVxufTtcblxudmFyIENyb3NzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDcm9zc0xpc3QoKSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIENyb3NzTGlzdCk7XG5cbiAgICAgICAgLy8g6KGM5ZKM5YiX6ZO+6KGo5aS05oyH6ZKI5ZCR6YeP5Z+65Z2A55SxQ3JlYXRlU01hdHJpeOWIhumFjVxuICAgICAgICB0aGlzLnJoZWFkID0gW107XG4gICAgICAgIHRoaXMuY2hlYWQgPSBbXTtcbiAgICAgICAgLy8g56iA55aP55+p6Zi155qE6KGM5pWw77yM5YiX5pWwXG4gICAgICAgIHRoaXMubXUgPSAwO1xuICAgICAgICB0aGlzLm51ID0gMDtcbiAgICAgICAgdGhpcy50dSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiDnn6npmLXliJ3lp4vljJZcclxuICAgICAqIEBwYXJhbSBtXHJcbiAgICAgKiBAcGFyYW0gblxyXG4gICAgICogQHBhcmFtIHRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3Qg5LqM57u05pWw57uE77yM5q+P6KGM55qE5YWD57Sg5YiG5Yir5pivW2ksIGosIGVdXHJcbiAgICAgKi9cblxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoQ3Jvc3NMaXN0LCBbe1xuICAgICAgICBrZXk6IFwiY3JlYXRlU01hdHJpeFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU01hdHJpeChtLCBuLCB0LCBsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLm11ID0gbTtcbiAgICAgICAgICAgIHRoaXMubnUgPSBuO1xuICAgICAgICAgICAgdGhpcy50dSA9IHQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGxpc3QubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShPTE5vZGUsIFtudWxsXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTMuZGVmYXVsdCkobGlzdFtyb3ddKSkpKSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9saXN0JHJvdyA9ICgwLCBfc2xpY2VkVG9BcnJheTMuZGVmYXVsdCkobGlzdFtyb3ddLCAyKTtcblxuICAgICAgICAgICAgICAgIHZhciBpID0gX2xpc3Qkcm93WzBdO1xuICAgICAgICAgICAgICAgIHZhciBqID0gX2xpc3Qkcm93WzFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHEgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaGVhZFtpXSA9PSBudWxsIHx8IHRoaXMucmhlYWRbaV0uaiA+IGopIHtcbiAgICAgICAgICAgICAgICAgICAgcC5yaWdodCA9IHRoaXMucmhlYWRbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmhlYWRbaV0gPSBwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOafpeivouWcqOihjOihqOS4reeahOaPkuWFpeS9jee9rlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSB0aGlzLnJoZWFkW2ldOyBxLnJpZ2h0ICYmIHEucmlnaHQuaiA8IGo7IHEgPSBxLnJpZ2h0KSB7fVxuICAgICAgICAgICAgICAgICAgICBwLnJpZ2h0ID0gcS5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgcS5yaWdodCA9IHA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlYWRbal0gPT0gbnVsbCB8fCB0aGlzLmNoZWFkW2pdLmkgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuZG93biA9IHRoaXMuY2hlYWRbal07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlYWRbal0gPSBwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IHRoaXMuY2hlYWRbal07IHEuZG93biAmJiBxLmRvd24uaSA8IGk7IHEgPSBxLmRvd24pIHt9XG4gICAgICAgICAgICAgICAgICAgIHAuZG93biA9IHEuZG93bjtcbiAgICAgICAgICAgICAgICAgICAgcS5kb3duID0gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDnn6npmLXnm7jliqBcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFkZE1hdHJpeFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWF0cml4KGNyb3NzTGlzdCkge1xuICAgICAgICAgICAgdmFyIGhsID0gW107XG4gICAgICAgICAgICAvL2hs5Yid5aeL5YyWXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSB0aGlzLm51OyBqKyspIHtcbiAgICAgICAgICAgICAgICBobFtqXSA9IHRoaXMuY2hlYWRbal07XG4gICAgICAgICAgICB9Zm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5tdTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy9wYeWSjHBi5oyH5ZCR5q+P5LiA6KGM55qE56ys5LiA5Liq6Z2eMOWFg+e7k+eCue+8jOebtOiHs+acgOWQjuS4gOihjFxuICAgICAgICAgICAgICAgIHZhciBwYSA9IHRoaXMucmhlYWRbaV07XG4gICAgICAgICAgICAgICAgdmFyIHBiID0gY3Jvc3NMaXN0LnJoZWFkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBwcmUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy/lpITnkIZC55qE5LiA6KGM77yM55u06Iez5pys6KGM5Lit5peg6Z2eMOWFg+e0oOeahOe7k+eCuVxuICAgICAgICAgICAgICAgIHdoaWxlIChwYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIOaWsOaPkuWFpeS4gOS4que7k+eCueWIsHBh55qE5bem5L6nXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGEgfHwgcGEuaiA+IHBiLmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgT0xOb2RlKHBiLmksIHBiLmosIHBiLmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+ihjOihqOeahOaMh+mSiOWPmOWMllxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRoaXMucmhlYWRbcC5pXSA9IHA7ZWxzZSBwcmUucmlnaHQgPSBwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnJpZ2h0ID0gcGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WIl+ihqOeahOaMh+mSiOWPmOWMllxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsW3Aual0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDku45obFtwLmpd5byA5aeL5om+5Yiw5paw57uT54K55Zyo5ZCM5LiA5YiX5Lit55qE5YmN6amx57uT54K577yM5bm26K6paGxbcC5qXeaMh+WQkeWug1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGhsW3Aual07IHEgJiYgcS5pIDwgcC5pOyBxID0gcS5kb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsW3Aual0gPSBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy/lnKjliJfooajkuK3mj5LlhaXmlrDnu5PngrnvvIzmoLnmja7ooYzmlbDliKTmlq3mj5LlhaXliY3pnaLov5jmmK/lkI7pnaJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVhZFtwLmpdIHx8IHRoaXMuY2hlYWRbcC5qXS5pID4gcC5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kb3duID0gdGhpcy5jaGVhZFtwLmpdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlYWRbcC5qXSA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZG93biA9IGhsW3Aual0uZG93bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobFtwLmpdLmRvd24gPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBobFtwLmpdID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBiID0gcGIucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGEuaiA8IHBiLmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZSA9IHBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGEgPSBwYS5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5b2TcGEuaiA9PT0gcGIuauaXtu+8jOWwhkLkuK3lvZPliY3nu5PngrnnmoTlgLzliqDliLBB5Lit5b2T5YmN57uT54K55LiKXG4gICAgICAgICAgICAgICAgICAgICAgICBwYS5lICs9IHBiLmU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5b2TcGEuZSA9PT0gMOaXtu+8jOWIoOmZpOivpee7k+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhLmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDoi6Xml6DliY3pqbHnu5PngrnvvIzlsIbnrKzkuIDkuKrpnZ4w5YWD57uT54K5572u5Li65b2T5YmN57uT54K555qE5ZCO57un57uT54K577yMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5YmN6amx57uT54K555qE5ZCO57un57uT54K55Li65b2T5YmN57uT54K555qE5ZCO57un57uT54K5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRoaXMucmhlYWRbcGEuaV0gPSBwYS5yaWdodDtlbHNlIHByZS5yaWdodCA9IHBhLnJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhID0gcGEucmlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WIl+ihqOeahOaMh+mSiOWPmOWMllxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobFtwLmpdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5LuOaGxbcC5qXeW8gOWni+aJvuWIsOaWsOe7k+eCueWcqOWQjOS4gOWIl+S4reeahOWJjempsee7k+eCue+8jOW5tuiuqWhsW3Aual3mjIflkJHlroNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gaGxbcC5qXTsgcSAmJiBxLmkgPCBwLmk7IHEgPSBxLmRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsW3Aual0gPSBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlYWRbcC5qXSA9PSBwKSB0aGlzLmNoZWFkW3Aual0gPSBobFtwLmpdID0gcC5kb3duO2Vsc2UgaGxbcC5qXS5kb3duID0gcC5kb3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYiA9IHBiLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBDcm9zc0xpc3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENyb3NzTGlzdDtcblxuXG52YXIgbGlzdHMgPSBbWzEsIDQsIDVdLCBbMiwgMiwgLTFdLCBbMSwgMSwgM10sIFszLCAxLCAyXV07XG52YXIgYSA9IG5ldyBDcm9zc0xpc3QoKTtcbmEuY3JlYXRlU01hdHJpeCg0LCA0LCA0LCBsaXN0cyk7XG5jb25zb2xlLmxvZyhhKTtcblxudmFyIGxpc3RzMiA9IFtbMSwgNCwgLTVdLCBbMiwgMywgMV0sIFsxLCAxLCAzXSwgWzMsIDIsIDJdXTtcbnZhciBiID0gbmV3IENyb3NzTGlzdCgpO1xuYi5jcmVhdGVTTWF0cml4KDQsIDQsIDQsIGxpc3RzMik7XG5jb25zb2xlLmxvZyhiKTtcblxuYS5hZGRNYXRyaXgoYik7XG5jb25zb2xlLmxvZyhhKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0FycmF5L0Nyb3NzTGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJMU01hdHJpeCA9IGV4cG9ydHMuVFNNYXRyaXggPSB1bmRlZmluZWQ7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICog57O75pWw55+p6Zi155qE5LiJ5YWD57uE6aG65bqP6KGo5a2Y5YKo6KGo56S6XHJcbiAqL1xuXG52YXIgVHJpcGxlID0gZnVuY3Rpb24gVHJpcGxlKGksIGosIGVsZW0pIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBUcmlwbGUpO1xuXG4gICAgLy8g6K+l6Z2e6Zu25YWD55qE6KGM5LiL5qCH5ZKM5YiX5LiL5qCHXG4gICAgdGhpcy5pID0gaSB8fCAwO1xuICAgIHRoaXMuaiA9IGogfHwgMDtcbiAgICB0aGlzLmUgPSBlbGVtIHx8IG51bGw7XG59O1xuXG52YXIgVFNNYXRyaXggPSBleHBvcnRzLlRTTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRTTWF0cml4KG11LCBudSkge1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBUU01hdHJpeCk7XG5cbiAgICAgICAgLy8g6Z2e6Zu25YWD5LiJ5YWD57uE6KGoXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAvLyDnn6npmLXnmoTooYzmlbDvvIzliJfmlbBcbiAgICAgICAgdGhpcy5tdSA9IG11IHx8IDA7XG4gICAgICAgIHRoaXMubnUgPSBudSB8fCAwO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFRTTWF0cml4LCBbe1xuICAgICAgICBrZXk6ICdhZGRUcmlwbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVHJpcGxlKHRyaXBsZSkge1xuICAgICAgICAgICAgaWYgKHRyaXBsZSBpbnN0YW5jZW9mIFRyaXBsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmlwbGUuaSA+PSB0aGlzLm11KSB0aGlzLm11ID0gdHJpcGxlLmkgKyAxO1xuICAgICAgICAgICAgICAgIGlmICh0cmlwbGUuaiA+PSB0aGlzLm51KSB0aGlzLm51ID0gdHJpcGxlLmogKyAxO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2godHJpcGxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyDph4fnlKjkuInlhYPnu4TooajlrZjlgqjooajnpLrvvIzmsYLnqIDnlo/nn6npmLXnmoTovaznva7nn6npmLV0XG4gICAgICAgIC8vIOaMieeFp2IuZGF0YeS4reS4ieWFg+e7hOeahOasoeW6j+S+neasoeWcqGEuZGF0YeS4reaJvuWIsOebuOW6lOeahOS4ieWFg+e7hOi/m+ihjOi9rOe9rlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0cmFuc3Bvc2VTTWF0cml4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zcG9zZVNNYXRyaXgoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG5ldyBUU01hdHJpeCgpO1xuICAgICAgICAgICAgdC5tdSA9IHRoaXMubnU7XG4gICAgICAgICAgICB0Lm51ID0gdGhpcy5tdTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5udTsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0aGlzLmRhdGEubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbcF0uaiA9PT0gY29sKSB0LmRhdGFbcSsrXSA9IG5ldyBUcmlwbGUodGhpcy5kYXRhW3BdLmosIHRoaXMuZGF0YVtwXS5pLCB0aGlzLmRhdGFbcF0uZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICAgIC8vIOmHh+eUqOS4ieWFg+e7hOihqOWtmOWCqOihqOekuu+8jOaxgueogOeWj+efqemYteeahOi9rOe9ruefqemYtXRcbiAgICAgICAgLypcclxuICAgICAgICAg5oyJ54WnYS5kYXRh5Lit5LiJ5YWD57uE55qE5qyh5bqP6L+b6KGM6L2s572u77yM5bm25bCG6L2s572u5ZCO55qE5LiJ5YWD57uE572u5YWlYuS4reaBsOW9k+eahOS9jee9ruOAglxyXG4gICAgICAgICDlpoLmnpzog73pooTlhYjnoa7lrprnn6npmLVN5Lit5q+P5LiA5YiX77yI5Y2zVOS4reavj+S4gOihjO+8ieeahOesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reW6lOacieeahOS9jee9ru+8jFxyXG4gICAgICAgICDpgqPkuYjlnKjlr7lhLmRhdGHkuK3nmoTkuInlhYPnu4Tkvp3mrKHlgZrovaznva7ml7bvvIzkvr/lj6/nm7TmjqXmlL7liLBiLmRhdGHkuK3mgbDlvZPnmoTkvY3nva7kuIrljrvjgIJcclxuICAgICAgICAg5Li65LqG5YW26aKd5a6a6L+Z5Lqb5L2N572u77yM5Zyo6L2s572u5YmN77yM5bqU5YWI5rGC5b6XTeeahOavj+S4gOWIl+S4remdnumbtuWFg+eahOS4quaVsO+8jOi/m+iAjOaxguW+l+avj+S4gOWIl+eahOesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reW6lOacieeahOS9jee9ruOAglxyXG4gICAgICAgICDlnKjmraTvvIzpnIDopoHorr5udW3lkoxjcG905Lik5Liq5Y+Y6YeP44CCbnVtW2NvbF3ooajnpLrnn6npmLVN5Lit56ysY29s5YiX5Lit6Z2e6Zu25YWD55qE5Liq5pWw77yMXHJcbiAgICAgICAgIGNwb3RbY29sXeaMh+ekuk3kuK3nrKxjb2zliJfnmoTnrKzkuIDkuKrpnZ7pm7blhYPlnKhiLmRhdGHkuK3nmoTmgbDlvZPkvY3nva7jgILmmL7nhLbmnInvvJpcclxuICAgICAgICAgY3BvdFswXSA9IDE7XHJcbiAgICAgICAgIGNwb3RbY29sXSA9IGNwb3RbY29sIC0gMV0gKyBudW1bY29sIC0gMV0gICAgMiA8PSBjb2wgPD0gYS5udVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmYXN0VHJhbnNwb3NlU01hdHJpeCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmYXN0VHJhbnNwb3NlU01hdHJpeCgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbmV3IFRTTWF0cml4KCk7XG4gICAgICAgICAgICB0Lm11ID0gdGhpcy5udTtcbiAgICAgICAgICAgIHQubnUgPSB0aGlzLm11O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLm51OyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBudW1bY29sXSA9IDA7XG4gICAgICAgICAgICAgICAgfWZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtW3RoaXMuZGF0YVtpXS5qXTtcbiAgICAgICAgICAgICAgICB9IC8vIOaxguefqemYteS4reavj+S4gOWIl+WQq+mdnumbtuWFg+S4quaVsFxuICAgICAgICAgICAgICAgIC8vIOaxguesrGNvbOWIl+S4reesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reeahOW6j+WPt1xuICAgICAgICAgICAgICAgIHZhciBjcG90ID0gWzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jb2wgPSAxOyBfY29sIDwgdGhpcy5udTsgX2NvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOS4iuS4gOWIl+S5i+WJjeeahOW6j+WPtyvkuIrkuIDliJfnmoTpnZ7pm7blhYPkuKrmlbAgPSDor6XliJfnmoTluo/lj7dcbiAgICAgICAgICAgICAgICAgICAgY3BvdFtfY29sXSA9IGNwb3RbX2NvbCAtIDFdICsgbnVtW19jb2wgLSAxXTtcbiAgICAgICAgICAgICAgICB9Zm9yICh2YXIgcCA9IDA7IHAgPCB0aGlzLmRhdGEubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jb2wyID0gdGhpcy5kYXRhW3BdLmo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gY3BvdFtfY29sMl07XG4gICAgICAgICAgICAgICAgICAgIHQuZGF0YVtxXSA9IG5ldyBUcmlwbGUodGhpcy5kYXRhW3BdLmosIHRoaXMuZGF0YVtwXS5pLCB0aGlzLmRhdGFbcF0uZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOe7meivpeWIl+eahOW6j+WPtysx77yM55So5L2c55u45ZCM5YiX5pWw55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgICAgICsrY3BvdFtfY29sMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gVFNNYXRyaXg7XG59KCk7XG5cbnZhciBhMSA9IG5ldyBUcmlwbGUoMSwgMiwgMTIpO1xudmFyIGEyID0gbmV3IFRyaXBsZSgxLCAzLCA5KTtcbnZhciBhMyA9IG5ldyBUcmlwbGUoMywgMSwgLTMpO1xudmFyIGE0ID0gbmV3IFRyaXBsZSgzLCA2LCAxNCk7XG52YXIgYTUgPSBuZXcgVHJpcGxlKDQsIDMsIDI0KTtcbnZhciBhNiA9IG5ldyBUcmlwbGUoNSwgMiwgMTgpO1xudmFyIGE3ID0gbmV3IFRyaXBsZSg2LCAxLCAxNSk7XG52YXIgYTggPSBuZXcgVHJpcGxlKDYsIDQsIC03KTtcblxudmFyIG1hdHJpeCA9IG5ldyBUU01hdHJpeCgpO1xubWF0cml4LmFkZFRyaXBsZShhMSk7XG5tYXRyaXguYWRkVHJpcGxlKGEyKTtcbm1hdHJpeC5hZGRUcmlwbGUoYTMpO1xubWF0cml4LmFkZFRyaXBsZShhNCk7XG5tYXRyaXguYWRkVHJpcGxlKGE1KTtcbm1hdHJpeC5hZGRUcmlwbGUoYTYpO1xubWF0cml4LmFkZFRyaXBsZShhNyk7XG5tYXRyaXguYWRkVHJpcGxlKGE4KTtcblxuY29uc29sZS5sb2cobWF0cml4LnRyYW5zcG9zZVNNYXRyaXgoKSk7XG5jb25zb2xlLmxvZyhtYXRyaXguZmFzdFRyYW5zcG9zZVNNYXRyaXgoKSk7XG5cbi8qXHJcbiDkuInlhYPnu4Tpobrluo/ooajlj4jnp7DmnInluo/nmoTlj4zkuIvmoIfms5XvvIzlroPnmoTnibnngrnmmK/vvIzpnZ7pm7blhYPlnKjooajkuK3mjInooYzluo/mnInluo/lrZjlgqjvvIzlm6DmraTkvr/kuo7ov5vooYzkvp3ooYzpobrluo/lpITnkIbnmoTnn6npmLXov5DnrpfjgIJcclxuIOeEtuiAjO+8jOiLpemcgOaMieihjOWPt+WtmOWPluafkOS4gOihjOeahOmdnumbtuWFg++8jOWImeS7juWktOW8gOWni+i/m+ihjOafpeaJvuOAglxyXG4gKi9cblxuLyoqXHJcbiAqIOihjOmAu+i+kemTvuaOpeeahOmhuuW6j+ihqFxyXG4gKlxyXG4gKiDkuLrkuobkvr/kuo7pmo/mnLrlrZjlj5bku7vmhI/kuIDooYznmoTpnZ7pm7blhYPvvIzliJnpnIDnn6XpgZPmr4/kuIDooYznmoTnrKzkuIDkuKrpnZ7pm7blhYPlnKjkuInlhYPnu4TooajkuK3nmoTkvY3nva7jgIJcclxuICog5Li65q2k5Y+v5bCG5b+r6YCf6L2s572u55+p6Zi155qE566X5rOV5Lit5Yib5bu655qE77yM5oyH56S64oCc6KGM4oCd5L+h5oGv55qE6L6F5Yqp5pWw57uEY3BvdOWbuuWumuWcqOeogOeWj+efqemYteeahOWtmOWCqOe7k+aehOS4reOAglxyXG4gKiDnp7Dov5nnp43igJzluKbooYzpk77mjqXkv6Hmga/igJ3nmoTkuInlhYPnu4TooajkuLrooYzpgLvovpHpk77mjqXnmoTpobrluo/ooahcclxuICovXG5cbnZhciBSTFNNYXRyaXggPSBleHBvcnRzLlJMU01hdHJpeCA9IGZ1bmN0aW9uIChfVFNNYXRyaXgpIHtcbiAgICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShSTFNNYXRyaXgsIF9UU01hdHJpeCk7XG5cbiAgICBmdW5jdGlvbiBSTFNNYXRyaXgoKSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFJMU01hdHJpeCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShSTFNNYXRyaXgpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgICAgIF90aGlzLnJwb3MgPSBbMF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiDmsYLnn6npmLXkuZjnp69RID0gTSAqIE7vvIzph4fnlKjooYzpgLvovpHpk77mjqXlrZjlgqjooajnpLpcclxuICAgICAqIEBwYXJhbSBuTWF0cml4XHJcbiAgICAgKiBAcmV0dXJucyB7UkxTTWF0cml4fVxyXG4gICAgICovXG5cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFJMU01hdHJpeCwgW3tcbiAgICAgICAga2V5OiAnbXVsdFNNYXRyaXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdFNNYXRyaXgobk1hdHJpeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubnUgIT09IG5NYXRyaXgubXUpIHRocm93IEVycm9yKCdudSBpcyBub3QgZXF1aXZhbGVudCB0byBtdScpO1xuXG4gICAgICAgICAgICAvLyDliJ3lp4vljJZRXG4gICAgICAgICAgICB2YXIgcU1hdHJpeCA9IG5ldyBSTFNNYXRyaXgodGhpcy5tdSwgbk1hdHJpeC5udSk7XG4gICAgICAgICAgICAvLyBR5piv6Z2e6Zu255+p6Zi1XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCAqIG5NYXRyaXguZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyDlpITnkIZN55qE5q+P5LiA6KGMXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXJvdyA9IDA7IGFyb3cgPCB0aGlzLm11OyBhcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN6KGM5ZCE5YWD57Sg57Sv5Yqg5Zmo5riF6Zu2XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBxTWF0cml4LnJwb3NbYXJvd10gPSBxTWF0cml4LmRhdGEubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRwID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2NvbCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJvdyA8IHRoaXMubXUpIHRwID0gdGhpcy5ycG9zW2Fyb3cgKyAxXTtlbHNlIHRwID0gdGhpcy5kYXRhLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy/lr7nlvZPliY3ooYzkuK3mr4/kuIDkuKrpnZ7pm7blhYPmib7liLDlr7nlupTlhYPlnKhO5Lit55qE6KGM5Y+3XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSB0aGlzLnJwb3NbYXJvd107IHAgPCB0cDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJvdyA9IHRoaXMuZGF0YVtwXS5qO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJvdyA8IG5NYXRyaXgubXUpIHQgPSBuTWF0cml4LnJwb3NbYnJvdyArIDFdO2Vsc2UgdCA9IG5NYXRyaXguZGF0YS5sZW5ndGggKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gbk1hdHJpeC5ycG9zW2Jyb3ddOyBxIDwgdDsgcSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5LmY56ev5YWD57Sg5ZyoUeS4reeahOW6j+WPt1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjb2wgPSBuTWF0cml4LmRhdGFbcV0uajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGVtcFtjY29sXSA9IChjdGVtcFtjY29sXSB8fCAwKSArIHRoaXMuZGF0YVtwXS5lICogbk1hdHJpeC5kYXRhW3FdLmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyDljovnvKnlrZjlgqjor6XooYzpnZ7pm7blhYNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjY29sID0gMTsgY2NvbCA8IHFNYXRyaXgubnU7IGNjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0ZW1wW2Njb2xdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrcU1hdHJpeC5kYXRhLmxlbmd0aCA+IFJMU01hdHJpeC5NQVhTSVpFKSB0aHJvdyBFcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxTWF0cml4LmRhdGFbcU1hdHJpeC5kYXRhLmxlbmd0aCAtIDFdID0gbmV3IFRyaXBsZShhcm93LCBjY29sLCBjdGVtcFtjY29sXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBxTWF0cml4O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfY2FsY1BvcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY1BvcygpIHtcbiAgICAgICAgICAgIHZhciBudW0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMubnU7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgbnVtW2NvbF0gPSAwO1xuICAgICAgICAgICAgfWZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgKytudW1bdGhpcy5kYXRhW2ldLmpdO1xuICAgICAgICAgICAgfSAvLyDmsYLnn6npmLXkuK3mr4/kuIDliJflkKvpnZ7pm7blhYPkuKrmlbBcbiAgICAgICAgICAgIC8vIOaxguesrGNvbOWIl+S4reesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reeahOW6j+WPt1xuICAgICAgICAgICAgZm9yICh2YXIgX2NvbDMgPSAxOyBfY29sMyA8IHRoaXMubnU7IF9jb2wzKyspIHtcbiAgICAgICAgICAgICAgICAvLyDkuIrkuIDliJfkuYvliY3nmoTluo/lj7cr5LiK5LiA5YiX55qE6Z2e6Zu25YWD5Liq5pWwID0g6K+l5YiX55qE5bqP5Y+3XG4gICAgICAgICAgICAgICAgdGhpcy5ycG9zW19jb2wzXSA9IHRoaXMucnBvc1tfY29sMyAtIDFdICsgbnVtW19jb2wzIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFJMU01hdHJpeDtcbn0oVFNNYXRyaXgpO1xuXG5STFNNYXRyaXguTUFYU0laRSA9IDEwMDtcblxudmFyIGIxID0gbmV3IFRyaXBsZSgxLCAxLCAzKTtcbnZhciBiMiA9IG5ldyBUcmlwbGUoMSwgMywgNSk7XG52YXIgYjMgPSBuZXcgVHJpcGxlKDIsIDIsIC0xKTtcbnZhciBiNCA9IG5ldyBUcmlwbGUoMywgMSwgMik7XG5cbnZhciB0MSA9IG5ldyBSTFNNYXRyaXgoKTtcbnQxLmFkZFRyaXBsZShiMSk7XG50MS5hZGRUcmlwbGUoYjIpO1xudDEuYWRkVHJpcGxlKGIzKTtcbnQxLmFkZFRyaXBsZShiNCk7XG50MS5fY2FsY1BvcygpO1xuXG52YXIgYzEgPSBuZXcgVHJpcGxlKDEsIDIsIDIpO1xudmFyIGMyID0gbmV3IFRyaXBsZSgyLCAxLCAxKTtcbnZhciBjMyA9IG5ldyBUcmlwbGUoMywgMSwgLTIpO1xudmFyIGM0ID0gbmV3IFRyaXBsZSgzLCAyLCA0KTtcblxudmFyIHQyID0gbmV3IFJMU01hdHJpeCgpO1xudDIuYWRkVHJpcGxlKGMxKTtcbnQyLmFkZFRyaXBsZShjMik7XG50Mi5hZGRUcmlwbGUoYzMpO1xudDIuYWRkVHJpcGxlKGM0KTtcbnQyLl9jYWxjUG9zKCk7XG5cbnQxLm11bHRTTWF0cml4KHQyKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0FycmF5L1RTTWF0cml4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGh1ZmZNYW5Db2Rpbmc7XG4vKipcclxuICog6LWr5aSr5pu877yISHVmZm1hbu+8ieagke+8jOWPiOensOacgOS8mOagke+8jOaYr+S4gOexu+W4puadg+i3r+W+hOmVv+W6puacgOefreeahOagke+8jOacieedgOW5v+azm+W6lOeUqOOAglxyXG4gKlxyXG4gKiDku47moJHkuK3kuIDkuKrnu5PngrnliLDlj6bkuIDkuKrnu5PngrnkuYvpl7TnmoTliIbmlK/mnoTmiJDov5nkuKTkuKrnu5PngrnkuYvpl7TnmoTot6/lvoTvvIzot6/lvoTkuIrnmoTliIbmlK/mlbDnm67np7DkvZzot6/lvoTplb/luqbjgIJcclxuICog5qCR55qE6Lev5b6E6ZW/5bqm5piv5LuO5qCR5qC55Yiw5q+P5LiA5Liq57uT54K555qE6Lev5b6E5LmL5ZKM44CCXHJcbiAqIOe7k+eCueeahOW4puadg+i3r+W+hOmVv+W6puS4uuS7juivpee7k+eCueWIsOagkeagueS5i+mXtOeahOi3r+W+hOmVv+W6puS4jue7k+eCueS4iuadg+eahOS5mOenr+OAguagkeeahOW4puadg+i3r+W+hOmVv+W6puS4uuagkeS4reaJgOacieWPtuWtkOe7k+eCueeahOW4puadg+i3r+W+hOmVv+W6puS5i+WSjOOAglxyXG4gKlxyXG4gKiDmnoTpgKDotavlpKvmm7zmoJHnmoTmraXpqqTvvJpcclxuICog77yIMe+8ieagueaNrue7meWumueahG7kuKrmnYPlgLx7dzEsdzIsLi4ud2595p6E5oiQbuajteS6jOWPieagkeeahOmbhuWQiEYgPSB7VDEsVDIsLi4uVG5977yM5YW25Lit5q+P5qO15LqM5Y+J5qCRVGnkuK3lj6rmnInkuIDkuKrluKbmnYPkuLp3aeeahOaguee7k+eCue+8jOWFtuW3puWPs+WtkOagkeWdh+epuuOAglxyXG4gKiDvvIgy77yJ5ZyoRuS4remAieWPluS4pOajteaguee7k+eCueeahOadg+WAvOacgOWwj+eahOagkeS9nOS4uuW3puWPs+WtkOagkeaehOmAoOS4gOajteaWsOeahOS6jOWPieagke+8jOS4lOe9ruaWsOeahOS6jOWPieagkeeahOaguee7k+eCueeahOadg+WAvOS4uuWFtuW3puWPs+WtkOagkeS4iuaguee7k+eCueeahOadg+WAvOS5i+WSjOOAglxyXG4gKiDvvIgz77yJ5ZyoRuS4reWIoOmZpOi/meS4pOajteagke+8jOWQjOaXtuWwhuaWsOW+l+WIsOeahOS6jOWPieagkeWKoOWFpUbkuK3jgIJcclxuICog77yINO+8iemHjeWkje+8iDLvvInlkozvvIgz77yJ77yM55u05YiwRuWPquWQq+S4gOajteagkeS4uuatouOAgui/meajteagkeS+v+aYr+i1q+Wkq+abvOagkeOAglxyXG4gKi9cbi8qXHJcbui1q+Wkq+abvOe8lueggVxyXG5odHRwOi8vemgud2lraXBlZGlhLm9yZy93aWtpLyVFOSU5QyU4RCVFNSVBNCVBQiVFNiU5QiVCQyVFNyVCQyU5NiVFNyVBMCU4MVxyXG5cclxu5YGH6K6+55S15oql6ZyA5Lyg6YCB55qE55S15paH5Li64oCcQSBCIEEgQyBDIEQgQeKAne+8jOWug+WPquaciTTnp43lrZfnrKblj6rpnIDkuKTkuKrlrZfnrKbkuLLkvr/lj6/liIbovqjjgILlgYforr5BLEIsQyxE55qE57yW56CB5YiG5Yir5Li6MDAsMDEsMTDlkowxMe+8jOWImeS4iui/sDfkuKrlrZfnrKbnmoTnlLXmlofkvr/kuLrigJwwMDAxMDAxMDEwMTEwMOKAne+8jOWvueaWueaOpeaUtuaXtu+8jOWPr+aMieS6jOS9jeS4gOWIhui/m+ihjOivkeeggeOAglxyXG7lnKjkvKDpgIHnlLXmlofml7bvvIzluIzmnJvmgLvplb/lsL3lj6/og73lnLDnn63jgILlpoLmnpzlr7nmr4/kuKrlrZfnrKborr7orqHplb/luqbkuI3nrYnnmoTnvJbnoIHvvIzkuJTorqnnlLXmlofkuK3lh7rnjrDmrKHmlbDovoPlpJrnmoTlrZfnrKbph4fnlKjlsL3lj6/og73nn63nmoTnvJbnoIHvvIzliJnkvKDpgIHnlLXmlofnmoTmgLvplb/kvr/lj6/lh4/lsJHjgIJcclxu5aaC5p6c5raJ5Y+KQSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAsMDAsMeWSjDAx77yM5YiZ5LiK6L+wN+S4quWtl+espueahOeUteaWh+WPr+i9rOaNouaIkOaAu+mVv+S4ujnnmoTlrZfnrKbkuLLigJwwMDAwMTEwMTDigJ3jgILkvYbmmK/vvIzov5nmoLfnmoTnlLXmlofml6Dms5Xnv7vor5HvvIzlm6DkuLrlj6/mnInlpJrnp43or5Hms5XjgIJcclxu5Zug5q2k77yM6Iul6KaB6K6+6K6h6ZW/55+t5LiN562J55qE57yW56CB77yM5YiZ5b+F6aG75piv5Lu75oSP5Liq5a2X56ym55qE57yW56CB6YO95LiN5piv5Y+m5LiA5Liq5a2X56ym57yW56CB55qE5YmN57yA77yM6L+Z56eN57yW56CB56ew5L2c5YmN57yA57yW56CB44CCXHJcbuWPr+WIqeeUqOS6jOWPieagkeadpeiuvuiuoeS6jOi/m+WItueahOWJjee8gOe8lueggeOAguWBh+iuvuacieS4gOajteS6jOWPieagke+8jOWFtjTkuKrlj7blrZDnu5PngrnliIbliKvooajnpLpBLEIsQyxE6L+ZNOS4quWtl+espu+8jOS4lOe6puWumuW3puWIhuaUr+ihqOekuuWtl+espuKAnDDigJ3vvIzlj7PliIbmlK/ooajnpLrlrZfnrKbigJwx4oCd77yM5YiZ5Y+v5Lul5LuO5qC557uT54K55Yiw5Y+25a2Q57uT54K555qE6Lev5b6E5LiK5YiG5pSv5a2X56ym57uE5oiQ55qE5a2X56ym5Liy5L2c5Li66K+l5Y+25a2Q57uT54K55a2X56ym55qE57yW56CB44CC5omA5b6X5LqM6L+b5Yi25YmN57yA57yW56CB5YiG5Yir5Li6MCwxMCwxMTAsMTExLlxyXG7orr7orqHnlLXmlofmgLvplb/mnIDnn63nmoTkuozov5vliLbliY3nvIDnvJbnoIHljbPku6Vu56eN5a2X56ym5Ye6546w55qE6aKR546H5L2c5p2D44CCXHJcbiAqL1xuXG4vLyDotavlpKvmm7zmoJHlkozotavlpKvmm7znvJbnoIHnmoTlrZjlgqjnu5PmnoRcbmZ1bmN0aW9uIEh1ZmZtYW5Ob2RlKHdlaWdodCwgcGFyZW50LCBsZWZ0Q2hpbGQsIHJpZ2h0Q2hpbGQpIHtcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodCB8fCAwO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IDA7XG4gICAgdGhpcy5sZWZ0Q2hpbGQgPSBsZWZ0Q2hpbGQgfHwgMDtcbiAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkIHx8IDA7XG59XG5mdW5jdGlvbiBodWZmTWFuQ29kaW5nKHdlaWdodHMpIHtcbiAgICB2YXIgbiA9IHdlaWdodHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMSkgcmV0dXJuO1xuXG4gICAgdmFyIGh1ZmZtYW5UcmVlID0gYnVpbGRIdWZmbWFuVHJlZSh3ZWlnaHRzLCBuKTtcblxuICAgIC8vIOS7juWPtuWtkOWIsOaguemAhuWQkeaxguavj+S4quWtl+espueahOi1q+Wkq+abvOe8lueggVxuICAgIHZhciBoYyA9IGNhbGNIdWZmbWFuQ29kZShodWZmbWFuVHJlZSwgbik7XG5cbiAgICByZXR1cm4gW2h1ZmZtYW5UcmVlLCBoY107XG59XG5cbmZ1bmN0aW9uIGNhbGNIdWZmbWFuQ29kZShodWZmbWFuVHJlZSwgbikge1xuICAgIC8vIOS7juWPtuWtkOWIsOaguemAhuWQkeaxguavj+S4quWtl+espueahOi1q+Wkq+abvOe8lueggVxuICAgIHZhciBoYyA9IFtdO1xuICAgIHZhciBjZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG4gLSAxO1xuICAgICAgICBmb3IgKHZhciBjID0gaSwgZiA9IGh1ZmZtYW5UcmVlW2ldLnBhcmVudDsgZiAhPSAwOyBjID0gZiwgZiA9IGh1ZmZtYW5UcmVlW2ZdLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGh1ZmZtYW5UcmVlW2ZdLmxlZnRDaGlsZCA9PSBjKSBjZFstLXN0YXJ0XSA9ICcwJztlbHNlIGNkWy0tc3RhcnRdID0gJzEnO1xuICAgICAgICB9XG5cbiAgICAgICAgaGNbaV0gPSBzdHJDb3B5KGNkLCBzdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhjO1xufVxuXG4vLyDliJvlu7rkuIDmo7Xlj7blrZDnu5PngrnmlbDkuLpu55qESHVmZm1hbuagkVxuZnVuY3Rpb24gYnVpbGRIdWZmbWFuVHJlZSh3ZWlnaHRzLCBuKSB7XG4gICAgbiA9IG4gfHwgd2VpZ2h0cy5sZW5ndGg7XG4gICAgdmFyIG0gPSAyICogbiAtIDE7XG4gICAgdmFyIGh1ZmZtYW5UcmVlID0gW107XG5cbiAgICAvLyDliJ3lp4vljJZcbiAgICB2YXIgaSA9IHZvaWQgMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldID0gbmV3IEh1ZmZtYW5Ob2RlKHdlaWdodHNbaV0sIDAsIDAsIDApO1xuICAgIH1mb3IgKDsgaSA8IG07IGkrKykge1xuICAgICAgICBodWZmbWFuVHJlZVtpXSA9IG5ldyBIdWZmbWFuTm9kZSgwLCAwLCAwLCAwKTtcbiAgICB9Zm9yICh2YXIgX2kgPSBuOyBfaSA8IG07IF9pKyspIHtcbiAgICAgICAgLy8g5ZyoSFRbMS4uaS0xXemAieaLqXBhcmVudOS4ujDkuJR3ZWlnaHTmnIDlsI/nmoTkuKTkuKrnu5PngrnvvIzov5Tlm57lhbbluo/lj7fkuLpbczEsIHMyXVxuICAgICAgICB2YXIgcmV0ID0gc2VsZWN0KGh1ZmZtYW5UcmVlLCBfaSk7XG4gICAgICAgIHZhciBzMSA9IHJldFswXTtcbiAgICAgICAgdmFyIHMyID0gcmV0WzFdO1xuICAgICAgICBodWZmbWFuVHJlZVtzMV0ucGFyZW50ID0gX2k7XG4gICAgICAgIGh1ZmZtYW5UcmVlW3MyXS5wYXJlbnQgPSBfaTtcbiAgICAgICAgaHVmZm1hblRyZWVbX2ldLmxlZnRDaGlsZCA9IHMxO1xuICAgICAgICBodWZmbWFuVHJlZVtfaV0ucmlnaHRDaGlsZCA9IHMyO1xuICAgICAgICBodWZmbWFuVHJlZVtfaV0ud2VpZ2h0ID0gaHVmZm1hblRyZWVbczFdLndlaWdodCArIGh1ZmZtYW5UcmVlW3MyXS53ZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1ZmZtYW5UcmVlO1xufVxuXG5mdW5jdGlvbiBzdHJDb3B5KHN0ciwgc3RhcnQpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAoOyBzdHJbc3RhcnRdOyBzdGFydCsrKSB7XG4gICAgICAgIHMgKz0gc3RyW3N0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdChodWZmbWFuVHJlZSwgbGVuKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBodWZmbWFuVHJlZVtpXTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSAwKSBjb250aW51ZTtcblxuICAgICAgICBpZiAocmV0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaHVmZm1hblRyZWVbcmV0WzBdXS53ZWlnaHQgPiBodWZmbWFuVHJlZVtyZXRbMV1dLndlaWdodCA/IDAgOiAxO1xuXG4gICAgICAgICAgICBpZiAobm9kZS53ZWlnaHQgPCBodWZmbWFuVHJlZVtyZXRbaW5kZXhdXS53ZWlnaHQpIHJldFtpbmRleF0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJldFswXSA+IHJldFsxXSkge1xuICAgICAgICB2YXIgdGVtcCA9IHJldFswXTtcbiAgICAgICAgcmV0WzBdID0gcmV0WzFdO1xuICAgICAgICByZXRbMV0gPSB0ZW1wO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNvbnNvbGUubG9nKCctLS0tLS0taHVmZm1hbiBjb2RpbmcgMTotLS0tLS0nKTtcbmNvbnNvbGUubG9nKGh1ZmZNYW5Db2RpbmcoWzUsIDI5LCA3LCA4LCAxNCwgMjMsIDMsIDExXSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvQmluYXJ5VHJlZS9odWZmTWFuQ29kaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbCcpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX1F1ZXVlID0gcmVxdWlyZSgnLi4vUXVldWUvUXVldWUuanMnKTtcblxudmFyIF9RdWV1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9RdWV1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiDlub/kuYnooahcclxuICpcclxuICog5bm/5LmJ6KGo5piv57q/5oCn6KGo55qE5o6o5bm/44CC5bm/5rOb55So5LqO5Lq65bel5pm66IO955qE6KGo5aSE55CG6K+t6KiATGlzcO+8jOaKiuW5v+S5ieihqOS9nOS4uuWfuuacrOeahOaVsOaNrue7k+aehOOAglxyXG4gKiDlub/kuYnooajkuIDoiKzorrDkvZzvvJpcclxuICogICAgICBMUyA9IChhMSwgYTIsIC4uLiwgYW4pXHJcbiAqIExT5piv5bm/5LmJ6KGo55qE5ZCN56ew77yMbuaYr+Wug+eahOmVv+W6pu+8jGFp5Y+v5Lul5piv5Y2V5Liq5YWD57Sg77yM5Lmf5Y+v5Lul5piv5bm/5LmJ6KGo77yM5YiG5Yir56ew5Li65bm/5LmJ6KGoTFPnmoTljp/lrZDlkozlrZDooajjgILkuaDmg6/kuIrvvIznlKjlpKflhpnlrZfmr43ooajnpLrlub/kuYnooajnmoTlkI3np7DvvIzlsI/lhpnlrZfmr43ooajnpLrljp/lrZDjgILlvZPlub/kuYnooahMU+mdnuepuuaXtu+8jOensOesrOS4gOS4quWFg+e0oGEx5Li6TFPnmoTooajlpLTvvIznp7DlhbbkvZnlhYPntKDnu4TmiJDnmoTooagoYTIsIGEzLCAuLi4sIGFuKeaYr0xT55qE6KGo5bC+44CCXHJcbiAqXHJcbiAqIOS4i+mdouWIl+S4vuS4gOS6m+W5v+S5ieihqOeahOS+i+WtkO+8mlxyXG4gKiAxLkEgPSAoKSAtLS0tIEHmmK/kuIDkuKrnqbrooajvvIzlroPnmoTplb/luqbkuLow44CCXHJcbiAqIDIuQiA9IChlKSAtLS0tIOWIl+ihqELlj6rmnInkuIDkuKrljp/lrZBl77yMQueahOmVv+W6puS4ujHjgIJcclxuICogMy5DID0gKGEsIChiLCBjLCBkKSkgLS0tLSDliJfooahD55qE6ZW/5bqm5Li6Mu+8jOS4pOS4quWFg+e0oOWIhuWIq+S4uuWOn+WtkGHlkozlrZDooagoYiwgYywgZCnjgIJcclxuICogNC5EID0gKEEsIEIsIEMpIC0tLS0g5YiX6KGoROeahOmVv+W6puS4ujMsM+S4quWFg+e0oOmDveaYr+WIl+ihqOOAguaYvuekuu+8jOWwhuWtkOihqOeahOWAvOS7o+WFpeWQju+8jOWImeaciUQgPSAoKCksIChlKSwgKGEsIChiLCBjLCBkKSkp44CCXHJcbiAqIDUuRSA9IChhLCBFKSAtLS0tIOi/meaYr+S4gOS4qumAkuW9kueahOihqO+8jOWug+eahOmVv+W6puS4ujIuReebuOW9k+S6juS4gOS4quaXoOmZkOeahOWIl+ihqEUgPSAoYSwgKGEsIChhLCAuLi4pKSnjgIJcclxuICpcclxuICogMe+8ieWIl+ihqOeahOWFg+e0oOWPr+S7peaYr+WtkOihqO+8jOiAjOWtkOihqOeahOWFg+e0oOi/mOWPr+S7peaYr+WtkOihqOOAgueUseatpO+8jOWIl+ihqOaYr+S4gOS4quWkmuWxguasoeeahOe7k+aehO+8jOWPr+S7peeUqOWbvuW9ouixoeWcsOihqOekuuOAglxyXG4gKiAyKeWIl+ihqOWPr+S4uuWFtuWug+WIl+ihqOaJgOWFseS6q+OAguWIl+ihqEHvvIxC5ZKMQ+S4ukTnmoTlrZDooajvvIzliJnlnKhE5Lit5Y+v5Lul5LiN5b+F5YiX5Ye65a2Q6KGo55qE5YC844CCXHJcbiAqIDPvvInliJfooajlj6/ku6XmmK/kuIDkuKrpgJLlvZLnmoTooajvvIzljbPliJfooajkuZ/lj6/ku6XmmK/lhbbmnKzouqvnmoTkuIDkuKrlrZDooajjgILkvovlpoLliJfooahF44CCXHJcbiAqXHJcbiAqIOS7u+S9leS4gOS4qumdnuepuuWIl+ihqOWFtuihqOWktOWPr+iDveaYr+WOn+WtkO+8jOS5n+WPr+iDveaYr+WIl+ihqO+8jOiAjOWFtuihqOWwvuW/heWumuS4uuWIl+ihqOOAglxyXG4gKlxyXG4gKi9cblxuLypcclxuIOW5v+S5ieihqOeahOmAkuW9kueul+azlVxyXG5cclxuIOmAkuW9kuWumuS5ieeahOW9kue6s+mhueaPj+i/sOS6huWmguS9leWunueOsOS7juW9k+WJjeeKtuaAgeWIsOe7iOe7k+eKtuaAgeeahOi9rOWMluOAglxyXG5cclxuIOeUseS6jumAkuW9kuWHveaVsOeahOiuvuiuoeeUqOeahOaYr+W9kue6s+aAnee7tOeahOaWueazle+8jOWImeWcqOiuvuiuoemAkuW9kuWHveaVsOaXtu+8jOW6lOazqOaEj++8mlxyXG4g77yIMe+8iemmluWFiOW6lOS5puWGmeWHveaVsOeahOmmlumDqOWSjOinhOagvOivtOaYju+8jOS4peagvOWumuS5ieWHveaVsOeahOWKn+iDveWSjOaOpeWPo++8iOmAkuW9kuiwg+eUqOeahOeVjOmdou+8ie+8jOWvueaxgueyvuWHveaVsOS4reaJgOW+l+eahOWSjOWOn+mXrumimOaAp+i0qOebuOWQjOeahOWtl+mXrumimO+8jOWPquimgeaOpeWPo+S4gOiHtO+8jOS+v+WPr+i/m+ihjOmAkuW9kuiwg+eUqOOAglxyXG4g77yIMu+8ieWvueWHveaVsOS4reeahOavj+S4gOS4qumAkuW9kuiwg+eUqOmDveeci+aIkOWPquaYr+S4gOS4queugOWNleeahOaTjeS9nO+8jOWPquimgeaOpeWPo+S4gOiHtO+8jOW/heiDveWunueOsOinhOagvOivtOaYjuS4reWumuS5ieeahOWKn+iDve+8jOWIh+W/jOaDs+W+l+Wkqua3seWkqui/nOOAglxyXG4gKi9cblxuLypcclxuIOaxguW5v+S5ieihqOeahOa3seW6plxyXG5cclxuIOW5v+S5ieihqOeahOa3seW6puWumuS5ieS4uuW5v+S5ieihqOS4reaLrOW8p+eahOmHjeaVsO+8jOaYr+W5v+S5ieihqOeahOS4gOenjemHj+W6puOAglxyXG4g6K6+6Z2e56m65bm/5LmJ6KGo5Li6OlxyXG4gTFMgPSAoYTEsIGEyLCAuLi4sIGFuKVxyXG5cclxuIOWFtuS4rWFpKGkgPSAxLCAyLCAuLi4sIG4p5oiW5Li65Y6f5a2Q5oiW5Li6TFPnmoTlrZDooajvvIzliJnmsYJMU+eahOa3seW6puWPr+WIhuino+S4um7kuKrlrZDpl67popjvvIzmr4/kuKrlrZDpl67popjkuLrmsYJhaeeahOa3seW6pu+8jOiLpWFp5piv5Y6f5a2Q77yM5YiZ55Sx5a6a5LmJ5YW25rex5bqm5Li66Zu277yM6IulYWnmmK/lub/kuYnooajvvIzliJnpgJLlvZLlpITnkIbvvIzogIxMU+eahOa3seW6puS4uuWQhGFpKGkgPSAxLCAyLCAuLi4sIG4p55qE5rex5bqm5pyA5aSn5YC85YqgMS7nqbrooajkuZ/mmK/lub/kuYnooajvvIzkuJTmt7HluqbkuLoxLlxyXG5cclxuIOW5v+S5ieihqOeahOa3seW6pkRFUFRIKExTKeeahOmAkuW9kuWumuS5ieS4uu+8mlxyXG4g5Z+65pys6aG577yaICAgIERFUFRIKExTKSA9IDEgICDlvZNMU+S4uuepuuihqOaXtlxyXG4gREVQVEgoTFMpID0gMCAgIOW9k0xT5Li65Y6f5a2Q5pe2XHJcbiDlvZLnurPpobnvvJogICAgREVQVEgoTFMpID0gMSArIE1BWHtERVBUSChhaSl9ICAxIDw9IGkgPD0gblxyXG4gKi9cblxudmFyIEFUT00gPSAoMCwgX3N5bWJvbDIuZGVmYXVsdCkoKTtcbnZhciBMSVNUID0gKDAsIF9zeW1ib2wyLmRlZmF1bHQpKCk7XG5cbnZhciBnbG9iYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLy8g5L2/55So6ZO+6Zif5YiXXG5cblxuLy8g5bm/5LmJ6KGo55qE5aS05bC+6ZO+6KGo5a2Y5YKo6KGo56S6XG5cbnZhciBHTE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR0xOb2RlKCkge1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBHTE5vZGUpO1xuXG4gICAgICAgIC8vIOWFrOWFsemDqOWIhu+8jOeUqOS6juWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBhdG9t5piv5Y6f5a2Q57uT54K555qE5YC85Z+fXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XG4gICAgICAgIC8vIHB0cuaYr+ihqOe7k+eCueeahOaMh+mSiOWfn1xuICAgICAgICB0aGlzLnB0ciA9IHtcbiAgICAgICAgICAgIC8vIHB0ci5ocOWSjHB0ci50cOWIhuWIq+aMh+WQkeihqOWktOWSjOihqOWwvlxuICAgICAgICAgICAgaHA6IG51bGwsXG4gICAgICAgICAgICB0cDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIOmHh+eUqOWktOWwvumTvuihqOWtmOWCqOe7k+aehO+8jOaxguW5v+S5ieihqOeahOa3seW6plxuXG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShHTE5vZGUsIFt7XG4gICAgICAgIGtleTogJ2RlcHRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldERlcHRoKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5aSN5Yi25bm/5LmJ6KGoXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvcHlMaXN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlMaXN0KGdMaXN0KSB7XG4gICAgICAgICAgICBnTGlzdC50YWcgPSB0aGlzLnRhZztcblxuICAgICAgICAgICAgaWYgKHRoaXMudGFnID09PSBBVE9NKSB7XG4gICAgICAgICAgICAgICAgZ0xpc3QuYXRvbSA9IHRoaXMuYXRvbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyLmhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdMaXN0LnB0ci5ocCA9IG5ldyBHTE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuaHAuY29weUxpc3QoZ0xpc3QucHRyLmhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyLnRwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdMaXN0LnB0ci50cCA9IG5ldyBHTE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHAuY29weUxpc3QoZ0xpc3QucHRyLnRwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDph4fnlKjlpLTlsL7pk77ooajlrZjlgqjnu5PmnoTvvIznlLHlub/kuYnooajnmoTkuablhpnlvaLlvI/kuLLliJvlu7rlub/kuYnooahcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JlYXRlR0xpc3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlR0xpc3Qoc3RyaW5nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuXG4gICAgICAgICAgICAvLyDliJvlu7rljZXljp/lrZDlub/kuYnooahcbiAgICAgICAgICAgIHZhciBxID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGlzV29yZChzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWcgPSBBVE9NO1xuICAgICAgICAgICAgICAgIHRoaXMuYXRvbSA9IHN0cmluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWcgPSBMSVNUO1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcztcblxuICAgICAgICAgICAgICAgIC8vIOiEseWkluWxguaLrOWPt1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBzdHJpbmcuc3Vic3RyKDEsIHN0cmluZy5sZW5ndGggLSAyKTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhzdWIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gc3ViLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHN1YltpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09ICcoJykgKytrO2Vsc2UgaWYgKGNoID09ICcpJykgLS1rO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgbiAmJiAoY2ggIT0gJywnIHx8IGsgIT0gMCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGnkuLrnrKzkuIDkuKrpgJflj7fliIbpmpTntKLlvJVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoc3ViID0gc3ViLnN1YnN0cigwLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWIuc3Vic3RyKGksIG4gLSBpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5pyA5ZCO5LiA57uEXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHN1YiA9IHN1YjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaHN1YiA9PT0gJygpJykgcC5wdHIuaHAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyDliJvlu7rooajlpLTnu5PngrlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5wdHIuaHAgPSBuZXcgR0xOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5wdHIuaHAuY3JlYXRlR0xpc3QoaHN1Yik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcSA9IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8g5Yib5bu66KGo5bC+57uT54K5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgR0xOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnRhZyA9IExJU1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnB0ci50cCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzdWIpO1xuXG4gICAgICAgICAgICAgICAgcS5wdHIudHAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXZlcnNlJyxcblxuXG4gICAgICAgIC8vIOmAkuW9kumAhui9rOW5v+S5ieihqFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgICAgICAgIHZhciBwdHIgPSBbXTtcbiAgICAgICAgICAgIC8vIOW9k0HkuI3kuLrljp/lrZDkuJTooajlsL7pnZ7nqbrml7bmiY3pnIDpgIbovaxcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZyA9PT0gTElTVCAmJiB0aGlzLnB0ci50cCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwLCBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YCG6L2s5ZCE5a2Q6KGoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnB0ci5ocCkgcC5wdHIuaHAucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHB0cltpXSA9IHAucHRyLmhwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOmHjeaWsOaMiemAhuW6j+aOkuWIl+WQhOWtkOihqOeahOmhuuW6j1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9wID0gdGhpczsgX3A7IF9wID0gX3AucHRyLnRwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wLnB0ci5ocCA9IHB0clstLWldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcyA9PSBnbG9iYWwgfHwgdGhpcyA9PSBudWxsKSBzdHIgPSAnKCknO2Vsc2UgaWYgKHRoaXMudGFnID09PSBBVE9NKSBzdHIgPSB0aGlzLmF0b207IC8vIOWOn+WtkFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnKCc7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMudG9TdHJpbmcuY2FsbChwLnB0ci5ocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5wdHIudHApIHN0ciArPSAnLCAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnKSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5oyJ5bGC5bqP6L6T5Ye65bm/5LmJ6KGoXG4gICAgICAgIC8vIOWxguW6j+mBjeWOhueahOmXrumimO+8jOS4gOiIrOmDveaYr+WAn+WKqemYn+WIl+adpeWujOaIkOeahO+8jOavj+asoeS7jumYn+WktFxuICAgICAgICAvLyDlj5blh7rkuIDkuKrlhYPntKDnmoTlkIzml7bmiorlroPkuIvkuIDlsYLnmoTlranlrZDmj5LlhaXpmJ/lsL7vvIzov5nmmK/lsYLluo/pgY3ljobnmoTln7rmnKzmgJ3mg7NcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb3JkZXJQcmludCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcmRlclByaW50KCkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChwKTtcbiAgICAgICAgICAgIH13aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyLnRhZyA9PT0gQVRPTSkgY29uc29sZS5sb2coci5hdG9tKTtlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyID0gci5wdHIuaHA7IHI7IHIgPSByLnB0ci50cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb3JkZXJQcmludDInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3JkZXJQcmludDIoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBuZXcgX1F1ZXVlMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHApO1xuICAgICAgICAgICAgfXdoaWxlIChxdWV1ZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHIudGFnID09PSBBVE9NKSBjb25zb2xlLmxvZyhyLmF0b20pO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHIgPSByLnB0ci5ocDsgcjsgciA9IHIucHRyLnRwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2VxdWFsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFsKGdMaXN0MSwgZ0xpc3QyKSB7XG4gICAgICAgICAgICAvLyDnqbrooajml7bnm7jnrYnnmoRcbiAgICAgICAgICAgIGlmICghZ0xpc3QxICYmICFnTGlzdDIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGdMaXN0MS50YWcgPT09IEFUT00gJiYgZ0xpc3QyLnRhZyA9PT0gQVRPTSAmJiBnTGlzdDEuYXRvbSA9PT0gZ0xpc3QyLmF0b20pIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoZ0xpc3QxLnRhZyA9PT0gTElTVCAmJiBnTGlzdDIudGFnID09PSBMSVNUKSB7XG4gICAgICAgICAgICAgICAgLy8g6KGo5aS06KGo5bC+6YO955u4562JXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwoZ0xpc3QxLnB0ci5ocCwgZ0xpc3QyLnB0ci5ocCkgJiYgdGhpcy5lcXVhbChnTGlzdDEucHRyLnRwLCBnTGlzdDIucHRyLnRwKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gR0xOb2RlO1xufSgpO1xuXG4vLyDlub/kuYnooajnmoTmianlsZXnur/mgKfpk77ooajlrZjlgqjooajnpLpcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBHTE5vZGU7XG5cbnZhciBHTE5vZGUyID0gZnVuY3Rpb24gR0xOb2RlMigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBHTE5vZGUyKTtcblxuICAgIC8vIOWFrOWFsemDqOWIhu+8jOeUqOS6juWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xuXG4gICAgLy8g5Y6f5a2Q57uT54K555qE5YC85Z+fXG4gICAgdGhpcy5hdG9tID0gbnVsbDtcbiAgICAvLyDooajnu5PngrnnmoTooajlpLTmjIfpkohcbiAgICB0aGlzLmhwID0gbnVsbDtcblxuICAgIC8vIOebuOW9k+S6jue6v+aAp+mTvuihqOeahG5leHTvvIzmjIflkJHkuIvkuIDkuKrlhYPntKDnu5PngrlcbiAgICB0aGlzLnRwID0gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGdldERlcHRoKGdMaXN0KSB7XG4gICAgaWYgKCFnTGlzdCkgcmV0dXJuIDE7ZWxzZSBpZiAoZ0xpc3QudGFnID09PSBBVE9NKSByZXR1cm4gMDtcblxuICAgIHZhciBtID0gZ2V0RGVwdGgoZ0xpc3QucHRyLmhwKSArIDE7XG4gICAgdmFyIG4gPSBnZXREZXB0aChnTGlzdC5wdHIudHApO1xuXG4gICAgcmV0dXJuIG0gPiBuID8gbSA6IG47XG59XG5cbmZ1bmN0aW9uIGlzV29yZChzdHIpIHtcbiAgICByZXR1cm4gKC9eW1xcdy1dKyQvLnRlc3Qoc3RyKVxuICAgICk7XG59XG5cbi8qXHJcbiBt5YWD5aSa6aG55byP6KGo56S6XHJcblxyXG4g5aaC5p6c55So57q/5oCn6KGo5p2l6KGo56S6LOWImeavj+S4quaVsOaNruWFg+e0oOmcgOimgW0rMeS4quaVsOaNrumhue+8jOS7peWtmOWCqOS4gOS4quezu+aVsOWSjG3kuKrmjIfmlbDlgLzvvIzov5nlsIbkuqfnlJ/kuKTkuKrpl67popjjgIJcclxuIOS4gOaYr+aXoOiuuuWkmumhueW8j+S4reWQhOmhueeahOWPmOWFg+aVsOaYr+WkmuaYr+Wwke+8jOiLpemDveaMiW3kuKrlj5jlhYPliIbphY3lrZjlgqjnqbrpl7TvvIzliJnlsIbpgKDmiJDmtarotLnvvJvlj43kuYvvvIzoi6XmjInlkITpobnlrp7pmYXnmoTlj5jlhYPmlbDliIbphY3lrZjlgqjnqbrpl7TvvIzlsLHkvJrpgKDmiJDnu5PngrnnmoTlpKflsI/kuI3ljIDvvIznu5nmk43kvZzluKbmnaXkuI3kvr/jgILkuozmmK/lr7lt5YC85LiN5ZCM55qE5aSa6aG55byP77yM57q/5oCn6KGo5Lit55qE57uT54K55aSn5bCP5Lmf5LiN5ZCM77yM6L+Z5ZCM5qC35byV6LW35a2Y5YKo566h55CG55qE5LiN5L6/44CCXHJcbiDmlYXkuI3pgILkuo7nlKjnur/mgKfooajooajnpLrjgIJcclxuXHJcbiDkvovlpoLkuInlhYPlpJrpobnlvI/vvJpcclxuIFAoeCwgeSwgeikgPSB4KDEwKXkoMyl6KDIpICsgMngoNil5KDMpeigyKSArIDN4KDUpeSgyKXooMikgKyB4KDQpeSg0KXogKyAyeXogKyAxNVxyXG5cclxuIOWmguiLpeaUueWGmeS4uu+8mlxyXG4gUCh4LCB5LCB6KSA9ICgoeCgxMCkgKyAyeCg2KSl5KDMpICsgM3goNSl5KDIpKXooMikgKyAoKHgoNCkgKyA2eCgzKSl5KDQpICsgMnkpeiArIDE1XHJcblxyXG4g55So5bm/5LmJ6KGo6KGo56S677yaXHJcbiBQID0geigoQSwgMiksIChCLCAxKSwgKDE1LCAwKSlcclxuIEEgPSB5KChDLCAzKSwgKEQsIDIpKVxyXG4gQiA9IHkoKEUsIDQpLCAoRiwgMSkpXHJcbiBDID0geCgoMSwgMTApLCAoMiwgNikpXHJcbiBEID0geCgoMywgNSkpXHJcbiBFID0geCgoMSwgNCksICg2LCAzKSlcclxuIEYgPSB4KCgyLCAwKSlcclxuXHJcblxyXG4gKi9cblxuZnVuY3Rpb24gTVBOb2RlKCkge1xuICAgIC8vIOWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xuICAgIC8vIOaMh+aVsOWfn1xuICAgIHRoaXMuZXhwID0gMDtcblxuICAgIC8vIOezu+aVsOWfn1xuICAgIHRoaXMuY29lZiA9IDA7XG4gICAgLy8g6KGo57uT54K555qE6KGo5aS05oyH6ZKIXG4gICAgdGhpcy5ocCA9IG51bGw7XG5cbiAgICAvLyDnm7jlvZPkuo7nur/mgKfooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XG4gICAgdGhpcy50cCA9IG51bGw7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9HZW5lcmFsaXplZExpc3QvR0xpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcclxuIOmCu+aOpeWkmumHjeihqFxyXG5cclxuIOmCu+aOpeWkmumHjeihqChBZGphY2VuY3kgTXVsdGlsaXN0KeaYr+aXoOWQkeWbvueahOWPpuS4gOenjemTvuW8j+WtmOWCqOe7k+aehOOAglxyXG5cclxuIOmCu+aOpeihqOaYr+aXoOWQkeWbvueahOS4gOenjeacieaViOeahOWtmOWCqOe7k+aehO+8jOWcqOaXoOWQkeWbvueahOmCu+aOpeihqOS4re+8jOS4gOadoei+uSh2LHcp55qE5Lik5Liq6KGo57uT54K55YiG5Yir5Yid6YCJ5Zyo5LulduWSjHfkuLrlpLTnu5PngrnnmoTpk77ooajkuK3vvIzlvojlrrnmmJPmsYLlvpfpobbngrnlkozovrnnmoTkv6Hmga/vvIzkvYblnKjmtonlj4rliLDovrnnmoTmk43kvZzkvJrluKbmnaXkuI3kvr/jgIJcclxuXHJcbiDpgrvmjqXlpJrph43ooajnmoTnu5PmnoTlkozljYHlrZfpk77ooajnsbvkvLzvvIzmr4/mnaHovrnnlKjkuIDkuKrnu5PngrnooajnpLrvvJvpgrvmjqXlpJrph43ooajkuK3nmoTpobbngrnnu5Pngrnnu5PmnoTkuI7pgrvmjqXooajkuK3nmoTlrozlhajnm7jlkIzvvIzogIzooajnu5PngrnljIXmi6zlha3kuKrln5/jgIJcclxuXHJcbiDil4YgIERhdGHln5/vvJrlrZjlgqjlkozpobbngrnnm7jlhbPnmoTkv6Hmga/vvJtcclxuIOKXhiDmjIfpkojln59maXJzdGVkZ2XvvJrmjIflkJHkvp3pmYTkuo7or6XpobbngrnnmoTnrKzkuIDmnaHovrnmiYDlr7nlupTnmoTooajnu5PngrnvvJtcclxuIOKXhiDmoIflv5fln59tYXJr77ya55So5Lul5qCH6K+G6K+l5p2h6L655piv5ZCm6KKr6K6/6Zeu6L+H77ybXHJcbiDil4YgaXZleOWSjGp2ZXjln5/vvJrliIbliKvkv53lrZjor6XovrnmiYDkvp3pmYTnmoTkuKTkuKrpobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcclxuIOKXhiBpbmZv5Z+f77ya5L+d5a2Y6K+l6L6555qE55u45YWz5L+h5oGv77ybXHJcbiDil4Yg5oyH6ZKI5Z+faWxpbmvvvJrmjIflkJHkuIvkuIDmnaHkvp3pmYTkuo7pobbngrlpdmV455qE6L6577ybXHJcbiDil4Yg5oyH6ZKI5Z+famxpbmvvvJrmjIflkJHkuIvkuIDmnaHkvp3pmYTkuo7pobbngrlqdmV455qE6L6577ybXHJcblxyXG4g6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo55qE5Yy65Yir77yaXHJcbiDlkI7ogIXnmoTlkIzkuIDmnaHovrnnlKjkuKTkuKrooajnu5PngrnooajnpLrvvIzogIzliY3ogIXlj6rnlKjkuIDkuKrooajnu5PngrnooajnpLrvvJvpmaTmoIflv5fln5/lpJbvvIzpgrvmjqXlpJrph43ooajkuI7pgrvmjqXooajooajovr7nmoTkv6Hmga/mmK/nm7jlkIznmoTvvIzlm6DmraTvvIzmk43kvZznmoTlrp7njrDkuZ/ln7rmnKznm7jkvLzjgIJcclxuXHJcbiAqL1xuXG52YXIgVU5WSVNJVEVEID0gMDtcbnZhciBWSVNJVEVEID0gMTtcblxudmFyIEVCb3ggPVxuLyoqXHJcbiAqIOi+ueeahOe7k+eCueihqOekulxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWFyayDorr/pl67moIforrAgMCAtLSDmnKrorr/pl64gIDEgPT0g5bey6K6/6ZeuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxyXG4gKiBAcGFyYW0ge051bWJlcn0ganZleCDor6Xovrnkvp3pmYTnmoTkuKTkuKrpobbngrnnmoTkvY3nva5cclxuICogQHBhcmFtIHtFQm94fSBpbGluayDliIbliKvmjIflkJHkvp3pmYTov5nkuKTkuKrpobbngrnnmoTkuIvkuIDmnaHovrlcclxuICogQHBhcmFtIHtFQm94fSBqbGluayDliIbliKvmjIflkJHkvp3pmYTov5nkuKTkuKrpobbngrnnmoTkuIvkuIDmnaHovrlcclxuICogQHBhcmFtIHsqfSBpbmZvIOivpei+ueS/oeaBr1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5mdW5jdGlvbiBFQm94KG1hcmssIGl2ZXgsIGp2ZXgsIGlsaW5rLCBqbGluaywgaW5mbykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEVCb3gpO1xuXG4gICAgdGhpcy5tYXJrID0gbWFyayB8fCBVTlZJU0lURUQ7XG4gICAgdGhpcy5pdmV4ID0gaXZleCB8fCAwO1xuICAgIHRoaXMuanZleCA9IGp2ZXggfHwgMDtcbiAgICB0aGlzLmlsaW5rID0gaWxpbmsgfHwgbnVsbDtcbiAgICB0aGlzLmpsaW5rID0gamxpbmsgfHwgbnVsbDtcbiAgICB0aGlzLmluZm8gPSBpbmZvIHx8IG51bGw7XG59O1xuXG52YXIgQU1MVmV4Qm94ID1cbi8qKlxyXG4gKiDpobbngrnnmoTnu5PngrnooajnpLpcclxuICogQHBhcmFtIHsqfSBkYXRhXHJcbiAqIEBwYXJhbSB7RUJveH0gZmlyc3RFZGdlIOaMh+WQkeesrOS4gOadoeS+nemZhOivpemhtueCueeahOi+uVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5mdW5jdGlvbiBBTUxWZXhCb3goZGF0YSwgZmlyc3RFZGdlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQU1MVmV4Qm94KTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbnVsbDtcbiAgICB0aGlzLmZpcnN0RWRnZSA9IGZpcnN0RWRnZSB8fCBudWxsO1xufTtcblxudmFyIEFNTEdyYXBoID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBBTUxWZXhCb3h9IGFkak11bGlzdFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2VudW1cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBTUxHcmFwaChhZGpNdWxpc3QsIHZleG51bSwgZWRnZW51bSkge1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBBTUxHcmFwaCk7XG5cbiAgICAgICAgdGhpcy5hZGpNdWxpc3QgPSBhZGpNdWxpc3QgfHwgW107XG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtIHx8IDA7XG4gICAgICAgIHRoaXMuZWRnZW51bSA9IGVkZ2VudW0gfHwgMDtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShBTUxHcmFwaCwgW3tcbiAgICAgICAga2V5OiAnbG9jYXRlVmV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2F0ZVZleCh2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3RbaV0uZGF0YSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlbGV0ZUFyYycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBcmModiwgdykge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgodyk7XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggbm90IGZvdW5kIScpO1xuXG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIC8vIOWcqGnpk77ooajkuK3liKDpmaTor6XovrlcbiAgICAgICAgICAgIGlmICh0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UuanZleCA9PT0gaikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZS5pbGluaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlOyBwICYmIHAuaWxpbmsuanZleCAhPT0gajsgcCA9IHAuaWxpbmspIHt9XG4gICAgICAgICAgICAgICAgaWYgKCFwKSB0aHJvdyBuZXcgRXJyb3IoJ2VkZ2Ugbm90IGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIHAuaWxpbmsgPSBwLmlsaW5rLmlsaW5rO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlnKhq6ZO+6KGo5Lit5Yig6Zmk6K+l6L65XG4gICAgICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlLml2ZXggPT09IGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UgPSB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2Uuamxpbms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZTsgcCAmJiBwLmpsaW5rLml2ZXggIT09IGk7IHAgPSBwLmpsaW5rKSB7fVxuICAgICAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgICAgICBwLmpsaW5rID0gcC5qbGluay5qbGluaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lZGdlbnVtLS07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JlYXRlR3JhcGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlR3JhcGgoKSB7XG4gICAgICAgICAgICB2YXIgdmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcbiAgICAgICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xuICAgICAgICAgICAgdmFyIGVkZ2VudW0gPSArcHJvbXB0KCdlZGdlbnVtOiAnKTtcbiAgICAgICAgICAgIHRoaXMuZWRnZW51bSA9IGVkZ2VudW07XG5cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdmV4bnVtOyArK20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFttXSA9IG5ldyBBTUxWZXhCb3gocHJvbXB0KCdkYXRhOiAnKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBlZGdlbnVtOyArK20pIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHByb21wdCgndGFpbFZleDogJyk7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBwcm9tcHQoJ2hlYWRWZXg6ICcpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5sb2NhdGVWZXgodCk7XG4gICAgICAgICAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleChoKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kISBUcnkgYWdhaW46Jyk7XG4gICAgICAgICAgICAgICAgICAgIG0tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgRUJveCgwLCBpLCBqLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB2YXIgcSwgcjtcblxuICAgICAgICAgICAgICAgIC8vIOaPkuWFpWnpk77ooajlsL7pg6hcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UgPSBwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHEgPSB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2U7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLml2ZXggPT09IGkpIHEgPSBxLmlsaW5rO2Vsc2UgcSA9IHEuamxpbms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuaXZleCA9PT0gaSkgci5pbGluayA9IHA7ZWxzZSByLmpsaW5rID0gcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDmj5LlhaVq6ZO+6KGo5bC+6YOoXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlID0gcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5qdmV4ID09PSBqKSBxID0gcS5qbGluaztlbHNlIHEgPSBxLmlsaW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmp2ZXggPT09IGopIHIuamxpbmsgPSBwO2Vsc2Ugci5pbGluayA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBBTUxHcmFwaDtcbn0oKTtcblxuLy92YXIgZyA9IG5ldyBBTUxHcmFwaCgpO1xuLy9nLmNyZWF0ZUdyYXBoKCk7XG4vL2NvbnNvbGUubG9nKGcpO1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFNTEdyYXBoO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvR3JhcGgvQU1MR3JhcGguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoJy4uL1N0YWNrL2luZGV4Jyk7XG5cbnZhciBfaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgpO1xuXG52YXIgX1F1ZXVlID0gcmVxdWlyZSgnLi4vUXVldWUvUXVldWUnKTtcblxudmFyIF9RdWV1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9RdWV1ZSk7XG5cbnZhciBfQmluYXJ5VHJlZSA9IHJlcXVpcmUoJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyDlm77nmoTmlbDnu4TvvIjpgrvmjqXnn6npmLXvvInlrZjlgqjooajnpLpcbnZhciBERyA9IDE7IC8vIOacieWQkeWbvlxuLyogQ3JlYXRlIEJ5IEx1a2UgKi9cblxudmFyIEROID0gMjsgLy8g5pyJ5ZCR572RXG52YXIgVURHID0gMzsgLy8g5peg5ZCR5Zu+XG52YXIgVUROID0gNDsgLy8g5peg5ZCR572RXG5cbi8qXHJcbiDpgrvmjqXpk77ooajms5VcclxuXHJcbiDln7rmnKzmgJ3mg7PvvJrlr7nlm77nmoTmr4/kuKrpobbngrnlu7rnq4vkuIDkuKrljZXpk77ooajvvIzlrZjlgqjor6XpobbngrnmiYDmnInpgrvmjqXpobbngrnlj4rlhbbnm7jlhbPkv6Hmga/jgILmr4/kuIDkuKrljZXpk77ooajorr7kuIDkuKrooajlpLTnu5PngrnjgIJcclxuXHJcbiDnrKxp5Liq5Y2V6ZO+6KGo6KGo56S65L6d6ZmE5LqO6aG254K5VmnnmoTovrko5a+55pyJ5ZCR5Zu+5piv5Lul6aG254K5VmnkuLrlpLTmiJblsL7nmoTlvKcp44CCXHJcblxyXG4gMSAg57uT54K557uT5p6E5LiO6YK75o6l6ZO+6KGo56S65L6LXHJcblxyXG4g6ZO+6KGo5Lit55qE57uT54K556ew5Li66KGo57uT54K577yM5q+P5Liq57uT54K555Sx5LiJ5Liq5Z+f57uE5oiQ44CC5YW25Lit6YK75o6l54K55Z+fKGFkanZleCnmjIfnpLrkuI7pobbngrlWaemCu+aOpeeahOmhtueCueWcqOWbvuS4reeahOS9jee9rijpobbngrnnvJblj7cp77yM6ZO+5Z+fKG5leHRhcmMp5oyH5ZCR5LiL5LiA5Liq5LiO6aG254K5VmnpgrvmjqXnmoTooajnu5PngrnvvIzmlbDmja7ln58oaW5mbynlrZjlgqjlkozovrnmiJblvKfnm7jlhbPnmoTkv6Hmga/vvIzlpoLmnYPlgLznrYnjgILlr7nkuo7ml6DmnYPlm77vvIzlpoLmnpzmsqHmnInkuI7ovrnnm7jlhbPnmoTlhbbku5bkv6Hmga/vvIzlj6/nnIHnlaXmraTln5/jgIJcclxuXHJcbiDmr4/kuKrpk77ooajorr7kuIDkuKrooajlpLTnu5Pngrko56ew5Li66aG254K557uT54K5Ke+8jOeUseS4pOS4quWfn+e7hOaIkOOAgumTvuWfnyhmaXJzdGFyYynmjIflkJHpk77ooajkuK3nmoTnrKzkuIDkuKrnu5PngrnvvIzmlbDmja7ln58oZGF0YSkg5a2Y5YKo6aG254K55ZCN5oiW5YW25LuW5L+h5oGv44CCXHJcblxyXG4g5Zyo5Zu+55qE6YK75o6l6ZO+6KGo6KGo56S65Lit77yM5omA5pyJ6aG254K557uT54K555So5LiA5Liq5ZCR6YePIOS7pemhuuW6j+e7k+aehOW9ouW8j+WtmOWCqO+8jOWPr+S7pemaj+acuuiuv+mXruS7u+aEj+mhtueCueeahOmTvuihqO+8jOivpeWQkemHj+ensOS4uuihqOWktOWQkemHj++8jOWQkemHj+eahOS4i+agh+aMh+ekuumhtueCueeahOW6j+WPt+OAglxyXG5cclxuIOeUqOmCu+aOpemTvuihqOWtmOWCqOWbvuaXtu+8jOWvueaXoOWQkeWbvu+8jOWFtumCu+aOpemTvuihqOaYr+WUr+S4gOeahO+8m+WvueacieWQkeWbvu+8jOWFtumCu+aOpemTvuihqOacieS4pOenjeW9ouW8j+OAglxyXG5cclxuXHJcbiAyICDpgrvmjqXooajms5XnmoTnibnngrlcclxuXHJcbiDil4Yg6KGo5aS05ZCR6YeP5Lit5q+P5Liq5YiG6YeP5bCx5piv5LiA5Liq5Y2V6ZO+6KGo55qE5aS057uT54K577yM5YiG6YeP5Liq5pWw5bCx5piv5Zu+5Lit55qE6aG254K55pWw55uu77ybXHJcbiDil4Yg5Zyo6L655oiW5byn56iA55aP55qE5p2h5Lu25LiL77yM55So6YK75o6l6KGo6KGo56S65q+U55So6YK75o6l55+p6Zi16KGo56S66IqC55yB5a2Y5YKo56m66Ze077ybXHJcbiDil4Yg5Zyo5peg5ZCR5Zu+77yM6aG254K5VmnnmoTluqbmmK/nrKxp5Liq6ZO+6KGo55qE57uT54K55pWw77ybXHJcbiDil4Yg5a+55pyJ5ZCR5Zu+5Y+v5Lul5bu656uL5q2j6YK75o6l6KGo5oiW6YCG6YK75o6l6KGo44CC5q2j6YK75o6l6KGo5piv5Lul6aG254K5VmnkuLrlh7rluqYo5Y2z5Li65byn55qE6LW354K5KeiAjOW7uueri+eahOmCu+aOpeihqO+8m+mAhumCu+aOpeihqOaYr+S7pemhtueCuVZp5Li65YWl5bqmKOWNs+S4uuW8p+eahOe7iOeCuSnogIzlu7rnq4vnmoTpgrvmjqXooajvvJtcclxuIOKXhiDlnKjmnInlkJHlm77kuK3vvIznrKxp5Liq6ZO+6KGo5Lit55qE57uT54K55pWw5piv6aG254K5VmnnmoTlh7ogKOaIluWFpSnluqbvvJvmsYLlhaUgKOaIluWHuinluqbvvIzpobvpgY3ljobmlbTkuKrpgrvmjqXooajvvJtcclxuIOKXhiDlnKjpgrvmjqXooajkuIrlrrnmmJPmib7lh7rku7vkuIDpobbngrnnmoTnrKzkuIDkuKrpgrvmjqXngrnlkozkuIvkuIDkuKrpgrvmjqXngrnvvJtcclxuXHJcbiAqL1xuXG52YXIgQXJjTm9kZSA9XG4vKipcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFkalZleFxyXG4gKiBAcGFyYW0ge0FyY05vZGV9IG5leHRBcmNcclxuICogQHBhcmFtIHsqfSBpbmZvXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cbmZ1bmN0aW9uIEFyY05vZGUoKSB7XG4gICAgdmFyIGFkalZleCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5leHRBcmMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBpbmZvID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBBcmNOb2RlKTtcblxuICAgIC8vIOivpeW8p+aJgOaMh+WQkeeahOmhtueCueeahOS9jee9rlxuICAgIHRoaXMuYWRqVmV4ID0gYWRqVmV4O1xuICAgIC8vIOaMh+WQkeS4i+S4gOadoeW8p+eahOaMh+mSiFxuICAgIHRoaXMubmV4dEFyYyA9IG5leHRBcmM7XG4gICAgLy8g6K+l5byn55u45YWz5L+h5oGv55qE5oyH6ZKIXG4gICAgdGhpcy5pbmZvID0gaW5mbztcbn07XG5cbnZhciBWZXhOb2RlID1cbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGRhdGFcclxuICogQHBhcmFtIHtBcmNOb2RlfSBmaXJzdEFyY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZWdyZWVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xuZnVuY3Rpb24gVmV4Tm9kZShkYXRhKSB7XG4gICAgdmFyIGZpcnN0QXJjID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaW5kZWdyZWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzJdO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFZleE5vZGUpO1xuXG4gICAgLy8g6aG254K55L+h5oGvXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyDmjIflkJHnrKzkuIDmnaHkvp3pmYTor6XpobbngrnnmoTlvKfnmoTmjIfpkohcbiAgICB0aGlzLmZpcnN0QXJjID0gZmlyc3RBcmM7XG4gICAgLy8gIOmhtueCueeahOW6piwg5pyJ5ZCR5Zu+5piv5YWl5bqm5oiW5Ye65bqm5oiW5rKh5pyJXG4gICAgdGhpcy5pbmRlZ3JlZSA9IGluZGVncmVlO1xufTtcblxudmFyIEFkamFjZW5jeUxpc3RHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgVmV4Tm9kZX0gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBraW5kXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQWRqYWNlbmN5TGlzdEdyYXBoKCkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHZleG51bSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBhcmNudW0gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IERHIDogYXJndW1lbnRzWzNdO1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBBZGphY2VuY3lMaXN0R3JhcGgpO1xuXG4gICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWw5ZKM5byn5pWwXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xuICAgICAgICB0aGlzLmFyY251bSA9IGFyY251bTtcbiAgICAgICAgLy8g5Zu+55qE56eN57G75qCH5b+XXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuXG4gICAgLy8g5p+l5om+6aG254K55L2N572uXG5cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKEFkamFjZW5jeUxpc3RHcmFwaCwgW3tcbiAgICAgICAga2V5OiAnbG9jYXRlVmV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2F0ZVZleCh2cCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMudmV4bnVtOyArK19pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbX2ldLmRhdGEgPT09IHZwKSByZXR1cm4gX2k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOa3u+WKoOmhtueCuVxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRWZXJ0ZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVmVydGV4KHZwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhdGVWZXgodnApICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggaGFzIGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXhudW0rK10gPSBuZXcgVmV4Tm9kZSh2cCwgbnVsbCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXhudW07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmt7vliqDlvKdcclxuICAgICAgICAgKiDlpoLmnpzmmK/ml6DlkJHlm77miJbogIXml6DlkJHnvZEsYXJjMeWSjGFyYzLml6Dpobrluo/opoHmsYJcclxuICAgICAgICAgKiDlpoLmnpzmmK/mnInlkJHlm77miJbogIXmnInlkJHnvZHvvIzlj6rkvJrmt7vliqBhcmMx77yM5Zug5q2k5q2j6YK75o6l6KGo5ZKM6YCG6YK75o6l6KGo55qE6aG65bqP6ZyA6KaB5rOo5oSPXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFyYzFcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJjMlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gaW5mb1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRBcmMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXJjKGFyYzEsIGFyYzIsIGluZm8pIHtcbiAgICAgICAgICAgIHZhciBrID0gdGhpcy5sb2NhdGVWZXgoYXJjMSk7XG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KGFyYzIpO1xuXG4gICAgICAgICAgICBpZiAoayA9PT0gLTEgfHwgaiA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgICAgIC8vIOi+ueeahOi1t+Wni+ihqOe7k+eCuei1i+WAvFxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgQXJjTm9kZShrLCBudWxsLCBpbmZvKTtcbiAgICAgICAgICAgIC8vIOi+ueeahOacq+WwvuihqOe7k+eCuei1i+WAvFxuICAgICAgICAgICAgdmFyIHEgPSBuZXcgQXJjTm9kZShqLCBudWxsLCBpbmZvKTtcblxuICAgICAgICAgICAgLy8g5piv5peg5ZCR5Zu+77yM55So5aS05o+S5YWl5rOV5o+S5YWl5Yiw5Lik5Liq5Y2V6ZO+6KGoXG4gICAgICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcbiAgICAgICAgICAgICAgICBxLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2tdLmZpcnN0QXJjO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNba10uZmlyc3RBcmMgPSBxO1xuICAgICAgICAgICAgICAgIHAubmV4dEFyYyA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYyA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlu7rnq4vmnInlkJHlm77nmoTpgrvmjqXpk77ooajvvIznlKjlpLTmj5LlhaXms5VcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjID0gcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICsrdGhpcy5hcmNudW07XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyDlhbbku5blm77nsbvlnovnmoTliJvlu7rmmoLml7bmsqHlvIRcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JlYXRlR3JhcGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlR3JhcGgoKSB7XG4gICAgICAgICAgICB0aGlzLnZleG51bSA9ICtwcm9tcHQoJ3ZleG51bTogJyk7XG4gICAgICAgICAgICB0aGlzLmFyY251bSA9ICtwcm9tcHQoJ2FyY251bTogJyk7XG4gICAgICAgICAgICAvLyBpbmNJbmZv5Li6MOWImeWQhOW8p+S4jeWQq+WFtuS7luS/oeaBr1xuICAgICAgICAgICAgdmFyIGluY0luZm8gPSArcHJvbXB0KCdpbmNJbmZvOiAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX20gPSAwOyBfbSA8IHRoaXMudmV4bnVtOyArK19tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tfbV0gPSBuZXcgVmV4Tm9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbX21dLmRhdGEgPSBwcm9tcHQoJ3ZlcnRleDogJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCB0aGlzLmFyY251bTsgKyttKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBwcm9tcHQoJ+W8p+WktDogJyk7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBwcm9tcHQoJ+W8p+WwvjogJyk7XG4gICAgICAgICAgICAgICAgdmFyIF9pMiA9IHRoaXMubG9jYXRlVmV4KHQpO1xuICAgICAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgoaCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2kyIDwgMCB8fCBqIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgn6aG254K55Li65om+5Yiw77yM6K+36YeN5paw6L6T5YWl77yBJyk7XG4gICAgICAgICAgICAgICAgICAgIG0tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgQXJjTm9kZShqLCBudWxsLCBpbmNJbmZvICYmIHByb21wdCgnaW5mbzogJykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2VzW19pMl0uZmlyc3RBcmMpIHRoaXMudmVydGljZXNbX2kyXS5maXJzdEFyYyA9IHA7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9xID0gdGhpcy52ZXJ0aWNlc1tfaTJdLmZpcnN0QXJjOyBfcS5uZXh0QXJjOyBfcSA9IF9xLm5leHRBcmMpIHt9XG4gICAgICAgICAgICAgICAgICAgIHEubmV4dEFyYyA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5Yik5pat5LiA5Liq6YK75o6l6KGo5a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzUGFzcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Bhc3MoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMudmV4bnVtOyArK3gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gdGhpcy52ZXJ0aWNlc1t4XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcTIgPSB0aGlzLnZlcnRpY2VzW3ldLmZpcnN0QXJjOyBfcTI7IF9xMiA9IF9xMi5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeiA9IF9xMi5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeiAhPT0geCAmJiB0aGlzLmlzQWRqKHgsIHopKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5Yik5pat5pyJ5ZCR5Zu+5piv5ZCm5a2Y5Zyo6L65KG0sbilcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNBZGonLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNBZGoobSwgbikge1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IHRoaXMudmVydGljZXNbbV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5hZGpWZXggPT09IG4pIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5rex5bqm5LyY5YWI5Yik5patPGI+5pyJ5ZCR5Zu+PGI+55qE6aG254K5aeWIsOmhtueCuWrmmK/lkKbmnInot6/lvoTvvIzlrp7liJnov5Tlm550cnVl77yM5ZCm5YiZ6L+U5ZueZmFsc2VcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqXHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4aXN0X3BhdGhfREZTJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4aXN0X3BhdGhfREZTKGksIGopIHtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkID0gW107XG4gICAgICAgICAgICBpID0gdGhpcy5sb2NhdGVWZXgoaSk7XG4gICAgICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kIScpO1xuXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RfcGF0aCh0aGlzLCBpLCBqKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZXhpc3RfcGF0aChncmFwaCwgaSwgaikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRba10gJiYgZXhpc3RfcGF0aChncmFwaCwgaywgaikpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOW5v+W6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30galxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleGlzdF9wYXRoX0JGUycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleGlzdF9wYXRoX0JGUyhpLCBqKSB7XG4gICAgICAgICAgICBpID0gdGhpcy5sb2NhdGVWZXgoaSk7XG4gICAgICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gbmV3IF9RdWV1ZTIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcblxuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW3VdID0gMTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBqKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2tdKSBxdWV1ZS5lblF1ZXVlKGspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat6YK75o6l6KGo5pa55byP5a2Y5YKo55qE5pyJ5ZCR5Zu+55qE6aG254K5aeWIsGrmmK/lkKblrZjlnKjplb/luqbkuLpr55qE566A5Y2V6Lev5b6EXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30galxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4aXN0X3BhdGhfbGVuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4aXN0X3BhdGhfbGVuKGksIGosIGspIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcbiAgICAgICAgICAgIGogPSB0aGlzLmxvY2F0ZVZleChqKTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkID0gW107XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKGdyYXBoLCBpLCBqLCBrKSB7XG4gICAgICAgICAgICAgICAgLy8g5om+5Yiw5LqG5LiA5p2h6Lev5b6E77yM5LiU6ZW/5bqm56ym5ZCIXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGogJiYgayA9PT0gMCkgcmV0dXJuIHRydWU7ZWxzZSBpZiAoayA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWJqeS9mei3r+W+hOmVv+W6puWHj+S4gFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKGdyYXBoLCBsLCBqLCBrIC0gMSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIOWFgeiuuOabvue7j+iiq+iuv+mXrui/h+eahOe7k+eCueWHuueOsOWcqOWPpuS4gOadoei3r+W+hOS4ilxuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KHRoaXMsIGksIGosIGspO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5rGC5pyJ5ZCR5Zu+5Lit6aG254K5deWIsHbkuYvpl7TnmoTmiYDmnInnroDljZXot6/lvoTvvIxr5Li65b2T5YmN6Lev5b6E6ZW/5bqmXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICBncmFwaC5maW5kX2FsbF9wYXRoKCd2MScsICd2MicsIDApO1xyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaW5kX2FsbF9wYXRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRfYWxsX3BhdGgodSwgdiwgaykge1xuICAgICAgICAgICAgdSA9IHRoaXMubG9jYXRlVmV4KHUpO1xuICAgICAgICAgICAgdiA9IHRoaXMubG9jYXRlVmV4KHYpO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkID0gW107XG5cbiAgICAgICAgICAgIGZpbmRQYXRoKHRoaXMsIHUsIHYsIGspO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kUGF0aChncmFwaCwgdSwgdiwgaykge1xuICAgICAgICAgICAgICAgIC8vIOWKoOWFpeW9k+WJjei3r+W+hOS4rVxuICAgICAgICAgICAgICAgIHBhdGhba10gPSB1O1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbdV0gPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8g5om+5Yiw5LiA5p2h566A5Y2V6Lev5b6EXG4gICAgICAgICAgICAgICAgaWYgKHUgPT09IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIG9uZSBwYXRoIScpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBwYXRoW19pM107ICsrX2kzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwYXRoW19pM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnZlcnRpY2VzW3VdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g57un57ut5a+75om+XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbF0pIGZpbmRQYXRoKGdyYXBoLCBsLCB2LCBrICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2aXNpdGVkW3VdID0gMDtcbiAgICAgICAgICAgICAgICAvLyDlm57muq9cbiAgICAgICAgICAgICAgICBwYXRoW2tdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaxguacieWQkeWbvueahOmhtueCueS5i+mXtOmVv+W6puS4umxlbueahOeugOWNlei3r+W+hOadoeaVsFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGpcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuXHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFBhdGhOdW1fbGVuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhdGhOdW1fbGVuKGksIGosIGxlbikge1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlY3Vyc2UoZ3JhcGgsIGksIGosIGxlbikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBqICYmIGxlbiA9PT0gMCkgcmV0dXJuIDE7ZWxzZSBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtsXSkgc3VtICs9IHJlY3Vyc2UobCwgaiwgbGVuIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSh0aGlzLCBpLCBqLCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5rGC5pyJ5ZCR5peg546v5Zu+55qE5qC5XHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdCgpIHtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHRoaXMudmV4bnVtOyArK19pNCkge1xuICAgICAgICAgICAgICAgIC8vIOavj+asoemDveimgeWwhuiuv+mXruaVsOe7hOa4hembtlxuICAgICAgICAgICAgICAgIGZvciAodmFyIF93ID0gMDsgX3cgPCB0aGlzLnZleG51bTsgKytfdykge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW193XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gLy8g5LuO6aG254K5aeWHuuWPkei/m+ihjOa3seW6puS8mOWFiOmBjeWOhlxuICAgICAgICAgICAgICAgIGRmcyh0aGlzLCBfaTQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenGnmmK/moLnvvIzliJnmt7HluqbkvJjlhYjpgY3ljoblj6/ku6Xorr/pl67liLDmiYDmnInnu5PngrlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3ddKSBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZsYWcpIGNvbnNvbGUubG9nKCdGb3VuZCBhIHJvb3QgdmVydGV4OiAlZCcsIF9pNCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdikge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnZlcnRpY2VzW3ZdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdzIgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW193Ml0pIGRmcyhncmFwaCwgX3cyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmsYLkuIDkuKrmnInlkJHml6Dnjq/lm77kuK3mnIDplb/nmoTot6/lvoRcclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TG9uZ2VzdFBhdGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdFBhdGgoKSB7XG4gICAgICAgICAgICB2YXIgbWxwID0gW107XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXhMZW4gPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmNvdW50SW5kZWdyZWUoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgdGhpcy52ZXhudW07ICsrX2k1KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbal0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IC8vIOS7juavj+S4gOS4qumbtuWFpeW6pue7k+eCueW8gOWni+a3seW6puS8mOWFiOmBjeWOhlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2VzW19pNV0uaW5kZWdyZWUgPT09IDApIGRmcyh0aGlzLCBfaTUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9uZ2VzdCBQYXRoOicpO1xuICAgICAgICAgICAgLy8g6L6T5Ye65pyA6ZW/6Lev5b6EXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBtbHBbaV07ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1scC5qb2luKCcsJykpO1xuICAgICAgICAgICAgfWZ1bmN0aW9uIGRmcyhncmFwaCwgaSwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGF0aFtsZW5dID0gaTtcblxuICAgICAgICAgICAgICAgIC8vIOaWsOeahOacgOmVv+i3r+W+hFxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiBtYXhMZW4gJiYgIWdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOS/neWtmOS4i+adpVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDw9IGxlbjsgKytfaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWxwW19qXSA9IHBhdGhbX2pdO1xuICAgICAgICAgICAgICAgICAgICB9bWF4TGVuID0gbGVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF93MyA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW193M10pIGRmcyhncmFwaCwgX3czLCBsZW4gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhdGhbaV0gPSAwO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOmCu+aOpeihqOeahOmAkuW9kuW8j+a3seW6puS8mOWFiOmBjeWOhlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdERlNUcmF2ZXJzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBERlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgdGhpcy52ZXhudW07ICsrX2k2KSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtfaTZdID0gZmFsc2U7XG4gICAgICAgICAgICB9Zm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgdGhpcy52ZXhudW07ICsrX2k3KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW19pN10pIGRmcyh0aGlzLCBfaTcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHYpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwoZ3JhcGgsIHYpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSBkZnMoZ3JhcGgsIHAuYWRqVmV4KTtcblxuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOmCu+aOpeihqOeahOmdnumAkuW9kua3seW6puS8mOWFiOaQnOe0olxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdERlNUcmF2ZXJzZV9Ob25SZWN1cnNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIERGU1RyYXZlcnNlX05vblJlY3Vyc2UodmlzaXRGbikge1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBfaW5kZXgyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IHRoaXMudmV4bnVtOyArK19pOCkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbX2k4XSA9IGZhbHNlO1xuICAgICAgICAgICAgfWZvciAodmFyIF9pOSA9IDA7IF9pOSA8IHRoaXMudmV4bnVtOyArK19pOSkge1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtfaTldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goX2k5KTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtfaTldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIF9pOSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgodiA9IHN0YWNrLnBlZWsoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnZlcnRpY2VzW3ZdLmZpcnN0QXJjO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbcC5hZGpWZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIHAuYWRqVmV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwLmFkalZleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOmCu+aOpeihqOeahOW5v+W6puS8mOWFiOaQnOe0olxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdCRlNUcmF2ZXJzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBCRlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBuZXcgX1F1ZXVlMi5kZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCB0aGlzLnZleG51bTsgKytfaTEwKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtfaTEwXSA9IGZhbHNlO1xuICAgICAgICAgICAgfWZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgdGhpcy52ZXhudW07ICsrX2kxMSkge1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtfaTExXSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKF9pMTEpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW19pMTFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIF9pMTEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3c0ID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnZlcnRpY2VzW193NF0uZmlyc3RBcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgcC5hZGpWZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAuYWRqVmV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5bu656uL5peg5ZCR5Zu+55qE5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6X55qE5a2p5a2Q5YWE5byf6ZO+6KGo5qCRXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NyZWF0ZURGU0ZvcmVzdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVERlNGb3Jlc3QoKSB7XG4gICAgICAgICAgICB2YXIgdHJlZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCB0aGlzLnZleG51bTsgKytfaTEyKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtfaTEyXSA9IGZhbHNlO1xuICAgICAgICAgICAgfXZhciBxID0gdm9pZCAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCB0aGlzLnZleG51bTsgKytfaTEzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW19pMTNdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOaWsOeahOeUn+aIkOagkeeahOaguee7k+eCuVxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBfQmluYXJ5VHJlZS5DaGlsZFNpYmxpbmdUcmVlKHRoaXMudmVydGljZXNbX2kxM10uZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5qO155Sf5oiQ5qCR55qE5qC5XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJlZSkgdHJlZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWFtuWug+eUn+aIkOagkeeahOaguVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHHkuLrlvZPliY3nlJ/miJDmoJHnmoTmoLlcbiAgICAgICAgICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIC8vIOW7uueri+S7pXDkuLrmoLnnmoTnlJ/miJDmoJFcbiAgICAgICAgICAgICAgICAgICAgREZTVHJlZSh0aGlzLCBfaTEzLCBwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuXG4gICAgICAgICAgICAvLyDku6XnrKx25Liq6aG254K56Kem5Y+R5rex5bqm5LyY5YWI6YGN5Y6G5Zu+77yM5bu656uL5LuldHJlZeS4uuagueeahOeUn+aIkOagkVxuICAgICAgICAgICAgZnVuY3Rpb24gREZTVHJlZShncmFwaCwgdiwgdHJlZSkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICh3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3LmFkalZleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbdy5hZGpWZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcCA9IG5ldyBfQmluYXJ5VHJlZS5DaGlsZFNpYmxpbmdUcmVlKGdyYXBoLnZlcnRpY2VzW3cuYWRqVmV4XS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd+aYr3bnmoTnrKzkuIDkuKrmnKrooqvorr/pl67nmoTpgrvmjqXnu5PngrlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuZmlyc3RDaGlsZCA9IF9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB35pivdueahOWFtuWug+acquiiq+iuv+mXrueahOmCu+aOpemhtueCuVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBxLm5leHRTaWJsaW5nID0gX3A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBfcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgREZTVHJlZShncmFwaCwgdy5hZGpWZXgsIHEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdyA9IHcubmV4dEFyYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NyZWF0ZUJGU0ZvcmVzdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVCRlNGb3Jlc3QoKSB7XG4gICAgICAgICAgICB2YXIgdHJlZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gbmV3IF9RdWV1ZTIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCB0aGlzLnZleG51bTsgKytfaTE0KSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtfaTE0XSA9IGZhbHNlO1xuICAgICAgICAgICAgfXZhciBxID0gdm9pZCAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxNSA9IDA7IF9pMTUgPCB0aGlzLnZleG51bTsgKytfaTE1KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW19pMTVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbX2kxNV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKF9pMTUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gbmV3IF9CaW5hcnlUcmVlLkNoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1tfaTE1XS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gbm9kZTtlbHNlIHEubmV4dFNpYmxpbmcgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIHEgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3c1ID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnZlcnRpY2VzW193NV0uZmlyc3RBcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbcC5hZGpWZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShwLmFkalZleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gbmV3IF9CaW5hcnlUcmVlLkNoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1twLmFkalZleF0uZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmZpcnN0Q2hpbGQgPSBub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBwcmUubmV4dFNpYmxpbmcgPSBub2RlMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZpbmRBcnRpY3VsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBcnRpY3VsKCkge1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgbG93ID0gW107XG4gICAgICAgICAgICBsb3dbMF0gPSBjb3VudDtcbiAgICAgICAgICAgIHZpc2l0ZWRbMF0gPSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxNiA9IDE7IF9pMTYgPCB0aGlzLnZleG51bTsgKytfaTE2KSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtfaTE2XSA9IDA7XG4gICAgICAgICAgICB9dmFyIHAgPSB0aGlzLnZlcnRpY2VzWzBdLmZpcnN0QXJjO1xuICAgICAgICAgICAgdmFyIHYgPSBwLmFkalZleDtcblxuICAgICAgICAgICAgREZTQXJ0aWN1bCh0aGlzLCB2KTtcbiAgICAgICAgICAgIGlmIChjb3VudCA8IHRoaXMudmV4bnVtKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coMCArICcgICcgKyB0aGlzLnZlcnRpY2VzWzBdLmRhdGEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcbiAgICAgICAgICAgICAgICAgICAgdiA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFt2XSA9PT0gMCkgREZTQXJ0aWN1bCh0aGlzLCB2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIERGU0FydGljdWwoZ3JhcGgsIHYwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IHZpc2l0ZWRbdjBdID0gKytjb3VudDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfcDIgPSBncmFwaC52ZXJ0aWNlc1t2MF0uZmlyc3RBcmM7IF9wMjsgX3AyID0gX3AyLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF93NiA9IF9wMi5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW193Nl0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERGU0FydGljdWwoZ3JhcGgsIF93Nik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG93W193Nl0gPCBtaW4pIG1pbiA9IGxvd1tfdzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvd1tfdzZdID49IHZpc2l0ZWRbdjBdKSBjb25zb2xlLmxvZyh2MCArICcgICcgKyBncmFwaC52ZXJ0aWNlc1t2MF0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlzaXRlZFtfdzZdIDwgbWluKSBtaW4gPSB2aXNpdGVkW193Nl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvd1t2MF0gPSBtaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDnu5/orqHlkITpobbngrnlhaXluqbnmoTlh73mlbBcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY291bnRJbmRlZ3JlZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb3VudEluZGVncmVlKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1trXS5pbmRlZ3JlZSA9IDA7XG4gICAgICAgICAgICB9Zm9yICh2YXIgX2sgPSAwOyBfayA8IHRoaXMudmV4bnVtOyArK19rKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IHRoaXMudmVydGljZXNbX2tdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgICsrdGhpcy52ZXJ0aWNlc1twLmFkalZleF0uaW5kZWdyZWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5ouT5omR5o6S5bqP566X5rOVXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvcG9sb2dpY1NvcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9wb2xvZ2ljU29ydCgpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBfaW5kZXgyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMudG9wb2xvZ2ljYWxPcmRlciA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jb3VudEluZGVncmVlKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTcgPSAwOyBfaTE3IDwgdGhpcy52ZXhudW07ICsrX2kxNykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2VzW19pMTddLmluZGVncmVlID09PSAwKSBzdGFjay5wdXNoKF9pMTcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBfaTE4ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyLnB1c2goX2kxOCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1tfaTE4XS5kYXRhKTtcbiAgICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSB0aGlzLnZlcnRpY2VzW19pMThdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLXRoaXMudmVydGljZXNba10uaW5kZWdyZWUgPT09IDApIHN0YWNrLnB1c2goayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY291bnQgPj0gdGhpcy52ZXhudW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyDovpPlh7rmnInlkJHlm77nmoTlkITpobnlhbPplK7mtLvliqhcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JpdGljYWxQYXRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyaXRpY2FsUGF0aCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50b3BvbG9naWNTb3J0KCkpIHRocm93IG5ldyBFcnJvcignQU9F572R5Lit5a2Y5Zyo5Zue6Lev77yBJyk7XG5cbiAgICAgICAgICAgIHZhciB2ZSA9IFtdO1xuICAgICAgICAgICAgLy8g5LqL5Lu25pyA5pep5Y+R55Sf5pe26Ze05Yid5aeL5YyWXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICB2ZVtqXSA9IDA7XG4gICAgICAgICAgICB9IC8vIOiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZl5YC8XG4gICAgICAgICAgICBmb3IgKHZhciBfbTIgPSAwOyBfbTIgPCB0aGlzLnZleG51bTsgKytfbTIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2oyID0gdGhpcy50b3BvbG9naWNhbE9yZGVyW19tMl07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IHRoaXMudmVydGljZXNbX2oyXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVbX2oyXSArIHAuaW5mbyA+IHZlW2tdKSB2ZVtrXSA9IHZlW19qMl0gKyBwLmluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZsID0gW107XG4gICAgICAgICAgICAvLyDkuovku7bmnIDmmZrlj5HnlJ/ml7bpl7TliJ3lp4vljJZcbiAgICAgICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IHRoaXMudmV4bnVtOyArK19qMykge1xuICAgICAgICAgICAgICAgIHZsW19qM10gPSB2ZVt0aGlzLnZleG51bSAtIDFdO1xuICAgICAgICAgICAgfSAvLyDorqHnrpfmr4/kuKrkuovku7bnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bOeahOWAvFxuICAgICAgICAgICAgZm9yICh2YXIgX20zID0gdGhpcy52ZXhudW0gLSAxOyBfbTMgPj0gMDsgLS1fbTMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2o0ID0gdGhpcy50b3BvbG9naWNhbE9yZGVyW19tM107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX3AzID0gdGhpcy52ZXJ0aWNlc1tfajRdLmZpcnN0QXJjOyBfcDM7IF9wMyA9IF9wMy5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfazIgPSBfcDMuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAodmxbX2syXSAtIF9wMy5pbmZvIDwgdmxbX2o0XSkgdmxbX2o0XSA9IHZsW19rMl0gLSBfcDMuaW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDovpPlh7rmiYDmnInlhbPplK7mtLvliqhcbiAgICAgICAgICAgIGZvciAodmFyIF9tNCA9IDA7IF9tNCA8IHRoaXMudmV4bnVtOyArK19tNCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9wNCA9IHRoaXMudmVydGljZXNbX200XS5maXJzdEFyYzsgX3A0OyBfcDQgPSBfcDQubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2szID0gX3A0LmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlW19tNF0gKyBfcDQuaW5mbyA9PT0gdmxbX2szXSkgY29uc29sZS5sb2coJzwlZCwgJWQ+JywgX200LCBfazMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2hvcnRlc3RQYXRoX0RpamtzdHJhJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3J0ZXN0UGF0aF9EaWprc3RyYSh2MCkge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBwcmUgPSBbXTtcbiAgICAgICAgICAgIHZhciBmaW5hbCA9IFtdO1xuICAgICAgICAgICAgdmFyIHcgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF92ID0gMDsgX3YgPCB0aGlzLnZleG51bTsgKytfdikge1xuICAgICAgICAgICAgICAgIGRpc3RbX3ZdID0gSW5maW5pdHk7XG4gICAgICAgICAgICB9Zm9yICh2YXIgcCA9IHRoaXMudmVydGljZXNbdjBdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgZGlzdFtwLmFkalZleF0gPSBwLmluZm87XG4gICAgICAgICAgICB9dmFyIHYgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xuICAgICAgICAgICAgICAgIGZpbmFsW3ZdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJlW3ZdID0gcHJlW3ZdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVt2XVt3XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1pZiAoZGlzdFt2XSA8IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmVbdl1bdl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlzdFt2MF0gPSAwO1xuICAgICAgICAgICAgZmluYWxbdjBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxOSA9IDE7IF9pMTkgPCB0aGlzLnZleG51bTsgKytfaTE5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgZGlzdFt3XSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0W3ddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmluYWxbdl0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX3A1ID0gdGhpcy52ZXJ0aWNlc1t2XS5maXJzdEFyYzsgX3A1OyBfcDUgPSBfcDUubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICB3ID0gX3A1LmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBtaW4gKyBfcDUuaW5mbyA8IGRpc3Rbd10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Rbd10gPSBtaW4gKyBfcDUuaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVt3XVt3XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHByZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkaXN0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaW5hbDogZmluYWwsXG4gICAgICAgICAgICAgICAgcHJlOiBwcmUsXG4gICAgICAgICAgICAgICAgZGlzdDogZGlzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQWRqYWNlbmN5TGlzdEdyYXBoO1xufSgpO1xuXG4vLyDml6DlkJHlm77nmoTpgrvmjqXooahcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBBZGphY2VuY3lMaXN0R3JhcGg7XG52YXIgYWRqTGlzdEdyYXBoID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgVURHKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YxJyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjMnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NScpO1xuXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MScsICd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjEnLCAndjMnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MicsICd2MycpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjQnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3Y1Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2NCcsICd2NScpO1xuXG5jb25zb2xlLmxvZyhhZGpMaXN0R3JhcGgpO1xuXG4vLyDmnInlkJHlm77nmoTpgIbpgrvmjqXooahcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZy5hZGRWZXJ0ZXgoJ3YxJyk7XG5nLmFkZFZlcnRleCgndjInKTtcbmcuYWRkVmVydGV4KCd2MycpO1xuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5nLmFkZFZlcnRleCgndjUnKTtcblxuZy5hZGRBcmMoJ3YxJywgJ3YyJyk7XG5nLmFkZEFyYygndjEnLCAndjQnKTtcbmcuYWRkQXJjKCd2MycsICd2MicpO1xuZy5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5nLmFkZEFyYygndjQnLCAndjMnKTtcbmcuYWRkQXJjKCd2MycsICd2NScpO1xuZy5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5cbmNvbnNvbGUubG9nKGcpO1xuXG4vLyDmnInlkJHlm77nmoTmraPpgrvmjqXooahcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZy5hZGRWZXJ0ZXgoJ3YxJyk7XG5nLmFkZFZlcnRleCgndjInKTtcbmcuYWRkVmVydGV4KCd2MycpO1xuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5nLmFkZFZlcnRleCgndjUnKTtcblxuZy5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nLmFkZEFyYygndjQnLCAndjEnKTtcbmcuYWRkQXJjKCd2MicsICd2MycpO1xuZy5hZGRBcmMoJ3YxJywgJ3YzJyk7XG5nLmFkZEFyYygndjMnLCAndjQnKTtcbmcuYWRkQXJjKCd2NScsICd2MycpO1xuZy5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XG5cbmNvbnNvbGUubG9nKGcpO1xuXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIERGU1RyYXZlcnNlOiAnKTtcbnZhciBhZGpMaXN0R3JhcGggPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBVREcpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjEnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YyJyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MycpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjQnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y1Jyk7XG5cbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjInLCAndjEnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5cbmFkakxpc3RHcmFwaC5ERlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XG59KTtcblxuY29uc29sZS5sb2coJ2Fkakxpc3RHcmFwaCBERlNUcmF2ZXJzZV9Ob25SZWN1cnNlOiAnKTtcbmFkakxpc3RHcmFwaC5ERlNUcmF2ZXJzZV9Ob25SZWN1cnNlKGZ1bmN0aW9uICh2KSB7XG4gICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1t2XS5kYXRhKTtcbn0pO1xuXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIEJGU1RyYXZlcnNlOiAnKTtcbnZhciBnMiA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcbmcyLmFkZFZlcnRleCgndjEnKTtcbmcyLmFkZFZlcnRleCgndjInKTtcbmcyLmFkZFZlcnRleCgndjMnKTtcbmcyLmFkZFZlcnRleCgndjQnKTtcbmcyLmFkZFZlcnRleCgndjUnKTtcblxuZzIuYWRkQXJjKCd2NCcsICd2MScpO1xuZzIuYWRkQXJjKCd2MicsICd2MScpO1xuZzIuYWRkQXJjKCd2NScsICd2MycpO1xuZzIuYWRkQXJjKCd2MicsICd2MycpO1xuZzIuYWRkQXJjKCd2MScsICd2MycpO1xuZzIuYWRkQXJjKCd2MycsICd2NCcpO1xuZzIuYWRkQXJjKCd2NCcsICd2NScpO1xuXG5nMi5CRlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XG59KTtcblxuY29uc29sZS5sb2coJ0RGUzogZXhwZWN0IGZhbHNlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0X3BhdGhfREZTKCd2MScsICd2NCcpKTtcbmNvbnNvbGUubG9nKCdERlM6IGV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0X3BhdGhfREZTKCd2MScsICd2MicpKTtcblxuY29uc29sZS5sb2coJ0JGUyA6IGV4cGVjdCBmYWxzZTogJyArIGFkakxpc3RHcmFwaC5leGlzdF9wYXRoX0JGUygndjEnLCAndjQnKSk7XG5jb25zb2xlLmxvZygnQkZTIDpleHBlY3QgdHJ1ZTogJyArIGFkakxpc3RHcmFwaC5leGlzdF9wYXRoX0JGUygndjEnLCAndjInKSk7XG5cbi8qXHJcbiDlm77nmoTov57pgJrmgKfpl67pophcclxuXHJcbiDml6DlkJHlm77nmoTov57pgJrliIbph4/kuI7nlJ/miJDmoJFcclxuXHJcbiAxIOaXoOWQkeWbvueahOi/numAmuWIhumHj+WSjOeUn+aIkOagkVxyXG4g5a+55LqO5peg5ZCR5Zu+77yM5a+55YW26L+b6KGM6YGN5Y6G5pe277yaXHJcbiDil4Yg6Iul5piv6L+e6YCa5Zu+77ya5LuF6ZyA5LuO5Zu+5Lit5Lu75LiA6aG254K55Ye65Y+R77yM5bCx6IO96K6/6Zeu5Zu+5Lit55qE5omA5pyJ6aG254K577ybXHJcbiDil4Yg6Iul5piv6Z2e6L+e6YCa5Zu+77ya6ZyA5LuO5Zu+5Lit5aSa5Liq6aG254K55Ye65Y+R44CC5q+P5qyh5LuO5LiA5Liq5paw6aG254K55Ye65Y+R5omA6K6/6Zeu55qE6aG254K56ZuG5bqP5YiX5oGw5aW95piv5ZCE5Liq6L+e6YCa5YiG6YeP55qE6aG254K56ZuG77ybXHJcblxyXG4g4pG0IOiLpUc9KFYsRSnmmK/ml6DlkJHov57pgJrlm77vvIwg6aG254K56ZuG5ZKM6L656ZuG5YiG5Yir5pivVihHKSDvvIxFKEcpIOOAguiLpeS7jkfkuK3ku7vmhI/ngrnlh7rlj5HpgY3ljobml7bvvIwgRShHKeiiq+WIhuaIkOS4pOS4quS6kuS4jeebuOS6pOeahOmbhuWQiO+8mlxyXG4gVChHKSDvvJrpgY3ljobov4fnqIvkuK3miYDnu4/ov4fnmoTovrnnmoTpm4blkIjvvJtcclxuIEIoRykg77ya6YGN5Y6G6L+H56iL5Lit5pyq57uP6L+H55qE6L6555qE6ZuG5ZCI77ybXHJcbiDmmL7nhLbvvJogRShHKT1UKEcp4oiqQihHKSDvvIxUKEcp4oipQihHKT3DmFxyXG4g5pi+54S277yM5Zu+R+KAmT0oViwgVChHKSnmmK9H55qE5p6B5bCP6L+e6YCa5a2Q5Zu+77yM5LiUR+KAmeaYr+S4gOajteagkeOAgkfigJnnp7DkuLrlm75H55qE5LiA5qO155Sf5oiQ5qCR44CCXHJcbiDku47ku7vmhI/ngrnlh7rlj5HmjIlERlPnrpfms5XlvpfliLDnlJ/miJDmoJFH4oCZ56ew5Li65rex5bqm5LyY5YWI55Sf5oiQ5qCR77yb5oyJQkZT566X5rOV5b6X5Yiw55qER+KAmeensOS4uuW5v+W6puS8mOWFiOeUn+aIkOagkeOAglxyXG5cclxuIOKRtSAg6IulRz0oVixFKeaYr+aXoOWQkemdnui/numAmuWbvu+8jOWvueWbvui/m+ihjOmBjeWOhuaXtuW+l+WIsOiLpeW5suS4qui/numAmuWIhumHj+eahOmhtueCuembhu+8mlYxKEcpICxWMihHKSAs4oCmLFZuKEcp5ZKM55u45bqU5omA57uP6L+H55qE6L656ZuG77yaVDEoRykgLFQyKEcpICwg4oCmLFRuKEcpIOOAglxyXG4g5YiZ5a+55bqU55qE6aG254K56ZuG5ZKM6L656ZuG55qE5LqM5YWD57uE77yaR2k9KFZpKEcpLFRpKEcpKVxyXG4gKDHiiaZp4ommbinmmK/lr7nlupTliIbph4/nmoTnlJ/miJDmoJHvvIzmiYDmnInov5nkupvnlJ/miJDmoJHmnoTmiJDkuobljp/mnaXpnZ7ov57pgJrlm77nmoTnlJ/miJDmo67mnpfjgIJcclxuXHJcbiDor7TmmI7vvJrlvZPnu5nlrprml6DlkJHlm77opoHmsYLnlLvlh7rlhbblr7nlupTnmoTnlJ/miJDmoJHmiJbnlJ/miJDmo67mnpfml7bvvIzlv4XpobvlhYjnu5nlh7rnm7jlupTnmoTpgrvmjqXooajvvIznhLblkI7miY3og73moLnmja7pgrvmjqXooajnlLvlh7rlhbblr7nlupTnmoTnlJ/miJDmoJHmiJbnlJ/miJDmo67mnpfjgIJcclxuXHJcblxyXG4gMiAg5Zu+55qE55Sf5oiQ5qCR5ZKM55Sf5oiQ5qOu5p6X566X5rOVXHJcblxyXG4g5a+55Zu+55qE5rex5bqm5LyY5YWI5pCc57Si6YGN5Y6GREZTKOaIlkJGUynnrpfms5XnqI3kvZzkv67mlLnvvIzlsLHlj6/lvpfliLDmnoTpgKDlm77nmoRERlPnlJ/miJDmoJHnrpfms5XjgIJcclxuIOWcqOeul+azleS4re+8jOagkeeahOWtmOWCqOe7k+aehOmHh+eUqOWtqeWtkOKAlOWFhOW8n+ihqOekuuazleOAgummluWFiOW7uueri+S7juafkOS4qumhtueCuVblh7rlj5HvvIzlu7rnq4vkuIDkuKrmoJHnu5PngrnvvIznhLblkI7lho3liIbliKvku6VW55qE6YK75o6l54K55Li66LW35aeL54K577yM5bu656uL55u45bqU55qE5a2Q55Sf5oiQ5qCR77yM5bm25bCG5YW25L2c5Li6ViDnu5PngrnnmoTlrZDmoJHpk77mjqXliLBW57uT54K55LiK44CC5pi+54S277yM566X5rOV5piv5LiA5Liq6YCS5b2S566X5rOV44CCXHJcblxyXG4gKi9cblxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZURGU0ZvcmVzdCgpKTtcblxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZUJGU0ZvcmVzdCgpKTtcblxuLypcclxuIOWcqOafkOWbvuS4re+8jOiLpeWIoOmZpOmhtueCuVbku6Xlj4pW55u45YWz55qE6L655ZCO77yM5Zu+55qE5LiA5Liq6L+e6YCa5YiG6YeP5YiG5Ymy5Li65Lik5Liq5oiW5Lik5Liq5Lul5LiK55qE6L+e6YCa5YiG6YeP77yM5YiZ56ew6aG254K5VuS4uuivpeWbvueahOS4gOS4quWFs+iKgueCueOAguS4gOS4quayoeacieWFs+iKgueCueeahOi/numAmuWbvuensOS4uumHjei/numAmuWbvuOAglxyXG4g5Zyo6YeN6L+e6YCa5Zu+5Lit77yM5Lu75oSP5LiA5a+56aG254K55LmL6Ze06Iez5bCR5a2Y5Zyo5Lik5p2h6Lev5b6E77yM5YiZ5YaN5Yig5Y675p+Q5Liq6aG254K55Y2z55u45YWz5ZCE6L655ZCO5Lmf5LiN56C05Z2P5Zu+55qE6L+e6YCa5oCn44CC6Iul5Zyo5Zu+55qE6L+e6YCa5Zu+5LiK5Yig5Y67a+S4quiKgueCueaJjeiDveegtOWdj+WbvueahOi/numAmuaAp++8jOWImeensEvkuLrmraTlm77nmoTov57pgJrluqbjgIJcclxuIOS7luS7rOW4uOW4uOWcqOmAmuS/oee9kee7nOeahOWbvuaIluiIquepuue9keS4reW6lOeUqO+8jEvotorlpKfvvIzns7vnu5/otornqLPlrprvvIzlj43kuYvvvIzmiJjkuonkuK3oi6XopoHmkafmr4HmlYzmlrnnmoTov5DovpPnur/vvIzlj6rpobvnoLTlnY/lhbbov5DovpPnvZHkuK3nmoTlhbPoioLngrnljbPlj6/jgIJcclxuICovXG5cbnZhciBhcnRpY3VsVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIFVERyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0EnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnQicpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdDJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0QnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRScpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdGJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0cnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSCcpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdJJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0onKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSycpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdMJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ00nKTtcblxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0InKTtcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdDJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnRicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0wnKTtcbmFydGljdWxUZXN0LmFkZEFyYygnQycsICdCJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0QnLCAnQicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0InKTtcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdCJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ00nLCAnQicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdEJywgJ0UnKTtcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdIJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnSScpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0snKTtcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdLJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0onLCAnTCcpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdKJywgJ00nKTtcbmFydGljdWxUZXN0LmFkZEFyYygnTCcsICdNJyk7XG5cbmFydGljdWxUZXN0LmZpbmRBcnRpY3VsKCk7XG5cbi8qXHJcbiDmnInlkJHml6Dnjq/lm77lj4rlhbblupTnlKhcclxuXHJcbiDmnInlkJHml6Dnjq/lm74oRGlyZWN0ZWQgQWN5Y2xpbmcgR3JhcGgp77ya5piv5Zu+5Lit5rKh5pyJ5Zue6LevKOeOrynnmoTmnInlkJHlm77jgILmmK/kuIDnsbvlhbfmnInku6PooajmgKfnmoTlm77vvIzkuLvopoHnlKjkuo7noJTnqbblt6XnqIvpobnnm67nmoTlt6Xluo/pl67popjjgIHlt6XnqIvml7bpl7Tov5vluqbpl67popjnrYnjgIJcclxuXHJcbiDkuIDkuKrlt6XnqIsocHJvamVjdCnpg73lj6/liIbkuLroi6XlubLkuKrnp7DkuLrmtLvliqgoYWN0aXZlKeeahOWtkOW3peeoiyjmiJblt6Xluo8p77yM5ZCE5Liq5a2Q5bel56iL5Y+X5Yiw5LiA5a6a55qE5p2h5Lu257qm5p2f77ya5p+Q5Liq5a2Q5bel56iL5b+F6aG75byA5aeL5LqO5Y+m5LiA5Liq5a2Q5bel56iL5a6M5oiQ5LmL5ZCO77yb5pW05Liq5bel56iL5pyJ5LiA5Liq5byA5aeL54K5KOi1t+eCuSnlkozkuIDkuKrnu4jngrnjgILkurrku6zlhbPlv4PvvJpcclxuIOKXhiDlt6XnqIvog73lkKbpobrliKnlrozmiJA/5b2x5ZON5bel56iL55qE5YWz6ZSu5rS75Yqo5piv5LuA5LmIP1xyXG4g4peGIOS8sOeul+aVtOS4quW3peeoi+WujOaIkOaJgOW/hemhu+eahOacgOefreaXtumXtOaYr+WkmuWwkT9cclxuXHJcbiDlr7nlt6XnqIvnmoTmtLvliqjliqDku6Xmir3osaHvvJrlm77kuK3pobbngrnooajnpLrmtLvliqjvvIzmnInlkJHovrnooajnpLrmtLvliqjkuYvpl7TnmoTkvJjlhYjlhbPns7vvvIzov5nmoLfnmoTmnInlkJHlm77np7DkuLrpobbngrnooajnpLrmtLvliqjnmoTnvZEoQWN0aXZpdHkgT24gVmVydGV4IE5ldHdvcmsg77yMQU9W572RKSDjgIJcclxuXHJcblxyXG4g5ouT5omR5o6S5bqPXHJcblxyXG4gMSDlrprkuYlcclxuIOaLk+aJkeaOkuW6jyhUb3BvbG9naWNhbCBTb3J0KSDvvJrnlLHmn5DkuKrpm4blkIjkuIrnmoTkuIDkuKrlgY/luo/lvpfliLDor6Xpm4blkIjkuIrnmoTkuIDkuKrlhajluo/nmoTmk43kvZzjgIJcclxuXHJcbiDil4Yg6ZuG5ZCI5LiK55qE5YWz57O777ya6ZuG5ZCIQeS4iueahOWFs+ezu+aYr+S7jkHliLBB55qE5YWz57O7KEHvgrRBKSDjgIJcclxuIOKXhiDlhbPns7vnmoToh6rlj43mgKfvvJroi6XvgKJh4oiIQeaciShh77yMYSniiIhS77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/oh6rlj43nmoTjgIJcclxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAglxyXG4g4peGIOWFs+ezu+eahOWvueensOaAp+S4juWPjeWvueensOaAp++8muWmguaenOWvueS6jmHvvIxi4oiIQSDvvIzlj6ropoHmnIkoYe+8jGIp4oiIUuWwseaciShi77yMYSniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5a+556ew55qE44CC5aaC5p6c5a+55LqOYe+8jGLiiIhBIO+8jOS7heW9k2E9YuaXtuaciShh77yMYiniiIhS5ZKMKGLvvIxhKeKIiFIg77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/lj43lr7nnp7DnmoTjgIJcclxuIOKXhiDlhbPns7vnmoTkvKDpgJLmgKfvvJroi6Vh77yMYu+8jGPiiIhB77yM6IulKGHvvIxiKeKIiFLvvIzlubbkuJQoYu+8jGMp4oiIUiDvvIzliJkoYe+8jGMp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+S8oOmAkueahOOAglxyXG4g4peGIOWBj+W6j++8muiLpembhuWQiEHkuIrnmoTlhbPns7tS5piv6Ieq5Y+N55qE77yM5Y+N5a+556ew55qE5ZKM5Lyg6YCS55qE77yM5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vjgIJcclxuIOKXhiDlhajluo/vvJrorr5S5piv6ZuG5ZCIQeS4iueahOWBj+W6j+WFs+ezu++8jO+AomHvvIxi4oiIQe+8jOW/heaciWFSYuaIlmJSYe+8jCDliJnnp7BS5piv6ZuG5ZCIQeS4iueahOWFqOW6j+WFs+ezu+OAglxyXG5cclxuIOWNs+WBj+W6j+aYr+aMh+mbhuWQiOS4reS7heaciemDqOWIhuWFg+e0oOS5i+mXtOWPr+S7peavlOi+g++8jOiAjOWFqOW6j+aYr+aMh+mbhuWQiOS4reS7u+aEj+S4pOS4quWFg+e0oOS5i+mXtOmDveWPr+S7peavlOi+g+OAglxyXG4g5ZyoQU9W572R5Lit77yM6Iul5pyJ5pyJ5ZCR6L65PGksIGo+77yM5YiZaeaYr2rnmoTnm7TmjqXliY3pqbHvvIxq5pivaeeahOebtOaOpeWQjue7p++8m+aOqOiAjOW5v+S5i++8jOiLpeS7jumhtueCuWnliLDpobbngrlq5pyJ5pyJ5ZCR6Lev5b6E77yM5YiZaeaYr2rnmoTliY3pqbHvvIxq5pivaeeahOWQjue7p+OAglxyXG4g5ZyoQU9W572R5Lit77yM5LiN6IO95pyJ546v77yM5ZCm5YiZ77yM5p+Q6aG55rS75Yqo6IO95ZCm6L+b6KGM5piv5Lul6Ieq6Lqr55qE5a6M5oiQ5L2c5Li65YmN5o+Q5p2h5Lu244CCXHJcbiDmo4Dmn6Xmlrnms5XvvJrlr7nmnInlkJHlm77nmoTpobbngrnov5vooYzmi5PmiZHmjpLluo/vvIzoi6XmiYDmnInpobbngrnpg73lnKjlhbbmi5PmiZHmnInluo/luo/liJfkuK3vvIzliJnml6Dnjq/jgIJcclxuIOacieWQkeWbvueahOaLk+aJkeaOkuW6j++8muaehOmAoEFPVue9keS4remhtueCueeahOS4gOS4quaLk+aJkee6v+aAp+W6j+WIlyh24oCZMSx24oCZMiwg4ouvLHbigJluKe+8jOS9v+W+l+ivpee6v+aAp+W6j+WIl+S4jeS7heS/neaMgeWOn+adpeacieWQkeWbvuS4remhtueCueS5i+mXtOeahOS8mOWFiOWFs+ezu++8jOiAjOS4lOWvueWOn+WbvuS4reayoeacieS8mOWFiOWFs+ezu+eahOmhtueCueS5i+mXtOS5n+W7uueri+S4gOenjSjkurrkuLrnmoQp5LyY5YWI5YWz57O744CCXHJcblxyXG4gMiDmi5PmiZHmjpLluo/nrpfms5VcclxuIOeul+azleaAneaDs1xyXG5cclxuIOKRoCDlnKhBT1bnvZHkuK3pgInmi6nkuIDkuKrmsqHmnInliY3pqbHnmoTpobbngrnkuJTovpPlh7rvvJtcclxuIOKRoSDlnKhBT1bnvZHkuK3liKDpmaTor6Xpobbngrnku6Xlj4rku47or6Xpobbngrnlh7rlj5HnmoQo5Lul6K+l6aG254K55Li65bC+55qE5bynKeaJgOacieacieWQkeW8pyjovrkpIO+8m1xyXG4g4pGiIOmHjeWkjeKRoOOAgeKRoe+8jOebtOWIsOWbvuS4reWFqOmDqOmhtueCuemDveW3sui+k+WHuijlm77kuK3ml6Dnjq8p5oiW5Zu+5Lit5LiN5a2Y5Zyo5peg5YmN6amx55qE6aG254K5KOWbvuS4reW/heacieeOrynjgIJcclxuXHJcbiAzICDnrpfms5Xlrp7njrDor7TmmI5cclxuIOKXhiDph4fnlKjmraPpgrvmjqXpk77kvZzkuLpBT1bnvZHnmoTlrZjlgqjnu5PmnoTvvJtcclxuIOKXhiDorr7nq4vloIbmoIjvvIznlKjmnaXmmoLlrZjlhaXluqbkuLow55qE6aG254K577ybXHJcbiDil4Yg5Yig6Zmk6aG254K55Lul5a6D5Li65bC+55qE5byn77ya5byn5aS06aG254K555qE5YWl5bqm5YePMeOAglxyXG5cclxuIOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08obitlKSDjgIJcclxuXHJcbiAqL1xuXG52YXIgdG9wb2xvZ2ljVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2MScpO1xudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3YyJyk7XG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjMnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2NCcpO1xudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3Y1Jyk7XG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjYnKTtcblxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YyJywgJ3YxJyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjQnLCAndjEnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2MycsICd2MScpO1xudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YyJywgJ3YzJyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjMnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NCcsICd2NicpO1xudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjYnKTtcblxuY29uc29sZS5sb2coJ3RvcG9sb2dpY1NvcnQ6ICcpO1xuY29uc29sZS5sb2codG9wb2xvZ2ljVGVzdC50b3BvbG9naWNTb3J0KCkpO1xuXG4vKlxyXG4g5YWz6ZSu6Lev5b6EKENyaXRpY2FsIFBhdGgpXHJcblxyXG4g5LiOQU9W572R55u45a+55bqU55qE5pivQU9FKEFjdGl2aXR5IE9uIEVkZ2UpIO+8jOaYr+i+ueihqOekuua0u+WKqOeahOacieWQkeaXoOeOr+Wbvu+8jOWmguWbvjctMjTmiYDnpLrjgILlm77kuK3pobbngrnooajnpLrkuovku7YoRXZlbnQp77yM5q+P5Liq5LqL5Lu26KGo56S65Zyo5YW25YmN55qE5omA5pyJ5rS75Yqo5bey57uP5a6M5oiQ77yM5YW25ZCO55qE5rS75Yqo5Y+v5Lul5byA5aeL77yb5byn6KGo56S65rS75Yqo77yM5byn5LiK55qE5p2D5YC86KGo56S655u45bqU5rS75Yqo5omA6ZyA55qE5pe26Ze05oiW6LS555So44CCXHJcblxyXG4gMSDkuI5BT0XmnInlhbPnmoTnoJTnqbbpl67pophcclxuIOKXhiDlrozmiJDmlbTkuKrlt6XnqIvoh7PlsJHpnIDopoHlpJrlsJHml7bpl7Q/XHJcbiDil4Yg5ZOq5Lqb5rS75Yqo5piv5b2x5ZON5bel56iL6L+b5bqmKOi0ueeUqCnnmoTlhbPplK4/XHJcbiDlt6XnqIvlrozmiJDmnIDnn63ml7bpl7TvvJrku47otbfngrnliLDnu4jngrnnmoTmnIDplb/ot6/lvoTplb/luqYo6Lev5b6E5LiK5ZCE5rS75Yqo5oyB57ut5pe26Ze05LmL5ZKMKSDjgILplb/luqbmnIDplb/nmoTot6/lvoTnp7DkuLrlhbPplK7ot6/lvoTvvIzlhbPplK7ot6/lvoTkuIrnmoTmtLvliqjnp7DkuLrlhbPplK7mtLvliqjjgILlhbPplK7mtLvliqjmmK/lvbHlk43mlbTkuKrlt6XnqIvnmoTlhbPplK7jgIJcclxuIOiuvnYw5piv6LW354K577yM5LuOdjDliLB2aeeahOacgOmVv+i3r+W+hOmVv+W6puensOS4uuS6i+S7tnZp55qE5pyA5pep5Y+R55Sf5pe26Ze077yM5Y2z5piv5LuldmnkuLrlsL7nmoTmiYDmnInmtLvliqjnmoTmnIDml6nlj5HnlJ/ml7bpl7TjgIJcclxuIOiLpea0u+WKqGFp5piv5bynPGosIGs+77yM5oyB57ut5pe26Ze05pivZHV0KDxqLCBrPinvvIzorr7vvJpcclxuIOKXhiBlKGkp77ya6KGo56S65rS75YqoYWnnmoTmnIDml6nlvIDlp4vml7bpl7TvvJtcclxuIOKXhiBsKGkp77ya5Zyo5LiN5b2x5ZON6L+b5bqm55qE5YmN5o+Q5LiL77yM6KGo56S65rS75YqoYWnnmoTmnIDmmZrlvIDlp4vml7bpl7TvvJsg5YiZbChpKS1lKGkp6KGo56S65rS75YqoYWnnmoTml7bpl7TkvZnph4/vvIzoi6VsKGkpLWUoaSk9MO+8jOihqOekuua0u+WKqGFp5piv5YWz6ZSu5rS75Yqo44CCXHJcbiDil4YgdmUoaSnvvJrooajnpLrkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtO+8jOWNs+S7jui1t+eCueWIsOmhtueCuXZp55qE5pyA6ZW/6Lev5b6E6ZW/5bqm77ybXHJcbiDil4YgdmwoaSnvvJrooajnpLrkuovku7Z2aeeahOacgOaZmuWPkeeUn+aXtumXtOOAguWImeacieS7peS4i+WFs+ezu++8mlxyXG4gZShpKT12ZShqKVxyXG4gbChpKT0gdmwoayktZHV0KDxqLCBrPilcclxuIDAgICAgaj0w77yM6KGo56S6dmrmmK/otbfngrlcclxuIHZlKGopPVxyXG4gTWF4e3ZlKGkpK2R1dCg8aSwgaj4pfDx2aSwgdmo+5piv572R5Lit55qE5bynfVxyXG5cclxuIOWQq+S5ieaYr++8mua6kOeCueS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtOiuvuS4ujDvvJvpmaTmupDngrnlpJbvvIzlj6rmnInov5vlhaXpobbngrl2aueahOaJgOacieW8p+aJgOS7o+ihqOeahOa0u+WKqOWFqOmDqOe7k+adn+WQju+8jOS6i+S7tnZq5omN6IO95Y+R55Sf44CC5Y2z5Y+q5pyJdmrnmoTmiYDmnInliY3pqbHkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtHZlKGkp6K6h566X5Ye65p2l5ZCO77yM5omN6IO96K6h566XdmUoaikg44CCXHJcbiDmlrnms5XmmK/vvJrlr7nmiYDmnInkuovku7bov5vooYzmi5PmiZHmjpLluo/vvIznhLblkI7kvp3mrKHmjInmi5PmiZHpobrluo/orqHnrpfmr4/kuKrkuovku7bnmoTmnIDml6nlj5HnlJ/ml7bpl7TjgIJcclxuIHZlKG4tMSkgICAgaj1uLTHvvIzooajnpLp2auaYr+e7iOeCuVxyXG4gdmwoaik9XHJcbiBNaW57dmwoayktZHV0KDxqLCBrPil8PHZqLCB2az7mmK/nvZHkuK3nmoTlvKd9XHJcbiDlkKvkuYnmmK/vvJrlj6rmnIl2aueahOaJgOacieWQjue7p+S6i+S7tnZr55qE5pyA5pma5Y+R55Sf5pe26Ze0dmwoaynorqHnrpflh7rmnaXlkI7vvIzmiY3og73orqHnrpd2bChqKSDjgIJcclxuIOaWueazleaYr++8muaMieaLk+aJkeaOkuW6j+eahOmAhumhuuW6j++8jOS+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtOOAglxyXG5cclxuXHJcbiAyIOaxgkFPReS4reWFs+mUrui3r+W+hOWSjOWFs+mUrua0u+WKqFxyXG4g4pG0IOeul+azleaAneaDs1xyXG4g4pGgIOWIqeeUqOaLk+aJkeaOkuW6j+axguWHukFPRee9keeahOS4gOS4quaLk+aJkeW6j+WIl++8m1xyXG4g4pGhICDku47mi5PmiZHmjpLluo/nmoTluo/liJfnmoTnrKzkuIDkuKrpobbngrko5rqQ54K5KeW8gOWni++8jOaMieaLk+aJkemhuuW6j+S+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZlKGkpIO+8m1xyXG4g4pGiICDku47mi5PmiZHmjpLluo/nmoTluo/liJfnmoTmnIDlkI7kuIDkuKrpobbngrko5rGH54K5KeW8gOWni++8jOaMiemAhuaLk+aJkemhuuW6j+S+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtHZsKGkpIO+8m1xyXG5cclxuIOiuvkFPRee9keaciW7kuKrkuovku7bvvIxl5Liq5rS75Yqo77yM5YiZ566X5rOV55qE5Li76KaB5omn6KGM5piv77yaXHJcbiDil4Yg6L+b6KGM5ouT5omR5o6S5bqP77ya5pe26Ze05aSN5p2C5bqm5pivTyhuK2UpIO+8m1xyXG4g4peGIOaxguavj+S4quS6i+S7tueahHZl5YC85ZKMdmzlgLzvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg77ybXHJcbiDil4Yg5qC55o2udmXlgLzlkox2bOWAvOaJvuWFs+mUrua0u+WKqO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcclxuIOWboOatpO+8jOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08obitlKSDjgIJcclxuXHJcbiAqL1xuXG52YXIgY3JpdGljYWxQYXRoVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MCcpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YxJyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjInKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MycpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjUnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NicpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y3Jyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjgnKTtcblxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3YxJywgJ3YwJywgMyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjInLCAndjAnLCAxMCk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjQnLCAndjEnLCAxMyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjQnLCAndjInLCAxMik7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjMnLCAndjEnLCA5KTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NScsICd2MicsIDcpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y3JywgJ3Y0JywgNik7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjcnLCAndjMnLCA0KTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NycsICd2NScsIDExKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NicsICd2MycsIDgpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y4JywgJ3Y3JywgNSk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjgnLCAndjYnLCAyKTtcblxuY3JpdGljYWxQYXRoVGVzdC5jcml0aWNhbFBhdGgoKTtcblxudmFyIGRpalRlc3QgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCBbXSwgMCwgMCwgRE4pO1xuXG5kaWpUZXN0LmFkZFZlcnRleCgnMCcpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzEnKTtcbmRpalRlc3QuYWRkVmVydGV4KCcyJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnMycpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzQnKTtcbmRpalRlc3QuYWRkVmVydGV4KCc1Jyk7XG5cbmRpalRlc3QuYWRkQXJjKCcxJywgJzAnLCAyMCk7XG5kaWpUZXN0LmFkZEFyYygnNCcsICcwJywgMTApO1xuZGlqVGVzdC5hZGRBcmMoJzInLCAnMCcsIDYwKTtcbmRpalRlc3QuYWRkQXJjKCc1JywgJzAnLCA2NSk7XG5kaWpUZXN0LmFkZEFyYygnMicsICcxJywgMzApO1xuZGlqVGVzdC5hZGRBcmMoJzMnLCAnMicsIDQwKTtcbmRpalRlc3QuYWRkQXJjKCcyJywgJzUnLCAxNSk7XG5kaWpUZXN0LmFkZEFyYygnNScsICc0JywgMjApO1xuZGlqVGVzdC5hZGRBcmMoJzQnLCAnMycsIDM1KTtcbmRpalRlc3QuYWRkQXJjKCczJywgJzEnLCA3MCk7XG5cbmRpalRlc3Quc2hvcnRlc3RQYXRoX0RpamtzdHJhKDApO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxyXG4gICAgICog6L6T5Ye65pyJ5ZCR5peg546v5Zu+5b2i5byP6KGo56S655qE6YCG5rOi5YWw5byPXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuaUJvTGFuX0RBRyhncmFwaCkge1xuICAgICAgICBncmFwaC5jb3VudEluZGVncmVlKCk7XG4gICAgICAgIGZvciAodmFyIF9pMjAgPSAwOyBfaTIwIDwgZ3JhcGgudmV4bnVtOyArK19pMjApIHtcbiAgICAgICAgICAgIC8vIOaJvuWIsOacieWQkeaXoOeOr+WbvueahOaguVxuICAgICAgICAgICAgaWYgKGdyYXBoLnZlcnRpY2VzW19pMjBdLmluZGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBfaTIwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludE5pQm9MYW4oZ3JhcGgsIGkpIHtcbiAgICAgICAgdmFyIGMgPSBncmFwaC52ZXJ0aWNlc1tpXS5kYXRhO1xuICAgICAgICB2YXIgcCA9IGdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjO1xuXG4gICAgICAgIC8vIOWtkOihqOi+vuW8j1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBwLmFkalZleCk7XG4gICAgICAgICAgICBwcmludE5pQm9MYW4oZ3JhcGgsIHAubmV4dEFyYy5hZGpWZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIOe7meacieWQkeaXoOeOr+WbvuihqOekuueahOihqOi+vuW8j+axguWAvFxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVfREFHKGdyYXBoKSB7XG4gICAgICAgIGdyYXBoLmNvdW50SW5kZWdyZWUoKTtcbiAgICAgICAgZm9yICh2YXIgX2kyMSA9IDA7IF9pMjEgPCBncmFwaC52ZXhudW07ICsrX2kyMSkge1xuICAgICAgICAgICAgaWYgKCFncmFwaC52ZXJ0aWNlc1tfaTIxXS5pbmRlZ3JlZSkgcmV0dXJuIGV2YWx1YXRlX2ltcChncmFwaCwgX2kyMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBldmFsdWF0ZV9pbXAoZywgaSkge1xuICAgICAgICBpZiAoL15cXGQrJC8udGVzdChnLnZlcnRpY2VzW2ldLmRhdGEpKSByZXR1cm4gZy52ZXJ0aWNlc1tpXS5kYXRhO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIHAgPSBnLnZlcnRpY2VzW2ldLmZpcnN0QXJjO1xuICAgICAgICAgICAgdmFyIHYxID0gZXZhbHVhdGVfaW1wKGcsIHAuYWRqVmV4KTtcbiAgICAgICAgICAgIHZhciB2MiA9IGV2YWx1YXRlX2ltcChnLCBwLm5leHRBcmMuYWRqVmV4KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGUodjEsIGcudmVydGljZXNbaV0uZGF0YSwgdjIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlKGEsIG9wZXJhdGlvbiwgYikge1xuICAgICAgICAvLyDlgbfkuIDkuIvmh5IuLlxuICAgICAgICByZXR1cm4gZXZhbChhICsgb3BlcmF0aW9uICsgYik7XG4gICAgfVxuXG4gICAgLy8gKCgxICsgMikgKiAoMiAqICgzICsgNCkpICsgKDMgKyA0KSAqIDUpICogKCgzICsgNCkgKiA1KVxuICAgIHZhciBkYWcgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XG5cbiAgICB2YXIgYTEgPSBuZXcgU3RyaW5nKCcqJyk7XG4gICAgdmFyIGEyID0gbmV3IFN0cmluZygnKycpO1xuICAgIHZhciBhMyA9IG5ldyBTdHJpbmcoJyonKTtcbiAgICB2YXIgYTQgPSBuZXcgU3RyaW5nKCcqJyk7XG4gICAgdmFyIGE1ID0gbmV3IFN0cmluZygnKycpO1xuICAgIHZhciBhNiA9IG5ldyBTdHJpbmcoJyonKTtcbiAgICB2YXIgYTcgPSBuZXcgU3RyaW5nKCcrJyk7XG5cbiAgICAvLyAxMlxuICAgIGRhZy5hZGRWZXJ0ZXgoYTEpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTIpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTMpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTQpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTUpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTYpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTcpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoMSk7XG4gICAgZGFnLmFkZFZlcnRleCgyKTtcbiAgICBkYWcuYWRkVmVydGV4KDMpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoNCk7XG4gICAgZGFnLmFkZFZlcnRleCg1KTtcblxuICAgIC8vIDE0XG4gICAgZGFnLmFkZEFyYyhhMiwgYTEpO1xuICAgIGRhZy5hZGRBcmMoYTQsIGExKTtcbiAgICBkYWcuYWRkQXJjKGEzLCBhMik7XG4gICAgZGFnLmFkZEFyYyhhNCwgYTIpO1xuICAgIGRhZy5hZGRBcmMoYTUsIGEzKTtcbiAgICBkYWcuYWRkQXJjKGE2LCBhMyk7XG4gICAgZGFnLmFkZEFyYyhhNywgYTYpO1xuICAgIGRhZy5hZGRBcmMoYTcsIGE0KTtcbiAgICBkYWcuYWRkQXJjKDUsIGE0KTtcbiAgICBkYWcuYWRkQXJjKDEsIGE1KTtcbiAgICBkYWcuYWRkQXJjKDIsIGE1KTtcbiAgICBkYWcuYWRkQXJjKDIsIGE2KTtcbiAgICBkYWcuYWRkQXJjKDMsIGE3KTtcbiAgICBkYWcuYWRkQXJjKDQsIGE3KTtcblxuICAgIGNvbnNvbGUubG9nKCduaUJvTGFuX0RBRzogJyk7XG4gICAgbmlCb0xhbl9EQUcoZGFnKTtcbiAgICBjb25zb2xlLmxvZygnZXZhbHVhdGVfREFHOiAnICsgZXZhbHVhdGVfREFHKGRhZykpOyAvLyAyNjk1XG59KSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKCcuLi9TdGFjay9pbmRleCcpO1xuXG52YXIgX2luZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luZGV4KTtcblxudmFyIF9RdWV1ZSA9IHJlcXVpcmUoJy4uL1F1ZXVlL1F1ZXVlJyk7XG5cbnZhciBfUXVldWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUXVldWUpO1xuXG52YXIgX0JpbmFyeVRyZWUgPSByZXF1aXJlKCcuLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XG52YXIgREcgPSAxOyAvLyDmnInlkJHlm75cbi8qIGNyZWF0ZSBieSBMdWtlICovXG4vKipcclxuICog5Zu+KEdyYXBoKVxyXG4gKlxyXG4gKiDlm74oR3JhcGgp5piv5LiA56eN5q+U57q/5oCn6KGo5ZKM5qCR5pu05Li65aSN5p2C55qE5pWw5o2u57uT5p6E44CCXHJcbiAqXHJcbiAqIOe6v+aAp+e7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueS4gOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOmZpOesrOS4gOS4quWSjOacgOWQjuS4gOS4quWFg+e0oOWklu+8jOS7u+S9leS4gOS4quWFg+e0oOmDveacieWUr+S4gOeahOS4gOS4quebtOaOpeWJjempseWSjOebtOaOpeWQjue7p+OAglxyXG4gKlxyXG4gKiDmoJHnu5PmnoTvvJrmmK/noJTnqbbmlbDmja7lhYPntKDkuYvpl7TnmoTkuIDlr7nlpJrnmoTlhbPns7vjgILlnKjov5nnp43nu5PmnoTkuK3vvIzmr4/kuKrlhYPntKDlr7nkuIso5bGCKeWPr+S7peaciTDkuKrmiJblpJrkuKrlhYPntKDnm7jogZTns7vvvIzlr7nkuIoo5bGCKeWPquacieWUr+S4gOeahOS4gOS4quWFg+e0oOebuOWFs++8jOaVsOaNruWFg+e0oOS5i+mXtOacieaYjuaYvueahOWxguasoeWFs+ezu+OAglxyXG4gKlxyXG4gKiDlm77nu5PmnoTvvJrmmK/noJTnqbbmlbDmja7lhYPntKDkuYvpl7TnmoTlpJrlr7nlpJrnmoTlhbPns7vjgILlnKjov5nnp43nu5PmnoTkuK3vvIzku7vmhI/kuKTkuKrlhYPntKDkuYvpl7Tlj6/og73lrZjlnKjlhbPns7vjgILljbPnu5PngrnkuYvpl7TnmoTlhbPns7vlj6/ku6XmmK/ku7vmhI/nmoTvvIzlm77kuK3ku7vmhI/lhYPntKDkuYvpl7Tpg73lj6/og73nm7jlhbPjgIJcclxuICpcclxuICog5Zu+55qE5bqU55So5p6B5Li65bm/5rOb77yM5bey5riX5YWl5Yiw6K+45aaC6K+t6KiA5a2m44CB6YC76L6R5a2m44CB54mp55CG44CB5YyW5a2m44CB55S16K6v44CB6K6h566X5py656eR5a2m5Lul5Y+K5pWw5a2m55qE5YW25a6D5YiG5pSv44CCXHJcbiAqXHJcbiAqIOWbvueahOWfuuacrOamguW/tVxyXG4gKlxyXG4gKiDkuIDkuKrlm74oRynlrprkuYnkuLrkuIDkuKrlgbblr7koVixFKSDvvIzorrDkuLpHPShWLEUpIOOAguWFtuS4re+8miBW5piv6aG254K5KFZlcnRleCnnmoTpnZ7nqbrmnInpmZDpm4blkIjvvIzorrDkuLpWKEcp77ybReaYr+aXoOW6j+mbhlYmVueahOS4gOS4quWtkOmbhu+8jOiusOS4ukUoRykg77yM5YW25YWD57Sg5piv5Zu+55qE5bynKEFyYynjgIJcclxuICog5bCG6aG254K56ZuG5ZCI5Li656m655qE5Zu+56ew5Li656m65Zu+44CC5YW25b2i5byP5YyW5a6a5LmJ5Li677yaXHJcbiBHPShWIO+8jEUpXHJcbiBWPXt2fHbiiIhkYXRhIG9iamVjdH1cclxuIEU9ezx2LHc+fCB2LHfiiIhW4oincCh2LHcpfVxyXG4gUCh2LHcp6KGo56S65LuO6aG254K5duWIsOmhtueCuXfmnInkuIDmnaHnm7TmjqXpgJrot6/jgIJcclxuICpcclxuICog5bynKEFyYykg77ya6KGo56S65Lik5Liq6aG254K5duWSjHfkuYvpl7TlrZjlnKjkuIDkuKrlhbPns7vvvIznlKjpobbngrnlgbblr7k8dix3PuihqOekuuOAgumAmuW4uOagueaNruWbvueahOmhtueCueWBtuWvueWwhuWbvuWIhuS4uuacieWQkeWbvuWSjOaXoOWQkeWbvuOAglxyXG4gKiDmnInlkJHlm74oRGlncmFwaCnvvJog6Iul5Zu+R+eahOWFs+ezu+mbhuWQiEUoRynkuK3vvIzpobbngrnlgbblr7k8dix3PueahHblkox35LmL6Ze05piv5pyJ5bqP55qE77yM56ew5Zu+R+aYr+acieWQkeWbvuOAglxyXG4gKiAgIOWcqOacieWQkeWbvuS4re+8jOiLpSA8dix3PuKIiEUoRykg77yM6KGo56S65LuO6aG254K5duWIsOmhtueCuXfmnInkuIDmnaHlvKfjgIIg5YW25Lit77yaduensOS4uuW8p+Wwvih0YWlsKeaIluWni+eCuShpbml0aWFsIG5vZGUp77yMd+ensOS4uuW8p+WktChoZWFkKeaIlue7iOeCuSh0ZXJtaW5hbCBub2RlKSDjgIJcclxuICog5peg5ZCR5Zu+KFVuZGlncmFwaCnvvJog6Iul5Zu+R+eahOWFs+ezu+mbhuWQiEUoRynkuK3vvIzpobbngrnlgbblr7k8dix3PueahHblkox35LmL6Ze05piv5peg5bqP55qE77yM56ew5Zu+R+aYr+aXoOWQkeWbvuOAglxyXG4gKiAgIOWcqOaXoOWQkeWbvuS4re+8jOiLpe+Aojx2LHc+4oiIRShHKSDvvIzmnIk8dyx2PuKIiEUoRykg77yM5Y2zRShHKeaYr+WvueensO+8jOWImeeUqOaXoOW6j+WvuSh2LHcpIOihqOekunblkox35LmL6Ze055qE5LiA5p2h6L65KEVkZ2Up77yM5Zug5q2kKHYsdykg5ZKMKHcsdinku6PooajnmoTmmK/lkIzkuIDmnaHovrnjgIJcclxuICpcclxuICog5L6LMe+8muiuvuacieacieWQkeWbvkcx5ZKM5peg5ZCR5Zu+RzLvvIzlvaLlvI/ljJblrprkuYnliIbliKvmmK/vvJpcclxuIEcxPShWMSDvvIxFMSlcclxuIFYxPXthLGIsYyxkLGV9XHJcbiBFMT17PGEsYj4sPGEsYz4sIDxhLGU+LDxjLGQ+LDxjLGU+ICw8ZCxhPiw8ZCxiPiw8ZSxkPn1cclxuIEcyPShWMiDvvIxFMilcclxuIFYyPXthLGIsYyxkfVxyXG4gRTI9eyhhLGIpLCAoYSxjKSwgKGEsZCksIChiLGQpLCAoYixjKSwgKGMsZCl9XHJcbiAqXHJcbiAqIOWujOWFqOaXoOWQkeWbvu+8muWvueS6juaXoOWQkeWbvu+8jOiLpeWbvuS4remhtueCueaVsOS4um4g77yM55SoZeihqOekuui+ueeahOaVsOebru+8jOWImWUg4oiIWzDvvIxuKG4tMSkvMl0g44CC5YW35pyJbihuLTEpLzLmnaHovrnnmoTml6DlkJHlm77np7DkuLrlrozlhajml6DlkJHlm77jgIJcclxuIOWujOWFqOaXoOWQkeWbvuWPpuWklueahOWumuS5ieaYr++8mlxyXG4gKiDlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZqIOKIiFYg77yM5b2TdmniiaB2auaXtu+8jOaciSh2aSAsdmop4oiIRe+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeaXoOWQkei+ue+8jOi/meagt+eahOaXoOWQkeWbvuensOS4uuWujOWFqOaXoOWQkeWbvuOAglxyXG4gKlxyXG4gKiDlrozlhajmnInlkJHlm77vvJrlr7nkuo7mnInlkJHlm77vvIzoi6Xlm77kuK3pobbngrnmlbDkuLpuIO+8jOeUqGXooajnpLrlvKfnmoTmlbDnm67vvIzliJll4oiIWzDvvIxuKG4tMSldIOOAguWFt+aciW4obi0xKeadoei+ueeahOacieWQkeWbvuensOS4uuWujOWFqOacieWQkeWbvuOAglxyXG4g5a6M5YWo5pyJ5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXHJcbiAqIOWvueS6juacieWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZp77yMdmriiIhWIO+8jOW9k3ZpIOKJoHZq5pe277yM5pyJPHZpICx2aj7iiIhF4oinPHZqICwgdmkgPuKIiEUg77yM5Y2z5Zu+5Lit5Lu75oSP5Lik5Liq5LiN5ZCM55qE6aG254K56Ze06YO95pyJ5LiA5p2h5byn77yM6L+Z5qC355qE5pyJ5ZCR5Zu+56ew5Li65a6M5YWo5pyJ5ZCR5Zu+44CCXHJcbiAqXHJcbiAqIOacieW+iOWwkei+ueaIluW8p+eahOWbvu+8iGU8buOPkm7vvInnmoTlm77np7DkuLrnqIDnlo/lm77vvIzlj43kuYvnp7DkuLrnqKDlr4blm77jgIJcclxuICog5p2DKFdlaWdodCnvvJrkuI7lm77nmoTovrnlkozlvKfnm7jlhbPnmoTmlbDjgILmnYPlj6/ku6XooajnpLrku47kuIDkuKrpobbngrnliLDlj6bkuIDkuKrpobbngrnnmoTot53nprvmiJbogJfotLnjgIJcclxuICpcclxuICog5a2Q5Zu+5ZKM55Sf5oiQ5a2Q5Zu+77ya6K6+5pyJ5Zu+Rz0oVu+8jEUp5ZKMR+KAmT0oVuKAme+8jEXigJkp77yM6IulVuKAmeKIiFbkuJRF4oCZ4oiIRSDvvIzliJnnp7Dlm75H4oCZ5pivR+eahOWtkOWbvu+8m+iLpVbigJk9VuS4lEXigJniiIhF77yM5YiZ56ew5Zu+R+KAmeaYr0fnmoTkuIDkuKrnlJ/miJDlrZDlm77jgIJcclxuICog6aG254K555qE6YK75o6lKEFkamFjZW50Ke+8muWvueS6juaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpei+uSh2LHcp4oiIRe+8jOWImeensOmhtueCuXblkox3IOS6kuS4uumCu+aOpeeCue+8jOWNs3blkox355u46YK75o6l44CC6L65KHYsdynkvp3pmYQoaW5jaWRlbnQp5LiO6aG254K5duWSjHcg44CCXHJcbiAqIOWvueS6juacieWQkeWbvkc9KFYg77yMRSnvvIzoi6XmnInlkJHlvKc8dix3PuKIiEXvvIzliJnnp7Dpobbngrl2IOKAnOmCu+aOpeWIsOKAnemhtueCuXfvvIzpobbngrl3IOKAnOmCu+aOpeiHquKAnemhtueCuXYg77yM5bynPHYsdz4g5LiO6aG254K5duWSjHcg4oCc55u45YWz6IGU4oCdIOOAglxyXG4gKlxyXG4gKiDpobbngrnnmoTluqbjgIHlhaXluqbjgIHlh7rluqbvvJrlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIwg74CidmniiIhW77yM5Zu+R+S4reS+nemZhOS6jnZp55qE6L6555qE5pWw55uu56ew5Li66aG254K5dmnnmoTluqYoZGVncmVlKe+8jOiusOS4ulREKHZpKeOAglxyXG4g5pi+54S277yM5Zyo5peg5ZCR5Zu+5Lit77yM5omA5pyJ6aG254K55bqm55qE5ZKM5piv5Zu+5Lit6L6555qEMuWAjeOAgiDljbMgICDiiJFURCh2aSk9MmUgICAgICBpPTEsIDIsIOKApiwgbiDvvIxl5Li65Zu+55qE6L655pWw44CCXHJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDiiIhWIO+8jOWbvkfkuK3ku6V2aeS9nOS4uui1t+eCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlh7rluqYoT3V0ZGVncmVlKe+8jOiusOS4uk9EKHZpKSDvvJvku6V2aeS9nOS4uue7iOeCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlhaXluqYoSW5kZWdyZWUp77yM6K6w5Li6SUQodmkpIOOAgumhtueCuXZp55qE5Ye65bqm5LiO5YWl5bqm5LmL5ZKM56ew5Li6dmnnmoTluqbvvIzorrDkuLpURCh2aSkg44CC5Y2zXHJcbiBURCh2aSk9T0QodmkpK0lEKHZpKVxyXG4gKlxyXG4gKiDot6/lvoQoUGF0aCnjgIHot6/lvoTplb/luqbjgIHlm57ot68oQ3ljbGUpIO+8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpeS7jumhtueCuXZp57uP6L+H6Iul5bmy5p2h6L656IO95Yiw6L6+dmrvvIznp7Dpobbngrl2aeWSjHZq5piv6L+e6YCa55qE77yM5Y+I56ew6aG254K5dmnliLB2auaciei3r+W+hOOAglxyXG4g5a+55pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM5LuO6aG254K5dmnliLB2auacieacieWQkei3r+W+hO+8jOaMh+eahOaYr+S7jumhtueCuXZp57uP6L+H6Iul5bmy5p2h5pyJ5ZCR6L65KOW8pynog73liLDovr52auOAglxyXG4g5oiW6Lev5b6E5piv5Zu+R+S4rei/nuaOpeS4pOmhtueCueS5i+mXtOaJgOe7j+i/h+eahOmhtueCueW6j+WIl+OAguWNs1xyXG4gUGF0aD12aTB2aTHigKZ2aW0g77yMdmlq4oiIVuS4lCh2aWotMSwgdmlqKeKIiEUgICBqPTEsMiwg4oCmLG1cclxuIOaIllxyXG4gUGF0aD12aTB2aTEg4oCmdmltIO+8jHZpauKIiFbkuJQ8dmlqLTEsIHZpaj7iiIhFICBqPTEsMiwg4oCmLG1cclxuIOi3r+W+hOS4iui+ueaIluacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66K+l6Lev5b6E55qE6ZW/5bqm44CCXHJcbiDlnKjkuIDmnaHot6/lvoTkuK3vvIzoi6XmsqHmnInph43lpI3nm7jlkIznmoTpobbngrnvvIzor6Xot6/lvoTnp7DkuLrnroDljZXot6/lvoTvvJvnrKzkuIDkuKrpobbngrnlkozmnIDlkI7kuIDkuKrpobbngrnnm7jlkIznmoTot6/lvoTnp7DkuLrlm57ot68o546vKe+8m+WcqOS4gOS4quWbnui3r+S4re+8jOiLpemZpOesrOS4gOS4quS4juacgOWQjuS4gOS4qumhtueCueWklu+8jOWFtuS9memhtueCueS4jemHjeWkjeWHuueOsOeahOWbnui3r+ensOS4uueugOWNleWbnui3ryjnroDljZXnjq8p44CCXHJcbiAqXHJcbiAqIOi/numAmuWbvuOAgeWbvueahOi/numAmuWIhumHj++8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZpIO+8jHZqIOKIiFbvvIx2aeWSjHZq6YO95piv6L+e6YCa55qE77yM5YiZ56ew5Zu+R+aYr+i/numAmuWbvu+8jOWQpuWImeensOS4uumdnui/numAmuWbvuOAguiLpUfmmK/pnZ7ov57pgJrlm77vvIzliJnmnoHlpKfnmoTov57pgJrlrZDlm77np7DkuLpH55qE6L+e6YCa5YiG6YeP44CCXHJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDvvIx2aiDiiIhW77yM6YO95pyJ5LuldmnkuLrotbfngrnvvIwgdmog5Li657uI54K55Lul5Y+K5LuldmrkuLrotbfngrnvvIx2aeS4uue7iOeCueeahOacieWQkei3r+W+hO+8jOensOWbvkfmmK/lvLrov57pgJrlm77vvIzlkKbliJnnp7DkuLrpnZ7lvLrov57pgJrlm77jgILoi6VH5piv6Z2e5by66L+e6YCa5Zu+77yM5YiZ5p6B5aSn55qE5by66L+e6YCa5a2Q5Zu+56ew5Li6R+eahOW8uui/numAmuWIhumHj+OAglxyXG4g4oCc5p6B5aSn4oCd55qE5ZCr5LmJ77ya5oyH55qE5piv5a+55a2Q5Zu+5YaN5aKe5Yqg5Zu+R+S4reeahOWFtuWug+mhtueCue+8jOWtkOWbvuWwseS4jeWGjei/numAmuOAglxyXG4g55Sf5oiQ5qCR44CB55Sf5oiQ5qOu5p6X77ya5LiA5Liq6L+e6YCa5Zu+KOaXoOWQkeWbvinnmoTnlJ/miJDmoJHmmK/kuIDkuKrmnoHlsI/ov57pgJrlrZDlm77vvIzlroPlkKvmnInlm77kuK3lhajpg6hu5Liq6aG254K55ZKM5Y+q5pyJ6Laz5Lul5p6E5oiQ5LiA5qO15qCR55qEbi0x5p2h6L6577yM56ew5Li65Zu+55qE55Sf5oiQ5qCR44CCXHJcbiDlhbPkuo7ml6DlkJHlm77nmoTnlJ/miJDmoJHnmoTlh6DkuKrnu5PorrrvvJpcclxuIOKXhiDkuIDmo7XmnIlu5Liq6aG254K555qE55Sf5oiQ5qCR5pyJ5LiU5LuF5pyJbi0x5p2h6L6577ybXHJcbiDil4Yg5aaC5p6c5LiA5Liq5Zu+5pyJbuS4qumhtueCueWSjOWwj+S6jm4tMeadoei+ue+8jOWImeaYr+mdnui/numAmuWbvu+8m1xyXG4g4peGIOWmguaenOWkmuS6jm4tMeadoei+ue+8jOWImeS4gOWumuacieeOr++8m1xyXG4g4peGIOaciW4tMeadoei+ueeahOWbvuS4jeS4gOWumuaYr+eUn+aIkOagkeOAglxyXG5cclxuIOacieWQkeWbvueahOeUn+aIkOajruael+aYr+i/meagt+S4gOS4quWtkOWbvu+8jOeUseiLpeW5suajteacieWQkeagkee7hOaIkO+8jOWQq+acieWbvuS4reWFqOmDqOmhtueCueOAglxyXG4g5pyJ5ZCR5qCR5piv5Y+q5pyJ5LiA5Liq6aG254K555qE5YWl5bqm5Li6MCDvvIzlhbbkvZnpobbngrnnmoTlhaXluqblnYfkuLox55qE5pyJ5ZCR5Zu+44CCXHJcblxyXG4gKlxyXG4gKiDnvZHvvJrmr4/kuKrovrko5oiW5bynKemDvemZhOWKoOS4gOS4quadg+WAvOeahOWbvu+8jOensOS4uuW4puadg+WbvuOAguW4puadg+eahOi/numAmuWbvijljIXmi6zlvLHov57pgJrnmoTmnInlkJHlm74p56ew5Li6572R5oiW572R57uc44CC572R57uc5piv5bel56iL5LiK5bi455So55qE5LiA5Liq5qaC5b+177yM55So5p2l6KGo56S65LiA5Liq5bel56iL5oiW5p+Q56eN5rWB56iLXHJcbiAqL1xuXG4vKipcclxuICog5Zu+55qE5a2Y5YKo57uT5p6EXHJcbiAqXHJcbiDlm77nmoTlrZjlgqjnu5PmnoTmr5TovoPlpI3mnYLvvIzlhbblpI3mnYLmgKfkuLvopoHooajnjrDlnKjvvJpcclxuIOKXhiDku7vmhI/pobbngrnkuYvpl7Tlj6/og73lrZjlnKjogZTns7vvvIzml6Dms5Xku6XmlbDmja7lhYPntKDlnKjlrZjlgqjljLrkuK3nmoTniannkIbkvY3nva7mnaXooajnpLrlhYPntKDkuYvpl7TnmoTlhbPns7vjgIJcclxuIOKXhiDlm77kuK3pobbngrnnmoTluqbkuI3kuIDmoLfvvIzmnInnmoTlj6/og73nm7jlt67lvojlpKfvvIzoi6XmjInluqbmlbDmnIDlpKfnmoTpobbngrnorr7orqHnu5PmnoTvvIzliJnkvJrmtarotLnlvojlpJrlrZjlgqjljZXlhYPvvIzlj43kuYvmjInmr4/kuKrpobbngrnoh6rlt7HnmoTluqborr7orqHkuI3lkIznmoTnu5PmnoTvvIzlj4jkvJrlvbHlk43mk43kvZzjgIJcclxuIOWbvueahOW4uOeUqOeahOWtmOWCqOe7k+aehOacie+8mumCu+aOpeefqemYteOAgemCu+aOpemTvuihqOOAgeWNgeWtl+mTvuihqOOAgemCu+aOpeWkmumHjeihqOWSjOi+ueihqOOAglxyXG4gKi9cblxuLypcclxuIOmCu+aOpeefqemYtSjmlbDnu4Qp6KGo56S65rOVXHJcblxyXG4g5Z+65pys5oCd5oOz77ya5a+55LqO5pyJbuS4qumhtueCueeahOWbvu+8jOeUqOS4gOe7tOaVsOe7hHZleHNbbl3lrZjlgqjpobbngrnkv6Hmga/vvIznlKjkuoznu7TmlbDnu4RBW25dW25d5a2Y5YKo6aG254K55LmL6Ze05YWz57O755qE5L+h5oGv44CC6K+l5LqM57u05pWw57uE56ew5Li66YK75o6l55+p6Zi144CC5Zyo6YK75o6l55+p6Zi15Lit77yM5Lul6aG254K55ZyodmV4c+aVsOe7hOS4reeahOS4i+agh+S7o+ihqOmhtueCue+8jOmCu+aOpeefqemYteS4reeahOWFg+e0oEFbaV1bal3lrZjmlL7nmoTmmK/pobbngrlp5Yiw6aG254K5auS5i+mXtOWFs+ezu+eahOS/oeaBr+OAglxyXG5cclxuIDEgIOaXoOWQkeWbvueahOaVsOe7hOihqOekulxyXG5cclxuICgxKSAg5peg5p2D5Zu+55qE6YK75o6l55+p6Zi1XHJcbiDml6DlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcclxuICAgICAgICAgICAgLS0gMSAgIOiLpSh2aSAsIHZqKeKIiEXvvIzljbN2aSAsIHZq6YK75o6lXHJcbiBBW2ldW2pdPVxyXG4gICAgICAgICAgICAgLS0gMCAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6lXHJcblxyXG4gKDIpICDluKbmnYPlm77nmoTpgrvmjqXnn6npmLVcclxuIOaXoOWQkeW4puadg+Wbvkc9KFbvvIxFKSDnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcclxuICAgICAgICAgICAgLS0gV2lqICAgIOiLpSh2aSAsIHZqKeKIiEXvvIzljbN2aSAsIHZq6YK75o6l77yM5p2D5YC85Li6d2lqXHJcbiBBW2ldW2pdPVxyXG5cclxuICAgICAgICAgICAgLS0g4oieICAg6IulKHZpICwgdmop4oiJRe+8jOWNs3ZpICwgdmrkuI3pgrvmjqXml7ZcclxuXHJcbiAoMykgIOaXoOWQkeWbvumCu+aOpeefqemYteeahOeJueaAp1xyXG4g4peGIOmCu+aOpeefqemYteaYr+WvueensOaWuemYtVxyXG4g4peGIOWvueS6jumhtueCuXZp77yM5YW25bqm5pWw5piv56ysaeihjOeahOmdnjDlhYPntKDnmoTkuKrmlbDvvJtcclxuIOKXhiDml6DlkJHlm77nmoTovrnmlbDmmK/kuIoo5oiW5LiLKeS4ieinkuW9ouefqemYteS4remdnjDlhYPntKDkuKrmlbDjgIJcclxuXHJcbiAyICDmnInlkJHlm77nmoTmlbDnu4TooajnpLpcclxuXHJcbiAoMSkgIOaXoOadg+WbvueahOmCu+aOpeefqemYtVxyXG4g6Iul5pyJ5ZCR5peg5p2D5Zu+Rz0oVu+8jEUp5pyJbihu4omnMSnkuKrpobbngrnvvIzliJnlhbbpgrvmjqXnn6npmLXmmK9u6Zi25a+556ew5pa56Zi144CC5YWD57Sg5a6a5LmJ5aaC5LiL77yaXHJcbiAgICAgICAgICAgIC0tIDEgICDoi6U8dmksIHZqPuKIiEXvvIzku452aeWIsHZq5pyJ5bynXHJcbiBBW2ldW2pdPVxyXG4gICAgICAgICAgICAtLSAwICAg6IulPHZpICwgdmo+4oiJRSAg5LuOdmnliLB2aiDmsqHmnInlvKdcclxuXHJcbiAoMikgIOW4puadg+WbvueahOmCu+aOpeefqemYtVxyXG4g5pyJ5ZCR5bim5p2D5Zu+Rz0oVu+8jEUp55qE6YK75o6l55+p6Zi144CC5YW25YWD57Sg55qE5a6a5LmJ5aaC5LiL77yaXHJcbiAgICAgICAgICAgIC0tIHdpaiAgICDoi6U8dmksdmo+4oiIRe+8jOWNs3ZpICwgdmrpgrvmjqXvvIzmnYPlgLzkuLp3aWpcclxuIEFbaV1bal09XHJcbiAgICAgICAgICAgIOKIniAgIOiLpTx2aSx2aj7iiIlF77yM5Y2zdmkgLCB2auS4jemCu+aOpeaXtlxyXG5cclxuIOKRtiDmnInlkJHlm77pgrvmjqXnn6npmLXnmoTnibnmgKdcclxuIOKXhiDlr7nkuo7pobbngrl2ae+8jOesrGnooYznmoTpnZ4w5YWD57Sg55qE5Liq5pWw5piv5YW25Ye65bqmT0Qodmkp77yb56ysaeWIl+eahOmdnjDlhYPntKDnmoTkuKrmlbDmmK/lhbblhaXluqZJRCh2aSkg44CCXHJcbiDil4Yg6YK75o6l55+p6Zi15Lit6Z2eMOWFg+e0oOeahOS4quaVsOWwseaYr+WbvueahOW8p+eahOaVsOebruOAglxyXG5cclxuIDMgIOWbvueahOmCu+aOpeefqemYteeahOaTjeS9nFxyXG5cclxuIOWbvueahOmCu+aOpeefqemYteeahOWunueOsOavlOi+g+WuueaYk++8jOWumuS5ieS4pOS4quaVsOe7hOWIhuWIq+WtmOWCqOmhtueCueS/oeaBryjmlbDmja7lhYPntKAp5ZKM6L655oiW5byn55qE5L+h5oGvKOaVsOaNruWFg+e0oOS5i+mXtOeahOWFs+ezuykg44CCXHJcblxyXG4gKi9cblxudmFyIEROID0gMjsgLy8g5pyJ5ZCR572RXG52YXIgVURHID0gMzsgLy8g5peg5ZCR5Zu+XG52YXIgVUROID0gNDsgLy8g5peg5ZCR572RXG5cbnZhciBBcmNDZWxsID1cbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYWRqXHJcbiAqIEBwYXJhbSB7Kn0gaW5mb1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5mdW5jdGlvbiBBcmNDZWxsKGFkaikge1xuICAgIHZhciBpbmZvID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBBcmNDZWxsKTtcblxuICAgIC8vIOmhtueCueexu+Wei+OAguWvueS6juaXoOadg+Wbvu+8jOeUqDHmiJYw6KGo56S655u46YK75ZCm77yb5a+55bim5p2D5Zu+77yM5YiZ5Li65p2D5YC857G75Z6LXG4gICAgdGhpcy5hZGogPSB0eXBlb2YgYWRqID09PSAnbnVtYmVyJyA/IGFkaiA6IEluZmluaXR5O1xuICAgIC8vIOivpeW8p+ebuOWFs+S/oeaBr1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG59O1xuXG52YXIgQWRqYWNlbmN5TWF0cml4R3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmV4cyDpobbngrnlkJHph49cclxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBBcmNDZWxsfSBhcmNzIOmCu+aOpeefqemYtVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyY251bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtpbmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBZGphY2VuY3lNYXRyaXhHcmFwaCgpIHtcbiAgICAgICAgdmFyIHZleHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFyY3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZleG51bSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBhcmNudW0gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzNdO1xuICAgICAgICB2YXIga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IERHIDogYXJndW1lbnRzWzRdO1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBBZGphY2VuY3lNYXRyaXhHcmFwaCk7XG5cbiAgICAgICAgLy8g6aG254K55ZCR6YePXG4gICAgICAgIHRoaXMudmV4cyA9IHZleHM7XG4gICAgICAgIC8vIOmCu+aOpeefqemYtVxuICAgICAgICB0aGlzLmFyY3MgPSBhcmNzO1xuICAgICAgICAvLyDlm77nmoTlvZPliY3pobbngrnmlbBcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW07XG4gICAgICAgIC8vIOWbvueahOW9k+WJjeW8p+aVsFxuICAgICAgICB0aGlzLmFyY251bSA9IGFyY251bTtcbiAgICAgICAgLy8g5Zu+55qE56eN57G75qCH5b+XXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoQWRqYWNlbmN5TWF0cml4R3JhcGgsIFt7XG4gICAgICAgIGtleTogJ2NyZWF0ZUdyYXBoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUdyYXBoKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERHOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlREcodGhpcyk7IC8vIOaehOmAoOacieWQkeWbvlxuICAgICAgICAgICAgICAgIGNhc2UgRE46XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVETih0aGlzKTsgLy8g5p6E6YCg5pyJ5ZCR572RXG4gICAgICAgICAgICAgICAgY2FzZSBVREc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVREcodGhpcyk7IC8vIOaehOmAoOaXoOWQkeWbvlxuICAgICAgICAgICAgICAgIGNhc2UgVUROOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVUROKHRoaXMpOyAvLyDmnoTpgKDml6DlkJHnvZFcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+mdnuacieaViOeahOWbvuexu+WeiycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5p+l5om+6aG254K5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsb2NhdGVWZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYXRlVmV4KHZwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXhzW2ldID09PSB2cCkgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWQkeWbvuS4reWinuWKoOmhtueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdnAg6aG254K55ZCR6YePXHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZFZlcnRleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRWZXJ0ZXgodnApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2F0ZVZleCh2cCkgIT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBoYXMgZXhpc3RlZCEnKTtcblxuICAgICAgICAgICAgdmFyIGsgPSB0aGlzLnZleG51bTtcbiAgICAgICAgICAgIHRoaXMudmV4c1t0aGlzLnZleG51bSsrXSA9IHZwO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmtpbmQgPT09IERHIHx8IHRoaXMua2luZCA9PT0gVURHID8gMCA6IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNzW2pdID0gdGhpcy5hcmNzW2pdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjc1trXSA9IHRoaXMuYXJjc1trXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10gPSB0aGlzLmFyY3Nbal1ba10gfHwgbmV3IEFyY0NlbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY3Nba11bal0gPSB0aGlzLmFyY3Nba11bal0gfHwgbmV3IEFyY0NlbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10uYWRqID0gdGhpcy5hcmNzW2tdW2pdLmFkaiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5ZCR5Zu+5Lit5aKe5Yqg5LiA5p2h5bynXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2ZXgxIOmhtueCuTHlkJHph49cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZleDIg6aG254K5MuWQkemHj1xyXG4gICAgICAgICAqIEBwYXJhbSB7QXJjQ2VsbH0gYXJjXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEFyYycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBcmModmV4MSwgdmV4MiwgYXJjKSB7XG4gICAgICAgICAgICBhcmMgPSBhcmMgfHwgbmV3IEFyY0NlbGwodGhpcy5raW5kID09PSBERyB8fCB0aGlzLmtpbmQgPT09IFVERyA/IDEgOiAnd2VpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgayA9IHRoaXMubG9jYXRlVmV4KHZleDEpO1xuICAgICAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleCh2ZXgyKTtcblxuICAgICAgICAgICAgaWYgKGsgPT09IC0xIHx8IGogPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0FyY1xcJ3MgVmVydGV4IGRvIG5vdCBleGlzdGVkIScpO1xuXG4gICAgICAgICAgICB0aGlzLmFyY3Nba11bal0uYWRqID0gYXJjLmFkajtcbiAgICAgICAgICAgIHRoaXMuYXJjc1trXVtqXS5pbmZvID0gYXJjLmluZm87XG4gICAgICAgICAgICAvLyDml6DlkJHlm77miJbml6DlkJHnvZFcbiAgICAgICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFVERyB8fCB0aGlzLmtpbmQgPT09IFVETikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5hZGogPSBhcmMuYWRqO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5pbmZvID0gYXJjLmluZm87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICsrdGhpcy5hcmNudW07XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yig6Zmk6aG254K5XHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZleCDopoHliKDpmaTnmoTpobbngrlcclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVsZXRlVmV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVZleCh2ZXgpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy52ZXhudW0gLSAxO1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmxvY2F0ZVZleCh2ZXgpO1xuXG4gICAgICAgICAgICBpZiAobSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8g5bCG5b6F5Yig6Zmk6aG254K55Lqk5o2i5Yiw5pyA5ZCO5LiA5Liq6aG254K5XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMudmV4c1ttXTtcbiAgICAgICAgICAgIHRoaXMudmV4c1ttXSA9IHRoaXMudmV4c1tuXTtcbiAgICAgICAgICAgIHRoaXMudmV4c1tuXSA9IHRlbXA7XG5cbiAgICAgICAgICAgIC8vIOWwhui+ueeahOWFs+ezu+maj+S5i+S6pOaNolxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNzW2ldW21dID0gdGhpcy5hcmNzW2ldW25dO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjc1ttXVtpXSA9IHRoaXMuYXJjc1tuXVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hcmNzW21dW21dLmFkaiA9IDA7XG4gICAgICAgICAgICB0aGlzLnZleHMubGVuZ3RoID0gLS10aGlzLnZleG51bTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yig6Zmk6L65KHYsIHcpXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gd1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZWxldGVBcmMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQXJjKHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5sb2NhdGVWZXgodik7XG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KHcpO1xuXG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1tpXVtqXS5hZGopIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY3NbaV1bal0uYWRqID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIpOaWreS4gOS4qumCu+aOpeefqemYteWtmOWCqOeahOacieWQkeWbvuaYr+WQpuWPr+S8oOmAklxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1Bhc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNQYXNzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMua2luZCAhPT0gREcpIHRocm93IG5ldyBFcnJvcignZ3JhcGgga2luZCBzaG91bGQgYmUgREcnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLnZleG51bTsgKyt4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLnZleG51bTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbeF1beV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgdGhpcy52ZXhudW07ICsreikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuYXJjc1t5XVt6XSAmJiAhdGhpcy5hcmNzW3hdW3pdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmaXJzdEFkalZleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdEFkalZleCh2KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSBJbmZpbml0eSkgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbmV4dEFkalZleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0QWRqVmV4KHYsIHcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB3ICsgMTsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSBJbmZpbml0eSkgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWvuemCu+aOpeefqemYteWbvuS9nOmAkuW9kuW8j+a3seW6puS8mOWFiOmBjeWOhlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdERlNUcmF2ZXJzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBERlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgLy8g6K6/6Zeu5qCH5b+X5pWw57uE5Yid5aeL5YyWXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgICAgICB9Zm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMudmV4bnVtOyArK19pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW19pXSkgZGZzKHRoaXMsIF9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2ZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW3ZlcnRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChncmFwaCwgdmVydGV4KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IDAgJiYgZ3JhcGguYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gSW5maW5pdHkgJiYgIXZpc2l0ZWRbal0pIGRmcyhncmFwaCwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g6Z2e6YCS5b2SXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ0RGU1RyYXZlcnNlX05vblJlY3Vyc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XG4gICAgICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gbmV3IF9pbmRleDIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIC8vIOiuv+mXruagh+W/l+aVsOe7hOWIneWni+WMllxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgfWZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMudmV4bnVtOyArK19pMikge1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtfaTJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goX2kyKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtfaTJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKG1lLCBfaTIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgodmVydGV4ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gSW5maW5pdHkgJiYgIXZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKG1lLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5a+56YK75o6l55+p6Zi15Zu+5L2c5bm/5bqm5LyY5YWI6YGN5Y6GXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ0JGU1RyYXZlcnNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIEJGU1RyYXZlcnNlKHZpc2l0Rm4pIHtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkID0gW107XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBuZXcgX1F1ZXVlMi5kZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1mb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0aGlzLnZleG51bTsgKytfaTMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbX2kzXSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW19pM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgX2kzKTtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShfaTMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHF1ZXVlLmRlUXVldWUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t1XVtqXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3VdW2pdLmFkaiAhPT0gSW5maW5pdHkgJiYgIXZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21pblNwYW5UcmVlX1BSSU0nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWluU3BhblRyZWVfUFJJTSh1KSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VkZ2UgPSBbXTtcblxuICAgICAgICAgICAgLy8g5Yid5aeL5YyWXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICBjbG9zZWRnZVtqXSA9IHsgYWRqdmV4OiB1LCBsb3djb3N0OiArdGhpcy5hcmNzW2pdW3VdLmFkaiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2VkZ2VbdV0ubG93Y29zdCA9IDA7XG5cbiAgICAgICAgICAgIHZhciB0ZSA9IFtdO1xuICAgICAgICAgICAgLy8g6YCJ5oup5YW25L2ZdGhpcy52ZXhudW0gLSAx5Liq6aG254K5XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgdGhpcy52ZXhudW0gLSAxOyArK19qKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIHZhciBrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkZ2Vbdl0ubG93Y29zdCAhPT0gMCAmJiBjbG9zZWRnZVt2XS5sb3djb3N0IDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBjbG9zZWRnZVt2XS5sb3djb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZVtfal0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZleDE6IGNsb3NlZGdlW2tdLmFkanZleCxcbiAgICAgICAgICAgICAgICAgICAgdmV4MjogayxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBjbG9zZWRnZVtrXS5sb3djb3N0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbG9zZWRnZVtrXS5sb3djb3N0ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfdiA9IDA7IF92IDwgdGhpcy52ZXhudW07ICsrX3YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1tfdl1ba10uYWRqIDwgY2xvc2VkZ2VbX3ZdLmxvd2Nvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZGdlW192XS5sb3djb3N0ID0gdGhpcy5hcmNzW192XVtrXS5hZGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWRnZVtfdl0uYWRqdmV4ID0gaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtaW5TcGFuVHJlZV9LcnVza2FsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pblNwYW5UcmVlX0tydXNrYWwoKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gW107XG4gICAgICAgICAgICB2YXIgdGUgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2V0W2ldID0gaTtcbiAgICAgICAgICAgIH12YXIgayA9IDA7XG4gICAgICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoayA8IHRoaXMudmV4bnVtIC0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHRoaXMudmV4bnVtOyArK19pNCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gX2k0ICsgMTsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbX2k0XVtqXS5hZGogPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0aGlzLmFyY3NbX2k0XVtqXS5hZGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF9pNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXRbYV0gIT09IHNldFtiXSkge1xuICAgICAgICAgICAgICAgICAgICB0ZVtrKytdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmV4MTogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZleDI6IGIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXMuYXJjc1thXVtiXS5hZGpcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCB0aGlzLnZleG51bTsgKytfaTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXRbX2k1XSA9PT0gc2V0W2JdICYmIF9pNSAhPT0gYikgc2V0W19pNV0gPSBzZXRbYV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0W2JdID0gc2V0W2FdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1pbiA9IHRoaXMuYXJjc1thXVtiXS5hZGogPSBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog55SoRGlqa3N0cmHnrpfms5XmsYLmnInlkJHnvZHnmoR2MOmhtueCueWIsOWFtuS9memhtueCuXbnmoTmnIDnn63ot6/lvoRwcmVbdl3lj4rlhbbluKbmnYPplb/luqZkaXN0W3Zd44CCXHJcbiAgICAgICAgICog6IulcHJlW3ZdW3dd5Li6dHJ1Ze+8jOWImXfmmK/ku452MOWIsHblvZPliY3msYLlvpfmnIDnn63ot6/lvoTkuIrnmoTpobbngrnjgIJcclxuICAgICAgICAgKiBmaW5hbFt2XeS4unRydWXlvZPkuJTku4XlvZN24oiIU++8jOWNs+W3sue7j+axguW+l3Yw5YiwdueahOacgOefrei3r+W+hFxyXG4gICAgICAgICAqIEBwYXJhbSB2MFxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaG9ydGVzdFBhdGhfRGlqa3N0cmEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvcnRlc3RQYXRoX0RpamtzdHJhKHYwKSB7XG4gICAgICAgICAgICB2YXIgcHJlID0gW107XG4gICAgICAgICAgICB2YXIgZGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGZpbmFsID0gW107XG4gICAgICAgICAgICB2YXIgdyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB2ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfdjIgPSAwOyBfdjIgPCB0aGlzLnZleG51bTsgKytfdjIpIHtcbiAgICAgICAgICAgICAgICBmaW5hbFtfdjJdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGlzdFtfdjJdID0gdGhpcy5hcmNzW3YwXVtfdjJdLmFkajtcbiAgICAgICAgICAgICAgICBwcmVbX3YyXSA9IHByZVtfdjJdIHx8IFtdO1xuICAgICAgICAgICAgICAgIC8vIOiuvuepuui3r+W+hFxuICAgICAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVtfdjJdW3ddID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfWlmIChkaXN0W192Ml0gPCBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVbX3YyXVt2MF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmVbX3YyXVtfdjJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWIneWni+WMlu+8jHYw6aG254K55bGe5LqOU+mbhlxuICAgICAgICAgICAgZGlzdFt2MF0gPSAwO1xuICAgICAgICAgICAgZmluYWxbdjBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8g5byA5aeL5Li75b6q546v77yM5q+P5qyh5rGC5b6XdjDliLDmn5DkuKp26aG254K555qE5pyA55+t6Lev5b6E77yM5bm25YqgduWIsFPpm4ZcblxuICAgICAgICAgICAgLy8g5YW25L2Z55qE6aG254K5XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgLy8g5b2T5YmN5omA5oyH56a7djDpobbngrnnmoTmnIDov5Hot53nprtcbiAgICAgICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xuICAgICAgICAgICAgICAgICAgICAvLyB36aG254K55ZyoViAtIFPkuK1cbiAgICAgICAgICAgICAgICAgICAgLy8g5LiUd+mhtueCueemu3Yw6aG254K55pu06L+RXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgZGlzdFt3XSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0W3ddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g56a7djDpobbngrnmnIDov5HnmoR25Yqg5YWlU+mbhlxuICAgICAgICAgICAgICAgIGZpbmFsW3ZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyDmm7TmlrDlvZPliY3mnIDnn63ot6/lvoTlj4rot53nprtcbiAgICAgICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbmFsW3ddICYmIG1pbiArIHRoaXMuYXJjc1t2XVt3XS5hZGogPCBkaXN0W3ddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0W3ddID0gbWluICsgdGhpcy5hcmNzW3ZdW3ddLmFkajtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVt3XVt3XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHByZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkaXN0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaW5hbDogZmluYWwsXG4gICAgICAgICAgICAgICAgcHJlOiBwcmUsXG4gICAgICAgICAgICAgICAgZGlzdDogZGlzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2hvcnRlc3RQYXRoX0ZMT1lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3J0ZXN0UGF0aF9GTE9ZRCgpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICBhW2pdID0gYVtqXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBwYXRoW2pdID0gcGF0aFtqXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMudmV4bnVtOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGspIGFbal1ba10gPSAwO2Vsc2UgYVtqXVtrXSA9IHRoaXMuYXJjc1tqXVtrXS5hZGo7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhbal1ba10gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHRoaXMudmV4bnVtOyArK19qMikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgdGhpcy52ZXhudW07ICsrX2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW19qMl1bbV0gKyBhW21dW19rXSA8IGFbX2oyXVtfa10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW19qMl1bX2tdID0gYVtfajJdW21dICsgYVttXVtfa107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFtfajJdW19rXSA9IG07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IHRoaXMudmV4bnVtOyArK19qMykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9rMiA9IDA7IF9rMiA8IHRoaXMudmV4bnVtOyArK19rMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2ozICE9PSBfazIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZOWIsCVk55qE5pyA55+t6Lev5b6E5Li677yaJywgX2ozLCBfazIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIF9qMyk7cHJuX3Bhc3MoX2ozLCBfazIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIF9rMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn5pyA55+t6Lev5b6E6ZW/5bqm5Li677yaICVkJywgYVtfajNdW19rMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm5fcGFzcyhqLCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbal1ba10gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBybl9wYXNzKGosIHBhdGhbal1ba10pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLCAlZCcsIHBhdGhbal1ba10pO1xuICAgICAgICAgICAgICAgICAgICBwcm5fcGFzcyhwYXRoW2pdW2tdLCBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEFkamFjZW5jeU1hdHJpeEdyYXBoO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBZGphY2VuY3lNYXRyaXhHcmFwaDtcblxuXG52YXIgY3JlYXRlREcgPSBjcmVhdGVHcmFwaChERyk7XG52YXIgY3JlYXRlRE4gPSBjcmVhdGVHcmFwaChETik7XG52YXIgY3JlYXRlVURHID0gY3JlYXRlR3JhcGgoVURHKTtcbnZhciBjcmVhdGVVRE4gPSBjcmVhdGVHcmFwaChVRE4pO1xuXG5mdW5jdGlvbiBjcmVhdGVHcmFwaChraW5kKSB7XG4gICAgdmFyIGFkaiA9IHZvaWQgMDtcbiAgICB2YXIgc2V0TWF0cml4VmFsdWUgPSB2b2lkIDA7XG5cbiAgICBpZiAoa2luZCA9PT0gMiB8fCBraW5kID09PSA0KSB7XG4gICAgICAgIGFkaiA9IEluZmluaXR5O1xuICAgICAgICBzZXRNYXRyaXhWYWx1ZSA9IGZ1bmN0aW9uIHNldE1hdHJpeFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21wdCgnd2VpZ2h0OiAnKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhZGogPSAwO1xuICAgICAgICBzZXRNYXRyaXhWYWx1ZSA9IGZ1bmN0aW9uIHNldE1hdHJpeFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChBZGphY2VuY3lNYXRyaXhHcmFwaCkge1xuICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW0gPSBwYXJzZUludChwcm9tcHQoJ3ZleG51bTogJyksIDEwKTtcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtID0gcGFyc2VJbnQocHJvbXB0KCdhcmNudW06ICcpLCAxMCk7XG4gICAgICAgIC8vIGluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXG4gICAgICAgIHZhciBpbmNJbmZvID0gcGFyc2VJbnQocHJvbXB0KCdpbmNJbmZvOiAnKSwgMTApO1xuXG4gICAgICAgIC8vIOaehOmAoOmhtueCueWQkemHj1xuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGogPSB2b2lkIDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4c1tpXSA9IHByb21wdCgn6aG254K55ZCR6YePdmV4OiAnKTtcbiAgICAgICAgfSAvLyDliJ3lp4vljJbpgrvmjqXnn6npmLVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldID0gQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdID0gbmV3IEFyY0NlbGwoYWRqLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOaehOmAoOmCu+aOpeefqemYtVxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY251bTsgKytrKSB7XG4gICAgICAgICAgICAvLyDovpPlhaXkuIDmnaHovrnkvp3pmYTnmoTpobbngrnlj4rmnYPlgLxcbiAgICAgICAgICAgIHZhciB2MSA9IHByb21wdCgndjE6ICcpO1xuICAgICAgICAgICAgdmFyIHYyID0gcHJvbXB0KCd2MjogJyk7XG5cbiAgICAgICAgICAgIC8vIOehruWumnYx77yMdjLlnKhH5Lit55qE5L2N572uXG4gICAgICAgICAgICBpID0gQWRqYWNlbmN5TWF0cml4R3JhcGgubG9jYXRlVmV4KHYxKTtcbiAgICAgICAgICAgIGogPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5sb2NhdGVWZXgodjIpO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHNldE1hdHJpeFZhbHVlKCk7XG4gICAgICAgICAgICAvLyDlvKc8djEsIHYyPueahOadg+WAvFxuICAgICAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXS5hZGogPSB3O1xuICAgICAgICAgICAgaWYgKGluY0luZm8pIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal0uaW5mbyA9IHByb21wdCgnaW5mbzogJyk7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gMyB8fCBraW5kID09PSA0KSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2pdW2ldID0gQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIOesrOS4gOenjeWIm+W7uuWbvuaWueazlVxudmFyIHZleHMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xudmFyIGFyY3MgPSBbW3sgXCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogXCIyXCIsIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsIH1dLCBbeyBcImFkalwiOiBcIjZcIiwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBcIjRcIiwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGwgfV0sIFt7IFwiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbCB9LCB7IFwiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbCB9LCB7IFwiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbCB9LCB7IFwiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbCB9LCB7IFwiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbCB9XSwgW3sgXCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogXCIxXCIsIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsIH0sIHsgXCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsIH1dLCBbeyBcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBcIjVcIiwgXCJpbmZvXCI6IG51bGwgfSwgeyBcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGwgfV1dO1xudmFyIHVkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaCh2ZXhzLCBhcmNzLCA1LCA3LCA0KTtcblxuLy8g56ys5LqM56eN5Yib5bu65Zu+5pa55rOVXG52YXIgZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCAyKTtcbmRuLmFkZFZlcnRleCgnYScpO1xuZG4uYWRkVmVydGV4KCdiJyk7XG5kbi5hZGRWZXJ0ZXgoJ2MnKTtcbmRuLmFkZFZlcnRleCgnZCcpO1xuZG4uYWRkVmVydGV4KCdlJyk7XG5cbmRuLmFkZEFyYygnYScsICdiJywge1xuICAgIGFkajogNlxufSk7XG5kbi5hZGRBcmMoJ2EnLCAnYycsIHtcbiAgICBhZGo6IDJcbn0pO1xuZG4uYWRkQXJjKCdjJywgJ2InLCB7XG4gICAgYWRqOiAzXG59KTtcbmRuLmFkZEFyYygnYycsICdkJywge1xuICAgIGFkajogMVxufSk7XG5kbi5hZGRBcmMoJ2QnLCAnYicsIHtcbiAgICBhZGo6IDRcbn0pO1xuZG4uYWRkQXJjKCdiJywgJ2UnLCB7XG4gICAgYWRqOiAzXG59KTtcbmRuLmFkZEFyYygnZCcsICdlJywge1xuICAgIGFkajogNVxufSk7XG5cbmNvbnNvbGUubG9nKGRuKTtcblxuLypcclxuXHJcbiAvLyDnrKzkuInnp43liJvlu7rlm77mlrnms5VcclxuIGxldCBnID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKCk7XHJcbiBnLmtpbmQgPSBETjtcclxuIGcuY3JlYXRlR3JhcGgoKTtcclxuIGNvbnNvbGUubG9nKGcpO1xyXG5cclxuICovXG5cbi8qXHJcbiDlm77nmoTpgY3ljoZcclxuXHJcbiDlm77nmoTpgY3ljoYoVHJhdmVyaW5nIEdyYXBoKe+8muS7juWbvueahOafkOS4gOmhtueCueWHuuWPke+8jOiuv+mBjeWbvuS4reeahOWFtuS9memhtueCue+8jOS4lOavj+S4qumhtueCueS7heiiq+iuv+mXruS4gOasoeOAguWbvueahOmBjeWOhueul+azleaYr+WQhOenjeWbvueahOaTjeS9nOeahOWfuuehgOOAglxyXG5cclxuIOKXhiDlpI3mnYLmgKfvvJrlm77nmoTku7vmhI/pobbngrnlj6/og73lkozlhbbkvZnnmoTpobbngrnnm7jpgrvmjqXvvIzlj6/og73lnKjorr/pl67kuobmn5DkuKrpobbngrnlkI7vvIzmsr/mn5DmnaHot6/lvoTmkJzntKLlkI7lj4jlm57liLDljp/pobbngrnjgIJcclxuIOKXhiDop6PlhrPlip7ms5XvvJrlnKjpgY3ljobov4fnqIvkuK3orrDkuIvlt7Looqvorr/pl67ov4fnmoTpobbngrnjgILorr7nva7kuIDkuKrovoXliqnlkJHph49WaXNpdGVkWzHigKZuXShu5Li66aG254K55pWwKe+8jOWFtuWIneWAvOS4ujDvvIzkuIDml6borr/pl67kuobpobbngrl2aeWQju+8jOS9v1Zpc2l0ZWRbaV3kuLox5oiW5Li66K6/6Zeu55qE5qyh5bqP5Y+344CCXHJcbiDlm77nmoTpgY3ljobnrpfms5XmnInmt7HluqbkvJjlhYjmkJzntKLnrpfms5Xlkozlub/luqbkvJjlhYjmkJzntKLnrpfms5XjgIJcclxuXHJcbiDmt7HluqbkvJjlhYjmkJzntKIoRGVwdGggRmlyc3QgU2VhcmNoLS1ERlMp6YGN5Y6G57G75Ly85qCR55qE5YWI5bqP6YGN5Y6G77yM5piv5qCR55qE5YWI5bqP6YGN5Y6G55qE5o6o5bm/44CCXHJcblxyXG4g566X5rOV5oCd5oOzXHJcbiDorr7liJ3lp4vnirbmgIHml7blm77kuK3nmoTmiYDmnInpobbngrnmnKrooqvorr/pl67vvIzliJnvvJpcclxuIOKRtCDvvJrku47lm77kuK3mn5DkuKrpobbngrl2aeWHuuWPke+8jOiuv+mXrnZp77yb54S25ZCO5om+5YiwdmnnmoTkuIDkuKrpgrvmjqXpobbngrl2aTEg77ybXHJcbiDikbXvvJrku452aTHlh7rlj5HvvIzmt7HluqbkvJjlhYjmkJzntKLorr/pl67lkox2aTHnm7jpgrvmjqXkuJTmnKrooqvorr/pl67nmoTmiYDmnInpobbngrnvvJtcclxuIOKRtu+8mui9rOKRtCDvvIznm7TliLDlkox2aeebuOmCu+aOpeeahOaJgOaciemhtueCuemDveiiq+iuv+mXruS4uuatolxyXG4g4pG3IO+8mue7p+e7remAieWPluWbvuS4reacquiiq+iuv+mXrumhtueCuXZq5L2c5Li66LW35aeL6aG254K577yM6L2sKDEp77yM55u05Yiw5Zu+5Lit5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2i44CCXHJcblxyXG5cclxuIOW5v+W6puS8mOWFiOaQnOe0oihCcmVhZHRoIEZpcnN0IFNlYXJjaC0tQkZTKemBjeWOhuexu+S8vOagkeeahOaMieWxguasoemBjeWOhueahOi/h+eoi+OAglxyXG5cclxuIOeul+azleaAneaDs1xyXG4g6K6+5Yid5aeL54q25oCB5pe25Zu+5Lit55qE5omA5pyJ6aG254K55pyq6KKr6K6/6Zeu77yM5YiZ77yaXHJcbiDikbQg77ya5LuO5Zu+5Lit5p+Q5Liq6aG254K5dmnlh7rlj5HvvIzorr/pl652ae+8m1xyXG4g4pG177ya6K6/6ZeudmnnmoTmiYDmnInnm7jpgrvmjqXkuJTmnKrooqvorr/pl67nmoTmiYDmnInpobbngrl2aTHvvIx2aTLvvIzigKbvvIx2aW3vvJtcclxuIOKRtu+8muS7pXZpMe+8jHZpMu+8jCDigKbvvIx2aW3nmoTmrKHluo/vvIzku6V2aWooMeKJpmriiaZtKeS+neatpOS9nOS4unZpIO+8jOi9rOKRtO+8m1xyXG4g4pG3IO+8mue7p+e7remAieWPluWbvuS4reacquiiq+iuv+mXrumhtueCuXZr5L2c5Li66LW35aeL6aG254K577yM6L2s4pG077yM55u05Yiw5Zu+5Lit5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2i44CCXHJcblxyXG4g55So5bm/5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+5LiO5rex5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+55qE5ZSv5LiA5Yy65Yir5piv6YK75o6l54K55pCc57Si5qyh5bqP5LiN5ZCMLlxyXG4gKi9cblxuY29uc29sZS5sb2coJ0RGU1RyYXZlcnNlOiB1ZG4nKTtcblxudmFyIGcxID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgVURHKTtcbmcxLmFkZFZlcnRleCgndjEnKTtcbmcxLmFkZFZlcnRleCgndjMnKTtcbmcxLmFkZFZlcnRleCgndjInKTtcbmcxLmFkZFZlcnRleCgndjQnKTtcbmcxLmFkZFZlcnRleCgndjUnKTtcblxuZzEuYWRkQXJjKCd2NScsICd2NCcpO1xuZzEuYWRkQXJjKCd2MycsICd2MScpO1xuZzEuYWRkQXJjKCd2MicsICd2MScpO1xuZzEuYWRkQXJjKCd2MycsICd2MicpO1xuXG5nMS5ERlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmV4c1t2XSk7XG59KTtcblxuY29uc29sZS5sb2coJ0RGU1RyYXZlcnNlX05vblJlY3Vyc2U6IHVkbicpO1xuZzEuREZTVHJhdmVyc2VfTm9uUmVjdXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmV4c1t2XSk7XG59KTtcblxuY29uc29sZS5sb2coJ0JGU1RyYXZlcnNlOiAnKTtcbnZhciBic2ZHID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgREcpO1xuYnNmRy5hZGRWZXJ0ZXgoJ3YxJyk7XG5ic2ZHLmFkZFZlcnRleCgndjInKTtcbmJzZkcuYWRkVmVydGV4KCd2MycpO1xuYnNmRy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5ic2ZHLmFkZFZlcnRleCgndjUnKTtcblxuYnNmRy5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XG5ic2ZHLmFkZEFyYygndjEnLCAndjInKTtcbmJzZkcuYWRkQXJjKCd2MycsICd2NScpO1xuYnNmRy5hZGRBcmMoJ3YzJywgJ3YyJyk7XG5ic2ZHLmFkZEFyYygndjMnLCAndjEnKTtcbmJzZkcuYWRkQXJjKCd2NCcsICd2MycpO1xuYnNmRy5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5cbmJzZkcuQkZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xufSk7XG5cbi8qXHJcbiDmnIDlsI/nlJ/miJDmoJFcclxuXHJcbiDlpoLmnpzov57pgJrlm77mmK/kuIDkuKrluKbmnYPlm77vvIzliJnlhbbnlJ/miJDmoJHkuK3nmoTovrnkuZ/luKbmnYPvvIznlJ/miJDmoJHkuK3miYDmnInovrnnmoTmnYPlgLzkuYvlkoznp7DkuLrnlJ/miJDmoJHnmoTku6Pku7fjgIJcclxuXHJcbiDmnIDlsI/nlJ/miJDmoJEoTWluaW11bSBTcGFubmluZyBUcmVlKSDvvJrluKbmnYPov57pgJrlm77kuK3ku6Pku7fmnIDlsI/nmoTnlJ/miJDmoJHnp7DkuLrmnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiDmnIDlsI/nlJ/miJDmoJHlnKjlrp7pmYXkuK3lhbfmnInph43opoHnlKjpgJTvvIzlpoLorr7orqHpgJrkv6HnvZHjgILorr7lm77nmoTpobbngrnooajnpLrln47luILvvIzovrnooajnpLrkuKTkuKrln47luILkuYvpl7TnmoTpgJrkv6Hnur/ot6/vvIzovrnnmoTmnYPlgLzooajnpLrlu7rpgKDpgJrkv6Hnur/ot6/nmoTotLnnlKjjgIJu5Liq5Z+O5biC5LmL6Ze05pyA5aSa5Y+v5Lul5bu6bu+CtChuLTEpLzLmnaHnur/ot6/vvIzlpoLkvZXpgInmi6nlhbbkuK3nmoRuLTHmnaHvvIzkvb/mgLvnmoTlu7rpgKDotLnnlKjmnIDkvY4/XHJcblxyXG4g5p6E6YCg5pyA5bCP55Sf5oiQ5qCR55qE566X5rOV5pyJ6K645aSa77yM5Z+65pys5Y6f5YiZ5piv77yaXHJcbiDil4Yg5bC95Y+v6IO96YCJ5Y+W5p2D5YC85pyA5bCP55qE6L6577yM5L2G5LiN6IO95p6E5oiQ5Zue6Lev77ybXHJcbiDil4Yg6YCJ5oupbi0x5p2h6L655p6E5oiQ5pyA5bCP55Sf5oiQ5qCR44CCXHJcbiDku6XkuIrnmoTln7rmnKzljp/liJnmmK/ln7rkuo5NU1TnmoTlpoLkuIvmgKfotKjvvJpcclxuIOiuvkc9KFbvvIxFKeaYr+S4gOS4quW4puadg+i/numAmuWbvu+8jFXmmK/pobbngrnpm4ZW55qE5LiA5Liq6Z2e56m65a2Q6ZuG44CC6IuldeKIiFUg77yMduKIiFYtVe+8jOS4lCh1LCB2KeaYr1XkuK3pobbngrnliLBWLVXkuK3pobbngrnkuYvpl7TmnYPlgLzmnIDlsI/nmoTovrnvvIzliJnlv4XlrZjlnKjkuIDmo7XljIXlkKvovrkodSwgdinnmoTmnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiDor4HmmI7vvJog55So5Y+N6K+B5rOV6K+B5piO44CCXHJcbiDorr7lm75H55qE5Lu75L2V5LiA5qO15pyA5bCP55Sf5oiQ5qCR6YO95LiN5YyF5ZCr6L65KHUsdinjgILorr5U5pivR+eahOS4gOajteeUn+aIkOagke+8jOWImVTmmK/ov57pgJrnmoTvvIzku4515YiwduW/heacieS4gOadoei3r+W+hCh1LOKApix2Ke+8jOW9k+Wwhui+uSh1LHYp5Yqg5YWl5YiwVOS4reaXtuWwseaehOaIkOS6huWbnui3r+OAguWImei3r+W+hCh1LCDigKYsdinkuK3lv4XmnInkuIDmnaHovrkodeKAmSx24oCZKSDvvIzmu6HotrN14oCZ4oiIVSDvvIx24oCZ4oiIVi1VIOOAguWIoOWOu+i+uSh14oCZLHbigJkpIOS+v+WPr+a2iOmZpOWbnui3r++8jOWQjOaXtuW+l+WIsOWPpuS4gOajteeUn+aIkOagkVTigJnjgIJcclxuIOeUseS6jih1LHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOaVhSh1LHYp55qE5p2D5YC85LiN5Lya6auY5LqOKHXigJksduKAmSnnmoTmnYPlgLzvvIxU4oCZ55qE5Luj5Lu35Lmf5LiN5Lya6auY5LqOVO+8jCBU4oCZ5piv5YyF5ZCrKHUsdikg55qE5LiA5qO15pyA5bCP55Sf5oiQ5qCR77yM5LiO5YGH6K6+55+b55u+44CCXHJcblxyXG4gKi9cblxuLypcclxuIOaZrumHjOWnhihQcmltKeeul+azlVxyXG5cclxuIOmAguWQiOi+ueeooOWvhueahOe9kVxyXG5cclxuIOS7jui/numAmue9kU49KFXvvIxFKeS4reaJvuacgOWwj+eUn+aIkOagkVQ9KFXvvIxURSkg44CCXHJcblxyXG4gMSDnrpfms5XmgJ3mg7NcclxuIOKRtCAg6Iul5LuO6aG254K5djDlh7rlj5HmnoTpgKDvvIxVPXt2MH3vvIxURT17fe+8m1xyXG4g4pG1IOWFiOaJvuadg+WAvOacgOWwj+eahOi+uSh177yMdinvvIzlhbbkuK114oiIVeS4lHbiiIhWLVXvvIzlubbkuJTlrZDlm77kuI3mnoTmiJDnjq/vvIzliJlVPSBV4oiqe3Z977yMVEU9VEXiiKp7KHXvvIx2KX0g77ybXHJcbiDikbYg6YeN5aSN4pG1IO+8jOebtOWIsFU9VuS4uuatouOAguWImVRF5Lit5b+F5pyJbi0x5p2h6L6577yMIFQ9KFXvvIxURSnlsLHmmK/mnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiAyLueul+azleWunueOsOivtOaYjlxyXG4g5Li65L6/5LqO566X5rOV5a6e546w77yM6K6+572u5LiA5Liq5LiA57u05pWw57uEY2xvc2VkZ2Vbbl3vvIznlKjmnaXkv53lrZhWLSBV5Lit5ZCE6aG254K55YiwVeS4remhtueCueWFt+acieadg+WAvOacgOWwj+eahOi+ueOAglxyXG4gY2xvc2VkZ2Vbal0uYWRqdmV4PWvvvIzooajmmI7ovrkodmosIHZrKeaYr1YtVeS4remhtueCuXZq5YiwVeS4readg+WAvOacgOWwj+eahOi+ue+8jOiAjOmhtueCuXZr5piv6K+l6L655omA5L6d6ZmE55qEVeS4reeahOmhtueCueOAgiBjbG9zZWRnZVtqXS5sb3djb3N05a2Y5pS+6K+l6L6555qE5p2D5YC844CCXHJcbiDlgYforr7ku47pobbngrl2c+W8gOWni+aehOmAoOacgOWwj+eUn+aIkOagkeOAguWIneWni+aXtuS7pO+8mlxyXG4gQ2xvc2VkZ2Vbc10ubG93Y29zdD0wIO+8muihqOaYjumhtueCuXZz6aaW5YWI5Yqg5YWl5YiwVeS4re+8m1xyXG4gQ2xvc2VkZ2Vba10uYWRqdmV4PXMg77yMQ2xvc2VkZ2Vba10ubG93Y29zdD1jb3N0KGssIHMpXHJcbiDooajnpLpWLVXkuK3nmoTlkITpobbngrnliLBV5Lit5p2D5YC85pyA5bCP55qE6L65KGviiaBzKSDvvIxjb3N0KGssIHMp6KGo56S66L65KHZrLCB2cykg5p2D5YC844CCXHJcblxyXG4gMy7nrpfms5XmraXpqqRcclxuIOKRtCAg5LuOY2xvc2VkZ2XkuK3pgInmi6nkuIDmnaHmnYPlgLwo5LiN5Li6MCnmnIDlsI/nmoTovrkodmssIHZqKSDvvIznhLblkI7lgZrvvJpcclxuIOKRoCDnva5jbG9zZWRnZVtrXS5sb3djb3N05Li6MCDvvIzooajnpLp2a+W3suWKoOWFpeWIsFXkuK3jgIJcclxuIOKRoSAg5qC55o2u5paw5Yqg5YWldmvnmoTmm7TmlrBjbG9zZWRnZeS4reavj+S4quWFg+e0oO+8mlxyXG4g74CidmniiIhWLVUg77yM6IulY29zdChpLCBrKeKJpmNvbHNlZGdlW2ldLmxvd2Nvc3TvvIzooajmmI7lnKhV5Lit5paw5Yqg5YWl6aG254K5dmvlkI7vvIwgKHZpLCB2aynmiJDkuLp2aeWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIznva7vvJpcclxuIENsb3NlZGdlW2ldLmxvd2Nvc3Q9Y29zdChpLCBrKVxyXG4gQ2xvc2VkZ2VbaV0uYWRqdmV4PWtcclxuIOKRtSAg6YeN5aSN4pG0bi0x5qyh5bCx5b6X5Yiw5pyA5bCP55Sf5oiQ5qCR44CCXHJcblxyXG4g566X5rOV5YiG5p6Q77yaXHJcbiDorr7luKbmnYPov57pgJrlm77mnIlu5Liq6aG254K577yM5YiZ566X5rOV55qE5Li76KaB5omn6KGM5piv5LqM6YeN5b6q546v77yaIOaxgmNsb3NlZGdl5Lit5p2D5YC85pyA5bCP55qE6L6577yM6aKR5bqm5Li6bi0x77ybIOS/ruaUuWNsb3NlZGdl5pWw57uE77yM6aKR5bqm5Li6biDjgILlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4yKe+8jOS4jui+ueeahOaVsOebruaXoOWFs+OAglxyXG5cclxuICovXG5cbnVkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIDQpO1xudWRuLmFkZFZlcnRleCgndjEnKTtcbnVkbi5hZGRWZXJ0ZXgoJ3YyJyk7XG51ZG4uYWRkVmVydGV4KCd2MycpO1xudWRuLmFkZFZlcnRleCgndjQnKTtcbnVkbi5hZGRWZXJ0ZXgoJ3Y1Jyk7XG51ZG4uYWRkVmVydGV4KCd2NicpO1xuXG51ZG4uYWRkQXJjKCd2MScsICd2MicsIHsgYWRqOiA2IH0pO1xudWRuLmFkZEFyYygndjEnLCAndjMnLCB7IGFkajogMSB9KTtcbnVkbi5hZGRBcmMoJ3YxJywgJ3Y0JywgeyBhZGo6IDUgfSk7XG51ZG4uYWRkQXJjKCd2MicsICd2MycsIHsgYWRqOiA1IH0pO1xudWRuLmFkZEFyYygndjInLCAndjUnLCB7IGFkajogMyB9KTtcbnVkbi5hZGRBcmMoJ3YzJywgJ3Y0JywgeyBhZGo6IDUgfSk7XG51ZG4uYWRkQXJjKCd2MycsICd2NScsIHsgYWRqOiA2IH0pO1xudWRuLmFkZEFyYygndjMnLCAndjYnLCB7IGFkajogNCB9KTtcbnVkbi5hZGRBcmMoJ3Y0JywgJ3Y2JywgeyBhZGo6IDIgfSk7XG51ZG4uYWRkQXJjKCd2NScsICd2NicsIHsgYWRqOiA2IH0pO1xuXG5jb25zb2xlLmxvZygnbWluU3BhblRyZWVfUFJJTTogJyk7XG5jb25zb2xlLmxvZyh1ZG4ubWluU3BhblRyZWVfUFJJTSgwKSk7XG5cbi8qXHJcbiDlhYvpsoHmlq/ljaHlsJQoS3J1c2thbCnnrpfms5VcclxuXHJcbiDpgILlkIjovrnnqIDnlo/nmoTnvZFcclxuXHJcbiAxIOeul+azleaAneaDs1xyXG4g6K6+Rz0oViwgRSnmmK/lhbfmnIlu5Liq6aG254K555qE6L+e6YCa572R77yMVD0oVSwgVEUp5piv5YW25pyA5bCP55Sf5oiQ5qCR44CC5Yid5YC877yaVT1W77yMVEU9e30g44CCXHJcbiDlr7lH5Lit55qE6L655oyJ5p2D5YC85aSn5bCP5LuO5bCP5Yiw5aSn5L6d5qyh6YCJ5Y+W44CCXHJcbiDikbQgICDpgInlj5bmnYPlgLzmnIDlsI/nmoTovrkodmnvvIx2ainvvIzoi6XovrkodmnvvIx2ainliqDlhaXliLBUReWQjuW9ouaIkOWbnui3r++8jOWImeiIjeW8g+ivpei+uSjovrkodmnvvIx2aikg77yb5ZCm5YiZ77yM5bCG6K+l6L655bm25YWl5YiwVEXkuK3vvIzljbNURT1UReKIqnsodmnvvIx2ail9IOOAglxyXG4g4pG1IOmHjeWkjeKRtCDvvIznm7TliLBUReS4reWMheWQq+aciW4tMeadoei+ueS4uuatouOAglxyXG4g5aaC5Zu+Ny0yMuaJgOaPkOekuuOAglxyXG5cclxuIDIg566X5rOV5a6e546w6K+05piOXHJcbiBLcnVza2Fs566X5rOV5a6e546w55qE5YWz6ZSu5piv77ya5b2T5LiA5p2h6L655Yqg5YWl5YiwVEXnmoTpm4blkIjlkI7vvIzlpoLkvZXliKTmlq3mmK/lkKbmnoTmiJDlm57ot68/XHJcbiDnroDljZXnmoTop6PlhrPmlrnms5XmmK/vvJrlrprkuYnkuIDkuKrkuIDnu7TmlbDnu4RWc2V0W25dIO+8jOWtmOaUvuWbvlTkuK3mr4/kuKrpobbngrnmiYDlnKjnmoTov57pgJrliIbph4/nmoTnvJblj7fjgIJcclxuIOKXhiDliJ3lgLzvvJpWc2V0W2ldPWnvvIzooajnpLrmr4/kuKrpobbngrnlkIToh6rnu4TmiJDkuIDkuKrov57pgJrliIbph4/vvIzov57pgJrliIbph4/nmoTnvJblj7fnroDljZXlnLDkvb/nlKjpobbngrnlnKjlm77kuK3nmoTkvY3nva4o57yW5Y+3KeOAglxyXG4g4peGIOW9k+W+gFTkuK3lop7liqDkuIDmnaHovrkodmnvvIx2aikg5pe277yM5YWI5qOA5p+lVnNldFtpXeWSjFZzZXRbal3lgLzvvJpcclxuIOKYhiDoi6VWc2V0W2ldPVZzZXRbal3vvJrooajmmI52aeWSjHZq5aSE5Zyo5ZCM5LiA5Liq6L+e6YCa5YiG6YeP5Lit77yM5Yqg5YWl5q2k6L655Lya5b2i5oiQ5Zue6Lev77ybXHJcbiDimIYg6IulVnNldFtpXeKJoFZzZXRbal3vvIzliJnliqDlhaXmraTovrnkuI3kvJrlvaLmiJDlm57ot6/vvIzlsIbmraTovrnliqDlhaXliLDnlJ/miJDmoJHnmoTovrnpm4bkuK3jgIJcclxuIOKXhiDliqDlhaXkuIDmnaHmlrDovrnlkI7vvIzlsIbkuKTkuKrkuI3lkIznmoTov57pgJrliIbph4/lkIjlubbvvJrlsIbkuIDkuKrov57pgJrliIbph4/nmoTnvJblj7fmjaLmiJDlj6bkuIDkuKrov57pgJrliIbph4/nmoTnvJblj7fjgIJcclxuXHJcbiAqL1xuXG5jb25zb2xlLmxvZygnbWluU3BhblRyZWVfS3J1c2thbDogJyk7XG5jb25zb2xlLmxvZyh1ZG4ubWluU3BhblRyZWVfS3J1c2thbCgpKTtcblxuLypcclxuIOacgOefrei3r+W+hFxyXG5cclxuIOiLpeeUqOW4puadg+WbvuihqOekuuS6pOmAmue9ke+8jOWbvuS4remhtueCueihqOekuuWcsOeCue+8jOi+ueS7o+ihqOS4pOWcsOS5i+mXtOacieebtOaOpemBk+i3r++8jOi+ueS4iueahOadg+WAvOihqOekuui3r+eoiyjmiJbmiYDoirHotLnnlKjmiJbml7bpl7QpIOOAguS7juS4gOS4quWcsOaWueWIsOWPpuS4gOS4quWcsOaWueeahOi3r+W+hOmVv+W6puihqOekuuivpei3r+W+hOS4iuWQhOi+ueeahOadg+WAvOS5i+WSjOOAgumXrumimO+8mlxyXG4g4peGIOS4pOWcsOS5i+mXtOaYr+WQpuaciemAmui3rz9cclxuIOKXhiDlnKjmnInlpJrmnaHpgJrot6/nmoTmg4XlhrXkuIvvvIzlk6rmnaHmnIDnn60/XHJcbiDogIPomZHliLDkuqTpgJrnvZHnmoTmnInlkJHmgKfvvIznm7TmjqXorqjorrrnmoTmmK/luKbmnYPmnInlkJHlm77nmoTmnIDnn63ot6/lvoTpl67popjvvIzkvYbop6PlhrPpl67popjnmoTnrpfms5XkuZ/pgILnlKjkuo7ml6DlkJHlm77jgIJcclxuIOWwhuS4gOS4qui3r+W+hOeahOi1t+Wni+mhtueCueensOS4uua6kOeCue+8jOacgOWQjuS4gOS4qumhtueCueensOS4uue7iOeCueOAglxyXG5cclxuXHJcbiDljZXmupDngrnmnIDnn63ot6/lvoRcclxuXHJcbiDlr7nkuo7nu5nlrprnmoTmnInlkJHlm75HPShW77yMRSnlj4rljZXkuKrmupDngrlWc++8jOaxglZz5YiwR+eahOWFtuS9meWQhOmhtueCueeahOacgOefrei3r+W+hOOAglxyXG4g6ZKI5a+55Y2V5rqQ54K555qE5pyA55+t6Lev5b6E6Zeu6aKY77yMRGlqa3N0cmHmj5Dlh7rkuobkuIDnp43mjInot6/lvoTplb/luqbpgJLlop7mrKHluo/kuqfnlJ/mnIDnn63ot6/lvoTnmoTnrpfms5XvvIzljbPov6rmnbDmlq/nibnmi4koRGlqa3N0cmEp566X5rOV44CCXHJcblxyXG4gMSDln7rmnKzmgJ3mg7NcclxuIOS7juWbvueahOe7meWumua6kOeCueWIsOWFtuWug+WQhOS4qumhtueCueS5i+mXtOWuouinguS4iuW6lOWtmOWcqOS4gOadoeacgOefrei3r+W+hO+8jOWcqOi/mee7hOacgOefrei3r+W+hOS4re+8jOaMieWFtumVv+W6pueahOmAkuWinuasoeW6j++8jOS+neasoeaxguWHuuWIsOS4jeWQjOmhtueCueeahOacgOefrei3r+W+hOWSjOi3r+W+hOmVv+W6puOAglxyXG4g5Y2z5oyJ6ZW/5bqm6YCS5aKe55qE5qyh5bqP55Sf5oiQ5ZCE6aG254K555qE5pyA55+t6Lev5b6E77yM5Y2z5YWI5rGC5Ye66ZW/5bqm5pyA5bCP55qE5LiA5p2h5pyA55+t6Lev5b6E77yM54S25ZCO5rGC5Ye66ZW/5bqm56ys5LqM5bCP55qE5pyA55+t6Lev5b6E77yM5L6d5q2k57G75o6o77yM55u05Yiw5rGC5Ye66ZW/5bqm5pyA6ZW/55qE5pyA55+t6Lev5b6E44CCXHJcblxyXG4gMiDnrpfms5XmgJ3mg7Por7TmmI5cclxuIOiuvue7meWumua6kOeCueS4ulZz77yMU+S4uuW3suaxguW+l+acgOefrei3r+W+hOeahOe7iOeCuembhu+8jOW8gOWni+aXtuS7pFM9e1ZzfSDjgILlvZPmsYLlvpfnrKzkuIDmnaHmnIDnn63ot6/lvoQoVnMg77yMVmkp5ZCO77yMU+S4untWc++8jFZpfSDjgILmoLnmja7ku6XkuIvnu5Porrrlj6/msYLkuIvkuIDmnaHmnIDnn63ot6/lvoTjgIJcclxuIOiuvuS4i+S4gOadoeacgOefrei3r+W+hOe7iOeCueS4ulZqIO+8jOWImVZq5Y+q5pyJ77yaXHJcbiDil4YgIOa6kOeCueWIsOe7iOeCueacieebtOaOpeeahOW8pzxWc++8jFZqPu+8m1xyXG4g4peGIOS7jlZzIOWHuuWPkeWIsFZqIOeahOi/meadoeacgOefrei3r+W+hOaJgOe7j+i/h+eahOaJgOacieS4remXtOmhtueCueW/heWumuWcqFPkuK3jgILljbPlj6rmnInov5nmnaHmnIDnn63ot6/lvoTnmoTmnIDlkI7kuIDmnaHlvKfmiY3mmK/ku45T5YaF5p+Q5Liq6aG254K56L+e5o6l5YiwU+WklueahOmhtueCuVZqIOOAglxyXG4g6Iul5a6a5LmJ5LiA5Liq5pWw57uEZGlzdFtuXe+8jOWFtuavj+S4qmRpc3RbaV3liIbph4/kv53lrZjku45WcyDlh7rlj5HkuK3pl7Tlj6rnu4/ov4fpm4blkIhT5Lit55qE6aG254K56ICM5Yiw6L6+VmnnmoTmiYDmnInot6/lvoTkuK3plb/luqbmnIDlsI/nmoTot6/lvoTplb/luqblgLzvvIzliJnkuIvkuIDmnaHmnIDnn63ot6/lvoTnmoTnu4jngrlWauW/heWumuaYr+S4jeWcqFPkuK3kuJTlgLzmnIDlsI/nmoTpobbngrnvvIzljbPvvJpcclxuIGRpc3RbaV09TWlueyBkaXN0W2tdfCBWa+KIiFYtUyB9XHJcbiDliKnnlKjkuIrov7DlhazlvI/lsLHlj6/ku6Xkvp3mrKHmib7lh7rkuIvkuIDmnaHmnIDnn63ot6/lvoTjgIJcclxuXHJcbiAzICDnrpfms5XmraXpqqRcclxuIOKRoCDku6RTPXtWc30g77yM55So5bim5p2D55qE6YK75o6l55+p6Zi16KGo56S65pyJ5ZCR5Zu+77yM5a+55Zu+5Lit5q+P5Liq6aG254K5VmnmjInku6XkuIvljp/liJnnva7liJ3lgLzvvJpcclxuIDAgICAgaSA9c1xyXG4gZGlzdFtpXSA9ICAgV3NpICAgICBp4omgc+S4lDx2cyx2aT7iiIhF77yMIHdzaeS4uuW8p+S4iueahOadg+WAvFxyXG4g4oieICAgaeKJoHPkuJQ8dnMsdmk+5LiN5bGe5LqORVxyXG4g4pGhIOmAieaLqeS4gOS4qumhtueCuVZqIO+8jOS9v+W+l++8mlxyXG4gZGlzdFtqXT1NaW57IGRpc3Rba118IFZr4oiIVi1TIH1cclxuIFZq5bCx5piv5rGC5b6X55qE5LiL5LiA5p2h5pyA55+t6Lev5b6E57uI54K577yM5bCGVmog5bm25YWl5YiwU+S4re+8jOWNs1M9U+KIqntWan0g44CCXHJcbiDikaIg5a+5Vi1T5Lit55qE5q+P5Liq6aG254K5Vmsg77yM5L+u5pS5ZGlzdFtrXe+8jOaWueazleaYr++8mlxyXG4g6IulZGlzdFtqXStXams8ZGlzdFtrXe+8jOWImeS/ruaUueS4uu+8mlxyXG4gZGlzdFtrXT1kaXN0W2pdK1dqayAo74CiVmviiIhWLVMgKVxyXG4g4pGjIOmHjeWkjeKRoe+8jOKRou+8jOebtOWIsFM9VuS4uuatouOAglxyXG5cclxuIDQg566X5rOV5a6e546wXHJcbiDnlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIwg5a+5UHJpbeeul+azleeVpeWKoOaUueWKqOWwseaIkOS6hkRpamtzdHJh566X5rOV77yM5bCGUHJpbeeul+azleS4reaxguavj+S4qumhtueCuVZr55qEbG93Y29zdOWAvOeUqGRpc3Rba13ku6Pmm7/ljbPlj6/jgIJcclxuIOKXhiAg6K6+5pWw57uEcHJlW25d5L+d5a2Y5LuOVnPliLDlhbblroPpobbngrnnmoTmnIDnn63ot6/lvoTjgILoi6VwcmVbaV09a++8jOihqOekuuS7jlZzIOWIsFZp55qE5pyA55+t6Lev5b6E5Lit77yMVmnnmoTliY3kuIDkuKrpobbngrnmmK9Wa++8jOWNs+acgOefrei3r+W+hOW6j+WIl+aYryhWcyAsIOKApiwgVmsgICwgVmkpIOOAglxyXG4g4peGIOiuvuaVsOe7hGZpbmFsW25d77yM5qCH6K+G5LiA5Liq6aG254K55piv5ZCm5bey5Yqg5YWlU+S4reOAglxyXG5cclxuIDUgIOeul+azleWIhuaekFxyXG4gRGlqa3N0cmHnrpfms5XnmoTkuLvopoHmiafooYzmmK/vvJpcclxuIOKXhiDmlbDnu4Tlj5jph4/nmoTliJ3lp4vljJbvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4pIO+8m1xyXG4g4peGIOaxguacgOefrei3r+W+hOeahOS6jOmHjeW+queOr++8muaXtumXtOWkjeadguW6puaYr08objIpIO+8m1xyXG4g5Zug5q2k77yM5pW05Liq566X5rOV55qE5pe26Ze05aSN5p2C5bqm5pivTyhuMikg44CCXHJcblxyXG4gKi9cblxudmFyIGRpalRlc3QgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XG5cbmRpalRlc3QuYWRkVmVydGV4KCcwJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnMScpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzInKTtcbmRpalRlc3QuYWRkVmVydGV4KCczJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnNCcpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzUnKTtcblxuZGlqVGVzdC5hZGRBcmMoJzAnLCAnMScsIHsgYWRqOiAyMCB9KTtcbmRpalRlc3QuYWRkQXJjKCcwJywgJzQnLCB7IGFkajogMTAgfSk7XG5kaWpUZXN0LmFkZEFyYygnMCcsICcyJywgeyBhZGo6IDYwIH0pO1xuZGlqVGVzdC5hZGRBcmMoJzAnLCAnNScsIHsgYWRqOiA2NSB9KTtcbmRpalRlc3QuYWRkQXJjKCcxJywgJzInLCB7IGFkajogMzAgfSk7XG5kaWpUZXN0LmFkZEFyYygnMicsICczJywgeyBhZGo6IDQwIH0pO1xuZGlqVGVzdC5hZGRBcmMoJzUnLCAnMicsIHsgYWRqOiAxNSB9KTtcbmRpalRlc3QuYWRkQXJjKCc0JywgJzUnLCB7IGFkajogMjAgfSk7XG5kaWpUZXN0LmFkZEFyYygnMycsICc0JywgeyBhZGo6IDM1IH0pO1xuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMycsIHsgYWRqOiA3MCB9KTtcblxuZGlqVGVzdC5zaG9ydGVzdFBhdGhfRGlqa3N0cmEoMCk7XG5cbi8qXHJcbiDmr4/kuIDlr7npobbngrnpl7TnmoTmnIDnn63ot6/lvoRcclxuXHJcbiDnlKhEaWprc3RyYeeul+azleS5n+WPr+S7peaxguW+l+acieWQkeWbvkc9KFbvvIxFKeS4reavj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hOOAguaWueazleaYr++8muavj+asoeS7peS4gOS4quS4jeWQjOeahOmhtueCueS4uua6kOeCuemHjeWkjURpamtzdHJh566X5rOV5L6/5Y+v5rGC5b6X5q+P5LiA5a+56aG254K56Ze055qE5pyA55+t6Lev5b6E77yM5pe26Ze05aSN5p2C5bqm5pivTyhuMykg44CCXHJcblxyXG4g5byX572X5LyK5b63KEZsb3lkKeaPkOWHuuS6huWPpuS4gOS4queul+azle+8jOWFtuaXtumXtOWkjeadguW6puS7jeaYr08objMpIO+8jCDkvYbnrpfms5XlvaLlvI/mm7TkuLrnroDmmI7jgIJcclxuXHJcbiAxIOeul+azleaAneaDs1xyXG5cclxuIOiuvumhtueCuembhlMo5Yid5YC85Li656m6Ke+8jOeUqOaVsOe7hEHnmoTmr4/kuKrlhYPntKBBW2ldW2pd5L+d5a2Y5LuOVmnlj6rnu4/ov4dT5Lit55qE6aG254K55Yiw6L6+VmrnmoTmnIDnn63ot6/lvoTplb/luqbvvIzlhbbmgJ3mg7PmmK/vvJpcclxuIOKRoCDliJ3lp4vml7bku6RTPXsgfSDvvIwgQVtpXVtqXeeahOi1i+WIneWAvOaWueW8j+aYr++8mlxyXG4gMCAgICBpID1q5pe2XHJcbiBBW2ldW2pdPSAgICBXaWogICAgIGniiaBq5LiUPHZpLHZqPuKIiEXvvIwgd2lq5Li65byn5LiK55qE5p2D5YC8XHJcbiDiiJ4gICBp4omgauS4lDx2aSx2aj7kuI3lsZ7kuo5FXHJcbiDikaEg5bCG5Zu+5Lit5LiA5Liq6aG254K5Vmsg5Yqg5YWl5YiwU+S4re+8jOS/ruaUuUFbaV1bal3nmoTlgLzvvIzkv67mlLnmlrnms5XmmK/vvJpcclxuIEFbaV1bal09TWlue0FbaV1bal0gLCAoQVtpXVtrXStBW2tdW2pdKSB9XHJcbiDljp/lm6DvvJog5LuOVmrlj6rnu4/ov4dT5Lit55qE6aG254K5KFZrKeWIsOi+vlZq55qE6Lev5b6E6ZW/5bqm5Y+v6IO95q+U5Y6f5p2l5LiN57uP6L+HVmvnmoTot6/lvoTmm7Tnn63jgIJcclxuIOKRoiDph43lpI3ikaHvvIznm7TliLBH55qE5omA5pyJ6aG254K56YO95Yqg5YWl5YiwU+S4reS4uuatouOAglxyXG5cclxuIDIg566X5rOV5a6e546wXHJcblxyXG4g4peGICDlrprkuYnkuoznu7TmlbDnu4RQYXRoW25dW25dKG7kuLrlm77nmoTpobbngrnmlbApIO+8jOWFg+e0oFBhdGhbaV1bal3kv53lrZjku45WaeWIsFZq55qE5pyA55+t6Lev5b6E5omA57uP6L+H55qE6aG254K544CCXHJcbiDil4Yg6IulUGF0aFtpXVtqXT1r77ya5LuOVmnliLBWaiDnu4/ov4dWayDvvIzmnIDnn63ot6/lvoTluo/liJfmmK8oVmkgLCDigKYsIFZrICwg4oCmLCBWaikg77yM5YiZ6Lev5b6E5a2Q5bqP5YiX77yaKFZpICwg4oCmLCBWaynlkowoVmsgLCDigKYsIFZqKeS4gOWumuaYr+S7jlZp5YiwVmvlkozku45Wa+WIsFZqIOeahOacgOefrei3r+W+hOOAguS7juiAjOWPr+S7peagueaNrlBhdGhbaV1ba13lkoxQYXRoW2tdW2pd55qE5YC85YaN5om+5Yiw6K+l6Lev5b6E5LiK5omA57uP6L+H55qE5YW25a6D6aG254K577yM4oCm5L6d5q2k57G75o6o44CCXHJcbiDil4Yg5Yid5aeL5YyW5Li6UGF0aFtpXVtqXT0tMe+8jOihqOekuuS7jlZp5YiwVmog5LiN57uP6L+H5Lu75L2VKFPkuK3nmoTkuK3pl7Qp6aG254K544CC5b2T5p+Q5Liq6aG254K5VmvliqDlhaXliLBT5Lit5ZCO5L2/QVtpXVtqXeWPmOWwj+aXtu+8jOS7pFBhdGhbaV1bal09a+OAglxyXG5cclxuXHJcbiAqL1xuXG52YXIgZmxveWQgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YwJyk7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YxJyk7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YyJyk7XG5mbG95ZC5hZGRBcmMoJ3YwJywgJ3YyJywgeyBhZGo6IDggfSk7XG5mbG95ZC5hZGRBcmMoJ3YwJywgJ3YxJywgeyBhZGo6IDIgfSk7XG5mbG95ZC5hZGRBcmMoJ3YxJywgJ3YyJywgeyBhZGo6IDQgfSk7XG5mbG95ZC5hZGRBcmMoJ3YyJywgJ3YwJywgeyBhZGo6IDUgfSk7XG5cbmZsb3lkLnNob3J0ZXN0UGF0aF9GTE9ZRCgpO1xuXG4vLyBodHRwOi8vYmxvZy5jc2RuLm5ldC9oZ3Vpc3UvYXJ0aWNsZS9kZXRhaWxzLzc3MTk0Mjhcbi8vIOa3u+WKoOOAiuWbvueahOW6lOeUqOivpuinoy3mlbDmja7nu5PmnoTjgItcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE9MR3JhcGg7XG4vKlxyXG4g5Y2B5a2X6ZO+6KGo5rOVXHJcblxyXG4g5Y2B5a2X6ZO+6KGoKE9ydGhvZ29uYWwgTGlzdCnmmK/mnInlkJHlm77nmoTlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoTvvIzmmK/lsIbmnInlkJHlm77nmoTmraPpgrvmjqXooajlkozpgIbpgrvmjqXooajnu5PlkIjotbfmnaXlvpfliLDnmoTkuIDnp43pk77ooajjgIJcclxuXHJcbiDlnKjov5nnp43nu5PmnoTkuK3vvIzmr4/mnaHlvKfnmoTlvKflpLTnu5PngrnlkozlvKflsL7nu5Pngrnpg73lrZjmlL7lnKjpk77ooajkuK3vvIzlubblsIblvKfnu5PngrnliIbliKvnu4Tnu4fliLDku6XlvKflsL7nu5PngrnkuLrlpLQo6aG254K5Kee7k+eCueWSjOS7peW8p+WktOe7k+eCueS4uuWktCjpobbngrkp57uT54K555qE6ZO+6KGo5Lit44CCXHJcblxyXG4g4peGICBkYXRh5Z+f77ya5a2Y5YKo5ZKM6aG254K555u45YWz55qE5L+h5oGv77ybXHJcbiDil4Yg5oyH6ZKI5Z+fZmlyc3Rpbu+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WktOeahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xyXG4g4peGIOaMh+mSiOWfn2ZpcnN0b3V077ya5oyH5ZCR5Lul6K+l6aG254K55Li65byn5bC+55qE56ys5LiA5p2h5byn5omA5a+55bqU55qE5byn57uT54K577ybXHJcbiDil4Yg5bC+5Z+fdGFpbHZleO+8muaMh+ekuuW8p+WwvumhtueCueWcqOWbvuS4reeahOS9jee9ru+8m1xyXG4g4peGIOWktOWfn2hlYWR2ZXjvvJrmjIfnpLrlvKflpLTpobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcclxuIOKXhiDmjIfpkojln59obGlua++8muaMh+WQkeW8p+WktOebuOWQjOeahOS4i+S4gOadoeW8p++8m1xyXG4g4peGIOaMh+mSiOWfn3RsaW5r77ya5oyH5ZCR5byn5bC+55u45ZCM55qE5LiL5LiA5p2h5byn77ybXHJcbiDil4YgSW5mb+Wfn++8muaMh+WQkeivpeW8p+eahOebuOWFs+S/oeaBr++8m1xyXG5cclxuIOS7jui/meenjeWtmOWCqOe7k+aehOWbvuWPr+S7peeci+WHuu+8jOS7juS4gOS4qumhtueCuee7k+eCueeahGZpcnN0b3V05Ye65Y+R77yM5rK/6KGo57uT54K555qEdGxpbmvmjIfpkojmnoTmiJDkuobmraPpgrvmjqXooajnmoTpk77ooajnu5PmnoTvvIzogIzku47kuIDkuKrpobbngrnnu5PngrnnmoRmaXJzdGlu5Ye65Y+R77yM5rK/6KGo57uT54K555qEaGxpbmvmjIfpkojmnoTmiJDkuobpgIbpgrvmjqXooajnmoTpk77ooajnu5PmnoTjgIJcclxuXHJcbiAqL1xuXG4vKipcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlYWRWZXgg5byn55qE5aS06aG254K555qE5L2N572uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YWlsVmV4IOW8p+eahOWwvumhtueCueS9jee9rlxyXG4gKiBAcGFyYW0ge0FyY0JveH0gaExpbmsg5byn5aS055u45ZCM55qE5byn55qE6ZO+5Z+fXHJcbiAqIEBwYXJhbSB7QXJjQm94fSB0TGluayDlvKflsL7nm7jlkIznmoTlvKfnmoTpk77ln59cclxuICogQHBhcmFtIHsqfSBpbmZvXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cbmZ1bmN0aW9uIEFyY0JveCh0YWlsVmV4LCBoZWFkVmV4LCBoTGluaywgdExpbmssIGluZm8pIHtcbiAgICB0aGlzLmhlYWRWZXggPSBoZWFkVmV4IHx8IDA7XG4gICAgdGhpcy50YWlsVmV4ID0gdGFpbFZleCB8fCAwO1xuICAgIHRoaXMuaExpbmsgPSBoTGluayB8fCBudWxsO1xuICAgIHRoaXMudExpbmsgPSB0TGluayB8fCBudWxsO1xuICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcbn1cblxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gKiBAcGFyYW0ge0FyY0JveH0gZmlyc3RJbiDor6XpobbngrnnrKzkuIDmnaHlhaXlvKdcclxuICogQHBhcmFtIHtBcmNCb3h9IGZpcnN0T3V0IOivpemhtueCueesrOS4gOadoeWHuuW8p1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5mdW5jdGlvbiBPTFZleE5vZGUoZGF0YSwgZmlyc3RJbiwgZmlyc3RPdXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGw7XG4gICAgdGhpcy5maXJzdEluID0gZmlyc3RJbiB8fCBudWxsO1xuICAgIHRoaXMuZmlyc3RPdXQgPSBmaXJzdE91dCB8fCBudWxsO1xufVxuXG4vKipcclxuICpcclxuICogQHBhcmFtIHtBcnJheSB8IE9MVmV4Tm9kZX0geExpc3Qg6KGo5aS05ZCR6YePXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW0g5pyJ5ZCR5Zu+55qE5b2T5YmN6aG254K55pWwXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW0g5pyJ5ZCR5Zu+55qE5b2T5YmN5byn5pWwXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cbmZ1bmN0aW9uIE9MR3JhcGgoeExpc3QsIHZleG51bSwgYXJjbnVtKSB7XG4gICAgdGhpcy54TGlzdCA9IHhMaXN0IHx8IFtdO1xuICAgIHRoaXMudmV4bnVtID0gdmV4bnVtIHx8IDA7XG4gICAgdGhpcy5hcmNudW0gPSBhcmNudW0gfHwgMDtcbn1cbk9MR3JhcGgucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBPTEdyYXBoLFxuXG4gICAgbG9jYXRlVmV4OiBmdW5jdGlvbiBsb2NhdGVWZXgodnApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5kYXRhID09PSB2cCkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8vIOWIoOmZpOmhtueCuVxuICAgIGRlbGV0ZVZlcnRleDogZnVuY3Rpb24gZGVsZXRlVmVydGV4KHYpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmxvY2F0ZVZleCh2KTtcblxuICAgICAgICBpZiAobSA8IDApIHRocm93IG5ldyBFcnJvcigndmVydGV4IG5vdCBmb3VuZCEnKTtcblxuICAgICAgICB2YXIgbiA9IHRoaXMudmV4bnVtO1xuICAgICAgICB2YXIgcSwgaSwgcDtcbiAgICAgICAgLy8g5Yig6Zmk5omA5pyJ5LulduS4uuWktOeahOi+uVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzlvoXliKDpmaTnmoTovrnmmK/lpLTpk77kuIrnmoTnrKzkuIDkuKrnu5PngrlcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmZpcnN0SW4udGFpbFZleCA9PT0gbSkge1xuICAgICAgICAgICAgICAgIHEgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47XG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdEluID0gcS5oTGluaztcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47IHAgJiYgcC5oTGluay50YWlsVmV4ICE9PSBtOyBwID0gcC5oTGluaykge31cbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBxID0gcC5oTGluaztcbiAgICAgICAgICAgICAgICAgICAgcC5oTGluayA9IHEuaExpbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5Yig6Zmk5omA5pyJ5LulduS4uuWwvueahOi+uVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzlvoXliKDpmaTnmoTovrnmmK/lsL7pk77kuIrnmoTnrKzkuIDkuKrnu5PngrlcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmZpcnN0T3V0LmhlYWRWZXggPT09IG0pIHtcbiAgICAgICAgICAgICAgICBxID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDtcbiAgICAgICAgICAgICAgICB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0ID0gcS50TGluaztcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0OyBwICYmIHAudExpbmsuaGVhZFZleCAhPT0gbTsgcCA9IHAudExpbmspIHt9XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHAudExpbms7XG4gICAgICAgICAgICAgICAgICAgIHAudExpbmsgPSBxLnRMaW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOmhuuasoeeUqOe7k+eCuW3kuYvlkI7nmoTpobbngrnlj5bku6PliY3kuIDkuKrpobbngrlcbiAgICAgICAgZm9yIChpID0gbTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8g5L+u5pS56KGo5aS05ZCR6YePXG4gICAgICAgICAgICB0aGlzLnhMaXN0W2ldID0gdGhpcy54TGlzdFtpICsgMV07XG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XG4gICAgICAgICAgICAgICAgcC5oZWFkVmV4LS07XG4gICAgICAgICAgICB9Zm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcbiAgICAgICAgICAgICAgICBwLnRhaWxWZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmV4bnVtLS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVERzogZnVuY3Rpb24gY3JlYXRlREcoKSB7XG4gICAgICAgIHRoaXMudmV4bnVtID0gcHJvbXB0KCdWZXhudW06ICcpO1xuICAgICAgICB0aGlzLmFyY251bSA9IHByb21wdCgnQXJjbnVtOiAnKTtcbiAgICAgICAgLy8gSW5jSW5mb+S4ujDliJnlkITlvKfkuI3lkKvlhbbku5bkv6Hmga9cbiAgICAgICAgdmFyIGluY0luZm8gPSArcHJvbXB0KCdJbmNJbmZvOiAnKTtcblxuICAgICAgICAvLyDovpPlhaXpobbngrnlgLxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnhMaXN0W2ldID0gbmV3IE9MVmV4Tm9kZShwcm9tcHQoJ2RhdGE6ICcpLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5hcmNudW07ICsraykge1xuICAgICAgICAgICAgdmFyIHYxID0gcHJvbXB0KCd2MTogJyk7XG4gICAgICAgICAgICB2YXIgdjIgPSBwcm9tcHQoJ3YyOiAnKTtcblxuICAgICAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KHYxKTtcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgodjIpO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEgfHwgaiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhbGVydCgn5peg5q2k6aG254K577yM6K+36YeN5paw6L6T5YWlIScpO1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgQXJjQm94KGksIGosIHRoaXMueExpc3Rbal0uZmlyc3RJbiwgdGhpcy54TGlzdFtpXS5maXJzdE91dCwgaW5jSW5mbyAmJiBwcm9tcHQoJ2luZm86ICcpKTtcbiAgICAgICAgICAgIHRoaXMueExpc3Rbal0uZmlyc3RJbiA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQgPSBwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICog5rGC5pyJ5ZCR5Zu+55qE5by66L+e6YCa5YiG6YePXHJcbiAgICAgKi9cbiAgICBnZXRTR3JhcGg6IGZ1bmN0aW9uIGdldFNHcmFwaCgpIHtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIH0gLy8g56ys5LiA5qyh5rex5bqm5LyY5YWI6YGN5Y6G5bu656uLZmluaXNoZWTmlbDnu4RcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzMSh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyDmuIXnqbp2aXNpdGVk5pWw57uEXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIH0gLy8g56ys5LqM5qyh6YCG5ZCR55qE5rex5bqm5LyY5YWI6YGN5Y6GXG4gICAgICAgIGZvciAodmFyIGxlbiA9IHRoaXMudmV4bnVtIC0gMTsgbGVuID49IDA7IC0tbGVuKSB7XG4gICAgICAgICAgICBpID0gZmluaXNoZWRbaV07XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmczIodGhpcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMxKGdyYXBoLCB2KSB7XG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHAuaGVhZFZleDtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbd10pIGRmczEoZ3JhcGgsIHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluaXNoZWRbKytjb3VudF0gPSB2O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGZzMihncmFwaCwgdikge1xuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJWQnLCB2KTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdEluOyBwOyBwID0gcC5oTGluaykge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gcC50YWlsVmV4O1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3XSkgZGZzMihncmFwaCwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vL3ZhciBnID0gbmV3IE9MR3JhcGgoKTtcbi8vZy5jcmVhdGVERygpO1xuLy9jb25zb2xlLmxvZyhnKTtcblxuLypcclxuIOacieWQkeWbvueahOW8uui/numAmuWIhumHj1xyXG5cclxuIOWvueS6juacieWQkeWbvu+8jOWcqOWFtuavj+S4gOS4quW8uui/numAmuWIhumHj+S4re+8jOS7u+S9leS4pOS4qumhtueCuemDveaYr+WPr+i+vueahOOAgiBW4oiIR++8jOS4jlblj6/nm7jkupLliLDovr7nmoTmiYDmnInpobbngrnlsLHmmK/ljIXlkKtW55qE5by66L+e6YCa5YiG6YeP55qE5omA5pyJ6aG254K544CCXHJcblxyXG4g6K6+5LuOVuWPr+WIsOi+viAo5LulVuS4uui1t+eCueeahOaJgOacieacieWQkei3r+W+hOeahOe7iOeCuSnnmoTpobbngrnpm4blkIjkuLpUMShHKe+8jOiAjOWIsOi+vlYgKOS7pVbkuLrnu4jngrnnmoTmiYDmnInmnInlkJHot6/lvoTnmoTotbfngrkp55qE6aG254K56ZuG5ZCI5Li6VDIoRynvvIzliJnljIXlkKtW55qE5by66L+e6YCa5YiG6YeP55qE6aG254K56ZuG5ZCI5piv77yaIFQxKEcp4oipVDIoRykg44CCXHJcblxyXG4g5rGC5pyJ5ZCR5Zu+R+eahOW8uui/numAmuWIhumHj+eahOWfuuacrOatpemqpOaYr++8mlxyXG4g4pG0IOWvuUfov5vooYzmt7HluqbkvJjlhYjpgY3ljobvvIznlJ/miJBH55qE5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6XVOOAglxyXG4g4pG1ICDlr7nmo67mnpdU55qE6aG254K55oyJ5Lit5bqP6YGN5Y6G6aG65bqP6L+b6KGM57yW5Y+344CCXHJcbiDikbYgIOaUueWPmEfkuK3mr4/kuIDmnaHlvKfnmoTmlrnlkJHvvIzmnoTmiJDkuIDkuKrmlrDnmoTmnInlkJHlm75H4oCZ44CCXHJcbiDikbcgIOaMieKRteS4reagh+WHuueahOmhtueCuee8luWPt++8jOS7jue8luWPt+acgOWkp+eahOmhtueCueW8gOWni+WvuUfigJnov5vooYzmt7HluqbkvJjlhYjmkJzntKLvvIzlvpfliLDkuIDmo7Xmt7HluqbkvJjlhYjnlJ/miJDmoJHjgILoi6XkuIDmrKHlrozmlbTnmoTmkJzntKLov4fnqIvmsqHmnInpgY3ljoZH4oCZ55qE5omA5pyJ6aG254K577yM5YiZ5LuO5pyq6K6/6Zeu55qE6aG254K55Lit6YCJ5oup5LiA5Liq57yW5Y+35pyA5aSn55qE6aG254K577yM55Sx5a6D5byA5aeL5YaN6L+b6KGM5rex5bqm5LyY5YWI5pCc57Si77yM5bm25b6X5Yiw5Y+m5LiA5qO15rex5bqm5LyY5YWI55Sf5oiQ5qCR44CC5Zyo6K+l5q2l6aqk5Lit77yM5q+P5LiA5qyh5rex5bqm5LyY5YWI5pCc57Si5omA5b6X5Yiw55qE55Sf5oiQ5qCR5Lit55qE6aG254K55bCx5pivR+eahOS4gOS4quW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxyXG4g4pG4ICDph43lpI3mraXpqqTikbcg77yM55u05YiwR+KAmeS4reeahOaJgOaciemhtueCuemDveiiq+iuv+mXruOAglxyXG5cclxuIOWcqOeul+azleWunueOsOaXtu+8jOW7uueri+S4gOS4quaVsOe7hGluX29yZGVyW25d5a2Y5pS+5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6X55qE5Lit5bqP6YGN5Y6G5bqP5YiX44CC5a+55q+P5Liq6aG254K5du+8jOWcqOiwg+eUqERGU+WHveaVsOe7k+adn+aXtu+8jOWwhumhtueCueS+neasoeWtmOaUvuWcqOaVsOe7hGluX29yZGVyW25d5Lit44CC5Zu+6YeH55So5Y2B5a2X6ZO+6KGo5L2c5Li65a2Y5YKo57uT5p6E5pyA5ZCI6YCC44CCXHJcblxyXG4gKi9cblxuLy8gdG9kbyB0byBiZSB0ZXN0ZWRcbk9MR3JhcGgucHJvdG90eXBlLmNvbm5lY3RlZF9ERyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlzaXRlZCA9IFtdO1xuICAgIHZhciBpbl9vcmRlciA9IFtdO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgIH0gLy8g5a+55Zu+5q2j5ZCR6YGN5Y6GXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XG4gICAgICAgICAgICBkZnModGhpcywgaSwgaW5fb3JkZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgIH0gLy8g5a+55Zu+6YCG5ZCR6YGN5Y6GXG4gICAgdmFyIGsgPSAxO1xuICAgIGZvciAodmFyIGogPSB0aGlzLnZleG51bSAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIHZhciB2ID0gaW5fb3JkZXJbal07XG4gICAgICAgIGlmICghdmlzaXRlZFt2XSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ+esrCcgKyBrKysgKyAn5Liq6L+e6YCa5YiG6YeP6aG254K5Jyk7XG4gICAgICAgICAgICByZXZfZGZzKHRoaXMsIHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2KSB7XG4gICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmhlYWRWZXhdKSB7XG4gICAgICAgICAgICAgICAgZGZzKGdyYXBoLCBwLmhlYWRWZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5fb3JkZXJbY291bnQrK10gPSB2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldl9kZnMoZ3JhcGgsIHYpIHtcbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCfpobbngrnvvJonICsgdik7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC50YWlsVmV4XSkge1xuICAgICAgICAgICAgICAgIHJldl9kZnMoZ3JhcGgsIHAudGFpbFZleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvR3JhcGgvT0xHcmFwaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvcicpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbnZhciBfaXRlcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvcicpO1xuXG52YXIgX2l0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX0RvdWJsZUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL0RvdWJsZUxpbmtlZExpc3QnKTtcblxudmFyIF9Eb3VibGVMaW5rZWRMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvdWJsZUxpbmtlZExpc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgTElNSVQgPSAyMDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBMUlUoIExlYXN0IHJlY2VudGx5IHVzZWQgKVxyXG4gICAgICAgICAgICAgICAgICovXG5cbnZhciBMUlVDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMUlVDYWNoZShzcUxpc3QpIHtcbiAgICAgICAgdmFyIGxpbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gTElNSVQgOiBhcmd1bWVudHNbMV07XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIExSVUNhY2hlKTtcblxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHNxTGlzdCA9IHNxTGlzdCAmJiBzcUxpc3QubGVuZ3RoID8gc3FMaXN0ICYmIHNxTGlzdC5sZW5ndGguc2xpY2UoMCwgdGhpcy5saW1pdCkgOiBbXTtcbiAgICAgICAgdGhpcy5fX2NhY2hlID0gbmV3IF9Eb3VibGVMaW5rZWRMaXN0Mi5kZWZhdWx0KHNxTGlzdCwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmtleSA9PT0gYi5rZXk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKExSVUNhY2hlLCBbe1xuICAgICAgICBrZXk6IF9pdGVyYXRvcjMuZGVmYXVsdCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKHRoaXMuX19jYWNoZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnJlbW92ZSh7IGtleToga2V5IH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fX2NhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9fY2FjaGUuaW5kZXhPZih7IGtleToga2V5IH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2NhY2hlLmZpbmRCeUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FjaGUucmVtb3ZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19jYWNoZS51bnNoaWZ0KGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2FjaGUucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChkYXRhLmtleSArICc6JyArIGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcnIuam9pbignID4gJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvSlNPTicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaXplJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnNpemU7XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIExSVUNhY2hlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMUlVDYWNoZTtcblxuXG5jb25zb2xlLmxvZygnTFJVQ2FjaGUnKTtcblxudmFyIGEgPSBuZXcgTFJVQ2FjaGUoW10sIDMpO1xuYS5hZGQoJ2FkYW0nLCAyOSk7XG5hLmFkZCgnam9obicsIDI2KTtcbmEuYWRkKCdhbmdlbGEnLCAyNCk7XG5jb25zb2xlLmxvZyhhICsgJycpO1xuYS5nZXQoJ2pvaG4nKTtcbmNvbnNvbGUubG9nKGEgKyAnJyk7XG5hLmFkZCgnem9ycm8nLCAxNDEpO1xuY29uc29sZS5sb2coYSArICcnKTtcbmNvbnNvbGUubG9nKGEudG9KU09OKCkpO1xuXG52YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG52YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbnZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxudHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xuICAgIH1cbn0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbn0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmEucmVtb3ZlKCd6b3JybycpO1xuYS5yZW1vdmUoJ2pvaG4nKTtcbmEucmVtb3ZlKCdhbmdlbGEnKTtcbmNvbnNvbGUubG9nKGEgKyAnJyk7XG5cbi8vIHRlc3QgY2FzZTpcbi8vIElucHV0OlxuLy8gMixbYWRkKDIsMSksYWRkKDEsMSksYWRkKDIsMyksYWRkKDQsMSksZ2V0KDEpLGdldCgyKV1cbi8vIEV4cGVjdGVkOlxuLy8gWyBmYWxzZSwgeyBrZXk6IDIsIHZhbHVlOiAzIH0gXVxuY29uc29sZS5sb2coJ2FkZCcpO1xuXG52YXIgYiA9IG5ldyBMUlVDYWNoZShbXSwgMik7XG5iLmFkZCgyLCAxKTtcbmIuYWRkKDEsIDEpO1xuYi5hZGQoMiwgMyk7XG5iLmFkZCg0LCAxKTtcbmNvbnNvbGUubG9nKFtiLmdldCgxKSwgYi5nZXQoMildKTtcblxuY29uc29sZS5sb2coJ35hZGQnKTtcblxuY29uc29sZS5sb2coJ0xSVUNhY2hlRW5kJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9MaXN0L0xSVS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVuaW9uID0gdW5pb247XG5leHBvcnRzLm1lcmdlTGlzdCA9IG1lcmdlTGlzdDtcbmV4cG9ydHMuaW5zZXJ0ID0gaW5zZXJ0O1xuZXhwb3J0cy5kZWwgPSBkZWw7XG5leHBvcnRzLmxpc3RDb21wID0gbGlzdENvbXA7XG5leHBvcnRzLnJldmVyc2UgPSByZXZlcnNlO1xuZXhwb3J0cy5pbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG5leHBvcnRzLmludGVyc2VjdF90cnVlID0gaW50ZXJzZWN0X3RydWU7XG5leHBvcnRzLmludGVyc2VjdF9kZWxldGUgPSBpbnRlcnNlY3RfZGVsZXRlO1xuLyoqXHJcbiAqIOe6v+aAp+ihqFxyXG4gKi9cblxuLy8g57q/5oCn6KGo55qE57G75Z6L5a6a5LmJXG4vLyDlsIbmiYDmnInlnKjmlbDnu4Ri5Lit5L2G5LiN5Zyo5pWw57uEYeeahOaVsOaNruWFg+e0oOaPkuWFpeWIsGHkuK1cblxudmFyIGEgPSBbMSwgMiwgMywgNCwgNV07XG52YXIgYiA9IFsxLCAzLCA1LCA3LCA5XTtcblxuZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICAgIHZhciBlbGVtLCBlcXVhbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBiTGVuID0gYi5sZW5ndGg7IGkgPCBiTGVuOyBpKyspIHtcbiAgICAgICAgZWxlbSA9IGJbaV07XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGFMZW4gPSBhLmxlbmd0aDsgaiA8IGFMZW47IGorKykge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09IGFbal0pIHtcbiAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVxdWFsKSBhLnB1c2goZWxlbSk7XG4gICAgfVxufVxuXG51bmlvbihhLCBiKTtcbmNvbnNvbGUubG9nKGEpO1xuLy8gWzEsIDIsIDMsIDQsIDUsIDcsIDldXG5cbi8vIOaXtumXtOWkjeadguW6pu+8mk8oYUxlbiAqIGJMZW4pXG5cbi8vIOW3suefpeaVsOe7hGHlkozmlbDnu4Ri5Lit55qE5pWw5o2u5YWD57Sg5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXG4vLyDlvZLlubZh5ZKMYuW+l+WIsOaWsOeahOaVsOe7hGPvvIxj55qE5pWw5o2u5YWD57Sg5Lmf5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXG52YXIgYSA9IFszLCA1LCA4LCAxMV07XG52YXIgYiA9IFsyLCA2LCA4LCA5LCAxMSwgMTUsIDIwXTtcblxuZnVuY3Rpb24gbWVyZ2VMaXN0KGEsIGIpIHtcbiAgICB2YXIgYyA9IFtdLFxuICAgICAgICBhRWxlbSxcbiAgICAgICAgYkVsZW07XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgayA9IDA7XG4gICAgdmFyIGFMZW4gPSBhLmxlbmd0aDtcbiAgICB2YXIgYkxlbiA9IGIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBhTGVuICYmIGogPCBiTGVuKSB7XG4gICAgICAgIGFFbGVtID0gYVtpXTtcbiAgICAgICAgYkVsZW0gPSBiW2pdO1xuXG4gICAgICAgIGlmIChhRWxlbSA8IGJFbGVtKSB7XG4gICAgICAgICAgICBjW2srK10gPSBhRWxlbTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNbaysrXSA9IGJFbGVtO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICAgIGNbaysrXSA9IGFbaSsrXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaiA8IGJMZW4pIHtcbiAgICAgICAgY1trKytdID0gYltqKytdO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xufVxuXG52YXIgYyA9IG1lcmdlTGlzdChhLCBiKTtcbmNvbnNvbGUubG9nKGMpO1xuLy8gWzIsIDMsIDUsIDYsIDgsIDgsIDksIDExLCAxMSwgMTUsIDIwXVxuXG4vLyDml7bpl7TlpI3mnYLluqbvvJogTyhhTGVuICsgYkxlbilcblxuLy8g57q/5oCn6KGo55qE6aG65bqP6KGo56S65ZKM5a6e546wXG4vLyDkvb/nlKjkvKrmlbDnu4TmqKHmi5/nur/mgKfooajmj5LlhaXmk43kvZznmoTliY3lkI7mlbDmja7lhYPntKDlnKjlrZjlgqjnqbrpl7TkuK3nmoTkvY3nva7lj5jljJZcbnZhciBhID0geyAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1IH07XG5hLmxlbmd0aCA9IDY7XG5cbmZ1bmN0aW9uIGluc2VydChhLCBpLCBlbGVtKSB7XG4gICAgaWYgKCFlbGVtKSByZXR1cm47XG5cbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgIHdoaWxlIChsZW4gPCBpKSB7XG4gICAgICAgICAgICBhW2xlbisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGEubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgYVtpXSA9IGVsZW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgICAgICAgIGFbbGVuLS1dID0gYVtsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGFbaV0gPSBlbGVtO1xuICAgIH1cbiAgICBhLmxlbmd0aCsrO1xufVxuXG5pbnNlcnQoYSwgMywgOCk7XG5pbnNlcnQoYSwgMTAsIDEwKTtcbmNvbnNvbGUubG9nKGEpO1xuXG4vLyDkvb/nlKjkvKrmlbDnu4TmqKHmi5/nur/mgKfooajliKDpmaTmk43kvZznmoTliY3lkI7mlbDmja7lhYPntKDlnKjlrZjlgqjnqbrpl7TkuK3nmoTkvY3nva7lj5jljJZcblxuZnVuY3Rpb24gZGVsKGEsIGkpIHtcbiAgICB2YXIgdGVtcCA9IGFbaV07XG4gICAgdmFyIGogPSBpICsgMTtcbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICBhW2ogLSAxXSA9IGFbaisrXTtcbiAgICB9XG4gICAgYS5sZW5ndGgtLTtcbiAgICBkZWxldGUgYVtsZW4gLSAxXTtcblxuICAgIHJldHVybiB0ZW1wO1xufVxuXG5kZWwoYSwgMyk7XG5jb25zb2xlLmxvZyhhKTtcbmRlbChhLCAxMCk7XG5jb25zb2xlLmxvZyhhKTtcblxuLy8g5pe26Ze05aSN5p2C5bqm77yaIE8oYS5sZW5ndGgpXG5cbi8vIOavlOi+g+Wtl+espuihqEHlkoxC77yM5bm255So6L+U5Zue5YC86KGo56S657uT5p6c77yM5YC85Li6Me+8jOihqOekukE+Qu+8jOWAvOS4ui0x77yM6KGo56S6QTxC77yM5YC85Li6MO+8jOihqOekukE9QlxuZnVuY3Rpb24gbGlzdENvbXAoYUxpc3QsIGJMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTGlzdC5sZW5ndGggJiYgaSA8IGJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhTGlzdFtpXSAhPT0gYkxpc3RbaV0pIHJldHVybiBhTGlzdFtpXSA+IGJMaXN0W2ldID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChhTGlzdC5sZW5ndGggPT0gYkxpc3QubGVuZ3RoKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBhTGlzdC5sZW5ndGggPiBiTGlzdC5sZW5ndGggPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2UobGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGlzdC5sZW5ndGggLSAxOyBpIDw9IGo7IGkrKywgai0tKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbGlzdFtpXTtcbiAgICAgICAgbGlzdFtpXSA9IGxpc3Rbal07XG4gICAgICAgIGxpc3Rbal0gPSB0ZW1wO1xuICAgIH1cbn1cblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXG5mdW5jdGlvbiBpbnRlcnNlY3QoYUxpc3QsIGJMaXN0KSB7XG4gICAgdmFyIGNMaXN0ID0gW107XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgayA9IDA7XG5cbiAgICB3aGlsZSAoYUxpc3RbaV0gJiYgYkxpc3Rbal0pIHtcbiAgICAgICAgaWYgKGFMaXN0W2ldIDwgYkxpc3Rbal0pIGkrKztlbHNlIGlmIChhTGlzdFtpXSA+IGJMaXN0W2pdKSBqKys7ZWxzZSB7XG4gICAgICAgICAgICBjTGlzdFtrKytdID0gYUxpc3RbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY0xpc3Q7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdChbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaXlm55hXG5mdW5jdGlvbiBpbnRlcnNlY3RfdHJ1ZShhLCBiKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgayA9IDA7XG5cbiAgICB3aGlsZSAoYVtpXSAmJiBiW2pdKSB7XG4gICAgICAgIGlmIChhW2ldIDwgYltqXSkgaSsrO2Vsc2UgaWYgKGFbaV0gPiBiW2pdKSBqKys7ZWxzZSB7XG4gICAgICAgICAgICBhW2srK10gPSBhW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGFba10pIHtcbiAgICAgICAgYS5zcGxpY2UoaywgMSk7XG4gICAgfXJldHVybiBhO1xufVxuXG5jb25zb2xlLmxvZyhpbnRlcnNlY3RfdHJ1ZShbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcblxuLy8gYe+8jGLvvIxj55qE5YWD57Sg5Z2H5piv6Z2e6YCS5YeP5o6S5YiXXG4vLyDmsYJh5pWw57uE5Lit6Z2eYuaVsOe7hOWSjGPmlbDnu4TnmoTkuqTpm4bnmoTlhYPntKDjgIJcbmZ1bmN0aW9uIGludGVyc2VjdF9kZWxldGUoYSwgYiwgYykge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGsgPSAwLFxuICAgICAgICBtID0gMDtcblxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaiA8IGIubGVuZ3RoICYmIGsgPCBjLmxlbmd0aCkge1xuICAgICAgICBpZiAoYltqXSA8IGNba10pIGorKztlbHNlIGlmIChiW2pdID4gY1trXSkgaysrO2Vsc2Uge1xuICAgICAgICAgICAgLy8g5om+5Yiw5LqG55u45ZCM5YWD57Sgc2FtZVxuICAgICAgICAgICAgdmFyIHNhbWUgPSBiW2pdO1xuXG4gICAgICAgICAgICAvLyBq77yMa+WQjuenu+WIsOaWsOeahOWFg+e0oFxuICAgICAgICAgICAgd2hpbGUgKGJbal0gPT09IHNhbWUpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9d2hpbGUgKGNba10gPT09IHNhbWUpIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9IC8vIOmcgOS/neeVmeeahOWFg+e0oOenu+WKqOWIsOaWsOS9jee9rlxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldIDwgc2FtZSkge1xuICAgICAgICAgICAgICAgIGFbbSsrXSA9IGFbaSsrXTtcbiAgICAgICAgICAgIH0gLy8g6Lez6L+H55u45ZCM55qE5YWD57SgXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEubGVuZ3RoICYmIGFbaV0gPT09IHNhbWUpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBh55qE5Ymp5L2Z5YWD57Sg6YeN5paw5a2Y5YKoXG4gICAgd2hpbGUgKGkgPCBhLmxlbmd0aCkge1xuICAgICAgICBhW20rK10gPSBhW2krK107XG4gICAgfWEubGVuZ3RoID0gbTtcblxuICAgIHJldHVybiBhO1xufVxuXG5jb25zb2xlLmxvZyhpbnRlcnNlY3RfZGVsZXRlKFsxLCAyLCAzLCA0LCA1LCA2LCA5XSwgWzEsIDMsIDUsIDcsIDldLCBbMSwgNSwgOSwgMTMsIDE3XSkgKyAnJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9MaXN0L0xpbmVhckxpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMS8xOS5cclxuICovXG5cbi8vIOW+queOr+mYn+WIl1xuXG52YXIgQ3ljbGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDeWNsZVF1ZXVlKCkge1xuICAgICAgICB2YXIgbWF4c2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDEwMCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ3ljbGVRdWV1ZSk7XG5cbiAgICAgICAgdGhpcy5iYXNlID0ge307XG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xuICAgICAgICB0aGlzLk1BWFFTSVpFID0gbWF4c2l6ZTtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShDeWNsZVF1ZXVlLCBbe1xuICAgICAgICBrZXk6ICdlblF1ZXVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuUXVldWUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLnJlYXIgKyAxKSAlIHRoaXMuTUFYUVNJWkUgPT09IDApIHRocm93IG5ldyBFcnJvcignY3ljbGVRdWV1ZSBpcyBhbHJlYWR5IGZ1bGwhJyk7XG5cbiAgICAgICAgICAgIHRoaXMuYmFzZVt0aGlzLnJlYXJdID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVhciA9ICh0aGlzLnJlYXIgKyAxKSAlIHRoaXMuTUFYUVNJWkU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlUXVldWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVRdWV1ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb250ID09PSB0aGlzLnJlYXIpIHRocm93IG5ldyBFcnJvcignY3ljbGVRdWV1ZSBpcyBhbHJlYWR5IGVtcHR5Jyk7XG5cbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xuICAgICAgICAgICAgdGhpcy5mcm9udCA9ICh0aGlzLmZyb250ICsgMSkgJSB0aGlzLk1BWFFTSVpFO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xlYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwZWVrQXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGVla0F0KCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggKyB0aGlzLk1BWFFTSVpFKSAlIHRoaXMuTUFYUVNJWkU7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VbaW5kZXggKyB0aGlzLmZyb250XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRIZWFkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWQoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZVt0aGlzLmZyb250XTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3F1ZXVlVHJhdmVyc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcXVldWVUcmF2ZXJzZShpdGVyYXRvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZnJvbnQsIGxlbiA9IHRoaXMucmVhciA9IHRoaXMuZnJvbnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvcih0aGlzLmJhc2VbaV0sIGkpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IFtdLnNsaWNlLmNhbGwodGhpcy5iYXNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2xpY2UodGhpcy5mcm9udCwgdGhpcy5yZWFyIC0gdGhpcy5mcm9udCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpemUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yZWFyIC0gdGhpcy5mcm9udCArIHRoaXMuTUFYUVNJWkUpICUgdGhpcy5NQVhRU0laRTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ3ljbGVRdWV1ZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ3ljbGVRdWV1ZTtcblxuXG52YXIgcXVldWUgPSBuZXcgQ3ljbGVRdWV1ZSgpO1xucXVldWUuZW5RdWV1ZSgxKTtcbnF1ZXVlLmRlUXVldWUoKTtcbnF1ZXVlLmVuUXVldWUoMik7XG5xdWV1ZS5lblF1ZXVlKDMpO1xuY29uc29sZS5sb2cocXVldWUucGVla0F0KDApKTtcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgxKSk7XG5jb25zb2xlLmxvZyhxdWV1ZS5wZWVrQXQoMikpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvUXVldWUvQ3ljbGVRdWV1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTUvMi8yNi5cclxuICovXG5cbi8qXHJcbuS8mOWFiOmYn+WIlyhwcmlvcml0eSBxdWV1ZSlcclxuXHJcbuaZrumAmueahOmYn+WIl+aYr+S4gOenjeWFiOi/m+WFiOWHuueahOaVsOaNrue7k+aehO+8jOWFg+e0oOWcqOmYn+WIl+Wwvui/veWKoO+8jOiAjOS7jumYn+WIl+WktOWIoOmZpOOAguWcqOS8mOWFiOmYn+WIl+S4re+8jOWFg+e0oOiiq+i1i+S6iOS8mOWFiOe6p+OAguW9k+iuv+mXruWFg+e0oOaXtu+8jOWFt+acieacgOmrmOS8mOWFiOe6p+eahOWFg+e0oOacgOWFiOWIoOmZpOOAguS8mOWFiOmYn+WIl+WFt+acieacgOmrmOe6p+WFiOWHuiDvvIhsYXJnZXN0LWlu77yMZmlyc3Qtb3V077yJ55qE6KGM5Li654m55b6B44CCXHJcblxyXG7kvJjlhYjpmJ/liJfmmK8w5Liq5oiW5aSa5Liq5YWD57Sg55qE6ZuG5ZCILOavj+S4quWFg+e0oOmDveacieS4gOS4quS8mOWFiOadg+aIluWAvCzlr7nkvJjlhYjpmJ/liJfmiafooYznmoTmk43kvZzmnIkxKSDmn6Xmib47Mikg5o+S5YWl5LiA5Liq5paw5YWD57SgOzMpIOWIoOmZpC7lnKjmnIDlsI/kvJjlhYjpmJ/liJcobWluIHByaW9yaXR5cSB1IGUgdSBlKeS4rSzmn6Xmib7mk43kvZznlKjmnaXmkJzntKLkvJjlhYjmnYPmnIDlsI/nmoTlhYPntKAs5Yig6Zmk5pON5L2c55So5p2l5Yig6Zmk6K+l5YWD57SgO+WvueS6juacgOWkp+S8mOWFiOmYn+WIlyhtYXggcHJpb3JpdHkgcXVldWUpLOafpeaJvuaTjeS9nOeUqOadpeaQnOe0ouS8mOWFiOadg+acgOWkp+eahOWFg+e0oCzliKDpmaTmk43kvZznlKjmnaXliKDpmaTor6XlhYPntKAu5LyY5YWI5p2D6Zif5YiX5Lit55qE5YWD57Sg5Y+v5Lul5pyJ55u45ZCM55qE5LyY5YWI5p2DLOafpeaJvuS4juWIoOmZpOaTjeS9nOWPr+agueaNruS7u+aEj+S8mOWFiOadg+i/m+ihjC5cclxuXHJcblxyXG7lhaXpmJ/mk43kvZxcclxu4pGg77ya5a6M5YWo5LqM5Y+J5qCR55qE5p6E5bu65pON5L2c5piv4oCc5LuO5LiK5Yiw5LiL77yM5LuO5bem5Yiw5Y+z4oCd55qE5b2i5byP77yM5omA5Lul5YWl6Zif55qE6IqC54K55piv5pS+5Zyo5pWw57uE55qE5pyA5ZCO77yM5Lmf5bCx5piv5qCR5Lit5Y+25a2Q5bGC55qE5pyJ5bqP5pyA5Y+z6L6556m65L2N44CCXHJcbuKRoe+8muW9k+iKgueCueaPkuWFpeWIsOacgOWQjuaXtu+8jOacieWPr+iDveegtOWdj+S6huWghueahOaAp+i0qO+8jOatpOaXtuaIkeS7rOimgei/m+ihjOKAnOS4iua7pOaTjeS9nOKAne+8jOW9k+eEtuaXtumXtOWkjeadguW6puS4uk8obGdOKeOAglxyXG5cclxu5Ye66Zif5pON5L2cXHJcbuWHuumYn+aTjeS9nOaXtu+8jOaIkeS7rOmHh+WPlueahOaWueahiOaYr++8muW8ueWHuuWghumhtuWFg+e0oO+8jOeEtuWQjuWwhuWPtuWtkOWxguS4reeahOacgOWPs+WtkOiKgueCuei1i+e7meWghumhtu+8jOWQjOagt+i/meaXtuS5n+S8muWPr+iDveWtmOWcqOegtOWdj+WghueahOaAp+i0qO+8jOacgOWQjuaIkeS7rOimgeiiq+i/q+i/m+ihjOS4i+a7pOaTjeS9nOOAglxyXG4gKi9cblxuLy8g55So5aCG5a6e546w5LyY5YWI6Zif5YiXXG5cbnZhciBQcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFByaW9yaXR5UXVldWUpO1xuXG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFByaW9yaXR5UXVldWUsIFt7XG4gICAgICAgIGtleTogJ2VuUXVldWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5RdWV1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByaW9yaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgcmVxdWlyZWQnKTtcblxuICAgICAgICAgICAgLy8g5bCG5b2T5YmN6IqC54K56L+95Yqg5Yiw5aCG5bC+XG4gICAgICAgICAgICB0aGlzLmhlYXAucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIOWmguaenOWPquacieS4gOS4quiKgueCue+8jOWImeS4jemcgOimgei/m+ihjOetm+mAieaTjeS9nFxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT09IDEpIHJldHVybjtcblxuICAgICAgICAgICAgLy8g6I635Y+W5pyA5ZCO5LiA5Liq6Z2e5Y+25a2Q6IqC54K577yM5bm26L+b6KGM5aCG6LCD5pW0XG4gICAgICAgICAgICB1cEhlYXBBZGp1c3QodGhpcy5oZWFwLCAodGhpcy5oZWFwLmxlbmd0aCA+PiAxKSAtIDEpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZVF1ZXVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlUXVldWUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgaGVhcCA9IHRoaXMuaGVhcDtcbiAgICAgICAgICAgIC8vIOWHuumYn+WIl+aTjeS9nO+8jOW8ueWHuuaVsOaNruWktOWFg+e0oFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBoZWFwWzBdO1xuICAgICAgICAgICAgLy8g55So5bC+5YWD57Sg5aGr5YWF5aS05YWD57SgXG4gICAgICAgICAgICBoZWFwWzBdID0gaGVhcFtoZWFwLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8g5Yig6Zmk5bC+6IqC54K5XG4gICAgICAgICAgICBoZWFwLnBvcCgpO1xuXG4gICAgICAgICAgICAvL+eEtuWQjuS7juagueiKgueCueS4i+a7pOWghlxuICAgICAgICAgICAgZG93bkhlYXBBZGp1c3QoaGVhcCwgMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaXplJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFwLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gUHJpb3JpdHlRdWV1ZTtcbn0oKTtcblxuLy8g5a+55aCG6L+b6KGM5LiK5ruk5pON5L2c77yM5L2/5b6X5ruh6Laz5aCG5oCn6LSoXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gUHJpb3JpdHlRdWV1ZTtcbmZ1bmN0aW9uIHVwSGVhcEFkanVzdChoZWFwLCBwYXJlbnQpIHtcbiAgICB2YXIgbGVuID0gaGVhcC5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyZW50ID49IDApIHtcbiAgICAgICAgdmFyIGxlZnRDaGlsZCA9IDIgKiBwYXJlbnQgKyAxO1xuICAgICAgICB2YXIgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XG4gICAgICAgIHZhciBtYXggPSBsZWZ0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQgPCBsZW4pIHtcbiAgICAgICAgICAgIG1heCA9IGhlYXBbbGVmdENoaWxkXS5wcmlvcml0eSA8IGhlYXBbcmlnaHRDaGlsZF0ucHJpb3JpdHkgPyByaWdodENoaWxkIDogbGVmdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5aaC5p6ccGFyZW506IqC54K55bCP5LqO5a6D55qE5p+Q5Liq5a2Q6IqC54K555qE6K+d77yM5q2k5pe2562b6YCJ5pON5L2cXG4gICAgICAgIGlmIChoZWFwW3BhcmVudF0ucHJpb3JpdHkgPCBoZWFwW21heF0ucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gaGVhcFtwYXJlbnRdO1xuICAgICAgICAgICAgaGVhcFtwYXJlbnRdID0gaGVhcFttYXhdO1xuICAgICAgICAgICAgaGVhcFttYXhdID0gdGVtcDtcblxuICAgICAgICAgICAgLy8g57un57ut6L+b6KGM5pu05LiK5LiA5bGC55qE6L+H5rukXG4gICAgICAgICAgICBwYXJlbnQgPSBNYXRoLmNlaWwocGFyZW50IC8gMikgLSAxO1xuICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgfVxufVxuXG4vLyDlr7nloIbov5vooYzkuIvmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcbmZ1bmN0aW9uIGRvd25IZWFwQWRqdXN0KGhlYXAsIHBhcmVudCkge1xuICAgIHZhciBsZW4gPSBoZWFwLmxlbmd0aDtcblxuICAgIHdoaWxlICgyICogcGFyZW50ICsgMSA8IGxlbikge1xuICAgICAgICB2YXIgbGVmdENoaWxkID0gMiAqIHBhcmVudCArIDE7XG4gICAgICAgIHZhciByaWdodENoaWxkID0gbGVmdENoaWxkICsgMTtcbiAgICAgICAgdmFyIG1heCA9IGxlZnRDaGlsZDtcblxuICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xuICAgICAgICAgICAgbWF4ID0gaGVhcFtsZWZ0Q2hpbGRdLnByaW9yaXR5IDwgaGVhcFtyaWdodENoaWxkXS5wcmlvcml0eSA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhcFtwYXJlbnRdLnByaW9yaXR5IDwgaGVhcFttYXhdLnByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGhlYXBbcGFyZW50XTtcbiAgICAgICAgICAgIGhlYXBbcGFyZW50XSA9IGhlYXBbbWF4XTtcbiAgICAgICAgICAgIGhlYXBbbWF4XSA9IHRlbXA7XG5cbiAgICAgICAgICAgIHBhcmVudCA9IG1heDtcbiAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgIH1cbn1cblxudmFyIHRlc3QgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xudGVzdC5lblF1ZXVlKDgsIDUpO1xudGVzdC5lblF1ZXVlKDcsIDIpO1xudGVzdC5lblF1ZXVlKDYsIDEpO1xudGVzdC5lblF1ZXVlKDUsIDQpO1xudGVzdC5lblF1ZXVlKDQsIDcpO1xudGVzdC5lblF1ZXVlKDMsIDMpO1xudGVzdC5lblF1ZXVlKDIsIDgpO1xudGVzdC5lblF1ZXVlKDEsIDEwKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1F1ZXVlL1ByaW9yaXR5UXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXHJcbiAqIEFWTCBUUkVFIENsYXNzXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJpY2UgQ2hldmFsaWVyXHJcbiAqXHJcbiAqXHJcbiAqIEBkZXNjXHJcbiAqXHJcbiAqICAgIE1ldGhvZCAgICAgICAgICAgICAgICBUaW1lIENvbXBsZXhpdHlcclxuICogICAgX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cclxuICpcclxuICogICAgYWRkICAgICAgICAgICAgICAgICAgICBPKGxvZzIobikpXHJcbiAqICAgIHJlbW92ZSAgICAgICAgICAgICAgICBPKGxvZzIobikpXHJcbiAqICAgIGdldEZpcnN0ICAgICAgICAgICAgTygxKVxyXG4gKiAgICBnZXRMYXN0ICAgICAgICAgICAgICAgIE8oMSlcclxuICogICAgZ2V0Q291bnQgICAgICAgICAgICBPKDEpXHJcbiAqICAgIGFwcGx5ICAgICAgICAgICAgICAgIE8obilcclxuICogICAgY2xlYXIgICAgICAgICAgICAgICAgTyhuKVxyXG4gKlxyXG4gKiAgICBNZW1vcnkgQ29tcGxleGl0eSBpbiBPKG4pXHJcbiAqL1xuXG5mdW5jdGlvbiBOb2RlKG9iaikge1xuICAgIHRoaXMub2JqZWN0ID0gb2JqO1xuICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgIHRoaXMucmlnaHQgPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBBdmxUcmVlKCkge1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbn1cbkF2bFRyZWUuY21wID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO2Vsc2UgaWYgKGEgPCBiKSByZXR1cm4gLTE7ZWxzZSByZXR1cm4gMDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLl9hZGRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQucHJldmlvdXM7XG4gICAgbm9kZS5uZXh0ID0gcGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuXG4gICAgcGFyZW50LmxlZnQgPSBub2RlO1xuICAgIHBhcmVudC5wcmV2aW91cyA9IG5vZGU7XG5cbiAgICBpZiAobm9kZS5wcmV2aW91cykge1xuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IG5vZGU7XG4gICAgfVxufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQ7XG4gICAgbm9kZS5uZXh0ID0gcGFyZW50Lm5leHQ7XG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICBwYXJlbnQucmlnaHQgPSBub2RlO1xuICAgIHBhcmVudC5uZXh0ID0gbm9kZTtcblxuICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZTtcbiAgICB9XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5jb3VudCArPSAxO1xuICAgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUob2JqKTtcblxuICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5maXJzdCA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5yb290O1xuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMucm9vdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgdmFyIGNtcCA9IEF2bFRyZWUuY21wKG9iaiwgY3VycmVudC5vYmplY3QpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVmdChuZXdOb2RlLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJpZ2h0KG5ld05vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMZWZ0KG5ld05vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmlnaHQobmV3Tm9kZSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmhlaWdodCA8IGN1cnJlbnQubGVmdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9iYWxhbmNlKG5ld05vZGUucGFyZW50KTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VMZWZ0UmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIHZhciBhID0gbGVmdC5sZWZ0O1xuICAgIHZhciBiID0gbGVmdC5yaWdodC5sZWZ0O1xuXG4gICAgbGVmdC5yaWdodC5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLmxlZnQgPSBsZWZ0LnJpZ2h0O1xuICAgIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgbGVmdC5wYXJlbnQgPSBub2RlO1xuXG4gICAgdmFyIGxlZnRMZWZ0ID0gbGVmdC5sZWZ0O1xuICAgIGxlZnRMZWZ0LnBhcmVudCA9IGxlZnQ7XG4gICAgbGVmdExlZnQubGVmdCA9IGE7XG4gICAgbGVmdExlZnQucmlnaHQgPSBiO1xuICAgIGlmIChhICE9PSBudWxsKSB7XG4gICAgICAgIGEucGFyZW50ID0gbGVmdExlZnQ7XG4gICAgfVxuICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgIGIucGFyZW50ID0gbGVmdExlZnQ7XG4gICAgfVxuXG4gICAgbGVmdC5oZWlnaHQgPSBsZWZ0TGVmdC5oZWlnaHQgKyAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VMZWZ0TGVmdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgdmFyIGMgPSBsZWZ0LnJpZ2h0O1xuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSBsZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZWZ0LnJpZ2h0ID0gbm9kZTtcbiAgICBsZWZ0LnBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gbGVmdDtcbiAgICBub2RlLmxlZnQgPSBjO1xuICAgIGlmIChjICE9PSBudWxsKSB7XG4gICAgICAgIGMucGFyZW50ID0gbm9kZTtcbiAgICB9XG5cbiAgICBub2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0IC0gMTtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlUmlnaHRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIHZhciBhID0gcmlnaHQucmlnaHQ7XG4gICAgdmFyIGIgPSByaWdodC5sZWZ0LnJpZ2h0O1xuXG4gICAgcmlnaHQubGVmdC5yaWdodCA9IHJpZ2h0O1xuICAgIG5vZGUucmlnaHQgPSByaWdodC5sZWZ0O1xuICAgIHJpZ2h0ID0gbm9kZS5yaWdodDtcbiAgICByaWdodC5wYXJlbnQgPSBub2RlO1xuXG4gICAgdmFyIHJpZ2h0UmlnaHQgPSByaWdodC5yaWdodDtcbiAgICByaWdodFJpZ2h0LnBhcmVudCA9IHJpZ2h0O1xuICAgIHJpZ2h0UmlnaHQucmlnaHQgPSBhO1xuICAgIHJpZ2h0UmlnaHQubGVmdCA9IGI7XG4gICAgaWYgKGEgIT09IG51bGwpIHtcbiAgICAgICAgYS5wYXJlbnQgPSByaWdodFJpZ2h0O1xuICAgIH1cbiAgICBpZiAoYiAhPT0gbnVsbCkge1xuICAgICAgICBiLnBhcmVudCA9IHJpZ2h0UmlnaHQ7XG4gICAgfVxuXG4gICAgbm9kZS5yaWdodC5oZWlnaHQgPSByaWdodFJpZ2h0LmhlaWdodCArIDE7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5fYmFsYW5jZVJpZ2h0UmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgdmFyIGMgPSByaWdodC5sZWZ0O1xuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQubGVmdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IHJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJpZ2h0LmxlZnQgPSBub2RlO1xuICAgIHJpZ2h0LnBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gcmlnaHQ7XG4gICAgbm9kZS5yaWdodCA9IGM7XG4gICAgaWYgKGMgIT09IG51bGwpIHtcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xuICAgIH1cblxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEJhbGFuY2luZyB0aGUgdHJlZVxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGVmdEhlaWdodCA9IGN1cnJlbnQubGVmdCA9PT0gbnVsbCA/IDAgOiBjdXJyZW50LmxlZnQuaGVpZ2h0O1xuICAgICAgICB2YXIgcmlnaHRIZWlnaHQgPSBjdXJyZW50LnJpZ2h0ID09PSBudWxsID8gMCA6IGN1cnJlbnQucmlnaHQuaGVpZ2h0O1xuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gMSArIE1hdGgubWF4KGxlZnRIZWlnaHQsIHJpZ2h0SGVpZ2h0KTtcblxuICAgICAgICBpZiAobmV3SGVpZ2h0ID4gY3VycmVudC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGxlZnRIZWlnaHQgLSByaWdodEhlaWdodCA+IDEpIHtcblxuICAgICAgICAgICAgICAgIC8vIExlZnQgY2FzZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmxlZnQucmlnaHQgIT09IG51bGwgJiYgKGN1cnJlbnQubGVmdC5sZWZ0ID09PSBudWxsIHx8IGN1cnJlbnQubGVmdC5sZWZ0LmhlaWdodCA8IGN1cnJlbnQubGVmdC5yaWdodC5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnQgUmlnaHQgQ2FzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlTGVmdFJpZ2h0KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExlZnQgTGVmdCBDYXNlXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZUxlZnRMZWZ0KGN1cnJlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRyZWUgaGFzIGJlZW4gYmFsYW5jZWRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRIZWlnaHQgLSBsZWZ0SGVpZ2h0ID4gMSkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgY2FzZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmxlZnQgIT09IG51bGwgJiYgKGN1cnJlbnQucmlnaHQucmlnaHQgPT09IG51bGwgfHwgY3VycmVudC5yaWdodC5yaWdodC5oZWlnaHQgPCBjdXJyZW50LnJpZ2h0LmxlZnQuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCBMZWZ0IENhc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZVJpZ2h0TGVmdChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSaWdodCBSaWdodCBDYXNlXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZVJpZ2h0UmlnaHQoY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgdHJlZSBoYXMgYmVlbiBiYWxhbmNlZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGlzIGJhbGFuY2VkXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5fcmVtb3ZlKG9iaiwgdGhpcy5yb290KTtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAob2JqLCBub2RlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGNtcCA9IEF2bFRyZWUuY21wKG9iaiwgY3VycmVudC5vYmplY3QpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IGN1cnJlbnQub2JqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBOb2RlIHJlbW92YWxcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50IC09IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMubmV4dCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjaW5nIHRoZSBub2RlIGJ5IHRoZSBzbWFsbGVzdCBlbGVtZW50IGdyZWF0ZXIgdGhhbiBpdFxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjdXJyZW50LnJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGJhbGFuY2VGcm9tO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50LmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5sZWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5yaWdodCA9IHJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudC5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3ZlKG9iaiwgY3VycmVudC5sZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUob2JqLCBjdXJyZW50LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLnJlbW92ZUJ5UmVmID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBOb2RlIHJlbW92YWxcbiAgICB0aGlzLmNvdW50IC09IDE7XG5cbiAgICBpZiAobm9kZS5wcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZpcnN0ID0gbm9kZS5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucHJldmlvdXMubmV4dCA9IG5vZGUubmV4dDtcbiAgICB9XG4gICAgaWYgKG5vZGUubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxhc3QgPSBub2RlLnByZXZpb3VzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dC5wcmV2aW91cyA9IG5vZGUucHJldmlvdXM7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjaW5nIHRoZSBub2RlIGJ5IHRoZSBzbWFsbGVzdCBlbGVtZW50IGdyZWF0ZXIgdGhhbiBpdFxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcbiAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xuXG4gICAgaWYgKG5vZGUucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBsZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9iYWxhbmNlKHBhcmVudCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciByZXBsYWNlbWVudCA9IG5vZGUucmlnaHQ7XG4gICAgdmFyIGJhbGFuY2VGcm9tO1xuXG4gICAgaWYgKHJlcGxhY2VtZW50LmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudDtcblxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcblxuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSByZXBsYWNlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5sZWZ0O1xuICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZW1lbnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xuICAgIH1cbiAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xuXG4gICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICByZXBsYWNlbWVudC5yaWdodCA9IHJpZ2h0O1xuXG4gICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudC5wYXJlbnQ7XG5cbiAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICBsZWZ0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHBhcmVudDtcblxuICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xuXG4gICAgcmV0dXJuIDE7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRGaXJzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmdldExhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvdW50O1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChwcm9jZXNzaW5nRnVuYywgcGFyYW1zKSB7XG4gICAgZm9yICh2YXIgY3VycmVudCA9IHRoaXMuZmlyc3Q7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50Lm5leHQpIHtcbiAgICAgICAgcHJvY2Vzc2luZ0Z1bmMoY3VycmVudC5vYmplY3QsIHBhcmFtcyk7XG4gICAgfVxufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAocHJvY2Vzc2luZ0Z1bmMsIHBhcmFtcykge1xuICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmxhc3Q7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzKSB7XG4gICAgICAgIHByb2Nlc3NpbmdGdW5jKGN1cnJlbnQub2JqZWN0LCBwYXJhbXMpO1xuICAgIH1cbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXZsVHJlZTtcblxuY29uc29sZS5sb2coJ1xcbkFWTCB0cmVlIGluc2VydDI6ICcpO1xudmFyIHRlc3QgPSBuZXcgQXZsVHJlZSgpO1xudGVzdC5hZGQoMyk7XG50ZXN0LmFkZCgxNCk7XG50ZXN0LmFkZCgyNSk7XG50ZXN0LmFkZCg4MSk7XG50ZXN0LmFkZCg0NCk7XG5cbi8qXHJcbiAxNFxyXG4gLyAgICBcXFxyXG4gMyAgICAgICA0NFxyXG4gLyAgIFxcXHJcbiAyNSAgICAgODFcclxuICovXG5cbmNvbnNvbGUubG9nKCdyZW1vdmVfUmVjdXJzaXZlIDI6Jyk7XG5cbnRlc3QucmVtb3ZlKDgxKTtcbnRlc3QucmVtb3ZlKDMpO1xudGVzdC5yZW1vdmUoMTQpO1xudGVzdC5yZW1vdmUoMjUpO1xudGVzdC5yZW1vdmUoNDQpO1xuXG52YXIgc3RyID0gJ2Nrbm9iZmp0bHBxYWVncm1kaHMnO1xuLy92YXIgc3RyID0gJ2NrYmZqbGFlZ21kaCc7XG5cbnRlc3QgPSBuZXcgQXZsVHJlZSgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXN0LmFkZChzdHJbaV0pO1xufVxuXG50ZXN0LnJlbW92ZSgnZScpO1xudGVzdC5yZW1vdmUoJ2gnKTtcbnRlc3QucmVtb3ZlKCdiJyk7XG50ZXN0LnJlbW92ZSgnbCcpO1xudGVzdC5yZW1vdmUoJ2YnKTtcbnRlc3QucmVtb3ZlKCdqJyk7XG50ZXN0LnJlbW92ZSgnZycpO1xudGVzdC5yZW1vdmUoJ2QnKTtcbnRlc3QucmVtb3ZlKCdrJyk7XG50ZXN0LnJlbW92ZSgnYScpO1xudGVzdC5yZW1vdmUoJ20nKTtcbnRlc3QucmVtb3ZlKCduJyk7XG50ZXN0LnJlbW92ZSgnbycpO1xudGVzdC5yZW1vdmUoJ3AnKTtcbnRlc3QucmVtb3ZlKCdxJyk7XG50ZXN0LnJlbW92ZSgncicpO1xudGVzdC5yZW1vdmUoJ3MnKTtcbnRlc3QucmVtb3ZlKCd0Jyk7XG50ZXN0LnJlbW92ZSgnYycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU2VhcmNoL0FWTFRyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcclxuIE1JVCBMaWNlbnNlXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTIgU2FudGFudSBCYXN1XHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMgRGFuaWVsIFdpcnR6XHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcclxuIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxyXG4gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqL1xuXG4vLyBCYXNlZCBvbiBTYW50YW51IEJhc3UncyBCUGx1c0pTXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2FudGFudWJhc3UvQlBsdXNKU1xuLy8gTW9kaWZpZWQgZm9yIHN0YW5kLWFsb25lIHVzZVxuXG4vKipcclxuICogQGxpY2Vuc2UgQlRyZWUuanNcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vQlRyZWUuanMgZm9yIGRldGFpbHNcclxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuXG4gICAgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAxMDA7XG4gICAgICAgIHRoaXMubWVyZ2VUaHJlc2hvbGQgPSBvcHRpb25zLm1lcmdlVGhyZXNob2xkIHx8IDQwO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0TGVmdFBlZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRQZWVyO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5zZXRMZWZ0UGVlciA9IGZ1bmN0aW9uIChsZWZ0UGVlcikge1xuICAgICAgICB0aGlzLmxlZnRQZWVyID0gbGVmdFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldFJpZ2h0UGVlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRQZWVyO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5zZXRSaWdodFBlZXIgPSBmdW5jdGlvbiAocmlnaHRQZWVyKSB7XG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gcmlnaHRQZWVyO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRTdXJwbHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcigodGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMubWVyZ2VUaHJlc2hvbGQpIC8gMikpO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSaWdodFN1cnBsdXNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3VycGx1cyA9IHRoaXMuZ2V0U3VycGx1cygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNwbGljZSh0aGlzLmRhdGEubGVuZ3RoIC0gc3VycGx1cyk7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldExlZnRTdXJwbHVzRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1cnBsdXMgPSB0aGlzLmdldFN1cnBsdXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zcGxpY2UoMCwgc3VycGx1cyk7XG4gICAgfTtcblxuICAgIHZhciBJbnRlcm5hbE5vZGUgPSBmdW5jdGlvbiBJbnRlcm5hbE5vZGUob3B0aW9ucykge1xuICAgICAgICBOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgdGhpcy5sZWZ0UGVlciA9IG9wdGlvbnMubGVmdFBlZXI7XG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gb3B0aW9ucy5yaWdodFBlZXI7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoTm9kZS5wcm90b3R5cGUpO1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xuICAgICAgICAgICAgaWYgKGRhdGFbbWlkXS5rZXkgPCBrZXkpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdLmtleSA+IGtleSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlZnQgPCByaWdodCAmJiAhZm91bmQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kQ2hpbGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBpZiAoZWxlbWVudC5rZXkgPD0ga2V5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciBuZXdOb2RlcywgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LnJpZ2h0O1xuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSwgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmlnaHRFbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1syXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnQucmlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld05vZGVzO1xuICAgIH07XG5cbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZSgwLCBzcGxpdEluZGV4KSxcbiAgICAgICAgICAgIGxlZnRQZWVyOiB0aGlzLmxlZnRQZWVyLFxuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXggKyAxLCB0aGlzLmRhdGEubGVuZ3RoKSxcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkXG4gICAgICAgIH0pO1xuICAgICAgICBsZWZ0Tm9kZS5zZXRSaWdodFBlZXIocmlnaHROb2RlKTtcbiAgICAgICAgcmlnaHROb2RlLnNldExlZnRQZWVyKGxlZnROb2RlKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0UGVlci5zZXRSaWdodFBlZXIobGVmdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGVlci5zZXRMZWZ0UGVlcihyaWdodE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgbGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIG1lcmdlSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB2YXIgcmV0dmFsO1xuICAgICAgICBpZiAoZWxlbWVudC5rZXkgPD0ga2V5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XG4gICAgICAgICAgICByZXR2YWwgPSBjaGlsZC5yZW1vdmUoa2V5LCBlbGVtZW50LmxlZnQsIGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAtIDEgPyBjaGlsZC5nZXRSaWdodFBlZXIoKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PSAxICYmIHJldHZhbC5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcmV0dmFsWzBdLCByZXR2YWxbM11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHZhbFsxXSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xuICAgICAgICAgICAgcmV0dmFsID0gY2hpbGQucmVtb3ZlKGtleSwgaW5kZXggPiAwID8gY2hpbGQuZ2V0TGVmdFBlZXIoKSA6IHVuZGVmaW5lZCwgZWxlbWVudC5yaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PSAxICYmIHJldHZhbC5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcmV0dmFsWzBdLCByZXR2YWxbM11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHZhbFsxXSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZUluZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VFbGVtZW50ID0gdGhpcy5kYXRhW21lcmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPT0gNSkge1xuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudC5rZXkgPSByZXR2YWxbM107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW21lcmdlSW5kZXggLSAxXS5yaWdodCA9IHJldHZhbFszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbWVyZ2VJbmRleCArIDFdLmxlZnQgPSByZXR2YWxbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UobWVyZ2VJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcbiAgICAgICAgLy8gdmFyIGRlZmljaXQgPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdFN1cnBsdXMgPSAwO1xuICAgICAgICB2YXIgbGVmdERhdGE7XG4gICAgICAgIHZhciByaWdodFN1cnBsdXMgPSAwO1xuICAgICAgICB2YXIgcmlnaHREYXRhO1xuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xuICAgICAgICB2YXIgcmlnaHRQZWVyID0gdGhpcy5yaWdodFBlZXI7XG4gICAgICAgIGlmIChpc0RlZmluZWQobGVmdE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgbGVmdFN1cnBsdXMgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgcmlnaHRTdXJwbHVzID0gcmlnaHRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRTdXJwbHVzID4gcmlnaHRTdXJwbHVzKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFN1cnBsdXNEYXRhID0gbGVmdE1lcmdlT3B0aW9uLmdldFJpZ2h0U3VycGx1c0RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5zbGljZSgxKS5jb25jYXQoW3tcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFN1cnBsdXNEYXRhW2xlZnRTdXJwbHVzRGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgIH1dLCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XG4gICAgICAgICAgICByZXR2YWxbMl0gPSBsZWZ0U3VycGx1c0RhdGFbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgIGtleTogcmlnaHRTdXJwbHVzRGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICByaWdodDogcmlnaHRTdXJwbHVzRGF0YVswXS5sZWZ0XG4gICAgICAgICAgICB9XSwgcmlnaHRTdXJwbHVzRGF0YS5zbGljZSgwLCByaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRTdXJwbHVzRGF0YVtyaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgIHJldHZhbFszXSA9IHJpZ2h0TWVyZ2VPcHRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiByaWdodERhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodERhdGFbMF0ubGVmdFxuICAgICAgICAgICAgICAgICAgICB9XSwgcmlnaHREYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0RlZmluZWQocmlnaHREYXRhKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdERhdGFbbGVmdERhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgfV0sIHRoaXMuZGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRJbnRlcm5hbE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodERhdGEubGVuZ3RoIDwgbGVmdERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiByaWdodERhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodERhdGFbMF0ubGVmdFxuICAgICAgICAgICAgICAgICAgICB9XSwgcmlnaHREYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdERhdGFbbGVmdERhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgfV0sIHRoaXMuZGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRJbnRlcm5hbE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENoaWxkKGtleSkuZmluZChrZXkpO1xuICAgIH07XG5cbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENoaWxkKHN0YXJ0KS5yYW5nZShzdGFydCwgZW5kKTtcbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5kZW50ICsgXCJba2V5PVwiICsgZWxlbWVudC5rZXksIFwiXFxuXCIgKyBpbmRlbnQgKyBcIiAgICBMRUZUXFxuXCIgKyBlbGVtZW50LmxlZnQudG9TdHJpbmcoaW5kZW50ICsgXCIgICAgXCIpLCBcIlxcblwiICsgaW5kZW50ICsgXCIgICAgUklHSFRcXG5cIiArIGVsZW1lbnQucmlnaHQudG9TdHJpbmcoaW5kZW50ICsgXCIgICAgXCIpICsgXCJcXG5cIiArIGluZGVudCArIFwiXVwiXTtcbiAgICAgICAgfSkuam9pbihcIixcXG5cIik7XG4gICAgfTtcblxuICAgIHZhciBMZWFmTm9kZSA9IGZ1bmN0aW9uIExlYWZOb2RlKG9wdGlvbnMpIHtcbiAgICAgICAgTm9kZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBvcHRpb25zLmxlZnRQZWVyO1xuICAgICAgICB0aGlzLnJpZ2h0UGVlciA9IG9wdGlvbnMucmlnaHRQZWVyO1xuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoTm9kZS5wcm90b3R5cGUpO1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgbWlkID0gbGVmdCArIE1hdGguZmxvb3IoKHJpZ2h0IC0gbGVmdCkgLyAyKTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICAgICAgICBpZiAoZGF0YVttaWRdLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW21pZF0ua2V5ID4ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVmdCAhPT0gcmlnaHQgJiYgIWZvdW5kKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIGlmIChjbG9iYmVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1lbnQudmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBjb25kaXRpb24gbWF5IG5ldmVyIG9jY3VyLCBnaXZlbiB0aGUgd2F5IGZpbmRJbmRleCBpcyB3cml0dGVuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5rZXkgPCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4ICsgMSwgMCwge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdCgpO1xuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoIDwgdGhpcy5vcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmRhdGEubGVuZ3RoIC8gMik7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBMZWFmTm9kZSh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2UoMCwgc3BsaXRJbmRleCksXG4gICAgICAgICAgICBsZWZ0UGVlcjogdGhpcy5sZWZ0UGVlcixcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByaWdodE5vZGUgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgcmlnaHRQZWVyOiB0aGlzLnJpZ2h0UGVlcixcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xuICAgICAgICByaWdodE5vZGUuc2V0TGVmdFBlZXIobGVmdE5vZGUpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMubGVmdFBlZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLnJpZ2h0UGVlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0Tm9kZSwgdGhpcy5kYXRhW3NwbGl0SW5kZXhdLmtleSwgcmlnaHROb2RlXTtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGF0YS5sZW5ndGggJiYgZWxlbWVudC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnQudmFsdWVdLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPiB0aGlzLm1lcmdlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdE1lcmdlT3B0aW9uKSAmJiAhaXNEZWZpbmVkKHJpZ2h0TWVyZ2VPcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldHZhbCA9IFtdO1xuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XG4gICAgICAgIHZhciBsZWZ0U3VycGx1cyA9IDA7XG4gICAgICAgIHZhciBsZWZ0RGF0YTtcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XG4gICAgICAgIHZhciByaWdodERhdGE7XG4gICAgICAgIHZhciBsZWZ0UGVlciA9IHRoaXMubGVmdFBlZXI7XG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pKSB7XG4gICAgICAgICAgICBsZWZ0RGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgICByaWdodFN1cnBsdXMgPSByaWdodE1lcmdlT3B0aW9uLmdldFN1cnBsdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0U3VycGx1c0RhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0UmlnaHRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbGVmdFN1cnBsdXNEYXRhLmNvbmNhdCh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XG4gICAgICAgICAgICByZXR2YWxbMl0gPSB0aGlzLmRhdGFbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChyaWdodFN1cnBsdXNEYXRhKTtcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gcmlnaHRNZXJnZU9wdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXJnZWRMZWFmTm9kZTtcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnREYXRhKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KHJpZ2h0RGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHJpZ2h0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGVmdERhdGEuY29uY2F0KHRoaXMuZGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLnNldExlZnRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodERhdGEubGVuZ3RoIDwgbGVmdERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQocmlnaHREYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRMZWFmTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikgJiYgaXNEZWZpbmVkKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLnNldFJpZ2h0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQodGhpcy5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAmJiBlbGVtZW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgICB3aGlsZSAoaXNEZWZpbmVkKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IG5vZGUuZmluZEluZGV4KHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG5vZGUuZmluZEluZGV4KGVuZCk7XG4gICAgICAgICAgICB2YXIgbm9kZURhdGEgPSBub2RlLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgbm9kZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2gobm9kZURhdGFbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PSBub2RlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5nZXRSaWdodFBlZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgIHJldHVybiBpbmRlbnQgKyBcIltcIiArIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmtleTtcbiAgICAgICAgfSkudG9TdHJpbmcoKSArIFwiXVwiO1xuICAgIH07XG5cbiAgICB2YXIgVHJlZSA9IGZ1bmN0aW9uIFRyZWUob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9wdGlvbnMub3JkZXIgfHwgMTAwO1xuICAgICAgICB0aGlzLm1lcmdlVGhyZXNob2xkID0gb3B0aW9ucy5tZXJnZVRocmVzaG9sZCB8fCA0MDtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QudG9TdHJpbmcoXCJcIik7XG4gICAgfTtcblxuICAgIFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IHRoaXMucm9vdC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgIGlmIChuZXdOb2Rlcy5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IEludGVybmFsTm9kZSh7XG4gICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdOb2Rlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmV0dmFsID0gdGhpcy5yb290LnJlbW92ZShrZXkpO1xuICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSByZXR2YWxbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHZhbFswXTtcbiAgICB9O1xuXG4gICAgVHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5maW5kKGtleSk7XG4gICAgfTtcblxuICAgIFRyZWUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5yYW5nZShzdGFydCwgZW5kKTtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIGFsbCB0eXBlcyBvbiB0b3BcbiAgICBUcmVlLk5vZGUgPSBOb2RlO1xuICAgIFRyZWUuSW50ZXJuYWxOb2RlID0gSW50ZXJuYWxOb2RlO1xuICAgIFRyZWUuTGVhZk5vZGUgPSBMZWFmTm9kZTtcblxuICAgIC8vIEVuYWJsZSBtb2R1bGUgbG9hZGluZyBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKSB7XG4gICAgICAgIC8vIENvbW1vbkpTXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBUcmVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmVbXCJhbWRcIl0pIHtcbiAgICAgICAgLy8gQU1EXG4gICAgICAgIGRlZmluZShcIkJQbHVzVHJlZVwiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyZWU7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNoaW1cbiAgICAgICAgaWYgKCFnbG9iYWxbXCJkY29kZUlPXCJdKSB7XG4gICAgICAgICAgICBnbG9iYWxbXCJkY29kZUlPXCJdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJQbHVzVHJlZVwiXSA9IFRyZWU7XG4gICAgfVxufSkodW5kZWZpbmVkKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xuXG4vKipcclxuICogQGxpY2Vuc2UgYnRyZWUuanMgKGMpIDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2Rjb2RlSU8vYnRyZWUuanMgZm9yIGRldGFpbHNcclxuICovXG4oZnVuY3Rpb24gKG1vZHVsZSwgY29uc29sZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxyXG4gICAgICogQ29uY2F0ZW5hdGVzIG11bHRpcGxlIGFycmF5cyBpbnRvIGEgbmV3IG9uZS5cclxuICAgICAqIEBwYXJhbSB7Li4uW0FycmF5XX0gdmFyX2FyZ3NcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNvbmNhdCh2YXJfYXJncykge1xuICAgICAgICAvLyBBcnJheSNjb25jYXQgYmVoYXZlcyBzdHJhbmdlbHkgZm9yIGVtcHR5IGFycmF5cywgc28uLi5cbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGEsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyBhbiBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSB7Kn0gdlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gSW5kZXggb3IgLTEgaWYgbm90IGZvdW5kXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNlYXJjaChhLCB2KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gQXJyYXkjaW5kZXhPZiBiZWNhdXNlIGl0J3MgcmF3LiBIb3dldmVyLCB3ZVxuICAgICAgICAvLyBjYW5ub3QgdXNlIGJpbmFyeSBzZWFyY2ggYmVjYXVzZSBub2RlcyBkbyBub3QgaGF2ZSBhIGNvbXBhcmFibGVcbiAgICAgICAgLy8ga2V5LiBJZiB0aGUgY29tcGlsZXIgaXMgc21hcnQsIGl0IHdpbGwgaW5saW5lIHRoaXMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtaTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIGJ0cmVlIG5hbWVzcGFjZS5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqL1xuICAgIHZhciBidHJlZSA9IHt9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpY3RseSBjb21wYXJlcyB0d28gc3RyaW5ncywgY2hhcmFjdGVyIGJ5IGNoYXJhY3Rlci4gTm8gbG9jYWxlcywgbm8gbnVtYmVyIGV4dGVuc2lvbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgYSA8IGIsIDEgaWYgYSA+IGIsIDAgb3RoZXJ3aXNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cbiAgICBidHJlZS5zdHJjbXAgPSBmdW5jdGlvbiBzdHJjbXAoYSwgYikge1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdmFyIGFjO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdmFyIGJjO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID49IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGFjID0gYS5jaGFyQ29kZUF0KGkpKSA8IChiYyA9IGIuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFjID4gYmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHNhbWUsIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoID8gMCA6IC0xO1xuICAgIH07XG5cbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHR3byBudW1iZXJzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xuICAgIGJ0cmVlLm51bWNtcCA9IGZ1bmN0aW9uIGludGNtcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQlRyZWUgY2xhc3MgdXNpbmcgdGhlIGdpdmVuIG9yZGVyLlxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgYSBjbGFzcywgbm90IGFuIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcmRlciBEZWZhdWx0cyB0byAyXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8sID8pOm51bWJlcj19IGNvbXBhcmUgQ29tcGFyZSBpbXBsZW1lbnRhdGlvbiB0byB1c2Ugb24ga2V5c1xyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXG4gICAgYnRyZWUuY3JlYXRlID0gZnVuY3Rpb24gKG9yZGVyLCBjb21wYXJlKSB7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgb3JkZXJcbiAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3JkZXIgPSA1MjsgLy8gQmVuY2htYXJrcyBwcm9vZmVkIHRoYXQgdGhpcyBpcyBjbG9zZSB0byB0aGUgb3B0aW11bVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gTWF0aC5mbG9vcihvcmRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gcGFyc2VJbnQob3JkZXIsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGVyIDwgMSkgb3JkZXIgPSAxO1xuICAgICAgICB2YXIgbWluT3JkZXIgPSBvcmRlciA+IDEgPyBNYXRoLmZsb29yKG9yZGVyIC8gMikgOiAxO1xuXG4gICAgICAgIC8vIFVzZSBudW1jbXAgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29tcGFyZSA9IGJ0cmVlLm51bWNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZhbGlkYXRlcyBhIG5vZGUgYW5kIHByaW50cyBkZWJ1Z2dpbmcgaW5mbyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cclxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZXwhVHJlZX0gbm9kZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBieSB0aGUgY29tcGlsZXJcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhdmVzLmxlbmd0aCArIDEgIT0gbm9kZS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBJbGxlZ2FsIGxlYWYvbm9kZSBjb3VudCBpbiBcIiArIG5vZGUgKyBcIjogXCIgKyBub2RlLmxlYXZlcy5sZW5ndGggKyBcIi9cIiArIG5vZGUubm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhdmVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbGVhZiBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogXCIgKyBub2RlLmxlYXZlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubm9kZXNbaV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogSWxsZWdhbCBub2RlIGluIFwiICsgbm9kZSArIFwiIGF0IFwiICsgaSArIFwiOiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlTm9kZS5cclxuICAgICAgICAgKiBAY2xhc3MgQSBUcmVlTm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEoVHJlZU5vZGV8VHJlZSl9IHBhcmVudCBQYXJlbnQgbm9kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPCFMZWFmPj19IGxlYXZlcyBMZWFmIG5vZGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48VHJlZU5vZGU+PX0gbm9kZXMgQ2hpbGQgbm9kZXNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFRyZWVOb2RlID0gZnVuY3Rpb24gVHJlZU5vZGUocGFyZW50LCBsZWF2ZXMsIG5vZGVzKSB7XG5cbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgbm9kZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFUcmVlTm9kZXwhVHJlZX1cclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExlYWYgbm9kZXMgKG1heC4gb3JkZXIpLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhTGVhZj59XHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBsZWF2ZXMgfHwgW107XG4gICAgICAgICAgICB0aGlzLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGlsZCBub2RlcyAobWF4LiBvcmRlcisxKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48VHJlZU5vZGU+fVxyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcyB8fCBbbnVsbF07XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VhcmNoZXMgZm9yIHRoZSBub2RlIHRoYXQgd291bGQgY29udGFpbiB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7e2xlYWY6ICFMZWFmLCBpbmRleDogbnVtYmVyfXx7bm9kZTogIVRyZWVOb2RlLCBpbmRleDogbnVtYmVyfX0gTGVhZiBpZiB0aGUga2V5IGV4aXN0cywgZWxzZSB0aGUgaW5zZXJ0aW9uIG5vZGVcclxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmxlYXZlc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhLmtleSwga2V5KSA9PSAwKSByZXR1cm4geyBsZWFmOiBhLCBpbmRleDogMCB9O1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgYS5rZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uc2VhcmNoKGtleSk7IC8vIExlZnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLCBpbmRleDogMCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5sZWF2ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGIua2V5LCBrZXkpID09IDApIHJldHVybiB7IGxlYWY6IGIsIGluZGV4OiBpIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgYi5rZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tpXS5zZWFyY2goa2V5KTsgLy8gSW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMsIGluZGV4OiBpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBSaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLCBpbmRleDogaSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcywgaW5kZXg6IDAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Knx1bmRlZmluZWR9IElmIHRoZXJlIGlzIG5vIHN1Y2gga2V5LCB1bmRlZmluZWQgaXMgcmV0dXJuZWRcclxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSByZXR1cm4gcmVzdWx0LmxlYWYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYSBrZXkvdmFsdWUgcGFpciBpbnRvIHRoaXMgbm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gb3ZlcndyaXRlIFdoZXRoZXIgdG8gb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlcywgZGVmYXVsdHMgdG8gYHRydWVgXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3VjY2Vzc2Z1bGx5IHNldCwgZmFsc2UgaWYgYWxyZWFkeSBwcmVzZW50IGFuZCBvdmVyd3JpdGUgaXMgYGZhbHNlYFxyXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoKGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJ3cml0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZWFmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IC8vIEtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgdmFyIG5vZGUgPSByZXN1bHQubm9kZSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMCwgbmV3IExlYWYobm9kZSwga2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgbm9kZS5ub2Rlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYXZlcy5sZW5ndGggPiBvcmRlcikge1xuICAgICAgICAgICAgICAgIC8vIFJlYmFsYW5jZVxuICAgICAgICAgICAgICAgIG5vZGUuc3BsaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGlzIG5vZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGtleSBoYXMgYmVlbiBkZWxldGVkLCBmYWxzZSBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2goa2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmxlYWYpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsZWFmID0gcmVzdWx0LmxlYWYsXG4gICAgICAgICAgICAgICAgbm9kZSA9IGxlYWYucGFyZW50LFxuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0LmluZGV4LFxuICAgICAgICAgICAgICAgIGxlZnQgPSBub2RlLm5vZGVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBub2RlLm5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgbm9kZS5iYWxhbmNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBsZWZ0LmxlYXZlc1tsZWZ0LmxlYXZlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZWZ0LmRlbChtYXgua2V5KTtcbiAgICAgICAgICAgICAgICBtYXgucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlLmxlYXZlcy5zcGxpY2UoaW5kZXgsIDEsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYWxhbmNlcyB0aGlzIG5vZGUgdG8gZnVsZmlsbCBhbGwgY29uZGl0aW9ucy5cclxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBSb290IGhhcyBqdXN0IGEgc2luZ2xlIGNoaWxkIGFuZCBubyBsZWF2ZXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWF2ZXMubGVuZ3RoID09IDAgJiYgdGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yb290ID0gdGhpcy5ub2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucm9vdC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA+PSBtaW5PcmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGFzZWFyY2godGhpcy5wYXJlbnQubm9kZXMsIHRoaXMpLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBpbmRleCA+IDAgPyB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCAtIDFdIDogbnVsbCxcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyZW50Lm5vZGVzLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMucGFyZW50Lm5vZGVzW2luZGV4ICsgMV0gOiBudWxsO1xuICAgICAgICAgICAgdmFyIHNlcCwgbGVhZiwgcmVzdDtcbiAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCAmJiByaWdodC5sZWF2ZXMubGVuZ3RoID4gbWluT3JkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHNlcGVyYXRvciBmcm9tIHBhcmVudCB0byB0aGlzXG4gICAgICAgICAgICAgICAgc2VwID0gdGhpcy5wYXJlbnQubGVhdmVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBzZXAucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKHNlcCk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgYmxhbmsgd2l0aCB0aGUgZmlyc3QgcmlnaHQgbGVhZlxuICAgICAgICAgICAgICAgIGxlYWYgPSByaWdodC5sZWF2ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlc1tpbmRleF0gPSBsZWFmO1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmlnaHQgcmVzdCB0byB0aGlzXG4gICAgICAgICAgICAgICAgcmVzdCA9IHJpZ2h0Lm5vZGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3QgIT09IG51bGwpIHJlc3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09IG51bGwgJiYgbGVmdC5sZWF2ZXMubGVuZ3RoID4gbWluT3JkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIHRoZSBzZXBlcmF0b3IgZnJvbSBwYXJlbnQgdG8gdGhpc1xuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHNlcC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnVuc2hpZnQoc2VwKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBibGFuayB3aXRoIHRoZSBsYXN0IGxlZnQgbGVhZlxuICAgICAgICAgICAgICAgIGxlYWYgPSBsZWZ0LmxlYXZlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdID0gbGVhZjtcbiAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIHRoZSBsZWZ0IHJlc3QgdG8gdGhpc1xuICAgICAgICAgICAgICAgIHJlc3QgPSBsZWZ0Lm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy51bnNoaWZ0KHJlc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3Q7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgdGhpcyArIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnQgKyByaWdodFxuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzdCA9IG5ldyBUcmVlTm9kZSh0aGlzLnBhcmVudCwgY29uY2F0KHRoaXMubGVhdmVzLCBbc2VwXSwgcmlnaHQubGVhdmVzKSwgY29uY2F0KHRoaXMubm9kZXMsIHJpZ2h0Lm5vZGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VwZXJhdG9yIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHJlcGxhY2UgdGhlIG5vZGVzIGl0IHNlcGVyYXRlZCB3aXRoIHN1YnN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lm5vZGVzLnNwbGljZShpbmRleCwgMiwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIGxlZnQgKyBzZXBlcmF0b3IgZnJvbSBwYXJlbnQgKyB0aGlzXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzdCA9IG5ldyBUcmVlTm9kZSh0aGlzLnBhcmVudCwgY29uY2F0KGxlZnQubGVhdmVzLCBbc2VwXSwgdGhpcy5sZWF2ZXMpLCBjb25jYXQobGVmdC5ub2RlcywgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVhdmVzLnNwbGljZShpbmRleCAtIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVwbGFjZSB0aGUgbm9kZXMgaXQgc2VwZXJhdGVkIHdpdGggc3Vic3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubm9kZXMuc3BsaWNlKGluZGV4IC0gMSwgMiwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogXCIgKyB0aGlzLnRvU3RyaW5nKHRydWUpICsgXCIgaGFzIG5laXRoZXIgYSBsZWZ0IG5vciBhIHJpZ2h0IHNpYmxpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmJhbGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbGlkYXRlKHRoaXMpO1xuICAgICAgICAgICAgLy8gdmFsaWRhdGUodGhpcy5wYXJlbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuc3BsaXRzIGEgY2hpbGQuXHJcbiAgICAgICAgICogQHBhcmFtIHshTGVhZn0gbGVhZlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVRyZWVOb2RlfSByZXN0XHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS51bnNwbGl0ID0gZnVuY3Rpb24gKGxlYWYsIHJlc3QpIHtcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHJlc3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5sZWF2ZXNbMF07XG4gICAgICAgICAgICBpZiAoY29tcGFyZShsZWFmLmtleSwgYS5rZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnVuc2hpZnQobGVhZik7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zcGxpY2UoMSwgMCwgcmVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmxlYXZlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUobGVhZi5rZXksIGIua2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnNwbGljZShpLCAwLCBsZWFmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuc3BsaWNlKGkgKyAxLCAwLCByZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA+IG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwbGl0cyB0aGlzIG5vZGUuXHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IodGhpcy5sZWF2ZXMubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IFtuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoMCwgaW5kZXgpLCB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLCBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoaW5kZXggKyAxKSwgdGhpcy5ub2Rlcy5zbGljZShpbmRleCArIDEpKV07XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBbdGhpcy5sZWF2ZXNbaW5kZXhdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWYgPSB0aGlzLmxlYXZlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIHRoaXMubGVhdmVzLnNsaWNlKGluZGV4ICsgMSksIHRoaXMubm9kZXMuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC51bnNwbGl0KGxlYWYsIHJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVOb2RlcyBXaGV0aGVyIHRvIGluY2x1ZGUgc3ViLW5vZGVzIG9yIG5vdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChpbmNsdWRlTm9kZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWwucHVzaCh0aGlzLmxlYXZlc1tpXS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHMgPSBcIltcIiArIHZhbC50b1N0cmluZygpICsgXCJdXCIgKyAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlID8gXCI6KlwiIDogXCI6XCIgKyB0aGlzLnBhcmVudCk7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZU5vZGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcIiAtPiBcIiArIHRoaXMubm9kZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpbnRzIG91dCB0aGUgbm9kZXMgbGVhdmVzIGFuZCBub2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZW50XHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGVudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UgKz0gXCIgXCI7XG4gICAgICAgICAgICB9Zm9yIChpID0gdGhpcy5sZWF2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpICsgMV0gIT09IG51bGwpIHRoaXMubm9kZXNbaSArIDFdLnByaW50KGluZGVudCArIDIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwYWNlICsgdGhpcy5sZWF2ZXNbaV0ua2V5ICsgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSA/IFwiKlwiIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHRoaXMubm9kZXNbMF0ucHJpbnQoaW5kZW50ICsgMik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBMZWFmIGNvbnRhaW5pbmcgYSB2YWx1ZS5cclxuICAgICAgICAgKiBAY2xhc3MgQSBMZWFmLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVRyZWVOb2RlfSBwYXJlbnRcclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBMZWFmID0gZnVuY3Rpb24gTGVhZihwYXJlbnQsIGtleSwgdmFsdWUpIHtcblxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcmVudCBub2RlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVRyZWVOb2RlfVxyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2V5LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7ISp9XHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBWYWx1ZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5rZXk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlLlxyXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWUuXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgVHJlZU5vZGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNlcnRzIGEga2V5L3ZhbHVlIHBhaXIgaW50byB0aGUgdHJlZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gb3ZlcndyaXRlIFdoZXRoZXIgdG8gb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlcywgZGVmYXVsdHMgdG8gYHRydWVgXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc2V0LCBmYWxzZSBpZiBhbHJlYWR5IHByZXNlbnQgYW5kIG92ZXJ3cml0ZSBpcyBgZmFsc2VgXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGtleSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QucHV0KGtleSwgdmFsdWUsIG92ZXJ3cml0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgdW5kZWZpbmVkIGlzIHJldHVybmVkXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwga2V5OiBcIiArIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldChrZXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGUgdHJlZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5IGhhcyBiZWVuIGRlbGV0ZWQsIGZhbHNlIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwga2V5OiBcIiArIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmRlbChrZXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdhbGtzIHRocm91Z2ggYWxsIGtleXMgW21pbktleSwgLi4uLCBtYXhLZXldIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgKiBAcGFyYW0geygqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCkpPX0gbWF4S2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgd2Fsa3MgdGlsbCB0aGUgZW5kXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nIHRoZSBrZXkgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGFzIGl0c1xyXG4gICAgICAgICAqICBwYXJhbWV0ZXJzLiBNYXkgZXhwbGljaXRseSByZXR1cm4gdHJ1ZSB0byBzdG9wIHRoZSBsb29wLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0FzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QubGVhdmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW5LZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWluS2V5O1xuICAgICAgICAgICAgICAgIG1pbktleSA9IG1heEtleSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXhLZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWF4S2V5O1xuICAgICAgICAgICAgICAgIG1heEtleSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaW5LZXkgPSB0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbDtcbiAgICAgICAgICAgIG1heEtleSA9IHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHB0ciwgaW5kZXg7XG4gICAgICAgICAgICBpZiAobWluS2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbWluaW11bSBsaW1pdFxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucm9vdDsgLy8gc2V0IHB0ciB0byB0aGUgb3V0ZXIgbGVmdCBub2RlXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1swXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gMDsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBmaXJzdCBsZWFmXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIGxvb2t1cFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtaW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtaW5pbXVtIGtleSBpdHNlbGYgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSByZXN1bHQubGVhZi5wYXJlbnQ7IC8vIHNldCBwdHIgdG8gdGhlIGNvbnRhaW5pbmcgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5sZWF2ZXMsIHJlc3VsdC5sZWFmKTsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSByZXN1bHQubm9kZTsgLy8gc2V0IHB0ciB0byB0aGUgaW5zZXJ0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdC5pbmRleDsgLy8gYW5kIHN0YXJ0IGF0IHRoZSBpbnNlcnRpb24gaW5kZXggKGtleSA+IG1pbktleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gcHRyLmxlYXZlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gb3ZlcnJ1biwgYmVnaW4gYXQgdGhlIHNlcGFyYXRvciBpbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gcHRyLnBhcmVudC5sZWF2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVtcHR5IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHRyL2luZGV4IG5vdyBwb2ludHMgYXQgb3VyIGZpcnN0IHJlc3VsdFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4S2V5ICE9PSBudWxsICYmIGNvbXBhcmUocHRyLmxlYXZlc1tpbmRleF0ua2V5LCBtYXhLZXkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUga2V5cyBsZXNzIHRoYW4gbWF4S2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhwdHIubGVhdmVzW2luZGV4XS5rZXksIHB0ci5sZWF2ZXNbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBicmVha3MgdGhlIGxvb3AgYnkgcmV0dXJuaW5nIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHB0ci5ub2Rlc1tpbmRleCArIDFdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmRcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1swXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwdHIubGVhdmVzLmxlbmd0aCA+IGluZGV4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNjZW5kXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaW5kZXggPj0gcHRyLmxlYXZlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGlhcyBvZiB7QGxpbmsgVHJlZSN3YWxrQXNjfS5cclxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgKiBAcGFyYW0geygqfChmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBOVUxMLCB3YWxrcyB0aWxsIHRoZSBlbmRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXHJcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS53YWxrID0gVHJlZS5wcm90b3R5cGUud2Fsa0FzYztcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCBrZXlzIFttaW5LZXksIC4uLiwgbWF4S2V5XSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpfSBtaW5LZXkgSWYgb21pdHRlZCBvciBudWxsLCB3YWxrcyB0aWxsIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgKiBAcGFyYW0geygqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCkpPX0gbWF4S2V5IElmIG9taXR0ZWQgb3IgbnVsbCwgc3RhcnRzIGF0IHRoZSBlbmRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXHJcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS53YWxrRGVzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWluS2V5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1pbktleTtcbiAgICAgICAgICAgICAgICBtaW5LZXkgPSBtYXhLZXkgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4S2V5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1heEtleTtcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWluS2V5ID0gdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGw7XG4gICAgICAgICAgICBtYXhLZXkgPSB0eXBlb2YgbWF4S2V5ICE9ICd1bmRlZmluZWQnID8gbWF4S2V5IDogbnVsbDtcbiAgICAgICAgICAgIHZhciBwdHIsIGluZGV4O1xuICAgICAgICAgICAgaWYgKG1heEtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG1heGltdW0gbGltaXRcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJvb3Q7IC8vIHNldCBwdHIgdG8gdGhlIG91dGVyIHJpZ2h0IG5vZGVcbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHB0ci5sZWF2ZXMubGVuZ3RoIC0gMTsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBsYXN0IGxlYWZcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgbG9va3VwXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJvb3Quc2VhcmNoKG1heEtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1heGltdW0ga2V5IGl0c2VsZiBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5sZWFmLnBhcmVudDsgLy8gc2V0IHB0ciB0byB0aGUgY29udGFpbmluZyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5ub2RlOyAvLyBzZXQgcHRyIHRvIHRoZSBpbnNlcnRpb24gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0LmluZGV4IC0gMTsgLy8gYW5kIHN0YXJ0IGF0IHRoZSBpbnNlcnRpb24gaW5kZXgtMSAoa2V5IDwgbWF4S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdW5kZXJydW4sIGJlZ2luIGF0IHRoZSBzZXBhcmF0b3IgaW4gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwdHIvaW5kZXggbm93IHBvaW50cyBhdCBvdXIgZmlyc3QgcmVzdWx0XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaW5LZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1pbktleSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBrZXlzIGJpZ2dlciB0aGFuIG1pbktleVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socHRyLmxlYXZlc1tpbmRleF0ua2V5LCBwdHIubGVhdmVzW2luZGV4XS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgYnJlYWtzIHRoZSBsb29wIGJ5IHJldHVybmluZyB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwdHIubm9kZXNbaW5kZXhdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmRcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwdHIubGVhdmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV4dFxuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzY2VuZFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpbmRleCA8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBrZXlzIGJldHdlZW4gbWluS2V5IGFuZCBtYXhLZXkgKGJvdGggaW5jbHVzaXZlKS5cclxuICAgICAgICAgKiBAcGFyYW0geyo9fSBtaW5LZXkgSWYgb21pdHRlZCwgY291bnRzIGZyb20gdGhlIHN0YXJ0XHJcbiAgICAgICAgICogQHBhcmFtIHsqPX0gbWF4S2V5IElmIG9taXR0ZWQsIGNvdW50cyB0aWxsIHRoZSBlbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAobWluS2V5LCBtYXhLZXkpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHRoaXMud2Fsayh0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbCwgdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGwsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcmludHMgb3V0IGFsbCBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LnByaW50KDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRyZWUoXCIgKyBvcmRlciArIFwiKSBcIiArIHRoaXMucm9vdC50b1N0cmluZygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBUcmVlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJ0cmVlO1xufSkobW9kdWxlLCBjb25zb2xlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NlYXJjaC9CVHJlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJpbmFyeVNlYXJjaCA9IGJpbmFyeVNlYXJjaDtcbmV4cG9ydHMuYmluYXJ5U2VhcmNoUmVjdXJzaXZlID0gYmluYXJ5U2VhcmNoUmVjdXJzaXZlO1xuLypcclxuIOaKmOWNiuafpeaJvihCaW5hcnkgU2VhcmNoKVxyXG5cclxuIOaKmOWNiuafpeaJvuWPiOensOS4uuS6jOWIhuafpeaJvu+8jOaYr+S4gOenjeaViOeOh+i+g+mrmOeahOafpeaJvuaWueazleOAglxyXG4g5YmN5o+Q5p2h5Lu277ya5p+l5om+6KGo5Lit55qE5omA5pyJ6K6w5b2V5piv5oyJ5YWz6ZSu5a2X5pyJ5bqPKOWNh+W6j+aIlumZjeW6jykg44CCXHJcbiDmn6Xmib7ov4fnqIvkuK3vvIzlhYjnoa7lrprlvoXmn6Xmib7orrDlvZXlnKjooajkuK3nmoTojIPlm7TvvIznhLblkI7pgJDmraXnvKnlsI/ojIPlm7Qo5q+P5qyh5bCG5b6F5p+l6K6w5b2V5omA5Zyo5Yy66Ze057yp5bCP5LiA5Y2KKe+8jOebtOWIsOaJvuWIsOaIluaJvuS4jeWIsOiusOW9leS4uuatouOAglxyXG5cclxuIDEgIOafpeaJvuaAneaDs1xyXG4g55SoTG9344CBSGlnaOWSjE1pZOihqOekuuW+heafpeaJvuWMuumXtOeahOS4i+eVjOOAgeS4iueVjOWSjOS4remXtOS9jee9ruaMh+mSiO+8jOWIneWAvOS4ukxvdz0w77yMSGlnaD1uIC0gMeOAglxyXG4g4pG0ICDlj5bkuK3pl7TkvY3nva5NaWTvvJpNaWQ9TWF0aC5mbG9vcigoTG93K0hpZ2gpLzIp77ybXHJcbiDikbUgIOavlOi+g+S4remXtOS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcclxuIOKRoCAg55u4562J77yaIOafpeaJvuaIkOWKn++8m1xyXG4g4pGhICDlpKfkuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTliY3ljYrmrrXvvIzkv67mlLnkuIrnlYzmjIfpkojvvJogSGlnaD1NaWQtMe+8jOi9rOKRtCDvvJtcclxuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q6177yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m1xyXG4g55u05Yiw6LaK55WMKExvdz5IaWdoKe+8jOafpeaJvuWksei0peOAglxyXG5cclxuIDIgIOeul+azleWIhuaekFxyXG4g4pGgICDmn6Xmib7ml7bmr4/nu4/ov4fkuIDmrKHmr5TovoPvvIzmn6Xmib7ojIPlm7TlsLHnvKnlsI/kuIDljYrvvIzor6Xov4fnqIvlj6/nlKjkuIDmo7Xkuozlj4nmoJHooajnpLrvvJpcclxuIOKXhiDmoLnnu5PngrnlsLHmmK/nrKzkuIDmrKHov5vooYzmr5TovoPnmoTkuK3pl7TkvY3nva7nmoTorrDlvZXvvJtcclxuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7liY3pnaLnmoTkvZzkuLrlt6blrZDmoJHnmoTnu5PngrnvvJtcclxuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7lkI7pnaLnmoTkvZzkuLrlj7PlrZDmoJHnmoTnu5PngrnvvJtcclxuIOWvueWQhOWtkOagkeadpeivtOmDveaYr+ebuOWQjOeahOOAgui/meagt+aJgOW+l+WIsOeahOS6jOWPieagkeensOS4uuWIpOWumuagkShEZWNpc2lvbiBUcmVlKeOAglxyXG4g4pGhICDlsIbkuozlj4nliKTlrprmoJHnmoTnrKxNYXRoLmZsb29yKE1hdGgubG9nKDIsIG4pKSsx5bGC5LiK55qE57uT54K56KGl6b2Q5bCx5oiQ5Li65LiA5qO15ruh5LqM5Y+J5qCR77yM5rex5bqm5LiN5Y+Y77yMaD0gTWF0aC5mbG9vcihNYXRoLmxvZygyLCBuICsgMSkpIOOAglxyXG4g4pGiICDnlLHmu6Hkuozlj4nmoJHmgKfotKjnn6XvvIznrKxpIOWxguS4iueahOe7k+eCueaVsOS4uk1hdGgucG93KDIsIGktMSkoaTw9aCkg77yM6K6+6KGo5Lit5q+P5Liq6K6w5b2V55qE5p+l5om+5qaC546H55u4562J77yM5Y2zUGk9MS9u77yM5p+l5om+5oiQ5Yqf5pe255qE5bmz5Z2H5p+l5om+6ZW/5bqmQVNM77yaXHJcbiAobisxKS9uKk1hdGgubG9nKDIsbisxKS0xXHJcbiDlvZNu5b6I5aSnIChuPjUwKeaXtu+8jCBBU0ziiYggTWF0aC5sb2coMixuKzEpLTHjgIJcclxuXHJcblxyXG4g5pe26Ze05aSN5p2C5bqmTyhsb2duKVxyXG4gKi9cblxuLy8g6Z2e6YCS5b2S5byPXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goc1RhYmxlLCBrZXkpIHtcbiAgICB2YXIgbG93ID0gMDtcbiAgICB2YXIgaGlnaCA9IHNUYWJsZS5sZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBsb3cgKyBoaWdoID4+IDE7XG4gICAgICAgIHZhciBlbGVtID0gc1RhYmxlW21pZF07XG5cbiAgICAgICAgaWYgKGVsZW0gPT09IGtleSkgcmV0dXJuIG1pZDtlbHNlIGlmIChlbGVtIDwga2V5KSBsb3cgPSBtaWQgKyAxO2Vsc2UgaGlnaCA9IG1pZCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG5jb25zb2xlLmxvZygnYmluYXJ5U2VhcmNoOiAnKTtcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDEpKTsgLy8gMFxuXG4vLyDpgJLlvZLlvI9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShzVGFibGUsIGtleSkge1xuICAgIHZhciBsb3cgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzJdO1xuICAgIHZhciBoaWdoID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gc1RhYmxlLmxlbmd0aCAtIDEgOiBhcmd1bWVudHNbM107XG5cbiAgICBpZiAobG93ID4gaGlnaCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIG1pZCA9IGxvdyArIGhpZ2ggPj4gMTtcbiAgICB2YXIgZWxlbSA9IHNUYWJsZVttaWRdO1xuXG4gICAgaWYgKGVsZW0gPT09IGtleSkgcmV0dXJuIG1pZDtlbHNlIGlmIChlbGVtIDwga2V5KSByZXR1cm4gYmluYXJ5U2VhcmNoUmVjdXJzaXZlKHNUYWJsZSwga2V5LCBtaWQgKyAxLCBoaWdoKTtlbHNlIHJldHVybiBiaW5hcnlTZWFyY2hSZWN1cnNpdmUoc1RhYmxlLCBrZXksIGxvdywgbWlkIC0gMSk7XG59XG5cbmNvbnNvbGUubG9nKCdiaW5hcnlTZWFyY2hSZWN1cnNpdmU6ICcpO1xuY29uc29sZS5sb2coYmluYXJ5U2VhcmNoUmVjdXJzaXZlKFsxLCAyLCAzLCA0LCA1XSwgMSkpOyAvLyAwXG5jb25zb2xlLmxvZyhiaW5hcnlTZWFyY2hSZWN1cnNpdmUoWzEsIDIsIDMsIDQsIDVdLCA2KSk7IC8vIC0xXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9TZWFyY2gvQmluYXJ5U2VhcmNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfZ2V0MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQnKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Mik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yJyk7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfeHhoYXNoanMgPSByZXF1aXJlKCd4eGhhc2hqcycpO1xuXG52YXIgX2NyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgX2NyeXB0bzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcnlwdG8pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKlxyXG4gQmxvb20gRmlsdGVy5piv5LiA56eN56m66Ze05pWI546H5b6I6auY55qE6ZqP5py65pWw5o2u57uT5p6E77yM5a6D5Yip55So5L2N5pWw57uE5b6I566A5rSB5Zyw6KGo56S65LiA5Liq6ZuG5ZCI77yM5bm26IO95Yik5pat5LiA5Liq5YWD57Sg5piv5ZCm5bGe5LqO6L+Z5Liq6ZuG5ZCI44CCQmxvb20gRmlsdGVy55qE6L+Z56eN6auY5pWI5piv5pyJ5LiA5a6a5Luj5Lu355qE77ya5Zyo5Yik5pat5LiA5Liq5YWD57Sg5piv5ZCm5bGe5LqO5p+Q5Liq6ZuG5ZCI5pe277yM5pyJ5Y+v6IO95Lya5oqK5LiN5bGe5LqO6L+Z5Liq6ZuG5ZCI55qE5YWD57Sg6K+v6K6k5Li65bGe5LqO6L+Z5Liq6ZuG5ZCI77yIZmFsc2UgcG9zaXRpdmXvvInjgILlm6DmraTvvIxCbG9vbSBGaWx0ZXLkuI3pgILlkIjpgqPkupvigJzpm7bplJnor6/igJ3nmoTlupTnlKjlnLrlkIjjgILogIzlnKjog73lrrnlv43kvY7plJnor6/njofnmoTlupTnlKjlnLrlkIjkuIvvvIxCbG9vbSBGaWx0ZXLpgJrov4fmnoHlsJHnmoTplJnor6/mjaLlj5bkuoblrZjlgqjnqbrpl7TnmoTmnoHlpKfoioLnnIHjgIJcclxuXHJcbiDkuLrkuobpmY3kvY7lhrLnqoHnmoTmpoLlv7XvvIxCbG9vbSBGaWx0ZXLkvb/nlKjkuoblpJrkuKrlk4jluIzlh73mlbDvvIzogIzkuI3mmK/kuIDkuKrjgIJcclxuXHJcbiBCbG9vbSBGaWx0ZXLnrpfms5XlpoLkuIvvvJpcclxuIOWIm+W7uuS4gOS4qm3kvY1CaXRTZXTvvIzlhYjlsIbmiYDmnInkvY3liJ3lp4vljJbkuLow77yM54S25ZCO6YCJ5oupa+S4quS4jeWQjOeahOWTiOW4jOWHveaVsOOAguesrGnkuKrlk4jluIzlh73mlbDlr7nlrZfnrKbkuLJzdHLlk4jluIznmoTnu5PmnpzorrDkuLpo77yIae+8jHN0cu+8ie+8jOS4lGjvvIhp77yMc3Ry77yJ55qE6IyD5Zu05pivMOWIsG0tMSDjgIJcclxuXHJcbiAoMSkg5Yqg5YWl5a2X56ym5Liy6L+H56iLXHJcbiDkuIvpnaLmmK/mr4/kuKrlrZfnrKbkuLLlpITnkIbnmoTov4fnqIvvvIzpppblhYjmmK/lsIblrZfnrKbkuLJzdHLigJzorrDlvZXigJ3liLBCaXRTZXTkuK3nmoTov4fnqIvvvJpcclxuIOWvueS6juWtl+espuS4snN0cu+8jOWIhuWIq+iuoeeul2jvvIgx77yMc3Ry77yJ77yMaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInjgILnhLblkI7lsIZCaXRTZXTnmoTnrKxo77yIMe+8jHN0cu+8ieOAgWjvvIgy77yMc3Ry77yJ4oCm4oCmIGjvvIhr77yMc3Ry77yJ5L2N6K6+5Li6MeOAglxyXG5cclxuICgyKSDmo4Dmn6XlrZfnrKbkuLLmmK/lkKblrZjlnKjnmoTov4fnqItcclxuIOS4i+mdouaYr+ajgOafpeWtl+espuS4snN0cuaYr+WQpuiiq0JpdFNldOiusOW9lei/h+eahOi/h+eoi++8mlxyXG4g5a+55LqO5a2X56ym5Liyc3Ry77yM5YiG5Yir6K6h566XaO+8iDHvvIxzdHLvvInvvIxo77yIMu+8jHN0cu+8ieKApuKApiBo77yIa++8jHN0cu+8ieOAgueEtuWQjuajgOafpUJpdFNldOeahOesrGjvvIgx77yMc3Ry77yJ44CBaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInkvY3mmK/lkKbkuLox77yM6Iul5YW25Lit5Lu75L2V5LiA5L2N5LiN5Li6MeWImeWPr+S7peWIpOWumnN0cuS4gOWumuayoeacieiiq+iusOW9lei/h+OAguiLpeWFqOmDqOS9jemDveaYrzHvvIzliJnigJzorqTkuLrigJ3lrZfnrKbkuLJzdHLlrZjlnKjjgIJcclxuIOiLpeS4gOS4quWtl+espuS4suWvueW6lOeahEJpdOS4jeWFqOS4ujHvvIzliJnlj6/ku6Xogq/lrpror6XlrZfnrKbkuLLkuIDlrprmsqHmnInooqtCbG9vbSBGaWx0ZXLorrDlvZXov4fjgILvvIjov5nmmK/mmL7nhLbnmoTvvIzlm6DkuLrlrZfnrKbkuLLooqvorrDlvZXov4fvvIzlhbblr7nlupTnmoTkuozov5vliLbkvY3ogq/lrprlhajpg6jooqvorr7kuLox5LqG77yJXHJcbiDjgIDkvYbmmK/oi6XkuIDkuKrlrZfnrKbkuLLlr7nlupTnmoRCaXTlhajkuLox77yM5a6e6ZmF5LiK5piv5LiN6IO9MTAwJeeahOiCr+WumuivpeWtl+espuS4suiiq0Jsb29tIEZpbHRlcuiusOW9lei/h+eahOOAgu+8iOWboOS4uuacieWPr+iDveivpeWtl+espuS4sueahOaJgOacieS9jemDveWImuWlveaYr+iiq+WFtuS7luWtl+espuS4suaJgOWvueW6lO+8iei/meenjeWwhuivpeWtl+espuS4suWIkuWIhumUmeeahOaDheWGte+8jOensOS4umZhbHNlIHBvc2l0aXZl44CCXHJcblxyXG4gKDMpIOWIoOmZpOWtl+espuS4sui/h+eoi1xyXG4g5a2X56ym5Liy5Yqg5YWl5LqG5bCx6KKr5LiN6IO95Yig6Zmk5LqG77yM5Zug5Li65Yig6Zmk5Lya5b2x5ZON5Yiw5YW25LuW5a2X56ym5Liy44CC5a6e5Zyo6ZyA6KaB5Yig6Zmk5a2X56ym5Liy55qE5Y+v5Lul5L2/55SoQ291bnRpbmcgYmxvb21maWx0ZXIoQ0JGKe+8jOi/meaYr+S4gOenjeWfuuacrEJsb29tIEZpbHRlcueahOWPmOS9k++8jENCRuWwhuWfuuacrEJsb29tIEZpbHRlcuavj+S4gOS4qkJpdOaUueS4uuS4gOS4quiuoeaVsOWZqO+8jOi/meagt+WwseWPr+S7peWunueOsOWIoOmZpOWtl+espuS4sueahOWKn+iDveS6huOAglxyXG5cclxuIEJsb29tIEZpbHRlcui3n+WNleWTiOW4jOWHveaVsEJpdC1NYXDkuI3lkIzkuYvlpITlnKjkuo7vvJpCbG9vbSBGaWx0ZXLkvb/nlKjkuoZr5Liq5ZOI5biM5Ye95pWw77yM5q+P5Liq5a2X56ym5Liy6Lefa+S4qmJpdOWvueW6lOOAguS7juiAjOmZjeS9juS6huWGsueqgeeahOamgueOh+OAglxyXG5cclxuIEJsb29tIEZpbHRlcuWPguaVsOmAieaLqVxyXG4gKDEp5ZOI5biM5Ye95pWw6YCJ5oupXHJcbiDjgIDjgIDlk4jluIzlh73mlbDnmoTpgInmi6nlr7nmgKfog73nmoTlvbHlk43lupTor6XmmK/lvojlpKfnmoTvvIzkuIDkuKrlpb3nmoTlk4jluIzlh73mlbDopoHog73ov5HkvLznrYnmpoLnjofnmoTlsIblrZfnrKbkuLLmmKDlsITliLDlkITkuKpCaXTjgILpgInmi6lr5Liq5LiN5ZCM55qE5ZOI5biM5Ye95pWw5q+U6L6D6bq754Om77yM5LiA56eN566A5Y2V55qE5pa55rOV5piv6YCJ5oup5LiA5Liq5ZOI5biM5Ye95pWw77yM54S25ZCO6YCB5YWla+S4quS4jeWQjOeahOWPguaVsOOAglxyXG5cclxuICgyKSBtLG4sa+WAvO+8jOaIkeS7rOWmguS9leWPluWAvFxyXG4g5oiR5Lus5a6a5LmJ77yaXHJcbiDlj6/og73miorkuI3lsZ7kuo7ov5nkuKrpm4blkIjnmoTlhYPntKDor6/orqTkuLrlsZ7kuo7ov5nkuKrpm4blkIjvvIhGYWxzZSBQb3NpdGl2Ze+8iVxyXG4g5LiN5Lya5oqK5bGe5LqO6L+Z5Liq6ZuG5ZCI55qE5YWD57Sg6K+v6K6k5Li65LiN5bGe5LqO6L+Z5Liq6ZuG5ZCI77yIRmFsc2UgTmVnYXRpdmXvvInjgIJcclxuXHJcbiDlk4jluIzlh73mlbDnmoTkuKrmlbBr44CB5L2N5pWw57uE5aSn5bCPbeOAgeWKoOWFpeeahOWtl+espuS4suaVsOmHj27nmoTlhbPns7vjgILlk4jluIzlh73mlbDkuKrmlbBr5Y+WMTDvvIzkvY3mlbDnu4TlpKflsI9t6K6+5Li65a2X56ym5Liy5Liq5pWwbueahDIw5YCN5pe277yMZmFsc2UgcG9zaXRpdmXlj5HnlJ/nmoTmpoLnjofmmK8wLjAwMDA4ODkg77yM5Y2zMTDkuIfmrKHnmoTliKTmlq3kuK3vvIzkvJrlrZjlnKg55qyh6K+v5Yik77yM5a+55LqO5LiA5aSpMeS6v+asoeeahOafpeivou+8jOivr+WIpOeahOasoeaVsOS4ujkwMDDmrKHjgIJcclxuXHJcbiBCbG9vbWZpbHRlciDnmoTlupTnlKjlnLrmma9cclxuIDEu6buR5ZCN5Y2VXHJcbiDmnIDlhbjlnovnmoTkuIDkuKrlupTnlKjlsLHmmK/pu5HlkI3ljZXlip/og73vvIzlr7nnlKjmiLflkI3np7DmiJbogIVJUOaIluiAhUVtYWls6L+b6KGM6L+H5ruk77yM5q+P5qyh5qOA5p+l5pe255Soa2V56L+b6KGMaGFzaOWQju+8jOWmguaenOS4jeWcqOm7keWQjeWNleWGheeahO+8jOiCr+WumuWPr+S7pemAmuihjO+8jOWmguaenOWcqOeahOWImeS4jeWFgeiuuOmAmui/h++8jOivr+WIpOaDheWGteWinuWKoOS4gOS4quaOkumZpOWQjeWNleadpei/m+ihjOaOkumZpOOAglxyXG4g6K+v5Yik5oOF5Ya177ya5bCG5q2j5bi455So5oi35Yik5a6a5Li66buR5ZCN5Y2V55So5oi3XHJcblxyXG4gMi7niKzomavph43lpI1VUkzmo4DmtYtcclxuIOWcqOeIrOWPlue9keermVVSTOaXtu+8jOimgeajgOa1i+i/meadoVVSTOaYr+WQpuW3sue7j+iuv+mXrui/h+OAglxyXG4g6K+v5Yik5oOF5Ya177ya5rKh5pyJ6K6/6Zeu6L+H55qE6K+v5Yik5Li66K6/6Zeu6L+HXHJcblxyXG4gMy7lrZflhbjnuqDplJlcclxuIOajgOafpeWNleivjeaLvOWGmeaYr+WQpuato+ehrlxyXG4g6K+v5Yik5oOF5Ya177ya6ZSZ6K+v55qE5Y2V6K+N6K+v5Yik5Li65q2j56Gu44CCXHJcblxyXG4gNC7no4Hnm5jmlofku7bmo4DmtYtcclxuIOWwhuejgeebmOS4reaIluiAheaVsOaNruW6k+S4reaVsOaNrmtleeWtmOWFpeivpee7k+aehOS4re+8jOajgOa1i+imgeiuv+mXrueahOaVsOaNruaYr+WQpuWcqOejgeebmOaIluaVsOaNruW6k+S4re+8jOeEtuWQjuWGjeWPkei1t+iuv+mXru+8jOmBv+WFjeepuuafpeivoumAoOaIkOejgeebmOaIluaVsOaNruW6k+WOi+WKm+OAglxyXG4g6K+v5Yik5oOF5Ya177ya5LiN5a2Y5Zyo6K+l5pWw5o2u5Y206K+v5Yik5Li65pyJ6K+l5pWw5o2u44CCXHJcblxyXG4gNS5DRE7vvIhzcXVpZO+8ieS7o+eQhue8k+WtmOaKgOacr1xyXG4g5YWI5p+l5om+5pys5Zyw5pyJ5pegY2FjaGXvvIzlpoLmnpzmsqHmnInliJnliLDlhbbku5blhYTlvJ8gY2FjaGXmnI3liqHlmajkuIrljrvmn6Xmib7jgILkuLrkuobpgb/lhY3ml6DosJPnmoTmn6Xor6LvvIzlnKjmr4/kuKpjYWNoZeacjeWKoeWZqOS4iuS/neWtmOWFtuWFhOW8n+acjeWKoeWZqOeahOe8k+WtmOWFs+mUruWtl++8jOS7pWJsb29tZmlsdGVy5pa55byP5a2Y5YKo77yM5YaN5Y675YW25LuWY2FjaGXmnI3liqHlmajmn6Xmib7kuYvliY3vvIzlhYjmo4Dmn6Xor6Xnu5PmnoTmmK/lkKbmnIl1cmzvvIzlpoLmnpzmnInlrZjlnKh1cmzvvIzlho3ljrvlr7nlupTmnI3liqHlmajmn6Xmib7jgIJcclxuIOivr+WIpOaDheWGte+8miDlr7nlupTmnI3liqHlmajkuI3lrZjlnKjor6VVUkznmoTnvJPlrZjjgIJcclxuXHJcbiBUaGFua3MgdG86XHJcbiBodHRwOi8vYWxsZW5raW02Ny5naXRodWIuaW8vMjAxNi8wNS8xNy9ub2RlanMtYnVmZmVyLXR1dG9yaWFsLmh0bWxcclxuIGh0dHBzOi8vZ2l0aHViLmNvbS9jZWVqYm90L3h4LWJsb29tXHJcbiBodHRwczovL2dpdGh1Yi5jb20vcGllcnJlYy9qcy14eGhhc2hcclxuICovXG5cbnZhciBMTjJfU1FVQVJFRCA9IE1hdGguTE4yICogTWF0aC5MTjI7XG5cbnZhciBCbG9vbUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCbG9vbUZpbHRlcigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQmxvb21GaWx0ZXIpO1xuXG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCbG9vbUZpbHRlciwgW3tcbiAgICAgICAga2V5OiAnaW5pdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlZWRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWVkcyA9IG9wdGlvbnMuc2VlZHM7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNoZXMgPSBvcHRpb25zLnNlZWRzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWVkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0aW9ucy5oYXNoZXMgfHwgMDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlU2VlZHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5iaXRzID0gb3B0aW9ucy5iaXRzIHx8IDEwMjQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhNYXRoLmNlaWwodGhpcy5iaXRzIC8gOCkpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NsZWFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgLy8gIGJ1Zi5maWxsKDApIHRvIGluaXRpYWxpemUgYSBCdWZmZXIgdG8gemVyb2VzXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2VuZXJhdGVTZWVkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVTZWVkcygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWVkcykgdGhpcy5zZWVkcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFzaGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIHBzZXVkby1yYW5kb20gZGF0YS4gR2VuZXJhdGUgNCBieXRlcy5cbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gX2NyeXB0bzIuZGVmYXVsdC5yYW5kb21CeXRlcyg0KTtcbiAgICAgICAgICAgICAgICAvLyBSZWFkcyBhbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBmcm9tIHRoZSBCdWZmZXIgZnJvbSBpbmRleCAwXG4gICAgICAgICAgICAgICAgdGhpcy5zZWVkc1tpXSA9IGJ1Zi5yZWFkVUludDMyTEUoMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgZW5kIHVwIHdpdGggdHdvIGlkZW50aWNhbCBzZWVkcyxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyB1bmxpa2VseSBidXQgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VlZHNbaV0gPT09IHRoaXMuc2VlZHNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhZGQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGJ1Zikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmKSkge1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShidWYpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhc2hlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gKDAsIF94eGhhc2hqcy5oMzIpKGJ1ZiwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IGhhc2ggJSB0aGlzLmJpdHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEJpdChiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oYXNoZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gKDAsIF94eGhhc2hqcy5oMzIpKGl0ZW0sIHRoaXMuc2VlZHNbaV0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJpdCA9IGhhc2ggJSB0aGlzLmJpdHM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNJblNldCA9IHRoaXMuX2dldEJpdChiaXQpO1xuICAgICAgICAgICAgICAgIGlmICghaXNJblNldCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldEJpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Qml0KGJpdCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGguZmxvb3IoYml0IC8gOCk7XG4gICAgICAgICAgICB2YXIgc2hpZnQgPSBiaXQgJSA4O1xuXG4gICAgICAgICAgICB2YXIgYml0RmllbGQgPSB0aGlzLmJ1ZmZlcltwb3NdO1xuICAgICAgICAgICAgYml0RmllbGQgfD0gMHgxIDw8IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbcG9zXSA9IGJpdEZpZWxkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0Qml0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCaXQoYml0KSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gTWF0aC5mbG9vcihiaXQgLyA4KTtcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IGJpdCAlIDg7XG5cbiAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuYnVmZmVyW3Bvc107XG5cbiAgICAgICAgICAgIHJldHVybiAoYml0RmllbGQgJiAweDEgPDwgc2hpZnQpICE9PSAwO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ29wdGltaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGl0ZW1Db3VudCkge1xuICAgICAgICAgICAgdmFyIGVycm9yUmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAuMDA1IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgICB2YXIgYml0cyA9IE1hdGgucm91bmQoLTEgKiBpdGVtQ291bnQgKiBNYXRoLmxvZyhlcnJvclJhdGUpIC8gTE4yX1NRVUFSRUQpO1xuICAgICAgICAgICAgdmFyIGhhc2hlcyA9IE1hdGgucm91bmQoYml0cyAvIGl0ZW1Db3VudCAqIE1hdGguTE4yKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiaXRzOiBiaXRzLFxuICAgICAgICAgICAgICAgIGhhc2hlczogaGFzaGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjcmVhdGVPcHRpbWFsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU9wdGltYWwoaXRlbUNvdW50LCBlcnJvclJhdGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpbWl6ZShpdGVtQ291bnQsIGVycm9yUmF0ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQmxvb21GaWx0ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJsb29tRmlsdGVyO1xuXG5cbnZhciBmaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoeyBoYXNoZXM6IDgsIGJpdHM6IDEwMjQgfSk7XG5maWx0ZXIuYWRkKFsnY2F0JywgJ2RvZycsICdjb2F0aScsICdyZWQgcGFuZGEnXSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjb2F0JykpO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnbnVsbCcpKTtcblxudmFyIENvdW50aW5nQmxvb21GaWx0ZXIgPSBmdW5jdGlvbiAoX0Jsb29tRmlsdGVyKSB7XG4gICAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQ291bnRpbmdCbG9vbUZpbHRlciwgX0Jsb29tRmlsdGVyKTtcblxuICAgIGZ1bmN0aW9uIENvdW50aW5nQmxvb21GaWx0ZXIoKSB7XG4gICAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIENvdW50aW5nQmxvb21GaWx0ZXIpO1xuICAgICAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoQ291bnRpbmdCbG9vbUZpbHRlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoQ291bnRpbmdCbG9vbUZpbHRlcikpLmNhbGwodGhpcywgb3B0cykpO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKENvdW50aW5nQmxvb21GaWx0ZXIsIFt7XG4gICAgICAgIGtleTogJ2luaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zZWVkcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VlZHMgPSBvcHRzLnNlZWRzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0cy5zZWVkcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0cy5oYXNoZXMgfHwgODtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVNlZWRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYml0cyA9IG9wdHMuYml0cyB8fCAxMDI0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5iaXRzKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgICgwLCBfZ2V0My5kZWZhdWx0KShDb3VudGluZ0Jsb29tRmlsdGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoQ291bnRpbmdCbG9vbUZpbHRlci5wcm90b3R5cGUpLCAnY2xlYXInLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLm92ZXJmbG93ID0gMDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldEJpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Qml0KGJpdCkge1xuICAgICAgICAgICAgLy8gbm8tb3AgYXQgb3ZlcmZsb3dcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICArK3RoaXMub3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICArK3RoaXMuYnVmZmVyW2JpdF07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ191blNldEJpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5TZXRCaXQoYml0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXJbYml0XSA9PT0gMjU1IHx8IHRoaXMuYnVmZmVyW2JpdF0gPT09IDApIHJldHVybjtcblxuICAgICAgICAgICAgLS10aGlzLmJ1ZmZlcltiaXRdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0Qml0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCaXQoYml0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbYml0XSAhPT0gMDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpdGVtKSkgaXRlbSA9IEJ1ZmZlci5mcm9tKGl0ZW0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VlZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9ICgwLCBfeHhoYXNoanMuaDMyKShpdGVtLCB0aGlzLnNlZWRzW2ldKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdW5TZXRCaXQoYml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzT3ZlcmZsb3dlZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmZsb3cgPiAwO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2NyZWF0ZU9wdGltYWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT3B0aW1hbChpdGVtQ291bnQsIGVycm9yUmF0ZSkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBCbG9vbUZpbHRlci5vcHRpbWl6ZShpdGVtQ291bnQsIGVycm9yUmF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIENvdW50aW5nQmxvb21GaWx0ZXI7XG59KEJsb29tRmlsdGVyKTtcblxuY29uc29sZS5sb2coJ0NvdW50aW5nQmxvb21GaWx0ZXInKTtcbnZhciBmaWx0ZXIgPSBuZXcgQ291bnRpbmdCbG9vbUZpbHRlcih7IGhhc2hlczogOCwgYml0czogMTAyNCB9KTtcbmZpbHRlci5hZGQoWydjYXQnLCAnZG9nJywgJ2NvYXRpJywgJ3JlZCBwYW5kYSddKTtcbmNvbnNvbGUubG9nKGZpbHRlci5oYXMoJ2NhdCcpKTtcbmZpbHRlci5yZW1vdmUoJ2NhdCcpO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnY2F0JykpO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnY29hdCcpKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NlYXJjaC9CbG9vbUZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRyaWVUcmVlID0gZXhwb3J0cy5Eb3VibGVMaW5rZWRUcmVlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzEvMTEuXHJcbiAqL1xuXG4vKlxyXG5cclxuIOWmguaenOS4gOS4quWFs+mUruWtl+WPr+S7peihqOekuuaIkOWtl+espueahOW6j+WPt++8jOWNs+Wtl+espuS4su+8jOmCo+S5iOWPr+S7peeUqOmUruagke+8iGtleXdvcmQgdHJlZe+8ie+8jOWPiOensOaVsOWtl+aQnOe0ouagke+8iGRpZ2l0YWwgc2VhcmNoIHRyZWXvvInmiJblrZfnrKbmoJHvvIzkuZ/lj6vlrZflhbjmoJHvvIzmnaXooajnpLrov5nmoLfnmoTlrZfnrKbkuLLnmoTpm4blkIjjgIJcclxuXHJcbiDmpoLlv7VcclxuXHJcbiDlpoLmnpzkuIDkuKrlhbPplK7lrZflj6/ku6XooajnpLrmiJDlrZfnrKbnmoTluo/lj7fvvIzljbPlrZfnrKbkuLLvvIzpgqPkuYjlj6/ku6XnlKjplK7moJHvvIhrZXl3b3JkIHRyZWXvvInvvIzlj4jnp7DmlbDlrZfmkJzntKLmoJHvvIhkaWdpdGFsIHNlYXJjaCB0cmVl77yJ5oiW5a2X56ym5qCR77yM5p2l6KGo56S66L+Z5qC355qE5a2X56ym5Liy55qE6ZuG5ZCI44CC6ZSu5qCR5Y+I56ew5Li65pWw5a2X5p+l5om+5qCR77yIRGlnaXRhbCBTZWFyY2ggVHJlZSnmiJZUcmll5qCRKHRyaWXkuLpyZXRyaWV2ZeS4remXtDTkuKrlrZfnrKYp77yM5YW257uT5p6E5Y+X5ZCv5Y+R5LqO5LiA6YOo5aSn5Z6L5a2X5YW455qE4oCc5Lmm6L655qCH55uu4oCd44CC5a2X5YW45Lit5qCH5Ye66aaW5a2X5q+N5pivIEEsQixDLC4uLi5a55qE5Y2V6K+N5omA5Zyo6aG1LOWGjeWvueWQhOmDqOWIhuagh+WHuuesrOS6jOWtl+avjeS4ukEsQixDLC4uLlrnmoTljZXor43miYDlnKjnmoTpobUsIC4uLi7nrYnnrYnjgIJcclxuXHJcbiDplK7moJHmmK/kuIDnp43nibnmrornmoTmn6Xmib7moJHvvIzlroPnmoTmn5DkuKroioLngrnkuI3mmK/ljIXlkKvkuIDkuKrmiJblpJrkuKrlhbPplK7lrZfvvIzogIzmmK/lj6rljIXlkKvnu4TmiJDlhbPplK7lrZfnmoTkuIDpg6jliIbvvIjlrZfnrKbmiJbmlbDlrZfvvInvvIzmr5TlpoLvvJrlpoLmnpzlhbPplK7lrZfmmK/mlbDlgLzvvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrmlbDkvY3vvJvlpoLmnpzlhbPplK7lrZfmmK/ljZXor43vvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrlrZfmr43lrZfnrKbjgIJcclxuXHJcbiDmoLnnu5PngrnkuI3ku6Pooajku7vkvZXlrZfnrKbvvIzmoLnku6XkuIvnrKzkuIDlsYLnmoTnu5Pngrnlr7nlupTkuo7lrZfnrKbkuLLnmoTnrKzkuIDkuKrlrZfnrKbvvIznrKzkuozlsYLnmoTnu5Pngrnlr7nlupTkuo7lrZfnrKbkuLLnmoTnrKzkuozkuKrlrZfnrKbigKbigKbmr4/kuKrlrZfnrKbkuLLlj6/nlLHkuIDkuKrnibnmrornmoTlrZfnrKblpoLigJwk4oCd562J5L2c5Li65a2X56ym5Liy55qE57uT5p2f56ym77yM55So5LiA5Liq5Y+25a2Q57uT54K55p2l6KGo56S66K+l54m55q6K5a2X56ym44CC5oqK5LuO5qC55Yiw5Y+25a2Q55qE6Lev5b6E5LiK77yM5omA5pyJ57uT54K577yI6Zmk5qC55Lul5aSW77yJ5a+55bqU55qE5a2X56ym6L+e5o6l6LW35p2l77yM5bCx5b6X5Yiw5LiA5Liq5a2X56ym5Liy44CC5Zug5q2k77yM5q+P5Liq5Y+25a2Q57uT54K55a+55bqU5LiA5Liq5YWz6ZSu5a2X44CC5Zyo5Y+25a2Q57uT54K56L+Y5Y+v5Lul5YyF5ZCr5LiA5Liq5oyH6ZKI77yM5oyH5ZCR6K+l5YWz6ZSu5a2X5omA5a+55bqU55qE5YWD57Sg44CC5pW05Liq5a2X56ym5Liy6ZuG5ZCI5Lit55qE5a2X56ym5Liy55qE5pWw55uu562J5LqO5Y+25a2Q57uT54K555qE5pWw55uu44CC5aaC5p6c5LiA5Liq6ZuG5ZCI5Lit55qE5YWz6ZSu5a2X6YO95YW35pyJ6L+Z5qC355qE5a2X56ym5Liy54m55oCn77yM6YKj5LmI77yM6K+l5YWz6ZSu5a2X6ZuG5ZCI5bCx5Y+v6YeH55So6L+Z5qC35LiA5qO16ZSu5qCR5p2l6KGo56S644CC5LqL5a6e5LiK77yM6L+Y5Y+v5Lul6LWL5LqI4oCc5a2X56ym5Liy4oCd5pu05bm/5rOb55qE5ZCr5LmJ77yM5a6D5Y+v5Lul5piv5Lu75L2V57G75Z6L55qE5a+56LGh57uE5oiQ55qE5Liy44CCXHJcblxyXG5cclxuIOmUruagkeeahOWtmOWCqFxyXG4gMe+8ieWPjOmTvuagkeihqOekulxyXG4gMikg5aSa6YeN6ZO+6KGo6KGo56S6XHJcblxyXG5cclxuIOmUruagkeeahOW6lOeUqOWcuuaZr1xyXG5cclxuIFRyaWXmmK/kuIDnp43pnZ7luLjnroDljZXpq5jmlYjnmoTmlbDmja7nu5PmnoTvvIzkvYbmnInlpKfph4/nmoTlupTnlKjlrp7kvovjgIJcclxuIO+8iDHvvIkg5a2X56ym5Liy5qOA57SiXHJcbiDkuovlhYjlsIblt7Lnn6XnmoTkuIDkupvlrZfnrKbkuLLvvIjlrZflhbjvvInnmoTmnInlhbPkv6Hmga/kv53lrZjliLB0cmll5qCR6YeM77yM5p+l5om+5Y+m5aSW5LiA5Lqb5pyq55+l5a2X56ym5Liy5piv5ZCm5Ye6546w6L+H5oiW6ICF5Ye6546w6aKR546H44CCXHJcbiDkuL7kvovvvJpcclxuIEAgIOe7meWHuk4g5Liq5Y2V6K+N57uE5oiQ55qE54af6K+N6KGo77yM5Lul5Y+K5LiA56+H5YWo55So5bCP5YaZ6Iux5paH5Lmm5YaZ55qE5paH56ug77yM6K+35L2g5oyJ5pyA5pep5Ye6546w55qE6aG65bqP5YaZ5Ye65omA5pyJ5LiN5Zyo54af6K+N6KGo5Lit55qE55Sf6K+N44CCXHJcbiBAICDnu5nlh7rkuIDkuKror43lhbjvvIzlhbbkuK3nmoTljZXor43kuLrkuI3oia/ljZXor43jgILljZXor43lnYfkuLrlsI/lhpnlrZfmr43jgILlho3nu5nlh7rkuIDmrrXmlofmnKzvvIzmlofmnKznmoTmr4/kuIDooYzkuZ/nlLHlsI/lhpnlrZfmr43mnoTmiJDjgILliKTmlq3mlofmnKzkuK3mmK/lkKblkKvmnInku7vkvZXkuI3oia/ljZXor43jgILkvovlpoLvvIzoi6Vyb2LmmK/kuI3oia/ljZXor43vvIzpgqPkuYjmlofmnKxwcm9ibGVt5ZCr5pyJ5LiN6Imv5Y2V6K+N44CCXHJcblxyXG4g77yIMu+8ieWtl+espuS4suacgOmVv+WFrOWFseWJjee8gFxyXG4gVHJpZeagkeWIqeeUqOWkmuS4quWtl+espuS4sueahOWFrOWFseWJjee8gOadpeiKguecgeWtmOWCqOepuumXtO+8jOWPjeS5i++8jOW9k+aIkeS7rOaKiuWkp+mHj+Wtl+espuS4suWtmOWCqOWIsOS4gOajtXRyaWXmoJHkuIrml7bvvIzmiJHku6zlj6/ku6Xlv6vpgJ/lvpfliLDmn5DkupvlrZfnrKbkuLLnmoTlhazlhbHliY3nvIDjgIJcclxuIOS4vuS+i++8mlxyXG4gQCDnu5nlh7pOIOS4quWwj+WGmeiLseaWh+Wtl+avjeS4su+8jOS7peWPilEg5Liq6K+i6Zeu77yM5Y2z6K+i6Zeu5p+Q5Lik5Liq5Liy55qE5pyA6ZW/5YWs5YWx5YmN57yA55qE6ZW/5bqm5piv5aSa5bCR77yfXHJcbiDop6PlhrPmlrnmoYjvvJrpppblhYjlr7nmiYDmnInnmoTkuLLlu7rnq4vlhbblr7nlupTnmoTlrZfmr43moJHjgILmraTml7blj5HnjrDvvIzlr7nkuo7kuKTkuKrkuLLnmoTmnIDplb/lhazlhbHliY3nvIDnmoTplb/luqbljbPlroPku6zmiYDlnKjnu5PngrnnmoTlhazlhbHnpZblhYjkuKrmlbDvvIzkuo7mmK/vvIzpl67popjlsLHovazljJbkuLrkuobnprvnur/vvIhPZmZsaW5l77yJ55qE5pyA6L+R5YWs5YWx56WW5YWI77yITGVhc3QgQ29tbW9uIEFuY2VzdG9y77yM566A56ewTENB77yJ6Zeu6aKY44CCXHJcbiDogIzmnIDov5HlhazlhbHnpZblhYjpl67popjlkIzmoLfmmK/kuIDkuKrnu4/lhbjpl67popjvvIzlj6/ku6XnlKjkuIvpnaLlh6Dnp43mlrnms5XvvJpcclxuIDEuIOWIqeeUqOW5tuafpembhu+8iERpc2pvaW50IFNldO+8ie+8jOWPr+S7pemHh+eUqOmHh+eUqOe7j+WFuOeahFRhcmphbiDnrpfms5XvvJtcclxuIDIuIOaxguWHuuWtl+avjeagkeeahOasp+aLieW6j+WIl++8iEV1bGVyIFNlcXVlbmNlIO+8ieWQju+8jOWwseWPr+S7pei9rOS4uue7j+WFuOeahOacgOWwj+WAvOafpeivou+8iFJhbmdlIE1pbmltdW0gUXVlcnnvvIznroDnp7BSTVHvvInpl67popjkuobvvJtcclxuIO+8iOWFs+S6juW5tuafpembhu+8jFRhcmphbueul+azle+8jFJNUemXrumimO+8jOe9keS4iuacieW+iOWkmui1hOaWmeOAgu+8iVxyXG5cclxuIO+8iDPvvInmjpLluo9cclxuIFRyaWXmoJHmmK/kuIDmo7XlpJrlj4nmoJHvvIzlj6ropoHlhYjluo/pgY3ljobmlbTmo7XmoJHvvIzovpPlh7rnm7jlupTnmoTlrZfnrKbkuLLkvr/mmK/mjInlrZflhbjluo/mjpLluo/nmoTnu5PmnpzjgIJcclxuIOS4vuS+i++8mlxyXG4gQCDnu5nkvaBOIOS4quS6kuS4jeebuOWQjOeahOS7heeUseS4gOS4quWNleivjeaehOaIkOeahOiLseaWh+WQje+8jOiuqeS9oOWwhuWug+S7rOaMieWtl+WFuOW6j+S7juWwj+WIsOWkp+aOkuW6j+i+k+WHuuOAglxyXG5cclxuIO+8iDTvvIkg5L2c5Li65YW25LuW5pWw5o2u57uT5p6E5ZKM566X5rOV55qE6L6F5Yqp57uT5p6EXHJcbiDlpoLlkI7nvIDmoJHvvIxBQ+iHquWKqOacuuetiVxyXG4gKi9cblxuLypcclxuIOWPjOmTvuagkeihqOekulxyXG5cclxuIOS7peagkeeahOWtqeWtkOWFhOW8n+mTvuihqOadpeihqOekuumUruagke+8jOWImeavj+S4quWIhuaUr+e7k+eCueWMheaLrOS4ieS4quWfn++8mlxyXG4gc3ltYm9s5Z+f77ya5a2Y5YKo5YWz6ZSu5a2X55qE5LiA5Liq5a2X56ym77ybXHJcbiBmaXJzdOWfn++8muWtmOWCqOaMh+WQkeesrOS4gOajteWtkOagkeagueeahOaMh+mSiO+8m1xyXG4gbmV4dOWfn++8muWtmOWCqOaMh+WQkeWPs+WFhOW8n+eahOaMh+mSiOOAglxyXG5cclxuIOWQjOaXtu+8jOWPtuWtkOe7k+eCueS4jeWQq2ZpcnN05Z+f77yM5a6D55qEaW5mb3B0cuWfn+WtmOWCqOaMh+WQkeivpeWFs+mUruWtl+iusOW9leeahOaMh+mSiOOAglxyXG4g5q2k5pe255qE6ZSu5qCR5Y+I56ew5Y+M6ZO+5qCR44CCXHJcbiDlnKjlj4zpk77moJHkuK3mj5LlhaXmiJbliKDpmaTkuIDkuKrlhbPplK7lrZfvvIznm7jlvZPkuo7lnKjmoJHkuK3mn5DkuKrnu5PngrnkuIrmj5LlhaXmiJbliKDpmaTkuIDmo7XlrZDmoJHjgIJcclxuIOe7k+eCueeahOe7k+aehOS4reWPr+S7peiuvue9ruS4gOS4quaemuS4vuWPmOmHj+ihqOekuue7k+eCueeahOexu+Wei++8jOWPtuWtkOe7k+eCueWSjOWIhuaUr+e7k+eCueOAglxyXG4g5Y+25a2Q57uT54K55ZKM5YiG5pSv57uT54K56YO95pyJc3ltYm9s5Z+f5ZKMbmV4dOWfn+OAguS4jeWQjOeahOS4gOS4quWfn+WPr+S7peeUqOiBlOWQiOihqOekuu+8jOWPtuWtkOe7k+eCueWMheWQq2luZm9wdHLmjIflkJHorrDlvZXvvIzogIzliIbmlK/nu5PngrnmmK9maXJzdOWfn+aMh+WQkeWFtuesrOS4gOajteWtkOagkeOAglxyXG5cclxuXHJcbiDlj4zpk77moJHnmoTmn6Xmib5cclxuXHJcbiDlgYforr7nu5nlrprlgLzkuLpLLmNoKDAuLm51bS0xKSwg5YW25LitSy5jaFswXeiHsyBLLmNoW251bS0yXeihqOekuuW+heafpeWFs+mUruWtl+S4rW51bS0x5Liq5a2X56ym77yMIEsuY2hbbnVtLTFd5Li657uT5p2f56ymJOOAglxyXG4g5LuO5Y+M6ZO+5qCR55qE5qC55oyH6ZKI5Ye65Y+R77yM6aG6Zmlyc3TmjIfpkojmib7liLDnrKzkuIDmo7XlrZDmoJHnmoTmoLnnu5PngrnvvIzku6VLLmNoWzBd5ZKM5q2k57uT54K555qEc3ltYm9s5Z+f5q+U6L6D77yM6Iul55u4562J77yM5YiZ6aG6Zmlyc3Tln5/lho3mr5TovoPkuIvkuIDlrZfnrKbvvIzlkKbliJnmsr9uZXh05Z+f6aG65bqP5p+l5om+44CCXHJcbiDoi6Xnm7Toh7Pnqbrku43mr5TovoPkuI3nrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcclxuXHJcbiAvLyDnm7jlhbPotYTmlplcclxuIGh0dHA6Ly93d3cuY25ibG9ncy5jb20vcm9sbGVuaG9sdC9hcmNoaXZlLzIwMTIvMDQvMjQvMjQ2ODkzMi5odG1sXHJcbiBodHRwOi8vYmxvZy5jc2RuLm5ldC92X2p1bHlfdi9hcnRpY2xlL2RldGFpbHMvNjg5NzA5N1xyXG4gaHR0cDovL3d3dy5yYXljaGFzZS5uZXQvMTc4M1xyXG4gKi9cblxudmFyIExFQUYgPSAnbGVhZic7XG52YXIgQlJBTkNIID0gJ2JyYW5jaCc7XG52YXIgVEVSTUlOQUwgPSBuZXcgU3RyaW5nKCckJyk7XG5cbnZhciBEb3VibGVMaW5rZWRUcmVlID0gZXhwb3J0cy5Eb3VibGVMaW5rZWRUcmVlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvdWJsZUxpbmtlZFRyZWUoKSB7XG4gICAgICAgIHZhciBzeW1ib2wgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAncm9vdCcgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBraW5kID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gQlJBTkNIIDogYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaW5mbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIERvdWJsZUxpbmtlZFRyZWUpO1xuXG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShEb3VibGVMaW5rZWRUcmVlLCBbe1xuICAgICAgICBrZXk6ICdzeW5vU2VhcmNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5bm9TZWFyY2goa2V5KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZmlyc3Q7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBwICYmIGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAocCAmJiBwLmtpbmQgPT09IExFQUYpIGJyZWFrO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwICYmIHAuc3ltYm9sIDwga2V5W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfWlmIChwICYmIHAuc3ltYm9sID09PSBrZXlbaV0pIHAgPSBwLmZpcnN0O2Vsc2UgcCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwICYmIHAua2luZCA9PT0gTEVBRiA/IHAuaW5mbyA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlYXJjaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2goa2V5KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZmlyc3Q7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBwICYmIGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgIH1pZiAocCAmJiBwLnN5bWJvbCA9PT0ga2V5W2ldKSBwID0gcC5maXJzdDtlbHNlIHAgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnNlcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGtleSArPSAnJztcbiAgICAgICAgICAgIHZhciBjdXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0ga2V5W2ldO1xuICAgICAgICAgICAgICAgIHZhciBwID0gY3VyO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5maXJzdDtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKGMsIEJSQU5DSCk7XG5cbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInlrZDnu5PngrnliJnlsIbmlrDnu5PngrnkvZzkuLrlrZDnu5PngrlcbiAgICAgICAgICAgICAgICBpZiAoIWN1cikge1xuICAgICAgICAgICAgICAgICAgICBwLmZpcnN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqOWFhOW8n+e7k+eCueS4reaJvuWIsOWvueW6lOe7k+eCuVxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA8IGN1ci5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmZpcnN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA+IGN1ci5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOebuOetie+8jOmAgOWHuuivpeW+queOr+afpeaJvuS4i+S4gOWtl+esplxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBjdXIuc3ltYm9sKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzlsI/kuo7lvZPliY3lrZfnrKbvvIzliJnmj5LlhaXliLDlvZPliY3nu5PngrnliY3pnaJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjIDwgY3VyLnN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uZXh0ID0gY3VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInlhYTlvJ/nu5PngrnliJnmj5LlhaXliLDlhYTlvJ/nu5PngrlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IGIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOeUn+aIkOWPtuWtkOe7k+eCuVxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjdXIua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY3VyLmZpcnN0O1xuXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5LiN5a2Y5Zyo5YWz6ZSu5a2X5YiZ6K+05piO5o+S5YWl5oiQ5Yqf77yM5ZCm5YiZ5o+S5YWl5aSx6LSlXG4gICAgICAgICAgICAgICAgaWYgKCEoY2hpbGQgJiYgY2hpbGQuc3ltYm9sID09PSBURVJNSU5BTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmZpcnN0ID0gbmV3IERvdWJsZUxpbmtlZFRyZWUoVEVSTUlOQUwsIExFQUYsIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5maXJzdC5wYXJlbnQgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5maXJzdC5uZXh0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZmlyc3Q7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChwICYmIGkgPCBrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5zeW1ib2wgPCBrZXlbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICB9aWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gcC5pbmZvO1xuICAgICAgICAgICAgd2hpbGUgKCFwLm5leHQgJiYgcC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgICB9dmFyIHRvcCA9IHA7XG5cbiAgICAgICAgICAgIGlmICh0b3AgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gdG9wLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuZmlyc3Q7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT0gdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDliKDpmaTlnKhmaXJzdOWfn+S4iueahOWtkOagkee7k+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRvcC5wYXJlbnQuZmlyc3QgPSB0b3AucGFyZW50LmZpcnN0Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDliKDpmaTlnKhuZXh05Z+f55qE5YWE5byf57uT54K5XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHByZS5uZXh0ID0gcHJlLm5leHQubmV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBEb3VibGVMaW5rZWRUcmVlO1xufSgpO1xuXG52YXIgdGVzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKCk7XG50ZXN0Lmluc2VydCgnQ0FJJyk7XG50ZXN0Lmluc2VydCgnTEFOJyk7XG50ZXN0Lmluc2VydCgnQ0FPJyk7XG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcbnRlc3QuaW5zZXJ0KCdDSEFPJyk7XG50ZXN0Lmluc2VydCgnQ0hFTicpO1xudGVzdC5pbnNlcnQoJ0xJJyk7XG50ZXN0Lmluc2VydCgnTElVJyk7XG50ZXN0Lmluc2VydCgnWkhBTycpO1xudGVzdC5pbnNlcnQoJ1pIQU8nKTtcblxuY29uc29sZS5sb2coJ1xcbnNlYXJjaDogJyk7XG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0FJJykpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdDSEFORycpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPeCcpKTtcblxuY29uc29sZS5sb2coJ1xcbnJlbW92ZTonKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQUknKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0FJJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0xBTicpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQU8nKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hBJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU5HJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU8nKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hFTicpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSScpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSVUnKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnWkhBTycpKTtcblxuLypcclxuIOWkmumHjemTvuihqOihqOekulxyXG5cclxuIOiLpeS7peagkeeahOWkmumHjemTvuihqOihqOekuumUruagke+8jOWImeagkeeahOavj+S4que7k+eCueS4reW6lOWQq+aciWTkuKrmjIfpkojln5/vvIzmraTml7bnmoTplK7moJHlj4jnp7BUcmll5qCR44CCXHJcbiDvvIhUcmll5piv5LuO5qOA57SicmV0cmlldmXkuK3lj5bkuK3pl7Tlm5vkuKrlrZfnrKbnmoTvvIzor7vpn7PlkIx0cnnvvInjgIJcclxuIOiLpeS7jumUruagkeS4reafkOS4que7k+eCueWIsOWPtuWtkOe7k+eCueeahOi3r+W+hOS4iuavj+S4que7k+eCuemDveWPquacieS4gOS4quWtqeWtkO+8jOWImeWPr+Wwhuivpei3r+W+hOS4iuaJgOaciee7k+eCueWOi+e8qeaIkOS4gOS4quKAnOWPtuWtkOe7k+eCueKAne+8jOS4lOWcqOivpeWPtuWtkOe7k+eCueS4reWtmOWCqOWFs+mUruWtl+WPiuaMh+WQkeiusOW9leeahOaMh+mSiOetieS/oeaBr+OAglxyXG4g5ZyoVHJpZeagkeS4reacieS4pOenjee7k+eCue+8mlxyXG4g5YiG5pSv57uT54K577ya5ZCr5pyJZOS4quaMh+mSiOWfn+WSjOS4gOS4quaMh+ekuuivpee7k+eCueS4remdnuepuuaMh+mSiOWfn+eahOS4quaVsOeahOaVtOaVsOWfn+OAguWcqOWIhuaUr+e7k+eCueS4reS4jeiuvuaVsOaNruWfn++8jOavj+S4quWIhuaUr+e7k+eCueaJgOihqOekuueahOWtl+espuWdh+acieWFtueItue7k+eCueS4reaMh+WQkeivpee7k+eCueeahOaMh+mSiOaJgOWcqOS9jee9ruWGs+WumuOAglxyXG4g5Y+25a2Q57uT54K577ya5ZCr5pyJ5YWz6ZSu5a2X5Z+f5ZKM5oyH5ZCR6K6w5b2V55qE5oyH6ZKI5Z+f44CCXHJcblxyXG5cclxuIOWcqFRyaWXmoJHkuIrov5vooYzmn6Xmib5cclxuXHJcbiDku47moLnnu5Pngrnlh7rlj5HvvIzmsr/lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojpgJDlsYLlkJHkuIvvvIznm7Toh7Plj7blrZDnu5PngrnvvIzoi6Xlj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLznm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvIzoi6XliIbmlK/nu5PngrnkuK3lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojkuLrnqbrvvIzmiJblj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLzkuI3nm7jnrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcclxuXHJcblxyXG4g5LyY5YyWVHJpZeagkeeahOa3seW6plxyXG5cclxuIOaIkeS7rOWPr+WvueWFs+mUruWtl+mbhumAieaLqeS4gOenjeWQiOmAgueahOWIhuWJsuOAguWFiOaMiemmluWtl+espuS4jemAmuWIhuaIkOWkmuS4quWtkOmbhuS5i+WQju+8jOeEtuWQjuaMieacgOWQjuS4gOS4quWtl+espuS4jeWQjOWIhuWJsuavj+S4quWtkOmbhu+8jOWGjeaMieesrOS6jOS4quWtl+espuOAguOAguOAguWJjeWQjuS6pOWPieWIhuWJsuOAguS4gOe8qeWHj1RyaWXmoJHnmoTmt7HluqZcclxuICovXG4vLyDmsYLlrZfnrKblnKjlrZfmr43ooajkuK3nmoTluo/lj7dcbmZ1bmN0aW9uIG9yZGVyKGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9Mb3dlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gJ2EnLmNoYXJDb2RlQXQoMCkgKyAxIDogMDtcbn1cblxuLy8g6YCa6L+H5Zue5rqv5rOV5riF55CGVHJpZeagkeeahOWHveaVsFxuZnVuY3Rpb24gcmVtb3ZlTm9kZSh0cmllTm9kZSwgb3JkZXIsIGNsZWFyKSB7XG4gICAgdHJpZU5vZGUuYnJhbmNoLm5vZGVzW29yZGVyXSA9IG51bGw7XG4gICAgLS10cmllTm9kZS5icmFuY2gubnVtO1xuXG4gICAgaWYgKCFjbGVhcikgcmV0dXJuO1xuXG4gICAgdmFyIG5vZGVzID0gdHJpZU5vZGUuYnJhbmNoLm5vZGVzO1xuICAgIHZhciBwYXJlbnQgPSB0cmllTm9kZS5wYXJlbnQ7XG4gICAgdmFyIHByZSA9IHRyaWVOb2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgbm9kZXNbaV0pIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHBhcmVudE5vZGVzID0gcGFyZW50LmJyYW5jaC5ub2RlcztcbiAgICAgICAgZm9yICh2YXIgX2kgaW4gcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2Rlcy5oYXNPd25Qcm9wZXJ0eShfaSkgJiYgcGFyZW50Tm9kZXNbX2ldICYmIHBhcmVudE5vZGVzW19pXSA9PSBwcmUpIGluZGV4ID0gX2k7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmJyYW5jaC5ub2Rlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAtLXBhcmVudC5icmFuY2gubnVtO1xuXG4gICAgICAgIHByZSA9IHBhcmVudDtcbiAgICAgICAgbm9kZXMgPSBwYXJlbnQuYnJhbmNoLm5vZGVzO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn1cblxudmFyIFRyaWVUcmVlID0gZXhwb3J0cy5UcmllVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmllVHJlZSgpIHtcbiAgICAgICAgdmFyIGtpbmQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBCUkFOQ0ggOiBhcmd1bWVudHNbMF07XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFRyaWVUcmVlKTtcblxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGtpbmQgPT09IExFQUYpIHtcbiAgICAgICAgICAgIHRoaXMubGVhZiA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgaW5mbzogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnJhbmNoID0ge1xuICAgICAgICAgICAgICAgIC8vIOKAnCTigJ3kuLrnrKzkuIDkuKrlrZfnrKbvvIzlkI7nu63kuLoyNuS4quWtl+avjVxuICAgICAgICAgICAgICAgIG5vZGVzOiBuZXcgQXJyYXkoMjcpLFxuICAgICAgICAgICAgICAgIG51bTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFRyaWVUcmVlLCBbe1xuICAgICAgICBrZXk6ICdzZWFyY2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoKGtleSkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IHAgJiYgcC5raW5kID09PSBCUkFOQ0ggJiYgaSA8IGtleS5sZW5ndGg7IHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKSB7fVxuXG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwLmtpbmQgPT09IExFQUYgJiYgcC5sZWFmLmtleSA9PT0ga2V5KSByZXR1cm4gcC5sZWFmLmluZm87XG4gICAgICAgICAgICAgICAgLy8g5ZCM5LmJ6K+NXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkgcmV0dXJuIHAubGVhZi5pbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbnNlcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIOW7uuWPtuWtkOe7k+eCuVxuICAgICAgICAgICAgdmFyIHEgPSBuZXcgVHJpZVRyZWUoTEVBRik7XG4gICAgICAgICAgICBxLmxlYWYua2V5ID0ga2V5O1xuICAgICAgICAgICAgcS5sZWFmLmluZm8gPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8g6Ieq5LiK6ICM5LiL5p+l5om+XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoICYmIHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldOyBwID0gcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0sICsraSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBwO1xuICAgICAgICAgICAgfSAvLyDlpoLmnpzmnIDlkI7okL3liLDliIbmlK/nu5PngrnvvIjml6DlkIzkuYnor43vvIlcbiAgICAgICAgICAgIC8vIOebtOaOpei/nuS4iuWPtuWtkFxuICAgICAgICAgICAgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICAgICAgcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0gPSBxO1xuICAgICAgICAgICAgICAgIHEucGFyZW50ID0gcDtcbiAgICAgICAgICAgICAgICArK3AuYnJhbmNoLm51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOWmguaenOacgOWQjuiQveWIsOWPtuWtkOe7k+eCue+8iOacieWQjOS5ieivje+8iVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyDlu7rnq4vmlrDnmoTliIbmlK/nu5PngrlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgVHJpZVRyZWUoQlJBTkNIKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g55So5paw55qE5YiG5pSv57uT54K55Y+W5Luj6ICB5Y+25a2Q57uT54K55ZKM5LiK5LiA5bGC55qE6IGU57O7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpIC0gMV0pXSA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHIucGFyZW50ID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgci5icmFuY2gubnVtID0gMjtcbiAgICAgICAgICAgICAgICAgICAgci5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0gPSBxO1xuICAgICAgICAgICAgICAgICAgICBxLnBhcmVudCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIOaWsOWIhuaUr+e7k+eCueS4juaWsOiAgeS4pOS4quWPtuWtkOe7k+eCueebuOi/nlxuICAgICAgICAgICAgICAgICAgICByLmJyYW5jaC5ub2Rlc1tvcmRlcihwLmxlYWYua2V5W2ldKV0gPSBwO1xuICAgICAgICAgICAgICAgICAgICBwLnBhcmVudCA9IHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXIg5piv5ZCm6ZyA6KaB5riF55CG57uT54K5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9IOWmguaenOWIoOmZpOaIkOWKn+i/lOWbnmluZm/mlbDmja7lkKbliJnov5Tlm55mYWxzZVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSwgY2xlYXIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgLy8g5p+l5om+5b6F5Yig6Zmk5YWD57SgXG4gICAgICAgICAgICBmb3IgKDsgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aDsgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gcDtcbiAgICAgICAgICAgIH1pZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgY2xlYXIgPSB0eXBlb2YgY2xlYXIgIT09ICd1bmRlZmluZWQnID8gY2xlYXIgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocC5raW5kID09PSBMRUFGICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwLmxlYWYuaW5mbztcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGxhc3QsIG9yZGVyKGtleVtpIC0gMV0pLCBjbGVhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcC5sZWFmLmluZm87XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUocC5wYXJlbnQsIDAsIGNsZWFyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFRyaWVUcmVlO1xufSgpO1xuXG52YXIgdGVzdCA9IG5ldyBUcmllVHJlZSgpO1xuXG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcbnRlc3QuaW5zZXJ0KCdDQUknKTtcbnRlc3QuaW5zZXJ0KCdDSEVOJyk7XG50ZXN0Lmluc2VydCgnQ0FPJyk7XG50ZXN0Lmluc2VydCgnQ0hBTycpO1xudGVzdC5pbnNlcnQoJ0xPTkcnKTtcbnRlc3QuaW5zZXJ0KCdMSScpO1xudGVzdC5pbnNlcnQoJ0xBTicpO1xudGVzdC5pbnNlcnQoJ0xJVScpO1xudGVzdC5pbnNlcnQoJ1dBTkcnKTtcbnRlc3QuaW5zZXJ0KCdXRU4nKTtcbnRlc3QuaW5zZXJ0KCdXVScpO1xudGVzdC5pbnNlcnQoJ1lBTkcnKTtcbnRlc3QuaW5zZXJ0KCdZVU4nKTtcbnRlc3QuaW5zZXJ0KCdaSEFPJyk7XG5cbmNvbnNvbGUubG9nKCdcXG5zZWFyY2g6ICcpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ1lVTicpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPJykpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcblxudGVzdC5yZW1vdmUoJ0xBTicpO1xudGVzdC5yZW1vdmUoJ0xJVScpO1xudGVzdC5yZW1vdmUoJ1dBTkcnKTtcbnRlc3QucmVtb3ZlKCdXRU4nKTtcbnRlc3QucmVtb3ZlKCdXVScpO1xudGVzdC5yZW1vdmUoJ1lBTkcnKTtcbnRlc3QucmVtb3ZlKCdZVU4nKTtcbnRlc3QucmVtb3ZlKCdaSEFPJyk7XG50ZXN0LnJlbW92ZSgnQ0hBJyk7XG50ZXN0LnJlbW92ZSgnQ0hBTkcnKTtcbnRlc3QucmVtb3ZlKCdDQUknKTtcbnRlc3QucmVtb3ZlKCdDSEVOJyk7XG50ZXN0LnJlbW92ZSgnQ0FPJyk7XG50ZXN0LnJlbW92ZSgnQ0hBTycpO1xudGVzdC5yZW1vdmUoJ0xPTkcnKTtcbnRlc3QucmVtb3ZlKCdMSScpO1xuXG50ZXN0Lmluc2VydCgnTEknKTtcbnRlc3QuaW5zZXJ0KCdMQU4nKTtcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NlYXJjaC9EaWdpdGFsU2VhcmNoVHJlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxpbmtlZExpc3RIYXNoVGFibGUgPSBleHBvcnRzLkhhc2hUYWJsZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfTGlua2VkTGlzdCA9IHJlcXVpcmUoJy4uL0xpc3QvTGlua2VkTGlzdCcpO1xuXG52YXIgX0xpbmtlZExpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlua2VkTGlzdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBoYXNoU2l6ZSA9IGJ1aWxkSGFzaFNpemUoOTc3LCAyMCk7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBIYXNoVGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTQvMTIvMzAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4vKipcclxu5ZOI5biMKOaVo+WIlynmn6Xmib5cclxuXHJcbuWfuuacrOaAneaDs++8muWcqOiusOW9leeahOWtmOWCqOWcsOWdgOWSjOWug+eahOWFs+mUruWtl+S5i+mXtOW7uueri+S4gOS4quehruWumueahOWvueW6lOWFs+ezu++8m+i/meagt++8jOS4jee7j+i/h+avlOi+g++8jOS4gOasoeWtmOWPluWwseiDveW+l+WIsOaJgOafpeWFg+e0oOeahOafpeaJvuaWueazleOAglxyXG5cclxu5Z+65pys5qaC5b+1XHJcblxyXG7lk4jluIzlh73mlbDvvJrlnKjorrDlvZXnmoTlhbPplK7lrZfkuI7orrDlvZXnmoTlrZjlgqjlnLDlnYDkuYvpl7Tlu7rnq4vnmoTkuIDnp43lr7nlupTlhbPns7vlj6vlk4jluIzlh73mlbDjgIJcclxu5ZOI5biM5Ye95pWw5piv5LiA56eN5pig6LGh77yM5piv5LuO5YWz6ZSu5a2X56m66Ze05Yiw5a2Y5YKo5Zyw5Z2A56m66Ze055qE5LiA56eN5pig6LGh44CC5Y+v5YaZ5oiQ77yaYWRkcihhaSk9SChraSkg77yM5YW25LitaeaYr+ihqOS4reS4gOS4quWFg+e0oO+8jGFkZHIoYWkp5pivYWnnmoTlnLDlnYDvvIwga2nmmK9haeeahOWFs+mUruWtl+OAglxyXG5cclxu5ZOI5biM6KGo77ya5bqU55So5ZOI5biM5Ye95pWw77yM55Sx6K6w5b2V55qE5YWz6ZSu5a2X56Gu5a6a6K6w5b2V5Zyo6KGo5Lit55qE5Zyw5Z2A77yM5bm25bCG6K6w5b2V5pS+5YWl5q2k5Zyw5Z2A77yM6L+Z5qC35p6E5oiQ55qE6KGo5Y+r5ZOI5biM6KGo44CCXHJcblxyXG7lk4jluIzmn6Xmib4o5Y+I5Y+r5pWj5YiX5p+l5om+Ke+8muWIqeeUqOWTiOW4jOWHveaVsOi/m+ihjOafpeaJvueahOi/h+eoi+WPq+WTiOW4jOafpeaJvuOAglxyXG5cclxu5Yay56qB77ya5a+55LqO5LiN5ZCM55qE5YWz6ZSu5a2Xa2njgIFrau+8jOiLpWtp74K5a2rvvIzkvYZIKGtpKT1IKGtqKeeahOeOsOixoeWPq+WGsueqgShjb2xsaXNpb24pIOOAglxyXG5cclxu5ZCM5LmJ6K+N77ya5YW35pyJ55u45ZCM5Ye95pWw5YC855qE5Lik5Liq5LiN5ZCM55qE5YWz6ZSu5a2X77yM56ew5Li66K+l5ZOI5biM5Ye95pWw55qE5ZCM5LmJ6K+N44CCXHJcbuWTiOW4jOWHveaVsOmAmuW4uOaYr+S4gOenjeWOi+e8qeaYoOixoe+8jOaJgOS7peWGsueqgeS4jeWPr+mBv+WFje+8jOWPquiDveWwvemHj+WHj+Wwke+8m+W9k+WGsueqgeWPkeeUn+aXtu+8jOW6lOivpeacieWkhOeQhuWGsueqgeeahOaWueazleOAguiuvuiuoeS4gOS4quaVo+WIl+ihqOW6lOWMheaLrO+8mlxyXG7ikaAgIOaVo+WIl+ihqOeahOepuumXtOiMg+WbtO+8jOWNs+ehruWumuaVo+WIl+WHveaVsOeahOWAvOWfn++8m1xyXG7ikaEgIOaehOmAoOWQiOmAgueahOaVo+WIl+WHveaVsO+8jOS9v+W+l+WvueS6juaJgOacieWPr+iDveeahOWFg+e0oCjorrDlvZXnmoTlhbPplK7lrZcp77yM5Ye95pWw5YC85Z2H5Zyo5pWj5YiX6KGo55qE5Zyw5Z2A56m66Ze06IyD5Zu05YaF77yM5LiU5Ye6546w5Yay56qB55qE5Y+v6IO95bC96YeP5bCP77ybXHJcbuKRoiAg5aSE55CG5Yay56qB55qE5pa55rOV44CC5Y2z5b2T5Yay56qB5Ye6546w5pe25aaC5L2V6Kej5Yaz44CCXHJcblxyXG5cclxu5ZOI5biM5Ye95pWw55qE5p6E6YCgXHJcblxyXG7lk4jluIzlh73mlbDmmK/kuIDnp43mmKDosaHvvIzlhbborr7lrprlvojngbXmtLvvvIzlj6ropoHkvb/ku7vkvZXlhbPplK7lrZfnmoTlk4jluIzlh73mlbDlgLzpg73okL3lnKjooajplb/lhYHorrjnmoTojIPlm7TkuYvlhoXljbPlj6/jgILlk4jluIzlh73mlbDigJzlpb3lnY/igJ3nmoTkuLvopoHor4Tku7flm6DntKDmnInvvJpcclxu4peGIOaVo+WIl+WHveaVsOeahOaehOmAoOeugOWNle+8m1xyXG7il4Yg6IO94oCc5Z2H5YyA4oCd5Zyw5bCG5pWj5YiX6KGo5Lit55qE5YWz6ZSu5a2X5pig5bCE5Yiw5Zyw5Z2A56m66Ze044CC5omA6LCT4oCc5Z2H5YyA4oCdKHVuaWZvcm0p5piv5oyH5Y+R55Sf5Yay56qB55qE5Y+v6IO95oCn5bC95Y+v6IO95pyA5bCR44CCXHJcblxyXG4xICDnm7TmjqXlrprlnYDms5Vcclxu5Y+W5YWz6ZSu5a2X5oiW5YWz6ZSu5a2X55qE5p+Q5Liq57q/5oCn5Ye95pWw5L2c5ZOI5biM5Zyw5Z2A77yM5Y2zSChrZXkpPWtleSAgICDmiJYgICBIKGtleSk9YcK3a2V5K2IoYSxi5Li65bi45pWwKVxyXG7nibnngrnvvJrnm7TmjqXlrprlnYDms5XmiYDlvpflnLDlnYDpm4blkIjkuI7lhbPplK7lrZfpm4blkIjlpKflsI/nm7jnrYnvvIzkuI3kvJrlj5HnlJ/lhrLnqoHvvIzkvYblrp7pmYXkuK3lvojlsJHkvb/nlKjjgIJcclxuXHJcbjIgIOaVsOWtl+WIhuaekOazlVxyXG7lr7nlhbPplK7lrZfov5vooYzliIbmnpDvvIzlj5blhbPplK7lrZfnmoToi6XlubLkvY3miJbnu4TlkIjkvZzkuLrlk4jluIzlnLDlnYDjgIJcclxu6YCC55So5LqO5YWz6ZSu5a2X5L2N5pWw5q+U5ZOI5biM5Zyw5Z2A5L2N5pWw5aSn77yM5LiU5Y+v6IO95Ye6546w55qE5YWz6ZSu5a2X5LqL5YWI55+l6YGT55qE5oOF5Ya144CCXHJcbuS+i++8miDorr7mnIk4MOS4quiusOW9le+8jOWFs+mUruWtl+S4ujjkvY3ljYHov5vliLbmlbDvvIzlk4jluIzlnLDlnYDkuLoy5L2N5Y2B6L+b5Yi25pWw44CCXHJcbu+CgSAg74KCIO+CgyAg74KEIO+ChSAg74KGIO+ChyAg74KIXHJcbjggIDEgIDMgIDQgIDYgIDUgIDMgIDJcclxuOCAgMSAgMyAgNyAgMiAgMiAgNCAgMlxyXG44ICAxICAzICA4ICA3ICA0ICAyICAyXHJcbjggIDEgIDMgIDAgIDEgIDMgIDYgIDdcclxuOCAgMSAgMyAgMiAgMiAgOCAgMSAgN1xyXG44ICAxICAzICAzICA4ICA5ICA2ICA3XHJcbjggIDEgIDMgIDYgIDggIDUgIDMgIDdcclxuOCAgMSAgNCAgMSAgOSAgMyAgNSAgNVxyXG7liIbmnpDvvJog74KBIOWPquWPljhcclxuICAgICAg74KCIOWPquWPljFcclxuICAgICAg74KDIOWPquWPljPjgIE0XHJcbiAgICAgIO+CiCDlj6rlj5Yy44CBN+OAgTVcclxuICAgICAg74KE74KF74KG74KH5pWw5a2X5YiG5biD6L+R5LmO6ZqP5py6XHJcbuaJgOS7pe+8muWPlu+ChO+Che+Chu+Ch+S7u+aEj+S4pOS9jeaIluS4pOS9jeS4juWPpuS4pOS9jeeahOWPoOWKoOS9nOWTiOW4jOWcsOWdgFxyXG5cclxuMyAg5bmz5pa55Y+W5Lit5rOVXHJcbuWwhuWFs+mUruWtl+W5s+aWueWQjuWPluS4remXtOWHoOS9jeS9nOS4uuWTiOW4jOWcsOWdgOOAglxyXG7kuIDkuKrmlbDlubPmlrnlkI7kuK3pl7Tlh6DkvY3lkozmlbDnmoTmr4/kuIDkvY3pg73mnInlhbPvvIzliJnnlLHpmo/mnLrliIbluIPnmoTlhbPplK7lrZflvpfliLDnmoTmlaPliJflnLDlnYDkuZ/mmK/pmo/mnLrnmoTjgILmlaPliJflh73mlbDmiYDlj5bnmoTkvY3mlbDnlLHmlaPliJfooajnmoTplb/luqblhrPlrprjgILov5nnp43mlrnms5XpgILkuo7kuI3nn6XpgZPlhajpg6jlhbPplK7lrZfmg4XlhrXvvIzmmK/kuIDnp43ovoPkuLrluLjnlKjnmoTmlrnms5XjgIJcclxuXHJcbjQgIOaKmOWPoOazlVxyXG7lsIblhbPplK7lrZfliIblibLmiJDkvY3mlbDnm7jlkIznmoTlh6Dpg6jliIYo5pyA5ZCO5LiA6YOo5YiG5Y+v5Lul5LiN5ZCMKe+8jOeEtuWQjuWPlui/meWHoOmDqOWIhueahOWPoOWKoOWSjOS9nOS4uuWTiOW4jOWcsOWdgOOAglxyXG7mlbDkvY3lj6DliqDmnInnp7vkvY3lj6DliqDlkozpl7TnlYzlj6DliqDkuKTnp43jgIJcclxu4peGIOenu+S9jeWPoOWKoO+8muWwhuWIhuWJsuWQjueahOWHoOmDqOWIhuS9juS9jeWvuem9kOebuOWKoOOAglxyXG7il4Yg6Ze055WM5Y+g5Yqg77ya5LuO5LiA56uv5Yiw5Y+m5LiA56uv5rK/5YiG5Ymy55WM5p2l5Zue5oqY6L+t77yM54S25ZCO5a+56b2Q55u45Yqg44CCXHJcbumAguS6juWFs+mUruWtl+S9jeaVsOW+iOWkmu+8jOS4lOavj+S4gOS9jeS4iuaVsOWtl+WIhuW4g+Wkp+iHtOWdh+WMgOaDheWGteOAglxyXG7kvovvvJog6K6+5YWz6ZSu5a2X5Li6MDQ0MjIwNTg2NO+8jOWTiOW4jOWcsOWdgOS9jeaVsOS4ujQg44CC5Lik56eN5LiN5ZCM55qE5Zyw5Z2A6K6h566X5pa55rOV5aaC5LiL77yaXHJcbiAgICA1ODY0ICAgICAgICAgICAgICAgICAgICAgICAgNTg2NFxyXG4gICAgNDIyMCAgICAgICAgICAgICAgICAgICAgICAgIDAyMjRcclxuICAgICAgMDQgICAgICAg56e75L2N5Y+g5YqgICAgICAgICAgICAgMDQgICAgICAgICAgIOmXtOeVjOWPoOWKoFxyXG4gLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLVxyXG4gICAxMDA4OCAgICAgICAgICAgICAgICAgICAgICAgIDYwOTFcclxuXHJcbjUgIOmZpOeVmeS9meaVsOazlVxyXG7lj5blhbPplK7lrZfooqvmn5DkuKrkuI3lpKfkuo7lk4jluIzooajooajplb9t55qE5pWwcOmZpOWQjuaJgOW+l+S9meaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgTU9EIHAgICAgIChwPD1tKVxyXG7mmK/kuIDnp43nroDljZXjgIHluLjnlKjnmoTlk4jluIzlh73mlbDmnoTpgKDmlrnms5XjgIJcclxu5Yip55So6L+Z56eN5pa55rOV55qE5YWz6ZSu5pivcOeahOmAieWPlu+8jHDpgInnmoTkuI3lpb3vvIzlrrnmmJPkuqfnlJ/lkIzkuYnor43jgIJw55qE6YCJ5Y+W55qE5YiG5p6Q77yaXHJcbuKXhiAg6YCJ5Y+WcD0yaShwPD1tKe+8mui/kOeul+S+v+S6jueUqOenu+S9jeadpeWunueOsO+8jOS9huetieS6juWwhuWFs+mUruWtl+eahOmrmOS9jeW/veeVpeiAjOS7heeVmeS4i+S9juS9jeS6jOi/m+WItuaVsOOAgumrmOS9jeS4jeWQjOiAjOS9juS9jeebuOWQjOeahOWFs+mUruWtl+aYr+WQjOS5ieivjeOAglxyXG7il4Yg6YCJ5Y+WcD1xKmYoceOAgWbpg73mmK/otKjlm6DmlbDvvIxwPD1tKe+8muWImeaJgOacieWQq+aciXHmiJZm5Zug5a2Q55qE5YWz6ZSu5a2X55qE5pWj5YiX5Zyw5Z2A5Z2H5pivceaIlmbnmoTlgI3mlbDjgIJcclxu4peGIOmAieWPlnDkuLrntKDmlbDmiJZwPXEqZihx44CBZuaYr+i0qOaVsOS4lOWdh+Wkp+S6jjIw77yMcDw9bSnvvJrluLjnlKjnmoTpgInlj5bmlrnms5XvvIzog73lh4/lsJHlhrLnqoHlh7rnjrDnmoTlj6/og73mgKfjgIJcclxuXHJcbjYgIOmaj+acuuaVsOazlVxyXG7lj5blhbPplK7lrZfnmoTpmo/mnLrlh73mlbDlgLzkvZzlk4jluIzlnLDlnYDvvIzljbNIKGtleSk9cmFuZG9tKGtleSlcclxu5b2T5pWj5YiX6KGo5Lit5YWz6ZSu5a2X6ZW/5bqm5LiN562J5pe277yM6K+l5pa55rOV5q+U6L6D5ZCI6YCC44CCXHJcblxyXG5cclxuXHJcbumAieWPluWTiOW4jOWHveaVsO+8jOiAg+iZkeS7peS4i+WboOe0oFxyXG7il4Yg6K6h566X5ZOI5biM5Ye95pWw5omA6ZyA5pe26Ze077ybXHJcbuKXhiDlhbPplK7lrZfnmoTplb/luqbvvJtcclxu4peGIOWTiOW4jOihqOmVv+W6pu+8iOWTiOW4jOWcsOWdgOiMg+WbtO+8ie+8m1xyXG7il4Yg5YWz6ZSu5a2X5YiG5biD5oOF5Ya177ybXHJcbuKXhiDorrDlvZXnmoTmn6Xmib7popHnjofjgIJcclxuXHJcblxyXG5cclxu5Yay56qB5aSE55CG55qE5pa55rOVXHJcbuWGsueqgeWkhOeQhu+8muW9k+WHuueOsOWGsueqgeaXtu+8jOS4uuWGsueqgeWFg+e0oOaJvuWIsOWPpuS4gOS4quWtmOWCqOS9jee9ruOAglxyXG5cclxuMSAg5byA5pS+5a6a5Z2A5rOVXHJcbuWfuuacrOaWueazle+8muW9k+WGsueqgeWPkeeUn+aXtu+8jOW9ouaIkOafkOS4quaOoua1i+W6j+WIl++8m+aMieatpOW6j+WIl+mAkOS4quaOoua1i+aVo+WIl+ihqOS4reeahOWFtuS7luWcsOWdgO+8jOebtOWIsOaJvuWIsOe7meWumueahOWFs+mUruWtl+aIluS4gOS4quepuuWcsOWdgCjlvIDmlL7nmoTlnLDlnYAp5Li65q2i77yM5bCG5Y+R55Sf5Yay56qB55qE6K6w5b2V5pS+5Yiw6K+l5Zyw5Z2A5Lit44CC5pWj5YiX5Zyw5Z2A55qE6K6h566X5YWs5byP5piv77yaXHJcbkhpKGtleSk9KEgoa2V5KStkaSkgIE1PRCBt77yMaT0xLCAyLCDigKYsIGsoazw9bS0xKVxyXG5cclxu5YW25Lit77yaSChrZXkp77ya5ZOI5biM5Ye95pWw77ybbe+8muaVo+WIl+ihqOmVv+W6pu+8m1xyXG5kae+8muesrGnmrKHmjqLmtYvml7bnmoTlop7ph4/luo/liJfvvJtcclxuSGkoa2V5KSDvvJrnu4/nrKxp5qyh5o6i5rWL5ZCO5b6X5Yiw55qE5pWj5YiX5Zyw5Z2A44CCXHJcblxyXG7ikbQgIOe6v+aAp+aOoua1i+azlVxyXG7lsIbmlaPliJfooahUWzAg4oCmbS0xXeeci+aIkOW+queOr+WQkemHj+OAguW9k+WPkeeUn+WGsueqgeaXtu+8jOS7juWIneasoeWPkeeUn+WGsueqgeeahOS9jee9ruS+neasoeWQkeWQjuaOoua1i+WFtuS7lueahOWcsOWdgOOAglxyXG7lop7ph4/luo/liJfkuLrvvJpkaT0xLCAyLCAzLCDigKYsIG0tMVxyXG7orr7liJ3mrKHlj5HnlJ/lhrLnqoHnmoTlnLDlnYDmmK9o77yM5YiZ5L6d5qyh5o6i5rWLVFtoKzFd77yMVFtoKzJd4oCm77yM55u05YiwVFttLTFd5pe25Y+I5b6q546v5Yiw6KGo5aS077yM5YaN5qyh5o6i5rWLVFswXe+8jFRbMV3igKbvvIznm7TliLBUW2gtMV3jgILmjqLmtYvov4fnqIvnu4jmraLnmoTmg4XlhrXmmK/vvJpcclxu4peGIOaOoua1i+WIsOeahOWcsOWdgOS4uuepuu+8muihqOS4reayoeacieiusOW9leOAguiLpeaYr+afpeaJvuWImeWksei0pe+8m+iLpeaYr+aPkuWFpeWImeWwhuiusOW9leWGmeWFpeWIsOivpeWcsOWdgO+8m1xyXG7il4Yg5o6i5rWL5Yiw55qE5Zyw5Z2A5pyJ57uZ5a6a55qE5YWz6ZSu5a2X77ya6Iul5piv5p+l5om+5YiZ5oiQ5Yqf77yb6Iul5piv5o+S5YWl5YiZ5aSx6LSl77ybXHJcbuKXhiDnm7TliLBUW2hd77ya5LuN5pyq5o6i5rWL5Yiw56m65Zyw5Z2A5oiW57uZ5a6a55qE5YWz6ZSu5a2X77yM5pWj5YiX6KGo5ruh44CCXHJcblxyXG7kvosxIO+8muiuvuaVo+WIl+ihqOmVv+S4ujfvvIzorrDlvZXlhbPplK7lrZfnu4TkuLrvvJoxNSwgMTQsIDI4LCAyNiwgNTYsIDIz77yM5pWj5YiX5Ye95pWw77yaSChrZXkpPWtleSAgIE1PRCAgN++8jOWGsueqgeWkhOeQhumHh+eUqOe6v+aAp+aOoua1i+azleOAglxyXG5IKDE1KT0xNSAgTU9EIDc9MVxyXG5IKDE0KT0xNCAgTU9EIDc9MFxyXG5IKDI4KT0yOCAgTU9EIDc9MCAg5Yay56qBICAgSDEoMjgpPTEgIOWPiOWGsueqgVxyXG5IMigyOCk9MiAgICAgICAgICAgSCgyNik9MjYgIE1PRCA3PTVcclxuSCg1Nik9NTYgIE1PRCA3PTAgICAgIOWGsueqgSAgICAgIEgxKDU2KT0xICAgICDlj4jlhrLnqoFcclxuSDIoNTYpPTIgICDlj4jlhrLnqoEgICAgSDMoNTYpPTNcclxuSCgyMyk9MjMgIE1PRCA3PTIgICAgIOWGsueqgSAgICAgIEgxKDIzKT0zICAgICDlj4jlhrLnqoFcclxuSDMoMjMpPTRcclxuXHJcbjAgICAgIDEgICAgICAyICAgICAgMyAgICAgIDQgICAgICAgNSAgICAgNlxyXG4xNCAgICAxNSAgICAgMjggICAgIDU2ICAgICAyMyAgICAgIDI2XHJcblxyXG7nur/mgKfmjqLmtYvms5XnmoTnibnngrlcclxu4peGIOS8mOeCue+8muWPquimgeaVo+WIl+ihqOacqua7oe+8jOaAu+iDveaJvuWIsOS4gOS4quS4jeWGsueqgeeahOaVo+WIl+WcsOWdgO+8m1xyXG7il4Yg57y654K577ya5q+P5Liq5Lqn55Sf5Yay56qB55qE6K6w5b2V6KKr5pWj5YiX5Yiw56a75Yay56qB5pyA6L+R55qE56m65Zyw5Z2A5LiK77yM5LuO6ICM5Y+I5aKe5Yqg5LqG5pu05aSa55qE5Yay56qB5py65LyaKOi/meenjeeOsOixoeensOS4uuWGsueqgeeahOKAnOiBmumbhuKAnSnjgIJcclxuXHJcbuKRtSAg5LqM5qyh5o6i5rWL5rOVXHJcbuWinumHj+W6j+WIl+S4uu+8mmRpPTHCsiwtMcKyLDLCsiwtMsKyLDPCsizigKbigKbCsWvCsiAgKGs8PeKMim0vMuKMiylcclxuXHJcbuS4iui/sOS+i+mimOiLpemHh+eUqOS6jOasoeaOoua1i+azlei/m+ihjOWGsueqgeWkhOeQhu+8jOWIme+8mlxyXG5IKDE1KT0xNSAgTU9EIDc9MSAgICAgICAgIEgoMTQpPTE0ICBNT0QgNz0wXHJcbkgoMjgpPTI4ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSgyOCk9MSAgICAg5Y+I5Yay56qBXHJcbkgyKDI4KT00XHJcbkgoMjYpPTI2ICBNT0QgNz01XHJcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXHJcbkgyKDU2KT0wICAg5Y+I5Yay56qBICAgIEgzKDU2KT00ICAgIOWPiOWGsueqgVxyXG5INCg1Nik9MlxyXG5IKDIzKT0yMyAgTU9EIDc9MiAgICAgIOWGsueqgVxyXG5IMSgyMyk9M1xyXG5cclxu5LqM5qyh5o6i5rWL5rOV55qE54m554K5XHJcbuKXhiDkvJjngrnvvJrmjqLmtYvluo/liJfot7Pot4PlvI/lnLDmlaPliJfliLDmlbTkuKrooajkuK3vvIzkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3njrDosaHvvJtcclxu4peGIOe8uueCue+8muS4jeiDveS/neivgeaOoua1i+WIsOaVo+WIl+ihqOeahOaJgOacieWcsOWdgOOAglxyXG5cclxu4pG2ICAg5Lyq6ZqP5py65o6i5rWL5rOVXHJcbuWinumHj+W6j+WIl+S9v+eUqOS4gOS4quS8qumaj+acuuWHveaVsOadpeS6p+eUn+S4gOS4quiQveWcqOmXreWMuumXtFsx77yMbS0xXeeahOmaj+acuuW6j+WIl+OAglxyXG5cclxu5L6LMiDvvJog6KGo6ZW/5Li6MTHnmoTlk4jluIzooajkuK3lt7LloavmnInlhbPplK7lrZfkuLoxN++8jDYw77yMMjnnmoTorrDlvZXvvIzmlaPliJflh73mlbDkuLpIKGtleSk9a2V5ICBNT0QgIDExIOOAgiDnjrDmnInnrKw05Liq6K6w5b2V77yM5YW25YWz6ZSu5a2X5Li6MzjvvIzmjInkuInnp43lpITnkIblhrLnqoHnmoTmlrnms5XvvIzlsIblroPloavlhaXooajkuK3jgIJcclxuXHJcbigxKSAgSCgzOCk9MzggTU9EIDExPTUgICAg5Yay56qBXHJcbiAgICAgSDE9KDUrMSkgTU9EIDExPTYgICAg5Yay56qBXHJcbiAgICAgSDI9KDUrMikgTU9EIDExPTcgICAg5Yay56qBXHJcbiAgICAgSDM9KDUrMykgTU9EIDExPTggICAg5LiN5Yay56qBXHJcbigyKSAgSCgzOCk9MzggTU9EIDExPTUgICAgICDlhrLnqoFcclxuICAgICBIMT0oNSsxwrIpIE1PRCAxMT02ICAgIOWGsueqgVxyXG4gICAgIEgyPSg1LTHCsikgTU9EIDExPTQgICAgIOS4jeWGsueqgVxyXG4oMykgIEgoMzgpPTM4IE1PRCAxMT01ICAgIOWGsueqgVxyXG4gICAgIOiuvuS8qumaj+acuuaVsOW6j+WIl+S4ujnvvIzliJlIMT0oNSs5KSBNT0QgMTE9MyDkuI3lhrLnqoFcclxuXHJcblxyXG4yICDlho3lk4jluIzms5Vcclxu5p6E6YCg6Iul5bmy5Liq5ZOI5biM5Ye95pWw77yM5b2T5Y+R55Sf5Yay56qB5pe277yM5Yip55So5LiN5ZCM55qE5ZOI5biM5Ye95pWw5YaN6K6h566X5LiL5LiA5Liq5paw5ZOI5biM5Zyw5Z2A77yM55u05Yiw5LiN5Y+R55Sf5Yay56qB5Li65q2i44CC5Y2z77yaSGk9UkhpKGtleSkgICAgIGk9MSwgMiwg4oCmLCBrXHJcblJIaSDvvJrkuIDnu4TkuI3lkIznmoTlk4jluIzlh73mlbDjgILnrKzkuIDmrKHlj5HnlJ/lhrLnqoHml7bvvIznlKhSSDHorqHnrpfvvIznrKzkuozmrKHlj5HnlJ/lhrLnqoHml7bvvIznlKhSSDLorqHnrpfigKbkvp3mraTnsbvmjqjnn6XpgZPlvpfliLDmn5DkuKpIaeS4jeWGjeWGsueqgeS4uuatouOAglxyXG7il4YgIOS8mOeCue+8muS4jeaYk+S6p+eUn+WGsueqgeeahOKAnOiBmumbhuKAneeOsOixoe+8m1xyXG7il4YgIOe8uueCue+8muiuoeeul+aXtumXtOWinuWKoOOAglxyXG5cclxuXHJcbjMgIOmTvuWcsOWdgOazlVxyXG7mlrnms5XvvJrlsIbmiYDmnInlhbPplK7lrZfkuLrlkIzkuYnor40o5pWj5YiX5Zyw5Z2A55u45ZCMKeeahOiusOW9leWtmOWCqOWcqOS4gOS4quWNlemTvuihqOS4re+8jOW5tueUqOS4gOe7tOaVsOe7hOWtmOaUvumTvuihqOeahOWktOaMh+mSiOOAglxyXG7orr7mlaPliJfooajplb/kuLpt77yM5a6a5LmJ5LiA5Liq5LiA57u05oyH6ZKI5pWw57uE77yaXHJcblJlY05vZGUgKmxpbmtoYXNoW21d77yM5YW25LitUmVjTm9kZeaYr+e7k+eCueexu+Wei++8jOavj+S4quWIhumHj+eahOWIneWAvOS4uuepuuOAguWHoeaVo+WIl+WcsOWdgOS4umvnmoTorrDlvZXpg73mj5LlhaXliLDku6VsaW5raGFzaFtrXeS4uuWktOaMh+mSiOeahOmTvuihqOS4re+8jOaPkuWFpeS9jee9ruWPr+S7peWcqOihqOWktOaIluihqOWwvuaIluaMieWFs+mUruWtl+aOkuW6j+aPkuWFpeOAglxyXG5cclxu5L6L77yaIOW3suefpeS4gOe7hOWFs+mUruWtlygxOSwgMTQsIDIzLCAxLCA2OCwgMjAsIDg0LCAyNywgNTUsIDExLCAxMCwgNzkpIO+8jOWTiOW4jOWHveaVsOS4uu+8mkgoa2V5KT1rZXkgTU9EIDEz77yM55So6ZO+5Zyw5Z2A5rOV5aSE55CG5Yay56qBOlxyXG5cclxuIDBcclxuIDEgIC0tPiAxNCAtPiAxIC0+IDI3IC0+IDc5XHJcbiAyXHJcbiAzICAtLT4gNjggLT4gNTVcclxuIDRcclxuIDVcclxuIDYgIC0tPiAxOSAtPiA4NFxyXG4gNyAgLS0+IDIwXHJcbiA4XHJcbiA5XHJcbiAxMCAtLT4gMjMgLT4gMTBcclxuIDExIC0tPiAxMVxyXG4gMTJcclxuXHJcbiDkvJjngrnvvJrkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3vvJvliKDpmaTorrDlvZXkuZ/lvojnroDljZXjgIJcclxuXHJcblxyXG4gNCAg5bu656uL5YWs5YWx5rqi5Ye65Yy6XHJcbiDmlrnms5XvvJrlnKjln7rmnKzmlaPliJfooajkuYvlpJbvvIzlj6blpJborr7nq4vkuIDkuKrmuqLlh7rooajkv53lrZjkuI7ln7rmnKzooajkuK3orrDlvZXlhrLnqoHnmoTmiYDmnInorrDlvZXjgIJcclxuIOiuvuaVo+WIl+ihqOmVv+S4um3vvIzorr7nq4vln7rmnKzmlaPliJfooahoYXNodGFibGVbbV3vvIzmr4/kuKrliIbph4/kv53lrZjkuIDkuKrorrDlvZXvvJvmuqLlh7rooahvdmVydGFibGVbbV3vvIzkuIDml6bmn5DkuKrorrDlvZXnmoTmlaPliJflnLDlnYDlj5HnlJ/lhrLnqoHvvIzpg73loavlhaXmuqLlh7rooajkuK3jgIJcclxuXHJcbiDkvovvvJog5bey55+l5LiA57uE5YWz6ZSu5a2XKDE1LCA0LCAxOCwgNywgMzcsIDQ3KSDvvIzmlaPliJfooajplb/luqbkuLo3IO+8jOWTiOW4jOWHveaVsOS4uu+8mkgoa2V5KT1rZXkgTU9EIDfvvIznlKjlu7rnq4vlhazlhbHmuqLlh7rljLrms5XlpITnkIblhrLnqoHjgILlvpfliLDnmoTln7rmnKzooajlkozmuqLlh7rooajlpoLkuIvvvJpcclxuICAgICAgICAgICAgICAgICAgICDmlaPliJflnLDlnYAgICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNSAgICAgNlxyXG4gSGFzaHRhYmxl6KGo77yaXHJcbiAgICAgICAgICAgICAgICAgICAg5YWz6ZSu5a2XICAgICA3ICAgICAxNSAgICAzNyAgICAgICAgICA0ICAgICA0N1xyXG5cclxuICAgICAgICAgICAgICAgICAgICDmuqLlh7rlnLDlnYAgICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNSAgICAgNlxyXG4gb3ZlcnRhYmxl6KGo77yaXHJcbiAgICAgICAgICAgICAgICAgICAgIOWFs+mUruWtlyAgICAxOFxyXG5cclxuXHJcblxyXG5cclxuIOWTiOW4jOafpeaJvui/h+eoi+WPiuWIhuaekFxyXG5cclxuIDEgICDlk4jluIzmn6Xmib7ov4fnqItcclxuIOWTiOW4jOihqOeahOS4u+imgeebrueahOaYr+eUqOS6juW/q+mAn+afpeaJvu+8jOS4lOaPkuWFpeWSjOWIoOmZpOaTjeS9nOmDveimgeeUqOWIsOafpeaJvuOAgueUseS6juaVo+WIl+ihqOeahOeJueauiue7hOe7h+W9ouW8j++8jOWFtuafpeaJvuacieeJueauiueahOaWueazleOAglxyXG5cclxuIOe7meWumkvlgLzvvIzmoLnmja7pgKDooajml7borr7lrprnmoTlk4jluIzlh73mlbDmsYLlvpflk4jluIzlnLDlnYDvvIzoi6XooajkuK3mraTkvY3nva7kuIrmsqHmnInorrDlvZXvvIzliJnmn6Xmib7kuI3miJDlip/vvJvlkKbliJnmr5TovoPlhbPplK7lrZfvvIzoi6Xlkoznu5nlrprlhbPplK7lrZfnm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvJvlkKbliJnmoLnmja7pgKDooajml7borr7lrprnmoTlpITnkIblhrLnqoHnmoTmlrnms5Xmib7igJzkuIvkuIDlnLDlnYDigJ3vvIznm7TliLDlk4jluIzooajkuK3mn5DkuKrkvY3nva7kuLrnqbrmiJbogIXooajkuK3miYDloavorrDlvZXnmoTlhbPplK7lrZfnrYnkuo7nu5nlrprlgLzml7bkuLrmraLjgIJcclxuXHJcblxyXG5cclxuIOWTiOW4jOafpeaJvuWIhuaekFxyXG5cclxuIOS7juWTiOW4jOafpeaJvui/h+eoi+WPr+inge+8muWwveeuoeaVo+WIl+ihqOWcqOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+S6huebtOaOpeaYoOixoe+8jOS9hueUseS6juKAnOWGsueqgeKAne+8jOafpeaJvui/h+eoi+S7jeaYr+S4gOS4que7meWumuWAvOS4juWFs+mUruWtl+i/m+ihjOavlOi+g+eahOi/h+eoi++8jOivhOS7t+WTiOW4jOafpeaJvuaViOeOh+S7jeimgeeUqEFTTOOAglxyXG4g5ZOI5biM5p+l5om+5pe25YWz6ZSu5a2X5LiO57uZ5a6a5YC85q+U6L6D55qE5qyh5pWw5Y+W5Yaz5LqO77yaXHJcbiDil4Yg5ZOI5biM5Ye95pWw77ybXHJcbiDil4Yg5aSE55CG5Yay56qB55qE5pa55rOV77ybXHJcbiDil4Yg5ZOI5biM6KGo55qE5aGr5ruh5Zug5a2QzrEg44CC5aGr5ruh5Zug5a2QzrHnmoTlrprkuYnmmK/vvJpcclxuXHJcbiDOsSA9IOihqOS4reWhq+WFpeeahOiusOW9leaVsCAvIOWTiOW4jOihqOmVv+W6plxyXG5cclxuXHJcbiDlkITnp43mlaPliJflh73mlbDmiYDmnoTpgKDnmoTmlaPliJfooajnmoRBU0zlpoLkuIvvvJpcclxuXHJcbiDikbQgICDnur/mgKfmjqLmtYvms5XnmoTlubPlnYfmn6Xmib7plb/luqbmmK/vvJpcclxuIFPmiJDlip8g57qm562J5LqOIDEgLyAyICogKDEgKyAxIC8gKDEgLSDOsSkpXHJcbiBT5aSx6LSlIOe6puetieS6jiAxIC8gMiAqICgxICsgMSAvICgxIC0gzrEpICogKDEgLSDOsSkpXHJcblxyXG4g4pG1ICAg5LqM5qyh5o6i5rWL44CB5Lyq6ZqP5py65o6i5rWL44CB5YaN5ZOI5biM5rOV55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXHJcbiBT5oiQ5YqfIOe6puetieS6jiAtMSAvIM6xICogbG4oMSAtIM6xKVxyXG4gU+Wksei0pSDnuqbnrYnkuo4gMSAvICgxIC0gzrEpXHJcblxyXG4g4pG2ICAg55So6ZO+5Zyw5Z2A5rOV6Kej5Yaz5Yay56qB55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXHJcbiBT5oiQ5YqfIOe6puetieS6jiAxICsgzrEgLyAyXHJcbiBT5aSx6LSlIOe6puetieS6jiDOsSArIGXnmoQtzrHmrKHluYJcclxuXHJcblxyXG4gKi9cblxudmFyIEhhc2hUYWJsZSA9IGV4cG9ydHMuSGFzaFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhhc2hUYWJsZSgpIHtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgSGFzaFRhYmxlKTtcblxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgLy8g5b2T5YmN5pWw5o2u5YWD57Sg5Liq5pWwO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgLy8g5b2T5YmN5a656YePXG4gICAgICAgIHRoaXMuc2l6ZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyDkvb/nlKjnur/mgKfmjqLmtYvms5Xop6PlhrPlhrLnqoFcblxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoSGFzaFRhYmxlLCBbe1xuICAgICAgICBrZXk6ICdzZWFyY2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoKGtleSkge1xuICAgICAgICAgICAgdmFyIG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcbiAgICAgICAgICAgIHZhciBwID0gaGFzaChrZXksIG1heCk7XG4gICAgICAgICAgICB2YXIgYyA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChwIDwgbWF4ICYmIHRoaXMuZGF0YVtwXSAhPSBudWxsICYmIGtleSAhPT0gdGhpcy5kYXRhW3BdKSB7XG4gICAgICAgICAgICAgICAgcCA9IGNvbGxpc2lvbihrZXksICsrYywgbWF4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBrZXkgPT09IHRoaXMuZGF0YVtwXSxcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25UaW1lczogYyxcbiAgICAgICAgICAgICAgICBpbmRleDogcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5zZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydChrZXkpIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCA+PSBtYXgpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcm1zZzogJ3RhYmxlIG92ZXJmbG93ZWQnIH07XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgdmFyIHAgPSByZXQuaW5kZXg7XG4gICAgICAgICAgICB2YXIgYyA9IHJldC5jb2xsaXNpb25UaW1lcztcblxuICAgICAgICAgICAgaWYgKHJldC5zdWNjZXNzKSByZXR1cm4gZmFsc2U7ZWxzZSBpZiAoYyA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbcF0gPSBrZXk7XG4gICAgICAgICAgICAgICAgKyt0aGlzLmNvdW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3JlYXRlSGFzaFRhYmxlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvdW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XG4gICAgICAgICAgICB2YXIgcCA9IGhhc2goa2V5LCBtYXgpO1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoa2V5ICE9PSB0aGlzLmRhdGFbcF0pIHtcbiAgICAgICAgICAgICAgICBwID0gY29sbGlzaW9uKGtleSwgKytjLCBtYXgpO1xuICAgICAgICAgICAgfWlmIChrZXkgPT09IHRoaXMuZGF0YVtwXSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhW3BdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UocCwgMSk7XG4gICAgICAgICAgICAgICAgLS10aGlzLmNvdW50O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjcmVhdGVIYXNoVGFibGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjcmVhdGVIYXNoVGFibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gKyt0aGlzLnNpemVJbmRleCA8IGhhc2hTaXplLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gSGFzaFRhYmxlO1xufSgpO1xuXG47XG5cbi8vIEVMRmhhc2jlrZfnrKbkuLLmlaPliJflh73mlbBcbmZ1bmN0aW9uIGhhc2goc3RyLCBtYXgpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpICsgaGFzaCArIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgICAgICBoYXNoID0gTWF0aC5hYnMoaGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoICUgbWF4O1xufVxuXG5mdW5jdGlvbiBjb2xsaXNpb24oa2V5LCB0aW1lcywgbWF4KSB7XG4gICAgLy8g57q/5oCn5o6i5rWL5rOVXG4gICAgcmV0dXJuIChoYXNoKGtleSwgbWF4KSArIHRpbWVzKSAlIG1heDtcbn1cblxuZnVuY3Rpb24gaXNQcmltZShuKSB7XG4gICAgaWYgKG4gPD0gMykgcmV0dXJuIG4gPiAxO1xuICAgIGlmIChuICUgMiA9PT0gMCB8fCBuICUgMyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSA1OyBpICogaSA8PSBuOyBpICs9IDYpIHtcbiAgICAgICAgaWYgKG4gJSBpID09PSAwIHx8IG4gJSAoaSArIDIpID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSGFzaFNpemUoYmVnaW4sIGxlbmd0aCkge1xuICAgIHZhciBoYXNoU2l6ZSA9IFtdO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgICAgaWYgKGhhc2hTaXplLmxlbmd0aCA+PSBsZW5ndGgpIGJyZWFrO1xuICAgICAgICBpZiAoaXNQcmltZShiZWdpbikpIGhhc2hTaXplLnB1c2goYmVnaW4pO1xuICAgICAgICArK2JlZ2luO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoU2l6ZTtcbn1cblxuLy8g5byA5pS+5a6a5Z2A5rOVXG4vL2hhc2hTaXplID0gWzUsIDddOyAvLyBmb3IgdGVzdC4gd2lsbCBiZSBkZWxldGVkXG52YXIgdGVzdCA9IG5ldyBIYXNoVGFibGUoKTtcbnRlc3QuaW5zZXJ0KCcxNycpO1xudGVzdC5pbnNlcnQoJzYwJyk7XG50ZXN0Lmluc2VydCgnMjknKTtcbnRlc3QuaW5zZXJ0KCczOCcpO1xudGVzdC5pbnNlcnQoJzM5Jyk7XG50ZXN0Lmluc2VydCgnNDAnKTtcblxudGVzdC5yZW1vdmUoJzE3Jyk7XG50ZXN0LnJlbW92ZSgnNjAnKTtcbnRlc3QucmVtb3ZlKCcyOScpO1xudGVzdC5yZW1vdmUoJzM4Jyk7XG50ZXN0LnJlbW92ZSgnMzknKTtcbnRlc3QucmVtb3ZlKCc0MCcpO1xuXG4vLyDkvb/nlKjpk77lnLDlnYDms5Xop6PlhrPlhrLnqoHnmoTlk4jluIzooahcblxudmFyIExpbmtlZExpc3RIYXNoVGFibGUgPSBleHBvcnRzLkxpbmtlZExpc3RIYXNoVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdEhhc2hUYWJsZSgpIHtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgTGlua2VkTGlzdEhhc2hUYWJsZSk7XG5cbiAgICAgICAgLy8g5b2T5YmN5pWw5o2u5YWD57Sg5Liq5pWwO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgLy8g5b2T5YmN5a656YePXG4gICAgICAgIHRoaXMuc2l6ZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5oTm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShMaW5rZWRMaXN0SGFzaFRhYmxlLCBbe1xuICAgICAgICBrZXk6ICdzZWFyY2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoKGtleSkge1xuICAgICAgICAgICAgdmFyIG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcbiAgICAgICAgICAgIHZhciBpID0gaGFzaChrZXksIG1heCk7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuaE5vZGVzO1xuXG4gICAgICAgICAgICBpZiAodFtpXSA9PSBudWxsKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgaW5kZXg6IGkgfTtcblxuICAgICAgICAgICAgdmFyIHAgPSB0W2ldO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgICAgICBwLmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGRhdGEgPT09IGtleSwgaW5kZXg6IGkgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5zZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydChrZXkpIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCA+PSBtYXgpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcm1zZzogJ3RhYmxlIG92ZXJmbG93ZWQnIH07XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmV0LmluZGV4O1xuXG4gICAgICAgICAgICBpZiAocmV0LnN1Y2Nlc3MpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhOb2Rlc1tpbmRleF0pIHRoaXMuaE5vZGVzW2luZGV4XSA9IG5ldyBfTGlua2VkTGlzdDIuZGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oTm9kZXNbaW5kZXhdLnNpemUoKSA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhOb2Rlc1tpbmRleF0ub3JkZXJJbnNlcnQoa2V5KTtcbiAgICAgICAgICAgICAgICArK3RoaXMuY291bnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjcmVhdGVIYXNoVGFibGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY291bnQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuc2VhcmNoKGtleSk7XG5cbiAgICAgICAgICAgIGlmIChyZXQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJldC5pbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJldC5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XVsncmVtb3ZlJ10oa2V5KTtcbiAgICAgICAgICAgICAgICAtLXRoaXMuY291bnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjcmVhdGVIYXNoVGFibGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjcmVhdGVIYXNoVGFibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gKyt0aGlzLnNpemVJbmRleCA8IGhhc2hTaXplLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTGlua2VkTGlzdEhhc2hUYWJsZTtcbn0oKTtcblxuO1xuXG52YXIgdGVzdDIgPSBuZXcgTGlua2VkTGlzdEhhc2hUYWJsZSgpO1xudGVzdDIuaW5zZXJ0KCcxNycpO1xudGVzdDIuaW5zZXJ0KCc2MCcpO1xudGVzdDIuaW5zZXJ0KCcyOScpO1xudGVzdDIuaW5zZXJ0KCczOCcpO1xudGVzdDIuaW5zZXJ0KCczOScpO1xudGVzdDIuaW5zZXJ0KCc0MCcpO1xuXG50ZXN0Mi5yZW1vdmUoJzE3Jyk7XG50ZXN0Mi5yZW1vdmUoJzYwJyk7XG50ZXN0Mi5yZW1vdmUoJzI5Jyk7XG50ZXN0Mi5yZW1vdmUoJzM4Jyk7XG50ZXN0Mi5yZW1vdmUoJzM5Jyk7XG50ZXN0Mi5yZW1vdmUoJzQwJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9TZWFyY2gvSGFzaFRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmluYXJ5U29ydGVkVHJlZSA9IHJlcXVpcmUoJy4vQmluYXJ5U29ydGVkVHJlZScpO1xuXG52YXIgX0JpbmFyeVNvcnRlZFRyZWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmluYXJ5U29ydGVkVHJlZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBSRUQgPSAncmVkJzsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICogUmVkIEJsYWNrIFRyZWVcclxuICAgICAgICAgICAgICAgICAgKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNC8xMi8zMC5cclxuICAgICAgICAgICAgICAgICAgKi9cbi8qXHJcbiBodHRwOi8vYmxvZy5jc2RuLm5ldC92X2p1bHlfdi9hcnRpY2xlL2RldGFpbHMvNjEwNTYzMFxyXG5cclxuIOe6oum7keagke+8jOS4gOenjeS6jOWPieafpeaJvuagke+8jOS9huWcqOavj+S4que7k+eCueS4iuWinuWKoOS4gOS4quWtmOWCqOS9jeihqOekuue7k+eCueeahOminOiJsu+8jOWPr+S7peaYr1JlZOaIlkJsYWNr44CCXHJcbiDpgJrov4flr7nku7vkvZXkuIDmnaHku47moLnliLDlj7blrZDnmoTot6/lvoTkuIrlkITkuKrnu5PngrnnnYDoibLmlrnlvI/nmoTpmZDliLbvvIznuqLpu5HmoJHnoa7kv53msqHmnInkuIDmnaHot6/lvoTkvJrmr5Tlhbbku5bot6/lvoTplb/lh7rkv6nlgI3vvIzlm6DogIzmmK/mjqXov5HlubPooaHnmoTjgIJcclxuXHJcbiDnuqLpu5HmoJHomb3nhLbmnKzotKjkuIrmmK/kuIDmo7Xkuozlj4nmn6Xmib7moJHvvIzkvYblroPlnKjkuozlj4nmn6Xmib7moJHnmoTln7rnoYDkuIrlop7liqDkuobnnYDoibLlkoznm7jlhbPnmoTmgKfotKjkvb/lvpfnuqLpu5HmoJHnm7jlr7nlubPooaHvvIzku47ogIzkv53or4HkuobnuqLpu5HmoJHnmoTmn6Xmib7jgIHmj5LlhaXjgIHliKDpmaTnmoTml7bpl7TlpI3mnYLluqbmnIDlnY/kuLpPKGxvZyBuKeOAglxyXG5cclxuIOe6oum7keagkeeahDXkuKrmgKfotKjvvJpcclxuIDEu5q+P5Liq57uT54K56KaB5LmI5piv57qi55qE6KaB5LmI5piv6buR55qE44CCXHJcbiAyLuaguee7k+eCueaYr+m7keeahOOAglxyXG4gMy7mr4/kuKrlj7bnu5PngrnvvIjlj7bnu5PngrnljbPmjIfmoJHlsL7nq69OSUzmjIfpkojmiJZOVUxM57uT54K577yJ6YO95piv6buR55qE44CCXHJcbiA0LuWmguaenOS4gOS4que7k+eCueaYr+e6oueahO+8jOmCo+S5iOWug+eahOS4pOS4quWEv+WtkOmDveaYr+m7keeahOOAglxyXG4gNS7lr7nkuo7ku7vmhI/nu5PngrnogIzoqIDvvIzlhbbliLDlj7bnu5PngrnmoJHlsL7nq69OSUzmjIfpkojnmoTmr4/mnaHot6/lvoTpg73ljIXlkKvnm7jlkIzmlbDnm67nmoTpu5Hnu5PngrnjgIJcclxuXHJcbiDmraPmmK/nuqLpu5HmoJHnmoTov5k15p2h5oCn6LSo77yM5L2/5LiA5qO1buS4que7k+eCueeahOe6oum7keagkeWni+e7iOS/neaMgeS6hmxvZ27nmoTpq5jluqbvvIzku47ogIzkuZ/lsLHop6Pph4rkuobkuIrpnaLmiYDor7TnmoTigJznuqLpu5HmoJHnmoTmn6Xmib7jgIHmj5LlhaXjgIHliKDpmaTnmoTml7bpl7TlpI3mnYLluqbmnIDlnY/kuLpPKGxvZyBuKeKAnei/meS4gOe7k+iuuuaIkOeri+eahOWOn+WboOOAglxyXG5cclxuXHJcbiDmoJHnmoTml4vovaxcclxuXHJcbuW9k+WcqOWvuee6oum7keagkei/m+ihjOaPkuWFpeWSjOWIoOmZpOetieaTjeS9nOaXtu+8jOWvueagkeWBmuS6huS/ruaUueWPr+iDveS8muegtOWdj+e6oum7keagkeeahOaAp+i0qOOAguS4uuS6hue7p+e7reS/neaMgee6oum7keagkeeahOaAp+i0qO+8jOWPr+S7pemAmui/h+Wvuee7k+eCuei/m+ihjOmHjeaWsOedgOiJsu+8jOS7peWPiuWvueagkei/m+ihjOebuOWFs+eahOaXi+i9rOaTjeS9nO+8jOWNs+mAmui/h+S/ruaUueagkeS4reafkOS6m+e7k+eCueeahOminOiJsuWPiuaMh+mSiOe7k+aehO+8jOadpei+vuWIsOWvuee6oum7keagkei/m+ihjOaPkuWFpeaIluWIoOmZpOe7k+eCueetieaTjeS9nOWQjue7p+e7reS/neaMgeWug+eahOaAp+i0qOaIluW5s+ihoeeahOebrueahOOAglxyXG5cclxu5qCR55qE5peL6L2s5YiG5Li65bem5peL5ZKM5Y+z5peLXHJcblxyXG7moJHlnKjnu4/ov4flt6bml4vlj7Pml4vkuYvlkI7vvIzmoJHnmoTmkJzntKLmgKfotKjkv53mjIHkuI3lj5jvvIzkvYbmoJHnmoTnuqLpu5HmgKfotKjliJnooqvnoLTlnY/kuobvvIzmiYDku6XvvIznuqLpu5HmoJHmj5LlhaXlkozliKDpmaTmlbDmja7lkI7vvIzpnIDopoHliKnnlKjml4vovazkuI7popzoibLph43mtoLmnaXph43mlrDmgaLlpI3moJHnmoTnuqLpu5HmgKfotKjjgIJcclxuXHJcblxyXG7nuqLpu5HmoJHnmoTmj5LlhaVcclxuXHJcbuWmguaenOaPkuWFpeeahOaYr+aguee7k+eCue+8jOeUseS6juWOn+agkeaYr+epuuagke+8jOatpOaDheWGteWPquS8mui/neWPjeaAp+i0qDLvvIzlm6DmraTnm7TmjqXmiormraTnu5PngrnmtoLkuLrpu5HoibLvvJvlpoLmnpzmj5LlhaXnmoTnu5PngrnnmoTniLbnu5PngrnmmK/pu5HoibLvvIznlLHkuo7mraTkuI3kvJrov53lj43mgKfotKgy5ZKM5oCn6LSoNO+8jOe6oum7keagkeayoeacieiiq+egtOWdj++8jOaJgOS7peatpOaXtuS7gOS5iOS5n+S4jeWBmuOAglxyXG7kvYblvZPpgYfliLDkuIvov7Az56eN5oOF5Ya15pe25Y+I6K+l5aaC5L2V6LCD5pW05ZGi77yfXHJcbuKXjyDmj5LlhaXkv67lpI3mg4XlhrUx77ya5aaC5p6c5b2T5YmN57uT54K555qE54i257uT54K55piv57qi6Imy5LiU56WW54i257uT54K555qE5Y+m5LiA5Liq5a2Q57uT54K577yI5Y+U57uT54K577yJ5piv57qi6ImyXHJcbuatpOaXtueItue7k+eCueeahOeItue7k+eCueS4gOWumuWtmOWcqO+8jOWQpuWImeaPkuWFpeWJjeWwseW3suS4jeaYr+e6oum7keagkeOAguS4juatpOWQjOaXtu+8jOWPiOWIhuS4uueItue7k+eCueaYr+ellueItue7k+eCueeahOW3puWtqeWtkOi/mOaYr+WPs+WtqeWtkO+8jOagueaNruWvueensOaAp++8jOaIkeS7rOWPquimgeino+W8gOS4gOS4quaWueWQkeWwseWPr+S7peS6huOAgui/memHjOWPquiAg+iZkeeItue7k+eCueS4uuellueItuW3puWtqeWtkOeahOaDheWGtVxyXG7lr7nmraTvvIzmiJHku6znmoTop6PlhrPnrZbnlaXmmK/vvJrlsIblvZPliY3oioLngrnnmoTniLboioLngrnlkozlj5Tlj5ToioLngrnmtoLpu5HvvIznpZbniLbnu5PngrnmtoLnuqLvvIzmiorlvZPliY3nu5PngrnmjIflkJHnpZbniLboioLngrnvvIzku47mlrDnmoTlvZPliY3oioLngrnph43mlrDlvIDlp4vnrpfms5XjgIJcclxu5LqO5piv77yM5o+S5YWl5L+u5aSN5oOF5Ya1Mei9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTJcclxuXHJcbuKXjyDmj5LlhaXkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOWPs+WtkFxyXG7mraTml7bvvIzop6PlhrPlr7nnrZbmmK/vvJrlvZPliY3oioLngrnnmoTniLboioLngrnlgZrkuLrmlrDnmoTlvZPliY3oioLngrnvvIzku6XmlrDlvZPliY3oioLngrnkuLrmlK/ngrnlt6bml4vjgIJcclxu5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcclxuXHJcbuKXjyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxyXG7op6PlhrPlr7nnrZbmmK/vvJrniLboioLngrnlj5jkuLrpu5HoibLvvIznpZbniLboioLngrnlj5jkuLrnuqLoibLvvIzlnKjnpZbniLboioLngrnkuLrmlK/ngrnlj7Pml4vvvIxcclxu5pyA5ZCO77yM5oqK5qC557uT54K55raC5Li66buR6Imy77yM5pW05qO157qi6buR5qCR5L6/6YeN5paw5oGi5aSN5LqG5bmz6KGh44CCXHJcblxyXG7nu4/ov4fkuIrpnaLmg4XlhrUz44CB5oOF5Ya1NOOAgeaDheWGtTXnrYkz56eN5o+S5YWl5L+u5aSN5oOF5Ya155qE5pON5L2c56S65oSP5Zu+77yM6K+76ICF6Ieq5Lya5Y+R546w77yM5ZCO6Z2i55qE5oOF5Ya1NOOAgeaDheWGtTXpg73mmK/pkojlr7nmg4XlhrUz5o+S5YWl6IqC54K5NOS7peWQju+8jOi/m+ihjOeahOS4gOezu+WIl+aPkuWFpeS/ruWkjeaDheWGteaTjeS9nO+8jOS4jei/h++8jOaMh+WQkeW9k+WJjeiKgueCuU7mjIfpkojkuIDnm7TlnKjlj5jljJbjgILmiYDku6XvvIzkvaDlj6/ku6Xmg7PlvZPnhLbnmoTorqTkuLrvvJrmlbTkuKrkuIvmnaXvvIzmg4XlhrUz44CBNOOAgTXlsLHmmK/kuIDkuKrlrozmlbTnmoTmj5LlhaXkv67lpI3mg4XlhrXnmoTmk43kvZzmtYHnqItcclxuXHJcblxyXG7nuqLpu5HmoJHnmoTliKDpmaRcclxuXHJcbuWcqOWIoOmZpOiKgueCueWQju+8jOWOn+e6oum7keagkeeahOaAp+i0qOWPr+iDveiiq+aUueWPmO+8jOWmguaenOWIoOmZpOeahOaYr+e6ouiJsuiKgueCue+8jOmCo+S5iOWOn+e6oum7keagkeeahOaAp+i0qOS+neaXp+S/neaMge+8jOatpOaXtuS4jeeUqOWBmuS/ruato+aTjeS9nO+8jOWmguaenOWIoOmZpOeahOiKgueCueaYr+m7keiJsuiKgueCue+8jOWOn+e6oum7keagkeeahOaAp+i0qOWPr+iDveS8muiiq+aUueWPmO+8jOaIkeS7rOimgeWvueWFtuWBmuS/ruato+aTjeS9nOOAgumCo+S5iOWTquS6m+agkeeahOaAp+i0qOS8muWPkeeUn+WPmOWMluWRou+8jOWmguaenOWIoOmZpOiKgueCueS4jeaYr+agkeWUr+S4gOiKgueCue+8jOmCo+S5iOWIoOmZpOiKgueCueeahOmCo+S4gOS4quaUr+eahOWIsOWQhOWPtuiKgueCueeahOm7keiJsuiKgueCueaVsOS8muWPkeeUn+WPmOWMlu+8jOatpOaXtuaAp+i0qDXooqvnoLTlnY/jgILlpoLmnpzooqvliKDoioLngrnnmoTllK/kuIDpnZ7nqbrlrZDoioLngrnmmK/nuqLoibLvvIzogIzooqvliKDoioLngrnnmoTniLboioLngrnkuZ/mmK/nuqLoibLvvIzpgqPkuYjmgKfotKg06KKr56C05Z2P44CC5aaC5p6c6KKr5Yig6IqC54K55piv5qC56IqC54K577yM6ICM5a6D55qE5ZSv5LiA6Z2e56m65a2Q6IqC54K55piv57qi6Imy77yM5YiZ5Yig6Zmk5ZCO5paw5qC56IqC54K55bCG5Y+Y5oiQ57qi6Imy77yM6L+d6IOM5oCn6LSoMuOAglxyXG5cclxu5LiK6Z2i55qE5L+u5aSN5oOF5Ya155yL6LW35p2l5pyJ5Lqb5aSN5p2C77yM5LiL6Z2i5oiR5Lus55So5LiA5Liq5YiG5p6Q5oqA5ben77ya5oiR5Lus5LuO6KKr5Yig6IqC54K55ZCO5p2l6aG25pu/5a6D55qE6YKj5Liq6IqC54K55byA5aeL6LCD5pW077yM5bm26K6k5Li65a6D5pyJ6aKd5aSW55qE5LiA6YeN6buR6Imy44CC6L+Z6YeM6aKd5aSW5LiA6YeN6buR6Imy5piv5LuA5LmI5oSP5oCd5ZGi77yM5oiR5Lus5LiN5piv5oqK57qi6buR5qCR55qE6IqC54K55Yqg5LiK6Zmk57qi5LiO6buR55qE5Y+m5LiA56eN6aKc6Imy77yM6L+Z6YeM5Y+q5piv5LiA56eN5YGH6K6+77yM5oiR5Lus6K6k5Li65oiR5Lus5b2T5YmN5oyH5ZCR5a6D77yM5Zug5q2k56m65pyJ6aKd5aSW5LiA56eN6buR6Imy77yM5Y+v5Lul6K6k5Li65a6D55qE6buR6Imy5piv5LuO5a6D55qE54i26IqC54K56KKr5Yig6Zmk5ZCO57un5om/57uZ5a6D55qE77yM5a6D546w5Zyo5Y+v5Lul5a6557qz5Lik56eN6aKc6Imy77yM5aaC5p6c5a6D5Y6f5p2l5piv57qi6Imy77yM6YKj5LmI546w5Zyo5piv57qiK+m7ke+8jOWmguaenOWOn+adpeaYr+m7keiJsu+8jOmCo+S5iOWug+eOsOWcqOeahOminOiJsuaYr+m7kSvpu5HjgILmnInkuobov5nph43pop3lpJbnmoTpu5HoibLvvIzljp/nuqLpu5HmoJHmgKfotKg15bCx6IO95L+d5oyB5LiN5Y+Y44CC546w5Zyo5Y+q6KaB5oGi5aSN5YW25a6D5oCn6LSo5bCx5Y+v5Lul5LqG77yM5YGa5rOV6L+Y5piv5bC96YeP5ZCR5qC556e75Yqo5ZKM56m35Li+5omA5pyJ5Y+v6IO95oCn44CCXHJcblxyXG4g5aaC5p6c5piv5Lul5LiL5oOF5Ya177yM5oGi5aSN5q+U6L6D566A5Y2V77yaXHJcbiBhKeW9k+WJjeiKgueCueaYr+e6oivpu5HoibJcclxuIOino+azle+8jOebtOaOpeaKiuW9k+WJjeiKgueCueafk+aIkOm7keiJsu+8jOe7k+adn+atpOaXtue6oum7keagkeaAp+i0qOWFqOmDqOaBouWkjeOAglxyXG4gYinlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5piv5qC56IqC54K577yMIOino+azle+8muS7gOS5iOmDveS4jeWBmu+8jOe7k+adn+OAglxyXG5cclxuIOS9huWmguaenOaYr+S7peS4i+aDheWGteWRou+8n++8mlxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKVxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJslxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueminOiJsuaYr+m7kSvpu5HvvIzlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzlhYTlvJ/nmoTlt6blrZDmmK/nuqLoibLvvIzlj7PlrZDmmK/pu5HoibJcclxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSPXHJcbiDmraTml7bvvIzmiJHku6zpnIDopoHosIPnlKhSQi1ERUxFVEUtRklYVVAoVCwgeCnvvIzmnaXmgaLlpI3kuI7kv53mjIHnuqLpu5HmgKfotKjnmoTlt6XkvZzjgIJcclxuXHJcbiDkuIvpnaLvvIzlkrHku6zkvr/mnaXliIbliKvlpITnkIbov5k056eN5Yig6Zmk5L+u5aSN5oOF5Ya144CCXHJcblxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKeOAglxyXG4g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV77yI5oiR5Lus5Y+q6K6o6K665b2T5YmN6IqC54K55piv5YW254i26IqC54K55bem5a2p5a2Q5pe255qE5oOF5Ya177yJ44CC5q2k5Y+Y5o2i5ZCO5Y6f57qi6buR5qCR5oCn6LSoNeS4jeWPmO+8jOiAjOaKiumXrumimOi9rOWMluS4uuWFhOW8n+iKgueCueS4uum7keiJsueahOaDheWGtSjms6jvvJrlj5jljJbliY3vvIzljp/mnKzlsLHmnKrov53lj43mgKfotKg177yM5Y+q5piv5Li65LqG5oqK6Zeu6aKY6L2s5YyW5Li65YWE5byf6IqC54K55Li66buR6Imy55qE5oOF5Ya1KeOAglxyXG5cclxuIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibLjgIJcclxuIOino+azle+8muaKiuW9k+WJjeiKgueCueWSjOWFhOW8n+iKgueCueS4reaKveWPluS4gOmHjem7keiJsui/veWKoOWIsOeItuiKgueCueS4iu+8jOaKiueItuiKgueCueW9k+aIkOaWsOeahOW9k+WJjeiKgueCue+8jOmHjeaWsOi/m+WFpeeul+azleOAgu+8iOatpOWPmOaNouWQjuaAp+i0qDXkuI3lj5jvvIlcclxuXHJcbiDliKDpmaTkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRK+m7ke+8jOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOWFhOW8n+eahOW3puWtkOaYr+e6ouiJsu+8jOWPs+WtkOaYr+m7keiJsuOAglxyXG4g6Kej5rOV77ya5oqK5YWE5byf57uT54K55p+T57qi77yM5YWE5byf5bem5a2Q6IqC54K55p+T6buR77yM5LmL5ZCO5YaN5Zyo5YWE5byf6IqC54K55Li65pSv54K56Kej5Y+z5peL77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV44CC5q2k5piv5oqK5b2T5YmN55qE5oOF5Ya16L2s5YyW5Li65oOF5Ya1NO+8jOiAjOaAp+i0qDXlvpfku6Xkv53mjIFcclxuXHJcbiDliKDpmaTkv67lpI3mg4XlhrU077ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRLem7keiJsu+8jOWug+eahOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOS9huaYr+WFhOW8n+iKgueCueeahOWPs+WtkOaYr+e6ouiJsu+8jOWFhOW8n+iKgueCueW3puWtkOeahOminOiJsuS7u+aEj+OAglxyXG4g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXHJcblxyXG5cclxuIOacgOWQjuWAvOW+l+S4gOaPkOeahOaYr+S4iui/sOWIoOmZpOS/ruWkjeeahOaDheWGtTF+NOmDveWPquaYr+agkeeahOWxgOmDqO+8jOW5tumdnuagkeeahOaVtOS9k+WFqOmDqO+8jOS4lOWIoOmZpOS/ruWkjeaDheWGtTPjgIE05Zyo57uP6L+H5LiK6Z2i55qE6LCD5pW05ZCO77yM6LCD5pW06L+Y5rKh57uT5p2fLOi/mOW+l+e7p+e7reiwg+aVtOebtOiHs+mHjeaWsOaBouWkjeW5s+ihoVxyXG4qL1xuXG52YXIgQkxBQ0sgPSAnYmxhY2snO1xuXG52YXIgUmVkQmxhY2tOb2RlID0gZnVuY3Rpb24gKF9CU1ROb2RlKSB7XG4gICAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoUmVkQmxhY2tOb2RlLCBfQlNUTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBSZWRCbGFja05vZGUoKSB7XG4gICAgICAgIHZhciBfT2JqZWN0JGdldFByb3RvdHlwZU87XG5cbiAgICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzBdO1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBSZWRCbGFja05vZGUpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChfT2JqZWN0JGdldFByb3RvdHlwZU8gPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShSZWRCbGFja05vZGUpKS5jYWxsLmFwcGx5KF9PYmplY3QkZ2V0UHJvdG90eXBlTywgW3RoaXMsIGRhdGFdLmNvbmNhdChyZXN0KSkpO1xuXG4gICAgICAgIF90aGlzLmxlZnRDaGlsZCA9IG51bGw7XG4gICAgICAgIF90aGlzLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLmNvbG9yID0gUkVEO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBSZWRCbGFja05vZGU7XG59KF9CaW5hcnlTb3J0ZWRUcmVlMi5kZWZhdWx0KTtcblxudmFyIFJlZEJsYWNrTGVhZiA9IGZ1bmN0aW9uIFJlZEJsYWNrTGVhZigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBSZWRCbGFja0xlYWYpO1xuXG4gICAgdGhpcy5jb2xvciA9IEJMQUNLO1xuICAgIHRoaXMubGVmdENoaWxkID0gdGhpcztcbiAgICB0aGlzLnJpZ2h0Q2hpbGQgPSB0aGlzO1xufTtcblxudmFyIFJlZEJsYWNrVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWRCbGFja1RyZWUoKSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFJlZEJsYWNrVHJlZSk7XG5cbiAgICAgICAgLy8g5ZOo5YW1XG4gICAgICAgIHRoaXMubmlsID0gbmV3IFJlZEJsYWNrTGVhZigpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm5pbDtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOmAkuW9kuafpeaJvueul+azlVxyXG4gICAgICogQHBhcmFtIGRhdGFcclxuICAgICAqL1xuXG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShSZWRCbGFja1RyZWUsIFt7XG4gICAgICAgIGtleTogJ2ZpbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgeiA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBmaW5kKHosIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoeiA9PSBtZS5uaWwgfHwgZGF0YSA9PT0gei5kYXRhKSByZXR1cm4gejtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhIDwgei5kYXRhKSByZXR1cm4gZmluZCh6LmxlZnRDaGlsZCwgZGF0YSk7ZWxzZSByZXR1cm4gZmluZCh6LnJpZ2h0Q2hpbGQsIGRhdGEpO1xuICAgICAgICAgICAgfSh6LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOe6oum7keagkeeahOaPkuWFpVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhZGQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB6ID0gbmV3IFJlZEJsYWNrTm9kZShkYXRhKTtcbiAgICAgICAgICAgIHoubGVmdENoaWxkID0gdGhpcy5uaWw7XG4gICAgICAgICAgICB6LnJpZ2h0Q2hpbGQgPSB0aGlzLm5pbDtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5uaWw7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMucm9vdDtcblxuICAgICAgICAgICAgLy8g5om+5Yiw6KaB5o+S5YWl5L2N572u55qE57uT54K5eVxuICAgICAgICAgICAgd2hpbGUgKHggIT0gdGhpcy5uaWwpIHtcbiAgICAgICAgICAgICAgICB5ID0geDtcblxuICAgICAgICAgICAgICAgIGlmICh6LmRhdGEgPCB4LmRhdGEpIHggPSB4LmxlZnRDaGlsZDtlbHNlIHggPSB4LnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHoucGFyZW50ID0geTtcblxuICAgICAgICAgICAgLy8g5aaC5p6ceeS4jeaYr+aguee7k+eCue+8jOagueaNruWkp+Wwj+aPkuWFpeWIsOW3puaIluWPs+WtkOagkVxuICAgICAgICAgICAgaWYgKHkgIT0gdGhpcy5uaWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoei5kYXRhIDwgeS5kYXRhKSB5LmxlZnRDaGlsZCA9IHo7ZWxzZSB5LnJpZ2h0Q2hpbGQgPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5ZCm5YiZ5o+S5YWl5Yiw5qC557uT54K5XG4gICAgICAgICAgICBlbHNlIHRoaXMucm9vdCA9IHogPT0gdGhpcy5uaWwgPyBudWxsIDogejtcblxuICAgICAgICAgICAgLy8g5o+S5YWl5L+u5aSN5pON5L2cXG4gICAgICAgICAgICB0aGlzLl9hZGRGaXh1cCh6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaPkuWFpeeul+azleS/ruWkjVxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVkQmxhY2tOb2RlfSB6IOW+heaPkuWFpeeahOe7k+eCuVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZGRGaXh1cCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkRml4dXAoeikge1xuXG4gICAgICAgICAgICB3aGlsZSAoeiAhPSB0aGlzLnJvb3QgJiYgei5wYXJlbnQuY29sb3IgPT09IFJFRCkge1xuICAgICAgICAgICAgICAgIGlmICh6LnBhcmVudCA9PSB6LnBhcmVudC5wYXJlbnQubGVmdENoaWxkKSBsZWZ0QWRkRml4dXAodGhpcywgeik7ZWxzZSByaWdodEFkZEZpeHVwKHRoaXMsIHopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDmnIDlkI7vvIzmiormoLnnu5PngrnmtoLkuLrpu5HoibLvvIzmlbTmo7XnuqLpu5HmoJHkvr/ph43mlrDmgaLlpI3kuoblubPooaFcbiAgICAgICAgICAgIHRoaXMucm9vdC5jb2xvciA9IEJMQUNLO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog57qi6buR5qCR55qE5Yig6Zmk566X5rOVXHJcbiAgICAgICAgICogQHBhcmFtIHtSZWRCbGFja05vZGV9IHog5b6F5Yig6Zmk57uT54K5XHJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTm9kZSh6KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB5ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAvLyDmib7liLDlvoXliKDpmaTnu5PngrnnmoTniLbnu5PngrnmiJbnm7jpgrvlvoXmm7/mjaLnu5PngrlcbiAgICAgICAgICAgIGlmICh6LmxlZnRDaGlsZCA9PSB0aGlzLm5pbCB8fCB6LnJpZ2h0Q2hpbGQgPT0gdGhpcy5uaWwpIHkgPSB6O2Vsc2UgeSA9IHRoaXMuc3VjY2Vzc29yKHopO1xuXG4gICAgICAgICAgICBpZiAoeS5sZWZ0Q2hpbGQgIT0gdGhpcy5uaWwpIHggPSB5LmxlZnRDaGlsZDtlbHNlIHggPSB5LnJpZ2h0Q2hpbGQ7XG5cbiAgICAgICAgICAgIHgucGFyZW50ID0geS5wYXJlbnQ7XG5cbiAgICAgICAgICAgIC8vIOWIoOmZpOaTjeS9nFxuICAgICAgICAgICAgaWYgKHkucGFyZW50ID09IHRoaXMubmlsKSB0aGlzLnJvb3QgPSB4O2Vsc2UgaWYgKHkgPT0geS5wYXJlbnQubGVmdENoaWxkKSB5LnBhcmVudC5sZWZ0Q2hpbGQgPSB4O2Vsc2UgeS5wYXJlbnQucmlnaHRDaGlsZCA9IHg7XG5cbiAgICAgICAgICAgIGlmICh5ICE9IHopIHouZGF0YSA9IHkuZGF0YTtcblxuICAgICAgICAgICAgLy8g5Yig6Zmk5L+u5aSNXG4gICAgICAgICAgICBpZiAoeS5jb2xvciA9PT0gQkxBQ0spIHRoaXMuX3JlbW92ZUZpeHVwKHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g566X5rOV5a+86K665LiK55qE5Yig6Zmk57uT54K5XG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZU5vZGUyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU5vZGUyKHopIHtcbiAgICAgICAgICAgIHZhciB5ID0gejtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFlDb2xvciA9IHkuY29sb3I7XG4gICAgICAgICAgICB2YXIgeCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKHoubGVmdENoaWxkID09IHRoaXMubmlsKSB7XG4gICAgICAgICAgICAgICAgeCA9IHoucmlnaHRDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHoucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHoucmlnaHRDaGlsZCA9PSB0aGlzLm5pbCkge1xuICAgICAgICAgICAgICAgIHggPSB6LmxlZnRDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHoubGVmdENoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IHRoaXMubWluKHoucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxZQ29sb3IgPSB5LmNvbG9yO1xuICAgICAgICAgICAgICAgIHggPSB5LnJpZ2h0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoeS5wYXJlbnQgPT0geikgeC5wYXJlbnQgPSB5O2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHksIHkucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHkucmlnaHRDaGlsZCA9IHoucmlnaHRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgeS5yaWdodENoaWxkLnBhcmVudCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwbGFudCh6LCB5KTtcbiAgICAgICAgICAgICAgICB5LmxlZnRDaGlsZCA9IHoubGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIHkubGVmdENoaWxkLnBhcmVudCA9IHk7XG4gICAgICAgICAgICAgICAgeS5jb2xvciA9IHouY29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFlDb2xvciA9PT0gQkxBQ0spIHRoaXMuX3JlbW92ZUZpeHVwKHgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfdHJhbnNwbGFudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNwbGFudCh1LCB2KSB7XG4gICAgICAgICAgICBpZiAodS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHY7ZWxzZSBpZiAodSA9PSB1LnBhcmVudC5sZWZ0Q2hpbGQpIHUucGFyZW50LmxlZnRDaGlsZCA9IHY7ZWxzZSB1LnBhcmVudC5yaWdodENoaWxkID0gdjtcblxuICAgICAgICAgICAgdi5wYXJlbnQgPSB1LnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIoOmZpOS/ruWkjVxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVkQmxhY2tOb2RlfSB6XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3JlbW92ZUZpeHVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGaXh1cCh6KSB7XG4gICAgICAgICAgICB3aGlsZSAoeiAhPT0gdGhpcy5yb290ICYmIHouY29sb3IgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgaWYgKHogPT0gei5wYXJlbnQubGVmdENoaWxkKSBsZWZ0UmVtb3ZlRml4dXAodGhpcywgeik7ZWxzZSByaWdodFJlbW92ZUZpeHVwKHRoaXMsIHopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6LmNvbG9yID0gQkxBQ0s7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N1Y2Nlc3NvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWNjZXNzb3Ioeikge1xuICAgICAgICAgICAgaWYgKHoucmlnaHRDaGlsZCAhPSB0aGlzLm5pbCkgcmV0dXJuIHRoaXMubWluKHoucmlnaHRDaGlsZCk7XG5cbiAgICAgICAgICAgIHZhciB5ID0gei5wYXJlbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlICh5ICE9IHRoaXMubmlsICYmIHogPT0geS5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICAgICAgeiA9IHk7XG4gICAgICAgICAgICAgICAgeSA9IHkucGFyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWluJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbih6KSB7XG4gICAgICAgICAgICB3aGlsZSAoei5sZWZ0Q2hpbGQgIT0gdGhpcy5uaWwpIHtcbiAgICAgICAgICAgICAgICB6ID0gei5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB6O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5qC55o2ua2V55YC85Yig6Zmk57uT54K5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcbiAgICAgICAgICAgIHZhciB6ID0gdGhpcy5maW5kKGtleSk7XG5cbiAgICAgICAgICAgIGlmICh6ID09IHRoaXMubmlsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU5vZGUoeik7XG4gICAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFJlZEJsYWNrVHJlZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVkQmxhY2tUcmVlO1xuXG5cblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZUxlZnQgPSByb3RhdGUoJ2xlZnQnKTtcblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gcm90YXRlKCdyaWdodCcpO1xuXG5mdW5jdGlvbiByb3RhdGUoZGlyKSB7XG4gICAgdmFyIGMxID0gdm9pZCAwLFxuICAgICAgICBjMiA9IHZvaWQgMDtcbiAgICBpZiAoZGlyID09PSAnbGVmdCcpIHtcbiAgICAgICAgYzEgPSAncmlnaHRDaGlsZCc7XG4gICAgICAgIGMyID0gJ2xlZnRDaGlsZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYzEgPSAnbGVmdENoaWxkJztcbiAgICAgICAgYzIgPSAncmlnaHRDaGlsZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB5ID0geFtjMV07XG4gICAgICAgIHhbYzFdID0geVtjMl07XG5cbiAgICAgICAgaWYgKHlbYzJdICE9IHRoaXMubmlsKSB5W2MyXS5wYXJlbnQgPSB4O1xuICAgICAgICB5LnBhcmVudCA9IHgucGFyZW50O1xuXG4gICAgICAgIGlmICh4LnBhcmVudCA9PSB0aGlzLm5pbCkgdGhpcy5yb290ID0geTtlbHNlIGlmICh4ID09IHgucGFyZW50W2MyXSkgeC5wYXJlbnRbYzJdID0geTtlbHNlIHgucGFyZW50W2MxXSA9IHk7XG5cbiAgICAgICAgeVtjMl0gPSB4O1xuICAgICAgICB4LnBhcmVudCA9IHk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkRml4dXAoZGlyKSB7XG4gICAgdmFyIGMxID0gdm9pZCAwLFxuICAgICAgICBjMiA9IHZvaWQgMCxcbiAgICAgICAgcm90YXRlMSA9IHZvaWQgMCxcbiAgICAgICAgcm90YXRlMiA9IHZvaWQgMDtcbiAgICBpZiAoZGlyID09PSAnbGVmdCcpIHtcbiAgICAgICAgYzEgPSAncmlnaHRDaGlsZCc7XG4gICAgICAgIGMyID0gJ2xlZnRDaGlsZCc7XG4gICAgICAgIHJvdGF0ZTEgPSAnX3JvdGF0ZUxlZnQnO1xuICAgICAgICByb3RhdGUyID0gJ19yb3RhdGVSaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYzEgPSAnbGVmdENoaWxkJztcbiAgICAgICAgYzIgPSAncmlnaHRDaGlsZCc7XG4gICAgICAgIHJvdGF0ZTEgPSAnX3JvdGF0ZVJpZ2h0JztcbiAgICAgICAgcm90YXRlMiA9ICdfcm90YXRlTGVmdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmVlLCB6KSB7XG4gICAgICAgIC8vIG5vdGU6IOazqOmHiuS7peW3pui+ueS4uuaDheWGtVxuXG4gICAgICAgIC8vIOWPlOe7k+eCuVxuICAgICAgICB2YXIgeSA9IHoucGFyZW50LnBhcmVudFtjMV07XG5cbiAgICAgICAgLy8g5o+S5YWl5L+u5aSN5oOF5Ya1Me+8muWmguaenOW9k+WJjee7k+eCueeahOeItue7k+eCueaYr+e6ouiJsuS4lOellueItue7k+eCueeahOWPpuS4gOS4quWtkOe7k+eCue+8iOWPlOe7k+eCue+8ieaYr+e6ouiJslxuICAgICAgICAvLyDlsIblvZPliY3oioLngrnnmoTniLboioLngrnlkozlj5Tlj5ToioLngrnmtoLpu5HvvIznpZbniLbnu5PngrnmtoLnuqLvvIzmiorlvZPliY3nu5PngrnmjIflkJHnpZbniLboioLngrnvvIzku47mlrDnmoTlvZPliY3oioLngrnph43mlrDlvIDlp4vnrpfms5XjgIJcbiAgICAgICAgaWYgKHkuY29sb3IgPT09IFJFRCkge1xuICAgICAgICAgICAgei5wYXJlbnQuY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHkuY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHoucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcbiAgICAgICAgICAgIHogPSB6LnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOWPs+WtkFxuICAgICAgICAgICAgLy8g6Kej5Yaz5a+5562W5piv77ya5b2T5YmN6IqC54K555qE54i26IqC54K55YGa5Li65paw55qE5b2T5YmN6IqC54K577yM5Lul5paw5b2T5YmN6IqC54K55Li65pSv54K55bem5peL44CCXG4gICAgICAgICAgICAvLyDku47ogIzmj5LlhaXkv67lpI3mg4XlhrUy6L2s5o2i5oiQ5LqG5o+S5YWl5L+u5aSN5oOF5Ya1M+OAglxuICAgICAgICAgICAgaWYgKHogPT09IHoucGFyZW50W2MxXSkge1xuICAgICAgICAgICAgICAgIHogPSB6LnBhcmVudDtcbiAgICAgICAgICAgICAgICB0cmVlW3JvdGF0ZTFdKHopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxuICAgICAgICAgICAgLy8g6Kej5Yaz5a+5562W5piv77ya54i26IqC54K55Y+Y5Li66buR6Imy77yM56WW54i26IqC54K55Y+Y5Li657qi6Imy77yM5Zyo56WW54i26IqC54K55Li65pSv54K55Y+z5peL77yMXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xuICAgICAgICAgICAgei5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgdHJlZVtyb3RhdGUyXSh6LnBhcmVudC5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxudmFyIGxlZnRBZGRGaXh1cCA9IGFkZEZpeHVwKCdsZWZ0Jyk7XG52YXIgcmlnaHRBZGRGaXh1cCA9IGFkZEZpeHVwKCdyaWdodCcpO1xudmFyIGxlZnRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdsZWZ0Jyk7XG52YXIgcmlnaHRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdyaWdodCcpO1xuXG5mdW5jdGlvbiByZW1vdmVGaXh1cChkaXIpIHtcbiAgICB2YXIgYzEgPSB2b2lkIDAsXG4gICAgICAgIGMyID0gdm9pZCAwLFxuICAgICAgICByMSA9IHZvaWQgMCxcbiAgICAgICAgcjIgPSB2b2lkIDA7XG4gICAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICBjMiA9ICdsZWZ0Q2hpbGQnO1xuICAgICAgICByMSA9ICdfcm90YXRlTGVmdCc7XG4gICAgICAgIHIyID0gJ19yb3RhdGVSaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYzEgPSAnbGVmdENoaWxkJztcbiAgICAgICAgYzIgPSAncmlnaHRDaGlsZCc7XG4gICAgICAgIHIxID0gJ19yb3RhdGVSaWdodCc7XG4gICAgICAgIHIyID0gJ19yb3RhdGVMZWZ0JztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRyZWUsIHopIHtcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XG5cbiAgICAgICAgLy8g5Y+U57uT54K5XG4gICAgICAgIHZhciB3ID0gei5wYXJlbnRbYzFdO1xuXG4gICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTHvvJrlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5YWE5byf6IqC54K55Li657qi6ImyKOatpOaXtueItuiKgueCueWSjOWFhOW8n+iKgueCueeahOWtkOiKgueCueWIhuS4uum7kSnjgIJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOVXG4gICAgICAgIGlmICh3LmNvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAgIHcuY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgdHJlZVtyMV0oei5wYXJlbnQpO1xuICAgICAgICAgICAgdyA9IHoucGFyZW50W2MxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibLjgIJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK5b2T5YmN6IqC54K55ZKM5YWE5byf6IqC54K55Lit5oq95Y+W5LiA6YeN6buR6Imy6L+95Yqg5Yiw54i26IqC54K55LiK77yM5oqK54i26IqC54K55b2T5oiQ5paw55qE5b2T5YmN6IqC54K577yM6YeN5paw6L+b5YWl566X5rOV44CCXG4gICAgICAgIGlmICh3W2MyXS5jb2xvciA9PT0gQkxBQ0sgJiYgd1tjMV0uY29sb3IgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICB3LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgeiA9IHoucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueminOiJsuaYr+m7kSvpu5HvvIzlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzlhYTlvJ/nmoTlt6blrZDmmK/nuqLoibLvvIzlj7PlrZDmmK/pu5HoibLjgIJcbiAgICAgICAgICAgIC8vIOino+azle+8muaKiuWFhOW8n+e7k+eCueafk+e6ou+8jOWFhOW8n+W3puWtkOiKgueCueafk+m7ke+8jOS5i+WQjuWGjeWcqOWFhOW8n+iKgueCueS4uuaUr+eCueino+WPs+aXi++8jOS5i+WQjumHjeaWsOi/m+WFpeeul+azleOAglxuICAgICAgICAgICAgaWYgKHdbYzFdLmNvbG9yID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIHdbYzJdLmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICAgICAgdy5jb2xvciA9IFJFRDtcbiAgICAgICAgICAgICAgICB0cmVlW3IyXSh3KTtcbiAgICAgICAgICAgICAgICB3ID0gei5wYXJlbnRbYzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrU077ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRLem7keiJsu+8jOWug+eahOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOS9huaYr+WFhOW8n+iKgueCueeahOWPs+WtkOaYr+e6ouiJsu+8jOWFhOW8n+iKgueCueW3puWtkOeahOminOiJsuS7u+aEj+OAglxuICAgICAgICAgICAgLy8g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXG4gICAgICAgICAgICB3LmNvbG9yID0gei5wYXJlbnQuY29sb3I7XG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xuICAgICAgICAgICAgd1tjMV0uY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHRyZWVbcjFdKHoucGFyZW50KTtcbiAgICAgICAgICAgIHogPSB0cmVlLnJvb3Q7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG52YXIgdGVzdCA9IG5ldyBSZWRCbGFja1RyZWUoKTtcbnRlc3QuYWRkKDEzKTtcbnRlc3QuYWRkKDgpO1xudGVzdC5hZGQoMTcpO1xudGVzdC5hZGQoMSk7XG50ZXN0LmFkZCg2KTtcbnRlc3QuYWRkKDExKTtcbnRlc3QuYWRkKDE1KTtcbnRlc3QuYWRkKDIyKTtcbnRlc3QuYWRkKDI1KTtcbnRlc3QuYWRkKDI3KTtcblxudGVzdC5yZW1vdmUoMTMpO1xudGVzdC5yZW1vdmUoOCk7XG50ZXN0LnJlbW92ZSgxNyk7XG50ZXN0LnJlbW92ZSgxKTtcbnRlc3QucmVtb3ZlKDYpO1xudGVzdC5yZW1vdmUoMTEpO1xudGVzdC5yZW1vdmUoMTUpO1xudGVzdC5yZW1vdmUoMjIpO1xudGVzdC5yZW1vdmUoMjUpO1xudGVzdC5yZW1vdmUoMjcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU2VhcmNoL1JlZEJsYWNrVHJlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNlY29uZE9wdGltYWwgPSBzZWNvbmRPcHRpbWFsO1xuZXhwb3J0cy5jcmVhdGVTT1NUcmVlID0gY3JlYXRlU09TVHJlZTtcblxudmFyIF9CaW5hcnlUcmVlID0gcmVxdWlyZSgnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJyk7XG5cbi8qKlxyXG4gKiDnlLHmnInluo/ooahzVGFibGVbbG93Li5oaWdoXeWPiuWFtue0r+iuoeadg+WAvOihqHdlaWdodHPpgJLlvZLmnoTpgKDmrKHkvJjmn6Xmib7moJFcclxuICogQHBhcmFtIHtCaW5hcnlUcmVlfSB0cmVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNUYWJsZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzV2VpZ2h0c1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXHJcbiAqL1xuZnVuY3Rpb24gc2Vjb25kT3B0aW1hbCh0cmVlLCBzVGFibGUsIHNXZWlnaHRzLCBsb3csIGhpZ2gpIHtcbiAgICB2YXIgaSA9IGxvdztcbiAgICB2YXIgbWluID0gTWF0aC5hYnMoc1dlaWdodHNbaGlnaF0gLSBzV2VpZ2h0c1tsb3ddKTtcbiAgICB2YXIgZHcgPSBzV2VpZ2h0c1toaWdoXSArIChzV2VpZ2h0c1tsb3cgLSAxXSB8fCAwKTtcblxuICAgIC8vIOmAieaLqeacgOWwj+eahOKWs1Bp5YC8XG4gICAgZm9yICh2YXIgaiA9IGxvdyArIDE7IGogPD0gaGlnaDsgKytqKSB7XG4gICAgICAgIHZhciB0ID0gTWF0aC5hYnMoZHcgLSBzV2VpZ2h0c1tqXSAtIHNXZWlnaHRzW2ogLSAxXSk7XG4gICAgICAgIGlmICh0IDwgbWluKSB7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIG1pbiA9IHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDosIPmlbTmoJHmoLnmnYPvvIzpgInmi6npgrvov5HmnYPlgLzovoPlpKfnmoTlhbPplK7lrZdcbiAgICB2YXIgYSA9IDAsXG4gICAgICAgIGIgPSB2b2lkIDAsXG4gICAgICAgIGMgPSAwO1xuICAgIGlmIChpIC0gMSA+PSBsb3cpIGIgPSBzV2VpZ2h0c1tpXSAtIHNXZWlnaHRzW2kgLSAxXTtcbiAgICBpZiAoaSAtIDIgPj0gbG93KSBhID0gc1dlaWdodHNbaSAtIDFdIC0gc1dlaWdodHNbaSAtIDJdO1xuICAgIGlmIChpICsgMSA8IGhpZ2gpIGMgPSBzV2VpZ2h0c1tpICsgMV0gLSBzV2VpZ2h0c1tpXTtcbiAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChhID4gYyAmJiBhID4gYikgLS1pO2Vsc2UgaWYgKGEgPCBjICYmIGMgPiBiKSArK2k7XG4gICAgfVxuXG4gICAgdHJlZS5kYXRhID0gc1RhYmxlW2ldO1xuICAgIC8v5bem5a2Q5qCRXG4gICAgaWYgKGkgPT09IGxvdykgdHJlZS5sZWZ0Q2hpbGQgPSBudWxsO2Vsc2Uge1xuICAgICAgICB0cmVlLmxlZnRDaGlsZCA9IG5ldyBfQmluYXJ5VHJlZS5CaW5hcnlUcmVlKCk7XG4gICAgICAgIHNlY29uZE9wdGltYWwodHJlZS5sZWZ0Q2hpbGQsIHNUYWJsZSwgc1dlaWdodHMsIGxvdywgaSAtIDEpO1xuICAgIH1cbiAgICAvLyDlj7PlrZDmoJFcbiAgICBpZiAoaSA9PT0gaGlnaCkgdHJlZS5yaWdodENoaWxkID0gbnVsbDtlbHNlIHtcbiAgICAgICAgdHJlZS5yaWdodENoaWxkID0gbmV3IF9CaW5hcnlUcmVlLkJpbmFyeVRyZWUoKTtcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLnJpZ2h0Q2hpbGQsIHNUYWJsZSwgc1dlaWdodHMsIGkgKyAxLCBoaWdoKTtcbiAgICB9XG59IC8qXHJcbiAgIOmdmeaAgeasoeS8mOafpeaJvuagkVxyXG4gIFxyXG4gICDpgILlkIjlkITorrDlvZXnmoTmn6Xmib7mpoLnjofkuI3nrYnnmoTmg4XlhrVcclxuICBcclxuICAg5p+l5om+5pWI546H5pyA6auY5Y2z5bmz5Z2H5p+l5om+6ZW/5bqm5pyA5bCP77yM5oiR5Lus5Y+v5Lul57uZ5Ye65pyJ5bqP6KGo5Zyo6Z2e562J5qaC546H5oOF5Ya15LiL5bqU6YG15b6q55qE5Lik5Liq5Y6f5YiZ77yaXHJcbiAgIDHjgIHmnIDlhYjorr/pl67nmoTnu5PngrnlupTmmK/orr/pl67mpoLnjofmnIDlpKfnmoTnu5PngrnvvJtcclxuICAgMuOAgeavj+asoeiuv+mXruW6lOS9v+e7k+eCueS4pOi+ueWwmuacquiuv+mXrueahOe7k+eCueeahOiiq+iuv+amgueOh+S5i+WSjOWwveWPr+iDveebuOetieOAglxyXG4gIFxyXG4gIFxyXG4gICDov5nkuKTkuKrljp/liJnlj6/nlKjkuIDlj6Xor53mnaXooajnpLrvvIzljbPliKTlrprmoJHkuLrluKbmnYPlhoXot6/lvoTplb/luqbkuYvlkozmnIDlsI/nmoTkuozlj4nmoJHvvIzkuqbljbPvvJpQSCA9IOKIkXdpaGkgIOacgOWwj++8jOWFtuS4rSBuIOS4uuacieW6j+ihqOmVv+W6pu+8jGhpIOS4uuesrCBpIOS4que7k+eCueWcqOWIpOWumuagkeS4iueahOWxguasoeaVsO+8jHdpID0gY3Bp77yMYyDkuLrmn5DkuKrluLjmlbDvvIxwaSDkuLrnrKwgaSDkuKrnu5PngrnnmoTmn6Xmib7mpoLnjofjgIJcclxuICBcclxuICBcclxuICAg6L+Z5qC355qE5qCR56ew5Li66Z2Z5oCB5pyA5LyY5p+l5om+5qCR77yIc3RhdGljIG9wdGltYWwgc2VhcmNoIHRyZWXvvInvvIzmnoTpgKDov5nmoLfkuIDmo7XmoJHnmoTml7bpl7Tku6Pku7flpKrlpKfvvIzkuqbljbPml7bpl7TlpI3mnYLluqblvojlpKfvvIzlm6DmraTmiJHku6zpgJrluLjmmK/mnoTpgKDmrKHkvJjmn6Xmib7moJHvvIhuZWFybHkgb3B0aW1hbCBzZWFyY2ggdHJlZe+8ie+8jOaehOmAoOWug+eahOaXtumXtOS7o+S7t+i/nOi/nOS9juS6juaehOmAoOacgOS8mOafpeaJvuagke+8jOS9huafpeaJvuaAp+iDveWPquavlOacgOS8mOafpeaJvuagkeW3rjElfjIl77yM5b6I5bCR5beuMyXku6XkuIrjgIJcclxuICBcclxuICAg5qyh5LyY5p+l5om+5qCR55qE5p6E6YCg77yaXHJcbiAgXHJcbiAgIOiuvuacieW6j+ihqOavj+S4quiusOW9leeahOadg+WAvOS4uiB3bCx3bCsxLOKApix3aO+8jOesrOS4gOS4quW6lOiuv+mXrueahOe7k+eCueWPt+S4uiBpIO+8jOWImeacie+8mlxyXG4gICDOlHBpID0gICDiiJF3aiAtIOKIkXdqICAg5pyA5bCP77yM5Y2zIM6UcGkgPSBNaW4ge86UcGogfVxyXG4gICDlho3liIbliKvlr7kge3JsLHJsKzEs4oCmLHJpLTF9IOWSjCB7cmkrMSxyaSsyLOKApixyaH0g5YiG5Yir5p6E6YCg5qyh5LyY5p+l5om+5qCRXHJcbiAgICovXG5cblxudmFyIHRyZWUgPSBuZXcgX0JpbmFyeVRyZWUuQmluYXJ5VHJlZSgpO1xuc2Vjb25kT3B0aW1hbCh0cmVlLCBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJ10sIFsxLCAyLCA0LCA5LCAxMiwgMTYsIDIwLCAyMywgMjhdLCAwLCA4KTtcbmNvbnNvbGUubG9nKHRyZWUpO1xuXG4vKipcclxuICog55Sx5pyJ5bqP6KGo5p6E6YCg5LiA5qO15qyh5LyY5p+l5om+5qCRXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmog5pyJ5bqP6KGo77yM5pWw5o2u5YWD57Sg5ZCr5pyJ5p2D5Z+fd2VpZ2h0XHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU09TVHJlZShvYmopIHtcbiAgICB2YXIgdHJlZSA9IHZvaWQgMDtcbiAgICBpZiAob2JqLmVsZW1zLmxlbmd0aCA9PT0gMCkgdHJlZSA9IG51bGw7ZWxzZSB7XG4gICAgICAgIC8vIOaxgue0r+iuoeadg+WAvOihqFxuICAgICAgICB2YXIgc3cgPSBmaW5kU1cob2JqLndlaWdodHMpO1xuICAgICAgICB0cmVlID0gbmV3IF9CaW5hcnlUcmVlLkJpbmFyeVRyZWUoKTtcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLCBvYmouZWxlbXMsIHN3LCAwLCBvYmouZWxlbXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRTVyhzVGFibGUpIHtcbiAgICB2YXIgc3cgPSBbc1RhYmxlWzBdXTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc1RhYmxlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3W2ldID0gc3dbaSAtIDFdICsgc1RhYmxlW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBzdztcbn1cblxudmFyIHNvc1RyZWUgPSBjcmVhdGVTT1NUcmVlKHtcbiAgICBlbGVtczogWydBJywgJ0InLCAnQycsICdEJywgJ0UnXSxcbiAgICB3ZWlnaHRzOiBbMSwgMzAsIDIsIDI5LCAzXVxufSk7XG5zb3NUcmVlLmluT3JkZXJSZWN1cnNpdmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coJ2luT3JkZXI6ICcgKyB2YWx1ZSk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NlYXJjaC9TT1NUcmVlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpYm9uYWNjaVNlYXJjaDtcbi8qXHJcbiBGaWJvbmFjY2nmn6Xmib5cclxuXHJcbiBGaWJvbmFjY2nmn6Xmib7mlrnms5XmmK/moLnmja5GaWJvbmFjY2nmlbDliJfnmoTnibnngrnlr7nmn6Xmib7ooajov5vooYzliIblibLjgIJGaWJvbmFjY2nmlbDliJfnmoTlrprkuYnmmK/vvJpcclxuIEYoMCk9MO+8jEYoMSk9Me+8jEYoaik9RihqLTEpK0Yoai0yKSDjgIJcclxuXHJcbiAxICDmn6Xmib7mgJ3mg7NcclxuIOiuvuafpeaJvuihqOS4reeahOiusOW9leaVsOavlOafkOS4qkZpYm9uYWNjaeaVsOWwjzHvvIzljbPorr5uPUYoaiktMeOAgueUqExvd+OAgUhpZ2jlkoxNaWTooajnpLrlvoXmn6Xmib7ljLrpl7TnmoTkuIvnlYzjgIHkuIrnlYzlkozliIblibLkvY3nva7vvIzliJ3lgLzkuLpMb3c9MO+8jEhpZ2g9biAtIDHjgIJcclxuIOKRtCAgIOWPluWIhuWJsuS9jee9rk1pZO+8mk1pZD1GKGotMSkg77ybXHJcbiDikbUgICDmr5TovoPliIblibLkvY3nva7orrDlvZXnmoTlhbPplK7lrZfkuI7nu5nlrprnmoRL5YC877yaXHJcbiDikaAg55u4562J77yaIOafpeaJvuaIkOWKn++8m1xyXG4g4pGhICDlpKfkuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTliY3ljYrmrrUo5Yy66Ze06ZW/5bqm5Li6RihqLTEpLTEp77yM5L+u5pS55LiK55WM5oyH6ZKI77yaIEhpZ2g9TWlkLTHvvIzovazikbQg77ybXHJcbiDikaIgIOWwj+S6ju+8muW+heafpeiusOW9leWcqOWMuumXtOeahOWQjuWNiuautSjljLrpl7Tplb/luqbkuLpGKGotMiktMSnvvIzkv67mlLnkuIvnlYzmjIfpkojvvJpMb3c9TWlkKzHvvIzovazikbQg77yb55u05Yiw6LaK55WMKExvdz5IaWdoKe+8jOafpeaJvuWksei0peOAglxyXG5cclxuIDIgIOeul+azleWunueOsFxyXG4g5Zyo566X5rOV5a6e546w5pe277yM5Li65LqG6YG/5YWN6aKR57mB6K6h566XRmlib25hY2Np5pWw77yM5Y+v55So5Lik5Liq5Y+Y6YePZjHlkoxmMuS/neWtmOW9k+WJjeebuOmCu+eahOS4pOS4qkZpYm9uYWNjaeaVsO+8jOi/meagt+WcqOS7peWQjueahOiuoeeul+S4reWPr+S7peS+neasoemAkuaOqOiuoeeul+WHuuOAglxyXG5cclxuIDMgIOeul+azleWIhuaekFxyXG4g55Sx566X5rOV55+l77yMRmlib25hY2Np5p+l5om+5Zyo5pyA5Z2P5oOF5Ya15LiL5oCn6IO95q+U5oqY5Y2K5p+l5om+5beu77yM5L2G5bmz5Z2H5pCc57Si5qyh5pWw5bCR5LqO5oqY5Y2K5p+l5om+77yM6ICM5LiU5oqY5Y2K5p+l5om+6KaB5rGC6K6w5b2V5oyJ5YWz6ZSu5a2X5pyJ5bqP77ybRmlib25hY2Np5p+l5om+55qE5LyY54K55piv5YiG5Ymy5pe25Y+q6ZyA6L+b6KGM5Yqg44CB5YeP6L+Q566X44CCXHJcblxyXG4gKi9cblxuZnVuY3Rpb24gZmliKG4pIHtcbiAgICBpZiAobiA9PT0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKG4gPT09IDEpIHJldHVybiAxO1xuICAgIHZhciBmID0gdm9pZCAwO1xuICAgIHZhciBmMCA9IDA7XG4gICAgdmFyIGYxID0gMTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgZiA9IGYwICsgZjE7XG4gICAgICAgIGYwID0gZjE7XG4gICAgICAgIGYxID0gZjtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG59XG5cbi8qKlxyXG4gKiDlnKjmnInluo/ooahTVOS4reeUqEZpYm9uYWNjaeaWueazleafpeaJvuWFs+mUruWtl+S4umtleeeahOiusOW9lVxyXG4gKiBAcGFyYW0gc1RhYmxlXHJcbiAqIEBwYXJhbSBrZXlcclxuICogQHBhcmFtIG5cclxuICovXG5mdW5jdGlvbiBmaWJvbmFjY2lTZWFyY2goc1RhYmxlLCBrZXkpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHNUYWJsZS5sZW5ndGggOiBhcmd1bWVudHNbMl07XG5cbiAgICB2YXIgbG93ID0gMDtcbiAgICB2YXIgaGlnaCA9IG4gLSAxO1xuICAgIHZhciBmMSA9IGZpYihuKTtcbiAgICB2YXIgZjIgPSBmaWIobiAtIDEpO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBsb3cgKyBmMSAtIDE7XG4gICAgICAgIGlmIChzVGFibGVbbWlkXSA9PT0ga2V5KSByZXR1cm4gbWlkO2Vsc2UgaWYgKGtleSA8IHNUYWJsZVttaWRdKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIGYyID0gZjEgLSBmMjtcbiAgICAgICAgICAgIGYxID0gZjEgLSBmMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBmMSA9IGYxIC0gZjI7XG4gICAgICAgICAgICBmMiA9IGYyIC0gZjE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5jb25zb2xlLmxvZygnZmlib25hY2NpU2VhcmNoOiAnKTtcbmNvbnNvbGUubG9nKGZpYm9uYWNjaVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDUpKTsgLy8gNFxuY29uc29sZS5sb2coZmlib25hY2NpU2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgNikpOyAvLyAtMVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzZXF1ZW50aWFsU2VhcmNoO1xuLypcclxuIOmdmeaAgeafpeaJvlxyXG5cclxuIOe6v+aAp+ihqOaYr+afpeaJvuihqOacgOeugOWNleeahOS4gOenjee7hOe7h+aWueW8j1xyXG5cclxuIOmhuuW6j+afpeaJvihTZXF1ZW50aWFsIFNlYXJjaClcclxuIDEgIOafpeaJvuaAneaDs1xyXG4g5LuO6KGo55qE5LiA56uv5byA5aeL6YCQ5Liq5bCG6K6w5b2V55qE5YWz6ZSu5a2X5ZKM57uZ5a6aS+WAvOi/m+ihjOavlOi+g++8jOiLpeafkOS4quiusOW9leeahOWFs+mUruWtl+WSjOe7meWumkvlgLznm7jnrYnvvIzmn6Xmib7miJDlip/vvJvlkKbliJnvvIzoi6Xmiavmj4/lrozmlbTkuKrooajvvIzku43nhLbmsqHmnInmib7liLDnm7jlupTnmoTorrDlvZXvvIzliJnmn6Xmib7lpLHotKXjgIJcclxuXHJcbiAyICDnrpfms5XliIbmnpBcclxuIOS4jeWkseS4gOiIrOaAp++8jOiuvuafpeaJvuavj+S4quiusOW9leaIkOWKn+eahOamgueOh+ebuOetie+8jOWNs1BpPTEvbu+8m+afpeaJvuesrGnkuKrlhYPntKDmiJDlip/nmoTmr5TovoPmrKHmlbBDaT1uLWnvvJtcclxuIOKXhiDmn6Xmib7miJDlip/ml7bnmoTlubPlnYfmn6Xmib7plb/luqZBU0zvvJoobisxKS8yXHJcbiDil4Yg5YyF5ZCr5p+l5om+5LiN5oiQ5Yqf5pe277ya5p+l5om+5aSx6LSl55qE5q+U6L6D5qyh5pWw5Li6bu+8jOiLpeaIkOWKn+S4juS4jeaIkOWKn+eahOamgueOh+ebuOetie+8jOWvueavj+S4quiusOW9leeahOafpeaJvuamgueOh+S4ulBpPTEvKDJuKe+8jOWImeW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mjPvvIhuKzHvvIkvNFxyXG4gKi9cblxuZnVuY3Rpb24gc2VxdWVudGlhbFNlYXJjaChzVGFibGUsIGtleSkge1xuICBmb3IgKHZhciBpID0gc1RhYmxlLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiBzVGFibGVbaV0gIT09IGtleTsgLS1pKSB7fVxuICByZXR1cm4gaTtcbn1cblxuY29uc29sZS5sb2coc2VxdWVudGlhbFNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY291bnRTb3J0ID0gY291bnRTb3J0O1xuZXhwb3J0cy5yYWRpeFNvcnQgPSByYWRpeFNvcnQ7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKCcuLi9leGNoYW5nZS9pbmRleCcpO1xuXG4vKlxyXG4g6K6h5pWw5o6S5bqPXHJcblxyXG4g6K6h5pWw5o6S5bqP77yIQ291bnRpbmcgc29ydO+8ieaYr+S4gOenjeeos+WumueahOe6v+aAp+aXtumXtOaOkuW6j+eul+azleOAguiuoeaVsOaOkuW6j+S9v+eUqOS4gOS4qumineWklueahOaVsOe7hEPvvIzlhbbkuK3nrKxp5Liq5YWD57Sg5piv5b6F5o6S5bqP5pWw57uEQeS4reWAvOetieS6jmnnmoTlhYPntKDnmoTkuKrmlbDjgILnhLblkI7moLnmja7mlbDnu4RD5p2l5bCGQeS4reeahOWFg+e0oOaOkuWIsOato+ehrueahOS9jee9ruOAglxyXG5cclxuIOiuoeaVsOaOkuW6j+eahOeJueW+gVxyXG5cclxuIOW9k+i+k+WFpeeahOWFg+e0oOaYr27kuKow5Yiwa+S5i+mXtOeahOaVtOaVsOaXtu+8jOWug+eahOi/kOihjOaXtumXtOaYr86YKG4gKyBrKeOAguiuoeaVsOaOkuW6j+S4jeaYr+avlOi+g+aOkuW6j++8jOaOkuW6j+eahOmAn+W6puW/q+S6juS7u+S9leavlOi+g+aOkuW6j+eul+azleOAglxyXG4g55Sx5LqO55So5p2l6K6h5pWw55qE5pWw57uEQ+eahOmVv+W6puWPluWGs+S6juW+heaOkuW6j+aVsOe7hOS4reaVsOaNrueahOiMg+WbtO+8iOetieS6juW+heaOkuW6j+aVsOe7hOeahOacgOWkp+WAvOS4juacgOWwj+WAvOeahOW3ruWKoOS4ijHvvInvvIzov5nkvb/lvpforqHmlbDmjpLluo/lr7nkuo7mlbDmja7ojIPlm7TlvojlpKfnmoTmlbDnu4TvvIzpnIDopoHlpKfph4/ml7bpl7TlkozlhoXlrZjjgILkvovlpoLvvJrorqHmlbDmjpLluo/mmK/nlKjmnaXmjpLluo8w5YiwMTAw5LmL6Ze055qE5pWw5a2X55qE5pyA5aW955qE566X5rOV77yM5L2G5piv5a6D5LiN6YCC5ZCI5oyJ5a2X5q+N6aG65bqP5o6S5bqP5Lq65ZCN44CC5L2G5piv77yM6K6h5pWw5o6S5bqP5Y+v5Lul55So5Zyo5Z+65pWw5o6S5bqP5Lit55qE566X5rOV5p2l5o6S5bqP5pWw5o2u6IyD5Zu05b6I5aSn55qE5pWw57uE44CCXHJcbiDpgJrkv5flnLDnkIbop6PvvIzkvovlpoLmnIkxMOS4quW5tOm+hOS4jeWQjOeahOS6uu+8jOe7n+iuoeWHuuaciTjkuKrkurrnmoTlubTpvoTmr5RB5bCP77yM6YKjQeeahOW5tOm+hOWwseaOkuWcqOesrDnkvY3vvIznlKjov5nkuKrmlrnms5Xlj6/ku6XlvpfliLDlhbbku5bmr4/kuKrkurrnmoTkvY3nva7vvIzkuZ/lsLHmjpLlpb3kuobluo/jgILlvZPnhLbvvIzlubTpvoTmnInph43lpI3ml7bpnIDopoHnibnmrorlpITnkIbvvIjkv53or4HnqLPlrprmgKfvvInvvIzov5nlsLHmmK/kuLrku4DkuYjmnIDlkI7opoHlj43lkJHloavlhYXnm67moIfmlbDnu4TvvIzku6Xlj4rlsIbmr4/kuKrmlbDlrZfnmoTnu5/orqHlh4/ljrsx55qE5Y6f5Zug44CC566X5rOV55qE5q2l6aqk5aaC5LiL77yaXHJcbiAxLuaJvuWHuuW+heaOkuW6j+eahOaVsOe7hOS4reacgOWkp+WSjOacgOWwj+eahOWFg+e0oFxyXG4gMi7nu5/orqHmlbDnu4TkuK3mr4/kuKrlgLzkuLpp55qE5YWD57Sg5Ye6546w55qE5qyh5pWw77yM5a2Y5YWl5pWw57uEQ+eahOesrGnpoblcclxuIDMu5a+55omA5pyJ55qE6K6h5pWw57Sv5Yqg77yI5LuOQ+S4reeahOesrOS4gOS4quWFg+e0oOW8gOWni++8jOavj+S4gOmhueWSjOWJjeS4gOmhueebuOWKoO+8iVxyXG4gNC7lj43lkJHloavlhYXnm67moIfmlbDnu4TvvJrlsIbmr4/kuKrlhYPntKBp5pS+5Zyo5paw5pWw57uE55qE56ysQyhpKemhue+8jOavj+aUvuS4gOS4quWFg+e0oOWwseWwhkMoaSnlh4/ljrsxXHJcbiBcclxuIOeugOimgeWIhuaekO+8mlxyXG4gMS7orqHmlbDmjpLluo/ku4XpgILlkIjkuo7lsI/ojIPlm7TnmoTmlbDmja7ov5vooYzmjpLluo9cclxuIDIu5LiN6IO95a+55rWu54K55pWw6L+b6KGM5o6S5bqPXHJcbiAzLuaXtumXtOWkjeadguW6puS4uiBPKG4pXHJcbiA0LuiuoeaVsOaOkuW6j+aYr+eos+WumueahO+8iOaOkuW6j+WQjuWAvOebuOWQjOeahOWFg+e0oOebuOWvueS6juWOn+WFiOeahOS9jee9ruaYr+S4jeS8muWPkeeUn+WPmOWMlueahO+8iVxyXG4gKi9cblxuZnVuY3Rpb24gbWF4RWxlbShhcnIpIHtcbiAgICB2YXIgbWF4ID0gYXJyWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAobWF4IDwgYXJyW2ldKSBtYXggPSBhcnJbaV07XG4gICAgfXJldHVybiBtYXg7XG59XG5cbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcUxpc3Qg6KaB5o6S5bqP55qE5pWw57uEXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBrIOaVsOe7hOS4reacgOWkp+eahOWFg+e0oOWAvFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xuLyoqXHJcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMi8xOC5cclxuICovXG5cbmZ1bmN0aW9uIGNvdW50U29ydCgpIHtcbiAgICB2YXIgc3FMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGsgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBtYXhFbGVtKHNxTGlzdCkgOiBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICB2YXIgYyA9IFtdO1xuICAgIHZhciBiID0gW107XG5cbiAgICAvLyDliJ3lp4vljJbovoXliqnmlbDnu4RcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBrOyArK2kpIHtcbiAgICAgICAgY1tpXSA9IDA7XG4gICAgfSAvLyDorqHmlbDmlbDnu4RB5Lit5YC8562J5LqOQ+aVsOe7hOS4i+agh+eahOS4quaVsFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47ICsrX2kpIHtcbiAgICAgICAgY1tzcUxpc3RbX2ldXSsrO1xuICAgIH0gLy8g6K6h5pWw5pWw57uEQeS4reWAvOWwj+S6juetieS6jkPmlbDnu4TkuIvmoIfnmoTkuKrmlbBcbiAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPD0gazsgKytfaTIpIHtcbiAgICAgICAgY1tfaTJdICs9IGNbX2kyIC0gMV07XG4gICAgfWZvciAodmFyIF9pMyA9IGxlbiAtIDE7IF9pMyA+PSAwOyAtLV9pMykge1xuICAgICAgICBiW2Nbc3FMaXN0W19pM11dIC0gMV0gPSBzcUxpc3RbX2kzXTtcbiAgICAgICAgLS1jW3NxTGlzdFtfaTNdXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBsZW47ICsrX2k0KSB7XG4gICAgICAgIHNxTGlzdFtfaTRdID0gYltfaTRdO1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsxMDAsIDkzLCA5NywgOTIsIDk2LCA5OSwgOTIsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIsIDk1XTtcbmNvdW50U29ydChhcnIsIDEwMCk7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cbi8qXHJcbiDln7rmlbDmjpLluo9cclxuXHJcbiDln7rmlbDmjpLluo/vvIjoi7Hor63vvJpSYWRpeCBzb3J077yJ5piv5LiA56eN6Z2e5q+U6L6D5Z6L5pW05pWw5o6S5bqP566X5rOV77yM5YW25Y6f55CG5piv5bCG5pW05pWw5oyJ5L2N5pWw5YiH5Ymy5oiQ5LiN5ZCM55qE5pWw5a2X77yM54S25ZCO5oyJ5q+P5Liq5L2N5pWw5YiG5Yir5q+U6L6D44CC55Sx5LqO5pW05pWw5Lmf5Y+v5Lul6KGo6L6+5a2X56ym5Liy77yI5q+U5aaC5ZCN5a2X5oiW5pel5pyf77yJ5ZKM54m55a6a5qC85byP55qE5rWu54K55pWw77yM5omA5Lul5Z+65pWw5o6S5bqP5Lmf5LiN5piv5Y+q6IO95L2/55So5LqO5pW05pWw44CC5Z+65pWw5o6S5bqP55qE5Y+R5piO5Y+v5Lul6L+95rqv5YiwMTg4N+W5tOi1q+WwlOabvMK35L2V5LmQ56S85Zyo5omT5a2U5Y2h54mH5Yi26KGo5py677yIVGFidWxhdGlvbiBNYWNoaW5l77yJ5LiK55qE6LSh54yu44CCXHJcbiDlroPmmK/ov5nmoLflrp7njrDnmoTvvJrlsIbmiYDmnInlvoXmr5TovoPmlbDlgLzvvIjmraPmlbTmlbDvvInnu5/kuIDkuLrlkIzmoLfnmoTmlbDkvY3plb/luqbvvIzmlbDkvY3ovoPnn63nmoTmlbDliY3pnaLooaXpm7bjgILnhLblkI7vvIzku47mnIDkvY7kvY3lvIDlp4vvvIzkvp3mrKHov5vooYzkuIDmrKHmjpLluo/jgILov5nmoLfku47mnIDkvY7kvY3mjpLluo/kuIDnm7TliLDmnIDpq5jkvY3mjpLluo/lrozmiJDku6XlkI7vvIzmlbDliJflsLHlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcclxuIOWfuuaVsOaOkuW6j+eahOaWueW8j+WPr+S7pemHh+eUqExTRO+8iExlYXN0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInmiJZNU0TvvIhNb3N0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInvvIxMU0TnmoTmjpLluo/mlrnlvI/nlLHplK7lgLznmoTmnIDlj7PovrnlvIDlp4vvvIzogIxNU0TliJnnm7jlj43vvIznlLHplK7lgLznmoTmnIDlt6bovrnlvIDlp4vjgIJcclxuXHJcbiDmlYjnjodcclxuXHJcbiDln7rmlbDmjpLluo/nmoTml7bpl7TlpI3mnYLluqbmmK9PKGvCt24p77yM5YW25LitbuaYr+aOkuW6j+WFg+e0oOS4quaVsO+8jGvmmK/mlbDlrZfkvY3mlbDjgILms6jmhI/ov5nkuI3mmK/or7Tov5nkuKrml7bpl7TlpI3mnYLluqbkuIDlrprkvJjkuo5PKG7Ct2xvZyhuKSnvvIxr55qE5aSn5bCP5Y+W5Yaz5LqO5pWw5a2X5L2N55qE6YCJ5oup77yI5q+U5aaC5q+U54m55L2N5pWw77yJ77yM5ZKM5b6F5o6S5bqP5pWw5o2u5omA5bGe5pWw5o2u57G75Z6L55qE5YWo6ZuG55qE5aSn5bCP77yba+WGs+WumuS6hui/m+ihjOWkmuWwkei9ruWkhOeQhu+8jOiAjG7mmK/mr4/ova7lpITnkIbnmoTmk43kvZzmlbDnm67jgIJcclxuIOS7peaOkuW6j27kuKrkuI3lkIzmlbTmlbDmnaXkuL7kvovvvIzlgYflrprov5nkupvmlbTmlbDku6VC5Li65bqV77yM6L+Z5qC35q+P5L2N5pWw6YO95pyJQuS4quS4jeWQjOeahOaVsOWtl++8jGsgPSBsb2dCKE4p77yMTuaYr+W+heaOkuW6j+aVsOaNruexu+Wei+WFqOmbhueahOWKv+OAguiZveeEtuaciULkuKrkuI3lkIznmoTmlbDlrZfvvIzpnIDopoFC5Liq5LiN5ZCM55qE5qG277yM5L2G5Zyo5q+P5LiA6L2u5aSE55CG5Lit77yM5Yik5pat5q+P5Liq5b6F5o6S5bqP5pWw5o2u6aG55Y+q6ZyA6KaB5LiA5qyh6K6h566X56Gu5a6a5a+55bqU5pWw5L2N55qE5YC877yM5Zug5q2k5Zyo5q+P5LiA6L2u5aSE55CG55qE5pe25YCZ6YO96ZyA6KaB5bmz5Z2HbuasoeaTjeS9nOadpeaKiuaVtOaVsOaUvuWIsOWQiOmAgueahOahtuS4reWOu++8jOaJgOS7peWwseacie+8mlxyXG4ga+e6puetieS6jmxvZ0IoTilcclxuIOaJgOS7pe+8jOWfuuaVsOaOkuW6j+eahOW5s+Wdh+aXtumXtFTlsLHmmK/vvJpcclxuIFTvvZ49IGxvZ0IoTinCt25cclxuIOWFtuS4reWJjeS4gOmhueaYr+S4gOS4quS4jui+k+WFpeaVsOaNruaXoOWFs+eahOW4uOaVsO+8jOW9k+eEtuivpemhueS4jeS4gOWumuWwj+S6jmxvZ25cclxuIOWmguaenOiAg+iZkeWSjOavlOi+g+aOkuW6j+i/m+ihjOWvueeFp++8jOWfuuaVsOaOkuW6j+eahOW9ouW8j+WkjeadguW6puiZveeEtuS4jeS4gOWumuabtOWwj++8jOS9hueUseS6juS4jei/m+ihjOavlOi+g++8jOWboOatpOWFtuWfuuacrOaTjeS9nOeahOS7o+S7t+i+g+Wwj++8jOiAjOS4lOWcqOmAguW9k+mAieaLqeeahELkuYvkuIvvvIxr5LiA6Iis5LiN5aSn5LqObG9nbu+8jOaJgOS7peWfuuaVsOaOkuW6j+S4gOiIrOimgeW/q+i/h+WfuuS6juavlOi+g+eahOaOkuW6j++8jOavlOWmguW/q+mAn+aOkuW6j+OAglxyXG5cclxuIOWBh+iuvuaIkeS7rOacieS4gOS6m+S6jOWFg+e7hChhLGIp77yM6KaB5a+55a6D5Lus6L+b6KGM5LulYeS4uummluimgeWFs+mUruWtl++8jGLnmoTmrKHopoHlhbPplK7lrZfnmoTmjpLluo/jgILmiJHku6zlj6/ku6XlhYjmiorlroPku6zlhYjmjInnhafpppbopoHlhbPplK7lrZfmjpLluo/vvIzliIbmiJDpppbopoHlhbPplK7lrZfnm7jlkIznmoToi6XlubLloIbjgILnhLblkI7vvIzlnKjmjInnhafmrKHopoHlhbPplK7lgLzliIbliKvlr7nmr4/kuIDloIbov5vooYzljZXni6zmjpLluo/jgILmnIDlkI7lho3miorov5nkupvloIbkuLLov57liLDkuIDotbfvvIzkvb/pppbopoHlhbPplK7lrZfovoPlsI/nmoTkuIDloIbmjpLlnKjkuIrpnaLjgILmjInov5nnp43mlrnlvI/nmoTln7rmlbDmjpLluo/np7DkuLpNU0QoTW9zdCBTaWduaWZpY2FudCBEaWdodCnmjpLluo/jgILnrKzkuoznp43mlrnlvI/mmK/ku47mnIDkvY7mnInmlYjlhbPplK7lrZflvIDlp4vmjpLluo/vvIznp7DkuLpMU0QoTGVhc3QgU2lnbmlmaWNhbnQgRGlnaHQp5o6S5bqP44CC6aaW5YWI5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn5qyh6KaB5YWz6ZSu5a2X5o6S5bqP77yM54S25ZCO5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn6aaW6KaB5YWz6ZSu5a2X5o6S5bqP44CC6KaB5rOo5oSP55qE5piv77yM5L2/55So55qE5o6S5bqP566X5rOV5b+F6aG75piv56iz5a6a55qE77yM5ZCm5YiZ5bCx5Lya5Y+W5raI5YmN5LiA5qyh5o6S5bqP55qE57uT5p6c44CC55Sx5LqO5LiN6ZyA6KaB5YiG5aCG5a+55q+P5aCG5Y2V54us5o6S5bqP77yMTFNE5pa55rOV5b6A5b6A5q+UTVNE566A5Y2V6ICM5byA6ZSA5bCP44CC5LiL5paH5LuL57uN55qE5pa55rOV5YWo6YOo5piv5Z+65LqOTFNE55qE44CCXHJcblxyXG4g5Z+65pWw5o6S5bqP55qE566A5Y2V5o+P6L+w5bCx5piv5bCG5pWw5a2X5ouG5YiG5Li65Liq5L2N5Y2B5L2N55m+5L2N77yM5q+P5Liq5L2N5L6d5qyh5o6S5bqP44CC5Zug5Li66L+Z5a+5566X5rOV56iz5a6a6KaB5rGC6auY77yM5omA5Lul5oiR5Lus5a+55pWw5L2N5o6S5bqP55So5Yiw5LiK5LiA5Liq5o6S5bqP5pa55rOV6K6h5pWw5o6S5bqP44CC5Zug5Li65Z+65pWw5o6S5bqP6KaB57uP6L+HZCAo5pWw5o2u6ZW/5bqmKeasoeaOkuW6j++8jCDmr4/mrKHkvb/nlKjorqHmlbDmjpLluo/vvIwg6K6h5pWw5o6S5bqP55qE5aSN5p2C5bqm5Li6IE9uKSwgIGQg55u45b2T5LqO5bi46YeP5ZKMTuaXoOWFs++8jOaJgOS7peWfuuaVsOaOkuW6j+S5n+aYryBPKG4p44CC5Z+65pWw5o6S5bqP6Jm954S25piv57q/5oCn5aSN5p2C5bqm77yMIOWNs+WvuW7kuKrmlbDlrZflpITnkIbkuoZu5qyh77yM5L2G5piv5q+P5LiA5qyh5Luj5Lu36YO95q+U6L6D6auY77yMIOiAjOS4lOS9v+eUqOiuoeaVsOaOkuW6j+eahOWfuuaVsOaOkuW6j+S4jeiDvei/m+ihjOWOn+WcsOaOkuW6j++8jOmcgOimgeabtOWkmueahOWGheWtmO+8jCDlubbkuJTlv6vpgJ/mjpLluo/lj6/og73mm7Tlpb3lnLDliKnnlKjnoazku7bnmoTnvJPlrZjvvIwg5omA5Lul5q+U6L6D6LW35p2l77yM5YOP5b+r6YCf5o6S5bqP6L+Z5Lqb5Y6f5Zyw5o6S5bqP566X5rOV5pu05Y+v5Y+W44CC5a+55LqO5LiA5Liq5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw77yM5oiR5Lus5Y+v5Lul5oqK5a6D55yL5L2c5LiA5Liq5aSa5YWD57uE77yM5LuO6auY5L2N5Yiw5L2O5L2N5YWz6ZSu5a2X6YeN6KaB56iL5bqm5L6d5qyh6YCS5YeP44CC5Y+v5Lul5L2/55So5Z+65pWw5o6S5bqP5a+55LiA5Lqb5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw5o6S5bqP44CCXHJcbiAqL1xuXG4vLyDmsYLmlbDmja7nmoTmnIDlpKfkvY3mlbBcbmZ1bmN0aW9uIG1heEJpdChhcnIpIHtcbiAgICB2YXIgZCA9IDE7XG4gICAgdmFyIHAgPSAxMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJyLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB3aGlsZSAoYXJyW2ldID49IHApIHtcbiAgICAgICAgICAgIHAgKj0gMTA7XG4gICAgICAgICAgICArK2Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn1cblxuZnVuY3Rpb24gcmFkaXhTb3J0KCkge1xuICAgIHZhciBhcnIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG1heEJpdChhcnIpIDogYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciB0ZW1wID0gW107XG4gICAgLy8g6K6h5pWw5ZmoXG4gICAgdmFyIGNvdW50ID0gW107XG4gICAgdmFyIHJhZGl4ID0gMTtcblxuICAgIC8vIOi/m+ihjGTmrKHmjpLluo9cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkOyArK2kpIHtcbiAgICAgICAgLy8g5q+P5qyh5YiG6YWN5YmN5riF56m66K6h5pWw5ZmoXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTA7ICsraikge1xuICAgICAgICAgICAgY291bnRbal0gPSAwO1xuICAgICAgICB9IC8vIOe7n+iuoeavj+S4quahtuS4reeahOiusOW9leaVsFxuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgKytfaikge1xuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKGFycltfal0gLyByYWRpeCkgJSAxMDtcbiAgICAgICAgICAgICsrY291bnRba107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMTsgX2oyIDwgMTA7ICsrX2oyKSB7XG4gICAgICAgICAgICBjb3VudFtfajJdICs9IGNvdW50W19qMiAtIDFdO1xuICAgICAgICB9IC8vIOWwhuaJgOacieahtuS4reiusOW9leS+neasoeaUtumbhuWIsHRtcOS4rVxuICAgICAgICBmb3IgKHZhciBfajMgPSBuIC0gMTsgX2ozID49IDA7IC0tX2ozKSB7XG4gICAgICAgICAgICB2YXIgX2sgPSBNYXRoLmZsb29yKGFycltfajNdIC8gcmFkaXgpICUgMTA7XG4gICAgICAgICAgICB0ZW1wWy0tY291bnRbX2tdXSA9IGFycltfajNdO1xuICAgICAgICB9XG4gICAgICAgIC8v5bCG5Li05pe25pWw57uE55qE5YaF5a655aSN5Yi25YiwYXJy5LitXG4gICAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IG47ICsrX2o0KSB7XG4gICAgICAgICAgICBhcnJbX2o0XSA9IHRlbXBbX2o0XTtcbiAgICAgICAgfXJhZGl4ICo9IDEwO1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsxMDAsIDkzLCA5NywgOTIsIDk2LCA5OSwgOTIsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIsIDk1XTtcbnJhZGl4U29ydChhcnIsIDEwMCk7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cbi8qXHJcbiDmobbmjpLluo9cclxuXHJcbiDmobbmjpLluo/vvIhCdWNrZXQgc29ydO+8ieaIluaJgOiwk+eahOeuseaOkuW6j++8jOaYr+S4gOS4quaOkuW6j+eul+azle+8jOW3peS9nOeahOWOn+eQhuaYr+WwhuaVsOe7hOWIhuWIsOaciemZkOaVsOmHj+eahOahtuWtkOmHjOOAguavj+S4quahtuWtkOWGjeS4quWIq+aOkuW6j++8iOacieWPr+iDveWGjeS9v+eUqOWIq+eahOaOkuW6j+eul+azleaIluaYr+S7pemAkuW9kuaWueW8j+e7p+e7reS9v+eUqOahtuaOkuW6j+i/m+ihjOaOkuW6j++8ieOAguahtuaOkuW6j+aYr+m4veW3ouaOkuW6j+eahOS4gOenjeW9kue6s+e7k+aenOOAguW9k+imgeiiq+aOkuW6j+eahOaVsOe7hOWGheeahOaVsOWAvOaYr+Wdh+WMgOWIhumFjeeahOaXtuWAme+8jOahtuaOkuW6j+S9v+eUqOe6v+aAp+aXtumXtO+8iM6YKG4p77yJ44CC5L2G5qG25o6S5bqP5bm25LiN5piv5q+U6L6D5o6S5bqP77yM5LuW5LiN5Y+X5YiwTyhuIGxvZyBuKeS4i+mZkOeahOW9seWTjeOAglxyXG5cclxuIOWfuuacrOaAneaDs1xyXG5cclxuIOWBh+iuvuacieS4gOe7hOmVv+W6puS4uk7nmoTlvoXmjpLlhbPplK7lrZfluo/liJdLWzEuLi4ubl3jgILpppblhYjlsIbov5nkuKrluo/liJfliJLliIbmiJBN5Liq55qE5a2Q5Yy66Ze0KOahtikg44CC54S25ZCO5Z+65LqO5p+Q56eN5pig5bCE5Ye95pWwIO+8jOWwhuW+heaOkuW6j+WIl+eahOWFs+mUruWtl2vmmKDlsITliLDnrKxp5Liq5qG25LitKOWNs+ahtuaVsOe7hELnmoTkuIvmoIcgaSkg77yM6YKj5LmI6K+l5YWz6ZSu5a2Xa+WwseS9nOS4ukJbaV3kuK3nmoTlhYPntKAo5q+P5Liq5qG2QltpXemDveaYr+S4gOe7hOWkp+Wwj+S4uk4vTeeahOW6j+WIlynjgILmjqXnnYDlr7nmr4/kuKrmobZCW2ld5Lit55qE5omA5pyJ5YWD57Sg6L+b6KGM5q+U6L6D5o6S5bqPKOWPr+S7peS9v+eUqOW/q+aOkinjgILnhLblkI7kvp3mrKHmnprkuL7ovpPlh7pCWzBdLi4uLkJbTV3kuK3nmoTlhajpg6jlhoXlrrnljbPmmK/kuIDkuKrmnInluo/luo/liJfjgIJcclxuIOWBh+WmguW+heaOkuW6j+WIl0s9IHs0OeOAgSAzOCDjgIEgMzXjgIEgOTcg44CBIDc244CBIDczIOOAgSAyN+OAgSA0OSB944CC6L+Z5Lqb5pWw5o2u5YWo6YOo5ZyoMeKAlDEwMOS5i+mXtOOAguWboOatpOaIkeS7rOWumuWItjEw5Liq5qG277yM54S25ZCO56Gu5a6a5pig5bCE5Ye95pWwZihrKT1rLzEw44CC5YiZ56ys5LiA5Liq5YWz6ZSu5a2XNDnlsIblrprkvY3liLDnrKw05Liq5qG25LitKDQ5LzEwPTQp44CC5L6d5qyh5bCG5omA5pyJ5YWz6ZSu5a2X5YWo6YOo5aCG5YWl5qG25Lit77yM5bm25Zyo5q+P5Liq6Z2e56m655qE5qG25Lit6L+b6KGM5b+r6YCf5o6S5bqP44CCXHJcblxyXG4g5YiG5p6QXHJcblxyXG4g5qG25o6S5bqP5Yip55So5Ye95pWw55qE5pig5bCE5YWz57O777yM5YeP5bCR5LqG5Yeg5LmO5omA5pyJ55qE5q+U6L6D5bel5L2c44CC5a6e6ZmF5LiK77yM5qG25o6S5bqP55qEZihrKeWAvOeahOiuoeeul++8jOWFtuS9nOeUqOWwseebuOW9k+S6juW/q+aOkuS4reWIkuWIhu+8jOW3sue7j+aKiuWkp+mHj+aVsOaNruWIhuWJsuaIkOS6huWfuuacrOacieW6j+eahOaVsOaNruWdlyjmobYp44CC54S25ZCO5Y+q6ZyA6KaB5a+55qG25Lit55qE5bCR6YeP5pWw5o2u5YGa5YWI6L+b55qE5q+U6L6D5o6S5bqP5Y2z5Y+v44CCXHJcbiDlr7lO5Liq5YWz6ZSu5a2X6L+b6KGM5qG25o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5YiG5Li65Lik5Liq6YOo5YiG77yaXHJcbiAgICAgKDEpIOW+queOr+iuoeeul+avj+S4quWFs+mUruWtl+eahOahtuaYoOWwhOWHveaVsO+8jOi/meS4quaXtumXtOWkjeadguW6puaYr08oTinjgIJcclxuICAgICAoMikg5Yip55So5YWI6L+b55qE5q+U6L6D5o6S5bqP566X5rOV5a+55q+P5Liq5qG25YaF55qE5omA5pyJ5pWw5o2u6L+b6KGM5o6S5bqP77yM5YW25pe26Ze05aSN5p2C5bqm5Li6IOKIkSBPKE5pKmxvZ05pKSDjgILlhbbkuK1OaSDkuLrnrKxp5Liq5qG255qE5pWw5o2u6YeP44CCXHJcbiDlvojmmL7nhLbvvIznrKwoMinpg6jliIbmmK/mobbmjpLluo/mgKfog73lpb3lnY/nmoTlhrPlrprlm6DntKDjgILlsL3ph4/lh4/lsJHmobblhoXmlbDmja7nmoTmlbDph4/mmK/mj5Dpq5jmlYjnjofnmoTllK/kuIDlip7ms5Uo5Zug5Li65Z+65LqO5q+U6L6D5o6S5bqP55qE5pyA5aW95bmz5Z2H5pe26Ze05aSN5p2C5bqm5Y+q6IO96L6+5YiwTyhOKmxvZ04p5LqGKeOAguWboOatpO+8jOaIkeS7rOmcgOimgeWwvemHj+WBmuWIsOS4i+mdouS4pOeCue+8mlxyXG4gICAgICgxKSDmmKDlsITlh73mlbBmKGsp6IO95aSf5bCGTuS4quaVsOaNruW5s+Wdh+eahOWIhumFjeWIsE3kuKrmobbkuK3vvIzov5nmoLfmr4/kuKrmobblsLHmnIlbTi9NXeS4quaVsOaNrumHj+OAglxyXG4gICAgICgyKSDlsL3ph4/nmoTlop7lpKfmobbnmoTmlbDph4/jgILmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rog73lvpfliLDkuIDkuKrmlbDmja7vvIzov5nmoLflsLHlrozlhajpgb/lvIDkuobmobblhoXmlbDmja7nmoTigJzmr5TovoPigJ3mjpLluo/mk43kvZzjgIIg5b2T54S277yM5YGa5Yiw6L+Z5LiA54K55b6I5LiN5a655piT77yM5pWw5o2u6YeP5beo5aSn55qE5oOF5Ya15LiL77yMZihrKeWHveaVsOS8muS9v+W+l+ahtumbhuWQiOeahOaVsOmHj+W3qOWkp++8jOepuumXtOa1qui0ueS4pemHjeOAgui/meWwseaYr+S4gOS4quaXtumXtOS7o+S7t+WSjOepuumXtOS7o+S7t+eahOadg+ihoemXrumimOS6huOAglxyXG5cclxuIOWvueS6jk7kuKrlvoXmjpLmlbDmja7vvIxN5Liq5qG277yM5bmz5Z2H5q+P5Liq5qG2W04vTV3kuKrmlbDmja7nmoTmobbmjpLluo/lubPlnYfml7bpl7TlpI3mnYLluqbkuLrvvJpcclxuIE8oTikrTyhNKihOL00pKmxvZyhOL00pKT1PKE4rTioobG9nTi1sb2dNKSk9TyhOK04qbG9nTi1OKmxvZ00pXHJcbiDlvZNOPU3ml7bvvIzljbPmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rmnInkuIDkuKrmlbDmja7ml7bjgILmobbmjpLluo/nmoTmnIDlpb3mlYjnjofog73lpJ/ovr7liLBPKE4p44CCXHJcblxyXG4g5oC757uT77yaIOahtuaOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puS4uue6v+aAp+eahE8oTitDKe+8jOWFtuS4rUM9TioobG9nTi1sb2dNKeOAguWmguaenOebuOWvueS6juWQjOagt+eahE7vvIzmobbmlbDph49N6LaK5aSn77yM5YW25pWI546H6LaK6auY77yM5pyA5aW955qE5pe26Ze05aSN5p2C5bqm6L6+5YiwTyhOKeOAgiDlvZPnhLbmobbmjpLluo/nmoTnqbrpl7TlpI3mnYLluqYg5Li6TyhOK00p77yM5aaC5p6c6L6T5YWl5pWw5o2u6Z2e5bi45bqe5aSn77yM6ICM5qG255qE5pWw6YeP5Lmf6Z2e5bi45aSa77yM5YiZ56m66Ze05Luj5Lu35peg55aR5piv5piC6LS155qE44CC5q2k5aSW77yM5qG25o6S5bqP5piv56iz5a6a55qE44CCXHJcbiAqL1xuXG52YXIgQlVDS0VUU05VTSA9IDEwO1xuXG5mdW5jdGlvbiBidWNrZXRTb3J0KHNxTGlzdCkge1xuICAgIHZhciBuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICB2YXIgYnVja2V0QSA9IFtdO1xuICAgIHZhciBiID0gW107XG5cbiAgICAvLyDliJ3lp4vljJbmobZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSkge1xuICAgICAgICBiW2ldID0gW107XG4gICAgICAgIGJ1Y2tldEFbaV0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBiW2ldW2pdID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDnu5nmobbloavoo4XmlbDmja5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBuOyArK19pNSkge1xuICAgICAgICB2YXIgZGF0YSA9IHNxTGlzdFtfaTVdO1xuICAgICAgICAvLyBub3RvOiDov5nph4znmoTmmKDlsITlh73mlbDmmK/pkojlr7kxLTEwMOS5i+mXtOeahOWunuaVsFxuICAgICAgICB2YXIgYnVja2V0ID0gTWF0aC5mbG9vcihkYXRhIC8gQlVDS0VUU05VTSk7XG4gICAgICAgIGJbYnVja2V0XVtidWNrZXRBW2J1Y2tldF1dID0gZGF0YTtcbiAgICAgICAgKytidWNrZXRBW2J1Y2tldF07XG4gICAgfVxuXG4gICAgLy8g6ZKI5a+55q+P5Liq5qG26L+b6KGM5b+r6YCf5o6S5bqPXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgQlVDS0VUU05VTTsgKytfaTYpIHtcbiAgICAgICAgaWYgKGJ1Y2tldEFbX2k2XSAhPT0gMCkge1xuICAgICAgICAgICAgKDAsIF9pbmRleC5xdWlja1NvcnQpKGJbX2k2XSwgMCwgYnVja2V0QVtfaTZdIC0gMSk7XG4gICAgICAgICAgICAvL2ZvcihsZXQgaiA9IDE7IGogPCBidWNrZXRBW2ldOyArK2ope1xuICAgICAgICAgICAgLy8gICAgbGV0IHAgPSBiW2ldW2pdO1xuICAgICAgICAgICAgLy8gICAgbGV0IGs7XG4gICAgICAgICAgICAvLyAgICBmb3IoayA9IGogLSAxOyBrID49IDAgJiYgcCA8IGJbaV1ba107IC0tayl7XG4gICAgICAgICAgICAvLyAgICAgICAgYltpXVtrICsgMV0gPSBiW2ldW2tdO1xuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gICAgYltpXVtrICsgMV0gPSBwO1xuICAgICAgICAgICAgLy99XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKGIpO1xuICAgIC8vY29uc29sZS5sb2coYnVja2V0QSk7XG5cbiAgICAvLyDlpI3liLblm57ljrtcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBCVUNLRVRTTlVNOyArK19pNykge1xuICAgICAgICBpZiAoYnVja2V0QVtfaTddICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBidWNrZXRBW19pN107ICsrX2o1KSB7XG4gICAgICAgICAgICAgICAgc3FMaXN0W251bSsrXSA9IGJbX2k3XVtfajVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5idWNrZXRTb3J0ID0gYnVja2V0U29ydDtcblxudmFyIGFyciA9IFs1MS4yLCA5MywgMSwgOTIuMiwgOCwgOTkuNSwgOTIuMCwgODksIDkzLCA5NywgOTAsIDk0LCA5Mi4xLCA5NV07XG5idWNrZXRTb3J0KGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cbnZhciBhcnIgPSBbNTEuMiwgOTMsIDEsIDkyLjIsIDgsIDk5LjUsIDkyLjAsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIuMSwgOTUsIEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldO1xuKDAsIF9pbmRleC5xdWlja1NvcnQpKGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cbi8qXHJcbiDmgKfog73liIbmnpBcclxuIOW+iOaYjuaYvu+8jOWfuuaVsOaOkuW6j+eahOaAp+iDveavlOahtuaOkuW6j+imgeeVpeW3ruOAguavj+S4gOasoeWFs+mUruWtl+eahOahtuWIhumFjemDvemcgOimgU8oTinnmoTml7bpl7TlpI3mnYLluqbvvIzogIzkuJTliIbphY3kuYvlkI7lvpfliLDmlrDnmoTlhbPplK7lrZfluo/liJflj4jpnIDopoFPKE4p55qE5pe26Ze05aSN5p2C5bqm44CC5YGH5aaC5b6F5o6S5pWw5o2u5Y+v5Lul5YiG5Li6ZOS4quWFs+mUruWtl++8jOWImeWfuuaVsOaOkuW6j+eahOaXtumXtOWkjeadguW6puWwhuaYr08oZCoyTikg77yM5b2T54S2ZOimgei/nOi/nOWwj+S6jk7vvIzlm6DmraTln7rmnKzkuIrov5jmmK/nur/mgKfnuqfliKvnmoTjgILln7rmlbDmjpLluo/nmoTnqbrpl7TlpI3mnYLluqbkuLpPKE4rTSnvvIzlhbbkuK1N5Li65qG255qE5pWw6YeP44CC5LiA6Iis5p2l6K+0Tj4+Te+8jOWboOatpOmineWkluepuumXtOmcgOimgeWkp+amgk7kuKrlt6blj7PjgIJcclxuIOS9huaYr++8jOWvueavlOahtuaOkuW6j++8jOWfuuaVsOaOkuW6j+avj+asoemcgOimgeeahOahtueahOaVsOmHj+W5tuS4jeWkmuOAguiAjOS4lOWfuuaVsOaOkuW6j+WHoOS5juS4jemcgOimgeS7u+S9leKAnOavlOi+g+KAneaTjeS9nO+8jOiAjOahtuaOkuW6j+WcqOahtuebuOWvuei+g+WwkeeahOaDheWGteS4i++8jOahtuWGheWkmuS4quaVsOaNruW/hemhu+i/m+ihjOWfuuS6juavlOi+g+aTjeS9nOeahOaOkuW6j+OAguWboOatpO+8jOWcqOWunumZheW6lOeUqOS4re+8jOWfuuaVsOaOkuW6j+eahOW6lOeUqOiMg+WbtOabtOWKoOW5v+azm+OAglxyXG4gKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NvcnQvZGlzdHJpYnV0aW9uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyYWlnaHRJbnNlcnRTb3J0ID0gc3RyYWlnaHRJbnNlcnRTb3J0O1xuZXhwb3J0cy5iaW5hcnlJbnNlcnRTb3J0ID0gYmluYXJ5SW5zZXJ0U29ydDtcbmV4cG9ydHMucGF0aDJJbnNlcnRTb3J0ID0gcGF0aDJJbnNlcnRTb3J0O1xuZXhwb3J0cy5zdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydCA9IHN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0O1xuZXhwb3J0cy5zaGVsbFNvcnQgPSBzaGVsbFNvcnQ7XG5cbnZhciBfU3RhdGljTGlua2VkTGlzdCA9IHJlcXVpcmUoJy4uLy4uL0xpc3QvU3RhdGljTGlua2VkTGlzdCcpO1xuXG52YXIgX1N0YXRpY0xpbmtlZExpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RhdGljTGlua2VkTGlzdCk7XG5cbnZhciBfZGVmYXVsdENvbXBhcmlzaW9uID0gcmVxdWlyZSgnLi4vZGVmYXVsdENvbXBhcmlzaW9uJyk7XG5cbnZhciBfZGVmYXVsdENvbXBhcmlzaW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRDb21wYXJpc2lvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qXHJcbiDmj5LlhaXmjpLluo9cclxuXHJcbiDph4fnlKjnmoTmmK/ku6Ug4oCc546p5qGl54mM6ICF4oCd55qE5pa55rOV5Li65Z+656GA55qE44CC5Y2z5Zyo6ICD5a+f6K6w5b2VUmnkuYvliY3vvIzorr7ku6XliY3nmoTmiYDmnInorrDlvZVSMSwgUjIgLOKApi4sIFJpLTHlt7LmjpLlpb3luo/vvIznhLblkI7lsIZSaeaPkuWFpeWIsOW3suaOkuWlveW6j+eahOivuOiusOW9leeahOmAguW9k+S9jee9rlxyXG5cclxuIOacgOWfuuacrOeahOaPkuWFpeaOkuW6j+aYr+ebtOaOpeaPkuWFpeaOkuW6jyhTdHJhaWdodCBJbnNlcnRpb24gU29ydCkg44CCXHJcblxyXG5cclxuIOebtOaOpeaPkuWFpeaOkuW6j1xyXG5cclxuIDEgIOaOkuW6j+aAneaDs1xyXG4g5bCG5b6F5o6S5bqP55qE6K6w5b2VUmnvvIzmj5LlhaXliLDlt7LmjpLlpb3luo/nmoTorrDlvZXooahSMSwgUjIgLOKApi4sIFJpLTHkuK3vvIzlvpfliLDkuIDkuKrmlrDnmoTjgIHorrDlvZXmlbDlop7liqAx55qE5pyJ5bqP6KGo44CCIOebtOWIsOaJgOacieeahOiusOW9lemDveaPkuWFpeWujOS4uuatouOAglxyXG4g6K6+5b6F5o6S5bqP55qE6K6w5b2V6aG65bqP5a2Y5pS+5Zyo5pWw57uEUlsx4oCmbl3kuK3vvIzlnKjmjpLluo/nmoTmn5DkuIDml7bliLvvvIzlsIborrDlvZXluo/liJfliIbmiJDkuKTpg6jliIbvvJpcclxuIOKXhiBSWzHigKZpLTFd77ya5bey5o6S5aW95bqP55qE5pyJ5bqP6YOo5YiG77ybXHJcbiDil4YgUltp4oCmbl3vvJrmnKrmjpLlpb3luo/nmoTml6Dluo/pg6jliIbjgIJcclxuIOaYvueEtu+8jOWcqOWImuW8gOWni+aOkuW6j+aXtu+8jFJbMV3mmK/lt7Lnu4/mjpLlpb3luo/nmoTjgIJcclxuXHJcbiAyLueul+azleWunueOsFxyXG5cclxuIDMu566X5rOV5YiG5p6QXHJcbiDikbQg5pyA5aW95oOF5Ya177ya6Iul5b6F5o6S5bqP6K6w5b2V5oyJ5YWz6ZSu5a2X5LuO5bCP5Yiw5aSn5o6S5YiXKOato+W6jynvvIznrpfms5XkuK3nmoTlhoXlvqrnjq/ml6DpobvmiafooYzvvIzliJnkuIDotp/mjpLluo/ml7bvvJrlhbPplK7lrZfmr5TovoPmrKHmlbAx5qyh77yM6K6w5b2V56e75Yqo5qyh5pWwMuasoShSW2ld4oaSUlswXSwgUlswXeKGklJbaisxXSnjgIJcclxuIOWImeaVtOS4quaOkuW6j+eahOWFs+mUruWtl+avlOi+g+asoeaVsOWSjOiusOW9leenu+WKqOasoeaVsOWIhuWIq+aYr++8mlxyXG4g5q+U6L6D5qyh5pWw77yabiAtIDEgICAgICAgICAg56e75Yqo5qyh5pWw77yaIDIgKiAobiAtIDEpXHJcblxyXG4g4pG1IOacgOWdj+aDheWGte+8muiLpeW+heaOkuW6j+iusOW9leaMieWFs+mUruWtl+S7juWkp+WIsOWwj+aOkuWIlyjpgIbluo8p77yM5YiZ5LiA6Laf5o6S5bqP5pe277ya566X5rOV5Lit55qE5YaF5b6q546v5L2T5omn6KGMaS0x77yM5YWz6ZSu5a2X5q+U6L6D5qyh5pWwaeasoe+8jOiusOW9leenu+WKqOasoeaVsGkrMeOAglxyXG4g5YiZ5bCx5pW05Liq5o6S5bqP6ICM6KiA77yaXHJcbiDmr5TovoPmrKHmlbDvvJogKG4gLSAxKSAqIChuICsgMSkgLyAyICAgICDnp7vliqjmrKHmlbA6IChuIC0gMSkgKiAobiArIDQpIC8gMlxyXG5cclxuIOS4gOiIrOWcsO+8jOiupOS4uuW+heaOkuW6j+eahOiusOW9leWPr+iDveWHuueOsOeahOWQhOenjeaOkuWIl+eahOamgueOh+ebuOWQjO+8jOWImeWPluS7peS4iuS4pOenjeaDheWGteeahOW5s+Wdh+WAvO+8jOS9nOS4uuaOkuW6j+eahOWFs+mUruWtl+avlOi+g+asoeaVsOWSjOiusOW9leenu+WKqOasoeaVsO+8jOe6puS4um4yLzTvvIzliJnlpI3mnYLluqbkuLpPKG4yKSDjgIJcclxuXHJcblxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMi5cclxuICovXG5cbmZ1bmN0aW9uIHN0cmFpZ2h0SW5zZXJ0U29ydChzcUxpc3QpIHtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbMV07XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIOiuvue9ruWTqOWFtSwg5b2T6K6+572uc3FMaXN0Wy0xXSA9IHNxTGlzdFtpXeaXtu+8jOe7j+a1i+ivleaViOeOh+abtOaFolxuICAgICAgICAvLyDlm6DkuLpqc+mHjOmdoueahOWPmOmHj+S9nOeUqOWfn+WcqOWHveaVsOWGheeahFxuICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgLy8g5p+l5om+5o+S5YWl5L2N572u77yM5bm25bCG6K6w5b2V5ZCO56e7XG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIGZvciAoOyBqID49IDAgJiYgY29tcCh0ZW1wLCBzcUxpc3Rbal0pIDwgMDsgLS1qKSB7XG4gICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gc3FMaXN0W2pdO1xuICAgICAgICB9IC8vIOaPkuWFpeWIsOato+ehruS9jee9rlxuICAgICAgICBzcUxpc3RbaiArIDFdID0gdGVtcDtcbiAgICB9XG59XG5cbnZhciBhID0gWzcsIDQsIC0yLCAxOSwgMTMsIDZdO1xuc3RyYWlnaHRJbnNlcnRTb3J0KGEpO1xuY29uc29sZS5sb2coYSArICcnKTtcblxuLypcclxuIOWFtuWug+aPkuWFpeaOkuW6j1xyXG5cclxuIDEgIOaKmOWNiuaPkuWFpeaOkuW6j1xyXG4g5b2T5bCG5b6F5o6S5bqP55qE6K6w5b2VUltpXSDmj5LlhaXliLDlt7LmjpLlpb3luo/nmoTorrDlvZXlrZDooahSWzHigKZpLTFd5Lit5pe277yM55Sx5LqOUjEsIFIyICzigKYsIFJpLTHlt7LmjpLlpb3luo/vvIzliJnmn6Xmib7mj5LlhaXkvY3nva7lj6/ku6XnlKjigJzmipjljYrmn6Xmib7igJ3lrp7njrDvvIzliJnnm7TmjqXmj5LlhaXmjpLluo/lsLHlj5jmiJDkuLrmipjljYrmj5LlhaXmjpLluo/jgIJcclxuXHJcbiDku47ml7bpl7TkuIrmr5TovoPvvIzmipjljYrmj5LlhaXmjpLluo/ku4Xku4Xlh4/lsJHkuoblhbPplK7lrZfnmoTmr5TovoPmrKHmlbDvvIzljbTmsqHmnInlh4/lsJHorrDlvZXnmoTnp7vliqjmrKHmlbDvvIzmlYXml7bpl7TlpI3mnYLluqbku43nhLbkuLpPKG4yKSDjgIJcclxuXHJcblxyXG4gKi9cblxuZnVuY3Rpb24gYmluYXJ5SW5zZXJ0U29ydChzcUxpc3QpIHtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbMV07XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICB2YXIgbG93ID0gMDtcbiAgICAgICAgdmFyIGhpZ2ggPSBpIC0gMTtcblxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBsb3cgKyBoaWdoID4+IDE7XG5cbiAgICAgICAgICAgIGlmIChjb21wKHRlbXAsIHNxTGlzdFttaWRdKSA8IDApIGhpZ2ggPSBtaWQgLSAxO2Vsc2UgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSBoaWdoICsgMTsgLS1qKSB7XG4gICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gc3FMaXN0W2pdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3FMaXN0W2hpZ2ggKyAxXSA9IHRlbXA7XG4gICAgfVxufVxuXG52YXIgYiA9IFszMCwgMTMsIDcwLCA4NSwgMzksIDQyLCA2LCAyMF07XG5iaW5hcnlJbnNlcnRTb3J0KGIpO1xuY29uc29sZS5sb2coYiArICcnKTtcblxuLypcclxuIDIt6Lev5o+S5YWl5o6S5bqPXHJcblxyXG4g5piv5a+55oqY5Y2K5o+S5YWl5o6S5bqP55qE5pS56L+b77yM5Lul5YeP5bCR5o6S5bqP6L+H56iL5Lit56e75Yqo6K6w5b2V55qE5qyh5pWw44CC6ZmE5YqgbuS4quiusOW9leeahOi+heWKqeepuumXtO+8jOaWueazleaYr++8mlxyXG4g4pGgICDlj6borr7kuIDkuKrmlbDnu4Rk77yMTFsxXei1i+e7mWRbMV3vvIzlsIZkWzFd55yL5oiQ5piv5o6S5aW95bqP55qE5bqP5YiX5Lit5Lit6Ze05L2N572u55qE6K6w5b2V77ybXHJcbiDikaEgIOWIhuWIq+WwhkxbIF3kuK3nmoTnrKxp5Liq6K6w5b2V5L6d5qyh5o+S5YWl5YiwZFsxXeS5i+WJjeaIluS5i+WQjueahOacieW6j+W6j+WIl+S4re+8jOWFt+S9k+aWueazle+8mlxyXG4g4peGICBMW2ldLmtleTxkWzFdLmtlee+8miBMW2ld5o+S5YWl5YiwZFsxXeS5i+WJjeeahOacieW6j+ihqOS4re+8m1xyXG4g4peGIExbaV0ua2V54omlZFsxXS5rZXnvvJogTFtpXeaPkuWFpeWIsGRbMV3kuYvlkI7nmoTmnInluo/ooajkuK3vvJtcclxuIOWFs+mUrueCue+8muWunueOsOaXtuWwhuWQkemHj2TnnIvmiJDmmK/lvqrnjq/lkJHph4/vvIzlubborr7kuKTkuKrmjIfpkohmaXJzdOWSjGZpbmFs5YiG5Yir5oyH56S65o6S5bqP6L+H56iL5Lit5b6X5Yiw55qE5pyJ5bqP5bqP5YiX5Lit55qE56ys5LiA5Liq5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V44CCXHJcblxyXG4g5ZyoMi3ot6/mj5LlhaXmjpLluo/kuK3vvIznp7vliqjorrDlvZXnmoTmrKHmlbDnuqbkuLpuMi84IOOAguS9huW9k0xbMV3mmK/lvoXmjpLluo/orrDlvZXkuK3lhbPplK7lrZfmnIDlpKfmiJbmnIDlsI/nmoTorrDlvZXml7bvvIwyLei3r+aPkuWFpeaOkuW6j+WwseWujOWFqOWkseWOu+S6huS8mOi2iuaAp+OAglxyXG4gKi9cblxuZnVuY3Rpb24gcGF0aDJJbnNlcnRTb3J0KHNxTGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBkID0gW3NxTGlzdFswXV07XG4gICAgLy8gZmlyc3TjgIFmaW5hbOWIhuWIq+aMh+ekumTkuK3mjpLlpb3luo/nmoTorrDlvZXnmoTnrKwx5Liq5ZKM5pyA5ZCOMeS4quiusOW9leeahOS9jee9ruOAglxuICAgIHZhciBmaXJzdCA9IDA7XG4gICAgdmFyIGZpbmFsID0gMDtcbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzcUxpc3RbaV07XG5cbiAgICAgICAgLy8g5b6F5o+S5YWl6K6w5b2V5bCP5LqOZOS4reacgOWwj+WAvO+8jOaPkuWFpeWIsGRbZmlyc3Rd5LmL5YmN77yI5LiN6ZyA56e75YqoZOaVsOe7hOeahOWFg+e0oO+8ieOAglxuICAgICAgICBpZiAoY29tcChpdGVtLCBkW2ZpcnN0XSkgPCAwKSB7XG4gICAgICAgICAgICBmaXJzdCA9IChmaXJzdCAtIDEpICUgbGVuO1xuICAgICAgICAgICAgZFtmaXJzdF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIC8vIOW+heaPkuWFpeiusOW9leWkp+S6jmTkuK3mnIDlsI/lgLzvvIzmj5LlhaXliLBkW2ZpbmFsXeS5i+WQju+8iOS4jemcgOenu+WKqGTmlbDnu4TnmoTlhYPntKDvvInjgIJcbiAgICAgICAgZWxzZSBpZiAoY29tcChpdGVtLCBkW2ZpbmFsXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZFsrK2ZpbmFsXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlvoXmj5LlhaXorrDlvZXlpKfkuo5k5Lit5pyA5bCP5YC877yM5bCP5LqOZOS4reacgOWkp+WAvO+8jOaPkuWFpeWIsGTnmoTkuK3pl7TvvIjpnIDopoHnp7vliqhk5pWw57uE55qE5YWD57Sg77yJ44CCXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g56e75YqoZOWwvumDqOWFg+e0oOS7peS+v+aMieW6j+aPkuWFpeiusOW9leOAglxuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IGZpbmFsKys7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb21wKGl0ZW0sIGRbal0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZFsoaiArIDEpICUgbGVuXSA9IGRbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gKGogLSAxKSAlIGxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkWyhqICsgMSkgJSBsZW5dID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5b6q546v5oqKZOi1i+e7mXNxTGlzdFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47ICsrX2kpIHtcbiAgICAgICAgc3FMaXN0W19pXSA9IGRbKF9pICsgZmlyc3QpICUgbGVuXTtcbiAgICB9XG59XG5cbnZhciBjID0gWzQ5LCAzOCwgNjUsIDEzLCA5NywgMjcsIDc2LCA1LCAxMDAsIDc4LCAxNSwgMTUsIDIwXTtcbnBhdGgySW5zZXJ0U29ydChjKTtcbmNvbnNvbGUubG9nKGMgKyAnJyk7XG5cbi8qXHJcbuihqOaPkuWFpeaOkuW6j1xyXG5cclxu5YmN6Z2i55qE5o+S5YWl5o6S5bqP5LiN5Y+v6YG/5YWN5Zyw6KaB56e75Yqo6K6w5b2V77yM6Iul5LiN56e75Yqo6K6w5b2V5bCx6ZyA6KaB5pS55Y+Y5pWw5o2u57uT5p6E44CCXHJcbuWIneWni+WMlu+8muS4i+agh+WAvOS4ujDnmoTliIbph4/kvZzkuLrooajlpLTnu5PngrnvvIzlhbPplK7lrZflj5bkuLrmnIDlpKflgLzvvIzlkITliIbph4/nmoTmjIfpkojlgLzkuLrnqbrvvJtcclxu4pGgICDlsIbpnZnmgIHpk77ooajkuK3mlbDnu4TkuIvmoIflgLzkuLox55qE5YiG6YePKOe7k+eCuSnkuI7ooajlpLTnu5PngrnmnoTmiJDkuIDkuKrlvqrnjq/pk77ooajvvJtcclxu4pGhIGk9MiDvvIzlsIbliIbph49SW2ld5oyJ5YWz6ZSu5a2X6YCS5YeP5o+S5YWl5Yiw5b6q546v6ZO+6KGo77ybXHJcbuKRoiAg5aKe5YqgaSDvvIzph43lpI3ikaHvvIznm7TliLDlhajpg6jliIbph4/mj5LlhaXliLDlvqrnjq/pk77ooajjgIJcclxuXHJcbuWSjOebtOaOpeaPkuWFpeaOkuW6j+ebuOavlO+8jOS4jeWQjOeahOaYr+S/ruaUuTJu5qyh5oyH6ZKI5YC85Lul5Luj5pu/56e75Yqo6K6w5b2V77yM6ICM5YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw55u45ZCM77yM5pWF5pe26Ze05aSN5p2C5bqm5Li6TyhuMinjgIJcclxuXHJcbuihqOaPkuWFpeaOkuW6j+W+l+WIsOS4gOS4quacieW6j+mTvuihqO+8jOWvueWFtuWPr+S7peaWueS+v+WcsOi/m+ihjOmhuuW6j+afpeaJvu+8jOS9huS4jeiDveWunueOsOmaj+acuuafpeaJvuOAguS4uuS6huiDveWunueOsOacieW6j+ihqOeahOaKmOWNiuafpeaJvuagueaNrumcgOimge+8jOWPr+S7peWvueiusOW9lei/m+ihjOmHjeaOki5cclxuXHJcbumHjeaOkuiusOW9leeahOWBmuazleaYr++8mumhuuW6j+aJq+aPj+acieW6j+mTvuihqO+8jOWwhumTvuihqOS4reesrGnkuKrnu5Pngrnnp7vliqjoh7PmlbDnu4TnmoTnrKxp5Liq5YiG6YeP5Lit44CCXHJcblxyXG7kvovlrZDkuK3vvIzpk77ooajkuK3nrKzkuIDkuKrnu5PngrnvvIzljbPlhbPplK7lrZfmnIDlsI/nmoTnu5PngrnmmK/mlbDnu4TkuK3kuIvmoIfkuLo255qE5YiG6YeP77yM5YW25Lit6K6w5b2V5bqU56e76Iez5pWw57uE55qE56ys5LiA5Liq5YiG6YeP77yM5YiZ5bCGbGlzdFsxXeWSjGxpc3RbNl3kupLmjaLvvIzlubbkuLrkuobkuI3kuK3mlq3pnZnmgIHpk77ooajkuK3nmoTpk77vvIzljbPlnKjnu6fnu63pobrpk77ooajmiavmj4/ml7bku43og73mib7liLDkupLmjaLkuYvliY3lnKhsaXN0WzFd5Lit55qE57uT54K577yM5Luk5LqS5o2i5LmL5ZCO55qEbGlzdFsxXeS4reeahOa4uOagh+aUueS4ujZcclxuXHJcbuaOqOW5v+iHs+S4gOiIrOaDheWGte+8jOiLpeesrGnkuKrmnIDlsI/lhbPplK7lrZfnmoTnu5PngrnmmK/mlbDnu4TkuK3kuIvmoIfkuLpw5LiUcCA+IGnnmoTliIbph4/vvIzliJnkupLmjaJsaXN0W2ld5ZKMbGlzdFtwXe+8jOS4lOS7pGxpc3RbaV3kuK3nmoTmuLjmoIfmlLnkuLpw77ybXHJcbueUseS6juatpOaXtuaVsOe7hOS4reaJgOacieWwj+S6jmnnmoTliIbph4/kuK3lt7LmmK/liLDkvY3orrDlvZXvvIzliJnlvZNwPGnml7bvvIzlupTpobrpk77nu6fnu63mn6Xmib7nm7TliLBwPj1p5Li65q2i44CCXHJcbiAqL1xuXG4vLyDooajmj5LlhaXmjpLluo9cbmZ1bmN0aW9uIHN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0KHNsbGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIC8vIOaehOaIkOW+queOr+mTvuihqFxuICAgIHNsbGlzdFswXS5jdXIgPSAxO1xuICAgIHNsbGlzdFsxXS5jdXIgPSAwO1xuXG4gICAgdmFyIHAgPSB2b2lkIDAsXG4gICAgICAgIHEgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IHNsbGlzdC5sZW5ndGg7IGkgPD0gbGVuOyArK2kpIHtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIHZhciB4ID0gc2xsaXN0W2ldLmRhdGE7XG5cbiAgICAgICAgd2hpbGUgKHNsbGlzdFtwXS5jdXIgJiYgY29tcChzbGxpc3Rbc2xsaXN0W3BdLmN1cl0uZGF0YSwgeCkgPCAwKSB7XG4gICAgICAgICAgICBwID0gc2xsaXN0W3BdLmN1cjtcbiAgICAgICAgfSAvLyDlvZPpgYfliLDlpKfkuo7lvZPliY3lhbPplK7lrZfnmoTkuIvmoIfml7bvvIzmj5LlhaXliLDlhbbliY3pqbHlkozlkI7nu6fnmoTkuK3pl7RcbiAgICAgICAgcSA9IHNsbGlzdFtwXS5jdXI7XG4gICAgICAgIHNsbGlzdFtwXS5jdXIgPSBpO1xuICAgICAgICBzbGxpc3RbaV0uY3VyID0gcTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0ID0gc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQ7XG5cbi8vIOmHjeaOkumdmeaAgemTvuihqO+8jOmdmeaAgemTvuihqOS4i+agh+W3suaOkuWlveW6j1xuZnVuY3Rpb24gYXJyYW5nZShzbGxpc3QpIHtcbiAgICB2YXIgcCA9IHNsbGlzdFswXS5jdXI7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc2xsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIOesrGnkuKrorrDlvZXlnKhsaXN05Lit55qE5b2T5YmN5L2N572u5bqU5LiN5bCP5LqOaVxuICAgICAgICAvLyDmib7liLDnrKxp5Liq6K6w5b2V77yM5bm255SocOaMh+ekuuWFtuWcqGxpc3TkuK3lvZPliY3kvY3nva5cbiAgICAgICAgd2hpbGUgKHAgPCBpKSB7XG4gICAgICAgICAgICBwID0gc2xsaXN0W3BdLmN1cjtcbiAgICAgICAgfSAvLyBx5oyH5ZCR5bCa5pyq6LCD5pW055qE6KGo5bC+XG4gICAgICAgIHZhciBxID0gc2xsaXN0W3BdLmN1cjtcblxuICAgICAgICBpZiAocCAhPT0gaSkge1xuICAgICAgICAgICAgLy8g5Lqk5o2i6K6w5b2V77yM5L2/56ysaeS4quiusOW9leWIsOS9jVxuICAgICAgICAgICAgdmFyIHRlbXAgPSBzbGxpc3RbcF07XG4gICAgICAgICAgICBzbGxpc3RbcF0gPSBzbGxpc3RbaV07XG4gICAgICAgICAgICBzbGxpc3RbaV0gPSB0ZW1wO1xuICAgICAgICAgICAgLy8g5oyH5ZCR6KKr56e76LWw55qE6K6w5b2V77yM5L2/5b6X5Lul5ZCO5Y+v5pyJd2hpbGXlvqrnjq/mib7liLBcbiAgICAgICAgICAgIHNsbGlzdFtpXS5jdXIgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcOaMh+WQkeWwmuacquiwg+aVtOeahOihqOWwvlxuICAgICAgICBwID0gcTtcbiAgICB9XG59XG5cbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDUyXTtcbnZhciBkID0gbmV3IF9TdGF0aWNMaW5rZWRMaXN0Mi5kZWZhdWx0KCk7XG5kLmNyZWF0ZShhcnIpO1xuc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQoZCk7XG5jb25zb2xlLmxvZyhkKTtcbmFycmFuZ2UoZCk7XG5jb25zb2xlLmxvZyhkKTtcblxuLypcclxu5biM5bCU5o6S5bqPXHJcblxyXG7luIzlsJTmjpLluo8oU2hlbGwgU29ydO+8jOWPiOensOe8qeWwj+WinumHj+azlSnmmK/kuIDnp43liIbnu4Tmj5LlhaXmjpLluo/mlrnms5XjgIJcclxuXHJcbjEgIOaOkuW6j+aAneaDs1xyXG7ikaAgICDlhYjlj5bkuIDkuKrmraPmlbTmlbBkMShkMTxuKeS9nOS4uuesrOS4gOS4quWinumHj++8jOWwhuWFqOmDqG7kuKrorrDlvZXliIbmiJBkMee7hO+8jOaKiuaJgOacieebuOmalGQx55qE6K6w5b2V5pS+5Zyo5LiA57uE5Lit77yM5Y2z5a+55LqO5q+P5LiqayhrPTEsIDIsICDigKYgZDEp77yMUltrXSwgUltkMStrXSwgUlsyZDEra10gLCDigKbliIblnKjlkIzkuIDnu4TkuK3vvIzlnKjlkITnu4TlhoXov5vooYznm7TmjqXmj5LlhaXmjpLluo/jgILov5nmoLfkuIDmrKHliIbnu4TlkozmjpLluo/ov4fnqIvnp7DkuLrkuIDotp/luIzlsJTmjpLluo/vvJtcclxu4pGhICAg5Y+W5paw55qE5aKe6YePZDI8ZDHvvIzph43lpI3ikaDnmoTliIbnu4TlkozmjpLluo/mk43kvZzvvJvnm7Toh7PmiYDlj5bnmoTlop7ph49kaT0x5Li65q2i77yM5Y2z5omA5pyJ6K6w5b2V5pS+6L+b5LiA5Liq57uE5Lit5o6S5bqP5Li65q2i44CCXHJcblxyXG4yICDmjpLluo/npLrkvotcclxu6K6+5pyJMTDkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLo5LCAxMywgOCwgMiwgNSwgMTMsIDcsIDEsIDE1LCAxMe+8jOWinumHj+W6j+WIl+aYrzUsIDMsIDHvvIzluIzlsJTmjpLluo/nmoTov4fnqIs6XHJcbuWIneWni+WFs+mUruWtl+W6j+WIlzogICAgOSAgICAgMTMgICAgIDggICAgICAyICAgICAgNSAgICAgIDEzICAgICAgNyAgICAgIDEgICAgICAxNSAgICAgIDExXHJcbuesrOS4gOi2n+aOkuW6j+WQjjogICAgICA5ICAgICA3ICAgICAgMSAgICAgIDIgICAgICA1ICAgICAgMTMgICAgICAxMyAgICAgOCAgICAgIDE1ICAgICAgMTFcclxu56ys5LqM6Laf5o6S5bqP5ZCOOiAgICAgIDIgICAgIDUgICAgICAxICAgICAgOSAgICAgIDcgICAgICAxMyAgICAgIDExICAgICA4ICAgICAgMTUgICAgICAxM1xyXG7nrKzkuInotp/mjpLluo/lkI46ICAgICAgMSAgICAgMiAgICAgIDUgICAgICA3ICAgICAgOCAgICAgIDkgICAgICAxMSAgICAgMTMgICAgICAxMyAgICAgIDE1XHJcblxyXG5cclxu5biM5bCU5o6S5bqP55qE5YiG5p6Q5q+U6L6D5aSN5p2C77yM5raJ5Y+K5LiA5Lqb5pWw5a2m5LiK55qE6Zeu6aKY77yM5YW25pe26Ze05piv5omA5Y+W55qE4oCc5aKe6YeP4oCd5bqP5YiX55qE5Ye95pWw44CCXHJcblxyXG7luIzlsJTmjpLluo/nibnngrlcclxu5a2Q5bqP5YiX55qE5p6E5oiQ5LiN5piv566A5Y2V55qE4oCc6YCQ5q615YiG5Ymy4oCd77yM6ICM5piv5bCG55u46ZqU5p+Q5Liq5aKe6YeP55qE6K6w5b2V57uE5oiQ5LiA5Liq5a2Q5bqP5YiX44CCXHJcbuW4jOWwlOaOkuW6j+WPr+aPkOmrmOaOkuW6j+mAn+W6pu+8jOWOn+WboOaYr++8mlxyXG7il4Yg5YiG57uE5ZCObuWAvOWHj+Wwj++8jG7CsuabtOWwj++8jOiAjFQobik9TyhuwrIpLOaJgOS7pVQobinku47mgLvkvZPkuIrnnIvmmK/lh4/lsI/kuobvvJtcclxu4peGIOWFs+mUruWtl+i+g+Wwj+eahOiusOW9lei3s+i3g+W8j+WJjeenu++8jOWcqOi/m+ihjOacgOWQjuS4gOi2n+WinumHj+S4ujHnmoTmj5LlhaXmjpLluo/ml7bvvIzluo/liJflt7Lln7rmnKzmnInluo/jgIJcclxuXHJcbuWinumHj+W6j+WIl+WPluazlVxyXG7il4Yg5peg6ZmkMeS7peWklueahOWFrOWboOWtkO+8m1xyXG7il4Yg5pyA5ZCO5LiA5Liq5aKe6YeP5YC85b+F6aG75Li6MeOAglxyXG5cclxu55u45YWz6LWE5paZ77yaIGh0dHA6Ly93ZW5rdS5iYWlkdS5jb20vbGluaz91cmw9cTdrek94WHFjMEJMYUdVVkRZNDNGUU9oMmFYMVVxQkhra1lkM1ZNd0poSm82cnY0U2lVNjg2Ulcza1FDU3FHRUt5dGwxMlM4ZkJPcHdocS1ydW5oWF9wYlpjZzZCZUQtbWlZTVBnRGhYeEtcclxuICovXG5cbmZ1bmN0aW9uIHNoZWxsSW5zZXJ0KHNxTGlzdCwgZGssIGNvbXApIHtcbiAgICBmb3IgKHZhciBpID0gZGssIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgaWYgKGNvbXAodGVtcCwgc3FMaXN0W2kgLSBka10pIDwgMCkge1xuICAgICAgICAgICAgdmFyIGogPSBpIC0gZGs7XG4gICAgICAgICAgICBmb3IgKDsgaiA+PSAwICYmIGNvbXAodGVtcCwgc3FMaXN0W2pdKSA8IDA7IGogLT0gZGspIHtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIGRrXSA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgIH1zcUxpc3RbaiArIGRrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoZWxsU29ydChzcUxpc3QpIHtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgZGVsdGEgPSBjcmVhdGVEZWx0YShzcUxpc3QubGVuZ3RoKTtcbiAgICAvL2NvbnNvbGUubG9nKGRlbHRhKTtcbiAgICBmb3IgKHZhciBrID0gMCwgdCA9IGRlbHRhLmxlbmd0aDsgayA8IHQ7ICsraykge1xuICAgICAgICBzaGVsbEluc2VydChzcUxpc3QsIGRlbHRhW2tdLCBjb21wKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlbHRhKG4pIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIHQgPSBNYXRoLmxvZyhuIC0gMSkgLyBNYXRoLmxvZygyKSB8IDA7IC8vIE1hdGgubG9nKG4gLSAxKSAvIE1hdGgubG9nKDIpLCBNYXRoLmxvZyhuICsgMSkgLyBNYXRoLmxvZygyKVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDw9IHQ7ICsraykge1xuICAgICAgICBhcnJba10gPSBNYXRoLnBvdygyLCB0IC0gaykgKyAxO1xuICAgIH0gLy8gTWF0aC5wb3coMiwgdCAtIGkgKyAxKSAtIDEsIE1hdGgucG93KDIsIHQgLSBpKSArIDFcblxuICAgIGFyclthcnIubGVuZ3RoXSA9IDE7XG5cbiAgICByZXR1cm4gYXJyO1xufVxuXG5jb25zb2xlLmxvZygnXFxuXFxuU2hlbGwgU29ydDonKTtcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XG5zaGVsbFNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NvcnQvaW5zZXJ0aW9uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubGlua2VkTGlzdE5hdHVyYWxNZXJnZVNvcnQgPSBleHBvcnRzLm5hdHVyYWxNZXJnZVNvcnQgPSB1bmRlZmluZWQ7XG5leHBvcnRzLm1lcmdlU29ydFJlY3Vyc2l2ZSA9IG1lcmdlU29ydFJlY3Vyc2l2ZTtcbmV4cG9ydHMubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlID0gbWVyZ2VTb3J0Tm9uUmVjdXJzaXZlO1xuZXhwb3J0cy5uYXR1cmVNZXJnZVNvcnQgPSBuYXR1cmVNZXJnZVNvcnQ7XG5cbnZhciBfTGlua2VkTGlzdCA9IHJlcXVpcmUoJy4uLy4uL0xpc3QvTGlua2VkTGlzdCcpO1xuXG52YXIgX0xpbmtlZExpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlua2VkTGlzdCk7XG5cbnZhciBfUXVldWUgPSByZXF1aXJlKCcuLi8uLi9RdWV1ZS9RdWV1ZScpO1xuXG52YXIgX1F1ZXVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1F1ZXVlKTtcblxudmFyIF9kZWZhdWx0Q29tcGFyaXNpb24gPSByZXF1aXJlKCcuLi9kZWZhdWx0Q29tcGFyaXNpb24nKTtcblxudmFyIF9kZWZhdWx0Q29tcGFyaXNpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdENvbXBhcmlzaW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcclxuIOW9kuW5tuaOkuW6j1xyXG5cclxuIOW9kuW5tihNZXJnaW5nKSDvvJrmmK/mjIflsIbkuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTmnInluo/luo/liJflkIjlubbmiJDkuIDkuKrmnInluo/luo/liJfjgILoi6Xph4fnlKjnur/mgKfooago5peg6K665piv6YKj56eN5a2Y5YKo57uT5p6EKeaYk+S6juWunueOsO+8jOWFtuaXtumXtOWkjeadguW6puS4uk8obStuKSDjgIJcclxuIOW9kuW5tuaAneaDs+WunuS+i++8muS4pOWghuaJkeWFi+eJjO+8jOmDveW3suS7juWwj+WIsOWkp+aOkuWlveW6j++8jOimgeWwhuS4pOWghuWQiOW5tuS4uuS4gOWghuS4lOimgeaxguS7juWwj+WIsOWkp+aOkuW6j+OAglxyXG4g4peGICDlsIbkuKTloIbmnIDkuIrpnaLnmoTmir3lh7oo6K6+5Li6QzHvvIxDMinmr5TovoPlpKflsI/vvIzlsIblsI/ogIXnva7kuo7kuIDovrnkvZzkuLrmlrDnmoTkuIDloIYo5LiN5aao6K6+QzE8QzIp77yb5YaN5LuO56ys5LiA5aCG5Lit5oq95Ye65LiA5byg57un57ut5LiOQzLov5vooYzmr5TovoPvvIzlsIbovoPlsI/nmoTmlL7nva7lnKjmlrDloIbnmoTmnIDkuIvpnaLvvJtcclxuIOKXhiDph43lpI3kuIrov7Dov4fnqIvvvIznm7TliLDmn5DkuIDloIblt7Lmir3lrozvvIznhLblkI7lsIbliankuIvkuIDloIbkuK3nmoTmiYDmnInniYzovaznp7vliLDmlrDloIbkuK3jgIJcclxuXHJcbiAxICAg5o6S5bqP5oCd5oOzXHJcbiDikaAgIOWIneWni+aXtu+8jOWwhuavj+S4quiusOW9leeci+aIkOS4gOS4quWNleeLrOeahOacieW6j+W6j+WIl++8jOWImW7kuKrlvoXmjpLluo/orrDlvZXlsLHmmK9u5Liq6ZW/5bqm5Li6MeeahOacieW6j+WtkOW6j+WIl++8m1xyXG4g4pGhICDlr7nmiYDmnInmnInluo/lrZDluo/liJfov5vooYzkuKTkuKTlvZLlubbvvIzlvpfliLDvg6luLzLvg7nkuKrplb/luqbkuLoy5oiWMeeahOacieW6j+WtkOW6j+WIl+KAlOKAlOS4gOi2n+W9kuW5tu+8m1xyXG4g4pGiICDph43lpI3ikaEg77yM55u05Yiw5b6X5Yiw6ZW/5bqm5Li6bueahOacieW6j+W6j+WIl+S4uuatouOAglxyXG5cclxuIOS4iui/sOaOkuW6j+i/h+eoi+S4re+8jOWtkOW6j+WIl+aAu+aYr+S4pOS4pOW9kuW5tu+8jOensOS4ujIt6Lev5b2S5bm25o6S5bqP44CC5YW25qC45b+D5piv5aaC5L2V5bCG55u46YK755qE5Lik5Liq5a2Q5bqP5YiX5b2S5bm25oiQ5LiA5Liq5a2Q5bqP5YiX44CC6K6+55u46YK755qE5Lik5Liq5a2Q5bqP5YiX5YiG5Yir5Li677yaXHJcbiB7UltrXSwgUltrKzFdLCDigKYsIFJbbV195ZKMe1JbbSsxXSwgUlttKzJdLOKApiwgUltoXX3vvIzlsIblroPku6zlvZLlubbkuLrkuIDkuKrmnInluo/nmoTlrZDluo/liJfvvJpcclxuIHtEUltsXSwgRFJbbCsxXSwg4oCmLCBEUlttXSwgRFJbbSsxXSwg4oCmLCBEUltoXSB9XHJcblxyXG4g5L6L77ya6K6+5pyJOeS4quW+heaOkuW6j+eahOiusOW9le+8jOWFs+mUruWtl+WIhuWIq+S4ujIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDHvvIzlvZLlubbmjpLluo/nmoTov4fnqIvjgIJcclxuIOWIneWni+WFs+mUruWtlzogWzIzXSAgIFszOF0gICBbMjJdICAgWzQ1XSAgIFsyM10gICBbNjddICAgWzMxXSAgIFsxNV0gICBbNDFdXHJcbiAgICAgICAgICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHxcclxuICAgICAgICAgICAgICAtLS0tLS0tLSAgICAgIC0tLS0tLS0tICAgICAgLS0tLS0tLS0gICAgICAtLS0tLS0tLVxyXG4g5LiA6Laf5b2S5bm25ZCOOiBbMjMgICAgMzhdICAgIFsyMiAgICAgNDVdICAgIFsyMyAgICAgNjddICAgIFsxNSAgICAgMzFdICAgWzQxXVxyXG4gICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLVxyXG4g5LqM6Laf5b2S5bm25ZCOOiBbMjIgICAgIDIzICAgICAgMzggICAgIDQ1XSAgICBbMTUgICAgIDIzICAgICAzMSAgICAgNjddICAgIFs0MV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuIOS4iei2n+W9kuW5tuWQjjogWzE1ICAgICAyMiAgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0NSAgICAgNjddICAgIFs0MV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiDlm5votp/lvZLlubblkI46IFsxNSAgICAgMjIgICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgICA2N1xyXG5cclxuXHJcbiAyICDkuIDotp/lvZLlubbmjpLluo9cclxuIOS4gOi2n+W9kuW5tuaOkuW6j+mDveaYr+S7juWJjeWIsOWQju+8jOS+neasoeWwhuebuOmCu+eahOS4pOS4quacieW6j+WtkOW6j+WIl+W9kuW5tuS4uuS4gOS4qu+8jOS4lOmZpOacgOWQjuS4gOS4quWtkOW6j+WIl+Wklu+8jOWFtuS9meavj+S4quWtkOW6j+WIl+eahOmVv+W6pumDveebuOWQjOOAguiuvui/meS6m+WtkOW6j+WIl+eahOmVv+W6puS4umTvvIzliJnkuIDotp/lvZLlubbmjpLluo/nmoTov4fnqIvmmK/vvJpcclxuIOS7jmo9MOW8gOWni++8jOS+neasoeWwhuebuOmCu+eahOS4pOS4quacieW6j+WtkOW6j+WIl1xyXG4gUltq4oCmaitkLTFd5ZKMUltqK2TigKZqKzJkLTFd6L+b6KGM5b2S5bm277yb5q+P5qyh5b2S5bm25Lik5Liq5a2Q5bqP5YiX5ZCO77yMauWQjuenu+WKqDJk5Liq5L2N572u77yM5Y2zXHJcbiBqPWorMmTvvJvoi6XliankuIvnmoTlhYPntKDkuI3otrPkuKTkuKrlrZDluo/liJfml7bvvIzliIbku6XkuIvkuKTnp43mg4XlhrXlpITnkIbvvJpcclxuIOKRoCAg5Ymp5LiL55qE5YWD57Sg5Liq5pWwPmTvvJrlho3osIPnlKjkuIDmrKHkuIrov7Dov4fnqIvvvIzlsIbkuIDkuKrplb/luqbkuLpk55qE5a2Q5bqP5YiX5ZKM5LiN6LazZOeahOWtkOW6j+WIl+i/m+ihjOW9kuW5tu+8m1xyXG4g4pGhICDliankuIvnmoTlhYPntKDkuKrmlbDiiaRk77ya5bCG5Ymp5LiL55qE5YWD57Sg5L6d5qyh5aSN5Yi25Yiw5b2S5bm25ZCO55qE5bqP5YiX5Lit44CCXHJcblxyXG5cclxuIDMu566X5rOV5YiG5p6QXHJcbuWFt+aciW7kuKrlvoXmjpLluo/orrDlvZXnmoTlvZLlubbmrKHmlbDmmK/jj5Iybu+8jOiAjOS4gOi2n+W9kuW5tueahOaXtumXtOWkjeadguW6puS4uk8obinvvIzliJnmlbTkuKrlvZLlubbmjpLluo/nmoTml7bpl7TlpI3mnYLluqbml6DorrrmmK/mnIDlpb3ov5jmmK/mnIDlnY/mg4XlhrXlnYfkuLpPKG7jj5IybinjgILlnKjmjpLluo/ov4fnqIvkuK3vvIzkvb/nlKjkuobovoXliqnlkJHph49EUu+8jOWkp+Wwj+S4juW+heaOkuW6j+iusOW9leepuumXtOebuOWQjO+8jOWImeepuumXtOWkjeadguW6puS4uk8obinjgILlvZLlubbmjpLluo/mmK/nqLPlrprnmoTjgIJcclxuXHJcbiAqL1xuXG52YXIgbkNvdW50ID0gMDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVkIGJ5IGxkcCBvbiAyMDE1LzIvNy5cclxuICAgICAgICAgICAgICAgICAqL1xuXG52YXIgbm9uUmVjdXJzaXZlQ291bnQgPSAwO1xudmFyIHJlY3Vyc2l2ZUNvdW50ID0gMDtcblxuLyoqXHJcbiAqIOWwhuacieW6j+eahHNyW3MxLi5lMV3lkoxzcltzMi4uZTJd5b2S5bm25Li65pyJ5bqP55qEdHJbczEuLmUyXVxyXG4gKiBAcGFyYW0gc3JcclxuICogQHBhcmFtIHMxXHJcbiAqIEBwYXJhbSBlMVxyXG4gKiBAcGFyYW0gZTJcclxuICovXG5mdW5jdGlvbiBtZXJnZShzciwgczEsIGUxLCBlMikge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1s0XTtcblxuICAgIHZhciB0ZW1wID0gW107XG4gICAgdmFyIGkgPSBzMTtcbiAgICB2YXIgaiA9IGUxICsgMTtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBqIDw9IGUyKSB7XG4gICAgICAgIGlmIChjb21wKHNyW2ldLCBzcltqXSkgPCAwKSB0ZW1wW2srK10gPSBzcltpKytdO2Vsc2UgdGVtcFtrKytdID0gc3JbaisrXTtcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgdGVtcFtrKytdID0gc3JbaSsrXTtcbiAgICB9d2hpbGUgKGogPD0gZTIpIHtcbiAgICAgICAgdGVtcFtrKytdID0gc3JbaisrXTtcbiAgICB9IC8vIOWkjeWItuWbnuWOu1xuICAgIGZvciAoaSA9IHMxLCBrID0gMDsgaSA8PSBlMjsgKytpLCArK2spIHtcbiAgICAgICAgc3JbaV0gPSB0ZW1wW2tdO1xuICAgIH1cbn1cblxuLyoqXHJcbiAqIDIt6Lev5b2S5bm25o6S5bqP6YCS5b2S566X5rOVXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XHJcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTb3J0UmVjdXJzaXZlKHNyKSB7XG4gICAgdmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gc3IubGVuZ3RoIC0gMSA6IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbM107XG5cbiAgICBpZiAocyA+PSB0KSByZXR1cm47XG5cbiAgICAvLyDlsIZzcltzLi50XeW5s+WIhuS4unNyW3MuLm1d5ZKMc3JbbSsxLi50XVxuICAgIHZhciBtID0gcyArIHQgPj4gMTtcbiAgICAvLyDpgJLlvZLlnLDlsIZzcltzLi5tXeW9kuW5tuS4uuacieW6j+eahHNyW3MuLm1dXG4gICAgbWVyZ2VTb3J0UmVjdXJzaXZlKHNyLCBzLCBtLCBjb21wKTtcbiAgICAvLyDpgJLlvZLlnLDlsIZzclttKzEuLnRd5b2S5bm25Li65pyJ5bqP55qEc3JbbSsxLi50XVxuICAgIG1lcmdlU29ydFJlY3Vyc2l2ZShzciwgbSArIDEsIHQsIGNvbXApO1xuICAgIC8vIOWwhnNyW3MuLm1d5ZKMc3JbbSsxLi50XeW9kuW5tuWIsHNyW3MuLnRdO1xuICAgIG1lcmdlKHNyLCBzLCBtLCB0LCBjb21wKTtcbn1cblxuY29uc29sZS5sb2coJ1xcblxcbm1lcmdlU29ydFJlY3Vyc2l2ZTonKTtcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XG5tZXJnZVNvcnRSZWN1cnNpdmUoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuZnVuY3Rpb24gbWVyZ2VTb3J0Tm9uUmVjdXJzaXZlKHNyKSB7XG4gICAgdmFyIGNvbXAgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfZGVmYXVsdENvbXBhcmlzaW9uMi5kZWZhdWx0IDogYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIGogPSB2b2lkIDAsXG4gICAgICAgIGsgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgZCA9IDEsIG4gPSBzci5sZW5ndGggLSAxOyBkIDwgbjsgZCAqPSAyKSB7XG4gICAgICAgIC8vIOS4gOi2n+W9kuW5tuaOkuW6j+eul+azlVxuICAgICAgICBqID0gMDtcblxuICAgICAgICAvLyDlrZDluo/liJfkuKTkuKTlvZLlubZcbiAgICAgICAgd2hpbGUgKChrID0gaiArIDIgKiBkIC0gMSkgPCBuKSB7XG4gICAgICAgICAgICBtZXJnZShzciwgaiwgaiArIGQgLSAxLCBrLCBjb21wKTtcbiAgICAgICAgICAgIGogPSBrICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWJqeS9meWFg+e0oOS4quaVsOi2hei/h+S4gOS4quWtkOW6j+WIl+mVv+W6plxuICAgICAgICBpZiAoaiArIGQgLSAxIDwgbikgbWVyZ2Uoc3IsIGosIGogKyBkIC0gMSwgbiwgY29tcCk7XG4gICAgICAgIC8vIOWJqeS9meWtkOW6j+WIl+WkjeWItlxuICAgICAgICBlbHNlIG1lcmdlKHNyLCBqLCBuLCBuLCBjb21wKTtcbiAgICB9XG59XG5cbmNvbnNvbGUubG9nKCdcXG5tZXJnZVNvcnROb25SZWN1cnNpdmU6Jyk7XG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlKGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cbi8vIOiHqueEtuWQiOW5tuaOkuW6j1xuLy8gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9saXVzaGFuZzA0MTkvYXJjaGl2ZS8yMDExLzA5LzE5LzIxODE0NzYuaHRtbFxuLy8gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9sYW5rZS9hcmNoaXZlLzIwMTMvMDEvMTUvMjg2MDQ4Ny5odG1sXG4vKlxyXG7oh6rnhLblvZLlubbmmK/lvZLlubbmjpLluo/nmoTkuIDkuKrlj5jlvaLvvIzmlYjnjofmm7Tpq5jkuIDkupvvvIzlj6/ku6XlnKjlvZLlubbmjpLluo/pnZ7pgJLlvZLlrp7njrDnmoTln7rnoYDkuIrov5vooYzkv67mlLku5a+55LqO5bey57uP5LiA5Liq5bey57uP57uZ5a6a5pWw57uEYSzpgJrluLjlrZjlnKjlpJrkuKrplb/luqblpKfkuo4x55qE5bey57uP6Ieq54S25o6S5aW955qE5a2Q5pWw57uE5q61LOWboOatpOeUqOS4gOasoeWvueaVsOe7hGHnmoTnur/mgKfmiavmj4/lsLHlj6/ku6Xmib7lh7rmiYDmnInov5nkupvmjpLlpb3luo/nmoTlrZDmlbDnu4TmrrUs54S25ZCO5YaN5a+56L+Z5Lqb5a2Q5pWw57uE5q615L+p5L+p5ZCI5bm2LlxyXG4gKi9cblxuLy8g5omr5o+P5b6X5Yiw5a2Q5Liy55qE5Ye95pWwXG5mdW5jdGlvbiBwYXNzKHNxTGlzdCwgcmVjLCBjb21wKSB7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgcmVjW251bSsrXSA9IDA7XG4gICAgdmFyIGxlbiA9IHNxTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSByZWNbbnVtKytdID0gaSArIDE7XG4gICAgfVxuICAgIHJlY1tudW0rK10gPSBsZW47XG5cbiAgICByZXR1cm4gbnVtO1xufVxuXG5mdW5jdGlvbiBuYXR1cmVNZXJnZVNvcnQoc3FMaXN0KSB7XG4gICAgdmFyIGNvbXAgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfZGVmYXVsdENvbXBhcmlzaW9uMi5kZWZhdWx0IDogYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIHJlYyA9IFtdO1xuXG4gICAgLy9udW09MuivtOaYjuW3sue7j+aOkuWlveW6j+S6hlxuICAgIC8v5q+P5b6q546v5LiA5qyh77yM6L+b6KGM5LiA5qyhcGFzcygp5pON5L2cXG4gICAgZm9yICh2YXIgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCk7IG51bSAhPT0gMjsgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAyIDwgbnVtOyBpICs9IDIpIHtcbiAgICAgICAgICAgIG1lcmdlKHNxTGlzdCwgcmVjW2ldLCByZWNbaSArIDFdIC0gMSwgcmVjW2kgKyAyXSAtIDEsIGNvbXApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zb2xlLmxvZygnXFxubmF0dXJlTWVyZ2VTb3J0OicpO1xudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcbm5hdHVyZU1lcmdlU29ydChhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5jb25zb2xlLmxvZyhyZWN1cnNpdmVDb3VudCk7XG5jb25zb2xlLmxvZyhub25SZWN1cnNpdmVDb3VudCk7XG5jb25zb2xlLmxvZyhuQ291bnQpO1xuXG4vLyDlj4zlkJHoh6rnhLblkIjlubbmjpLluo/nrpfms5Vcbi8qXHJcbuWPjOWQkeiHqueEtuWQiOW5tuaOkuW6j+aYr+agueaNruassuaOkuW6j+aVsOaNruWxgOmDqOS4jeaYr+WNh+W6j+WwseaYr+mZjeW6j+eahOiHqueEtuacieW6j+eJueeCuSzlhYjnur/mgKfmiavmj4/lh7roh6rnhLbmnInluo/nmoTlrZDmlbDnu4TmrrUs5YaN6L+b6KGM5ZCI5bm25o6S5bqPLuaJq+aPj+aXtueahOacieW6j+aVsOautemVv+W6pui2iumVvyzmrrXmlbDotorlsJEs5a+55bqU5ZCI5bm25qCR55qE5bGC5pWw5bCx5Lya6LaK5bCRLOeul+azleeahOaViOeOh+i2iumrmC5cclxuICovXG52YXIgbmF0dXJhbE1lcmdlU29ydCA9IGV4cG9ydHMubmF0dXJhbE1lcmdlU29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmF0dXJhbE1lcmdlU29ydDtcblxuICAgIGZ1bmN0aW9uIG5hdHVyYWxNZXJnZVNvcnQoYSkge1xuICAgICAgICB2YXIgY29tcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0Q29tcGFyaXNpb24yLmRlZmF1bHQgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIGIgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCFtZXJnZVJ1bnMoYSwgYiwgbiwgY29tcCkpIHt9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VSdW5zKGEsIGIsIG4sIGNvbXApIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIHZhciBhc2MgPSB0cnVlO1xuICAgICAgICB2YXIgeCA9IHZvaWQgMDtcblxuICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgIGsgPSBpO1xuICAgICAgICAgICAgLy8g5om+5Yiw5pyA5ZCO5LiA5Liq6YCS5aKe5bqP5YiX5YWD57SgXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgeCA9IGFbaSsrXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBuICYmIGNvbXAoeCwgYVtpXSkgPD0gMCk7XG4gICAgICAgICAgICAvLyDmib7liLDmnIDlkI7kuIDkuKrpgJLlh4/luo/liJflhYPntKBcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbiAmJiBjb21wKHgsIGFbaV0pID49IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gYVtpKytdO1xuICAgICAgICAgICAgfSAvLyDlvZLlubbpgJLlop7luo/liJflkozpgJLlh4/luo/liJfvvIznu5Pmnpzlj6/og73pgJLlop7miJbpgJLlh49cbiAgICAgICAgICAgIG1lcmdlKGEsIGIsIGssIGkgLSAxLCBhc2MsIGNvbXApO1xuICAgICAgICAgICAgYXNjID0gIWFzYztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW9k2vnrYnkuo4w5pe25Luj6KGoYeW3sue7j+aOkuWlveW6j+S6hlxuICAgICAgICByZXR1cm4gayA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiLCBsb3csIGhpZ2gsIGFzYywgY29tcCkge1xuICAgICAgICB2YXIgayA9IGFzYyA/IGxvdyA6IGhpZ2g7XG4gICAgICAgIHZhciBjID0gYXNjID8gMSA6IC0xO1xuICAgICAgICB2YXIgaSA9IGxvdztcbiAgICAgICAgdmFyIGogPSBoaWdoO1xuXG4gICAgICAgIHdoaWxlIChpIDw9IGopIHtcbiAgICAgICAgICAgIGlmIChjb21wKGFbaV0sIGFbal0pIDw9IDApIGJba10gPSBhW2krK107ZWxzZSBiW2tdID0gYVtqLS1dO1xuICAgICAgICAgICAgayArPSBjO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGsgPSBsb3csIGogPSBoaWdoOyBpIDw9IGo7ICsraSwgKytrKSB7XG4gICAgICAgICAgICBhW2ldID0gYltrXTtcbiAgICAgICAgfVxuICAgIH1cbn0oKTtcblxuY29uc29sZS5sb2coJ1xcbm5hdHVyYWxNZXJnZVNvcnQ6Jyk7XG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xubmF0dXJhbE1lcmdlU29ydChhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG4vLyDpk77ooajlrZjlgqjnu5PmnoTnmoToh6rnhLblkIjlubbmjpLluo9cbnZhciBsaW5rZWRMaXN0TmF0dXJhbE1lcmdlU29ydCA9IGV4cG9ydHMubGlua2VkTGlzdE5hdHVyYWxNZXJnZVNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lcmdlU29ydDtcblxuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChsaW5rZWRsaXN0KSB7XG4gICAgICAgIHZhciBuZWVkUmVwbGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICBpZiAoIWxpbmtlZGxpc3QpIHJldHVybiBsaW5rZWRsaXN0O1xuXG4gICAgICAgIHZhciBxdWV1ZSA9IG5ldyBfUXVldWUyLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIGxpc3QgPSBsaW5rZWRsaXN0LmhlYWQ7XG5cbiAgICAgICAgaWYgKCFsaXN0IHx8ICFsaXN0Lm5leHQpIHJldHVybiBsaW5rZWRsaXN0O1xuXG4gICAgICAgIHZhciB1ID0gbGlzdDtcbiAgICAgICAgdmFyIHQgPSBsaXN0O1xuICAgICAgICB2YXIgdiA9IHZvaWQgMDtcbiAgICAgICAgLy8g5bCG6YCS5aKe55qE57uT54K55pS+5YWl5Yiw6Zif5YiX5Lit77yI5Lya6KKr5YiH5pat77yJXG4gICAgICAgIGZvciAoOyB0OyB0ID0gdSkge1xuICAgICAgICAgICAgd2hpbGUgKHUgJiYgdS5uZXh0ICYmIGNvbXAodS5kYXRhLCB1Lm5leHQuZGF0YSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIHUgPSB1Lm5leHQ7XG4gICAgICAgICAgICB9diA9IHU7XG4gICAgICAgICAgICB1ID0gdS5uZXh0O1xuICAgICAgICAgICAgdi5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUodCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAvLyDlkIjlubbnu5PngrlcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnNpemUpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUodCk7XG4gICAgICAgICAgICB2YXIgYSA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgICAgIHZhciBiID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgdCA9IG1lcmdlKGEsIGIsIGNvbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRSZXBsYWNlKSBsaW5rZWRsaXN0LmhlYWQgPSB0O1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIsIGNvbXApIHtcbiAgICAgICAgdmFyIGMgPSBuZXcgX0xpbmtlZExpc3QyLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIGhlYWQgPSB7IGRhdGE6IG51bGwsIG5leHQ6IG51bGwgfTtcbiAgICAgICAgYy5oZWFkID0gaGVhZDtcbiAgICAgICAgYyA9IGMuaGVhZDtcblxuICAgICAgICB3aGlsZSAoYSAmJiBiKSB7XG4gICAgICAgICAgICBpZiAoY29tcChhLmRhdGEsIGIuZGF0YSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgYy5uZXh0ID0gYTtcbiAgICAgICAgICAgICAgICBjID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYS5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjLm5leHQgPSBiO1xuICAgICAgICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjLm5leHQgPSBhID8gYSA6IGI7XG5cbiAgICAgICAgcmV0dXJuIGhlYWQubmV4dDtcbiAgICB9XG59KCk7XG5cbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XG52YXIgbGlua2VkTGlzdCA9IG5ldyBfTGlua2VkTGlzdDIuZGVmYXVsdChhcnIpO1xubGlua2VkTGlzdE5hdHVyYWxNZXJnZVNvcnQobGlua2VkTGlzdCk7XG5jb25zb2xlLmxvZyhsaW5rZWRMaXN0ICsgJycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU29ydC9tZXJnaW5nL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2ltcGxlU2VsZWN0aW9uU29ydCA9IHNpbXBsZVNlbGVjdGlvblNvcnQ7XG5leHBvcnRzLmhlYXBTb3J0ID0gaGVhcFNvcnQ7XG5cbnZhciBfZGVmYXVsdENvbXBhcmlzaW9uID0gcmVxdWlyZSgnLi4vZGVmYXVsdENvbXBhcmlzaW9uJyk7XG5cbnZhciBfZGVmYXVsdENvbXBhcmlzaW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRDb21wYXJpc2lvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qXHJcbumAieaLqeaOkuW6j1xyXG5cclxu6YCJ5oup5o6S5bqPKFNlbGVjdGlvbiBTb3J0KeeahOWfuuacrOaAneaDs+aYr++8muavj+asoeS7juW9k+WJjeW+heaOkuW6j+eahOiusOW9leS4remAieWPluWFs+mUruWtl+acgOWwj+eahOiusOW9leihqO+8jOeEtuWQjuS4juW+heaOkuW6j+eahOiusOW9leW6j+WIl+S4reeahOesrOS4gOS4quiusOW9lei/m+ihjOS6pOaNou+8jOebtOWIsOaVtOS4quiusOW9leW6j+WIl+acieW6j+S4uuatouOAglxyXG5cclxuXHJcbueugOWNlemAieaLqeaOkuW6j1xyXG5cclxu566A5Y2V6YCJ5oup5o6S5bqPKFNpbXBsZSBTZWxlY3Rpb24gU29ydCDvvIzlj4jnp7DkuLrnm7TmjqXpgInmi6nmjpLluo8p55qE5Z+65pys5pON5L2c5piv77ya6YCa6L+Hbi1p5qyh5YWz6ZSu5a2X6Ze055qE5q+U6L6D77yM5LuObi1pKzHkuKrorrDlvZXkuK3pgInlj5blhbPplK7lrZfmnIDlsI/nmoTorrDlvZXvvIznhLblkI7lkoznrKxp5Liq6K6w5b2V6L+b6KGM5Lqk5o2i77yMaT0xLCAyLCDigKYgbi0xIOOAglxyXG4xICDmjpLluo/npLrkvotcclxu5L6L77ya6K6+5pyJ5YWz6ZSu5a2X5bqP5YiX5Li677yaNywgNCwgLTIsIDE5LCAxMywgNu+8jOebtOaOpemAieaLqeaOkuW6j+eahOi/h+eoi++8mlxyXG7liJ3lp4vorrDlvZXnmoTlhbPplK7lrZfvvJogIDcgICAgIDQgICAgLTIgICAgIDE5ICAgIDEzICAgIDZcclxuICAgIOesrOS4gOi2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDcgICAgIDE5ICAgIDEzICAgIDZcclxuICAgIOesrOS6jOi2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDcgICAgIDE5ICAgIDEzICAgIDZcclxuICAgIOesrOS4iei2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDE5ICAgIDEzICAgIDdcclxuICAgIOesrOWbm+i2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDcgICAgIDEzICAgIDE5XHJcbiAgICDnrKzkupTotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICA3ICAgICAxMyAgICAxOVxyXG4gICAg56ys5YWt6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgNyAgICAgMTMgICAgMTlcclxuXHJcbjIu566X5rOV5YiG5p6QXHJcbuaVtOS4queul+azleaYr+S6jOmHjeW+queOr++8muWkluW+queOr+aOp+WItuaOkuW6j+eahOi2n+aVsO+8jOWvuW7kuKrorrDlvZXov5vooYzmjpLluo/nmoTotp/mlbDkuLpuLTHotp/vvJvlhoXlvqrnjq/mjqfliLbmr4/kuIDotp/nmoTmjpLluo/jgIJcclxu6L+b6KGM56ysaei2n+aOkuW6j+aXtu+8jOWFs+mUruWtl+eahOavlOi+g+asoeaVsOS4um4tae+8jOWIme+8mlxyXG7mr5TovoPmrKHmlbDvvJogbioobiAtIDEpIC8gMlxyXG7ml7bpl7TlpI3mnYLluqbmmK/vvJpUKG4pPU8objIpXHJcbuepuumXtOWkjeadguW6puaYr++8mlMobik9TygxKVxyXG7ku47mjpLluo/nmoTnqLPlrprmgKfmnaXnnIvvvIznm7TmjqXpgInmi6nmjpLluo/mmK/kuI3nqLPlrprnmoTjgIJcclxuXHJcbiAqL1xuXG5mdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb25Tb3J0KHNxTGlzdCkge1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRDb21wYXJpc2lvbjIuZGVmYXVsdCA6IGFyZ3VtZW50c1sxXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGsgPSBpO1xuICAgICAgICBmb3IgKHZhciBqID0gayArIDE7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2pdLCBzcUxpc3Rba10pIDwgMCkgayA9IGo7XG4gICAgICAgIH1pZiAoayAhPT0gaSkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3Rba107XG4gICAgICAgICAgICBzcUxpc3Rba10gPSBzcUxpc3RbaV07XG4gICAgICAgICAgICBzcUxpc3RbaV0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfVxufSAvKipcclxuICAgKiBDcmVhdGVkIGJ5IGx1a2Ugb24gMjAxNS8yLzIuXHJcbiAgICovXG5cbnZhciBhcnIgPSBbNywgNCwgLTIsIDE5LCAxMywgNl07XG5zaW1wbGVTZWxlY3Rpb25Tb3J0KGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cbi8qXHJcbuagkeW9oumAieaLqeaOkuW6j1xyXG5cclxu6aaW5YWI5a+5buS4quiusOW9leeahOWFs+mUruWtl+S4pOS4pOi/m+ihjOavlOi+g++8jOmAieWPlu+DqW4vMu+DueS4qui+g+Wwj+iAhe+8m+eEtuWQjui/me+DqW4vMu+DueS4qui+g+Wwj+iAheS4pOS4pOi/m+ihjOavlOi+g++8jOmAieWPlu+DqW4vNO+DueS4qui+g+Wwj+iAheKApiDlpoLmraTph43lpI3vvIznm7TliLDlj6rliakx5Liq5YWz6ZSu5a2X5Li65q2i44CCXHJcbuivpei/h+eoi+WPr+eUqOS4gOajteaciW7kuKrlj7blrZDnu5PngrnnmoTlrozlhajkuozlj4nmoJHooajnpLrvvIzmr4/kuKrmnp3nu5PngrnnmoTlhbPplK7lrZfpg73nrYnkuo7lhbblt6bjgIHlj7PlranlrZDnu5PngrnkuK3ovoPlsI/nmoTlhbPplK7lrZfvvIzmoLnnu5PngrnnmoTlhbPplK7lrZflsLHmmK/mnIDlsI/nmoTlhbPplK7lrZfjgIJcclxu6L6T5Ye65pyA5bCP5YWz6ZSu5a2X5ZCO77yM5qC55o2u5YWz57O755qE5Y+v5Lyg6YCS5oCn77yM5qyy6YCJ5Y+W5qyh5bCP5YWz6ZSu5a2X77yM5Y+q6ZyA5bCG5Y+25a2Q57uT54K55Lit55qE5pyA5bCP5YWz6ZSu5a2X5pS55Li64oCc5pyA5aSn5YC84oCdIO+8jOeEtuWQjumHjeWkjeS4iui/sOatpemqpOWNs+WPr+OAglxyXG7lkKvmnIlu5Liq5Y+25a2Q57uT54K555qE5a6M5YWo5LqM5Y+J5qCR55qE5rex5bqm5Li674Op44+SMm7vg7krMe+8jOWImeaAu+eahOaXtumXtOWkjeadguW6puS4uk8obuOPkjJuKSDjgIJcclxuXHJcbuS9hui/meenjeaOkuW6j+aWueazleWwmuaciei+heWKqeWtmOWCqOepuumXtOi+g+WkmizlkozmnIDlpKflgLzov5vooYzlpJrkvZnmr5TovoPnrYnnvLrngrnjgILkuLrkuoblvKXooaXov5nkupvnvLrpmbfvvIzlh7rnjrDkuoblj6bkuIDnp43pgInmi6nmjpLluo8tLS3loIbmjpLluo9cclxuICovXG5cbi8qXHJcbuWghuaOkuW6j1xyXG5cclxuMSAg5aCG55qE5a6a5LmJXHJcbuaYr27kuKrlhYPntKDnmoTluo/liJdIPXtrMSwgazIgLCDigKYga259IO+8jOa7oei2s++8mlxyXG4gICAga2niiaRrMmkgICAgICAg5b2TMmniiaRu5pe2XHJcbiAgICBraeKJpGsyaSsxICAg5b2TMmkrMeKJpG7ml7ZcclxuXHJcbueUseWghueahOWumuS5ieefpe+8jOWghuaYr+S4gOajteS7pWsx5Li65qC555qE5a6M5YWo5LqM5Y+J5qCR44CC6Iul5a+56K+l5LqM5Y+J5qCR55qE57uT54K56L+b6KGM57yW5Y+3KOS7juS4iuWIsOS4i++8jOS7juW3puWIsOWPsynvvIzlvpfliLDnmoTluo/liJflsLHmmK/lsIbkuozlj4nmoJHnmoTnu5Pngrnku6Xpobrluo/nu5PmnoTlrZjmlL7vvIzloIbnmoTnu5PmnoTmraPlpb3lkozor6Xluo/liJfnu5PmnoTlrozlhajkuIDoh7TjgIJcclxuXHJcbjIgIOWghueahOaAp+i0qFxyXG4gICAgMSkgIOWghuaYr+S4gOajtemHh+eUqOmhuuW6j+WtmOWCqOe7k+aehOeahOWujOWFqOS6jOWPieagke+8jCBrMeaYr+aguee7k+eCue+8m1xyXG4gICAgMikgIOWghueahOaguee7k+eCueaYr+WFs+mUruWtl+W6j+WIl+S4reeahOacgOWwjyjmiJbmnIDlpKcp5YC877yM5YiG5Yir56ew5Li65bCPKOaIluWkpynmoLnloIbvvJtcclxuICAgIDMpICDku47moLnnu5PngrnliLDmr4/kuIDlj7blrZDnu5Pngrnot6/lvoTkuIrnmoTlhYPntKDnu4TmiJDnmoTluo/liJfpg73mmK/mjInlhYPntKDlgLwo5oiW5YWz6ZSu5a2X5YC8KemdnumAkuWHjyjmiJbpnZ7pgJLlop4p55qE77ybXHJcbiAgICA0KSAg5aCG5Lit55qE5Lu75LiA5a2Q5qCR5Lmf5piv5aCG44CCXHJcblxyXG7liKnnlKjloIbpobborrDlvZXnmoTlhbPplK7lrZflgLzmnIDlsI8o5oiW5pyA5aSnKeeahOaAp+i0qO+8jOS7juW9k+WJjeW+heaOkuW6j+eahOiusOW9leS4reS+neasoemAieWPluWFs+mUruWtl+acgOWwjyjmiJbmnIDlpKcp55qE6K6w5b2V77yM5bCx5Y+v5Lul5a6e546w5a+55pWw5o2u6K6w5b2V55qE5o6S5bqP77yM6L+Z56eN5o6S5bqP5pa55rOV56ew5Li65aCG5o6S5bqP44CCXHJcblxyXG4zICDloIbmjpLluo/mgJ3mg7NcclxuXHJcbuKRoCAg5a+55LiA57uE5b6F5o6S5bqP55qE6K6w5b2V77yM5oyJ5aCG55qE5a6a5LmJ5bu656uL5aCG77ybXHJcbuKRoSAg5bCG5aCG6aG26K6w5b2V5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V5Lqk5o2i5L2N572u77yM5YiZ5YmNbi0x5Liq6K6w5b2V5piv5peg5bqP55qE77yM6ICM5pyA5ZCO5LiA5Liq6K6w5b2V5piv5pyJ5bqP55qE77ybXHJcbuKRoiAg5aCG6aG26K6w5b2V6KKr5Lqk5o2i5ZCO77yM5YmNbi0x5Liq6K6w5b2V5LiN5YaN5piv5aCG77yM6ZyA5bCG5YmNbi0x5Liq5b6F5o6S5bqP6K6w5b2V6YeN5paw57uE57uH5oiQ5Li65LiA5Liq5aCG77yM54S25ZCO5bCG5aCG6aG26K6w5b2V5ZKM5YCS5pWw56ys5LqM5Liq6K6w5b2V5Lqk5o2i5L2N572u77yM5Y2z5bCG5pW05Liq5bqP5YiX5Lit5qyh5bCP5YWz6ZSu5a2X5YC855qE6K6w5b2V6LCD5pW0KOaOkumZpCnlh7rml6Dluo/ljLrvvJtcclxu4pGjICDph43lpI3kuIrov7DmraXpqqTvvIznm7TliLDlhajpg6jorrDlvZXmjpLlpb3luo/kuLrmraLjgIJcclxuXHJcbue7k+iuuu+8muaOkuW6j+i/h+eoi+S4re+8jOiLpemHh+eUqOWwj+agueWghu+8jOaOkuW6j+WQjuW+l+WIsOeahOaYr+mdnumAkuWHj+W6j+WIl++8m+iLpemHh+eUqOWkp+agueWghu+8jOaOkuW6j+WQjuW+l+WIsOeahOaYr+mdnumAkuWinuW6j+WIl+OAglxyXG5cclxu5aCG5o6S5bqP55qE5YWz6ZSuXHJcbuKRoCAg5aaC5L2V55Sx5LiA5Liq5peg5bqP5bqP5YiX5bu65oiQ5LiA5Liq5aCG77yfXHJcbuKRoSAg5aaC5L2V5Zyo6L6T5Ye65aCG6aG25YWD57Sg5LmL5ZCO77yM6LCD5pW05Ymp5L2Z5YWD57Sg77yM5L2/5LmL5oiQ5Li65LiA5Liq5paw55qE5aCG77yfXHJcblxyXG40ICDloIbnmoTosIPmlbTigJTigJTnrZvpgIlcclxu4pG0IOWghueahOiwg+aVtOaAneaDs1xyXG7ovpPlh7rloIbpobblhYPntKDkuYvlkI7vvIzku6XloIbkuK3mnIDlkI7kuIDkuKrlhYPntKDmm7/ku6PkuYvvvJvnhLblkI7lsIbmoLnnu5PngrnlgLzkuI7lt6bjgIHlj7PlrZDmoJHnmoTmoLnnu5PngrnlgLzov5vooYzmr5TovoPvvIzlubbkuI7lhbbkuK3lsI/ogIXov5vooYzkuqTmjaLvvJvph43lpI3kuIrov7Dmk43kvZzvvIznm7TliLDmmK/lj7blrZDnu5PngrnmiJblhbblhbPplK7lrZflgLzlsI/kuo7nrYnkuo7lt6bjgIHlj7PlrZDmoJHnmoTlhbPplK7lrZfnmoTlgLzvvIzlsIblvpfliLDmlrDnmoTloIbjgILnp7Dov5nkuKrku47loIbpobboh7Plj7blrZDnmoTosIPmlbTov4fnqIvkuLrigJznrZvpgInigJ3jgIJcclxuXHJcbuazqOaEj++8muetm+mAiei/h+eoi+S4re+8jOaguee7k+eCueeahOW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWboOatpO+8jOetm+mAieaYr+S7juaguee7k+eCueWIsOafkOS4quWPtuWtkOe7k+eCueeahOS4gOasoeiwg+aVtOi/h+eoi+OAglxyXG5cclxuNSAg5aCG55qE5bu656uLXHJcbuWIqeeUqOetm+mAieeul+azle+8jOWPr+S7peWwhuS7u+aEj+aXoOW6j+eahOiusOW9leW6j+WIl+W7uuaIkOS4gOS4quWghu+8jOiuvlJbMV0sUlsyXSwg4oCmLFJbbl3mmK/lvoXmjpLluo/nmoTorrDlvZXluo/liJfjgIJcclxu5bCG5LqM5Y+J5qCR55qE5q+P5qO15a2Q5qCR6YO9562b6YCJ5oiQ5Li65aCG44CC5Y+q5pyJ5qC557uT54K555qE5qCR5piv5aCG44CC56ys4oyKbi8y4oyL5Liq57uT54K55LmL5ZCO55qE5omA5pyJ57uT54K56YO95rKh5pyJ5a2Q5qCR77yM5Y2z5Lul56ys4oyKbi8y4oyL5Liq57uT54K55LmL5ZCO55qE57uT54K55Li65qC555qE5a2Q5qCR6YO95piv5aCG44CC5Zug5q2k77yM5Lul6L+Z5Lqb57uT54K55Li65bem44CB5Y+z5a2p5a2Q55qE57uT54K577yM5YW25bem44CB5Y+z5a2Q5qCR6YO95piv5aCG77yM5YiZ6L+b6KGM5LiA5qyh562b6YCJ5bCx5Y+v5Lul5oiQ5Li65aCG44CC5ZCM55CG77yM5Y+q6KaB5bCG6L+Z5Lqb57uT54K555qE55u05o6l54i257uT54K56L+b6KGM5LiA5qyh562b6YCJ5bCx5Y+v5Lul5oiQ5Li65aCG4oCm44CCXHJcbuWPqumcgOS7juesrOKMim4vMuKMi+S4quiusOW9leWIsOesrDHkuKrorrDlvZXkvp3mrKHov5vooYznrZvpgInlsLHlj6/ku6Xlu7rnq4vloIbjgIJcclxuXHJcbjYgICDloIbmjpLluo/nrpfms5Xlrp7njrBcclxu5aCG55qE5qC557uT54K55piv5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V77yM6L6T5Ye65qC557uT54K55ZCO77yM5piv5Lul5bqP5YiX55qE5pyA5ZCO5LiA5Liq6K6w5b2V5L2c5Li65qC557uT54K577yM6ICM5Y6f5p2l5aCG55qE5bem44CB5Y+z5a2Q5qCR6YO95piv5aCG77yM5YiZ6L+b6KGM5LiA5qyh562b6YCJ5bCx5Y+v5Lul5oiQ5Li65aCG44CCXHJcblxyXG43ICDnrpfms5XliIbmnpBcclxu5Li76KaB6L+H56iL77ya5Yid5aeL5bu65aCG5ZKM6YeN5paw6LCD5pW05oiQ5aCG44CC6K6+6K6w5b2V5pWw5Li6bu+8jOaJgOWvueW6lOeahOWujOWFqOS6jOWPieagkea3seW6puS4umgg44CCXHJcbuKXhiAg5Yid5aeL5bu65aCG77ya5q+P5Liq6Z2e5Y+25a2Q57uT54K56YO96KaB5LuO5LiK5Yiw5LiL5YGa4oCc562b6YCJ4oCdIOOAguesrGnlsYLnu5PngrnmlbDiiaQyaS0x77yM57uT54K55LiL56e755qE5pyA5aSn5rex5bqm5pivaC1p77yM6ICM5q+P5LiL56e75LiA5bGC6KaB5q+U6L6DMuasoe+8jOWImeavlOi+g+asoeaVsEMxKG4p5Li677yaXHJcbkMxKG4p4omkNChuLeOPkjJuLTEpXHJcbuKXhiAg562b6YCJ6LCD5pW077ya5q+P5qyh562b6YCJ6KaB5bCG5qC557uT54K54oCc5LiL5rKJ4oCd5Yiw5LiA5Liq5ZCI6YCC5L2N572u44CC56ysaeasoeetm+mAieaXtu+8muWghuS4reWFg+e0oOS4quaVsOS4um4taSsx77yb5aCG55qE5rex5bqm5piv74Or44+SMihuLWkrMSnvg7srMe+8jOWImei/m+ihjG4tMeasoeKAnOetm+mAieKAneeahOavlOi+g+asoeaVsEMyKG4p5Li677yaXHJcbkMyKG4pPDJu44+SMm5cclxu5aCG5o6S5bqP55qE5q+U6L6D5qyh5pWw55qE5pWw6YeP57qn5Li677yaIFQobik9Tyhu44+SMm4p77yb6ICM6ZmE5Yqg56m66Ze05bCx5piv5Lqk5o2i5pe25omA55So55qE5Li05pe256m66Ze077yM5pWF56m66Ze05aSN5p2C5bqm5Li677yaIFMobik9TygxKSDjgIJcclxuXHJcbuWghuaOkuW6j+mAguWQiOiusOW9leaVsOi+g+Wkp+eahOaDheWGtVxyXG5cclxuXHJcbmh0dHA6Ly9ibG9nLmNzZG4ubmV0L3p6MTk4ODA4L2FydGljbGUvZGV0YWlscy83Njc4MDU1XHJcbiAqL1xuXG4vKipcclxuICog5bey55+lc3FMaXN0W3MuLm1d5Lit6K6w5b2V55qE5YWz6ZSu5a2X6Zmkc3FMaXN0W3Nd5LmL5aSW5Z2H5ruh6Laz5aCG55qE5a6a5LmJ77yMXHJcbiAqIOacrOWHveaVsOiwg+aVtHNxTGlzdFtzXeeahOWFs+mUruWtl++8jOS9v3NxTGlzdFtzLi5tXeaIkOS4uuS4gOS4quWkp+Wghumhtu+8iOWvueWFtuS4reWFs+mUruWtl+iAjOiogO+8iVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcUxpc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1cclxuICovXG5mdW5jdGlvbiBoZWFwQWRqdXN0KHNxTGlzdCwgcywgbSwgY29tcCkge1xuICAgIHZhciByYyA9IHNxTGlzdFtzXTtcblxuICAgIC8vIOayv+WFs+mUruWtl+i+g+Wkp+eahOWtqeWtkOe7k+eCueWQkeS4i+etm+mAiVxuICAgIGZvciAodmFyIGogPSAyICogcyArIDE7IGogPD0gbTsgaiA9IGogKiAyICsgMSkge1xuICAgICAgICAvLyBq5Li65YWz6ZSu5a2X6L6D5aSn55qE6K6w5b2V5LiL5qCHXG4gICAgICAgIGlmIChqIDwgbSAmJiBjb21wKHNxTGlzdFtqXSwgc3FMaXN0W2ogKyAxXSkgPCAwKSArK2o7XG4gICAgICAgIC8vIHJj5bqU5o+S5YWl5Zyo5L2N572uc+S4ilxuICAgICAgICBpZiAoY29tcChyYywgc3FMaXN0W2pdKSA+PSAwKSBicmVhaztcbiAgICAgICAgc3FMaXN0W3NdID0gc3FMaXN0W2pdO1xuICAgICAgICBzID0gajtcbiAgICB9XG5cbiAgICBzcUxpc3Rbc10gPSByYztcbn1cblxuZnVuY3Rpb24gaGVhcFNvcnQoc3FMaXN0KSB7XG4gICAgdmFyIGNvbXAgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfZGVmYXVsdENvbXBhcmlzaW9uMi5kZWZhdWx0IDogYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIGxlbiA9IHNxTGlzdC5sZW5ndGg7XG4gICAgLy8g5bu656uL5aSn5aCG6aG2XG4gICAgZm9yICh2YXIgaSA9IChsZW4gPj4gMSkgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBoZWFwQWRqdXN0KHNxTGlzdCwgaSwgbGVuIC0gMSwgY29tcCk7XG4gICAgfWZvciAodmFyIF9pID0gbGVuIC0gMTsgX2kgPiAwOyAtLV9pKSB7XG4gICAgICAgIC8vIOWwhuWghumhtuiusOW9leWSjOW9k+WJjeacque7j+aOkuW6j+WtkOW6j+WIl3NxTGlzdFswLi5pXeS4rVxuICAgICAgICAvLyDmnIDlkI7kuIDkuKrorrDlvZXnm7jkupLkuqTmjaJcbiAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbX2ldO1xuICAgICAgICBzcUxpc3RbX2ldID0gc3FMaXN0WzBdO1xuICAgICAgICBzcUxpc3RbMF0gPSB0ZW1wO1xuXG4gICAgICAgIC8vIOWwhnNxTGlzdFswLi5pIC0gMV3ph43mlrDosIPmlbTkuLrlpKfloIbpobZcbiAgICAgICAgaGVhcEFkanVzdChzcUxpc3QsIDAsIF9pIC0gMSwgY29tcCk7XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzEsIDMsIDQsIDUsIDcsIDIsIDYsIDgsIDBdO1xuaGVhcFNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL1NvcnQvc2VsZWN0aW9uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiDloIbliIbphY3lrZjlgqjooajnpLpcclxuICpcclxuICog6L+Z56eN5a2Y5YKo6KGo56S655qE54m554K55piv77yM5LuN5Lul5LiA57uE5Zyw5Z2A6L+e57ut55qE5a2Y5YKo5Y2V5YWD5a2Y5pS+5Liy5YC85a2X56ym5bqP5YiX77yM5L2G5a6D5Lus55qE5a2Y5YKo56m66Ze05piv5Zyo56iL5bqP5omn6KGM6L+H56iL5Lit5Yqo5oCB5YiG6YWN6ICM5b6X44CC5ZyoY+ivreiogOS4re+8jOWtmOWcqOS4gOS4quensOS5i+S4uuKAnOWghuKAneeahOiHqueUseWtmOWCqOWMuu+8jOW5tueUsWPor63oqIDnmoTliqjmgIHliIbphY3lh73mlbBtYWxsb2MoKeWSjGZyZWUoKeadpeeuoeeQhuOAguWIqeeUqOWHveaVsG1hbGxvYygp5Li65q+P5Liq5paw5Lqn55Sf55qE5Liy5YiG6YWN5LiA5Z2X5a6e6ZmF5Liy6ZW/5omA6ZyA55qE5a2Y5YKo56m66Ze044CCXHJcbiAqL1xuXG52YXIgSFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIU3RyaW5nKCkge1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBIU3RyaW5nKTtcblxuICAgICAgICB0aGlzLmNoID0ge307XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvLyAxIDw9IHBvc2l0aW9uIDw9IHRoaXMubGVuZ3RoLuWcqOS4sueahOesrHBvc2l0aW9u5Liq5a2X56ym5LmL5YmN5o+S5YWl5LiydEhTdHJpbmdcblxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoSFN0cmluZywgW3tcbiAgICAgICAga2V5OiAnc3RySW5zZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0ckluc2VydChwb3NpdGlvbiwgdEhTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDEgfHwgcG9zaXRpb24gPiB0aGlzLmxlbmd0aCArIDEpIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwb3NpdGlvbicpO1xuXG4gICAgICAgICAgICBpZiAodEhTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8g5Li65o+S5YWldOiAjOiFvuWHuuS9jee9rlxuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxlbiA9IHBvc2l0aW9uIC0gMTsgaSA+PSBsZW47IC0taSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoW2kgKyB0SFN0cmluZy5sZW5ndGhdID0gdGhpcy5jaFtpXTtcbiAgICAgICAgICAgICAgICB9c3RyaW5nQ29weSh0aGlzLmNoLCB0SFN0cmluZy5jaCwgcG9zaXRpb24gLSAxLCB0SFN0cmluZy5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRIU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RyQXNzaWduJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0ckFzc2lnbihjaGFycykge1xuICAgICAgICAgICAgc3RyaW5nQ29weSh0aGlzLmNoLCBjaGFycywgMCwgY2hhcnMubGVuZ3RoIC0gMSwgMCk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RyTGVuZ3RoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0ckxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RyQ29tcGFyZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJDb21wYXJlKHRIU3RyaW5nKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW4gJiYgaSA8IHRIU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hbaV0gIT09IHRIU3RyaW5nLmNoW2ldKSByZXR1cm4gdGhpcy5jaFtpXSAtIHRIU3RyaW5nLmNoW2ldO1xuICAgICAgICAgICAgfXJldHVybiB0aGlzLmxlbmd0aCAtIHRIU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xlYXJTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJTdHJpbmcoKSB7XG4gICAgICAgICAgICB0aGlzLmNoID0ge307XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbmNhdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQocykge1xuICAgICAgICAgICAgdmFyIHQgPSBuZXcgSFN0cmluZygpO1xuXG4gICAgICAgICAgICAvLyB0LmNoWzAuLnRoaXMubGVuZ3RoIC0gMV0gPSB0aGlzLmNoWzAuLnRoaXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIHN0cmluZ0NvcHkodC5jaCwgdGhpcy5jaCwgMCwgdGhpcy5sZW5ndGggLSAxLCAwKTtcbiAgICAgICAgICAgIHQubGVuZ3RoID0gdGhpcy5sZW5ndGggKyBzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIHQuY2hbdGhpcy5sZW5ndGguLnQubGVuZ3RoIC0gMV0gPSBzLmNoWzAuLnMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIHN0cmluZ0NvcHkodC5jaCwgcy5jaCwgdGhpcy5sZW5ndGgsIHMubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic3RyaW5nKHBvc2l0aW9uLCBsZW4pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gfn5wb3NpdGlvbiB8fCAwO1xuICAgICAgICAgICAgbGVuID0gfn5sZW4gfHwgdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpcy5sZW5ndGggLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpcy5sZW5ndGggLSBwb3NpdGlvbikgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBhcmFtZXRlcicpO1xuXG4gICAgICAgICAgICB2YXIgc3ViID0gbmV3IEhTdHJpbmcoKTtcbiAgICAgICAgICAgIHN0cmluZ0NvcHkoc3ViLmNoLCB0aGlzLmNoLCAwLCBsZW4gLSAxLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBzdWIubGVuZ3RoID0gbGVuO1xuXG4gICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHMgKz0gdGhpcy5jaFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBIU3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIU3RyaW5nO1xuXG5cbmZ1bmN0aW9uIHN0cmluZ0NvcHkoZGVzdGluYXRpb24sIHRhcmdldCwgZGVzdFN0YXJ0LCBsZW5ndGgsIHRhcmdldFN0YXJ0KSB7XG4gICAgZGVzdFN0YXJ0ID0gZGVzdFN0YXJ0IHx8IDA7XG4gICAgbGVuZ3RoID0gbGVuZ3RoIHx8IHRhcmdldC5sZW5ndGg7XG4gICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXRTdGFydCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVzdGluYXRpb25bZGVzdFN0YXJ0ICsgaV0gPSB0YXJnZXRbdGFyZ2V0U3RhcnQgKyBpXTtcbiAgICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9TdHJpbmcvSFN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vU3RhY2svaW5kZXgnKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBDaHVuayA9IGZ1bmN0aW9uIENodW5rKCkge1xuICAgIHZhciBjaHVua1NpemUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyA0IDogYXJndW1lbnRzWzBdO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIENodW5rKTtcblxuICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgIHRoaXMuY2ggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtTaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaFtpXSA9ICcjJztcbiAgICB9XG4gICAgLy8gdHlwZTogQ2h1bmtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xufTsgLyoqXHJcbiAgICAqIOS4sueahOWdl+mTvuWtmOWCqOihqOekulxyXG4gICAgKlxyXG4gICAgKiDlkoznur/mgKfooajnmoTpk77lvI/lrZjlgqjnu5PmnoTnm7jnsbvkvLzvvIzkuZ/lj6/ph4fnlKjpk77lvI/mlrnlvI/lrZjlgqjkuLLlgLzjgILnlLHkuo7kuLLnu5PmnoTnmoTnibnmrormgKctLee7k+aehOS4reeahOavj+S4quaVsOaNruWFg+e0oOaYr+S4gOS4quWtl+espu+8jOWImeeUqOmTvuihqOWtmOWCqOS4suWAvOaXtu+8jOWtmOWcqOS4gOS4quKAnOe7k+eCueWkp+Wwj+KAneeahOmXrumimO+8jOWNs+avj+S4que7k+eCueWPr+S7peWtmOaUvuS4gOS4quWtl+espu+8jOS5n+WPr+S7peWtmOaUvuWkmuS4quWtl+espuOAglxyXG4gICAgKiDkuIvpnaLmmK/nu5PngrnlpKflsI/kuLo077yI5Y2z5q+P5Liq57uT54K55a2Y5pS+NOS4quWtl+espu+8ieeahOmTvuihqFxyXG4gICAgKiBoZWFkIC0tPiAoYSxiLGMsZCkgLS0+IChlLGYsZyxoKSAtLT4gKGkjIyMpXHJcbiAgICAqIOS4i+mdouaYr+e7k+eCueWkp+Wwj+S4ujHnmoTpk77ooahcclxuICAgICogaGVhZCAtLT4gKGEpIC0tPiAoYikgLS0+IChjKSAtLT4gLi4uIC0tPiAoaSlcclxuICAgICpcclxuICAgICog5b2T57uT54K55aSn5bCP5aSn5LqOMeaXtu+8jOeUseS6juS4sumVv+S4jeS4gOWumuaYr+e7k+eCueWkp+Wwj+eahOaVtOWAjeaVsO+8jOWImemTvuihqOS4reeahOacgOWQjuS4gOS4que7k+eCueS4jeS4gOWumuWFqOiiq+S4suWAvOWNoOa7oe+8jOatpOaXtumAmuW4uOihpeS4iuKAnCPigJ3miJblhbblroPpnZ7kuLLlgLzlrZfnrKbjgIJcclxuICAgICog5Li65LqG5L6/5LqO6L+b6KGM5Liy55qE5pON5L2c77yM5b2T5Lul6ZO+6KGo5a2Y5YKo5Liy5YC85pe277yM6Zmk5aS05oyH6ZKI5aSW6L+Y5Y+v6ZmE6K6+5LiA5Liq5bC+5oyH6ZKI5oyH56S66ZO+6KGo5Lit55qE5pyA5ZCO5LiA5Liq57uT54K577yM5bm257uZ5Ye65b2T5YmN5Liy55qE6ZW/5bqm77yM56ew5aaC5q2k5a6a5LmJ55qE5Liy5a2Y5YKo57uT5p6E5Li65Z2X6ZO+57uT5p6E44CCXHJcbiAgICAqXHJcbiAgICAqIOeUseS6juS4gOiIrOaDheWGteS4i++8jOWvueS4sui/m+ihjOaTjeS9nOaXtu+8jOWPqumcgOimgeS7juWktOWQkeWwvumhuuW6j+aJq+aPj+WNs+WPr++8jOWImeWvueS4suWAvOS4jeW/heW7uueri+WPjOWQkemTvuihqOOAguiuvuWwvuaMh+mSiOeahOebrueahOaYr+S4uuS6huS+v+S6jui/m+ihjOi/nuaOpeaTjeS9nO+8jOS9huW6lOazqOaEj+i/nuaOpeaXtumcgOWkhOeQhuesrOS4gOS4quS4suWwvueahOaXoOaViOWtl+espuOAglxyXG4gICAgKiDlnKjpk77lvI/lrZjlgqjmlrnlvI/kuK3vvIznu5PngrnlpKflsI/nmoTpgInmi6nlkozpobrluo/lrZjlgqjmlrnlvI/nmoTmoLzlvI/pgInmi6nkuIDmoLfpg73lvojph43opoHvvIzlroPnm7TmjqXlvbHlk43liLDkuLLlpITnkIbnmoTmlYjnjofjgILlpoLmnpzkuLLlvojplb/vvIzov5nopoHmsYLmiJHku6zogIPomZHkuLLlgLznmoTlrZjlgqjlr4bluqbvvJpcclxuICAgICog5a2Y5YKo5a+G5bqmID0g5Liy5YC85omA5Y2g55qE5a2Y5YKo5L2NIC8g5a6e6ZmF5YiG6YWN55qE5a2Y5YKo5L2NXHJcbiAgICAqXHJcbiAgICAqIOS4suWAvOeahOmTvuW8j+WtmOWCqOe7k+aehOWvueafkOS6m+S4suaTjeS9nO+8jOWmgui/nuaOpeaTjeS9nOetieacieS4gOWumuaWueS+v+S5i+WkhO+8jOS9huaAu+eahOadpeivtOS4jeWmguWPpuWkluS4pOenjeWtmOWCqOe7k+aehOeBtea0u++8jOWug+WNoOeUqOWtmOWCqOmHj+Wkp+S4lOaTjeS9nOWkjeadguOAglxyXG4gICAgKi9cblxuXG52YXIgTFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMU3RyaW5nKCkge1xuICAgICAgICB2YXIgY2h1bmtTaXplID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gNCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgTFN0cmluZyk7XG5cbiAgICAgICAgLy8gdHlwZSBDaHVua1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICAvLyB0eXBlOiBjaHVua1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAvLyDkuLLnmoTlvZPliY3plb/luqZcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvLyDlsIblrZfnrKbkuLLovazmjaLmiJBMU3RyaW5n57G75Z6LXG5cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKExTdHJpbmcsIFt7XG4gICAgICAgIGtleTogJ3N0ckFzc2lnbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJBc3NpZ24oY2hhcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hhcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNoW2kgJSB0aGlzLmNodW5rU2l6ZV0gPSBjaGFyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4gJiYgKGkgKyAxKSAlIHRoaXMuY2h1bmtTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IG5ldyBDaHVuaygpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50YWlsID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyDlrZfnrKbkuLLlr7nmr5RcbiAgICAgICAgLy8gVE9ETyDmmK/lkKbljrvmjoljaHVua1NpemXnmoTlr7nmr5RcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RyQ29tcGFyZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJDb21wYXJlKHRMU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHZhciBjdXJUID0gdExTdHJpbmcuaGVhZDtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB0TFN0cmluZy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hbaV0gIT09IGN1clQuY2hbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIGN1clQgPSBjdXJULm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhclN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclN0cmluZygpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbmNhdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQodExTdGluZykge1xuICAgICAgICAgICAgaWYgKCF0TFN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IExTdHJpbmcodGhpcy5jaHVua1NpemUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQuaGVhZCA9IHJldC50YWlsID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSByZXQudGFpbC5jaC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdExTdGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcsIHJldC50YWlsLCB0TFN0aW5nLmhlYWQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N1YnN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzdHJpbmcocG9zLCBsZW4pIHtcbiAgICAgICAgICAgIHBvcyA9IH5+cG9zIHx8IDA7XG4gICAgICAgICAgICBsZW4gPSB+fmxlbiB8fCB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoIC0gMSB8fCBsZW4gPCAwIHx8IGxlbiA+IHRoaXMubGVuZ3RoIC0gcG9zKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgICAgIHZhciBzdWIgPSBuZXcgTFN0cmluZyh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGZpbmRQb3NDaHVuayh0aGlzLCBwb3MpO1xuICAgICAgICAgICAgdmFyIGN1clMgPSBzdWIuaGVhZCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBzdWIubGVuZ3RoID0gbGVuO1xuXG4gICAgICAgICAgICBvdXRlcmxvb3A6IHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIHNpemUgPSB0aGlzLmNodW5rU2l6ZTsgaiA8IHNpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcmxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTLmNoW2pdID0gY3VycmVudC5jaFsoaSArIHBvcykgJSB0aGlzLmNodW5rU2l6ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyBwb3MpICUgdGhpcy5jaHVua1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCAmJiAoY3VycmVudC5jaFtpXSB8fCBjdXJyZW50Lm5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyUy5uZXh0ID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJTID0gY3VyUy5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGN1cnJlbnQuY2hbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGN1cnJlbnQuY2hbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTFN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTFN0cmluZztcblxuXG5mdW5jdGlvbiBmaW5kUG9zQ2h1bmsobFN0cmluZywgcG9zKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBsU3RyaW5nLmhlYWQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxTdHJpbmcuY2h1bmtTaXplOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwb3MtLSA9PT0gMCkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlTdHJpbmcoZGVzdGluYXRpb24sIHRhcmdldCwgY3VyRCwgY3VyclQsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIGN1cnJUID0gY3VyclQgfHwgdGFyZ2V0LmhlYWQ7XG4gICAgY3VyRCA9IGN1ckQgfHwgZGVzdGluYXRpb24uaGVhZDtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoY3VyclQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldC5jaHVua1NpemU7IGkgPCBsZW47IGkrKywgaysrKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGsgJSBjdXJELmNodW5rU2l6ZSArIG9mZnNldDtcbiAgICAgICAgICAgIGN1ckQuY2hbaiAlIGN1ckQuY2h1bmtTaXplXSA9IGN1cnJULmNoW2ldO1xuXG4gICAgICAgICAgICBpZiAoKGogKyAxKSAlIGN1ckQuY2h1bmtTaXplID09PSAwICYmIChjdXJyVC5jaFtpICsgMV0gfHwgY3VyclQubmV4dCkpIHtcbiAgICAgICAgICAgICAgICBjdXJELm5leHQgPSBuZXcgQ2h1bmsoZGVzdGluYXRpb24uY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICBjdXJEID0gY3VyRC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VyclQgPSBjdXJyVC5uZXh0O1xuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uLnRhaWwgPSBjdXJEO1xuICAgIGRlc3RpbmF0aW9uLmxlbmd0aCArPSB0YXJnZXQubGVuZ3RoO1xufVxuXG52YXIgYSA9IG5ldyBMU3RyaW5nKCk7XG52YXIgYiA9IG5ldyBMU3RyaW5nKCk7XG52YXIgYyA9IG5ldyBMU3RyaW5nKCk7XG5cbmEuc3RyQXNzaWduKCdhYmNkZWZnJyk7XG5jb25zb2xlLmxvZyhhICsgJycpO1xuYi5zdHJBc3NpZ24oJ2hpamtsbW5vJyk7XG5jb25zb2xlLmxvZyhiICsgJycpO1xuYy5zdHJBc3NpZ24oJ2FiY2RlZmcnKTtcbmNvbnNvbGUubG9nKGEuc3RyQ29tcGFyZShiKSk7XG5jb25zb2xlLmxvZyhhLnN0ckNvbXBhcmUoYykpO1xudmFyIHQgPSBhLmNvbmNhdChiKTtcbmNvbnNvbGUubG9nKHQgKyAnJyk7XG50ID0gdC5zdWJzdHJpbmcoMiwgNSk7XG5jb25zb2xlLmxvZyh0ICsgJycpO1xuXG4vLyDliKTmlq3mmK/lkKbkuLrlm57mloflrZfnrKbkuLJcbmZ1bmN0aW9uIHBhbGluZHJvbWUobFN0cikge1xuICAgIHZhciBzdGFjayA9IG5ldyBfaW5kZXgyLmRlZmF1bHQoKTtcbiAgICB2YXIgcCA9IGxTdHIuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8PSBsU3RyLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGlmIChrIDw9IGxTdHIubGVuZ3RoIC8gMikgc3RhY2sucHVzaChwLmNoW2ldKTtlbHNlIGlmIChrID4gKGxTdHIubGVuZ3RoICsgMSkgLyAyKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwLmNoW2ldICE9PSBfYykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsraSA9PT0gbFN0ci5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU3RyaW5nL0xTdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIOS4su+8iHN0cmluZ++8ie+8iOaIluWtl+espuS4su+8ieaYr+eUsembtuS4quaIluWkmuS4quWtl+espue7hOaIkOeahOaciemZkOW6j+WIl+OAguS4suS4reWtl+espueahOaVsOebruensOS4uuS4sueahOmVv+W6puOAgumbtuS4quWtl+espueahOS4suensOS4uuepuuS4su+8iG51bGwgc3RyaW5n77yJ77yM5a6D55qE6ZW/5bqm5Li66Zu244CCXHJcbiAqIOS4suS4reS7u+aEj+S4qui/nue7reeahOWtl+espue7hOaIkOeahOWtkOW6j+WIl+ensOS4uuivpeS4sueahOWtkOS4suOAguWMheWQq+WtkOS4sueahOS4suebuOW6lOWcsOensOS4uuS4u+S4suOAgumAmuW4uOensOWtl+espuWcqOW6j+WIl+S4reeahOW6j+WPt+S4uuivpeWtl+espuWcqOS4suS4reeahOS9jee9ruOAguWtkOS4suWcqOS4u+S4suS4reeahOS9jee9ruWImeS7peWtkOS4sueahOesrOS4gOS4quWtl+espuWcqOS4u+S4suS4reeahOS9jee9ruadpeihqOekuuOAglxyXG4gKiDlj6rmnInlvZPkuKTkuKrkuLLnmoTplb/luqbnm7jnrYnvvIzlubbkuJTlkITkuKrlr7nlupTkvY3nva7nmoTlrZfnrKbpg73nm7jnrYnml7bmiY3nm7jnrYnjgIJcclxuICpcclxuICog5Liy5pyJM+enjeacuuWGheihqOekuuaWueazle+8mlxyXG4gKiAxLuWumumVv+mhuuW6j+WtmOWCqOihqOekulxyXG4gKiAyLuWghuWIhumFjeWtmOWCqOihqOekulxyXG4gKiAzLuS4sueahOWdl+mTvuWtmOWCqOihqOekulxyXG4gKi9cblxuLyoqXHJcbiAqIOWumumVv+mhuuW6j+WtmOWCqOihqOekulxyXG4gKiDnsbvkvLzkuo7nur/mgKfooajnmoTpobrluo/lrZjlgqjnu5PmnoTvvIznlKjkuIDnu4TlnLDlnYDov57nu63nmoTlrZjlgqjljZXlhYPlrZjlgqjkuLLlgLzlvpflrZfnrKbluo/liJfjgILlnKjkuLLnmoTlrprplb/pobrluo/lrZjlgqjnu5PmnoTkuK3vvIzmjInnhafpooTlrprkuYnnmoTlpKflsI/vvIzkuLrmr4/kuKrlrprkuYnnmoTkuLLlj5jph4/liIbphY3kuIDkuKrlm7rlrprplb/luqbnmoTlrZjlgqjljLrvvIzliJnlj6/nlKjlrprplb/mlbDnu4TmnaXmj4/ov7DjgIJcclxuICog5Lul5LiL5qCH5Li6MOeahOaVsOe7hOWIhumHj+WtmOaUvuS4sueahOWunumZhemVv+W6puOAglxyXG4gKi9cblxudmFyIFNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU1N0cmluZyhzdHIpIHtcbiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU1N0cmluZyk7XG5cbiAgICAgICAgdGhpcy5NQVhTVFJMRU4gPSAxMDtcbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgdGhpc1swXSA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gc3RyW2kgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOi/lOWbnueUsXMx5ZKMczLov57mjqXogIzmiJDnmoTmlrDkuLJcblxuXG4gICAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoU1N0cmluZywgW3tcbiAgICAgICAga2V5OiAnY29uY2F0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChzMikge1xuICAgICAgICAgICAgdmFyIHQgPSBuZXcgU1N0cmluZygpO1xuICAgICAgICAgICAgLy8g5pyq5oiq5patXG4gICAgICAgICAgICBpZiAodGhpc1swXSArIHMyWzBdIDw9IHRoaXMuTUFYU1RSTEVOKSB7XG4gICAgICAgICAgICAgICAgY29weVN0cjJUKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvcHlTdHIyVChzMiwgdGhpc1swXSk7XG4gICAgICAgICAgICAgICAgdFswXSA9IHRoaXNbMF0gKyBzMlswXTtcblxuICAgICAgICAgICAgICAgIC8vIOaIquaWrVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzWzBdIDwgdGhpcy5NQVhTVFJMRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVN0cjJUKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5U3RyMlQoczIsIHRoaXNbMF0sIHRoaXMuTUFYU1RSTEVOIC0gdGhpc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHRbMF0gPSB0aGlzLk1BWFNUUkxFTjtcblxuICAgICAgICAgICAgICAgICAgICAvLyDmiKrmlq3vvIjku4Xlj5ZzMe+8iVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5U3RyMlQodGhpcywgMCwgdGhpcy5NQVhTVFJMRU4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdFswXSA9IHRoaXNbMF0gPSB0aGlzLk1BWFNUUkxFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY29weVN0cjJUKHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHN0clswXSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBlbmQgfHwgc3RyWzBdOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbc3RhcnQgKyBpXSA9IHN0cltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N1YnN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRoaXNbMF0gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gfn5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxlbiA9IH5+bGVuO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXNbMF0gLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpc1swXSAtIHBvc2l0aW9uKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgICAgIHZhciBzdWIgPSBuZXcgU1N0cmluZygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJbaV0gPSB0aGlzW3Bvc2l0aW9uICsgaSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViWzBdID0gbGVuO1xuXG4gICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5bCG5Liyc+S4reeahOWtkOS4snTmm7/mjaLkuLp277yM6L+U5Zue5pu/5o2i5qyh5pWwXHJcbiAgICAgICAgICogdG9kbyB0byBiZSB0ZXN0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge1NTdHJpbmd9IHRcclxuICAgICAgICAgKiBAcGFyYW0ge1NTdHJpbmd9IHZcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmm7/mjaLmrKHmlbBcclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVwbGFjZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHQsIHYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9uID0gMCwgaSA9IDE7IGkgPD0gdGhpc1swXSAtIHRbMF0gKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSwgX2sgPSAxOyB0W19rXSAmJiB0aGlzW2pdID09PSB0W19rXTsgKytqLCArK19rKSB7fVxuXG4gICAgICAgICAgICAgICAgLy8g5om+5Yiw5LqG5LiOdOWMuemFjeeahOWtl+S4su+8muWIhuS4ieenjeaDheWGteWkhOeQhlxuICAgICAgICAgICAgICAgIGlmIChrID4gdFswXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgLy8g5paw5a2X5Liy55qE6ZW/5bqm5LiO5Y6f5a2Q5Liy55u45ZCM5pe277yM55u05o6l5pu/5o2iXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzBdID09PSB2WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAxOyBsIDw9IHRbMF07ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaSArIGwgLSAxXSA9IHZbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8g5paw5a2Q5Liy6ZW/5bqm5aSn5LqO5Y6f5a2Q5Liy5pe277yM5YWI5bCG5ZCO6YOo5Y+z56e7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRbMF0gPCB2WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gdGhpc1swXTsgbCA+PSBpICsgdFswXTsgLS1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbCArIHZbMF0gLSB0WzBdXSA9IHRoaXNbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWZvciAobCA9IDE7IGwgPD0gdlswXTsgKytsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaSArIGwgLSAxXSA9IHZbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5paw5a2Q5Liy6ZW/5bqm5bCP5LqO5Y6f5a2Q5Liy5pe277yM5YWI5bCG5ZCO6YOo5bem56e7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gaSArIHZbMF07IGwgPD0gdGhpc1swXSArIHZbMF0gLSB0WzBdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbF0gPSB0aGlzW2wgLSB2WzBdICsgdFswXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1mb3IgKGwgPSAxOyBsIDw9IHZbMF07ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpICsgbCAtIDFdID0gdltsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gdGhpc1swXSAtIHRbMF0gKyB2WzBdO1xuICAgICAgICAgICAgICAgICAgICBpICs9IHZbMF07XG4gICAgICAgICAgICAgICAgICAgICsrX247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgdGhpc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIOi/lOWbnuWtkOS4snNzdHJpbmflnKjkuLvkuLLkuK3nmoTnrKxwb3NpdGlvbuS4quWtl+espuS5i+WQjueahOS9jee9rlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbmRleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleChzc3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGkgPSBwb3NpdGlvbiB8fCAxO1xuICAgICAgICAgICAgdmFyIGogPSAxO1xuXG4gICAgICAgICAgICB3aGlsZSAoaSA8PSB0aGlzWzBdICYmIGogPD0gc3N0cmluZ1swXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBzc3RyaW5nW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpIC0gaiArIDI7XG4gICAgICAgICAgICAgICAgICAgIGogPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGogPiBzc3RyaW5nWzBdID8gaSAtIHNzdHJpbmdbMF0gOiAtMTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAna21wSW5kZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24ga21wSW5kZXgoc3N0cmluZywgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBpID0gcG9zaXRpb24gfHwgMTtcbiAgICAgICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dChzc3RyaW5nKTtcblxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gdGhpc1swXSAmJiBqIDw9IHNzdHJpbmdbMF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCB8fCB0aGlzW2ldID09PSBzc3RyaW5nW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGogPSBuZXh0W2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGogPiBzc3RyaW5nWzBdID8gaSAtIHNzdHJpbmdbMF0gOiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOaxguWMheWQq+WcqOWtl+espuS4suS4reiAjHN0cuayoeacieeahOWtl+espuS4slxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJ0cmFjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChzdHIpIHtcbiAgICAgICAgICAgIHZhciByID0gbmV3IFNTdHJpbmcoKTtcbiAgICAgICAgICAgIHJbMF0gPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzWzBdOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIC8vIOWIpOaWreW9k+WJjeWtl+espmPmmK/lkKbnrKzkuIDmrKHlh7rnjrBcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCBpICYmIHRoaXNbal0gIT09IF9jOyArK2opIHt9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yik5pat5b2T5YmN5a2X56ym5piv5ZCm5YyF5ZCr5Zyoc3Ry5LitXG4gICAgICAgICAgICAgICAgICAgIHZhciBfazIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgX2syIDw9IHN0clswXSAmJiBzdHJbX2syXSAhPT0gX2M7ICsrX2syKSB7fVxuICAgICAgICAgICAgICAgICAgICBpZiAoX2syID4gc3RyWzBdKSByWysrclswXV0gPSBfYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbyBidWcgZXhpc3RzXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlbGV0ZV9zdWJzdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlX3N1YnN0cmluZyhzdHIpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXNbMF0gLSBzdHJbMF0gKyAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgICAgICAgICAgZm9yICg7IGogPD0gc3RyWzBdICYmIHRoaXNbaSArIGogLSAxXSA9PT0gc3RyW2pdOyArK2opIHt9XG4gICAgICAgICAgICAgICAgaWYgKGogPiBzdHJbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rMyA9IGk7IF9rMyA8PSB0aGlzWzBdIC0gc3RyWzBdOyArK19rMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tfazNdID0gdGhpc1tfazMgKyBzdHJbMF1dO1xuICAgICAgICAgICAgICAgICAgICB9dGhpc1swXSAtPSBzdHJbMF07XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBTU3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTU3RyaW5nO1xuXG5cbmZ1bmN0aW9uIGdldE5leHQoc3N0cmluZykge1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgbmV4dCA9IHsgMTogMCB9O1xuICAgIHZhciBqID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3N0cmluZ1swXSkge1xuICAgICAgICBpZiAoaiA9PT0gMCB8fCBzc3RyaW5nW2ldID09PSBzc3RyaW5nW2pdKSB7XG4gICAgICAgICAgICBpZiAoc3N0cmluZ1srK2ldICE9PSBzc3RyaW5nWysral0pIHtcbiAgICAgICAgICAgICAgICBuZXh0W2ldID0gajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFtpXSA9IG5leHRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBuZXh0WysraV0gPSArK2o7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaiA9IG5leHRbal07XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG59XG5cbnZhciBhID0gbmV3IFNTdHJpbmcoKTtcbnZhciBiID0gbmV3IFNTdHJpbmcoKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgYVtpICsgMV0gPSBpICsgJyc7XG4gICAgYltpICsgMV0gPSBpICsgJyc7XG59XG5hWzBdID0gYlswXSA9IDQ7XG52YXIgdCA9IGEuY29uY2F0KGIpO1xuY29uc29sZS5sb2codCArICcnKTsgLy8gMDEyMzAxMjNcblxudmFyIGQgPSBuZXcgU1N0cmluZygnYWNhYmFhYmFhYmNhY2FhYmMnKTtcbnZhciBjID0gbmV3IFNTdHJpbmcoJ2FiYWFiYycpO1xuXG5jb25zb2xlLmxvZygnaW5kZXg6ICcgKyBkLmluZGV4KGMpKTtcbmNvbnNvbGUubG9nKCdrbXBJbmRleDogJyArIGQua21wSW5kZXgoYykpO1xuXG5hID0gbmV3IFNTdHJpbmcoJ2FiY2RlZmcnKTtcbmIgPSBuZXcgU1N0cmluZygnYXNkZmcnKTtcbmNvbnNvbGUubG9nKGEuc3VidHJhY3QoYikgKyAnJyk7XG5cbmEgPSBuZXcgU1N0cmluZygnYWJjZGVmZ2gnKTtcbmIgPSBuZXcgU1N0cmluZygnY2RlZicpO1xuY29uc29sZS5sb2coYS5kZWxldGVfc3Vic3RyaW5nKGIpICsgJycpO1xuY29uc29sZS5sb2coYSArICcnKTtcblxuLypcclxuIOWcqOmhuuW6j+WtmOWCqOe7k+aehOS4re+8jOWunueOsOS4suaTjeS9nOeahOWOn+aTjeS9nOS4uuKAnOWtl+espuS4suW6j+WIl+eahOWkjeWItuKAne+8jOaTjeS9nOaXtumXtOWkjeadguW6puWfuuS6juWkjeWItueahOWtl+espuS4suW6j+WIl+eahOmVv+W6puOAglxyXG4g5Y+m5LiA5pON5L2c54m554K55piv77yM5aaC5p6c5Zyo5pON5L2c5Lit5Ye6546w5Liy5YC85bqP5YiX55qE6ZW/5bqm6LaF6L+HTUFYU1RSTEVO5pe277yM57qm5a6a55So5oiq5bC+5rOV5aSE55CG77yM6L+Z56eN5oOF5Ya15LiN5LuF5Zyo5rGC6L+e5o6l5Liy5pe25Y+v6IO95Y+R55Sf77yM5Zyo5Liy55qE5YW25LuW5pON5L2c5Lit77yM5aaC5o+S5YWl77yM572u5o2i562J5Lmf5Y+v6IO95Y+R55Sf77yM5YWL5pyN6L+Z5Liq5byK55eF5ZSv5pyJ5LiN6ZmQ5a6a5Liy6ZW/55qE5pyA5aSn6ZW/5bqm77yM5Y2z5Yqo5oCB5YiG6YWN5Liy5YC855qE5a2Y5YKo56m66Ze044CCXHJcbiAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvU3RyaW5nL1NTdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjcnlwdG8pIHtcbiAgZnVuY3Rpb24gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRpZ2VzdCkge1xuICAgICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICAgIGRpZ2VzdCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2FsbGJhY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNhbGxiYWNrIHByb3ZpZGVkIHRvIHBia2RmMicpXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdFxuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIGl0ZXJhdGlvbnMpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdGVyYXRpb25zIG5vdCBhIG51bWJlcicpXG5cbiAgICBpZiAoaXRlcmF0aW9ucyA8IDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgaXRlcmF0aW9ucycpXG5cbiAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBrZXlsZW4pXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLZXkgbGVuZ3RoIG5vdCBhIG51bWJlcicpXG5cbiAgICBpZiAoa2V5bGVuIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBrZXkgbGVuZ3RoJylcblxuICAgIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gbmV3IEJ1ZmZlcihzYWx0KVxuXG4gICAgdmFyIGhMZW4sIGwgPSAxLCByLCBUXG4gICAgdmFyIERLID0gbmV3IEJ1ZmZlcihrZXlsZW4pXG4gICAgdmFyIGJsb2NrMSA9IG5ldyBCdWZmZXIoc2FsdC5sZW5ndGggKyA0KVxuICAgIHNhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbDsgaSsrKSB7XG4gICAgICBibG9jazEud3JpdGVVSW50MzJCRShpLCBzYWx0Lmxlbmd0aClcblxuICAgICAgdmFyIFUgPSBjcnlwdG8uY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoYmxvY2sxKS5kaWdlc3QoKVxuXG4gICAgICBpZiAoIWhMZW4pIHtcbiAgICAgICAgaExlbiA9IFUubGVuZ3RoXG4gICAgICAgIFQgPSBuZXcgQnVmZmVyKGhMZW4pXG4gICAgICAgIGwgPSBNYXRoLmNlaWwoa2V5bGVuIC8gaExlbilcbiAgICAgICAgciA9IGtleWxlbiAtIChsIC0gMSkgKiBoTGVuXG5cbiAgICAgICAgaWYgKGtleWxlbiA+IChNYXRoLnBvdygyLCAzMikgLSAxKSAqIGhMZW4pXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5bGVuIGV4Y2VlZHMgbWF4aW11bSBsZW5ndGgnKVxuICAgICAgfVxuXG4gICAgICBVLmNvcHkoVCwgMCwgMCwgaExlbilcblxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgICAgVSA9IGNyeXB0by5jcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShVKS5kaWdlc3QoKVxuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaExlbjsgaysrKSB7XG4gICAgICAgICAgVFtrXSBePSBVW2tdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlc3RQb3MgPSAoaSAtIDEpICogaExlblxuICAgICAgdmFyIGxlbiA9IChpID09IGwgPyByIDogaExlbilcbiAgICAgIFQuY29weShESywgZGVzdFBvcywgMCwgbGVuKVxuICAgIH1cblxuICAgIHJldHVybiBES1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYmtkZjI6IHBia2RmMixcbiAgICBwYmtkZjJTeW5jOiBwYmtkZjJTeW5jXG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Bia2RmMi1jb21wYXQvcGJrZGYyLmpzXG4gKiogbW9kdWxlIGlkID0gMTY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJpcGVtZDE2MFxuXG5cblxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKiogQHByZXNlcnZlXG4oYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8vIENvbnN0YW50cyB0YWJsZVxudmFyIHpsID0gW1xuICAgIDAsICAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gICAgNywgIDQsIDEzLCAgMSwgMTAsICA2LCAxNSwgIDMsIDEyLCAgMCwgIDksICA1LCAgMiwgMTQsIDExLCAgOCxcbiAgICAzLCAxMCwgMTQsICA0LCAgOSwgMTUsICA4LCAgMSwgIDIsICA3LCAgMCwgIDYsIDEzLCAxMSwgIDUsIDEyLFxuICAgIDEsICA5LCAxMSwgMTAsICAwLCAgOCwgMTIsICA0LCAxMywgIDMsICA3LCAxNSwgMTQsICA1LCAgNiwgIDIsXG4gICAgNCwgIDAsICA1LCAgOSwgIDcsIDEyLCAgMiwgMTAsIDE0LCAgMSwgIDMsICA4LCAxMSwgIDYsIDE1LCAxM107XG52YXIgenIgPSBbXG4gICAgNSwgMTQsICA3LCAgMCwgIDksICAyLCAxMSwgIDQsIDEzLCAgNiwgMTUsICA4LCAgMSwgMTAsICAzLCAxMixcbiAgICA2LCAxMSwgIDMsICA3LCAgMCwgMTMsICA1LCAxMCwgMTQsIDE1LCAgOCwgMTIsICA0LCAgOSwgIDEsICAyLFxuICAgIDE1LCAgNSwgIDEsICAzLCAgNywgMTQsICA2LCAgOSwgMTEsICA4LCAxMiwgIDIsIDEwLCAgMCwgIDQsIDEzLFxuICAgIDgsICA2LCAgNCwgIDEsICAzLCAxMSwgMTUsICAwLCAgNSwgMTIsICAyLCAxMywgIDksICA3LCAxMCwgMTQsXG4gICAgMTIsIDE1LCAxMCwgIDQsICAxLCAgNSwgIDgsICA3LCAgNiwgIDIsIDEzLCAxNCwgIDAsICAzLCAgOSwgMTFdO1xudmFyIHNsID0gW1xuICAgICAxMSwgMTQsIDE1LCAxMiwgIDUsICA4LCAgNywgIDksIDExLCAxMywgMTQsIDE1LCAgNiwgIDcsICA5LCAgOCxcbiAgICA3LCA2LCAgIDgsIDEzLCAxMSwgIDksICA3LCAxNSwgIDcsIDEyLCAxNSwgIDksIDExLCAgNywgMTMsIDEyLFxuICAgIDExLCAxMywgIDYsICA3LCAxNCwgIDksIDEzLCAxNSwgMTQsICA4LCAxMywgIDYsICA1LCAxMiwgIDcsICA1LFxuICAgICAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgIDksICA4LCAgOSwgMTQsICA1LCAgNiwgIDgsICA2LCAgNSwgMTIsXG4gICAgOSwgMTUsICA1LCAxMSwgIDYsICA4LCAxMywgMTIsICA1LCAxMiwgMTMsIDE0LCAxMSwgIDgsICA1LCAgNiBdO1xudmFyIHNyID0gW1xuICAgIDgsICA5LCAgOSwgMTEsIDEzLCAxNSwgMTUsICA1LCAgNywgIDcsICA4LCAxMSwgMTQsIDE0LCAxMiwgIDYsXG4gICAgOSwgMTMsIDE1LCAgNywgMTIsICA4LCAgOSwgMTEsICA3LCAgNywgMTIsICA3LCAgNiwgMTUsIDEzLCAxMSxcbiAgICA5LCAgNywgMTUsIDExLCAgOCwgIDYsICA2LCAxNCwgMTIsIDEzLCAgNSwgMTQsIDEzLCAxMywgIDcsICA1LFxuICAgIDE1LCAgNSwgIDgsIDExLCAxNCwgMTQsICA2LCAxNCwgIDYsICA5LCAxMiwgIDksIDEyLCAgNSwgMTUsICA4LFxuICAgIDgsICA1LCAxMiwgIDksIDEyLCAgNSwgMTQsICA2LCAgOCwgMTMsICA2LCAgNSwgMTUsIDEzLCAxMSwgMTEgXTtcblxudmFyIGhsID0gIFsgMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV07XG52YXIgaHIgPSAgWyAweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXTtcblxudmFyIGJ5dGVzVG9Xb3JkcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICB2YXIgd29yZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOCkge1xuICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufTtcblxudmFyIHdvcmRzVG9CeXRlcyA9IGZ1bmN0aW9uICh3b3Jkcykge1xuICB2YXIgYnl0ZXMgPSBbXTtcbiAgZm9yICh2YXIgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KSB7XG4gICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxudmFyIHByb2Nlc3NCbG9jayA9IGZ1bmN0aW9uIChILCBNLCBvZmZzZXQpIHtcblxuICAvLyBTd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cbiAgICAvLyBTd2FwXG4gICAgTVtvZmZzZXRfaV0gPSAoXG4gICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuICAgICk7XG4gIH1cblxuICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsO1xuICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyO1xuXG4gIGFyID0gYWwgPSBIWzBdO1xuICBiciA9IGJsID0gSFsxXTtcbiAgY3IgPSBjbCA9IEhbMl07XG4gIGRyID0gZGwgPSBIWzNdO1xuICBlciA9IGVsID0gSFs0XTtcbiAgLy8gQ29tcHV0YXRpb25cbiAgdmFyIHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgIHQgPSAoYWwgKyAgTVtvZmZzZXQremxbaV1dKXwwO1xuICAgIGlmIChpPDE2KXtcbiAgICAgICAgdCArPSAgZjEoYmwsY2wsZGwpICsgaGxbMF07XG4gICAgfSBlbHNlIGlmIChpPDMyKSB7XG4gICAgICAgIHQgKz0gIGYyKGJsLGNsLGRsKSArIGhsWzFdO1xuICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuICAgICAgICB0ICs9ICBmMyhibCxjbCxkbCkgKyBobFsyXTtcbiAgICB9IGVsc2UgaWYgKGk8NjQpIHtcbiAgICAgICAgdCArPSAgZjQoYmwsY2wsZGwpICsgaGxbM107XG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgICB0ICs9ICBmNShibCxjbCxkbCkgKyBobFs0XTtcbiAgICB9XG4gICAgdCA9IHR8MDtcbiAgICB0ID0gIHJvdGwodCxzbFtpXSk7XG4gICAgdCA9ICh0K2VsKXwwO1xuICAgIGFsID0gZWw7XG4gICAgZWwgPSBkbDtcbiAgICBkbCA9IHJvdGwoY2wsIDEwKTtcbiAgICBjbCA9IGJsO1xuICAgIGJsID0gdDtcblxuICAgIHQgPSAoYXIgKyBNW29mZnNldCt6cltpXV0pfDA7XG4gICAgaWYgKGk8MTYpe1xuICAgICAgICB0ICs9ICBmNShicixjcixkcikgKyBoclswXTtcbiAgICB9IGVsc2UgaWYgKGk8MzIpIHtcbiAgICAgICAgdCArPSAgZjQoYnIsY3IsZHIpICsgaHJbMV07XG4gICAgfSBlbHNlIGlmIChpPDQ4KSB7XG4gICAgICAgIHQgKz0gIGYzKGJyLGNyLGRyKSArIGhyWzJdO1xuICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuICAgICAgICB0ICs9ICBmMihicixjcixkcikgKyBoclszXTtcbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICAgIHQgKz0gIGYxKGJyLGNyLGRyKSArIGhyWzRdO1xuICAgIH1cbiAgICB0ID0gdHwwO1xuICAgIHQgPSAgcm90bCh0LHNyW2ldKSA7XG4gICAgdCA9ICh0K2VyKXwwO1xuICAgIGFyID0gZXI7XG4gICAgZXIgPSBkcjtcbiAgICBkciA9IHJvdGwoY3IsIDEwKTtcbiAgICBjciA9IGJyO1xuICAgIGJyID0gdDtcbiAgfVxuICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICB0ICAgID0gKEhbMV0gKyBjbCArIGRyKXwwO1xuICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKXwwO1xuICBIWzJdID0gKEhbM10gKyBlbCArIGFyKXwwO1xuICBIWzNdID0gKEhbNF0gKyBhbCArIGJyKXwwO1xuICBIWzRdID0gKEhbMF0gKyBibCArIGNyKXwwO1xuICBIWzBdID0gIHQ7XG59O1xuXG5mdW5jdGlvbiBmMSh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKHkpIF4gKHopKTtcbn1cblxuZnVuY3Rpb24gZjIoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkmKHkpKSB8ICgofngpJih6KSkpO1xufVxuXG5mdW5jdGlvbiBmMyh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpO1xufVxuXG5mdW5jdGlvbiBmNCh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpJih+KHopKSkpO1xufVxuXG5mdW5jdGlvbiBmNSh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKCh5KSB8KH4oeikpKSk7XG59XG5cbmZ1bmN0aW9uIHJvdGwoeCxuKSB7XG4gIHJldHVybiAoeDw8bikgfCAoeD4+PigzMi1uKSk7XG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MChtZXNzYWdlKSB7XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdO1xuXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PSAnc3RyaW5nJylcbiAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAndXRmOCcpO1xuXG4gIHZhciBtID0gYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpO1xuXG4gIHZhciBuQml0c0xlZnQgPSBtZXNzYWdlLmxlbmd0aCAqIDg7XG4gIHZhciBuQml0c1RvdGFsID0gbWVzc2FnZS5sZW5ndGggKiA4O1xuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIG1bbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcbiAgbVsoKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICAgKCgobkJpdHNUb3RhbCA8PCA4KSAgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuICApO1xuXG4gIGZvciAodmFyIGk9MCA7IGk8bS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBwcm9jZXNzQmxvY2soSCwgbSwgaSk7XG4gIH1cblxuICAvLyBTd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgLy8gU2hvcnRjdXRcbiAgICB2YXIgSF9pID0gSFtpXTtcblxuICAgIC8vIFN3YXBcbiAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcbiAgfVxuXG4gIHZhciBkaWdlc3RieXRlcyA9IHdvcmRzVG9CeXRlcyhIKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIoZGlnZXN0Ynl0ZXMpO1xufVxuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCdWZmZXIpIHtcblxuICAvL3Byb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgICB0aGlzLl9ibG9jayA9IG5ldyBCdWZmZXIoYmxvY2tTaXplKSAvL25ldyBVaW50MzJBcnJheShibG9ja1NpemUvNClcbiAgICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgICB0aGlzLl9sZW4gPSAwXG4gICAgdGhpcy5fcyA9IDBcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcyA9IDBcbiAgICB0aGlzLl9sZW4gPSAwXG4gIH1cblxuICBIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBlbmMgPSBlbmMgfHwgXCJ1dGY4XCJcbiAgICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgICB9XG5cbiAgICB2YXIgbCA9IHRoaXMuX2xlbiArPSBkYXRhLmxlbmd0aFxuICAgIHZhciBzID0gdGhpcy5fcyA9ICh0aGlzLl9zIHx8IDApXG4gICAgdmFyIGYgPSAwXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2Jsb2NrXG5cbiAgICB3aGlsZSAocyA8IGwpIHtcbiAgICAgIHZhciB0ID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIGYgKyB0aGlzLl9ibG9ja1NpemUgLSAocyAlIHRoaXMuX2Jsb2NrU2l6ZSkpXG4gICAgICB2YXIgY2ggPSAodCAtIGYpXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2g7IGkrKykge1xuICAgICAgICBidWZmZXJbKHMgJSB0aGlzLl9ibG9ja1NpemUpICsgaV0gPSBkYXRhW2kgKyBmXVxuICAgICAgfVxuXG4gICAgICBzICs9IGNoXG4gICAgICBmICs9IGNoXG5cbiAgICAgIGlmICgocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKGJ1ZmZlcilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcyA9IHNcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gICAgLy8gU3VwcG9zZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIE0sIGluIGJpdHMsIGlzIGxcbiAgICB2YXIgbCA9IHRoaXMuX2xlbiAqIDhcblxuICAgIC8vIEFwcGVuZCB0aGUgYml0IDEgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZVxuICAgIHRoaXMuX2Jsb2NrW3RoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZV0gPSAweDgwXG5cbiAgICAvLyBhbmQgdGhlbiBrIHplcm8gYml0cywgd2hlcmUgayBpcyB0aGUgc21hbGxlc3Qgbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobCArIDEgKyBrKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZSArIDEpXG5cbiAgICBpZiAobCAlICh0aGlzLl9ibG9ja1NpemUgKiA4KSA+PSB0aGlzLl9maW5hbFNpemUgKiA4KSB7XG4gICAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gICAgfVxuXG4gICAgLy8gdG8gdGhpcyBhcHBlbmQgdGhlIGJsb2NrIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgbCB3cml0dGVuIGluIGJpbmFyeVxuICAgIC8vIFRPRE86IGhhbmRsZSBjYXNlIHdoZXJlIGwgaXMgPiBNYXRoLnBvdygyLCAyOSlcbiAgICB0aGlzLl9ibG9jay53cml0ZUludDMyQkUobCwgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAgIHZhciBoYXNoID0gdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKSB8fCB0aGlzLl9oYXNoKClcblxuICAgIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG4gIH1cblxuICBIYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbiAgfVxuXG4gIHJldHVybiBIYXNoXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaGEuanMvaGFzaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhbGcpIHtcbiAgdmFyIEFsZyA9IGV4cG9ydHNbYWxnXVxuICBpZighQWxnKSB0aHJvdyBuZXcgRXJyb3IoYWxnICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuICByZXR1cm4gbmV3IEFsZygpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbnZhciBIYXNoICAgPSByZXF1aXJlKCcuL2hhc2gnKShCdWZmZXIpXG5cbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpKEJ1ZmZlciwgSGFzaClcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKShCdWZmZXIsIEhhc2gpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJykoQnVmZmVyLCBIYXNoKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2hhLmpzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQnVmZmVyLCBIYXNoKSB7XG5cbiAgdmFyIEEgPSAwfDBcbiAgdmFyIEIgPSA0fDBcbiAgdmFyIEMgPSA4fDBcbiAgdmFyIEQgPSAxMnwwXG4gIHZhciBFID0gMTZ8MFxuXG4gIHZhciBXID0gbmV3ICh0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEludDMyQXJyYXkpKDgwKVxuXG4gIHZhciBQT09MID0gW11cblxuICBmdW5jdGlvbiBTaGExICgpIHtcbiAgICBpZihQT09MLmxlbmd0aClcbiAgICAgIHJldHVybiBQT09MLnBvcCgpLmluaXQoKVxuXG4gICAgaWYoISh0aGlzIGluc3RhbmNlb2YgU2hhMSkpIHJldHVybiBuZXcgU2hhMSgpXG4gICAgdGhpcy5fdyA9IFdcbiAgICBIYXNoLmNhbGwodGhpcywgMTYqNCwgMTQqNClcblxuICAgIHRoaXMuX2ggPSBudWxsXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIGluaGVyaXRzKFNoYTEsIEhhc2gpXG5cbiAgU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICAgIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gICAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICAgIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgICBIYXNoLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgU2hhMS5wcm90b3R5cGUuX1BPT0wgPSBQT09MXG4gIFNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoWCkge1xuXG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIF9hLCBfYiwgX2MsIF9kLCBfZVxuXG4gICAgYSA9IF9hID0gdGhpcy5fYVxuICAgIGIgPSBfYiA9IHRoaXMuX2JcbiAgICBjID0gX2MgPSB0aGlzLl9jXG4gICAgZCA9IF9kID0gdGhpcy5fZFxuICAgIGUgPSBfZSA9IHRoaXMuX2VcblxuICAgIHZhciB3ID0gdGhpcy5fd1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgIHZhciBXID0gd1tqXSA9IGogPCAxNiA/IFgucmVhZEludDMyQkUoaio0KVxuICAgICAgICA6IHJvbCh3W2ogLSAzXSBeIHdbaiAtICA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSlcblxuICAgICAgdmFyIHQgPSBhZGQoXG4gICAgICAgIGFkZChyb2woYSwgNSksIHNoYTFfZnQoaiwgYiwgYywgZCkpLFxuICAgICAgICBhZGQoYWRkKGUsIFcpLCBzaGExX2t0KGopKVxuICAgICAgKVxuXG4gICAgICBlID0gZFxuICAgICAgZCA9IGNcbiAgICAgIGMgPSByb2woYiwgMzApXG4gICAgICBiID0gYVxuICAgICAgYSA9IHRcbiAgICB9XG5cbiAgICB0aGlzLl9hID0gYWRkKGEsIF9hKVxuICAgIHRoaXMuX2IgPSBhZGQoYiwgX2IpXG4gICAgdGhpcy5fYyA9IGFkZChjLCBfYylcbiAgICB0aGlzLl9kID0gYWRkKGQsIF9kKVxuICAgIHRoaXMuX2UgPSBhZGQoZSwgX2UpXG4gIH1cblxuICBTaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihQT09MLmxlbmd0aCA8IDEwMCkgUE9PTC5wdXNoKHRoaXMpXG4gICAgdmFyIEggPSBuZXcgQnVmZmVyKDIwKVxuICAgIC8vY29uc29sZS5sb2codGhpcy5fYXwwLCB0aGlzLl9ifDAsIHRoaXMuX2N8MCwgdGhpcy5fZHwwLCB0aGlzLl9lfDApXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYXwwLCBBKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2J8MCwgQilcbiAgICBILndyaXRlSW50MzJCRSh0aGlzLl9jfDAsIEMpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZHwwLCBEKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2V8MCwgRSlcbiAgICByZXR1cm4gSFxuICB9XG5cbiAgLypcbiAgICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAgICogaXRlcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpIHtcbiAgICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gICAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICAgIHJldHVybiBiIF4gYyBeIGQ7XG4gIH1cblxuICAvKlxuICAgKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHNoYTFfa3QodCkge1xuICAgIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xuICB9XG5cbiAgLypcbiAgICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICAgKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICAgKiAvL2RvbWluaWN0YXJyOiB0aGlzIGlzIDEwIHllYXJzIG9sZCwgc28gbWF5YmUgdGhpcyBjYW4gYmUgZHJvcHBlZD8pXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhZGQoeCwgeSkge1xuICAgIHJldHVybiAoeCArIHkgKSB8IDBcbiAgLy9sZXRzIHNlZSBob3cgdGhpcyBnb2VzIG9uIHRlc3RsaW5nLlxuICAvLyAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgLy8gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgLy8gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xuICB9XG5cbiAgLypcbiAgICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICAgKi9cbiAgZnVuY3Rpb24gcm9sKG51bSwgY250KSB7XG4gICAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xuICB9XG5cbiAgcmV0dXJuIFNoYTFcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NoYS5qcy9zaGExLmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQnVmZmVyLCBIYXNoKSB7XG5cbiAgdmFyIEsgPSBbXG4gICAgICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAgICAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgICAgIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gICAgICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAgICAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgICAgIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gICAgICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAgICAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAgIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gICAgICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAgICAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgICAgIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gICAgICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAgICAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgICAgIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gICAgICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG4gICAgXVxuXG4gIHZhciBXID0gbmV3IEFycmF5KDY0KVxuXG4gIGZ1bmN0aW9uIFNoYTI1NigpIHtcbiAgICB0aGlzLmluaXQoKVxuXG4gICAgdGhpcy5fdyA9IFcgLy9uZXcgQXJyYXkoNjQpXG5cbiAgICBIYXNoLmNhbGwodGhpcywgMTYqNCwgMTQqNClcbiAgfVxuXG4gIGluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuICBTaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9hID0gMHg2YTA5ZTY2N3wwXG4gICAgdGhpcy5fYiA9IDB4YmI2N2FlODV8MFxuICAgIHRoaXMuX2MgPSAweDNjNmVmMzcyfDBcbiAgICB0aGlzLl9kID0gMHhhNTRmZjUzYXwwXG4gICAgdGhpcy5fZSA9IDB4NTEwZTUyN2Z8MFxuICAgIHRoaXMuX2YgPSAweDliMDU2ODhjfDBcbiAgICB0aGlzLl9nID0gMHgxZjgzZDlhYnwwXG4gICAgdGhpcy5faCA9IDB4NWJlMGNkMTl8MFxuXG4gICAgdGhpcy5fbGVuID0gdGhpcy5fcyA9IDBcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmdW5jdGlvbiBTIChYLCBuKSB7XG4gICAgcmV0dXJuIChYID4+PiBuKSB8IChYIDw8ICgzMiAtIG4pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFIgKFgsIG4pIHtcbiAgICByZXR1cm4gKFggPj4+IG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1haiAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNpZ21hMDI1NiAoeCkge1xuICAgIHJldHVybiAoUyh4LCAyKSBeIFMoeCwgMTMpIF4gUyh4LCAyMikpO1xuICB9XG5cbiAgZnVuY3Rpb24gU2lnbWExMjU2ICh4KSB7XG4gICAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSk7XG4gIH1cblxuICBmdW5jdGlvbiBHYW1tYTAyNTYgKHgpIHtcbiAgICByZXR1cm4gKFMoeCwgNykgXiBTKHgsIDE4KSBeIFIoeCwgMykpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2FtbWExMjU2ICh4KSB7XG4gICAgcmV0dXJuIChTKHgsIDE3KSBeIFMoeCwgMTkpIF4gUih4LCAxMCkpO1xuICB9XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oTSkge1xuXG4gICAgdmFyIFcgPSB0aGlzLl93XG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGhcbiAgICB2YXIgVDEsIFQyXG5cbiAgICBhID0gdGhpcy5fYSB8IDBcbiAgICBiID0gdGhpcy5fYiB8IDBcbiAgICBjID0gdGhpcy5fYyB8IDBcbiAgICBkID0gdGhpcy5fZCB8IDBcbiAgICBlID0gdGhpcy5fZSB8IDBcbiAgICBmID0gdGhpcy5fZiB8IDBcbiAgICBnID0gdGhpcy5fZyB8IDBcbiAgICBoID0gdGhpcy5faCB8IDBcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgdmFyIHcgPSBXW2pdID0gaiA8IDE2XG4gICAgICAgID8gTS5yZWFkSW50MzJCRShqICogNClcbiAgICAgICAgOiBHYW1tYTEyNTYoV1tqIC0gMl0pICsgV1tqIC0gN10gKyBHYW1tYTAyNTYoV1tqIC0gMTVdKSArIFdbaiAtIDE2XVxuXG4gICAgICBUMSA9IGggKyBTaWdtYTEyNTYoZSkgKyBDaChlLCBmLCBnKSArIEtbal0gKyB3XG5cbiAgICAgIFQyID0gU2lnbWEwMjU2KGEpICsgTWFqKGEsIGIsIGMpO1xuICAgICAgaCA9IGc7IGcgPSBmOyBmID0gZTsgZSA9IGQgKyBUMTsgZCA9IGM7IGMgPSBiOyBiID0gYTsgYSA9IFQxICsgVDI7XG4gICAgfVxuXG4gICAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gICAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gICAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gICAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gICAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gICAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gICAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gICAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG5cbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBIID0gbmV3IEJ1ZmZlcigzMilcblxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsICAwKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsICA0KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsICA4KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIHJldHVybiBTaGEyNTZcblxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2hhLmpzL3NoYTI1Ni5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJ1ZmZlciwgSGFzaCkge1xuICB2YXIgSyA9IFtcbiAgICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAgIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gICAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAgIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gICAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAgIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gICAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAgIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gICAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAgIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gICAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAgIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gICAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAgIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gICAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gICAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAgIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gICAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gICAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAgIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gICAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAgIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gICAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAgIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gICAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG4gIF1cblxuICB2YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbiAgZnVuY3Rpb24gU2hhNTEyKCkge1xuICAgIHRoaXMuaW5pdCgpXG4gICAgdGhpcy5fdyA9IFdcblxuICAgIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbiAgfVxuXG4gIGluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuICBTaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9hID0gMHg2YTA5ZTY2N3wwXG4gICAgdGhpcy5fYiA9IDB4YmI2N2FlODV8MFxuICAgIHRoaXMuX2MgPSAweDNjNmVmMzcyfDBcbiAgICB0aGlzLl9kID0gMHhhNTRmZjUzYXwwXG4gICAgdGhpcy5fZSA9IDB4NTEwZTUyN2Z8MFxuICAgIHRoaXMuX2YgPSAweDliMDU2ODhjfDBcbiAgICB0aGlzLl9nID0gMHgxZjgzZDlhYnwwXG4gICAgdGhpcy5faCA9IDB4NWJlMGNkMTl8MFxuXG4gICAgdGhpcy5fYWwgPSAweGYzYmNjOTA4fDBcbiAgICB0aGlzLl9ibCA9IDB4ODRjYWE3M2J8MFxuICAgIHRoaXMuX2NsID0gMHhmZTk0ZjgyYnwwXG4gICAgdGhpcy5fZGwgPSAweDVmMWQzNmYxfDBcbiAgICB0aGlzLl9lbCA9IDB4YWRlNjgyZDF8MFxuICAgIHRoaXMuX2ZsID0gMHgyYjNlNmMxZnwwXG4gICAgdGhpcy5fZ2wgPSAweGZiNDFiZDZifDBcbiAgICB0aGlzLl9obCA9IDB4MTM3ZTIxNzl8MFxuXG4gICAgdGhpcy5fbGVuID0gdGhpcy5fcyA9IDBcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmdW5jdGlvbiBTIChYLCBYbCwgbikge1xuICAgIHJldHVybiAoWCA+Pj4gbikgfCAoWGwgPDwgKDMyIC0gbikpXG4gIH1cblxuICBmdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xuICB9XG5cbiAgZnVuY3Rpb24gTWFqICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xuICB9XG5cbiAgU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oTSkge1xuXG4gICAgdmFyIFcgPSB0aGlzLl93XG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGhcbiAgICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsLCBmbCwgZ2wsIGhsXG5cbiAgICBhID0gdGhpcy5fYSB8IDBcbiAgICBiID0gdGhpcy5fYiB8IDBcbiAgICBjID0gdGhpcy5fYyB8IDBcbiAgICBkID0gdGhpcy5fZCB8IDBcbiAgICBlID0gdGhpcy5fZSB8IDBcbiAgICBmID0gdGhpcy5fZiB8IDBcbiAgICBnID0gdGhpcy5fZyB8IDBcbiAgICBoID0gdGhpcy5faCB8IDBcblxuICAgIGFsID0gdGhpcy5fYWwgfCAwXG4gICAgYmwgPSB0aGlzLl9ibCB8IDBcbiAgICBjbCA9IHRoaXMuX2NsIHwgMFxuICAgIGRsID0gdGhpcy5fZGwgfCAwXG4gICAgZWwgPSB0aGlzLl9lbCB8IDBcbiAgICBmbCA9IHRoaXMuX2ZsIHwgMFxuICAgIGdsID0gdGhpcy5fZ2wgfCAwXG4gICAgaGwgPSB0aGlzLl9obCB8IDBcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgdmFyIGogPSBpICogMlxuXG4gICAgICB2YXIgV2ksIFdpbFxuXG4gICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIFdpID0gV1tqXSA9IE0ucmVhZEludDMyQkUoaiAqIDQpXG4gICAgICAgIFdpbCA9IFdbaiArIDFdID0gTS5yZWFkSW50MzJCRShqICogNCArIDQpXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ICA9IFdbaiAtIDE1KjJdXG4gICAgICAgIHZhciB4bCA9IFdbaiAtIDE1KjIgKyAxXVxuICAgICAgICB2YXIgZ2FtbWEwICA9IFMoeCwgeGwsIDEpIF4gUyh4LCB4bCwgOCkgXiAoeCA+Pj4gNylcbiAgICAgICAgdmFyIGdhbW1hMGwgPSBTKHhsLCB4LCAxKSBeIFMoeGwsIHgsIDgpIF4gUyh4bCwgeCwgNylcblxuICAgICAgICB4ICA9IFdbaiAtIDIqMl1cbiAgICAgICAgeGwgPSBXW2ogLSAyKjIgKyAxXVxuICAgICAgICB2YXIgZ2FtbWExICA9IFMoeCwgeGwsIDE5KSBeIFMoeGwsIHgsIDI5KSBeICh4ID4+PiA2KVxuICAgICAgICB2YXIgZ2FtbWExbCA9IFMoeGwsIHgsIDE5KSBeIFMoeCwgeGwsIDI5KSBeIFMoeGwsIHgsIDYpXG5cbiAgICAgICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgICAgIHZhciBXaTcgID0gV1tqIC0gNyoyXVxuICAgICAgICB2YXIgV2k3bCA9IFdbaiAtIDcqMiArIDFdXG5cbiAgICAgICAgdmFyIFdpMTYgID0gV1tqIC0gMTYqMl1cbiAgICAgICAgdmFyIFdpMTZsID0gV1tqIC0gMTYqMiArIDFdXG5cbiAgICAgICAgV2lsID0gZ2FtbWEwbCArIFdpN2xcbiAgICAgICAgV2kgID0gZ2FtbWEwICArIFdpNyArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKVxuICAgICAgICBXaWwgPSBXaWwgKyBnYW1tYTFsXG4gICAgICAgIFdpICA9IFdpICArIGdhbW1hMSAgKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWExbCA+Pj4gMCkgPyAxIDogMClcbiAgICAgICAgV2lsID0gV2lsICsgV2kxNmxcbiAgICAgICAgV2kgID0gV2kgICsgV2kxNiArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMClcblxuICAgICAgICBXW2pdID0gV2lcbiAgICAgICAgV1tqICsgMV0gPSBXaWxcbiAgICAgIH1cblxuICAgICAgdmFyIG1haiA9IE1haihhLCBiLCBjKVxuICAgICAgdmFyIG1hamwgPSBNYWooYWwsIGJsLCBjbClcblxuICAgICAgdmFyIHNpZ21hMGggPSBTKGEsIGFsLCAyOCkgXiBTKGFsLCBhLCAyKSBeIFMoYWwsIGEsIDcpXG4gICAgICB2YXIgc2lnbWEwbCA9IFMoYWwsIGEsIDI4KSBeIFMoYSwgYWwsIDIpIF4gUyhhLCBhbCwgNylcbiAgICAgIHZhciBzaWdtYTFoID0gUyhlLCBlbCwgMTQpIF4gUyhlLCBlbCwgMTgpIF4gUyhlbCwgZSwgOSlcbiAgICAgIHZhciBzaWdtYTFsID0gUyhlbCwgZSwgMTQpIF4gUyhlbCwgZSwgMTgpIF4gUyhlLCBlbCwgOSlcblxuICAgICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuICAgICAgdmFyIEtpID0gS1tqXVxuICAgICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICAgIHZhciBjaCA9IENoKGUsIGYsIGcpXG4gICAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgICAgdmFyIHQxbCA9IGhsICsgc2lnbWExbFxuICAgICAgdmFyIHQxID0gaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApXG4gICAgICB0MWwgPSB0MWwgKyBjaGxcbiAgICAgIHQxID0gdDEgKyBjaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApXG4gICAgICB0MWwgPSB0MWwgKyBLaWxcbiAgICAgIHQxID0gdDEgKyBLaSArICgodDFsID4+PiAwKSA8IChLaWwgPj4+IDApID8gMSA6IDApXG4gICAgICB0MWwgPSB0MWwgKyBXaWxcbiAgICAgIHQxID0gdDEgKyBXaSArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApXG5cbiAgICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgICB2YXIgdDJsID0gc2lnbWEwbCArIG1hamxcbiAgICAgIHZhciB0MiA9IHNpZ21hMGggKyBtYWogKyAoKHQybCA+Pj4gMCkgPCAoc2lnbWEwbCA+Pj4gMCkgPyAxIDogMClcblxuICAgICAgaCAgPSBnXG4gICAgICBobCA9IGdsXG4gICAgICBnICA9IGZcbiAgICAgIGdsID0gZmxcbiAgICAgIGYgID0gZVxuICAgICAgZmwgPSBlbFxuICAgICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgICAgZSAgPSAoZCArIHQxICsgKChlbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICAgIGQgID0gY1xuICAgICAgZGwgPSBjbFxuICAgICAgYyAgPSBiXG4gICAgICBjbCA9IGJsXG4gICAgICBiICA9IGFcbiAgICAgIGJsID0gYWxcbiAgICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgICBhICA9ICh0MSArIHQyICsgKChhbCA+Pj4gMCkgPCAodDFsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgfVxuXG4gICAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gICAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gICAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gICAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gICAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gICAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gICAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gICAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhICsgKCh0aGlzLl9hbCA+Pj4gMCkgPCAoYWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9iID0gKHRoaXMuX2IgKyBiICsgKCh0aGlzLl9ibCA+Pj4gMCkgPCAoYmwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjICsgKCh0aGlzLl9jbCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkICsgKCh0aGlzLl9kbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9lID0gKHRoaXMuX2UgKyBlICsgKCh0aGlzLl9lbCA+Pj4gMCkgPCAoZWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9mID0gKHRoaXMuX2YgKyBmICsgKCh0aGlzLl9mbCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9nID0gKHRoaXMuX2cgKyBnICsgKCh0aGlzLl9nbCA+Pj4gMCkgPCAoZ2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9oID0gKHRoaXMuX2ggKyBoICsgKCh0aGlzLl9obCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgfVxuXG4gIFNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEggPSBuZXcgQnVmZmVyKDY0KVxuXG4gICAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFKGgsIGwsIG9mZnNldCkge1xuICAgICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgICB9XG5cbiAgICB3cml0ZUludDY0QkUodGhpcy5fYSwgdGhpcy5fYWwsIDApXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2IsIHRoaXMuX2JsLCA4KVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9jLCB0aGlzLl9jbCwgMTYpXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2QsIHRoaXMuX2RsLCAyNClcbiAgICB3cml0ZUludDY0QkUodGhpcy5fZSwgdGhpcy5fZWwsIDMyKVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9mLCB0aGlzLl9mbCwgNDApXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2csIHRoaXMuX2dsLCA0OClcbiAgICB3cml0ZUludDY0QkUodGhpcy5faCwgdGhpcy5faGwsIDU2KVxuXG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIHJldHVybiBTaGE1MTJcblxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2hhLmpzL3NoYTUxMi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0aDMyOiByZXF1aXJlKFwiLi94eGhhc2hcIilcbixcdGg2NDogcmVxdWlyZShcIi4veHhoYXNoNjRcIilcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3h4aGFzaGpzL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG54eEhhc2ggaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5NSVQgbGljZW5zZVxuKi9cbnZhciBVSU5UMzIgPSByZXF1aXJlKCdjdWludCcpLlVJTlQzMlxuXG4vKlxuXHRNZXJnZWQgdGhpcyBzZXF1ZW5jZSBvZiBtZXRob2QgY2FsbHMgYXMgaXQgc3BlZWRzIHVwXG5cdHRoZSBjYWxjdWxhdGlvbnMgYnkgYSBmYWN0b3Igb2YgMlxuICovXG4vLyB0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUUzMl8yKSApLnJvdGwoMTMpLm11bHRpcGx5KFBSSU1FMzJfMSk7XG5VSU5UMzIucHJvdG90eXBlLnh4aF91cGRhdGUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG5cdHZhciBiMDAgPSBQUklNRTMyXzIuX2xvd1xuXHR2YXIgYjE2ID0gUFJJTUUzMl8yLl9oaWdoXG5cblx0dmFyIGMxNiwgYzAwXG5cdGMwMCA9IGxvdyAqIGIwMFxuXHRjMTYgPSBjMDAgPj4+IDE2XG5cblx0YzE2ICs9IGhpZ2ggKiBiMDBcblx0YzE2ICY9IDB4RkZGRlx0XHQvLyBOb3QgcmVxdWlyZWQgYnV0IGltcHJvdmVzIHBlcmZvcm1hbmNlXG5cdGMxNiArPSBsb3cgKiBiMTZcblxuXHR2YXIgYTAwID0gdGhpcy5fbG93ICsgKGMwMCAmIDB4RkZGRilcblx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblxuXHRhMTYgKz0gdGhpcy5faGlnaCArIChjMTYgJiAweEZGRkYpXG5cblx0dmFyIHYgPSAoYTE2IDw8IDE2KSB8IChhMDAgJiAweEZGRkYpXG5cdHYgPSAodiA8PCAxMykgfCAodiA+Pj4gMTkpXG5cblx0YTAwID0gdiAmIDB4RkZGRlxuXHRhMTYgPSB2ID4+PiAxNlxuXG5cdGIwMCA9IFBSSU1FMzJfMS5fbG93XG5cdGIxNiA9IFBSSU1FMzJfMS5faGlnaFxuXG5cdGMwMCA9IGEwMCAqIGIwMFxuXHRjMTYgPSBjMDAgPj4+IDE2XG5cblx0YzE2ICs9IGExNiAqIGIwMFxuXHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0YzE2ICs9IGEwMCAqIGIxNlxuXG5cdHRoaXMuX2xvdyA9IGMwMCAmIDB4RkZGRlxuXHR0aGlzLl9oaWdoID0gYzE2ICYgMHhGRkZGXG59XG5cbi8qXG4gKiBDb25zdGFudHNcbiAqL1xudmFyIFBSSU1FMzJfMSA9IFVJTlQzMiggJzI2NTQ0MzU3NjEnIClcbnZhciBQUklNRTMyXzIgPSBVSU5UMzIoICcyMjQ2ODIyNTE5JyApXG52YXIgUFJJTUUzMl8zID0gVUlOVDMyKCAnMzI2NjQ4OTkxNycgKVxudmFyIFBSSU1FMzJfNCA9IFVJTlQzMiggICc2NjgyNjUyNjMnIClcbnZhciBQUklNRTMyXzUgPSBVSU5UMzIoICAnMzc0NzYxMzkzJyApXG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBwcm9wZXIgVVRGLTggYXJyYXlcbiogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVURjggYXJyYXkgaXMgcmV0dXJuZWQgYXMgdWludDggYXJyYXlcbiovXG5mdW5jdGlvbiB0b1VURjhBcnJheSAoc3RyKSB7XG5cdHZhciB1dGY4ID0gW11cblx0Zm9yICh2YXIgaT0wLCBuPXN0ci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKVxuXHRcdGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSlcblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRlbHNlIHtcblx0XHRcdGkrKztcblx0XHRcdC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcblx0XHRcdC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcblx0XHRcdC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG5cdFx0XHRjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG5cdFx0XHR8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSlcblx0XHRcdHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHV0ZjgpXG59XG5cbi8qKlxuICogWFhIIG9iamVjdCB1c2VkIGFzIGEgY29uc3RydWN0b3Igb3IgYSBmdW5jdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcnxVSU5UMzJ9IHNlZWRcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqIG9yXG4gKiBAcmV0dXJuIHtVSU5UMzJ9IHh4SGFzaFxuICovXG5mdW5jdGlvbiBYWEggKCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKVxuXHRcdHJldHVybiBuZXcgWFhIKCBhcmd1bWVudHNbMV0gKS51cGRhdGUoIGFyZ3VtZW50c1swXSApLmRpZ2VzdCgpXG5cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFhYSCkpXG5cdFx0cmV0dXJuIG5ldyBYWEgoIGFyZ3VtZW50c1swXSApXG5cblx0aW5pdC5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSlcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBYWEggaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHNlZWQgYXMgYSBudW1iZXIgb3IgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cbiBmdW5jdGlvbiBpbml0IChzZWVkKSB7XG5cdHRoaXMuc2VlZCA9IHNlZWQgaW5zdGFuY2VvZiBVSU5UMzIgPyBzZWVkLmNsb25lKCkgOiBVSU5UMzIoc2VlZClcblx0dGhpcy52MSA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTMyXzEpLmFkZChQUklNRTMyXzIpXG5cdHRoaXMudjIgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUUzMl8yKVxuXHR0aGlzLnYzID0gdGhpcy5zZWVkLmNsb25lKClcblx0dGhpcy52NCA9IHRoaXMuc2VlZC5jbG9uZSgpLnN1YnRyYWN0KFBSSU1FMzJfMSlcblx0dGhpcy50b3RhbF9sZW4gPSAwXG5cdHRoaXMubWVtc2l6ZSA9IDBcblx0dGhpcy5tZW1vcnkgPSBudWxsXG5cblx0cmV0dXJuIHRoaXNcbn1cblhYSC5wcm90b3R5cGUuaW5pdCA9IGluaXRcblxuLyoqXG4gKiBBZGQgZGF0YSB0byBiZSBjb21wdXRlZCBmb3IgdGhlIFhYSCBoYXNoXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfSBpbnB1dCBhcyBhIHN0cmluZyBvciBub2RlanMgQnVmZmVyIG9yIEFycmF5QnVmZmVyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cblhYSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgaXNBcnJheUJ1ZmZlclxuXG5cdC8vIENvbnZlcnQgYWxsIHN0cmluZ3MgdG8gdXRmLTggZmlyc3QgKGlzc3VlICM1KVxuXHRpZiAoaXNTdHJpbmcpIHtcblx0XHRpbnB1dCA9IHRvVVRGOEFycmF5KGlucHV0KVxuXHRcdGlzU3RyaW5nID0gZmFsc2Vcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHR9XG5cblx0aWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHR7XG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0XHRpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcblx0fVxuXG5cdHZhciBwID0gMFxuXHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoXG5cdHZhciBiRW5kID0gcCArIGxlblxuXG5cdGlmIChsZW4gPT0gMCkgcmV0dXJuIHRoaXNcblxuXHR0aGlzLnRvdGFsX2xlbiArPSBsZW5cblxuXHRpZiAodGhpcy5tZW1zaXplID09IDApXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gJydcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoMTYpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IEJ1ZmZlcigxNilcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplICsgbGVuIDwgMTYpICAgLy8gZmlsbCBpbiB0bXAgYnVmZmVyXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgbGVuKVxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXRcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgbGVuKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgbGVuIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgKz0gbGVuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgPiAwKSAgIC8vIHNvbWUgZGF0YSBsZWZ0IGZyb20gcHJldmlvdXMgdXBkYXRlXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgMTYtdGhpcy5tZW1zaXplKTtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0LnNsaWNlKDAsIDE2IC0gdGhpcy5tZW1zaXplKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCAxNiAtIHRoaXMubWVtc2l6ZSksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIDAsIDE2IC0gdGhpcy5tZW1zaXplIClcblx0XHR9XG5cblx0XHR2YXIgcDMyID0gMFxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHR9XG5cblx0XHRwICs9IDE2IC0gdGhpcy5tZW1zaXplXG5cdFx0dGhpcy5tZW1zaXplID0gMFxuXHRcdGlmIChpc1N0cmluZykgdGhpcy5tZW1vcnkgPSAnJ1xuXHR9XG5cblx0aWYgKHAgPD0gYkVuZCAtIDE2KVxuXHR7XG5cdFx0dmFyIGxpbWl0ID0gYkVuZCAtIDE2XG5cblx0XHRkb1xuXHRcdHtcblx0XHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdFx0cCArPSA0XG5cdFx0fSB3aGlsZSAocCA8PSBsaW1pdClcblx0fVxuXG5cdGlmIChwIDwgYkVuZClcblx0e1xuXHRcdC8vIFhYSF9tZW1jcHkodGhpcy5tZW1vcnksIHAsIGJFbmQtcCk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZShwKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheShwLCBiRW5kKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgcCwgYkVuZCApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplID0gYkVuZCAtIHBcblx0fVxuXG5cdHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogRmluYWxpemUgdGhlIFhYSCBjb21wdXRhdGlvbi4gVGhlIFhYSCBpbnN0YW5jZSBpcyByZWFkeSBmb3IgcmV1c2UgZm9yIHRoZSBnaXZlbiBzZWVkXG4gKiBAbWV0aG9kIGRpZ2VzdFxuICogQHJldHVybiB7VUlOVDMyfSB4eEhhc2hcbiAqL1xuWFhILnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpbnB1dCA9IHRoaXMubWVtb3J5XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgcCA9IDBcblx0dmFyIGJFbmQgPSB0aGlzLm1lbXNpemVcblx0dmFyIGgzMiwgaFxuXHR2YXIgdSA9IG5ldyBVSU5UMzJcblxuXHRpZiAodGhpcy50b3RhbF9sZW4gPj0gMTYpXG5cdHtcblx0XHRoMzIgPSB0aGlzLnYxLnJvdGwoMSkuYWRkKCB0aGlzLnYyLnJvdGwoNykuYWRkKCB0aGlzLnYzLnJvdGwoMTIpLmFkZCggdGhpcy52NC5yb3RsKDE4KSApICkgKVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGgzMiAgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoIFBSSU1FMzJfNSApXG5cdH1cblxuXHRoMzIuYWRkKCB1LmZyb21OdW1iZXIodGhpcy50b3RhbF9sZW4pIClcblxuXHR3aGlsZSAocCA8PSBiRW5kIC0gNClcblx0e1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHQpXG5cdFx0fVxuXHRcdGgzMlxuXHRcdFx0LmFkZCggdS5tdWx0aXBseShQUklNRTMyXzMpIClcblx0XHRcdC5yb3RsKDE3KVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTMyXzQgKVxuXHRcdHAgKz0gNFxuXHR9XG5cblx0d2hpbGUgKHAgPCBiRW5kKVxuXHR7XG5cdFx0dS5mcm9tQml0cyggaXNTdHJpbmcgPyBpbnB1dC5jaGFyQ29kZUF0KHArKykgOiBpbnB1dFtwKytdLCAwIClcblx0XHRoMzJcblx0XHRcdC5hZGQoIHUubXVsdGlwbHkoUFJJTUUzMl81KSApXG5cdFx0XHQucm90bCgxMSlcblx0XHRcdC5tdWx0aXBseShQUklNRTMyXzEpXG5cdH1cblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxNSlcblx0aDMyLnhvcihoKS5tdWx0aXBseShQUklNRTMyXzIpXG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTMpXG5cdGgzMi54b3IoaCkubXVsdGlwbHkoUFJJTUUzMl8zKVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDE2KVxuXHRoMzIueG9yKGgpXG5cblx0Ly8gUmVzZXQgdGhlIHN0YXRlXG5cdHRoaXMuaW5pdCggdGhpcy5zZWVkIClcblxuXHRyZXR1cm4gaDMyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gWFhIXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94eGhhc2hqcy9saWIveHhoYXNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbnh4SGFzaDY0IGltcGxlbWVudGF0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKEMpIDIwMTYsIFBpZXJyZSBDdXJ0b1xuTUlUIGxpY2Vuc2VcbiovXG52YXIgVUlOVDY0ID0gcmVxdWlyZSgnY3VpbnQnKS5VSU5UNjRcblxuLypcbiAqIENvbnN0YW50c1xuICovXG52YXIgUFJJTUU2NF8xID0gVUlOVDY0KCAnMTE0MDA3MTQ3ODUwNzQ2OTQ3OTEnIClcbnZhciBQUklNRTY0XzIgPSBVSU5UNjQoICcxNDAyOTQ2NzM2Njg5NzAxOTcyNycgKVxudmFyIFBSSU1FNjRfMyA9IFVJTlQ2NCggICcxNjA5NTg3OTI5MzkyODM5MTYxJyApXG52YXIgUFJJTUU2NF80ID0gVUlOVDY0KCAgJzk2NTAwMjkyNDIyODc4Mjg1NzknIClcbnZhciBQUklNRTY0XzUgPSBVSU5UNjQoICAnMjg3MDE3NzQ1MDAxMjYwMDI2MScgKVxuXG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gcHJvcGVyIFVURi04IGFycmF5XG4qIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtVaW50OEFycmF5fSBVVEY4IGFycmF5IGlzIHJldHVybmVkIGFzIHVpbnQ4IGFycmF5XG4qL1xuZnVuY3Rpb24gdG9VVEY4QXJyYXkgKHN0cikge1xuXHR2YXIgdXRmOCA9IFtdXG5cdGZvciAodmFyIGk9MCwgbj1zdHIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0dmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSlcblx0XHRpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpXG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0ZWxzZSB7XG5cdFx0XHRpKys7XG5cdFx0XHQvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG5cdFx0XHQvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG5cdFx0XHQvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuXHRcdFx0Y2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuXHRcdFx0fCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpXG5cdFx0XHR1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PjE4KSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgVWludDhBcnJheSh1dGY4KVxufVxuXG4vKipcbiAqIFhYSDY0IG9iamVjdCB1c2VkIGFzIGEgY29uc3RydWN0b3Igb3IgYSBmdW5jdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcnxVSU5UNjR9IHNlZWRcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqIG9yXG4gKiBAcmV0dXJuIHtVSU5UNjR9IHh4SGFzaFxuICovXG5mdW5jdGlvbiBYWEg2NCAoKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG5cdFx0cmV0dXJuIG5ldyBYWEg2NCggYXJndW1lbnRzWzFdICkudXBkYXRlKCBhcmd1bWVudHNbMF0gKS5kaWdlc3QoKVxuXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBYWEg2NCkpXG5cdFx0cmV0dXJuIG5ldyBYWEg2NCggYXJndW1lbnRzWzBdIClcblxuXHRpbml0LmNhbGwodGhpcywgYXJndW1lbnRzWzBdKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFhYSDY0IGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBzZWVkIGFzIGEgbnVtYmVyIG9yIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG4gZnVuY3Rpb24gaW5pdCAoc2VlZCkge1xuXHR0aGlzLnNlZWQgPSBzZWVkIGluc3RhbmNlb2YgVUlOVDY0ID8gc2VlZC5jbG9uZSgpIDogVUlOVDY0KHNlZWQpXG5cdHRoaXMudjEgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYyID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FNjRfMilcblx0dGhpcy52MyA9IHRoaXMuc2VlZC5jbG9uZSgpXG5cdHRoaXMudjQgPSB0aGlzLnNlZWQuY2xvbmUoKS5zdWJ0cmFjdChQUklNRTY0XzEpXG5cdHRoaXMudG90YWxfbGVuID0gMFxuXHR0aGlzLm1lbXNpemUgPSAwXG5cdHRoaXMubWVtb3J5ID0gbnVsbFxuXG5cdHJldHVybiB0aGlzXG59XG5YWEg2NC5wcm90b3R5cGUuaW5pdCA9IGluaXRcblxuLyoqXG4gKiBBZGQgZGF0YSB0byBiZSBjb21wdXRlZCBmb3IgdGhlIFhYSDY0IGhhc2hcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ9IGlucHV0IGFzIGEgc3RyaW5nIG9yIG5vZGVqcyBCdWZmZXIgb3IgQXJyYXlCdWZmZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuWFhINjQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIGlzQXJyYXlCdWZmZXJcblxuXHQvLyBDb252ZXJ0IGFsbCBzdHJpbmdzIHRvIHV0Zi04IGZpcnN0IChpc3N1ZSAjNSlcblx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0aW5wdXQgPSB0b1VURjhBcnJheShpbnB1dClcblx0XHRpc1N0cmluZyA9IGZhbHNlXG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0fVxuXG5cdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0e1xuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdFx0aW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG5cdH1cblxuXHR2YXIgcCA9IDBcblx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aFxuXHR2YXIgYkVuZCA9IHAgKyBsZW5cblxuXHRpZiAobGVuID09IDApIHJldHVybiB0aGlzXG5cblx0dGhpcy50b3RhbF9sZW4gKz0gbGVuXG5cblx0aWYgKHRoaXMubWVtc2l6ZSA9PSAwKVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9ICcnXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDMyKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBCdWZmZXIoMzIpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSArIGxlbiA8IDMyKSAgIC8vIGZpbGwgaW4gdG1wIGJ1ZmZlclxuXHR7XG5cdFx0Ly8gWFhINjRfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgbGVuKVxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXRcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgbGVuKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgbGVuIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgKz0gbGVuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgPiAwKSAgIC8vIHNvbWUgZGF0YSBsZWZ0IGZyb20gcHJldmlvdXMgdXBkYXRlXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCAxNi10aGlzLm1lbXNpemUpO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UoMCwgMzIgLSB0aGlzLm1lbXNpemUpXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIDMyIC0gdGhpcy5tZW1zaXplKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgMzIgLSB0aGlzLm1lbXNpemUgKVxuXHRcdH1cblxuXHRcdHZhciBwNjQgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR2YXIgb3RoZXJcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52My5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52MS5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52NC5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdH1cblxuXHRcdHAgKz0gMzIgLSB0aGlzLm1lbXNpemVcblx0XHR0aGlzLm1lbXNpemUgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB0aGlzLm1lbW9yeSA9ICcnXG5cdH1cblxuXHRpZiAocCA8PSBiRW5kIC0gMzIpXG5cdHtcblx0XHR2YXIgbGltaXQgPSBiRW5kIC0gMzJcblxuXHRcdGRvXG5cdFx0e1xuXHRcdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYyLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb3RoZXJcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52My5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHR9XG5cdFx0XHRwICs9IDhcblx0XHR9IHdoaWxlIChwIDw9IGxpbWl0KVxuXHR9XG5cblx0aWYgKHAgPCBiRW5kKVxuXHR7XG5cdFx0Ly8gWFhINjRfbWVtY3B5KHRoaXMubWVtb3J5LCBwLCBiRW5kLXApO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UocClcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkocCwgYkVuZCksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIHAsIGJFbmQgKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSA9IGJFbmQgLSBwXG5cdH1cblxuXHRyZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBYWEg2NCBjb21wdXRhdGlvbi4gVGhlIFhYSDY0IGluc3RhbmNlIGlzIHJlYWR5IGZvciByZXVzZSBmb3IgdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgZGlnZXN0XG4gKiBAcmV0dXJuIHtVSU5UNjR9IHh4SGFzaFxuICovXG5YWEg2NC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLm1lbW9yeVxuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIHAgPSAwXG5cdHZhciBiRW5kID0gdGhpcy5tZW1zaXplXG5cdHZhciBoNjQsIGhcblx0dmFyIHUgPSBuZXcgVUlOVDY0XG5cblx0aWYgKHRoaXMudG90YWxfbGVuID49IDMyKVxuXHR7XG5cdFx0aDY0ID0gdGhpcy52MS5jbG9uZSgpLnJvdGwoMSlcblx0XHRoNjQuYWRkKCB0aGlzLnYyLmNsb25lKCkucm90bCg3KSApXG5cdFx0aDY0LmFkZCggdGhpcy52My5jbG9uZSgpLnJvdGwoMTIpIClcblx0XHRoNjQuYWRkKCB0aGlzLnY0LmNsb25lKCkucm90bCgxOCkgKVxuXG5cdFx0aDY0LnhvciggdGhpcy52MS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnYyLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjMubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52NC5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0aDY0ICA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZCggUFJJTUU2NF81IClcblx0fVxuXG5cdGg2NC5hZGQoIHUuZnJvbU51bWJlcih0aGlzLnRvdGFsX2xlbikgKVxuXG5cdHdoaWxlIChwIDw9IGJFbmQgLSA4KVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs3KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs2KVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHQpXG5cdFx0fVxuXHRcdHUubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpXG5cdFx0aDY0XG5cdFx0XHQueG9yKHUpXG5cdFx0XHQucm90bCgyNylcblx0XHRcdC5tdWx0aXBseSggUFJJTUU2NF8xIClcblx0XHRcdC5hZGQoIFBSSU1FNjRfNCApXG5cdFx0cCArPSA4XG5cdH1cblxuXHRpZiAocCArIDQgPD0gYkVuZCkge1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHQsXHQwXG5cdFx0XHQsXHQwXG5cdFx0XHQpXG5cdFx0fVxuXHRcdGg2NFxuXHRcdFx0LnhvciggdS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRcdC5yb3RsKDIzKVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzIgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF8zIClcblx0XHRwICs9IDRcblx0fVxuXG5cdHdoaWxlIChwIDwgYkVuZClcblx0e1xuXHRcdHUuZnJvbUJpdHMoIGlzU3RyaW5nID8gaW5wdXQuY2hhckNvZGVBdChwKyspIDogaW5wdXRbcCsrXSwgMCwgMCwgMCApXG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfNSkgKVxuXHRcdFx0LnJvdGwoMTEpXG5cdFx0XHQubXVsdGlwbHkoUFJJTUU2NF8xKVxuXHR9XG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMzMpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8yKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDI5KVxuXHRoNjQueG9yKGgpLm11bHRpcGx5KFBSSU1FNjRfMylcblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMilcblx0aDY0LnhvcihoKVxuXG5cdC8vIFJlc2V0IHRoZSBzdGF0ZVxuXHR0aGlzLmluaXQoIHRoaXMuc2VlZCApXG5cblx0cmV0dXJuIGg2NFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhYSDY0XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94eGhhc2hqcy9saWIveHhoYXNoNjQuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogY3J5cHRvIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDE4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==