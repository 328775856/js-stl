(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DS"] = factory();
	else
		root["DS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	    Array: {
	        CrossList: __webpack_require__(108).default,
	        TSMatrix: __webpack_require__(109).default
	    },
	
	    BinaryTree: {
	        // BinaryThreadTree: require('./BinaryTree/BinaryThreadTree'),
	        BinaryTree: __webpack_require__(16),
	        // EBTNode: require('./BinaryTree/EBTNode'),
	        huffManCoding: __webpack_require__(110).default
	    },
	
	    GeneralizedList: __webpack_require__(111).default,
	
	    Graph: {
	        AdjacencyListGraph: __webpack_require__(113).default,
	        AdjacencyMatrixGraph: __webpack_require__(114).default,
	        AMLGraph: __webpack_require__(112).default,
	        OLGraph: __webpack_require__(115).default
	    },
	
	    List: {
	        DoubleLinkedList: __webpack_require__(53).default,
	        LinearList: __webpack_require__(117),
	        StaticLinkedList: __webpack_require__(55).default,
	        LRUCache: __webpack_require__(116).default
	    },
	
	    Queue: {
	        CycleQueue: __webpack_require__(118).default,
	        PriorityQueue: __webpack_require__(119).default,
	        Queue: __webpack_require__(12).default
	    },
	
	    Search: {
	        AVLTree: __webpack_require__(120),
	        binarySearch: __webpack_require__(123),
	        BinarySortedTree: __webpack_require__(56).default,
	        BPlusTree: __webpack_require__(121),
	        BTree: __webpack_require__(122),
	        DigitalSearchTree: __webpack_require__(125),
	        fibonacciSearch: __webpack_require__(129).default,
	        HashTable: __webpack_require__(126),
	        RedBlackTree: __webpack_require__(127).default,
	        sequentialSearch: __webpack_require__(130).default,
	        SOSTree: __webpack_require__(128),
	        BloomFilter: __webpack_require__(124)
	    },
	
	    Sort: {
	        distribution: __webpack_require__(131),
	        exchange: __webpack_require__(57),
	        insertion: __webpack_require__(132),
	        merging: __webpack_require__(133),
	        selection: __webpack_require__(134)
	    },
	
	    Stack: __webpack_require__(17).default,
	
	    String: {
	        HString: __webpack_require__(135).default,
	        LString: __webpack_require__(136).default,
	        SString: __webpack_require__(137).default
	    }
	};

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(99)
	var ieee754 = __webpack_require__(138)
	var isArray = __webpack_require__(140)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(20)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 5 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(44)
	  , toPrimitive    = __webpack_require__(35)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(4) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(75)
	  , defined = __webpack_require__(25);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(61);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 9 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(6)
	  , createDesc = __webpack_require__(22);
	module.exports = __webpack_require__(4) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(33)('wks')
	  , uid        = __webpack_require__(23)
	  , Symbol     = __webpack_require__(3).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 队列Queue
	 *
	 * 队列是一种先进先出（first in first out, FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。
	 * 允许插入的一端叫队尾（rear），允许删除的一端叫队头（front）。
	 */
	
	// 链队列
	var Queue = function () {
	    function Queue() {
	        (0, _classCallCheck3.default)(this, Queue);
	
	        this.rear = this.front = null;
	        this.size = 0;
	    }
	
	    Queue.prototype.isEmpty = function isEmpty() {
	        return this.rear === null;
	    };
	
	    Queue.prototype.clear = function clear() {
	        this.rear = this.front = null;
	        this.size = 0;
	    };
	
	    Queue.prototype.getHead = function getHead() {
	        return this.front ? this.front.data : null;
	    };
	
	    Queue.prototype.enQueue = function enQueue(elem) {
	        if (this.front === null) {
	            this.rear = this.front = { data: elem, next: null };
	        } else {
	            var p = { data: elem, next: null };
	            this.rear.next = p;
	            this.rear = p;
	        }
	        this.size++;
	    };
	
	    Queue.prototype.deQueue = function deQueue() {
	        if (this.front) {
	            var elem = this.front.data;
	            this.front = this.front.next;
	            if (this.front === null) {
	                this.rear = null;
	            }
	            this.size--;
	            return elem;
	        } else {
	            return null;
	        }
	    };
	
	    Queue.prototype.queueTraverse = function queueTraverse(iterator) {
	        var current = this.front;
	        while (current) {
	            if (iterator(current.data)) break;
	            current = current.next;
	        }
	    };
	
	    Queue.prototype.peekAt = function peekAt() {
	        var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	        if (index < this.size) {
	            var current = this.front;
	            for (var i = 0; i < index; i++) {
	                current = current.next;
	            }
	            return current.data;
	        }
	
	        return null;
	    };
	
	    Queue.prototype.toString = function toString() {
	        if (this.front === null) {
	            return null;
	        }
	
	        var arr = [];
	        var current = this.front;
	
	        for (var i = 0, len = this.size; i < len; i++) {
	            arr[i] = current.data;
	            current = current.next;
	        }
	
	        return arr;
	    };
	
	    return Queue;
	}();
	
	exports.default = Queue;
	
	
	var queue = new Queue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));
	console.log(queue.peekAt(3));
	console.log(queue.toString().join());
	
	// 类似广度优先遍历
	function repaintColor(matrix, i, j, color) {
	    var old = matrix[i][j];
	    var queue = new Queue();
	    var m = matrix.length - 1;
	    var n = matrix[0].length - 1;
	
	    queue.enQueue({ x: i, y: j });
	
	    while (queue.rear) {
	        var a = queue.deQueue();
	        var x = a.x;
	        var y = a.y;
	
	        if (x >= 1) setColor(x - 1, y);
	        if (y >= 1) setColor(x, y - 1);
	        if (x < m) setColor(x + 1, y);
	        if (y < n) setColor(x, y + 1);
	    }
	
	    function setColor(x, y) {
	        if (matrix[x][y] === old) {
	            matrix[x][y] = color;
	            queue.enQueue({ x: x, y: y });
	        }
	    }
	}
	
	var matrix = [];
	
	for (var i = 0; i < 8; i++) {
	    matrix[i] = [];
	    for (var j = 0; j < 8; j++) {
	        matrix[i][j] = 0;
	    }
	}
	
	repaintColor(matrix, 4, 5, 1);
	console.log(matrix);

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(15);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(3)
	  , core      = __webpack_require__(9)
	  , ctx       = __webpack_require__(42)
	  , hide      = __webpack_require__(10)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ChildSiblingTree = exports.ChildTree = exports.ParentTree = exports.BinaryTree = undefined;
	
	var _regenerator = __webpack_require__(38);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(17);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 树的一些概念
	 *
	 * 树（Tree）是n（n>=0）个结点的有限集。在任意一棵非空树中：
	 * （1）有且仅有一个特定的称为根（Root）的结点；
	 * （2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,T3,...Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。
	 *
	 * 例如，（a）是只有一个根结点的树；
	 * （b）是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。
	 *
	 * 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。例如，（b）中A的度为3，C的度为1，F的度为0.度为0的结点称为叶子（Leaf）或者终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。（b）的树的度为3.结点的子树的根称为该结点的孩子（Child）。相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。
	 * 结点的层次（Level）从根开始定义起，根为第一层，跟的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。例如，结点G与E，F,H,I,J互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。（b）的树的深度为4。
	 *
	 * 如果将树中结点的各子树看成从左至右是有次序的（即不能交换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
	 * 森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
	 *
	 *
	 */
	
	/**
	 * 二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）
	 *
	 * 二叉树的性质
	 * 1.在二叉树的第i层上至多有2的i-1次方个结点(i>=1)。
	 * 2.深度为k的二叉树至多有2的k次方-1个结点，(k>=1)。
	 * 3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1;
	 *      一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树。
	 *      深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。
	 * 下面是完全二叉树的两个特性
	 * 4.具有n个结点的完全二叉树的深度为Math.floor(log 2 n) + 1
	 * 5.如果对一棵有n个结点的完全二叉树（其深度为Math.floor(log 2 n) + 1）的结点按层序编号（从第1层到第Math.floor(2 n) + 1，每层从左到右），则对任一结点（1<=i<=n）有：
	 *     (1)如果i=1，则结点i、是二叉树的根，无双亲；如果i>1，则其双亲parent(i)是结点Math.floor(i/2)。
	 *     (2)如果2i > n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LChild(i)是结点2i.
	 *     (3)如果2i + 1 > n，则结点i无右孩子；否则其右孩子RChild(i)是结点2i + 1;
	 */
	
	/*
	 二叉树的存储结构
	
	 1.顺序存储结构
	 用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，即将二叉树上编号为i的结点元素存储在加上定义的一维数组中下标为i-1的分量中。“0”表示不存在此结点。这种顺序存储结构仅适用于完全二叉树。
	 因为，在最坏情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为2的n次方-1的一维数组。
	
	 2.链式存储结构
	 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左右指针域。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结构所得的二叉树的存储结构分别称之为二叉链表和三叉链表。
	 在含有n个结点的二叉链表中有n+1个空链域，我们可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构---线索链表。
	
	 先（根）序遍历：根左右
	 中（根）序遍历：左根右
	 后（根）序遍历：左右根
	
	 */
	
	// 顺序存储结构
	(function () {
	    // 顺序存储结构的遍历
	    var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	
	    console.log('preOrder:');
	    void function preOrderRecursive(x, visit) {
	        visit(tree[x]);
	        if (tree[2 * x + 1]) preOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) preOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('inOrder:');
	    void function inOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) inOrderRecursive(2 * x + 1, visit);
	        visit(tree[x]);
	        if (tree[2 * x + 2]) inOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('postOrder:');
	    void function postOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) postOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) postOrderRecursive(2 * x + 2, visit);
	        visit(tree[x]);
	    }(0, function (value) {
	        console.log(value);
	    });
	})();
	
	// 链式存储结构
	var BinaryTree = exports.BinaryTree = function () {
	    function BinaryTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var leftChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var rightChild = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, BinaryTree);
	
	        this.data = data;
	        // 左右孩子结点
	        this.leftChild = leftChild;
	        this.rightChild = rightChild;
	    }
	
	    // 判断两棵树是否相似
	
	
	    BinaryTree.prototype.isSimilar = function isSimilar(tree) {
	        return !!(tree && (this.leftChild && this.leftChild.isSimilar(tree.leftChild) || !this.leftChild && !tree.leftChild) && (this.rightChild && this.rightChild.isSimilar(tree.rightChild) || !this.rightChild && !tree.rightChild));
	    };
	
	    BinaryTree.prototype.createBinaryTree = function createBinaryTree(tree) {
	        void function preOrderRecursive(node, x, visit) {
	            visit(node, tree[x]);
	
	            var p = void 0;
	            if (tree[2 * x + 1]) {
	                p = node.leftChild = new BinaryTree();
	                preOrderRecursive(p, 2 * x + 1, visit);
	            }
	            if (tree[2 * x + 2]) {
	                p = node.rightChild = new BinaryTree();
	                preOrderRecursive(p, 2 * x + 2, visit);
	            }
	
	            if (p) p.parentNode = node;
	        }(this, 0, function (node, value) {
	            node.data = value;
	        });
	    };
	
	    /** Prefix iteration */
	
	
	    BinaryTree.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
	        return _regenerator2.default.wrap(function _callee$(_context) {
	            while (1) {
	                switch (_context.prev = _context.next) {
	                    case 0:
	                        _context.next = 2;
	                        return this.data;
	
	                    case 2:
	                        if (!this.leftChild) {
	                            _context.next = 4;
	                            break;
	                        }
	
	                        return _context.delegateYield(this.leftChild, 't0', 4);
	
	                    case 4:
	                        if (!this.rightChild) {
	                            _context.next = 6;
	                            break;
	                        }
	
	                        return _context.delegateYield(this.rightChild, 't1', 6);
	
	                    case 6:
	                    case 'end':
	                        return _context.stop();
	                }
	            }
	        }, _callee, this);
	    });
	
	    // 先序遍历二叉树的非递归算法
	
	    BinaryTree.prototype.preOrderNonRecursive = function preOrderNonRecursive(visit) {
	        var stack = new _index2.default();
	        var p = this;
	
	        while (p || stack.length) {
	            // 向左走到尽头
	            if (p) {
	                stack.push(p);
	                p.data && visit(p.data);
	                p = p.leftChild;
	            } else {
	                p = stack.pop();
	                p = p.rightChild;
	            }
	        }
	    };
	
	    // 中序非递归遍历
	
	
	    BinaryTree.prototype.inOrderNonRecursive = function inOrderNonRecursive(visit) {
	        var stack = new _index2.default();
	        var p = this;
	
	        while (p || stack.length) {
	            if (p) {
	                stack.push(p);
	                p = p.leftChild;
	            } else {
	                p = stack.pop();
	                p.data && visit(p.data);
	                p = p.rightChild;
	            }
	        }
	    };
	
	    // 为了区分两次过栈的不同处理方式，在堆栈中增加一个mark域，
	    // mark=0表示刚刚访问此结点，mark=1表示左子树处理结束返回，
	    // mark=2表示右子树处理结束返回。每次根据栈顶的mark域决定做何动作
	
	
	    BinaryTree.prototype.postOrderNonRecursive = function postOrderNonRecursive(visit) {
	        var stack = new _index2.default();
	        stack.push([this, 0]);
	
	        while (stack.length) {
	            var a = stack.pop();
	            var node = a[0];
	
	            switch (a[1]) {
	                case 0:
	                    stack.push([node, 1]); // 修改mark域
	                    if (node.leftChild) stack.push([node.leftChild, 0]); // 访问左子树
	                    break;
	                case 1:
	                    stack.push([node, 2]);
	                    if (node.rightChild) stack.push([node.rightChild, 0]);
	                    break;
	                case 2:
	                    node.data && visit(node.data);
	                    break;
	                default:
	                    break;
	            }
	        }
	    };
	
	    BinaryTree.prototype.preOrderRecursive = function preOrderRecursive(visit) {
	        visit(this.data);
	        if (this.leftChild) this.leftChild.preOrderRecursive(visit);
	        if (this.rightChild) this.rightChild.preOrderRecursive(visit);
	    };
	
	    BinaryTree.prototype.inOrderRecursive = function inOrderRecursive(visit) {
	        if (this.leftChild) this.leftChild.inOrderRecursive(visit);
	        visit(this.data);
	        if (this.rightChild) this.rightChild.inOrderRecursive(visit);
	    };
	
	    BinaryTree.prototype.postOrderRecursive = function postOrderRecursive(visit) {
	        if (this.leftChild) this.leftChild.postOrderRecursive(visit);
	        if (this.rightChild) this.rightChild.postOrderRecursive(visit);
	        visit(this.data);
	    };
	
	    BinaryTree.prototype.levelOrderTraverse = function levelOrderTraverse(visit) {
	        var queue = new _Queue2.default();
	        queue.enQueue(this);
	
	        while (queue.rear) {
	            var p = queue.deQueue();
	            p.data && visit(p.data);
	            p.leftChild && queue.enQueue(p.leftChild);
	            p.rightChild && queue.enQueue(p.rightChild);
	        }
	    };
	
	    // 求先序序列为k的结点的值
	
	
	    BinaryTree.prototype.getPreSequence = function getPreSequence(k) {
	        var count = 0;
	        var data = null;
	
	        void function recurse(node) {
	            if (node) {
	                if (++count === k) data = node.data;else {
	                    recurse(node.leftChild);
	                    recurse(node.rightChild);
	                }
	            }
	        }(this);
	
	        return data;
	    };
	
	    // 求二叉树中叶子结点的数目
	
	
	    BinaryTree.prototype.countLeaves = function countLeaves() {
	        return function recurse(node) {
	            if (!node) return 0;else if (!node.leftChild && !node.rightChild) return 1;else return recurse(node.leftChild) + recurse(node.rightChild);
	        }(this);
	    };
	
	    // 交换所有结点的左右子树
	
	
	    BinaryTree.prototype.revoluteBinaryTree = function revoluteBinaryTree() {
	        var _ref = [this.rightChild, this.leftChild];
	        this.leftChild = _ref[0];
	        this.rightChild = _ref[1];
	
	
	        if (this.leftChild) this.leftChild.revoluteBinaryTree();
	        if (this.rightChild) this.rightChild.revoluteBinaryTree();
	    };
	
	    BinaryTree.prototype.revoluteNonRecursive = function revoluteNonRecursive() {
	        var stack = [];
	        stack.push(this);
	
	        while (stack.length) {
	            var node = stack.pop();
	            var _ref2 = [node.rightChild, node.leftChild];
	            node.leftChild = _ref2[0];
	            node.rightChild = _ref2[1];
	
	
	            if (node.leftChild) stack.push(node.leftChild);
	            if (node.rightChild) stack.push(node.rightChild);
	        }
	    };
	
	    // 求二叉树中以值为x的结点为根的子树深度
	
	
	    BinaryTree.prototype.getSubDepth = function getSubDepth(x) {
	        var count = 0;
	        var stack = new _index2.default();
	        stack.push(this);
	
	        while (stack.length) {
	            var node = stack.pop();
	
	            if (node.data === x) {
	                count = node.getDepth();
	                break;
	            } else {
	                if (node.leftChild) stack.push(node.leftChild);
	                if (node.rightChild) stack.push(node.rightChild);
	            }
	        }
	
	        return count;
	    };
	
	    BinaryTree.prototype.getDepth = function getDepth() {
	        var m = this.leftChild && this.leftChild.getDepth() || 0;
	        var n = this.rightChild && this.rightChild.getDepth() || 0;
	        return (m > n ? m : n) + 1;
	    };
	
	    // 删除所有以元素x为根的子树
	
	
	    BinaryTree.prototype.delSubX = function delSubX(x) {
	        if (this.data === x) {
	            this.leftChild = null;
	            this.rightChild = null;
	        } else {
	            if (this.leftChild) this.leftChild.delSubX(x);
	            if (this.rightChild) this.rightChild.delSubX(x);
	        }
	    };
	
	    /**
	     * 非递归复制二叉树
	     * @param {Function} cb 拷贝过程中会执行的回调，可以用来拷贝其它自定义属性
	     * @returns {Cstr} 返回新的实例
	     */
	
	
	    BinaryTree.prototype.copy = function copy() {
	        var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
	
	        // 用来存放本体结点的栈
	        var stack1 = new _index2.default();
	        // 用来存放新二叉树结点的栈
	        var stack2 = new _index2.default();
	        stack1.push(this);
	        var Cstr = this.constructor;
	        var newTree = new Cstr();
	        var q = newTree;
	        stack2.push(newTree);
	        var p = void 0;
	
	        while (stack1.length) {
	            // 向左走到尽头
	            while (p = stack1.peek()) {
	                if (p.leftChild) q.leftChild = new Cstr();
	                q = q.leftChild;
	                stack1.push(p.leftChild);
	                stack2.push(q);
	            }
	
	            p = stack1.pop();
	            q = stack2.pop();
	
	            if (stack1.length) {
	                p = stack1.pop();
	                q = stack2.pop();
	                if (p.rightChild) q.rightChild = new Cstr();
	                q.data = p.data;
	                cb(q, p);
	                q = q.rightChild;
	                stack1.push(p.rightChild); // 向右一步
	                stack2.push(q);
	            }
	        }
	
	        return newTree;
	    };
	
	    // 求二叉树中结点p和q的最近祖先
	
	
	    BinaryTree.prototype.findNearAncient = function findNearAncient(pNode, qNode) {
	        var pathP = findPath(this, pNode, 0);
	        var pathQ = findPath(this, qNode, 0);
	
	        for (var i = 0; pathP[i] == pathQ[i] && pathP[i]; i++) {}
	        return pathP[--i];
	    };
	
	    // todo
	
	
	    BinaryTree.prototype.toString = function toString() {};
	
	    // 求一棵二叉树的繁茂度
	
	
	    BinaryTree.prototype.lushDegree = function lushDegree() {
	        var countArr = [];
	        var queue = new _Queue2.default();
	        queue.enQueue({
	            node: this,
	            layer: 0
	        });
	        // 利用层序遍历来统计各层的结点数
	        var r = void 0;
	        while (queue.rear) {
	            r = queue.deQueue();
	            countArr[r.layer] = (countArr[r.layer] || 0) + 1;
	
	            if (r.node.leftChild) queue.enQueue({
	                node: r.node.leftChild,
	                layer: r.layer + 1
	            });
	            if (r.node.rightChild) queue.enQueue({
	                node: r.node.rightChild,
	                layer: r.layer + 1
	            });
	        }
	
	        // 最后一个队列元素所在层就是树的高度
	        var height = r.layer;
	        var max = countArr[0];
	        for (var i = 1; countArr[i]; i++) {
	            // 求层最大结点数
	            if (countArr[i] > max) max = countArr[i];
	        }return height * max;
	    };
	
	    // 求树结点的子孙总数填入descNum域中，并返回
	
	
	    BinaryTree.prototype.descNum = function descNum() {
	        return function recurse(node) {
	            var d = void 0;
	            if (!node) return -1;else d = recurse(node.leftChild) + recurse(node.rightChild) + 2;
	
	            node.descNum = d;
	
	            return d;
	        }(this);
	    };
	
	    // 判断二叉树是否完全二叉树
	
	
	    BinaryTree.isFullBinaryTree = function isFullBinaryTree(tree) {
	        var queue = new _Queue2.default();
	        var flag = 0;
	        queue.enQueue(tree);
	
	        while (queue.rear) {
	            var p = queue.deQueue();
	
	            if (!p) flag = 1;else if (flag) return false;else {
	                queue.enQueue(p.leftChild);
	                queue.enQueue(p.rightChild);
	            }
	        }
	
	        return true;
	    };
	
	    return BinaryTree;
	}();
	
	// 求从tree到node结点路径的递归算法
	
	
	function findPath(tree, node) {
	    var i = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    var path = [];
	    var found = false;
	
	    void function recurse(tree, i) {
	        if (tree == node) {
	            found = true;
	            return;
	        }
	
	        path[i] = tree;
	        if (tree.leftChild) recurse(tree.leftChild, i + 1);
	        if (tree.rightChild && !found) recurse(tree.rightChild, i + 1);
	        if (!found) path[i] = null;
	    }(tree, i);
	
	    return path;
	}
	
	var global = Function('return this;')();
	
	// 求深度等于树的高度减一的最靠左的结点
	function printPath_maxDepthS1(tree) {
	    var maxh = tree.getDepth();
	    var path = [];
	
	    if (maxh < 2) return false;
	    find_h(tree, 1);
	
	    function find_h(tree, h) {
	        path[h] = tree;
	
	        if (h == maxh - 1) {
	            var s = ' ';
	            for (var i = 1; path[i]; i++) {
	                s += path[i].data + (path[i + 1] ? ' -> ' : '');
	            }console.log(s);
	            return;
	        } else {
	            if (tree.leftChild) find_h(tree.leftChild, h + 1);
	            if (tree.rightChild) find_h(tree.rightChild, h + 1);
	        }
	
	        path[h] = null;
	    }
	}
	
	var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	var test = new BinaryTree();
	test.createBinaryTree(tree);
	
	console.log('iterator: ');
	for (var _iterator = test, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref3;
	
	    if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref3 = _iterator[_i++];
	    } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref3 = _i.value;
	    }
	
	    var x = _ref3;
	
	    console.log(x);
	}
	
	/**
	 * 树的3种常用链表结构
	 */
	
	// 1.双亲表示法
	// 优点：parent(tree, x)操作可以在常量时间内实现
	// 缺点：求结点的孩子时需要遍历整个结构
	
	var ParentTree = exports.ParentTree = function () {
	    function ParentTree() {
	        (0, _classCallCheck3.default)(this, ParentTree);
	
	        this.nodes = [];
	    }
	
	    ParentTree.prototype.getDepth = function getDepth() {
	        var maxDepth = 0;
	
	        for (var i = 0; i < this.nodes.length; i++) {
	            var dep = 0;
	            for (var j = i; j >= 0; j = this.nodes[i].parent) {
	                dep++;
	            }if (dep > maxDepth) maxDepth = dep;
	        }
	
	        return maxDepth;
	    };
	
	    return ParentTree;
	}();
	
	var ParentTreeNode = function ParentTreeNode() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var parent = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    (0, _classCallCheck3.default)(this, ParentTreeNode);
	
	    // type: ParentTree
	    this.data = data;
	    // 双亲位置域 {Number}
	    this.parent = parent;
	};
	
	var pt = new ParentTree();
	pt.nodes.push(new ParentTreeNode('R', -1));
	pt.nodes.push(new ParentTreeNode('A', 0));
	pt.nodes.push(new ParentTreeNode('B', 0));
	pt.nodes.push(new ParentTreeNode('C', 0));
	pt.nodes.push(new ParentTreeNode('D', 1));
	pt.nodes.push(new ParentTreeNode('E', 1));
	pt.nodes.push(new ParentTreeNode('F', 3));
	pt.nodes.push(new ParentTreeNode('G', 6));
	pt.nodes.push(new ParentTreeNode('H', 6));
	pt.nodes.push(new ParentTreeNode('I', 6));
	
	// 孩子表示法
	
	var ChildTree = exports.ChildTree = function () {
	    function ChildTree() {
	        (0, _classCallCheck3.default)(this, ChildTree);
	
	        this.nodes = [];
	    }
	
	    ChildTree.prototype.getDepth = function getDepth() {
	        var self = this;
	        return function subDepth(rootIndex) {
	            if (!self.nodes[rootIndex]) return 1;
	
	            var sd = 1;
	            for (var p = self.nodes[rootIndex]; p; p = p.next) {
	                var d = subDepth(p.child);
	                if (d > sd) sd = d;
	            }
	
	            return sd + 1;
	        }(this.data[0]);
	    };
	
	    return ChildTree;
	}();
	/**
	 *
	 * @param {*} data
	 * @param {ChildTreeNode} firstChild 孩子链表头指针
	 * @constructor
	 */
	
	
	var ChildTreeBox = function ChildTreeBox() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeBox);
	
	    this.data = data;
	    this.firstChild = firstChild;
	};
	
	/**
	 * 孩子结点
	 *
	 * @param {Number} child
	 * @param {ChildTreeNode} next
	 * @constructor
	 */
	
	
	var ChildTreeNode = function ChildTreeNode() {
	    var child = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeNode);
	
	    this.child = child;
	    this.next = next;
	};
	
	/*
	 孩子表示法便于涉及孩子的操作的实现，但不适用于parent操作。
	 我们可以把双亲表示法和孩子表示法结合起来。
	 */
	
	// 孩子兄弟表示法(二叉树表示法)
	// 可增设一个parent域实现parent操作
	
	
	var ChildSiblingTree = exports.ChildSiblingTree = function () {
	    function ChildSiblingTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var nextSibling = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, ChildSiblingTree);
	
	        this.data = data;
	        this.firstChild = firstChild;
	        this.nextSibling = nextSibling;
	    }
	
	    // 输出孩子兄弟链表表示的树的各边
	
	
	    ChildSiblingTree.prototype.print = function print() {
	        for (var child = this.firstChild; child; child = child.nextSibling) {
	            console.log('%c %c', this.data, child.data);
	            child.print();
	        }
	    };
	
	    // 求孩子兄弟链表表示的树的叶子数目
	
	
	    ChildSiblingTree.prototype.leafCount = function leafCount() {
	        if (!this.firstChild) return 1;else {
	            var count = 0;
	            for (var child = this.firstChild; child; child = child.nextSibling) {
	                count += child.leafCount();
	            }
	            return count;
	        }
	    };
	
	    // 求树的度
	
	
	    ChildSiblingTree.prototype.getDegree = function getDegree() {
	        if (!this.firstChild) return 0;else {
	            var degree = 0;
	            for (var p = this.firstChild; p; p = p.nextSibling) {
	                degree++;
	            }for (var _p = this.firstChild; _p; _p = _p.nextSibling) {
	                var d = _p.getDegree();
	                if (d > degree) degree = d;
	            }
	
	            return degree;
	        }
	    };
	
	    ChildSiblingTree.prototype.getDepth = function getDepth() {
	        if (this === global) return 0;else {
	            var maxd = 0;
	            for (var p = this.firstChild; p; p = p.nextSibling) {
	                var d = p.getDepth();
	                if (d > maxd) maxd = d;
	            }
	
	            return maxd + 1;
	        }
	    };
	
	    return ChildSiblingTree;
	}();

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(8);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 栈
	 *
	 * 是限定仅在表尾进行插入或删除操作的线性表。表尾为栈顶（top），表头为栈底（bottom），不含元素的空表为空栈。
	 * 栈又称为后进先出（last in first out）的线性表。
	 */
	
	/**
	 * 顺序栈
	 * 栈的顺序存储结构是利用一组地址连续的存储单元依次存放至栈底到栈顶的元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
	 *
	 */
	
	// 栈的链式表示
	var Stack = function () {
	    function Stack() {
	        (0, _classCallCheck3.default)(this, Stack);
	
	        this.top = null;
	        this.length = 0;
	    }
	
	    Stack.prototype.isEmpty = function isEmpty() {
	        return this.length === 0;
	    };
	
	    Stack.prototype.push = function push(data) {
	        var node = {
	            data: data,
	            next: null
	        };
	
	        node.next = this.top;
	        this.top = node;
	        this.length++;
	    };
	
	    Stack.prototype.peek = function peek() {
	        return this.top === null ? null : this.top.data;
	    };
	
	    Stack.prototype.pop = function pop() {
	        if (this.top === null) return null;
	
	        var out = this.top;
	        this.top = this.top.next;
	
	        if (this.length > 0) this.length--;
	
	        return out.data;
	    };
	
	    Stack.prototype.clear = function clear() {
	        this.top = null;
	        this.length = 0;
	    };
	
	    Stack.prototype.toString = function toString() {
	        if (this.top === null) return null;
	
	        var arr = [];
	        var current = this.top;
	
	        for (var i = 0, len = this.size; i < len; i++) {
	            arr[i] = current.data;
	            current = current.next;
	        }
	
	        return arr;
	    };
	
	    (0, _createClass3.default)(Stack, [{
	        key: 'size',
	        get: function get() {
	            return this.length;
	        }
	    }]);
	    return Stack;
	}();
	
	exports.default = Stack;
	
	
	var stack = new Stack();
	
	stack.push(1);
	stack.push('asd');
	
	stack.pop();
	stack.push({ a: 1 });
	console.log(stack);
	
	/**
	 * 这里用字符串train表示火车，H表示硬席，S表示软席
	 * @param {String} train
	 */
	function trainArrange(train) {
	    var stack = new Stack();
	    var q = [];
	    var i = 0;
	    var j = 0;
	
	    while (train[i]) {
	        if (train[i] === 'H') stack.push(train[i]);else q[j++] = train[i];
	        i++;
	    }
	
	    while (stack.length) {
	        var c = stack.pop();
	        q[j++] = c;
	    }
	
	    return q + '';
	}
	
	console.log('trainArrange: ' + trainArrange('HSSHSSSHHHHHS')); // trainArrange: S,S,S,S,S,S,H,H,H,H,H,H,H
	
	
	// 判断字符串中“&”前和“&”后部分是否为逆串，"@"表示结束符，是则返回true，否则返回false
	function isReverse(str) {
	    var stack = new Stack();
	    var i = 0;
	
	    while (str[i] !== '&') {
	        if (str[i] === '@') return false;
	        stack.push(str[i]);
	        i++;
	    }
	
	    i++;
	
	    while (str[i] !== '@') {
	        if (!stack.length) return false;
	
	        var s = stack.pop();
	        if (s !== str[i]) return false;
	        i++;
	    }
	
	    return !stack.length;
	}
	
	console.log('isReverse: ' + isReverse('abcd&dcba@a')); // true
	
	
	// 数值进制转换
	// 公式： N = (N / d) * d + N % d
	// N：十进制数值， d：需要转换的进制数
	function numTransform(number, rad) {
	    var s = new Stack();
	
	    while (number) {
	        s.push(number % rad);
	        number = parseInt(number / 8, 10);
	    }
	
	    var arr = [];
	    while (s.top) {
	        arr.push(s.pop());
	    }
	    console.log(arr.join(''));
	}
	
	numTransform(1348, 8);
	numTransform(1348, 2);
	
	// 括号匹配检查
	function bracketsMatch(str) {
	    var stack = new Stack();
	    var text = '';
	
	    for (var i = 0, len = str.length; i < len; i++) {
	        var c = str[i];
	        if (c === '[') {
	            stack.push(c);
	        } else if (c === ']') {
	            if (!stack.length || stack.pop() !== '[') throw new Error('unexpected brackets:' + c);
	        } else {
	            text += c;
	        }
	    }
	    console.log(text);
	}
	
	console.log(bracketsMatch('[asd]'));
	
	function Matcher(left, right) {
	    this.left = left;
	    this.right = right;
	    this.stack = new Stack();
	}
	Matcher.prototype = {
	    match: function match(str) {
	        var text = '';
	
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            if (c === this.left) {
	                this.stack.push(c);
	            } else if (c === this.right) {
	                if (!this.stack.length || this.stack.pop() !== this.left) {
	                    throw new Error('unexpected brackets:' + c);
	                } else {
	                    text += ',';
	                }
	            } else {
	                text += c;
	            }
	        }
	        console.log(text);
	        return text;
	    }
	};
	var m = new Matcher('{', '}');
	m.match('[{123}123');
	
	function LineEditor(str) {
	    this.stack = new Stack();
	    this.str = str || '';
	}
	LineEditor.prototype = {
	    getResult: function getResult() {
	        var stack = this.stack;
	        var str = this.str;
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            switch (c) {
	                case '#':
	                    stack.pop();
	                    break;
	                case '@':
	                    stack.clear();
	                    break;
	                default:
	                    stack.push(c);
	                    break;
	            }
	        }
	
	        var result = '';
	        var current = stack.length;
	        while (current) {
	            result = current.data + result;
	            current = current.next;
	        }
	
	        return result;
	    }
	};
	
	var le = new LineEditor('whli##ilr#e(s#*s)\
	    \noutcha@putchar(*s=#++)');
	console.log(le.getResult());
	
	var prioty = {
	    "+": 1,
	    "-": 1,
	    "%": 2,
	    "*": 2,
	    "/": 2,
	    "^": 3,
	    "(": 0,
	    ")": 0,
	    "`": -1
	};
	
	function doop(op, opn1, opn2) {
	    switch (op) {
	        case "+":
	            return opn1 + opn2;
	        case "-":
	            return opn1 - opn2;
	        case "*":
	            return opn1 * opn2;
	        case "/":
	            return opn1 / opn2;
	        case "%":
	            return opn1 % opn2;
	        case "^":
	            return Math.pow(opn1, opn2);
	        default:
	            return 0;
	    }
	}
	
	function opcomp(a, b) {
	    return prioty[a] - prioty[b];
	}
	
	function calInfixExpression(exp) {
	    var cs = [];
	    var ns = [];
	    exp = exp.replace(/\s/g, "");
	    exp += '`';
	    if (exp[0] === '-') {
	        exp = "0" + exp;
	    }
	    var c = void 0;
	    var op = void 0;
	    var opn1 = void 0;
	    var opn2 = void 0;
	    for (var i = 0; i < exp.length; ++i) {
	        c = exp[i];
	        // 如果是操作符
	        if (c in prioty) {
	            // 如果右边不是左括号且操作符栈的栈顶元素优先权比右边大
	            // 循环遍历进行连续运算
	            while (c != '(' && cs.length && opcomp(cs[cs.length - 1], c) >= 0) {
	                // 出栈的操作符
	                op = cs.pop();
	                // 如果不是左括号或者右括号，说明是运算符
	                if (op != '(' && op != ')') {
	                    // 出栈保存数字的栈的两个元素
	                    opn2 = ns.pop();
	                    opn1 = ns.pop();
	                    // 将与操作符运算后的结果保存到栈顶
	                    ns.push(doop(op, opn1, opn2));
	                }
	            }
	            // 如果右边不是右括号，保存到操作符栈中
	            if (c != ')') cs.push(c);
	        } else {
	            // 多位数的数字的情况
	            while (!(exp[i] in prioty)) {
	                i++;
	                c += exp[i];
	            }
	            ns.push(parseFloat(c));
	            i--;
	        }
	    }
	    return ns.length ? ns[0] : NaN;
	}
	
	var exp1 = calInfixExpression('5+3*4/2-2^3+5%2');
	console.log(exp1);

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(62);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(60);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(40);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(40);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(49)
	  , enumBugKeys = __webpack_require__(26);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.default = defaultCompare;
	/**
	 * Created by ldp on 2015/4/12.
	 */
	
	function defaultCompare(a, b) {
	  return a - b;
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 26 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(81)
	  , enumBugKeys = __webpack_require__(26)
	  , IE_PROTO    = __webpack_require__(32)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(43)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(74).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(6).f
	  , has = __webpack_require__(5)
	  , TAG = __webpack_require__(11)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(33)('keys')
	  , uid    = __webpack_require__(23);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(3)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(15);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(3)
	  , core           = __webpack_require__(9)
	  , LIBRARY        = __webpack_require__(28)
	  , wksExt         = __webpack_require__(37)
	  , defineProperty = __webpack_require__(6).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(11);

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(142);


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(150);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(139);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(58)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(64);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(63);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(70);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(15)
	  , document = __webpack_require__(3).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(4) && !__webpack_require__(20)(function(){
	  return Object.defineProperty(__webpack_require__(43)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(28)
	  , $export        = __webpack_require__(14)
	  , redefine       = __webpack_require__(50)
	  , hide           = __webpack_require__(10)
	  , has            = __webpack_require__(5)
	  , Iterators      = __webpack_require__(27)
	  , $iterCreate    = __webpack_require__(77)
	  , setToStringTag = __webpack_require__(31)
	  , getPrototypeOf = __webpack_require__(83)
	  , ITERATOR       = __webpack_require__(11)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(30)
	  , createDesc     = __webpack_require__(22)
	  , toIObject      = __webpack_require__(7)
	  , toPrimitive    = __webpack_require__(35)
	  , has            = __webpack_require__(5)
	  , IE8_DOM_DEFINE = __webpack_require__(44)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(4) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(49)
	  , hiddenKeys = __webpack_require__(26).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 48 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(5)
	  , toIObject    = __webpack_require__(7)
	  , arrayIndexOf = __webpack_require__(72)(false)
	  , IE_PROTO     = __webpack_require__(32)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(10);

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(146)
	
	var md5 = toConstructor(__webpack_require__(103))
	var rmd160 = toConstructor(__webpack_require__(144))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	exports.UINT32 = __webpack_require__(106)
	exports.UINT64 = __webpack_require__(107)

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _regenerator = __webpack_require__(38);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _createClass2 = __webpack_require__(8);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 循环链表（circular linked list）
	 * 是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个表形成一个环。
	 * 循环链表的操作和线性链表基本一致，仅有细微差别。
	 */
	
	/**
	 * 双向链表
	 *
	 * 双向链表是为了克服单链表这种单向性的缺点。
	 * 双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋。
	 *
	 * 双向链表也可以有循环表。
	 */
	
	var Node = function Node(data) {
	    var prev = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var next = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.prev = prev;
	    this.next = next;
	};
	
	function defaultCompare(a, b) {
	    return a === b;
	}
	
	var DoubleLinkedList = function () {
	    function DoubleLinkedList(sqList) {
	        var compare = arguments.length <= 1 || arguments[1] === undefined ? defaultCompare : arguments[1];
	        (0, _classCallCheck3.default)(this, DoubleLinkedList);
	
	        this.head = null;
	        this.tail = null;
	        this.size = 0;
	        this.compare = compare;
	
	        if (sqList && sqList.length) {
	            for (var _iterator = sqList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	                var _ref;
	
	                if (_isArray) {
	                    if (_i >= _iterator.length) break;
	                    _ref = _iterator[_i++];
	                } else {
	                    _i = _iterator.next();
	                    if (_i.done) break;
	                    _ref = _i.value;
	                }
	
	                var item = _ref;
	
	                this.push(item);
	            }
	        }
	    }
	
	    DoubleLinkedList.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
	        var current;
	        return _regenerator2.default.wrap(function _callee$(_context) {
	            while (1) {
	                switch (_context.prev = _context.next) {
	                    case 0:
	                        current = this.head;
	
	                    case 1:
	                        if (!current) {
	                            _context.next = 7;
	                            break;
	                        }
	
	                        _context.next = 4;
	                        return current.data;
	
	                    case 4:
	
	                        current = current.next;
	                        _context.next = 1;
	                        break;
	
	                    case 7:
	                    case 'end':
	                        return _context.stop();
	                }
	            }
	        }, _callee, this);
	    });
	
	    DoubleLinkedList.prototype.clear = function clear() {
	        this.head = null;
	        this.tail = null;
	        this.size = 0;
	
	        return true;
	    };
	
	    DoubleLinkedList.prototype.push = function push(data) {
	        if (typeof data === 'undefined') throw new Error('data argument required');
	
	        ++this.size;
	
	        if (!this.head) {
	            this.head = this.tail = new Node(data);
	        } else {
	            var node = new Node(data, this.tail, null);
	            this.tail.next = node;
	            this.tail = node;
	        }
	
	        return data;
	    };
	
	    DoubleLinkedList.prototype.unshift = function unshift(data) {
	        if (typeof data === 'undefined') throw new Error('data argument required');
	
	        ++this.size;
	
	        if (!this.head) {
	            this.head = this.tail = new Node(data);
	        } else {
	            var node = new Node(data, null, this.head);
	            this.head.prev = node;
	            this.head = node;
	        }
	
	        return data;
	    };
	
	    DoubleLinkedList.prototype.pop = function pop() {
	        if (!this.tail) {
	            this.head = this.tail = null;
	            return;
	        }
	
	        --this.size;
	
	        this.tail.prev.next = null;
	        this.tail = this.tail.prev;
	    };
	
	    DoubleLinkedList.prototype.shift = function shift() {
	        if (!this.head) {
	            this.head = this.tail = null;
	            return;
	        }
	
	        --this.size;
	
	        this.head.next.prev = null;
	        this.head = this.head.next;
	    };
	
	    DoubleLinkedList.prototype.update = function update(index, data) {
	        var node = this.findByIndex(index, true);
	        node.data = data;
	        return this;
	    };
	
	    DoubleLinkedList.prototype.remove = function remove(data) {
	        if (typeof data === 'function') throw new Error('data argument required');
	
	        var current = this.head;
	
	        while (current) {
	            if (this.compare(data, current.data)) {
	                --this.size;
	
	                if (current === this.head) {
	                    this.head = this.head.next;
	
	                    if (this.head) {
	                        this.head.prev = null;
	                    } else {
	                        this.head = this.tail = null;
	                    }
	                } else if (current === this.tail) {
	                    this.tail = this.tail.prev;
	
	                    if (this.tail) {
	                        this.tail.next = null;
	                    } else {
	                        this.head = this.tail = null;
	                    }
	                } else {
	                    current.prev.next = current.next;
	                    current.next.prev = current.prev;
	                }
	
	                return current.data;
	            }
	
	            current = current.next;
	        }
	
	        return false;
	    };
	
	    DoubleLinkedList.prototype.indexOf = function indexOf(data) {
	        var current = this.head;
	        var index = -1;
	
	        while (current) {
	            ++index;
	            if (this.compare(data, current.data)) return index;
	
	            current = current.next;
	        }
	
	        return -1;
	    };
	
	    DoubleLinkedList.prototype.findByIndex = function findByIndex() {
	        var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var returnNode = arguments[1];
	
	        var current = this.head;
	        var j = 0;
	
	        while (current) {
	            if (j++ === index) break;
	
	            current = current.next;
	        }
	
	        return returnNode ? current : current.data;
	    };
	
	    DoubleLinkedList.prototype.forEach = function forEach() {
	        var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	        if (typeof cb !== 'function') throw new Error('argument should be a function');
	
	        var current = this.head;
	
	        while (current) {
	            cb(current.data);
	
	            current = current.next;
	        }
	    };
	
	    DoubleLinkedList.prototype.toJSON = function toJSON() {
	        var list = [];
	        var current = this.head;
	
	        while (current) {
	            list.push(current.data);
	
	            current = current.next;
	        }
	
	        return list;
	    };
	
	    DoubleLinkedList.prototype.toString = function toString() {
	        return this.toJSON() + '';
	    };
	
	    (0, _createClass3.default)(DoubleLinkedList, [{
	        key: 'length',
	        get: function get() {
	            return this.size;
	        }
	    }]);
	    return DoubleLinkedList;
	}();
	
	exports.default = DoubleLinkedList;
	
	
	var a = new DoubleLinkedList([2, 3]);
	a.unshift(1);
	a.push(4);
	console.log(a.indexOf(4));
	console.log(a.findByIndex(2));
	
	for (var _iterator2 = a, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	    var _ref2;
	
	    if (_isArray2) {
	        if (_i2 >= _iterator2.length) break;
	        _ref2 = _iterator2[_i2++];
	    } else {
	        _i2 = _iterator2.next();
	        if (_i2.done) break;
	        _ref2 = _i2.value;
	    }
	
	    var item = _ref2;
	
	    console.log(item);
	}
	
	a.pop();
	a.shift();
	a.remove(2);
	a.remove(32);
	a.remove(3);

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _regenerator = __webpack_require__(38);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 由于链表在空间的合理利用上和插入，删除时不需要移动等的有点，因此在很多场合下，它是线性表的首选存储结构。然而，它也存在着实现某些基本操作，如求线性表长度时不如顺序存储结构的缺点；另一方面，由于在链表中，结点之间的关系使用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际出发重新定义线性链表及其基本操作
	 */
	
	var Node = function Node() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.next = next;
	};
	
	var LinkedList = function () {
	    function LinkedList(sqList) {
	        (0, _classCallCheck3.default)(this, LinkedList);
	
	        this.head = null;
	        this.tail = null;
	
	        if (sqList) {
	            for (var i = 0, len = sqList.length; i < len; ++i) {
	                this.push(sqList[i]);
	            }
	        }
	    }
	
	    LinkedList.mergeList = function mergeList(a, b) {
	        var compare = arguments.length <= 2 || arguments[2] === undefined ? compFn : arguments[2];
	
	        var ha = a.head;
	        var hb = b.head;
	        var pa = ha;
	        var pb = hb;
	        var c = new LinkedList();
	        var q = void 0;
	
	        while (pa && pb) {
	            var data1 = pa.data;
	            var data2 = pb.data;
	
	            if (!compare(data1, data2)) {
	                // delete head node
	                q = a.shift();
	                // append the node to c linkedList
	                c.append(q);
	                pa = a.head;
	            } else {
	                q = b.shift();
	                c.append(q);
	                pb = b.head;
	            }
	        }
	
	        if (pa) c.append(pa);else c.append(pb);
	
	        return c;
	    };
	
	    // delete first element and return it
	
	
	    LinkedList.prototype.shift = function shift() {
	        var head = this.head;
	        this.head = this.head.next;
	        head.next = null;
	
	        if (this.head === null) this.tail = null;
	        return head;
	    };
	
	    LinkedList.prototype.pop = function pop() {
	        var current = this.head;
	        var previous = this.head;
	        var elem = void 0;
	
	        while (current !== null) {
	            if (this.tail === current) {
	                if (current === this.head) {
	                    elem = this.tail.data;
	                    this.head = null;
	                    break;
	                }
	
	                this.tail = previous;
	
	                previous.next = current.next;
	                elem = current.data;
	                break;
	            }
	
	            previous = current;
	            current = current.next;
	        }
	
	        if (this.head === null) this.tail = null;
	
	        return elem ? elem : false;
	    };
	
	    // append node
	
	
	    LinkedList.prototype.append = function append(node) {
	        if (this.head !== null) {
	            this.tail.next = node;
	            this.tail = this.tail.next;
	        } else {
	            this.head = node;
	            this.tail = node;
	        }
	    };
	
	    // add data
	
	
	    LinkedList.prototype.push = function push(data) {
	        if (this.head === null) {
	            this.head = new Node(data);
	            this.tail = this.head;
	        } else {
	            this.tail.next = new Node(data);
	            this.tail = this.tail.next;
	        }
	
	        this.tail.data = data;
	    };
	
	    // remove data
	
	
	    LinkedList.prototype.remove = function remove(data) {
	        var current = this.head;
	        var previous = this.head;
	        var elem = void 0;
	
	        while (current !== null) {
	            if (data === current.data) {
	                if (current === this.head) {
	                    this.head = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                if (current === this.tail) this.tail = previous;
	
	                previous.next = current.next;
	                elem = current.data;
	                break;
	            }
	
	            previous = current;
	            current = current.next;
	        }
	
	        if (this.head === null) this.tail = null;
	
	        return elem ? elem : false;
	    };
	
	    LinkedList.prototype.indexOf = function indexOf(data) {
	        var current = this.head;
	        var index = -1;
	        while (current !== null) {
	            ++index;
	            if (current.data === data) {
	                return index;
	            }
	
	            current = current.next;
	        }
	
	        return index;
	    };
	
	    LinkedList.prototype.unshift = function unshift(data) {
	        var temp = new Node(data);
	        temp.next = this.head;
	        this.head = temp;
	    };
	
	    LinkedList.prototype.insertAfter = function insertAfter(target, data) {
	        var current = this.head;
	        while (current !== null) {
	            if (current.data === target) {
	                var temp = new Node(data);
	                temp.next = current.next;
	
	                if (current === this.tail) this.tail = temp;
	
	                current.next = temp;
	                return;
	            }
	
	            current = current.next;
	        }
	    };
	
	    LinkedList.prototype.item = function item(index) {
	        var current = this.head;
	
	        while (current !== null) {
	            if (--index === 0) return current;
	
	            current = current.next;
	        }
	
	        return null;
	    };
	
	    LinkedList.prototype.each = function each(callback) {
	        if (typeof callback !== 'function') return;
	
	        for (var current = this.head; current; current = current.next) {
	            if (callback(current)) break;
	        }
	    };
	
	    LinkedList.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
	        var current;
	        return _regenerator2.default.wrap(function _callee$(_context) {
	            while (1) {
	                switch (_context.prev = _context.next) {
	                    case 0:
	                        current = this.head;
	
	                    case 1:
	                        if (!current) {
	                            _context.next = 7;
	                            break;
	                        }
	
	                        _context.next = 4;
	                        return current.data;
	
	                    case 4:
	                        current = current.next;
	                        _context.next = 1;
	                        break;
	
	                    case 7:
	                    case 'end':
	                        return _context.stop();
	                }
	            }
	        }, _callee, this);
	    });
	
	    LinkedList.prototype.size = function size() {
	        var current = this.head;
	        var size = 0;
	
	        while (current !== null) {
	            ++size;
	            current = current.next;
	        }
	
	        return size;
	    };
	
	    LinkedList.prototype.toString = function toString() {
	        var str = '';
	
	        this.each(function (node) {
	            str += node.data + (node.next ? ',' : '');
	        });
	
	        return str;
	    };
	
	    LinkedList.prototype.orderInsert = function orderInsert(data, cmp) {
	        cmp = typeof cmp === 'function' ? cmp : function (a, b) {
	            if (a > b) return 1;else if (a === b) return 0;else return -1;
	        };
	        var previous = this.head;
	        var current = this.head;
	
	        if (current === null) {
	            this.head = this.tail = new Node(data);
	            return;
	        }
	
	        var me = this;
	        while (current) {
	            var ret = cmp(data, current.data);
	            // 如果插入元素大于当前元素，准备下次遍历
	            if (ret > 0) {
	                previous = current;
	                current = current.next;
	
	                // 如果等于，直接插入到后面
	            } else if (ret === 0) {
	                return insertBetween(data, previous, current);
	
	                // 如果小于则插入到前节点和当前节点中
	                // 因为已经是排序了，所以不需要多余判断了
	            } else {
	                if (this.head === previous && previous === current) return this.unshift(data);else return insertBetween(data, previous, current);
	            }
	        }
	
	        // 插入到最后一个结点
	        previous.next = new Node(data);
	        this.tail = previous.next;
	
	        function insertBetween(data, a, b) {
	            if (a == b) {
	                if (a == me.head) return me.unshift(data);
	            } else {
	                var temp = new Node(data);
	                temp.next = b;
	                a.next = temp;
	                return true;
	            }
	        }
	    };
	
	    // 删除元素递增排列的链表中值大于min，且小于max的所有元素
	
	
	    LinkedList.prototype.delete_between = function delete_between(min, max) {
	        var p = this.head;
	
	        // p是最后一个不大于min的元素
	        while (p.next && p.next.data <= min) {
	            p = p.next;
	        } // 如果还有比min更大的元素
	        var q = void 0;
	        if (p.next) {
	            q = p.next;
	            // q是第一个不小于max的元素
	            while (q && q.data < max) {
	                q = q.next;
	            }p.next = q;
	        }
	
	        var last = q || p;
	        while (last.next) {
	            last = last.next;
	        }this.tail = last;
	    };
	
	    // 删除元素递增排列的链表的重复元素
	
	
	    LinkedList.prototype.delete_equal = function delete_equal() {
	        var p = this.head;
	        var q = p.next;
	
	        while (p.next) {
	            // 当相邻两元素不相等时，p,q都向后移
	            if (p.data !== q.data) {
	                p = p.next;
	                q = p.next;
	            } else {
	                while (q.data === p.data) {
	                    q = q.next;
	                } // 删除
	                p.next = q;
	                p = q;
	                q = p.next;
	            }
	        }
	    };
	
	    LinkedList.prototype.reverse = function reverse() {
	        var p = this.head;
	        var q = p.next;
	        var s = q.next;
	        p.next = null;
	
	        while (s.next) {
	            q.next = p;
	            p = q;
	            q = s;
	            s = s.next;
	        }
	
	        q.next = p;
	        s.next = q;
	        this.head = s;
	    };
	
	    return LinkedList;
	}();
	
	exports.default = LinkedList;
	
	
	function compFn(a, b) {
	    return a - b;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(list, bList) {
	    var cList = new LinkedList();
	
	    var p = list.head;
	    var q = bList.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (q.data > q.data) q = q.next;else {
	            cList.push(q.data);
	            p = p.next;
	            q = q.next;
	        }
	    }
	
	    return cList;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(list, bList) {
	    var p = list.head;
	    var q = bList.head;
	    var pc = list.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            pc.data = p.data;
	            p = p.next;
	            q = q.next;
	
	            if (!p || !q) {
	                pc.next = null;
	                list.tail = pc;
	            } else pc = pc.next;
	        }
	    }
	
	    pc.next = null;
	    list.tail = pc;
	}
	
	// a，b，c的元素均是非递减排列
	// 求a链表中非b链表和c链表的交集的元素。
	function intersect_delete(list, b, c) {
	    var p = b.head;
	    var q = c.head;
	    var r = list.head;
	
	    while (p && q && r) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            // 确定待删除元素
	            var elem = p.data;
	
	            if (r.data === elem && r === list.head) {
	                list.head = list.head.next;
	            } else {
	                // 确定最后一个小于elem的元素指针
	                while (r.next && r.next.data < elem) {
	                    r = r.next;
	                }if (r.next.data === elem) {
	                    var s = r.next;
	
	                    // 确定第一个大于elem的元素指针
	                    while (s && s.data === elem) {
	                        s = s.next;
	                    } // 删除r和s之间的元素
	                    r.next = s;
	                }
	            }
	
	            while (p && p.data === elem) {
	                p = p.next;
	            }while (q && q.data === elem) {
	                q = q.next;
	            }
	        }
	    }
	
	    list.tail = r;
	}
	
	var list = new LinkedList();
	list.push('b');
	list.unshift('a');
	list.insertAfter('b', 'c');
	console.log(list.item(2));
	console.log(JSON.stringify(list));
	list.each(function (node) {
	    if (node.data === 'b') {
	        console.log('get b in each');
	    }
	});
	list.remove('c');
	list.remove('a');
	console.log(list);
	
	var list2 = new LinkedList();
	list2.push('c');
	list2.unshift('d');
	list2.insertAfter('d', 'b');
	console.log(JSON.stringify(list2));
	
	var list3 = LinkedList.mergeList(list, list2);
	console.log(list3);
	
	var list = new LinkedList();
	
	list.orderInsert(5);
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	list.orderInsert(4);
	list.orderInsert(4);
	list.orderInsert(6);
	list.orderInsert(6);
	list.orderInsert(7);
	
	list.delete_between(5, 8);
	console.log('delete-between:  ');
	console.log(list);
	
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	
	list.delete_equal();
	console.log(list);
	
	list.reverse();
	console.log(list);
	
	var a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var b = new LinkedList();
	b.orderInsert(1);
	b.orderInsert(5);
	b.orderInsert(9);
	b.orderInsert(13);
	b.orderInsert(17);
	console.log(intersect(a, b));
	
	console.log(intersect_true(a, b));
	
	a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var test = new LinkedList();
	test.orderInsert(1);
	test.orderInsert(2);
	test.orderInsert(3);
	test.orderInsert(4);
	test.orderInsert(5);
	test.orderInsert(6);
	test.orderInsert(9);
	
	intersect_delete(test, a, b);
	console.log(test);
	
	var popTest = new LinkedList();
	popTest.push(1);
	popTest.push(2);
	popTest.pop();
	popTest.pop();

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 静态单链表
	/*
	 有时可借用一维数组来描述线性链表，这就是线性表的静态单链表存储结构。
	 在静态链表中，数组的一个分量表示一个结点，同时用游标（cur）代替指针指示结点在数组中的相对位置。
	 数组的第0分量可看成头结点，其指针域指示链表的第一个结点。
	 这种存储结构需要预先分配一个较大的空间，但在线性表的插入和删除操作时不需移动元素，
	 仅需要修改指针，故仍具有链式存储结构的主要优点
	 */
	
	var StaticLinkedList = function () {
	    function StaticLinkedList(MAXSIZE) {
	        (0, _classCallCheck3.default)(this, StaticLinkedList);
	
	        this[-1] = { cur: 0 };
	        this.length = 0;
	        this.MAXSIZE = MAXSIZE + 1 || 1000;
	    }
	
	    /**
	     * 在静态单链线性表L中查找第1个值为e的元素，
	     * 若找到，则返回它在L中的位序
	     * @param data
	     */
	
	
	    StaticLinkedList.prototype.find = function find(data) {
	        var i = this[0].cur;
	        while (i && this[i].data !== data) {
	            i = this[i].cur;
	        }
	        return i;
	    };
	    /**
	     * 将一维数组中各分量链成一个备用链表
	     * this[0].cur为头指针
	     */
	
	
	    StaticLinkedList.prototype.init = function init(len) {
	        len = len ? len + 1 : this.MAXSIZE;
	        for (var i = 0; i < len - 1; ++i) {
	            this[i] = this[i] || { data: null, cur: null };
	            this[i].cur = i + 1;
	        }
	
	        this[len - 1] = this[len - 1] || {};
	        this[len - 1].cur = 0;
	    };
	    /**
	     * 若备用链表非空，则返回分配的结点下标，反则返回0
	     * @returns {*}
	     */
	
	
	    StaticLinkedList.prototype.malloc = function malloc() {
	        var i = this[-1].cur;
	        if (typeof this[-1].cur !== 'undefined') this[-1].cur = this[i].cur;
	        return i;
	    };
	    /**
	     * 将下标为k的空闲结点回收到备用链表
	     * @param k
	     */
	
	
	    StaticLinkedList.prototype.free = function free(k) {
	        this[k].cur = this[0].cur;
	        this[0].cur = k;
	    };
	
	    StaticLinkedList.prototype.create = function create(sqList) {
	        // 初始化备用空间
	        this.init(sqList.length);
	        // 生成s的头结点
	        var s = this.malloc();
	        // r指向s的当前最后结点
	        var r = s;
	        var m = sqList.length;
	
	        // 建立集合A的链表
	        for (var j = 0; j < m; ++j) {
	            //分配结点
	            var i = this.malloc();
	            // 输入A元素的值
	            this[i].data = sqList[j];
	            // 插入到表尾
	            this[r].cur = i;
	            ++this.length;
	            r = i;
	        }
	        // 尾结点的指针为空
	        this[r].cur = 0;
	    };
	
	    // todo
	
	
	    StaticLinkedList.prototype.add = function add(index, elem) {};
	
	    StaticLinkedList.prototype.remove = function remove(index) {};
	
	    return StaticLinkedList;
	}();
	
	/**
	 * 在一维数组中建立表示集合(A-B)U(B-A)
	 * 的静态链表，s为其头指针。
	 * @returns {*}
	 */
	
	
	exports.default = StaticLinkedList;
	function difference(sllist, arr1, arr2) {
	    // 初始化备用空间
	    sllist.init();
	    // 生成s的头结点
	    var s = sllist.malloc();
	    // r指向s的当前最后结点
	    var r = s;
	    // 删除A和B的元素个数
	    var m = arr1.length;
	    var n = arr2.length;
	
	    // 建立集合A的链表
	    for (var j = 0; j < m; ++j) {
	        //分配结点
	        var i = sllist.malloc();
	        // 输入A元素的值
	        sllist[i].data = arr1[j];
	        // 插入到表尾
	        sllist[r].cur = i;
	        r = i;
	    }
	    // 尾结点的指针为空
	    sllist[r].cur = 0;
	
	    // 依次输入B的元素，若不在当前表中，则插入，
	    // 否则删除
	    for (var _j = 0; _j < n; ++_j) {
	        var b = arr2[_j];
	        var p = s;
	        // k指向集合中的第一个结点
	        var k = sllist[s].cur;
	        // 在当前表中查找
	        while (k !== sllist[r].cur && sllist[k].data !== b) {
	            p = k;
	            k = sllist[k].cur;
	        }
	        // 当前表中不存在该元素，插入在r所指结点之后，且r的位置不变
	        if (k === sllist[r].cur) {
	            var _i = sllist.malloc();
	            sllist[_i].data = b;
	            sllist[_i].cur = sllist[r].cur;
	            sllist[r].cur = _i;
	
	            // 该元素已在表中，删除之
	        } else {
	            sllist[p].cur = sllist[k].cur;
	            sllist.free(k);
	            // 若删除的是r所指结点，则需修改尾指针
	            if (r === k) r = p;
	        }
	    }
	}
	
	var sl = new StaticLinkedList(10);
	var ret = difference(sl, [1, 2, 3], [3, 4, 5]);
	console.log(sl);
	
	var test = new StaticLinkedList(10);
	test.create([49, 38, 65, 97, 76, 13, 27, 49]);
	console.log(test);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(19);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(18);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinaryTree2 = __webpack_require__(16);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BSTNode = function (_BinaryTree) {
	    (0, _inherits3.default)(BSTNode, _BinaryTree);
	
	    function BSTNode() {
	        (0, _classCallCheck3.default)(this, BSTNode);
	
	        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
	            arg[_key] = arguments[_key];
	        }
	
	        return (0, _possibleConstructorReturn3.default)(this, _BinaryTree.call.apply(_BinaryTree, [this].concat(arg)));
	    }
	
	    /**
	     * BST树的查找（递归）
	     * @param {*} key
	     * @returns {*}
	     */
	
	
	    BSTNode.prototype.search = function search(key) {
	        if (this.data != null) {
	            if (this.data === key) return this;else if (key < this.data) {
	                if (this.leftChild) return this.leftChild.search(key);
	            } else {
	                if (this.rightChild) return this.rightChild.search(key);
	            }
	        }
	
	        return null;
	    };
	
	    /**
	     * BST树的查找（非递归）
	     * @param {*} key
	     * @returns {*}
	     */
	
	
	    BSTNode.prototype.searchNonRecursive = function searchNonRecursive(key) {
	        if (this.data == null) return null;
	
	        var p = this;
	        while (p && p.data !== key) {
	            if (key < p.data) p = p.leftChild;else p = p.rightChild;
	        }
	
	        if (!p || key !== p.data) return null;else return p;
	    };
	
	    /**
	     * BST树的插入（递归）
	     * @param {*} key
	     */
	
	
	    BSTNode.prototype.insert = function insert(key) {
	        if (this.data == null) {
	            this.data = key;
	            return;
	        }
	        if (key === this.data) return;
	
	        var node = new BSTNode(key);
	        if (key < this.data) {
	            if (!this.leftChild) this.leftChild = node;
	            this.leftChild.insert(key);
	        } else {
	            if (!this.rightChild) this.rightChild = node;
	            this.rightChild.insert(key);
	        }
	    };
	
	    /**
	     * BST树的插入（非递归）
	     * @param {*} key
	     */
	
	
	    BSTNode.prototype.insertNonRecursive = function insertNonRecursive(key) {
	        if (this.data == null) {
	            this.data = key;
	            return;
	        }
	
	        var p = this;
	        var q = void 0;
	        while (p) {
	            if (p.data === key) return;
	            // q作为p的父节点
	            q = p;
	            if (key < p.data) p = p.leftChild;else p = p.rightChild;
	        }
	
	        var node = new BSTNode(key);
	        if (key < q.data) q.leftChild = node;else q.rightChild = node;
	    };
	
	    /**
	     * 利用BST树的插入操作建立一棵BST树
	     * @param {Array} arr
	     * @param {Boolean|undefined} useNonRecursive 是否使用非递归
	     */
	
	
	    BSTNode.prototype.createBST = function createBST(arr, useNonRecursive) {
	        var i = void 0;
	        if (useNonRecursive) {
	            for (i = 0; i < arr.length; ++i) {
	                this.insertNonRecursive(arr[i]);
	            }
	        } else {
	            for (i = 0; i < arr.length; ++i) {
	                this.insert(arr[i]);
	            }
	        }
	
	        return this;
	    };
	
	    /**
	     * 使用递归的方法删除与关键字符合的结点
	     * @param {*} key 需要查找的关键字
	     * @param {BSTNode} parent 父节点，内部调用需要用到
	     * @returns {Boolean}
	     */
	
	
	    BSTNode.prototype.remove = function remove(key, parent) {
	        // 空结点的情况
	        if (this.data == null) return false;
	
	        // 找到关键字
	        if (this.data === key) return deleteNode(this, parent);
	        // 查找左子树，如果有的话
	        else if (key < this.data) {
	                if (this.leftChild) return this.leftChild.remove(key, this);
	            }
	            // 查找右子树，如果有的话
	            else {
	                    if (this.rightChild) return this.rightChild.remove(key, this);
	                }
	
	        // 未找到
	        return false;
	    };
	
	    /**
	     * 非递归删除与关键字符合的结点
	     * @param {*} key 需要查找的关键字
	     * @returns {boolean}
	     */
	
	
	    BSTNode.prototype.removeNonRecursive = function removeNonRecursive(key) {
	        var p = this;
	        var f = void 0;
	
	        while (p && p.data !== key) {
	            f = p;
	            if (key < p.data) p = p.leftChild;else p = p.rightChild;
	        }
	
	        // 没有要删除的结点
	        if (!p) return false;
	
	        // 找到了要删除的结点p
	        var s = p;
	        var q = void 0;
	        // 如果有左右子树
	        if (p.leftChild && p.rightChild) {
	            f = p;
	            s = p.leftChild;
	
	            // 找到左子树的最大右子树，即仅小于左子树的值的结点
	            while (s.rightChild) {
	                f = s;
	                s = s.rightChild;
	            }
	
	            p.data = s.data;
	        }
	
	        // 若s有左子树，右子树为空
	        if (s.leftChild) q = s.leftChild;else q = s.rightChild;
	
	        // 只有一个根结点的情况
	        if (!f) this.data = null;else if (f.leftChild == s) f.leftChild = q;else f.rightChild = q;
	
	        return true;
	    };
	
	    /**
	     * 找到小于x的最大元素和大于x的最小元素
	     * @param {String|Number} x
	     * @returns {Array} [min, max]
	     */
	
	
	    BSTNode.prototype.findNeighborElem = function findNeighborElem(x) {
	        var last = typeof this.data === 'number' ? -Infinity : 'a';
	        var ret = [];
	
	        void function recurse(tree, x) {
	            if (tree.leftChild) recurse(tree.leftChild, x);
	            if (last < x && tree.data >= x) ret[0] = last;
	            if (last <= x && tree.data > x) ret[1] = tree.data;
	            last = tree.data;
	            if (tree.rightChild) recurse(tree.rightChild, x);
	        }(this, x);
	
	        return ret;
	    };
	
	    /**
	     * 把二叉排序树bst合并到该树中
	     * @param {BSTNode} bst
	     */
	
	
	    BSTNode.prototype.merge = function merge(bst) {
	        if (bst.leftChild) this.merge(bst.leftChild);
	        if (bst.rightChild) this.merge(bst.rightChild);
	        this.insert(bst.data);
	    };
	
	    /**
	     * 把结点插入到合适位置
	     * @param {BSTNode} node 待插入的结点
	     */
	
	
	    BSTNode.prototype.insertNode = function insertNode(node) {
	        if (this.data == null) {
	            this.data = node.data;
	        } else {
	            if (node.data > this.data) {
	                if (!this.rightChild) this.rightChild = node;else this.rightChild.insertNode(node);
	            } else if (node.data < this.data) {
	                if (!this.leftChild) this.leftChild = node;else this.leftChild.insertNode(node);
	            }
	        }
	
	        node.leftChild = node.rightChild = null;
	    };
	
	    /**
	     * 分裂为两棵二叉排序树
	     * @param {*} x
	     * @returns {BSTNode[a, b]} a的元素全部小于等于x，b的元素全部大于x
	     */
	
	
	    BSTNode.prototype.split = function split(x) {
	        var a = new BSTNode();
	        var b = new BSTNode();
	
	        void function split(tree, x) {
	            if (tree.leftChild) split(tree.leftChild, x);
	            if (tree.rightChild) split(tree.rightChild, x);
	            if (tree.data <= x) a.insertNode(tree);else b.insertNode(tree);
	        }(this, x);
	
	        return [a, b];
	    };
	
	    /**
	     * 判断tree是否是二叉排序树
	     * @param tree
	     */
	
	
	    BSTNode.isBSTTree = function isBSTTree(tree) {
	        var last = typeof tree.data === 'number' ? -Infinity : 'a';
	        var flag = true;
	
	        void function isBSTTree(tree) {
	            if (tree.leftChild && flag) isBSTTree(tree.leftChild);
	            if (tree.data < last) flag = false;
	            last = tree.data;
	            if (tree.rightChild && flag) isBSTTree(tree.rightChild);
	        }(tree);
	
	        return flag;
	    };
	
	    return BSTNode;
	}(_BinaryTree2.BinaryTree);
	
	/**
	 * 删除结点
	 * @param {BSTNode} p 要删除的结点
	 * @param {BSTNode} parent 要删除的结点的父节点
	 * @returns {boolean} 返回删除成功
	 */
	/*
	 动态查找
	
	 当查找表以线性表的形式组织时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。
	 利用树的形式组织查找表，可以对查找表进行动态高效的查找。
	
	
	 二叉排序树(BST)的定义
	
	 二叉排序树(Binary Sort Tree或Binary Search Tree) 的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。
	 (1) ：若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；
	 (2) ：若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；
	 (3) ：左、右子树都分别是二叉排序树。
	 结论：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。
	
	
	 BST树的查找
	 1  查找思想
	 首先将给定的K值与二叉排序树的根结点的关键字进行比较：若相等： 则查找成功；
	 ① 给定的K值小于BST的根结点的关键字：继续在该结点的左子树上进行查找；
	 ② 给定的K值大于BST的根结点的关键字：继续在该结点的右子树上进行查找。
	
	 在随机情况下，二叉排序树的平均查找长度ASL和㏒(n)(树的深度)是等数量级的。
	
	
	 BST树的插入
	
	 在BST树中插入一个新结点，要保证插入后仍满足BST的性质。
	
	 1 插入思想
	 在BST树中插入一个新结点x时，若BST树为空，则令新结点x为插入后BST树的根结点；否则，将结点x的关键字与根结点T的关键字进行比较：
	 ① 若相等： 不需要插入；
	 ②  若x.key<T->key：结点x插入到T的左子树中；
	 ③  若x.key>T->key：结点x插入到T的右子树中。
	
	 由结论知，对于一个无序序列可以通过构造一棵BST树而变成一个有序序列。
	 由算法知，每次插入的新结点都是BST树的叶子结点，即在插入时不必移动其它结点，仅需修改某个结点的指针。
	
	
	 BST树的删除
	
	 1  删除操作过程分析
	 从BST树上删除一个结点，仍然要保证删除后满足BST的性质。设被删除结点为p，其父结点为f ，删除情况如下：
	 ①  若p是叶子结点： 直接删除p。
	 ②  若p只有一棵子树(左子树或右子树)：直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树。
	 ③ 若p既有左子树又有右子树 ：处理方法有以下两种，可以任选其中一种。
	 ◆  用p的直接前驱结点代替p。即从p的左子树中选择值最大的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的左子树中的最右边的结点且没有右子树，对s的删除同②。
	 ◆ 用p的直接后继结点代替p。即从p的右子树中选择值最小的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的右子树中的最左边的结点且没有左子树，对s的删除同②。
	
	 */
	
	exports.default = BSTNode;
	function deleteNode(p, parent) {
	    // 叶子结点或只有一个结点
	    if (!p.leftChild && !p.rightChild) {
	        // 当前结点是其父结点的左子树还是右子树
	        var pos = parent && parent.leftChild == p ? 'leftChild' : 'rightChild';
	        if (parent) parent[pos] = null;
	        // 只有一个结点的情况
	        else p.data = null;
	    }
	    // 只有左子树
	    else if (!p.rightChild) {
	            p.data = p.leftChild.data;
	            p.leftChild = p.leftChild.leftChild;
	        }
	        // 只有右子树
	        else if (!p.leftChild) {
	                p.data = p.rightChild.data;
	                p.rightChild = p.rightChild.rightChild;
	            }
	            // 左右子树都有
	            else {
	                    var s = p.leftChild;
	                    // q为父结点
	                    var q = p;
	                    // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                    while (s.rightChild) {
	                        q = s;
	                        s = s.rightChild;
	                    }
	
	                    p.data = s.data;
	                    if (q != p) q.rightChild = s.leftChild;else q.leftChild = s.leftChild;
	                }
	
	    return true;
	}
	
	var bst = new BSTNode();
	bst.createBST([45, 24, 53, 12, 24, 90]);
	console.log(bst.search(12));
	console.log(bst.search(13));
	
	var bst2 = new BSTNode();
	bst2.createBST([45, 24, 53, 12, 24, 90], true);
	console.log(bst2.searchNonRecursive(12));
	console.log(bst2.searchNonRecursive(13));
	
	console.log('\nfindSiblingElem: ');
	console.log(bst.findNeighborElem(12) + '');
	console.log(bst.findNeighborElem(90) + '');
	console.log(bst.findNeighborElem(45) + '');
	
	console.log(bst.remove(45));
	console.log(bst.remove(1));
	console.log(bst.remove(53));
	console.log(bst.remove(12));
	console.log(bst.remove(90));
	console.log(bst.remove(24));
	console.log(bst.remove(2));
	
	//console.log(bst2.removeNonRecursive(45));
	//console.log(bst2.removeNonRecursive(1));
	//console.log(bst2.removeNonRecursive(53));
	//console.log(bst2.removeNonRecursive(12));
	//console.log(bst2.removeNonRecursive(90));
	//console.log(bst2.removeNonRecursive(24));
	//console.log(bst2.removeNonRecursive(2));
	
	console.log('\nisBSTTree: ');
	console.log(BSTNode.isBSTTree(bst));
	//console.log(BSTNode.isBSTTree(sosTree));
	
	
	/**
	 * 从大到小输出二叉排序树中所有不小于x的元素
	 * @param bst
	 * @param x
	 */
	function printNotLessThan(bst, x) {
	    if (bst.rightChild) printNotLessThan(bst.rightChild, x);
	    if (bst.data < x) return;
	    console.log(bst.data);
	    if (bst.leftChild) printNotLessThan(bst.leftChild, x);
	}
	
	console.log('\nprintNotLessThan: ');
	printNotLessThan(bst2, 90);
	console.log('\n');
	printNotLessThan(bst2, 12);
	
	bst.merge(bst2);
	
	var a1 = new BSTNode(5);
	var a2 = new BSTNode(91);
	bst2.insertNode(a1);
	bst2.insertNode(a2);
	
	bst2.split(45);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.bubbleSort = bubbleSort;
	exports.bubbleSort2 = bubbleSort2;
	exports.cockTailSort = cockTailSort;
	exports.cockTailSort2 = cockTailSort2;
	exports.quickSortRecursive = quickSortRecursive;
	exports.quickSortRecursive2 = quickSortRecursive2;
	exports.quickSortNonRecursive = quickSortNonRecursive;
	exports.quickSort = quickSort;
	exports.oddEvenSort = oddEvenSort;
	
	var _defaultComparision = __webpack_require__(24);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 交换排序
	
	 是一类基于交换的排序，系统地交换反序的记录的偶对，直到不再有这样的偶对为止。其中最基本的是冒泡排序(Bubble Sort)。
	
	 冒泡排序
	 1  排序思想
	 依次比较相邻的两个记录的关键字，若两个记录是反序的(即前一个记录的关键字大于后前一个记录的关键字)，则进行交换，直到没有反序的记录为止。
	     ① 首先将L->R[1]与L->R[2]的关键字进行比较，若为反序(L->R[1]的关键字大于L->R[2]的关键字)，则交换两个记录；然后比较L->R[2]与L->R[3]的关键字，依此类推，直到L->R[n-1]与L->R[n]的关键字比较后为止，称为一趟冒泡排序，L->R[n]为关键字最大的记录。
	     ②  然后进行第二趟冒泡排序，对前n-1个记录进行同样的操作。
	 一般地，第i趟冒泡排序是对L->R[1 … n-i+1]中的记录进行的，因此，若待排序的记录有n个，则要经过n-1趟冒泡排序才能使所有的记录有序。
	
	 2  排序示例
	 设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41
	
	 初始关键字序列:  23    38     22     45     23     67     31     15    41
	 第一趟排序后:    23    22     38     23     45     31     15     41    67
	 第二趟排序后:    22    23     23     38     31     15     41     45    67
	 第三趟排序后:    22    23     23     31     15     38     41     45    67
	 第四趟排序后:    22    23     23     15     31     38     41     45    67
	 第五趟排序后:    22    23     15     23     31     38     41     45    67
	 第六趟排序后:    22    15     23     23     31     38     41     45    67
	 第七趟排序后:    15    22     23     23     31     38     41     45    67
	
	3.算法分析
	 时间复杂度
	 ◆  最好情况(正序)：比较次数：n-1；移动次数：0；
	 ◆  最坏情况(逆序)：
	 比较次数： n * (n - 1) / 2
	 移动次数： 3*n*(n - 1) / 2
	
	 故时间复杂度：T(n)=O(n²)
	 空间复杂度：S(n)=O(1)
	
	 */
	
	function bubbleSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var change = 0;
	
	        for (var j = 0; j <= len - i; ++j) {
	            if (comp(sqList[j + 1], sqList[j]) < 0) {
	                change = 1;
	                var temp = sqList[j];
	                sqList[j] = sqList[j + 1];
	                sqList[j + 1] = temp;
	            }
	        }
	
	        if (!change) break;
	    }
	} /**
	   * Created by Luke on 2015/2/2.
	   */
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort(arr);
	console.log('bubbleSort:\n' + arr + '');
	
	// 冒泡改进1
	function bubbleSort2(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var len = sqList.length;
	    var change = len - 1;
	
	    while (change) {
	        var c = 0;
	        for (var i = 0; i < change; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                // c指示这一趟冒泡中发生交换的元素
	                c = i + 1;
	            }
	        }
	
	        change = c;
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort2(arr);
	console.log('bubbleSort2:\n' + arr + '');
	
	// 相邻两趟反方向起泡的冒泡排序算法
	function cockTailSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var len = sqList.length;
	    // 冒泡上下界
	    var low = 0,
	        high = len - 1;
	    var change = 1;
	    var temp = void 0;
	
	    while (low < high && change) {
	        change = 0;
	
	        // 从上向下起泡
	        for (var i = low; i < high; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改上界
	        --high;
	
	        // 从下向上起泡
	        for (var _i = high; _i > low; --_i) {
	            if (comp(sqList[_i], sqList[_i - 1]) < 0) {
	                temp = sqList[_i];
	                sqList[_i] = sqList[_i - 1];
	                sqList[_i - 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改下界
	        ++low;
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort(arr);
	console.log('cockTailSort:\n' + arr + '');
	
	// 改进3
	function cockTailSort2(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var b = {};
	    var len = sqList.length;
	    // d为冒泡方向标识， 1为向上，-1为向下
	    var d = 1;
	    // b[0]为冒泡上界，b[2]为冒泡上界，b[1]无用
	    b[0] = 0;
	    b[2] = len - 1;
	    var change = 1;
	
	    while (b[0] < b[2] && change) {
	        change = 0;
	
	        // 统一的冒泡算法
	        for (var i = b[1 - d]; i !== b[1 + d]; i += d) {
	            // 注意这个交换条件
	            if (comp(sqList[i], sqList[i + d]) * d > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + d];
	                sqList[i + d] = temp;
	                change = 1;
	            }
	        }
	
	        // 修改边界
	        b[1 + d] -= d;
	        // 换个方向
	        d *= -1;
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort2(arr);
	console.log('cockTailSort2:\n' + arr + '');
	
	/*
	 快速排序
	
	 1  排序思想
	 通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录进行下一趟排序，以达到整个序列有序。
	
	 2  排序过程
	 设待排序的记录序列是R[s…t] ，在记录序列中任取一个记录(一般取R[s])作为参照(又称为基准或枢轴)，以R[s].key为基准重新排列其余的所有记录，方法是：
	     ◆ 所有关键字比基准小的放R[s]之前；
	     ◆ 所有关键字比基准大的放R[s]之后。
	 以R[s].key最后所在位置i作为分界，将序列R[s…t]分割成两个子序列，称为一趟快速排序。
	
	 3  一趟快速排序方法
	 从序列的两端交替扫描各个记录，将关键字小于基准关键字的记录依次放置到序列的前边；而将关键字大于基准关键字的记录从序列的最后端起，依次放置到序列的后边，直到扫描完所有的记录。
	
	 设置指针low，high，初值为第1个和最后一个记录的位置。
	 设两个变量i，j，初始时令i=low，j=high，以R[low].key作为基准(将R[low]保存在temp中) 。
	 ① 从j所指位置向前搜索：将temp与R[j].key进行比较：
	    ◆ 若temp≤R[j].key ：令j=j-1，然后继续进行比较， 直到i=j或temp>R[j].key为止；
	    ◆ 若temp>R[j].key ：R[j]R[i]，腾空R[j]的位置， 且令i=i+1；
	 ② 从i所指位置起向后搜索：将temp与R[i].key进行比较：
	    ◆ 若temp≥R[i].key ：令i=i+1，然后继续进行比较， 直到i=j或temp<R[i].key为止；
	    ◆ 若temp<R[i].key ：R[i]R[j]，腾空R[i]的位置， 且令j=j-1；
	 ③ 重复①、②，直至i=j为止，i就是temp(基准)所应放置的位置。
	
	 算法分析
	 快速排序的主要时间是花费在划分上，对长度为k的记录序列进行划分时关键字的比较次数是k-1 。设长度为n的记录序列进行排序的比较次数为C(n)，则C(n)=n-1+C(k)+C(n-k-1) 。
	 ◆  最好情况：每次划分得到的子序列大致相等，则
	 C(n)<=h×n+2h×C(n/2h) ，当n/2h=1时排序结束。
	 即C(n)≤O(n×㏒2n) ；
	 ◆  最坏情况：每次划分得到的子序列中有一个为空，另一个子序列的长度为n-1。即每次划分所选择的基准是当前待排序序列中的最小(或最大)关键字。
	 比较次数：:  即C(n)=O(n2)
	 ◆  一般情况： 对n个记录进行快速排序所需的时间T(n)组成是：
	     ① 对n个记录进行一趟划分所需的时间是：n×C ，C是常数；
	     ② 对所得到的两个子序列进行快速排序的时间：
	        Tavg(n)=C(n)+Tavg(k-1)+Tavg(n-k)          ……
	
	 快速排序的平均时间复杂度是：T(n)=O(n㏒2n)
	 从所需要的附加空间来看，快速排序算法是递归调用，系统内用堆栈保存递归参数，当每次划分比较均匀时，栈的最大深度为[㏒2n]+1 。
	
	 快速排序的空间复杂度是：S(n)=O(㏒2n)
	 从排序的稳定性来看，快速排序是不稳定的。
	
	 */
	
	function partition1(sqList, low, high) {
	    var temp = sqList[low];
	
	    while (low < high) {
	        while (low < high && sqList[high] >= temp) {
	            --high;
	        }sqList[low] = sqList[high];
	        while (low < high && sqList[low] <= temp) {
	            ++low;
	        }sqList[high] = sqList[low];
	    }
	
	    sqList[low] = temp;
	
	    return low;
	}
	
	// 优化一趟快速排序方法： 随机化partition
	// 最坏情况效率大幅提升，时间复杂度T(n)=O(n㏒2n)
	function partition2(sqList, low, high) {
	    var temp = void 0;
	    var n = high - low + 1;
	    var rand = Math.floor(Math.random() * n) + low;
	
	    //let rand = (low + high) >> 1;
	    temp = sqList[high];
	    sqList[high] = sqList[rand];
	    sqList[rand] = temp;
	
	    var i = low - 1;
	    var pivot = sqList[high];
	
	    for (var j = low; j < high; ++j) {
	        if (sqList[j] <= pivot) {
	            ++i;
	            temp = sqList[i];
	            sqList[i] = sqList[j];
	            sqList[j] = temp;
	        }
	    }
	
	    ++i;
	    sqList[high] = sqList[i];
	    sqList[i] = pivot;
	
	    return i;
	}
	
	function partition(sqList, low, high, comp) {
	    var temp = void 0;
	    var i = low;
	    var j = high + 1;
	    var rand = Math.floor(Math.random() * (high - low)) + low + 1;
	    //let rand = (low + high) >> 1;
	
	    temp = sqList[low];
	    sqList[low] = sqList[rand];
	    sqList[rand] = temp;
	
	    var x = sqList[low];
	
	    while (1) {
	        while (comp(sqList[++i], x) < 0 && i < high) {}
	        while (comp(sqList[--j], x) > 0) {}
	        if (i >= j) break;
	        temp = sqList[i];
	        sqList[i] = sqList[j];
	        sqList[j] = temp;
	    }
	
	    sqList[low] = sqList[j];
	    sqList[j] = x;
	
	    return j;
	}
	
	function quickSortRecursive() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    if (low >= high) return;
	
	    var k = partition(sqList, low, high, comp);
	    quickSortRecursive(sqList, low, k - 1, comp);
	    quickSortRecursive(sqList, k + 1, high, comp);
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive(arr);
	console.log('quickSortRecursive:\n' + arr + '');
	
	/*
	快排递归算法优化，在最坏情况下堆栈深度为O(logn)
	 */
	function quickSortRecursive2() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    while (low < high) {
	        var k = partition(sqList, low, high, comp);
	
	        // 对两个子数组中较小的一个子数组进行递归调用。
	        // 较小子数组的大小最多为原数组大小一半，
	        // 由于每次递归调用的数组大小至少减少一半，所以递归调用的次数
	        // 最多为O(logn)
	        if (k - low + 1 < high - k) {
	            quickSortRecursive2(sqList, low, k - 1, comp);
	            low = k + 1;
	        } else {
	            quickSortRecursive2(sqList, k + 1, high, comp);
	            high = k - 1;
	        }
	    }
	}
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive2(arr);
	console.log('quickSortRecursive2:\n' + arr + '');
	
	function quickSortNonRecursive() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    var stack = [];
	    var k = void 0;
	
	    do {
	        while (low < high) {
	            k = partition(sqList, low, high, comp);
	            // 第二个子序列的上,下界分别入栈
	            stack.push(high, k + 1);
	            //stack.push(k + 1);
	            high = k - 1;
	        }
	
	        if (!stack.length) return;
	
	        low = stack.pop();
	        high = stack.pop();
	    } while (1);
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortNonRecursive(arr);
	console.log('quickSortNonRecursive:\n' + arr + '');
	
	// 优化版本
	function quickSort() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var low = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var high = arguments.length <= 2 || arguments[2] === undefined ? sqList.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    var stack = [];
	    var pivot = void 0;
	
	    do {
	        // 如果当前子序列长度大于3且尚未排好序
	        if (high - low > 2) {
	            // 进行一趟划分
	            pivot = partition(sqList, low, high, comp);
	
	            // 吧长的子序列边界入栈，
	            // 短的子序列留待下次排序
	            if (high - pivot > pivot - low) {
	                stack.push(high, pivot + 1);
	                //stack.push();
	                high = pivot - 1;
	            } else {
	                stack.push(pivot - 1, low);
	                //stack.push();
	                low = pivot + 1;
	            }
	        }
	        // 如果当前子序列长度小于3，且尚未排好序，
	        // 直接进行比较排序买当前子序列标志为已排好序
	        else if (low < high && high - low < 3) {
	                easySort(sqList, low, high, comp);
	                low = high;
	            }
	            // 如果当前子序列已排好序但栈中还有未排序的子序列
	            // 从栈中取出一个子序列
	            else {
	                    if (!stack.length) return;
	
	                    low = stack.pop();
	                    high = stack.pop();
	                }
	    } while (1);
	}
	
	function easySort(sqList, low, high, comp) {
	    var temp = void 0;
	
	    if (high - low === 1) {
	        if (comp(sqList[low], sqList[high]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[high];
	            sqList[high] = temp;
	        }
	    } else {
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	        if (comp(sqList[low + 1], sqList[high]) > 0) {
	            temp = sqList[low + 1];
	            sqList[low + 1] = sqList[high];
	            sqList[high] = temp;
	        }
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSort(arr);
	console.log('quickSort:\n' + arr + '');
	
	// 奇偶交换排序
	function oddEvenSort() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var change = 1;
	    var temp = void 0;
	    var len = sqList.length;
	
	    while (change) {
	        change = 0;
	        // 对所有奇数进行一趟比较
	        for (var i = 1; i < len - 1; i += 2) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	
	                change = 1;
	            }
	        }
	
	        // 对所有偶数进行一趟比较
	        for (var _i2 = 0; _i2 < len - 1; _i2 += 2) {
	            if (comp(sqList[_i2], sqList[_i2 + 1]) > 0) {
	                temp = sqList[_i2];
	                sqList[_i2] = sqList[_i2 + 1];
	                sqList[_i2 + 1] = temp;
	
	                change = 1;
	            }
	        }
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	oddEvenSort(arr);
	console.log('oddEvenSort:\n' + arr + '');
	
	/*
	把由三种颜色组成的序列重排为按照红白蓝的顺序排列，
	思路：
	设立三个指针，其中j表示当前元素；i以前的元素全部为红色；k以后的颜色全为蓝色。这样就可以根据j的颜色把其交换到序列的前面或者后面。
	 */
	var RED = 0;
	var WHITE = 1;
	var BLUE = 2;
	
	function flagArrange(colors) {
	    var i = 0;
	    var j = 0;
	    var k = colors.length - 1;
	    var temp = void 0;
	
	    while (j <= k) {
	        switch (colors[j]) {
	            case RED:
	                temp = colors[i];
	                colors[i] = colors[j];
	                colors[j] = temp;
	                ++i;
	                ++j;
	                break;
	            case WHITE:
	                ++j;
	                break;
	            case BLUE:
	                temp = colors[j];
	                colors[j] = colors[k];
	                colors[k] = temp;
	                --k;
	                break;
	            default:
	                break;
	        }
	    }
	}
	
	var arr = [2, 1, 0, 2, 1, 1, 0, 2, 0, 2, 1];
	flagArrange(arr);
	console.log(arr + '');

/***/ },
/* 58 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        return setTimeout(fun, 0);
	    } else {
	        return cachedSetTimeout.call(null, fun, 0);
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        clearTimeout(marker);
	    } else {
	        cachedClearTimeout.call(null, marker);
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(65), __esModule: true };

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(66), __esModule: true };

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(67), __esModule: true };

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(68), __esModule: true };

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(69), __esModule: true };

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(90);
	var $Object = __webpack_require__(9).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	var $Object = __webpack_require__(9).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(92);
	module.exports = __webpack_require__(9).Object.setPrototypeOf;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(95);
	__webpack_require__(93);
	__webpack_require__(96);
	__webpack_require__(97);
	module.exports = __webpack_require__(9).Symbol;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(94);
	__webpack_require__(98);
	module.exports = __webpack_require__(37).f('iterator');

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(7)
	  , toLength  = __webpack_require__(87)
	  , toIndex   = __webpack_require__(86);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(21)
	  , gOPS    = __webpack_require__(48)
	  , pIE     = __webpack_require__(30);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(3).document && document.documentElement;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(41);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(41);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(29)
	  , descriptor     = __webpack_require__(22)
	  , setToStringTag = __webpack_require__(31)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(11)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(21)
	  , toIObject = __webpack_require__(7);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(23)('meta')
	  , isObject = __webpack_require__(15)
	  , has      = __webpack_require__(5)
	  , setDesc  = __webpack_require__(6).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(20)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(6)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(21);
	
	module.exports = __webpack_require__(4) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(7)
	  , gOPN      = __webpack_require__(47).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(5)
	  , toObject    = __webpack_require__(88)
	  , IE_PROTO    = __webpack_require__(32)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(15)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(42)(Function.call, __webpack_require__(46).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(34)
	  , defined   = __webpack_require__(25);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(34)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(34)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(25);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(71)
	  , step             = __webpack_require__(78)
	  , Iterators        = __webpack_require__(27)
	  , toIObject        = __webpack_require__(7);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(45)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(14)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(29)});

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(14);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(4), 'Object', {defineProperty: __webpack_require__(6).f});

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(14);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(84).set});

/***/ },
/* 93 */
/***/ function(module, exports) {



/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(85)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(45)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(3)
	  , has            = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(4)
	  , $export        = __webpack_require__(14)
	  , redefine       = __webpack_require__(50)
	  , META           = __webpack_require__(80).KEY
	  , $fails         = __webpack_require__(20)
	  , shared         = __webpack_require__(33)
	  , setToStringTag = __webpack_require__(31)
	  , uid            = __webpack_require__(23)
	  , wks            = __webpack_require__(11)
	  , wksExt         = __webpack_require__(37)
	  , wksDefine      = __webpack_require__(36)
	  , keyOf          = __webpack_require__(79)
	  , enumKeys       = __webpack_require__(73)
	  , isArray        = __webpack_require__(76)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(7)
	  , toPrimitive    = __webpack_require__(35)
	  , createDesc     = __webpack_require__(22)
	  , _create        = __webpack_require__(29)
	  , gOPNExt        = __webpack_require__(82)
	  , $GOPD          = __webpack_require__(46)
	  , $DP            = __webpack_require__(6)
	  , $keys          = __webpack_require__(21)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(47).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(30).f  = $propertyIsEnumerable;
	  __webpack_require__(48).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(36)('asyncIterator');

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(36)('observable');

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(89);
	var global        = __webpack_require__(3)
	  , hide          = __webpack_require__(10)
	  , Iterators     = __webpack_require__(27)
	  , TO_STRING_TAG = __webpack_require__(11)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(51)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(105)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(51)
	
	exports.createHmac = __webpack_require__(100)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(104)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(101);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(141)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(155)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2).Buffer))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
		C-like unsigned 32 bits integers in Javascript
		Copyright (C) 2013, Pierre Curto
		MIT license
	 */
	;(function (root) {
	
		// Local cache for typical radices
		var radixPowerCache = {
			36: UINT32( Math.pow(36, 5) )
		,	16: UINT32( Math.pow(16, 7) )
		,	10: UINT32( Math.pow(10, 9) )
		,	2:  UINT32( Math.pow(2, 30) )
		}
		var radixCache = {
			36: UINT32(36)
		,	16: UINT32(16)
		,	10: UINT32(10)
		,	2:  UINT32(2)
		}
	
		/**
		 *	Represents an unsigned 32 bits integer
		 * @constructor
		 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
		 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
		 * @return 
		 */
		function UINT32 (l, h) {
			if ( !(this instanceof UINT32) )
				return new UINT32(l, h)
	
			this._low = 0
			this._high = 0
			this.remainder = null
			if (typeof h == 'undefined')
				return fromNumber.call(this, l)
	
			if (typeof l == 'string')
				return fromString.call(this, l, h)
	
			fromBits.call(this, l, h)
		}
	
		/**
		 * Set the current _UINT32_ object with its low and high bits
		 * @method fromBits
		 * @param {Number} low bits
		 * @param {Number} high bits
		 * @return ThisExpression
		 */
		function fromBits (l, h) {
			this._low = l | 0
			this._high = h | 0
	
			return this
		}
		UINT32.prototype.fromBits = fromBits
	
		/**
		 * Set the current _UINT32_ object from a number
		 * @method fromNumber
		 * @param {Number} number
		 * @return ThisExpression
		 */
		function fromNumber (value) {
			this._low = value & 0xFFFF
			this._high = value >>> 16
	
			return this
		}
		UINT32.prototype.fromNumber = fromNumber
	
		/**
		 * Set the current _UINT32_ object from a string
		 * @method fromString
		 * @param {String} integer as a string
		 * @param {Number} radix (optional, default=10)
		 * @return ThisExpression
		 */
		function fromString (s, radix) {
			var value = parseInt(s, radix || 10)
	
			this._low = value & 0xFFFF
			this._high = value >>> 16
	
			return this
		}
		UINT32.prototype.fromString = fromString
	
		/**
		 * Convert this _UINT32_ to a number
		 * @method toNumber
		 * @return {Number} the converted UINT32
		 */
		UINT32.prototype.toNumber = function () {
			return (this._high << 16) | this._low
		}
	
		/**
		 * Convert this _UINT32_ to a string
		 * @method toString
		 * @param {Number} radix (optional, default=10)
		 * @return {String} the converted UINT32
		 */
		UINT32.prototype.toString = function (radix) {
			radix = radix || 10
			var radixUint = radixCache[radix] || new UINT32(radix)
	
			if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)
	
			var self = this.clone()
			var res = new Array(32)
			for (var i = 31; i >= 0; i--) {
				self.div(radixUint)
				res[i] = self.remainder.toNumber().toString(radix)
				if ( !self.gt(radixUint) ) break
			}
			res[i-1] = self.toNumber().toString(radix)
	
			return res.join('')
		}
	
		/**
		 * Add two _UINT32_. The current _UINT32_ stores the result
		 * @method add
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.add = function (other) {
			var a00 = this._low + other._low
			var a16 = a00 >>> 16
	
			a16 += this._high + other._high
	
			this._low = a00 & 0xFFFF
			this._high = a16 & 0xFFFF
	
			return this
		}
	
		/**
		 * Subtract two _UINT32_. The current _UINT32_ stores the result
		 * @method subtract
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.subtract = function (other) {
			//TODO inline
			return this.add( other.clone().negate() )
		}
	
		/**
		 * Multiply two _UINT32_. The current _UINT32_ stores the result
		 * @method multiply
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.multiply = function (other) {
			/*
				a = a00 + a16
				b = b00 + b16
				a*b = (a00 + a16)(b00 + b16)
					= a00b00 + a00b16 + a16b00 + a16b16
	
				a16b16 overflows the 32bits
			 */
			var a16 = this._high
			var a00 = this._low
			var b16 = other._high
			var b00 = other._low
	
	/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
			// this == 0 or other == 1: nothing to do
			if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this
	
			// other == 0 or this == 1: this = other
			if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
				this._low = other._low
				this._high = other._high
				return this
			}
	*/
	
			var c16, c00
			c00 = a00 * b00
			c16 = c00 >>> 16
	
			c16 += a16 * b00
			c16 &= 0xFFFF		// Not required but improves performance
			c16 += a00 * b16
	
			this._low = c00 & 0xFFFF
			this._high = c16 & 0xFFFF
	
			return this
		}
	
		/**
		 * Divide two _UINT32_. The current _UINT32_ stores the result.
		 * The remainder is made available as the _remainder_ property on
		 * the _UINT32_ object. It can be null, meaning there are no remainder.
		 * @method div
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.div = function (other) {
			if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')
	
			// other == 1
			if (other._high == 0 && other._low == 1) {
				this.remainder = new UINT32(0)
				return this
			}
	
			// other > this: 0
			if ( other.gt(this) ) {
				this.remainder = this.clone()
				this._low = 0
				this._high = 0
				return this
			}
			// other == this: 1
			if ( this.eq(other) ) {
				this.remainder = new UINT32(0)
				this._low = 1
				this._high = 0
				return this
			}
	
			// Shift the divisor left until it is higher than the dividend
			var _other = other.clone()
			var i = -1
			while ( !this.lt(_other) ) {
				// High bit can overflow the default 16bits
				// Its ok since we right shift after this loop
				// The overflown bit must be kept though
				_other.shiftLeft(1, true)
				i++
			}
	
			// Set the remainder
			this.remainder = this.clone()
			// Initialize the current result to 0
			this._low = 0
			this._high = 0
			for (; i >= 0; i--) {
				_other.shiftRight(1)
				// If shifted divisor is smaller than the dividend
				// then subtract it from the dividend
				if ( !this.remainder.lt(_other) ) {
					this.remainder.subtract(_other)
					// Update the current result
					if (i >= 16) {
						this._high |= 1 << (i - 16)
					} else {
						this._low |= 1 << i
					}
				}
			}
	
			return this
		}
	
		/**
		 * Negate the current _UINT32_
		 * @method negate
		 * @return ThisExpression
		 */
		UINT32.prototype.negate = function () {
			var v = ( ~this._low & 0xFFFF ) + 1
			this._low = v & 0xFFFF
			this._high = (~this._high + (v >>> 16)) & 0xFFFF
	
			return this
		}
	
		/**
		 * Equals
		 * @method eq
		 * @param {Object} other UINT32
		 * @return {Boolean}
		 */
		UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
			return (this._low == other._low) && (this._high == other._high)
		}
	
		/**
		 * Greater than (strict)
		 * @method gt
		 * @param {Object} other UINT32
		 * @return {Boolean}
		 */
		UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
			if (this._high > other._high) return true
			if (this._high < other._high) return false
			return this._low > other._low
		}
	
		/**
		 * Less than (strict)
		 * @method lt
		 * @param {Object} other UINT32
		 * @return {Boolean}
		 */
		UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
			if (this._high < other._high) return true
			if (this._high > other._high) return false
			return this._low < other._low
		}
	
		/**
		 * Bitwise OR
		 * @method or
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.or = function (other) {
			this._low |= other._low
			this._high |= other._high
	
			return this
		}
	
		/**
		 * Bitwise AND
		 * @method and
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.and = function (other) {
			this._low &= other._low
			this._high &= other._high
	
			return this
		}
	
		/**
		 * Bitwise NOT
		 * @method not
		 * @return ThisExpression
		 */
		UINT32.prototype.not = function() {
			this._low = ~this._low & 0xFFFF
			this._high = ~this._high & 0xFFFF
	
			return this
		}
	
		/**
		 * Bitwise XOR
		 * @method xor
		 * @param {Object} other UINT32
		 * @return ThisExpression
		 */
		UINT32.prototype.xor = function (other) {
			this._low ^= other._low
			this._high ^= other._high
	
			return this
		}
	
		/**
		 * Bitwise shift right
		 * @method shiftRight
		 * @param {Number} number of bits to shift
		 * @return ThisExpression
		 */
		UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
			if (n > 16) {
				this._low = this._high >> (n - 16)
				this._high = 0
			} else if (n == 16) {
				this._low = this._high
				this._high = 0
			} else {
				this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )
				this._high >>= n
			}
	
			return this
		}
	
		/**
		 * Bitwise shift left
		 * @method shiftLeft
		 * @param {Number} number of bits to shift
		 * @param {Boolean} allow overflow
		 * @return ThisExpression
		 */
		UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
			if (n > 16) {
				this._high = this._low << (n - 16)
				this._low = 0
				if (!allowOverflow) {
					this._high &= 0xFFFF
				}
			} else if (n == 16) {
				this._high = this._low
				this._low = 0
			} else {
				this._high = (this._high << n) | (this._low >> (16-n))
				this._low = (this._low << n) & 0xFFFF
				if (!allowOverflow) {
					// Overflow only allowed on the high bits...
					this._high &= 0xFFFF
				}
			}
	
			return this
		}
	
		/**
		 * Bitwise rotate left
		 * @method rotl
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
			var v = (this._high << 16) | this._low
			v = (v << n) | (v >>> (32 - n))
			this._low = v & 0xFFFF
			this._high = v >>> 16
	
			return this
		}
	
		/**
		 * Bitwise rotate right
		 * @method rotr
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
			var v = (this._high << 16) | this._low
			v = (v >>> n) | (v << (32 - n))
			this._low = v & 0xFFFF
			this._high = v >>> 16
	
			return this
		}
	
		/**
		 * Clone the current _UINT32_
		 * @method clone
		 * @return {Object} cloned UINT32
		 */
		UINT32.prototype.clone = function () {
			return new UINT32(this._low, this._high)
		}
	
		if (true) {
			// AMD / RequireJS
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return UINT32
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
		} else if (typeof module != 'undefined' && module.exports) {
			// Node.js
			module.exports = UINT32
		} else {
			// Browser
			root['UINT32'] = UINT32
		}
	
	})(this)


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
		C-like unsigned 64 bits integers in Javascript
		Copyright (C) 2013, Pierre Curto
		MIT license
	 */
	;(function (root) {
	
		// Local cache for typical radices
		var radixPowerCache = {
			16: UINT64( Math.pow(16, 5) )
		,	10: UINT64( Math.pow(10, 5) )
		,	2:  UINT64( Math.pow(2, 5) )
		}
		var radixCache = {
			16: UINT64(16)
		,	10: UINT64(10)
		,	2:  UINT64(2)
		}
	
		/**
		 *	Represents an unsigned 64 bits integer
		 * @constructor
		 * @param {Number} first low bits (8)
		 * @param {Number} second low bits (8)
		 * @param {Number} first high bits (8)
		 * @param {Number} second high bits (8)
		 * or
		 * @param {Number} low bits (32)
		 * @param {Number} high bits (32)
		 * or
		 * @param {String|Number} integer as a string 		 | integer as a number
		 * @param {Number|Undefined} radix (optional, default=10)
		 * @return 
		 */
		function UINT64 (a00, a16, a32, a48) {
			if ( !(this instanceof UINT64) )
				return new UINT64(a00, a16, a32, a48)
	
			this.remainder = null
			if (typeof a00 == 'string')
				return fromString.call(this, a00, a16)
	
			if (typeof a16 == 'undefined')
				return fromNumber.call(this, a00)
	
			fromBits.apply(this, arguments)
		}
	
		/**
		 * Set the current _UINT64_ object with its low and high bits
		 * @method fromBits
		 * @param {Number} first low bits (8)
		 * @param {Number} second low bits (8)
		 * @param {Number} first high bits (8)
		 * @param {Number} second high bits (8)
		 * or
		 * @param {Number} low bits (32)
		 * @param {Number} high bits (32)
		 * @return ThisExpression
		 */
		function fromBits (a00, a16, a32, a48) {
			if (typeof a32 == 'undefined') {
				this._a00 = a00 & 0xFFFF
				this._a16 = a00 >>> 16
				this._a32 = a16 & 0xFFFF
				this._a48 = a16 >>> 16
				return this
			}
	
			this._a00 = a00 | 0
			this._a16 = a16 | 0
			this._a32 = a32 | 0
			this._a48 = a48 | 0
	
			return this
		}
		UINT64.prototype.fromBits = fromBits
	
		/**
		 * Set the current _UINT64_ object from a number
		 * @method fromNumber
		 * @param {Number} number
		 * @return ThisExpression
		 */
		function fromNumber (value) {
			this._a00 = value & 0xFFFF
			this._a16 = value >>> 16
			this._a32 = 0
			this._a48 = 0
	
			return this
		}
		UINT64.prototype.fromNumber = fromNumber
	
		/**
		 * Set the current _UINT64_ object from a string
		 * @method fromString
		 * @param {String} integer as a string
		 * @param {Number} radix (optional, default=10)
		 * @return ThisExpression
		 */
		function fromString (s, radix) {
			radix = radix || 10
	
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
	
			/*
				In Javascript, bitwise operators only operate on the first 32 bits 
				of a number, even though parseInt() encodes numbers with a 53 bits 
				mantissa.
				Therefore UINT64(<Number>) can only work on 32 bits.
				The radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)
				maximum input value is m = 32bits as 1 = 2^32 - 1
				So the maximum substring length n is:
				36^(n+1) - 1 = 2^32 - 1
				36^(n+1) = 2^32
				(n+1)ln(36) = 32ln(2)
				n = 32ln(2)/ln(36) - 1
				n = 5.189644915687692
				n = 5
			 */
			var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) )
	
			for (var i = 0, len = s.length; i < len; i += 5) {
				var size = Math.min(5, len - i)
				var value = parseInt( s.slice(i, i + size), radix )
				this.multiply(
						size < 5
							? new UINT64( Math.pow(radix, size) )
							: radixUint
					)
					.add( new UINT64(value) )
			}
	
			return this
		}
		UINT64.prototype.fromString = fromString
	
		/**
		 * Convert this _UINT64_ to a number (last 32 bits are dropped)
		 * @method toNumber
		 * @return {Number} the converted UINT64
		 */
		UINT64.prototype.toNumber = function () {
			return (this._a16 << 16) | this._a00
		}
	
		/**
		 * Convert this _UINT64_ to a string
		 * @method toString
		 * @param {Number} radix (optional, default=10)
		 * @return {String} the converted UINT64
		 */
		UINT64.prototype.toString = function (radix) {
			radix = radix || 10
			var radixUint = radixCache[radix] || new UINT64(radix)
	
			if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)
	
			var self = this.clone()
			var res = new Array(64)
			for (var i = 63; i >= 0; i--) {
				self.div(radixUint)
				res[i] = self.remainder.toNumber().toString(radix)
				if ( !self.gt(radixUint) ) break
			}
			res[i-1] = self.toNumber().toString(radix)
	
			return res.join('')
		}
	
		/**
		 * Add two _UINT64_. The current _UINT64_ stores the result
		 * @method add
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.add = function (other) {
			var a00 = this._a00 + other._a00
	
			var a16 = a00 >>> 16
			a16 += this._a16 + other._a16
	
			var a32 = a16 >>> 16
			a32 += this._a32 + other._a32
	
			var a48 = a32 >>> 16
			a48 += this._a48 + other._a48
	
			this._a00 = a00 & 0xFFFF
			this._a16 = a16 & 0xFFFF
			this._a32 = a32 & 0xFFFF
			this._a48 = a48 & 0xFFFF
	
			return this
		}
	
		/**
		 * Subtract two _UINT64_. The current _UINT64_ stores the result
		 * @method subtract
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.subtract = function (other) {
			return this.add( other.clone().negate() )
		}
	
		/**
		 * Multiply two _UINT64_. The current _UINT64_ stores the result
		 * @method multiply
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.multiply = function (other) {
			/*
				a = a00 + a16 + a32 + a48
				b = b00 + b16 + b32 + b48
				a*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)
					= a00b00 + a00b16 + a00b32 + a00b48
					+ a16b00 + a16b16 + a16b32 + a16b48
					+ a32b00 + a32b16 + a32b32 + a32b48
					+ a48b00 + a48b16 + a48b32 + a48b48
	
				a16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits
				so it comes down to:
				a*b	= a00b00 + a00b16 + a00b32 + a00b48
					+ a16b00 + a16b16 + a16b32
					+ a32b00 + a32b16
					+ a48b00
					= a00b00
					+ a00b16 + a16b00
					+ a00b32 + a16b16 + a32b00
					+ a00b48 + a16b32 + a32b16 + a48b00
			 */
			var a00 = this._a00
			var a16 = this._a16
			var a32 = this._a32
			var a48 = this._a48
			var b00 = other._a00
			var b16 = other._a16
			var b32 = other._a32
			var b48 = other._a48
	
			var c00 = a00 * b00
	
			var c16 = c00 >>> 16
			c16 += a00 * b16
			var c32 = c16 >>> 16
			c16 &= 0xFFFF
			c16 += a16 * b00
	
			c32 += c16 >>> 16
			c32 += a00 * b32
			var c48 = c32 >>> 16
			c32 &= 0xFFFF
			c32 += a16 * b16
			c48 += c32 >>> 16
			c32 &= 0xFFFF
			c32 += a32 * b00
	
			c48 += c32 >>> 16
			c48 += a00 * b48
			c48 &= 0xFFFF
			c48 += a16 * b32
			c48 &= 0xFFFF
			c48 += a32 * b16
			c48 &= 0xFFFF
			c48 += a48 * b00
	
			this._a00 = c00 & 0xFFFF
			this._a16 = c16 & 0xFFFF
			this._a32 = c32 & 0xFFFF
			this._a48 = c48 & 0xFFFF
	
			return this
		}
	
		/**
		 * Divide two _UINT64_. The current _UINT64_ stores the result.
		 * The remainder is made available as the _remainder_ property on
		 * the _UINT64_ object. It can be null, meaning there are no remainder.
		 * @method div
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.div = function (other) {
			if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
				if (other._a00 == 0) throw Error('division by zero')
	
				// other == 1: this
				if (other._a00 == 1) {
					this.remainder = new UINT64(0)
					return this
				}
			}
	
			// other > this: 0
			if ( other.gt(this) ) {
				this.remainder = this.clone()
				this._a00 = 0
				this._a16 = 0
				this._a32 = 0
				this._a48 = 0
				return this
			}
			// other == this: 1
			if ( this.eq(other) ) {
				this.remainder = new UINT64(0)
				this._a00 = 1
				this._a16 = 0
				this._a32 = 0
				this._a48 = 0
				return this
			}
	
			// Shift the divisor left until it is higher than the dividend
			var _other = other.clone()
			var i = -1
			while ( !this.lt(_other) ) {
				// High bit can overflow the default 16bits
				// Its ok since we right shift after this loop
				// The overflown bit must be kept though
				_other.shiftLeft(1, true)
				i++
			}
	
			// Set the remainder
			this.remainder = this.clone()
			// Initialize the current result to 0
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			for (; i >= 0; i--) {
				_other.shiftRight(1)
				// If shifted divisor is smaller than the dividend
				// then subtract it from the dividend
				if ( !this.remainder.lt(_other) ) {
					this.remainder.subtract(_other)
					// Update the current result
					if (i >= 48) {
						this._a48 |= 1 << (i - 48)
					} else if (i >= 32) {
						this._a32 |= 1 << (i - 32)
					} else if (i >= 16) {
						this._a16 |= 1 << (i - 16)
					} else {
						this._a00 |= 1 << i
					}
				}
			}
	
			return this
		}
	
		/**
		 * Negate the current _UINT64_
		 * @method negate
		 * @return ThisExpression
		 */
		UINT64.prototype.negate = function () {
			var v = ( ~this._a00 & 0xFFFF ) + 1
			this._a00 = v & 0xFFFF
			v = (~this._a16 & 0xFFFF) + (v >>> 16)
			this._a16 = v & 0xFFFF
			v = (~this._a32 & 0xFFFF) + (v >>> 16)
			this._a32 = v & 0xFFFF
			this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF
	
			return this
		}
	
		/**
	
		 * @method eq
		 * @param {Object} other UINT64
		 * @return {Boolean}
		 */
		UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
			return (this._a48 == other._a48) && (this._a00 == other._a00)
				 && (this._a32 == other._a32) && (this._a16 == other._a16)
		}
	
		/**
		 * Greater than (strict)
		 * @method gt
		 * @param {Object} other UINT64
		 * @return {Boolean}
		 */
		UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
			if (this._a48 > other._a48) return true
			if (this._a48 < other._a48) return false
			if (this._a32 > other._a32) return true
			if (this._a32 < other._a32) return false
			if (this._a16 > other._a16) return true
			if (this._a16 < other._a16) return false
			return this._a00 > other._a00
		}
	
		/**
		 * Less than (strict)
		 * @method lt
		 * @param {Object} other UINT64
		 * @return {Boolean}
		 */
		UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
			if (this._a48 < other._a48) return true
			if (this._a48 > other._a48) return false
			if (this._a32 < other._a32) return true
			if (this._a32 > other._a32) return false
			if (this._a16 < other._a16) return true
			if (this._a16 > other._a16) return false
			return this._a00 < other._a00
		}
	
		/**
		 * Bitwise OR
		 * @method or
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.or = function (other) {
			this._a00 |= other._a00
			this._a16 |= other._a16
			this._a32 |= other._a32
			this._a48 |= other._a48
	
			return this
		}
	
		/**
		 * Bitwise AND
		 * @method and
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.and = function (other) {
			this._a00 &= other._a00
			this._a16 &= other._a16
			this._a32 &= other._a32
			this._a48 &= other._a48
	
			return this
		}
	
		/**
		 * Bitwise XOR
		 * @method xor
		 * @param {Object} other UINT64
		 * @return ThisExpression
		 */
		UINT64.prototype.xor = function (other) {
			this._a00 ^= other._a00
			this._a16 ^= other._a16
			this._a32 ^= other._a32
			this._a48 ^= other._a48
	
			return this
		}
	
		/**
		 * Bitwise NOT
		 * @method not
		 * @return ThisExpression
		 */
		UINT64.prototype.not = function() {
			this._a00 = ~this._a00 & 0xFFFF
			this._a16 = ~this._a16 & 0xFFFF
			this._a32 = ~this._a32 & 0xFFFF
			this._a48 = ~this._a48 & 0xFFFF
	
			return this
		}
	
		/**
		 * Bitwise shift right
		 * @method shiftRight
		 * @param {Number} number of bits to shift
		 * @return ThisExpression
		 */
		UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
			n %= 64
			if (n >= 48) {
				this._a00 = this._a48 >> (n - 48)
				this._a16 = 0
				this._a32 = 0
				this._a48 = 0
			} else if (n >= 32) {
				n -= 32
				this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
				this._a16 = (this._a48 >> n) & 0xFFFF
				this._a32 = 0
				this._a48 = 0
			} else if (n >= 16) {
				n -= 16
				this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
				this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
				this._a32 = (this._a48 >> n) & 0xFFFF
				this._a48 = 0
			} else {
				this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF
				this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
				this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
				this._a48 = (this._a48 >> n) & 0xFFFF
			}
	
			return this
		}
	
		/**
		 * Bitwise shift left
		 * @method shiftLeft
		 * @param {Number} number of bits to shift
		 * @param {Boolean} allow overflow
		 * @return ThisExpression
		 */
		UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
			n %= 64
			if (n >= 48) {
				this._a48 = this._a00 << (n - 48)
				this._a32 = 0
				this._a16 = 0
				this._a00 = 0
			} else if (n >= 32) {
				n -= 32
				this._a48 = (this._a16 << n) | (this._a00 >> (16-n))
				this._a32 = (this._a00 << n) & 0xFFFF
				this._a16 = 0
				this._a00 = 0
			} else if (n >= 16) {
				n -= 16
				this._a48 = (this._a32 << n) | (this._a16 >> (16-n))
				this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
				this._a16 = (this._a00 << n) & 0xFFFF
				this._a00 = 0
			} else {
				this._a48 = (this._a48 << n) | (this._a32 >> (16-n))
				this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF
				this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
				this._a00 = (this._a00 << n) & 0xFFFF
			}
			if (!allowOverflow) {
				this._a48 &= 0xFFFF
			}
	
			return this
		}
	
		/**
		 * Bitwise rotate left
		 * @method rotl
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
			n %= 64
			if (n == 0) return this
			if (n >= 32) {
				// A.B.C.D
				// B.C.D.A rotl(16)
				// C.D.A.B rotl(32)
				var v = this._a00
				this._a00 = this._a32
				this._a32 = v
				v = this._a48
				this._a48 = this._a16
				this._a16 = v
				if (n == 32) return this
				n -= 32
			}
	
			var high = (this._a48 << 16) | this._a32
			var low = (this._a16 << 16) | this._a00
	
			var _high = (high << n) | (low >>> (32 - n))
			var _low = (low << n) | (high >>> (32 - n))
	
			this._a00 = _low & 0xFFFF
			this._a16 = _low >>> 16
			this._a32 = _high & 0xFFFF
			this._a48 = _high >>> 16
	
			return this
		}
	
		/**
		 * Bitwise rotate right
		 * @method rotr
		 * @param {Number} number of bits to rotate
		 * @return ThisExpression
		 */
		UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
			n %= 64
			if (n == 0) return this
			if (n >= 32) {
				// A.B.C.D
				// D.A.B.C rotr(16)
				// C.D.A.B rotr(32)
				var v = this._a00
				this._a00 = this._a32
				this._a32 = v
				v = this._a48
				this._a48 = this._a16
				this._a16 = v
				if (n == 32) return this
				n -= 32
			}
	
			var high = (this._a48 << 16) | this._a32
			var low = (this._a16 << 16) | this._a00
	
			var _high = (high >>> n) | (low << (32 - n))
			var _low = (low >>> n) | (high << (32 - n))
	
			this._a00 = _low & 0xFFFF
			this._a16 = _low >>> 16
			this._a32 = _high & 0xFFFF
			this._a48 = _high >>> 16
	
			return this
		}
	
		/**
		 * Clone the current _UINT64_
		 * @method clone
		 * @return {Object} cloned UINT64
		 */
		UINT64.prototype.clone = function () {
			return new UINT64(this._a00, this._a16, this._a32, this._a48)
		}
	
		if (true) {
			// AMD / RequireJS
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return UINT64
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
		} else if (typeof module != 'undefined' && module.exports) {
			// Node.js
			module.exports = UINT64
		} else {
			// Browser
			root['UINT64'] = UINT64
		}
	
	})(this)


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 十字链表
	 *
	 * 当矩阵的非零个数和位置在操作过程中变化大时，就不宜采用顺序存储结构来表示三元组的线性表。例如，在作“将矩阵B加到矩阵A上”的操作时，由于非零元的插入或删除将会引起A.data中元素的移动。为此，对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。
	 *
	 * 在链表中，每个非零元可用一个含5个域的结点表示，其中i，j和e这3个域分别表示该非零元所在的行，列和非零元的值，向右域right用以链接同一行中下一个非零元，向下域down用以链接同一列中下一个非零元。同一行的非零元通过right域链接成一个线性表，同一列中的非零元通常down域链接成一个线性链表，每一个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表。
	 *
	 * 可用两个分别存储行链表的头指针和列链表的头指针的一维数组来表示。
	 */
	
	// 稀疏矩阵的十字链表存储表示
	var OLNode = function OLNode() {
	    var i = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var j = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var e = arguments[2];
	    (0, _classCallCheck3.default)(this, OLNode);
	
	    // 该非零元的行和列下标
	    this.i = i;
	    this.j = j;
	    this.e = e;
	    // 该非零元所在行表和列表的后继链域
	    this.right = null; // type: OLNode
	    this.down = null; // type: OLNode
	};
	
	var CrossList = function () {
	    function CrossList() {
	        (0, _classCallCheck3.default)(this, CrossList);
	
	        // 行和列链表头指针向量基址由CreateSMatrix分配
	        this.rhead = [];
	        this.chead = [];
	        // 稀疏矩阵的行数，列数
	        this.mu = 0;
	        this.nu = 0;
	        this.tu = 0;
	    }
	
	    /**
	     * 矩阵初始化
	     * @param m
	     * @param n
	     * @param t
	     * @param {Array} list 二维数组，每行的元素分别是[i, j, e]
	     */
	
	
	    CrossList.prototype.createSMatrix = function createSMatrix(m, n, t, list) {
	        this.mu = m;
	        this.nu = n;
	        this.tu = t;
	
	        for (var row = 0; row < list.length; row++) {
	            var p = new (Function.prototype.bind.apply(OLNode, [null].concat(list[row])))();
	            var _list$row = list[row];
	            var i = _list$row[0];
	            var j = _list$row[1];
	
	            var q = void 0;
	
	            if (this.rhead[i] == null || this.rhead[i].j > j) {
	                p.right = this.rhead[i];
	                this.rhead[i] = p;
	            } else {
	                // 查询在行表中的插入位置
	                for (q = this.rhead[i]; q.right && q.right.j < j; q = q.right) {}
	                p.right = q.right;
	                q.right = p;
	            }
	
	            if (this.chead[j] == null || this.chead[j].i > i) {
	                p.down = this.chead[j];
	                this.chead[j] = p;
	            } else {
	                for (q = this.chead[j]; q.down && q.down.i < i; q = q.down) {}
	                p.down = q.down;
	                q.down = p;
	            }
	        }
	    };
	
	    // 矩阵相加
	
	
	    CrossList.prototype.addMatrix = function addMatrix(crossList) {
	        var hl = [];
	        //hl初始化
	        for (var j = 0; j <= this.nu; j++) {
	            hl[j] = this.chead[j];
	        }for (var i = 0; i <= this.mu; i++) {
	            //pa和pb指向每一行的第一个非0元结点，直至最后一行
	            var pa = this.rhead[i];
	            var pb = crossList.rhead[i];
	            var pre = null;
	
	            //处理B的一行，直至本行中无非0元素的结点
	            while (pb) {
	                var p = void 0,
	                    q = void 0;
	                // 新插入一个结点到pa的左侧
	                if (!pa || pa.j > pb.j) {
	                    p = new OLNode(pb.i, pb.j, pb.e);
	
	                    //行表的指针变化
	                    if (!pre) this.rhead[p.i] = p;else pre.right = p;
	
	                    p.right = pa;
	                    pre = p;
	
	                    //列表的指针变化
	                    if (hl[p.j]) {
	                        // 从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                        for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                            hl[p.j] = q;
	                        }
	                    }
	
	                    //在列表中插入新结点，根据行数判断插入前面还是后面
	                    if (!this.chead[p.j] || this.chead[p.j].i > p.i) {
	                        p.down = this.chead[p.j];
	                        this.chead[p.j] = p;
	                    } else {
	                        p.down = hl[p.j].down;
	                        hl[p.j].down = p;
	                    }
	
	                    hl[p.j] = p;
	                    pb = pb.right;
	                } else if (pa.j < pb.j) {
	                    pre = pa;
	                    pa = pa.right;
	                } else {
	                    //当pa.j === pb.j时，将B中当前结点的值加到A中当前结点上
	                    pa.e += pb.e;
	
	                    //当pa.e === 0时，删除该结点
	                    if (pa.e === 0) {
	                        // 若无前驱结点，将第一个非0元结点置为当前结点的后继结点，
	                        // 否则前驱结点的后继结点为当前结点的后继结点
	                        if (!pre) this.rhead[pa.i] = pa.right;else pre.right = pa.right;
	
	                        p = pa;
	                        pa = pa.right;
	
	                        //列表的指针变化
	                        if (hl[p.j]) {
	                            //从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                            for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                hl[p.j] = q;
	                            }
	                        }
	
	                        if (this.chead[p.j] == p) this.chead[p.j] = hl[p.j] = p.down;else hl[p.j].down = p.down;
	                    }
	
	                    pb = pb.right;
	                }
	            }
	        }
	    };
	
	    return CrossList;
	}();
	
	exports.default = CrossList;
	
	
	var lists = [[1, 4, 5], [2, 2, -1], [1, 1, 3], [3, 1, 2]];
	var a = new CrossList();
	a.createSMatrix(4, 4, 4, lists);
	console.log(a);
	
	var lists2 = [[1, 4, -5], [2, 3, 1], [1, 1, 3], [3, 2, 2]];
	var b = new CrossList();
	b.createSMatrix(4, 4, 4, lists2);
	console.log(b);
	
	a.addMatrix(b);
	console.log(a);

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.RLSMatrix = exports.TSMatrix = undefined;
	
	var _possibleConstructorReturn2 = __webpack_require__(19);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(18);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 系数矩阵的三元组顺序表存储表示
	 */
	
	var Triple = function Triple(i, j, elem) {
	    (0, _classCallCheck3.default)(this, Triple);
	
	    // 该非零元的行下标和列下标
	    this.i = i || 0;
	    this.j = j || 0;
	    this.e = elem || null;
	};
	
	var TSMatrix = exports.TSMatrix = function () {
	    function TSMatrix(mu, nu) {
	        (0, _classCallCheck3.default)(this, TSMatrix);
	
	        // 非零元三元组表
	        this.data = [];
	        // 矩阵的行数，列数
	        this.mu = mu || 0;
	        this.nu = nu || 0;
	    }
	
	    TSMatrix.prototype.addTriple = function addTriple(triple) {
	        if (triple instanceof Triple) {
	            if (triple.i >= this.mu) this.mu = triple.i + 1;
	            if (triple.j >= this.nu) this.nu = triple.j + 1;
	
	            this.data.push(triple);
	            return true;
	        }
	        return false;
	    };
	    // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	    // 按照b.data中三元组的次序依次在a.data中找到相应的三元组进行转置
	
	
	    TSMatrix.prototype.transposeSMatrix = function transposeSMatrix() {
	        var t = new TSMatrix();
	        t.mu = this.nu;
	        t.nu = this.mu;
	
	        if (this.data.length) {
	            var q = 0;
	            for (var col = 0; col < this.nu; col++) {
	                for (var p = 0; p < this.data.length; p++) {
	                    if (this.data[p].j === col) t.data[q++] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                }
	            }
	        }
	
	        return t;
	    };
	    // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	    /*
	     按照a.data中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置。
	     如果能预先确定矩阵M中每一列（即T中每一行）的第一个非零元在b.data中应有的位置，
	     那么在对a.data中的三元组依次做转置时，便可直接放到b.data中恰当的位置上去。
	     为了其额定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在b.data中应有的位置。
	     在此，需要设num和cpot两个变量。num[col]表示矩阵M中第col列中非零元的个数，
	     cpot[col]指示M中第col列的第一个非零元在b.data中的恰当位置。显然有：
	     cpot[0] = 1;
	     cpot[col] = cpot[col - 1] + num[col - 1]    2 <= col <= a.nu
	     */
	
	
	    TSMatrix.prototype.fastTransposeSMatrix = function fastTransposeSMatrix() {
	        var t = new TSMatrix();
	        t.mu = this.nu;
	        t.nu = this.mu;
	
	        if (this.data.length) {
	            var num = [];
	            for (var col = 0; col < this.nu; col++) {
	                num[col] = 0;
	            }for (var i = 0; i < this.data.length; i++) {
	                ++num[this.data[i].j];
	            } // 求矩阵中每一列含非零元个数
	            // 求第col列中第一个非零元在b.data中的序号
	            var cpot = [0];
	            for (var _col = 1; _col < this.nu; _col++) {
	                // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                cpot[_col] = cpot[_col - 1] + num[_col - 1];
	            }for (var p = 0; p < this.data.length; p++) {
	                var _col2 = this.data[p].j;
	                var q = cpot[_col2];
	                t.data[q] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                // 给该列的序号+1，用作相同列数的情况
	                ++cpot[_col2];
	            }
	        }
	
	        return t;
	    };
	
	    return TSMatrix;
	}();
	
	var a1 = new Triple(1, 2, 12);
	var a2 = new Triple(1, 3, 9);
	var a3 = new Triple(3, 1, -3);
	var a4 = new Triple(3, 6, 14);
	var a5 = new Triple(4, 3, 24);
	var a6 = new Triple(5, 2, 18);
	var a7 = new Triple(6, 1, 15);
	var a8 = new Triple(6, 4, -7);
	
	var matrix = new TSMatrix();
	matrix.addTriple(a1);
	matrix.addTriple(a2);
	matrix.addTriple(a3);
	matrix.addTriple(a4);
	matrix.addTriple(a5);
	matrix.addTriple(a6);
	matrix.addTriple(a7);
	matrix.addTriple(a8);
	
	console.log(matrix.transposeSMatrix());
	console.log(matrix.fastTransposeSMatrix());
	
	/*
	 三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。
	 然而，若需按行号存取某一行的非零元，则从头开始进行查找。
	 */
	
	/**
	 * 行逻辑链接的顺序表
	 *
	 * 为了便于随机存取任意一行的非零元，则需知道每一行的第一个非零元在三元组表中的位置。
	 * 为此可将快速转置矩阵的算法中创建的，指示“行”信息的辅助数组cpot固定在稀疏矩阵的存储结构中。
	 * 称这种“带行链接信息”的三元组表为行逻辑链接的顺序表
	 */
	
	var RLSMatrix = exports.RLSMatrix = function (_TSMatrix) {
	    (0, _inherits3.default)(RLSMatrix, _TSMatrix);
	
	    function RLSMatrix() {
	        (0, _classCallCheck3.default)(this, RLSMatrix);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, _TSMatrix.apply(this, arguments));
	
	        _this.rpos = [0];
	        return _this;
	    }
	    /**
	     * 求矩阵乘积Q = M * N，采用行逻辑链接存储表示
	     * @param nMatrix
	     * @returns {RLSMatrix}
	     */
	
	
	    RLSMatrix.prototype.multSMatrix = function multSMatrix(nMatrix) {
	        if (this.nu !== nMatrix.mu) throw Error('nu is not equivalent to mu');
	
	        // 初始化Q
	        var qMatrix = new RLSMatrix(this.mu, nMatrix.nu);
	        // Q是非零矩阵
	        if (this.data.length * nMatrix.data.length !== 0) {
	            // 处理M的每一行
	            for (var arow = 0; arow < this.mu; arow++) {
	                // 当前行各元素累加器清零
	                var ctemp = [];
	                qMatrix.rpos[arow] = qMatrix.data.length + 1;
	                var tp = void 0,
	                    ccol = void 0;
	
	                if (arow < this.mu) tp = this.rpos[arow + 1];else tp = this.data.length + 1;
	
	                //对当前行中每一个非零元找到对应元在N中的行号
	                for (var p = this.rpos[arow]; p < tp; p++) {
	                    var brow = this.data[p].j;
	                    var t = void 0;
	                    if (brow < nMatrix.mu) t = nMatrix.rpos[brow + 1];else t = nMatrix.data.length + 1;
	
	                    for (var q = nMatrix.rpos[brow]; q < t; q++) {
	                        // 乘积元素在Q中的序号
	                        ccol = nMatrix.data[q].j;
	                        ctemp[ccol] = (ctemp[ccol] || 0) + this.data[p].e * nMatrix.data[q].e;
	                    }
	                }
	
	                // 压缩存储该行非零元
	                for (ccol = 1; ccol < qMatrix.nu; ccol++) {
	                    if (ctemp[ccol]) {
	                        if (++qMatrix.data.length > RLSMatrix.MAXSIZE) throw Error('overflow');
	                        qMatrix.data[qMatrix.data.length - 1] = new Triple(arow, ccol, ctemp[ccol]);
	                    }
	                }
	            }
	        }
	
	        return qMatrix;
	    };
	
	    RLSMatrix.prototype._calcPos = function _calcPos() {
	        var num = [];
	        for (var col = 0; col < this.nu; col++) {
	            num[col] = 0;
	        }for (var i = 0; i < this.data.length; i++) {
	            ++num[this.data[i].j];
	        } // 求矩阵中每一列含非零元个数
	        // 求第col列中第一个非零元在b.data中的序号
	        for (var _col3 = 1; _col3 < this.nu; _col3++) {
	            // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	            this.rpos[_col3] = this.rpos[_col3 - 1] + num[_col3 - 1];
	        }
	    };
	
	    return RLSMatrix;
	}(TSMatrix);
	
	RLSMatrix.MAXSIZE = 100;
	
	var b1 = new Triple(1, 1, 3);
	var b2 = new Triple(1, 3, 5);
	var b3 = new Triple(2, 2, -1);
	var b4 = new Triple(3, 1, 2);
	
	var t1 = new RLSMatrix();
	t1.addTriple(b1);
	t1.addTriple(b2);
	t1.addTriple(b3);
	t1.addTriple(b4);
	t1._calcPos();
	
	var c1 = new Triple(1, 2, 2);
	var c2 = new Triple(2, 1, 1);
	var c3 = new Triple(3, 1, -2);
	var c4 = new Triple(3, 2, 4);
	
	var t2 = new RLSMatrix();
	t2.addTriple(c1);
	t2.addTriple(c2);
	t2.addTriple(c3);
	t2.addTriple(c4);
	t2._calcPos();
	
	t1.multSMatrix(t2);

/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = huffManCoding;
	/**
	 * 赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树，有着广泛应用。
	 *
	 * 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
	 * 树的路径长度是从树根到每一个结点的路径之和。
	 * 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。
	 *
	 * 构造赫夫曼树的步骤：
	 * （1）根据给定的n个权值{w1,w2,...wn}构成n棵二叉树的集合F = {T1,T2,...Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
	 * （2）在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
	 * （3）在F中删除这两棵树，同时将新得到的二叉树加入F中。
	 * （4）重复（2）和（3），直到F只含一棵树为止。这棵树便是赫夫曼树。
	 */
	/*
	赫夫曼编码
	http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81
	
	假设电报需传送的电文为“A B A C C D A”，它只有4种字符只需两个字符串便可分辨。假设A,B,C,D的编码分别为00,01,10和11，则上述7个字符的电文便为“00010010101100”，对方接收时，可按二位一分进行译码。
	在传送电文时，希望总长尽可能地短。如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便可减少。
	如果涉及A,B,C,D的编码分别为0,00,1和01，则上述7个字符的电文可转换成总长为9的字符串“000011010”。但是，这样的电文无法翻译，因为可有多种译法。
	因此，若要设计长短不等的编码，则必须是任意个字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码。
	可利用二叉树来设计二进制的前缀编码。假设有一棵二叉树，其4个叶子结点分别表示A,B,C,D这4个字符，且约定左分支表示字符“0”，右分支表示字符“1”，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。所得二进制前缀编码分别为0,10,110,111.
	设计电文总长最短的二进制前缀编码即以n种字符出现的频率作权。
	 */
	
	// 赫夫曼树和赫夫曼编码的存储结构
	function HuffmanNode(weight, parent, leftChild, rightChild) {
	    this.weight = weight || 0;
	    this.parent = parent || 0;
	    this.leftChild = leftChild || 0;
	    this.rightChild = rightChild || 0;
	}
	function huffManCoding(weights) {
	    var n = weights.length;
	    if (n < 1) return;
	
	    var huffmanTree = buildHuffmanTree(weights, n);
	
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = calcHuffmanCode(huffmanTree, n);
	
	    return [huffmanTree, hc];
	}
	
	function calcHuffmanCode(huffmanTree, n) {
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = [];
	    var cd = [];
	    for (var i = 0; i < n; i++) {
	        var start = n - 1;
	        for (var c = i, f = huffmanTree[i].parent; f != 0; c = f, f = huffmanTree[f].parent) {
	            if (huffmanTree[f].leftChild == c) cd[--start] = '0';else cd[--start] = '1';
	        }
	
	        hc[i] = strCopy(cd, start);
	    }
	
	    return hc;
	}
	
	// 创建一棵叶子结点数为n的Huffman树
	function buildHuffmanTree(weights, n) {
	    n = n || weights.length;
	    var m = 2 * n - 1;
	    var huffmanTree = [];
	
	    // 初始化
	    var i = void 0;
	    for (i = 0; i < n; i++) {
	        huffmanTree[i] = new HuffmanNode(weights[i], 0, 0, 0);
	    }for (; i < m; i++) {
	        huffmanTree[i] = new HuffmanNode(0, 0, 0, 0);
	    }for (var _i = n; _i < m; _i++) {
	        // 在HT[1..i-1]选择parent为0且weight最小的两个结点，返回其序号为[s1, s2]
	        var ret = select(huffmanTree, _i);
	        var s1 = ret[0];
	        var s2 = ret[1];
	        huffmanTree[s1].parent = _i;
	        huffmanTree[s2].parent = _i;
	        huffmanTree[_i].leftChild = s1;
	        huffmanTree[_i].rightChild = s2;
	        huffmanTree[_i].weight = huffmanTree[s1].weight + huffmanTree[s2].weight;
	    }
	
	    return huffmanTree;
	}
	
	function strCopy(str, start) {
	    var s = '';
	    for (; str[start]; start++) {
	        s += str[start];
	    }
	    return s;
	}
	
	function select(huffmanTree, len) {
	    var ret = [];
	    for (var i = 0; i < len; i++) {
	        var node = huffmanTree[i];
	        if (node.parent !== 0) continue;
	
	        if (ret.length < 2) {
	            ret.push(i);
	        } else {
	            var index = huffmanTree[ret[0]].weight > huffmanTree[ret[1]].weight ? 0 : 1;
	
	            if (node.weight < huffmanTree[ret[index]].weight) ret[index] = i;
	        }
	    }
	
	    if (ret[0] > ret[1]) {
	        var temp = ret[0];
	        ret[0] = ret[1];
	        ret[1] = temp;
	    }
	
	    return ret;
	}
	
	console.log('-------huffman coding 1:------');
	console.log(huffManCoding([5, 29, 7, 8, 14, 23, 3, 11]));

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 广义表
	 *
	 * 广义表是线性表的推广。广泛用于人工智能的表处理语言Lisp，把广义表作为基本的数据结构。
	 * 广义表一般记作：
	 *      LS = (a1, a2, ..., an)
	 * LS是广义表的名称，n是它的长度，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头，称其余元素组成的表(a2, a3, ..., an)是LS的表尾。
	 *
	 * 下面列举一些广义表的例子：
	 * 1.A = () ---- A是一个空表，它的长度为0。
	 * 2.B = (e) ---- 列表B只有一个原子e，B的长度为1。
	 * 3.C = (a, (b, c, d)) ---- 列表C的长度为2，两个元素分别为原子a和子表(b, c, d)。
	 * 4.D = (A, B, C) ---- 列表D的长度为3,3个元素都是列表。显示，将子表的值代入后，则有D = ((), (e), (a, (b, c, d)))。
	 * 5.E = (a, E) ---- 这是一个递归的表，它的长度为2.E相当于一个无限的列表E = (a, (a, (a, ...)))。
	 *
	 * 1）列表的元素可以是子表，而子表的元素还可以是子表。由此，列表是一个多层次的结构，可以用图形象地表示。
	 * 2)列表可为其它列表所共享。列表A，B和C为D的子表，则在D中可以不必列出子表的值。
	 * 3）列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如列表E。
	 *
	 * 任何一个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。
	 *
	 */
	
	/*
	 广义表的递归算法
	
	 递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。
	
	 由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，应注意：
	 （1）首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的字问题，只要接口一致，便可进行递归调用。
	 （2）对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。
	 */
	
	/*
	 求广义表的深度
	
	 广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。
	 设非空广义表为:
	 LS = (a1, a2, ..., an)
	
	 其中ai(i = 1, 2, ..., n)或为原子或为LS的子表，则求LS的深度可分解为n个子问题，每个子问题为求ai的深度，若ai是原子，则由定义其深度为零，若ai是广义表，则递归处理，而LS的深度为各ai(i = 1, 2, ..., n)的深度最大值加1.空表也是广义表，且深度为1.
	
	 广义表的深度DEPTH(LS)的递归定义为：
	 基本项：    DEPTH(LS) = 1   当LS为空表时
	 DEPTH(LS) = 0   当LS为原子时
	 归纳项：    DEPTH(LS) = 1 + MAX{DEPTH(ai)}  1 <= i <= n
	 */
	
	var ATOM = Symbol();
	var LIST = Symbol();
	
	var global = Function('return this')();
	// 使用链队列
	
	// 广义表的头尾链表存储表示
	var GLNode = function () {
	    function GLNode() {
	        (0, _classCallCheck3.default)(this, GLNode);
	
	        // 公共部分，用于区分原子结点和表结点
	        this.tag = undefined;
	
	        // atom是原子结点的值域
	        this.atom = null;
	        // ptr是表结点的指针域
	        this.ptr = {
	            // ptr.hp和ptr.tp分别指向表头和表尾
	            hp: null,
	            tp: null
	        };
	    }
	
	    // 采用头尾链表存储结构，求广义表的深度
	
	
	    GLNode.prototype.depth = function depth() {
	        return getDepth(this);
	    };
	
	    // 复制广义表
	
	
	    GLNode.prototype.copyList = function copyList(gList) {
	        gList.tag = this.tag;
	
	        if (this.tag === ATOM) {
	            gList.atom = this.atom;
	        } else {
	            if (this.ptr.hp) {
	                gList.ptr.hp = new GLNode();
	                this.ptr.hp.copyList(gList.ptr.hp);
	            }
	            if (this.ptr.tp) {
	                gList.ptr.tp = new GLNode();
	                this.ptr.tp.copyList(gList.ptr.tp);
	            }
	        }
	    };
	
	    // 采用头尾链表存储结构，由广义表的书写形式串创建广义表
	
	
	    GLNode.prototype.createGList = function createGList(string) {
	        string = string.trim();
	
	        // 创建单原子广义表
	        var q = void 0;
	        if (isWord(string)) {
	            this.tag = ATOM;
	            this.atom = string;
	        } else {
	            this.tag = LIST;
	            var p = this;
	
	            // 脱外层括号
	            var sub = string.substr(1, string.length - 2);
	
	            do {
	                var hsub = void 0;
	                var n = sub.length;
	                var i = 0;
	                var k = 0;
	                var ch = void 0;
	
	                do {
	                    ch = sub[i++];
	                    if (ch == '(') ++k;else if (ch == ')') --k;
	                } while (i < n && (ch != ',' || k != 0));
	
	                // i为第一个逗号分隔索引
	                if (i < n) {
	                    hsub = sub.substr(0, i - 1);
	                    sub = sub.substr(i, n - i);
	
	                    // 最后一组
	                } else {
	                    hsub = sub;
	                    sub = '';
	                }
	
	                if (hsub === '()') p.ptr.hp = null;
	                // 创建表头结点
	                else {
	                        p.ptr.hp = new GLNode();
	                        p.ptr.hp.createGList(hsub);
	                    }
	
	                q = p;
	
	                // 创建表尾结点
	                if (sub) {
	                    p = new GLNode();
	                    p.tag = LIST;
	                    q.ptr.tp = p;
	                }
	            } while (sub);
	
	            q.ptr.tp = null;
	        }
	    };
	
	    GLNode.equal = function equal(gList1, gList2) {
	        // 空表时相等的
	        if (!gList1 && !gList2) return true;
	        if (gList1.tag === ATOM && gList2.tag === ATOM && gList1.atom === gList2.atom) return true;
	
	        if (gList1.tag === LIST && gList2.tag === LIST) {
	            // 表头表尾都相等
	            if (this.equal(gList1.ptr.hp, gList2.ptr.hp) && this.equal(gList1.ptr.tp, gList2.ptr.tp)) return true;
	        }
	
	        return false;
	    };
	
	    // 递归逆转广义表
	
	
	    GLNode.prototype.reverse = function reverse() {
	        var ptr = [];
	        // 当A不为原子且表尾非空时才需逆转
	        if (this.tag === LIST && this.ptr.tp) {
	            var i = 0;
	            for (var p = this; p; p = p.ptr.tp, i++) {
	                // 逆转各子表
	                if (p.ptr.hp) p.ptr.hp.reverse();
	
	                ptr[i] = p.ptr.hp;
	            }
	
	            // 重新按逆序排列各子表的顺序
	            for (var _p = this; _p; _p = _p.ptr.tp) {
	                _p.ptr.hp = ptr[--i];
	            }
	        }
	    };
	
	    GLNode.prototype.toString = function toString() {
	        var str = '';
	        if (this == global || this == null) str = '()';else if (this.tag === ATOM) str = this.atom; // 原子
	        else {
	                str += '(';
	
	                for (var p = this; p; p = p.ptr.tp) {
	                    str += this.toString.call(p.ptr.hp);
	                    if (p.ptr.tp) str += ', ';
	                }
	                str += ')';
	            }
	
	        return str;
	    };
	
	    // 按层序输出广义表
	    // 层序遍历的问题，一般都是借助队列来完成的，每次从队头
	    // 取出一个元素的同时把它下一层的孩子插入队尾，这是层序遍历的基本思想
	
	
	    GLNode.prototype.orderPrint = function orderPrint() {
	        var queue = [];
	        for (var p = this; p; p = p.ptr.tp) {
	            queue.push(p);
	        }while (queue.length) {
	            var r = queue.shift();
	            if (r.tag === ATOM) console.log(r.atom);else {
	                for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                    queue.push(r);
	                }
	            }
	        }
	    };
	
	    GLNode.prototype.orderPrint2 = function orderPrint2() {
	        var queue = new _Queue2.default();
	
	        for (var p = this; p; p = p.ptr.tp) {
	            queue.enQueue(p);
	        }while (queue.size) {
	            var r = queue.deQueue();
	            if (r.tag === ATOM) console.log(r.atom);else {
	                for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                    queue.enQueue(r);
	                }
	            }
	        }
	    };
	
	    return GLNode;
	}();
	
	// 广义表的扩展线性链表存储表示
	
	
	exports.default = GLNode;
	
	var GLNode2 = function GLNode2() {
	    (0, _classCallCheck3.default)(this, GLNode2);
	
	    // 公共部分，用于区分原子结点和表结点
	    this.tag = undefined;
	
	    // 原子结点的值域
	    this.atom = null;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性链表的next，指向下一个元素结点
	    this.tp = null;
	};
	
	function getDepth(gList) {
	    if (!gList) return 1;else if (gList.tag === ATOM) return 0;
	
	    var m = getDepth(gList.ptr.hp) + 1;
	    var n = getDepth(gList.ptr.tp);
	
	    return m > n ? m : n;
	}
	
	function isWord(str) {
	    return (/^[\w-]+$/.test(str)
	    );
	}
	
	/*
	 m元多项式表示
	
	 如果用线性表来表示,则每个数据元素需要m+1个数据项，以存储一个系数和m个指数值，这将产生两个问题。
	 一是无论多项式中各项的变元数是多是少，若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便。二是对m值不同的多项式，线性表中的结点大小也不同，这同样引起存储管理的不便。
	 故不适于用线性表表示。
	
	 例如三元多项式：
	 P(x, y, z) = x(10)y(3)z(2) + 2x(6)y(3)z(2) + 3x(5)y(2)z(2) + x(4)y(4)z + 2yz + 15
	
	 如若改写为：
	 P(x, y, z) = ((x(10) + 2x(6))y(3) + 3x(5)y(2))z(2) + ((x(4) + 6x(3))y(4) + 2y)z + 15
	
	 用广义表表示：
	 P = z((A, 2), (B, 1), (15, 0))
	 A = y((C, 3), (D, 2))
	 B = y((E, 4), (F, 1))
	 C = x((1, 10), (2, 6))
	 D = x((3, 5))
	 E = x((1, 4), (6, 3))
	 F = x((2, 0))
	
	
	 */
	
	function MPNode() {
	    // 区分原子结点和表结点
	    this.tag = undefined;
	    // 指数域
	    this.exp = 0;
	
	    // 系数域
	    this.coef = 0;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性表的next，指向下一个元素结点
	    this.tp = null;
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 邻接多重表
	
	 邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。
	
	 邻接表是无向图的一种有效的存储结构，在无向图的邻接表中，一条边(v,w)的两个表结点分别初选在以v和w为头结点的链表中，很容易求得顶点和边的信息，但在涉及到边的操作会带来不便。
	
	 邻接多重表的结构和十字链表类似，每条边用一个结点表示；邻接多重表中的顶点结点结构与邻接表中的完全相同，而表结点包括六个域。
	
	 ◆  Data域：存储和顶点相关的信息；
	 ◆ 指针域firstedge：指向依附于该顶点的第一条边所对应的表结点；
	 ◆ 标志域mark：用以标识该条边是否被访问过；
	 ◆ ivex和jvex域：分别保存该边所依附的两个顶点在图中的位置；
	 ◆ info域：保存该边的相关信息；
	 ◆ 指针域ilink：指向下一条依附于顶点ivex的边；
	 ◆ 指针域jlink：指向下一条依附于顶点jvex的边；
	
	 邻接多重表与邻接表的区别：
	 后者的同一条边用两个表结点表示，而前者只用一个表结点表示；除标志域外，邻接多重表与邻接表表达的信息是相同的，因此，操作的实现也基本相似。
	
	 */
	
	var UNVISITED = 0;
	var VISITED = 1;
	
	var EBox =
	/**
	 * 边的结点表示
	 * @param {Number} mark 访问标记 0 -- 未访问  1 == 已访问
	 * @param {Number} ivex 该边依附的两个顶点的位置
	 * @param {Number} jvex 该边依附的两个顶点的位置
	 * @param {EBox} ilink 分别指向依附这两个顶点的下一条边
	 * @param {EBox} jlink 分别指向依附这两个顶点的下一条边
	 * @param {*} info 该边信息
	 * @constructor
	 */
	function EBox(mark, ivex, jvex, ilink, jlink, info) {
	    (0, _classCallCheck3.default)(this, EBox);
	
	    this.mark = mark || UNVISITED;
	    this.ivex = ivex || 0;
	    this.jvex = jvex || 0;
	    this.ilink = ilink || null;
	    this.jlink = jlink || null;
	    this.info = info || null;
	};
	
	var AMLVexBox =
	/**
	 * 顶点的结点表示
	 * @param {*} data
	 * @param {EBox} firstEdge 指向第一条依附该顶点的边
	 * @constructor
	 */
	function AMLVexBox(data, firstEdge) {
	    (0, _classCallCheck3.default)(this, AMLVexBox);
	
	    this.data = data || null;
	    this.firstEdge = firstEdge || null;
	};
	
	var AMLGraph = function () {
	    /**
	     *
	     * @param {Array | AMLVexBox} adjMulist
	     * @param {Number} vexnum
	     * @param {Number} edgenum
	     * @constructor
	     */
	    function AMLGraph(adjMulist, vexnum, edgenum) {
	        (0, _classCallCheck3.default)(this, AMLGraph);
	
	        this.adjMulist = adjMulist || [];
	        this.vexnum = vexnum || 0;
	        this.edgenum = edgenum || 0;
	    }
	
	    AMLGraph.prototype.locateVex = function locateVex(v) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.adjMulist[i].data === v) return i;
	        }
	        return -1;
	    };
	
	    AMLGraph.prototype.deleteArc = function deleteArc(v, w) {
	        var i = this.locateVex(v);
	        var j = this.locateVex(w);
	
	        if (i < 0 || j < 0) throw new Error('Vertex not found!');
	
	        var p;
	        // 在i链表中删除该边
	        if (this.adjMulist[i].firstEdge.jvex === j) {
	            this.adjMulist[i].firstEdge = this.adjMulist[i].firstEdge.ilink;
	        } else {
	            for (p = this.adjMulist[i].firstEdge; p && p.ilink.jvex !== j; p = p.ilink) {}
	            if (!p) throw new Error('edge not found!');
	            p.ilink = p.ilink.ilink;
	        }
	
	        // 在j链表中删除该边
	        if (this.adjMulist[j].firstEdge.ivex === i) {
	            this.adjMulist[j].firstEdge = this.adjMulist[j].firstEdge.jlink;
	        } else {
	            for (p = this.adjMulist[j].firstEdge; p && p.jlink.ivex !== i; p = p.jlink) {}
	            if (!p) throw new Error('edge not found!');
	            p.jlink = p.jlink.jlink;
	        }
	
	        this.edgenum--;
	        return true;
	    };
	
	    AMLGraph.prototype.createGraph = function createGraph() {
	        var vexnum = +prompt('vexnum: ');
	        this.vexnum = vexnum;
	        var edgenum = +prompt('edgenum: ');
	        this.edgenum = edgenum;
	
	        for (var m = 0; m < vexnum; ++m) {
	            this.adjMulist[m] = new AMLVexBox(prompt('data: '), null);
	        }
	
	        for (m = 0; m < edgenum; ++m) {
	            var t = prompt('tailVex: ');
	            var h = prompt('headVex: ');
	            var i = this.locateVex(t);
	            var j = this.locateVex(h);
	
	            if (i < 0 || j < 0) {
	                console.error('vertex not found! Try again:');
	                m--;
	                continue;
	            }
	
	            var p = new EBox(0, i, j, null, null);
	            var q, r;
	
	            // 插入i链表尾部
	            if (!this.adjMulist[i].firstEdge) {
	                this.adjMulist[i].firstEdge = p;
	            } else {
	                q = this.adjMulist[i].firstEdge;
	                while (q) {
	                    r = q;
	                    if (q.ivex === i) q = q.ilink;else q = q.jlink;
	                }
	                if (r.ivex === i) r.ilink = p;else r.jlink = p;
	            }
	
	            // 插入j链表尾部
	            if (!this.adjMulist[j].firstEdge) {
	                this.adjMulist[j].firstEdge = p;
	            } else {
	                q = this.adjMulist[j].firstEdge;
	                while (q) {
	                    r = q;
	                    if (q.jvex === j) q = q.jlink;else q = q.ilink;
	                }
	                if (r.jvex === j) r.jlink = p;else r.ilink = p;
	            }
	        }
	    };
	
	    return AMLGraph;
	}();
	
	//var g = new AMLGraph();
	//g.createGraph();
	//console.log(g);
	
	
	exports.default = AMLGraph;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(17);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(16);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* Create By Luke */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	
	/*
	 邻接链表法
	
	 基本思想：对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。
	
	 第i个单链表表示依附于顶点Vi的边(对有向图是以顶点Vi为头或尾的弧)。
	
	 1  结点结构与邻接链表示例
	
	 链表中的结点称为表结点，每个结点由三个域组成。其中邻接点域(adjvex)指示与顶点Vi邻接的顶点在图中的位置(顶点编号)，链域(nextarc)指向下一个与顶点Vi邻接的表结点，数据域(info)存储和边或弧相关的信息，如权值等。对于无权图，如果没有与边相关的其他信息，可省略此域。
	
	 每个链表设一个表头结点(称为顶点结点)，由两个域组成。链域(firstarc)指向链表中的第一个结点，数据域(data) 存储顶点名或其他信息。
	
	 在图的邻接链表表示中，所有顶点结点用一个向量 以顺序结构形式存储，可以随机访问任意顶点的链表，该向量称为表头向量，向量的下标指示顶点的序号。
	
	 用邻接链表存储图时，对无向图，其邻接链表是唯一的；对有向图，其邻接链表有两种形式。
	
	
	 2  邻接表法的特点
	
	 ◆ 表头向量中每个分量就是一个单链表的头结点，分量个数就是图中的顶点数目；
	 ◆ 在边或弧稀疏的条件下，用邻接表表示比用邻接矩阵表示节省存储空间；
	 ◆ 在无向图，顶点Vi的度是第i个链表的结点数；
	 ◆ 对有向图可以建立正邻接表或逆邻接表。正邻接表是以顶点Vi为出度(即为弧的起点)而建立的邻接表；逆邻接表是以顶点Vi为入度(即为弧的终点)而建立的邻接表；
	 ◆ 在有向图中，第i个链表中的结点数是顶点Vi的出 (或入)度；求入 (或出)度，须遍历整个邻接表；
	 ◆ 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点；
	
	 */
	
	var ArcNode =
	/**
	 *
	 * @param {Number} adjVex
	 * @param {ArcNode} nextArc
	 * @param {*} info
	 * @constructor
	 */
	function ArcNode() {
	    var adjVex = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var nextArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, ArcNode);
	
	    // 该弧所指向的顶点的位置
	    this.adjVex = adjVex;
	    // 指向下一条弧的指针
	    this.nextArc = nextArc;
	    // 该弧相关信息的指针
	    this.info = info;
	};
	
	var VexNode =
	/**
	 *
	 * @param {*} data
	 * @param {ArcNode} firstArc
	 * @param {Number} indegree
	 * @constructor
	 */
	function VexNode(data) {
	    var firstArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var indegree = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    (0, _classCallCheck3.default)(this, VexNode);
	
	    // 顶点信息
	    this.data = data;
	    // 指向第一条依附该顶点的弧的指针
	    this.firstArc = firstArc;
	    //  顶点的度, 有向图是入度或出度或没有
	    this.indegree = indegree;
	};
	
	var AdjacencyListGraph = function () {
	    /**
	     *
	     * @param {Array | VexNode} vertices
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	    function AdjacencyListGraph() {
	        var vertices = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var vexnum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var arcnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var kind = arguments.length <= 3 || arguments[3] === undefined ? DG : arguments[3];
	        (0, _classCallCheck3.default)(this, AdjacencyListGraph);
	
	        this.vertices = vertices;
	        // 图的当前顶点数和弧数
	        this.vexnum = vexnum;
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    // 查找顶点位置
	
	
	    AdjacencyListGraph.prototype.locateVex = function locateVex(vp) {
	        for (var _i = 0; _i < this.vexnum; ++_i) {
	            if (this.vertices[_i].data === vp) return _i;
	        }
	
	        return -1;
	    };
	
	    // 添加顶点
	
	
	    AdjacencyListGraph.prototype.addVertex = function addVertex(vp) {
	        if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	        this.vertices[this.vexnum++] = new VexNode(vp, null, 0);
	        return this.vexnum;
	    };
	
	    /**
	     * 添加弧
	     * 如果是无向图或者无向网,arc1和arc2无顺序要求
	     * 如果是有向图或者有向网，只会添加arc1，因此正邻接表和逆邻接表的顺序需要注意
	     * @param {String} arc1
	     * @param {String} arc2
	     * @param {*} info
	     * @returns {boolean}
	     */
	
	
	    AdjacencyListGraph.prototype.addArc = function addArc(arc1, arc2, info) {
	        var k = this.locateVex(arc1);
	        var j = this.locateVex(arc2);
	
	        if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	        // 边的起始表结点赋值
	        var p = new ArcNode(k, null, info);
	        // 边的末尾表结点赋值
	        var q = new ArcNode(j, null, info);
	
	        // 是无向图，用头插入法插入到两个单链表
	        if (this.kind === UDG || this.kind === UDN) {
	            q.nextArc = this.vertices[k].firstArc;
	            this.vertices[k].firstArc = q;
	            p.nextArc = this.vertices[j].firstArc;
	            this.vertices[j].firstArc = p;
	        }
	        // 建立有向图的邻接链表，用头插入法
	        else {
	                p.nextArc = this.vertices[j].firstArc;
	                this.vertices[j].firstArc = p;
	            }
	
	        ++this.arcnum;
	
	        return true;
	    };
	
	    // TODO 其他图类型的创建暂时没弄
	
	
	    AdjacencyListGraph.prototype.createGraph = function createGraph() {
	        this.vexnum = +prompt('vexnum: ');
	        this.arcnum = +prompt('arcnum: ');
	        // incInfo为0则各弧不含其他信息
	        var incInfo = +prompt('incInfo: ');
	
	        for (var _m = 0; _m < this.vexnum; ++_m) {
	            this.vertices[_m] = new VexNode();
	            this.vertices[_m].data = prompt('vertex: ');
	        }
	
	        for (m = 0; m < this.arcnum; ++m) {
	            var h = prompt('弧头: ');
	            var t = prompt('弧尾: ');
	            var _i2 = this.locateVex(t);
	            var j = this.locateVex(h);
	
	            if (_i2 < 0 || j < 0) {
	                alert('顶点为找到，请重新输入！');
	                m--;
	                continue;
	            }
	
	            var p = new ArcNode(j, null, incInfo && prompt('info: '));
	
	            if (!this.vertices[_i2].firstArc) this.vertices[_i2].firstArc = p;else {
	                for (var _q = this.vertices[_i2].firstArc; _q.nextArc; _q = _q.nextArc) {}
	                q.nextArc = p;
	            }
	        }
	    };
	
	    // 判断一个邻接表存储的有向图是否可传递
	
	
	    AdjacencyListGraph.prototype.isPass = function isPass() {
	        if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	        for (var x = 0; x < this.vexnum; ++x) {
	            for (var p = this.vertices[x].firstArc; p; p = p.nextArc) {
	                var y = p.adjVex;
	                for (var _q2 = this.vertices[y].firstArc; _q2; _q2 = _q2.nextArc) {
	                    var z = _q2.adjVex;
	                    if (z !== x && this.isAdj(x, z)) return false;
	                }
	            }
	        }
	
	        return true;
	    };
	
	    // 判断有向图是否存在边(m,n)
	
	
	    AdjacencyListGraph.prototype.isAdj = function isAdj(m, n) {
	        for (var p = this.vertices[m].firstArc; p; p = p.nextArc) {
	            if (p.adjVex === n) return true;
	        }
	        return false;
	    };
	
	    /**
	     * 深度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	     * @param {String} i
	     * @param {String} j
	     */
	
	
	    AdjacencyListGraph.prototype.exist_path_DFS = function exist_path_DFS(i, j) {
	        var visited = [];
	        i = this.locateVex(i);
	        j = this.locateVex(j);
	
	        if (i < 0 || j < 0) throw new Error('vertex not found!');
	
	        return exist_path(this, i, j);
	
	        function exist_path(graph, i, j) {
	            if (i === j) return true;
	
	            visited[i] = true;
	            for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                var k = p.adjVex;
	                if (!visited[k] && exist_path(graph, k, j)) return true;
	            }
	
	            return false;
	        }
	    };
	
	    /**
	     * 广度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	     * @param {String} i
	     * @param {String} j
	     */
	
	
	    AdjacencyListGraph.prototype.exist_path_BFS = function exist_path_BFS(i, j) {
	        i = this.locateVex(i);
	        j = this.locateVex(j);
	        var visited = [];
	        var queue = new _Queue2.default();
	        queue.enQueue(i);
	
	        while (queue.rear) {
	            var u = queue.deQueue();
	            visited[u] = 1;
	
	            for (var p = this.vertices[i].firstArc; p; p = p.nextArc) {
	                var k = p.adjVex;
	                if (k === j) return true;
	                if (!visited[k]) queue.enQueue(k);
	            }
	        }
	
	        return false;
	    };
	
	    /**
	     * 判断邻接表方式存储的有向图的顶点i到j是否存在长度为k的简单路径
	     * @param {String} i
	     * @param {String} j
	     * @param {Number} k
	     */
	
	
	    AdjacencyListGraph.prototype.exist_path_len = function exist_path_len(i, j, k) {
	        i = this.locateVex(i);
	        j = this.locateVex(j);
	        var visited = [];
	
	        return function recurse(graph, i, j, k) {
	            // 找到了一条路径，且长度符合
	            if (i === j && k === 0) return true;else if (k > 0) {
	                visited[i] = 1;
	                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                    var l = p.adjVex;
	                    if (!visited[l]) {
	                        // 剩余路径长度减一
	                        if (recurse(graph, l, j, k - 1)) return true;
	                    }
	                }
	                // 允许曾经被访问过的结点出现在另一条路径上
	                visited[i] = 0;
	            }
	
	            return false;
	        }(this, i, j, k);
	    };
	
	    /**
	     * 求有向图中顶点u到v之间的所有简单路径，k为当前路径长度
	     * @param {String} u
	     * @param {String} v
	     * @param {Number} k
	     *
	     * @example
	     *  graph.find_all_path('v1', 'v2', 0);
	     */
	
	
	    AdjacencyListGraph.prototype.find_all_path = function find_all_path(u, v, k) {
	        u = this.locateVex(u);
	        v = this.locateVex(v);
	        var path = [];
	        var visited = [];
	
	        findPath(this, u, v, k);
	
	        function findPath(graph, u, v, k) {
	            // 加入当前路径中
	            path[k] = u;
	            visited[u] = 1;
	
	            // 找到一条简单路径
	            if (u === v) {
	                console.log('Found one path!');
	                for (var _i3 = 0; path[_i3]; ++_i3) {
	                    console.log(path[_i3]);
	                }
	            } else {
	                for (var p = graph.vertices[u].firstArc; p; p = p.nextArc) {
	                    var l = p.adjVex;
	                    // 继续寻找
	                    if (!visited[l]) findPath(graph, l, v, k + 1);
	                }
	            }
	
	            visited[u] = 0;
	            // 回溯
	            path[k] = 0;
	        }
	    };
	
	    /**
	     * 求有向图的顶点之间长度为len的简单路径条数
	     * @param {String} i
	     * @param {String} j
	     * @param {Number} len
	     */
	
	
	    AdjacencyListGraph.prototype.getPathNum_len = function getPathNum_len(i, j, len) {
	        var visited = [];
	
	        return function recurse(graph, i, j, len) {
	            if (i === j && len === 0) return 1;else if (len > 0) {
	                var sum = 0;
	                visited[i] = 1;
	                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                    var l = p.adjVex;
	                    if (!visited[l]) sum += recurse(l, j, len - 1);
	                }
	                visited[i] = 0;
	                return sum;
	            }
	        }(this, i, j, len);
	    };
	
	    /**
	     * 求有向无环图的根
	     */
	
	
	    AdjacencyListGraph.prototype.getRoot = function getRoot() {
	        var visited = [];
	
	        for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	            // 每次都要将访问数组清零
	            for (var _w = 0; _w < this.vexnum; ++_w) {
	                visited[_w] = false;
	            } // 从顶点i出发进行深度优先遍历
	            dfs(this, _i4);
	
	            var flag = true;
	            for (w = 0; w < this.vexnum; ++w) {
	                // 如果i是根，则深度优先遍历可以访问到所有结点
	                if (!visited[w]) flag = false;
	            }
	
	            if (flag) console.log('Found a root vertex: %d', _i4);
	        }
	
	        function dfs(graph, v) {
	            visited[v] = true;
	
	            for (var p = graph.vertices[v].firstArc; p; p = p.nextArc) {
	                var _w2 = p.adjVex;
	                if (!visited[_w2]) dfs(graph, _w2);
	            }
	        }
	    };
	
	    /**
	     * 求一个有向无环图中最长的路径
	     */
	
	
	    AdjacencyListGraph.prototype.getLongestPath = function getLongestPath() {
	        var mlp = [];
	        var path = [];
	        var visited = [];
	        var maxLen = 0;
	
	        this.countIndegree();
	
	        for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	            for (var j = 0; j < this.vexnum; ++j) {
	                visited[j] = false;
	            } // 从每一个零入度结点开始深度优先遍历
	            if (this.vertices[_i5].indegree === 0) dfs(this, _i5, 0);
	        }
	
	        console.log('Longest Path:');
	        // 输出最长路径
	        for (i = 0; mlp[i]; ++i) {
	            console.log(mlp.join(','));
	        }function dfs(graph, i, len) {
	            visited[i] = true;
	            path[len] = i;
	
	            // 新的最长路径
	            if (len > maxLen && !graph.vertices[i].firstArc) {
	                // 保存下来
	                for (var _j = 0; _j <= len; ++_j) {
	                    mlp[_j] = path[_j];
	                }maxLen = len;
	            } else {
	                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                    var _w3 = p.adjVex;
	                    if (!visited[_w3]) dfs(graph, _w3, len + 1);
	                }
	            }
	
	            path[i] = 0;
	            visited[i] = false;
	        }
	    };
	
	    // 邻接表的递归式深度优先遍历
	
	
	    AdjacencyListGraph.prototype.DFSTraverse = function DFSTraverse(visitFn) {
	        var visited = [];
	        for (var _i6 = 0; _i6 < this.vexnum; ++_i6) {
	            visited[_i6] = false;
	        }for (var _i7 = 0; _i7 < this.vexnum; ++_i7) {
	            if (!visited[_i7]) dfs(this, _i7);
	        }
	
	        function dfs(graph, v) {
	            visited[v] = true;
	            visitFn.call(graph, v);
	
	            var p = graph.vertices[v].firstArc;
	            while (p) {
	                if (!visited[p.adjVex]) dfs(graph, p.adjVex);
	
	                p = p.nextArc;
	            }
	        }
	    };
	
	    // 邻接表的非递归深度优先搜索
	
	
	    AdjacencyListGraph.prototype.DFSTraverse_NonRecurse = function DFSTraverse_NonRecurse(visitFn) {
	        var visited = [];
	        var stack = new _index2.default();
	        for (var _i8 = 0; _i8 < this.vexnum; ++_i8) {
	            visited[_i8] = false;
	        }for (var _i9 = 0; _i9 < this.vexnum; ++_i9) {
	            if (!visited[_i9]) {
	                stack.push(_i9);
	                visited[_i9] = true;
	                visitFn.call(this, _i9);
	
	                var v = void 0;
	                while ((v = stack.peek()) != null) {
	                    var p = this.vertices[v].firstArc;
	                    while (p) {
	                        if (!visited[p.adjVex]) {
	                            visited[p.adjVex] = true;
	                            visitFn.call(this, p.adjVex);
	                            stack.push(p.adjVex);
	                        } else stack.pop();
	
	                        p = p.nextArc;
	                    }
	                }
	            }
	        }
	    };
	
	    // 邻接表的广度优先搜索
	
	
	    AdjacencyListGraph.prototype.BFSTraverse = function BFSTraverse(visitFn) {
	        var queue = new _Queue2.default();
	        var visited = [];
	        for (var _i10 = 0; _i10 < this.vexnum; ++_i10) {
	            visited[_i10] = false;
	        }for (var _i11 = 0; _i11 < this.vexnum; ++_i11) {
	            if (!visited[_i11]) {
	                queue.enQueue(_i11);
	                visited[_i11] = true;
	                visitFn.call(this, _i11);
	
	                while (queue.rear) {
	                    var _w4 = queue.deQueue();
	                    var p = this.vertices[_w4].firstArc;
	                    while (p) {
	                        if (!visited[p.adjVex]) {
	                            visited[p.adjVex] = true;
	                            visitFn.call(this, p.adjVex);
	                            queue.enQueue(p.adjVex);
	                        }
	
	                        p = p.nextArc;
	                    }
	                }
	            }
	        }
	    };
	
	    // 建立无向图的深度优先生成森林的孩子兄弟链表树
	
	
	    AdjacencyListGraph.prototype.createDFSForest = function createDFSForest() {
	        var tree = null;
	        var visited = [];
	        for (var _i12 = 0; _i12 < this.vexnum; ++_i12) {
	            visited[_i12] = false;
	        }var q = void 0;
	        for (var _i13 = 0; _i13 < this.vexnum; ++_i13) {
	            if (!visited[_i13]) {
	                // 新的生成树的根结点
	                var p = new _BinaryTree.ChildSiblingTree(this.vertices[_i13].data);
	
	                // 第一棵生成树的根
	                if (!tree) tree = p;
	                // 其它生成树的根
	                else q.nextSibling = p;
	
	                // q为当前生成树的根
	                q = p;
	                // 建立以p为根的生成树
	                DFSTree(this, _i13, p);
	            }
	        }
	
	        return tree;
	
	        // 以第v个顶点触发深度优先遍历图，建立以tree为根的生成树
	        function DFSTree(graph, v, tree) {
	            visited[v] = true;
	            var first = true;
	            var w = graph.vertices[v].firstArc;
	            var q = void 0;
	
	            while (w) {
	                if (!visited[w.adjVex]) {
	                    visited[w.adjVex] = true;
	                    var _p = new _BinaryTree.ChildSiblingTree(graph.vertices[w.adjVex].data);
	
	                    // w是v的第一个未被访问的邻接结点
	                    if (first) {
	                        tree.firstChild = _p;
	                        first = false;
	                    }
	                    // w是v的其它未被访问的邻接顶点
	                    else q.nextSibling = _p;
	
	                    q = _p;
	
	                    DFSTree(graph, w.adjVex, q);
	                }
	
	                w = w.nextArc;
	            }
	        }
	    };
	
	    AdjacencyListGraph.prototype.createBFSForest = function createBFSForest() {
	        var tree = null;
	        var visited = [];
	        var queue = new _Queue2.default();
	        for (var _i14 = 0; _i14 < this.vexnum; ++_i14) {
	            visited[_i14] = false;
	        }var q = void 0;
	        for (var _i15 = 0; _i15 < this.vexnum; ++_i15) {
	            if (!visited[_i15]) {
	                visited[_i15] = true;
	                queue.enQueue(_i15);
	
	                var node = new _BinaryTree.ChildSiblingTree(this.vertices[_i15].data);
	                if (!tree) tree = node;else q.nextSibling = node;
	
	                q = node;
	
	                while (queue.rear) {
	                    var _w5 = queue.deQueue();
	                    var p = this.vertices[_w5].firstArc;
	                    var first = true;
	                    var pre = void 0;
	
	                    while (p) {
	                        if (!visited[p.adjVex]) {
	                            visited[p.adjVex] = true;
	                            queue.enQueue(p.adjVex);
	
	                            var node2 = new _BinaryTree.ChildSiblingTree(this.vertices[p.adjVex].data);
	
	                            if (first) {
	                                node.firstChild = node2;
	                                first = false;
	                            } else pre.nextSibling = node2;
	
	                            pre = node2;
	                        }
	                        p = p.nextArc;
	                    }
	                }
	            }
	        }
	
	        return tree;
	    };
	
	    AdjacencyListGraph.prototype.findArticul = function findArticul() {
	        var visited = [];
	        var count = 1;
	        var low = [];
	        low[0] = count;
	        visited[0] = 1;
	        for (var _i16 = 1; _i16 < this.vexnum; ++_i16) {
	            visited[_i16] = 0;
	        }var p = this.vertices[0].firstArc;
	        var v = p.adjVex;
	
	        DFSArticul(this, v);
	        if (count < this.vexnum) {
	            console.log(0 + '  ' + this.vertices[0].data);
	            while (p.nextArc) {
	                p = p.nextArc;
	                v = p.adjVex;
	                if (visited[v] === 0) DFSArticul(this, v);
	            }
	        }
	
	        function DFSArticul(graph, v0) {
	            var min = visited[v0] = ++count;
	            for (var _p2 = graph.vertices[v0].firstArc; _p2; _p2 = _p2.nextArc) {
	                var _w6 = _p2.adjVex;
	                if (visited[_w6] === 0) {
	                    DFSArticul(graph, _w6);
	                    if (low[_w6] < min) min = low[_w6];
	                    if (low[_w6] >= visited[v0]) console.log(v0 + '  ' + graph.vertices[v0].data);
	                } else if (visited[_w6] < min) min = visited[_w6];
	            }
	            low[v0] = min;
	        }
	    };
	
	    // 统计各顶点入度的函数
	
	
	    AdjacencyListGraph.prototype.countIndegree = function countIndegree() {
	        for (var k = 0; k < this.vexnum; ++k) {
	            this.vertices[k].indegree = 0;
	        }for (var _k = 0; _k < this.vexnum; ++_k) {
	            for (var p = this.vertices[_k].firstArc; p; p = p.nextArc) {
	                ++this.vertices[p.adjVex].indegree;
	            }
	        }
	    };
	
	    // 拓扑排序算法
	
	
	    AdjacencyListGraph.prototype.topologicSort = function topologicSort() {
	        var stack = new _index2.default();
	        this.topologicalOrder = [];
	        this.countIndegree();
	
	        for (var _i17 = 0; _i17 < this.vexnum; ++_i17) {
	            if (this.vertices[_i17].indegree === 0) stack.push(_i17);
	        }
	
	        var count = 0;
	        while (stack.length) {
	            var _i18 = stack.pop();
	            this.topologicalOrder.push(_i18);
	            console.log(this.vertices[_i18].data);
	            ++count;
	            for (var p = this.vertices[_i18].firstArc; p; p = p.nextArc) {
	                var k = p.adjVex;
	                if (--this.vertices[k].indegree === 0) stack.push(k);
	            }
	        }
	
	        return count >= this.vexnum;
	    };
	
	    // 输出有向图的各项关键活动
	
	
	    AdjacencyListGraph.prototype.criticalPath = function criticalPath() {
	        if (!this.topologicSort()) throw new Error('AOE网中存在回路！');
	
	        var ve = [];
	        // 事件最早发生时间初始化
	        for (var j = 0; j < this.vexnum; ++j) {
	            ve[j] = 0;
	        } // 计算每个事件的最早发生时间ve值
	        for (var _m2 = 0; _m2 < this.vexnum; ++_m2) {
	            var _j2 = this.topologicalOrder[_m2];
	            for (var p = this.vertices[_j2].firstArc; p; p = p.nextArc) {
	                var k = p.adjVex;
	                if (ve[_j2] + p.info > ve[k]) ve[k] = ve[_j2] + p.info;
	            }
	        }
	        var vl = [];
	        // 事件最晚发生时间初始化
	        for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	            vl[_j3] = ve[this.vexnum - 1];
	        } // 计算每个事件的最晚发生时间vl的值
	        for (var _m3 = this.vexnum - 1; _m3 >= 0; --_m3) {
	            var _j4 = this.topologicalOrder[_m3];
	            for (var _p3 = this.vertices[_j4].firstArc; _p3; _p3 = _p3.nextArc) {
	                var _k2 = _p3.adjVex;
	                if (vl[_k2] - _p3.info < vl[_j4]) vl[_j4] = vl[_k2] - _p3.info;
	            }
	        }
	        // 输出所有关键活动
	        for (var _m4 = 0; _m4 < this.vexnum; ++_m4) {
	            for (var _p4 = this.vertices[_m4].firstArc; _p4; _p4 = _p4.nextArc) {
	                var _k3 = _p4.adjVex;
	                if (ve[_m4] + _p4.info === vl[_k3]) console.log('<%d, %d>', _m4, _k3);
	            }
	        }
	    };
	
	    AdjacencyListGraph.prototype.shortestPath_Dijkstra = function shortestPath_Dijkstra(v0) {
	        var dist = [];
	        var pre = [];
	        var final = [];
	        var w = void 0;
	
	        for (var _v = 0; _v < this.vexnum; ++_v) {
	            dist[_v] = Infinity;
	        }for (var p = this.vertices[v0].firstArc; p; p = p.nextArc) {
	            dist[p.adjVex] = p.info;
	        }var v = void 0;
	        for (v = 0; v < this.vexnum; ++v) {
	            final[v] = false;
	            pre[v] = pre[v] || [];
	            for (w = 0; w < this.vexnum; ++w) {
	                pre[v][w] = false;
	            }if (dist[v] < Infinity) {
	                pre[v][v0] = true;
	                pre[v][v] = true;
	            }
	        }
	
	        dist[v0] = 0;
	        final[v0] = true;
	
	        for (var _i19 = 1; _i19 < this.vexnum; ++_i19) {
	            var min = Infinity;
	            for (w = 0; w < this.vexnum; ++w) {
	                if (!final[w] && dist[w] < min) {
	                    v = w;
	                    min = dist[w];
	                }
	            }
	
	            final[v] = true;
	
	            for (var _p5 = this.vertices[v].firstArc; _p5; _p5 = _p5.nextArc) {
	                w = _p5.adjVex;
	                if (!final[w] && min + _p5.info < dist[w]) {
	                    dist[w] = min + _p5.info;
	                    pre[w] = pre[v];
	                    pre[w][w] = true;
	                }
	            }
	        }
	
	        console.log(final);
	        console.log(pre);
	        console.log(dist);
	
	        return {
	            final: final,
	            pre: pre,
	            dist: dist
	        };
	    };
	
	    return AdjacencyListGraph;
	}();
	
	// 无向图的邻接表
	
	
	exports.default = AdjacencyListGraph;
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v1', 'v2');
	adjListGraph.addArc('v1', 'v3');
	adjListGraph.addArc('v1', 'v4');
	adjListGraph.addArc('v2', 'v3');
	adjListGraph.addArc('v3', 'v4');
	adjListGraph.addArc('v3', 'v5');
	adjListGraph.addArc('v4', 'v5');
	
	console.log(adjListGraph);
	
	// 有向图的逆邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v1', 'v2');
	g.addArc('v1', 'v4');
	g.addArc('v3', 'v2');
	g.addArc('v3', 'v1');
	g.addArc('v4', 'v3');
	g.addArc('v3', 'v5');
	g.addArc('v5', 'v4');
	
	console.log(g);
	
	// 有向图的正邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v2', 'v1');
	g.addArc('v4', 'v1');
	g.addArc('v2', 'v3');
	g.addArc('v1', 'v3');
	g.addArc('v3', 'v4');
	g.addArc('v5', 'v3');
	g.addArc('v4', 'v5');
	
	console.log(g);
	
	console.log('adjListGraph DFSTraverse: ');
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v5', 'v4');
	adjListGraph.addArc('v3', 'v2');
	adjListGraph.addArc('v2', 'v1');
	adjListGraph.addArc('v3', 'v1');
	
	adjListGraph.DFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph DFSTraverse_NonRecurse: ');
	adjListGraph.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph BFSTraverse: ');
	var g2 = new AdjacencyListGraph([], 0, 0, DG);
	g2.addVertex('v1');
	g2.addVertex('v2');
	g2.addVertex('v3');
	g2.addVertex('v4');
	g2.addVertex('v5');
	
	g2.addArc('v4', 'v1');
	g2.addArc('v2', 'v1');
	g2.addArc('v5', 'v3');
	g2.addArc('v2', 'v3');
	g2.addArc('v1', 'v3');
	g2.addArc('v3', 'v4');
	g2.addArc('v4', 'v5');
	
	g2.BFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('DFS: expect false: ' + adjListGraph.exist_path_DFS('v1', 'v4'));
	console.log('DFS: expect true: ' + adjListGraph.exist_path_DFS('v1', 'v2'));
	
	console.log('BFS : expect false: ' + adjListGraph.exist_path_BFS('v1', 'v4'));
	console.log('BFS :expect true: ' + adjListGraph.exist_path_BFS('v1', 'v2'));
	
	/*
	 图的连通性问题
	
	 无向图的连通分量与生成树
	
	 1 无向图的连通分量和生成树
	 对于无向图，对其进行遍历时：
	 ◆ 若是连通图：仅需从图中任一顶点出发，就能访问图中的所有顶点；
	 ◆ 若是非连通图：需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集；
	
	 ⑴ 若G=(V,E)是无向连通图， 顶点集和边集分别是V(G) ，E(G) 。若从G中任意点出发遍历时， E(G)被分成两个互不相交的集合：
	 T(G) ：遍历过程中所经过的边的集合；
	 B(G) ：遍历过程中未经过的边的集合；
	 显然： E(G)=T(G)∪B(G) ，T(G)∩B(G)=Ø
	 显然，图G’=(V, T(G))是G的极小连通子图，且G’是一棵树。G’称为图G的一棵生成树。
	 从任意点出发按DFS算法得到生成树G’称为深度优先生成树；按BFS算法得到的G’称为广度优先生成树。
	
	 ⑵  若G=(V,E)是无向非连通图，对图进行遍历时得到若干个连通分量的顶点集：V1(G) ,V2(G) ,…,Vn(G)和相应所经过的边集：T1(G) ,T2(G) , …,Tn(G) 。
	 则对应的顶点集和边集的二元组：Gi=(Vi(G),Ti(G))
	 (1≦i≦n)是对应分量的生成树，所有这些生成树构成了原来非连通图的生成森林。
	
	 说明：当给定无向图要求画出其对应的生成树或生成森林时，必须先给出相应的邻接表，然后才能根据邻接表画出其对应的生成树或生成森林。
	
	
	 2  图的生成树和生成森林算法
	
	 对图的深度优先搜索遍历DFS(或BFS)算法稍作修改，就可得到构造图的DFS生成树算法。
	 在算法中，树的存储结构采用孩子—兄弟表示法。首先建立从某个顶点V出发，建立一个树结点，然后再分别以V的邻接点为起始点，建立相应的子生成树，并将其作为V 结点的子树链接到V结点上。显然，算法是一个递归算法。
	
	 */
	
	console.log(adjListGraph.createDFSForest());
	
	console.log(adjListGraph.createBFSForest());
	
	/*
	 在某图中，若删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。一个没有关节点的连通图称为重连通图。
	 在重连通图中，任意一对顶点之间至少存在两条路径，则再删去某个顶点即相关各边后也不破坏图的连通性。若在图的连通图上删去k个节点才能破坏图的连通性，则称K为此图的连通度。
	 他们常常在通信网络的图或航空网中应用，K越大，系统越稳定，反之，战争中若要摧毁敌方的运输线，只须破坏其运输网中的关节点即可。
	 */
	
	var articulTest = new AdjacencyListGraph([], 0, 0, UDG);
	articulTest.addVertex('A');
	articulTest.addVertex('B');
	articulTest.addVertex('C');
	articulTest.addVertex('D');
	articulTest.addVertex('E');
	articulTest.addVertex('F');
	articulTest.addVertex('G');
	articulTest.addVertex('H');
	articulTest.addVertex('I');
	articulTest.addVertex('J');
	articulTest.addVertex('K');
	articulTest.addVertex('L');
	articulTest.addVertex('M');
	
	articulTest.addArc('A', 'B');
	articulTest.addArc('A', 'C');
	articulTest.addArc('A', 'F');
	articulTest.addArc('A', 'L');
	articulTest.addArc('C', 'B');
	articulTest.addArc('D', 'B');
	articulTest.addArc('G', 'B');
	articulTest.addArc('H', 'B');
	articulTest.addArc('M', 'B');
	articulTest.addArc('D', 'E');
	articulTest.addArc('G', 'H');
	articulTest.addArc('G', 'I');
	articulTest.addArc('G', 'K');
	articulTest.addArc('H', 'K');
	articulTest.addArc('J', 'L');
	articulTest.addArc('J', 'M');
	articulTest.addArc('L', 'M');
	
	articulTest.findArticul();
	
	/*
	 有向无环图及其应用
	
	 有向无环图(Directed Acycling Graph)：是图中没有回路(环)的有向图。是一类具有代表性的图，主要用于研究工程项目的工序问题、工程时间进度问题等。
	
	 一个工程(project)都可分为若干个称为活动(active)的子工程(或工序)，各个子工程受到一定的条件约束：某个子工程必须开始于另一个子工程完成之后；整个工程有一个开始点(起点)和一个终点。人们关心：
	 ◆ 工程能否顺利完成?影响工程的关键活动是什么?
	 ◆ 估算整个工程完成所必须的最短时间是多少?
	
	 对工程的活动加以抽象：图中顶点表示活动，有向边表示活动之间的优先关系，这样的有向图称为顶点表示活动的网(Activity On Vertex Network ，AOV网) 。
	
	
	 拓扑排序
	
	 1 定义
	 拓扑排序(Topological Sort) ：由某个集合上的一个偏序得到该集合上的一个全序的操作。
	
	 ◆ 集合上的关系：集合A上的关系是从A到A的关系(AA) 。
	 ◆ 关系的自反性：若a∈A有(a，a)∈R，称集合A上的关系R是自反的。
	 ◆ 关系的对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。
	 ◆ 关系的对称性与反对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。如果对于a，b∈A ，仅当a=b时有(a，b)∈R和(b，a)∈R ，称集合A上的关系R是反对称的。
	 ◆ 关系的传递性：若a，b，c∈A，若(a，b)∈R，并且(b，c)∈R ，则(a，c)∈R ，称集合A上的关系R是传递的。
	 ◆ 偏序：若集合A上的关系R是自反的，反对称的和传递的，则称R是集合A上的偏序关系。
	 ◆ 全序：设R是集合A上的偏序关系，a，b∈A，必有aRb或bRa， 则称R是集合A上的全序关系。
	
	 即偏序是指集合中仅有部分元素之间可以比较，而全序是指集合中任意两个元素之间都可以比较。
	 在AOV网中，若有有向边<i, j>，则i是j的直接前驱，j是i的直接后继；推而广之，若从顶点i到顶点j有有向路径，则i是j的前驱，j是i的后继。
	 在AOV网中，不能有环，否则，某项活动能否进行是以自身的完成作为前提条件。
	 检查方法：对有向图的顶点进行拓扑排序，若所有顶点都在其拓扑有序序列中，则无环。
	 有向图的拓扑排序：构造AOV网中顶点的一个拓扑线性序列(v’1,v’2, ⋯,v’n)，使得该线性序列不仅保持原来有向图中顶点之间的优先关系，而且对原图中没有优先关系的顶点之间也建立一种(人为的)优先关系。
	
	 2 拓扑排序算法
	 算法思想
	
	 ① 在AOV网中选择一个没有前驱的顶点且输出；
	 ② 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧)所有有向弧(边) ；
	 ③ 重复①、②，直到图中全部顶点都已输出(图中无环)或图中不存在无前驱的顶点(图中必有环)。
	
	 3  算法实现说明
	 ◆ 采用正邻接链作为AOV网的存储结构；
	 ◆ 设立堆栈，用来暂存入度为0的顶点；
	 ◆ 删除顶点以它为尾的弧：弧头顶点的入度减1。
	
	 整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var topologicTest = new AdjacencyListGraph([], 0, 0, DG);
	topologicTest.addVertex('v1');
	topologicTest.addVertex('v2');
	topologicTest.addVertex('v3');
	topologicTest.addVertex('v4');
	topologicTest.addVertex('v5');
	topologicTest.addVertex('v6');
	
	topologicTest.addArc('v2', 'v1');
	topologicTest.addArc('v4', 'v1');
	topologicTest.addArc('v3', 'v1');
	topologicTest.addArc('v2', 'v3');
	topologicTest.addArc('v5', 'v3');
	topologicTest.addArc('v4', 'v6');
	topologicTest.addArc('v5', 'v4');
	topologicTest.addArc('v5', 'v6');
	
	console.log('topologicSort: ');
	console.log(topologicTest.topologicSort());
	
	/*
	 关键路径(Critical Path)
	
	 与AOV网相对应的是AOE(Activity On Edge) ，是边表示活动的有向无环图，如图7-24所示。图中顶点表示事件(Event)，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的时间或费用。
	
	 1 与AOE有关的研究问题
	 ◆ 完成整个工程至少需要多少时间?
	 ◆ 哪些活动是影响工程进度(费用)的关键?
	 工程完成最短时间：从起点到终点的最长路径长度(路径上各活动持续时间之和) 。长度最长的路径称为关键路径，关键路径上的活动称为关键活动。关键活动是影响整个工程的关键。
	 设v0是起点，从v0到vi的最长路径长度称为事件vi的最早发生时间，即是以vi为尾的所有活动的最早发生时间。
	 若活动ai是弧<j, k>，持续时间是dut(<j, k>)，设：
	 ◆ e(i)：表示活动ai的最早开始时间；
	 ◆ l(i)：在不影响进度的前提下，表示活动ai的最晚开始时间； 则l(i)-e(i)表示活动ai的时间余量，若l(i)-e(i)=0，表示活动ai是关键活动。
	 ◆ ve(i)：表示事件vi的最早发生时间，即从起点到顶点vi的最长路径长度；
	 ◆ vl(i)：表示事件vi的最晚发生时间。则有以下关系：
	 e(i)=ve(j)
	 l(i)= vl(k)-dut(<j, k>)
	 0    j=0，表示vj是起点
	 ve(j)=
	 Max{ve(i)+dut(<i, j>)|<vi, vj>是网中的弧}
	
	 含义是：源点事件的最早发生时间设为0；除源点外，只有进入顶点vj的所有弧所代表的活动全部结束后，事件vj才能发生。即只有vj的所有前驱事件vi的最早发生时间ve(i)计算出来后，才能计算ve(j) 。
	 方法是：对所有事件进行拓扑排序，然后依次按拓扑顺序计算每个事件的最早发生时间。
	 ve(n-1)    j=n-1，表示vj是终点
	 vl(j)=
	 Min{vl(k)-dut(<j, k>)|<vj, vk>是网中的弧}
	 含义是：只有vj的所有后继事件vk的最晚发生时间vl(k)计算出来后，才能计算vl(j) 。
	 方法是：按拓扑排序的逆顺序，依次计算每个事件的最晚发生时间。
	
	
	 2 求AOE中关键路径和关键活动
	 ⑴ 算法思想
	 ① 利用拓扑排序求出AOE网的一个拓扑序列；
	 ②  从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个事件的最早发生时间ve(i) ；
	 ③  从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；
	
	 设AOE网有n个事件，e个活动，则算法的主要执行是：
	 ◆ 进行拓扑排序：时间复杂度是O(n+e) ；
	 ◆ 求每个事件的ve值和vl值：时间复杂度是O(n+e) ；
	 ◆ 根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；
	 因此，整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var criticalPathTest = new AdjacencyListGraph([], 0, 0, DG);
	criticalPathTest.addVertex('v0');
	criticalPathTest.addVertex('v1');
	criticalPathTest.addVertex('v2');
	criticalPathTest.addVertex('v3');
	criticalPathTest.addVertex('v4');
	criticalPathTest.addVertex('v5');
	criticalPathTest.addVertex('v6');
	criticalPathTest.addVertex('v7');
	criticalPathTest.addVertex('v8');
	
	criticalPathTest.addArc('v1', 'v0', 3);
	criticalPathTest.addArc('v2', 'v0', 10);
	criticalPathTest.addArc('v4', 'v1', 13);
	criticalPathTest.addArc('v4', 'v2', 12);
	criticalPathTest.addArc('v3', 'v1', 9);
	criticalPathTest.addArc('v5', 'v2', 7);
	criticalPathTest.addArc('v7', 'v4', 6);
	criticalPathTest.addArc('v7', 'v3', 4);
	criticalPathTest.addArc('v7', 'v5', 11);
	criticalPathTest.addArc('v6', 'v3', 8);
	criticalPathTest.addArc('v8', 'v7', 5);
	criticalPathTest.addArc('v8', 'v6', 2);
	
	criticalPathTest.criticalPath();
	
	var dijTest = new AdjacencyListGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('1', '0', 20);
	dijTest.addArc('4', '0', 10);
	dijTest.addArc('2', '0', 60);
	dijTest.addArc('5', '0', 65);
	dijTest.addArc('2', '1', 30);
	dijTest.addArc('3', '2', 40);
	dijTest.addArc('2', '5', 15);
	dijTest.addArc('5', '4', 20);
	dijTest.addArc('4', '3', 35);
	dijTest.addArc('3', '1', 70);
	
	dijTest.shortestPath_Dijkstra(0);
	
	(function () {
	    /**
	     * 输出有向无环图形式表示的逆波兰式
	     */
	    function niBoLan_DAG(graph) {
	        graph.countIndegree();
	        for (var _i20 = 0; _i20 < graph.vexnum; ++_i20) {
	            // 找到有向无环图的根
	            if (graph.vertices[_i20].indegree === 0) {
	                printNiBoLan(graph, _i20);
	                break;
	            }
	        }
	
	        return false;
	    }
	
	    function printNiBoLan(graph, i) {
	        var c = graph.vertices[i].data;
	        var p = graph.vertices[i].firstArc;
	
	        // 子表达式
	        if (p) {
	            printNiBoLan(graph, p.adjVex);
	            printNiBoLan(graph, p.nextArc.adjVex);
	        }
	
	        console.log(c + '');
	    }
	
	    /**
	     * 给有向无环图表示的表达式求值
	     */
	    function evaluate_DAG(graph) {
	        graph.countIndegree();
	        for (var _i21 = 0; _i21 < graph.vexnum; ++_i21) {
	            if (!graph.vertices[_i21].indegree) return evaluate_imp(graph, _i21);
	        }
	    }
	
	    function evaluate_imp(g, i) {
	        if (/^\d+$/.test(g.vertices[i].data)) return g.vertices[i].data;else {
	            var p = g.vertices[i].firstArc;
	            var v1 = evaluate_imp(g, p.adjVex);
	            var v2 = evaluate_imp(g, p.nextArc.adjVex);
	            return calculate(v1, g.vertices[i].data, v2);
	        }
	    }
	
	    function calculate(a, operation, b) {
	        // 偷一下懒..
	        return eval(a + operation + b);
	    }
	
	    // ((1 + 2) * (2 * (3 + 4)) + (3 + 4) * 5) * ((3 + 4) * 5)
	    var dag = new AdjacencyListGraph([], 0, 0, DG);
	
	    var a1 = new String('*');
	    var a2 = new String('+');
	    var a3 = new String('*');
	    var a4 = new String('*');
	    var a5 = new String('+');
	    var a6 = new String('*');
	    var a7 = new String('+');
	
	    // 12
	    dag.addVertex(a1);
	    dag.addVertex(a2);
	    dag.addVertex(a3);
	    dag.addVertex(a4);
	    dag.addVertex(a5);
	    dag.addVertex(a6);
	    dag.addVertex(a7);
	    dag.addVertex(1);
	    dag.addVertex(2);
	    dag.addVertex(3);
	    dag.addVertex(4);
	    dag.addVertex(5);
	
	    // 14
	    dag.addArc(a2, a1);
	    dag.addArc(a4, a1);
	    dag.addArc(a3, a2);
	    dag.addArc(a4, a2);
	    dag.addArc(a5, a3);
	    dag.addArc(a6, a3);
	    dag.addArc(a7, a6);
	    dag.addArc(a7, a4);
	    dag.addArc(5, a4);
	    dag.addArc(1, a5);
	    dag.addArc(2, a5);
	    dag.addArc(2, a6);
	    dag.addArc(3, a7);
	    dag.addArc(4, a7);
	
	    console.log('niBoLan_DAG: ');
	    niBoLan_DAG(dag);
	    console.log('evaluate_DAG: ' + evaluate_DAG(dag)); // 2695
	})();

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(17);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(16);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* create by Luke */
	/**
	 * 图(Graph)
	 *
	 * 图(Graph)是一种比线性表和树更为复杂的数据结构。
	 *
	 * 线性结构：是研究数据元素之间的一对一关系。在这种结构中，除第一个和最后一个元素外，任何一个元素都有唯一的一个直接前驱和直接后继。
	 *
	 * 树结构：是研究数据元素之间的一对多的关系。在这种结构中，每个元素对下(层)可以有0个或多个元素相联系，对上(层)只有唯一的一个元素相关，数据元素之间有明显的层次关系。
	 *
	 * 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。
	 *
	 * 图的应用极为广泛，已渗入到诸如语言学、逻辑学、物理、化学、电讯、计算机科学以及数学的其它分支。
	 *
	 * 图的基本概念
	 *
	 * 一个图(G)定义为一个偶对(V,E) ，记为G=(V,E) 。其中： V是顶点(Vertex)的非空有限集合，记为V(G)；E是无序集V&V的一个子集，记为E(G) ，其元素是图的弧(Arc)。
	 * 将顶点集合为空的图称为空图。其形式化定义为：
	 G=(V ，E)
	 V={v|v∈data object}
	 E={<v,w>| v,w∈V∧p(v,w)}
	 P(v,w)表示从顶点v到顶点w有一条直接通路。
	 *
	 * 弧(Arc) ：表示两个顶点v和w之间存在一个关系，用顶点偶对<v,w>表示。通常根据图的顶点偶对将图分为有向图和无向图。
	 * 有向图(Digraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是有序的，称图G是有向图。
	 *   在有向图中，若 <v,w>∈E(G) ，表示从顶点v到顶点w有一条弧。 其中：v称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) 。
	 * 无向图(Undigraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是无序的，称图G是无向图。
	 *   在无向图中，若<v,w>∈E(G) ，有<w,v>∈E(G) ，即E(G)是对称，则用无序对(v,w) 表示v和w之间的一条边(Edge)，因此(v,w) 和(w,v)代表的是同一条边。
	 *
	 * 例1：设有有向图G1和无向图G2，形式化定义分别是：
	 G1=(V1 ，E1)
	 V1={a,b,c,d,e}
	 E1={<a,b>,<a,c>, <a,e>,<c,d>,<c,e> ,<d,a>,<d,b>,<e,d>}
	 G2=(V2 ，E2)
	 V2={a,b,c,d}
	 E2={(a,b), (a,c), (a,d), (b,d), (b,c), (c,d)}
	 *
	 * 完全无向图：对于无向图，若图中顶点数为n ，用e表示边的数目，则e ∈[0，n(n-1)/2] 。具有n(n-1)/2条边的无向图称为完全无向图。
	 完全无向图另外的定义是：
	 * 对于无向图G=(V，E)，若vi，vj ∈V ，当vi≠vj时，有(vi ,vj)∈E，即图中任意两个不同的顶点间都有一条无向边，这样的无向图称为完全无向图。
	 *
	 * 完全有向图：对于有向图，若图中顶点数为n ，用e表示弧的数目，则e∈[0，n(n-1)] 。具有n(n-1)条边的有向图称为完全有向图。
	 完全有向图另外的定义是：
	 * 对于有向图G=(V，E)，若vi，vj∈V ，当vi ≠vj时，有<vi ,vj>∈E∧<vj , vi >∈E ，即图中任意两个不同的顶点间都有一条弧，这样的有向图称为完全有向图。
	 *
	 * 有很少边或弧的图（e<n㏒n）的图称为稀疏图，反之称为稠密图。
	 * 权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。
	 *
	 * 子图和生成子图：设有图G=(V，E)和G’=(V’，E’)，若V’∈V且E’∈E ，则称图G’是G的子图；若V’=V且E’∈E，则称图G’是G的一个生成子图。
	 * 顶点的邻接(Adjacent)：对于无向图G=(V，E)，若边(v,w)∈E，则称顶点v和w 互为邻接点，即v和w相邻接。边(v,w)依附(incident)与顶点v和w 。
	 * 对于有向图G=(V ，E)，若有向弧<v,w>∈E，则称顶点v “邻接到”顶点w，顶点w “邻接自”顶点v ，弧<v,w> 与顶点v和w “相关联” 。
	 *
	 * 顶点的度、入度、出度：对于无向图G=(V，E)， vi∈V，图G中依附于vi的边的数目称为顶点vi的度(degree)，记为TD(vi)。
	 显然，在无向图中，所有顶点度的和是图中边的2倍。 即   ∑TD(vi)=2e      i=1, 2, …, n ，e为图的边数。
	 对有向图G=(V，E)，若vi ∈V ，图G中以vi作为起点的有向边(弧)的数目称为顶点vi的出度(Outdegree)，记为OD(vi) ；以vi作为终点的有向边(弧)的数目称为顶点vi的入度(Indegree)，记为ID(vi) 。顶点vi的出度与入度之和称为vi的度，记为TD(vi) 。即
	 TD(vi)=OD(vi)+ID(vi)
	 *
	 * 路径(Path)、路径长度、回路(Cycle) ：对无向图G=(V，E)，若从顶点vi经过若干条边能到达vj，称顶点vi和vj是连通的，又称顶点vi到vj有路径。
	 对有向图G=(V，E)，从顶点vi到vj有有向路径，指的是从顶点vi经过若干条有向边(弧)能到达vj。
	 或路径是图G中连接两顶点之间所经过的顶点序列。即
	 Path=vi0vi1…vim ，vij∈V且(vij-1, vij)∈E   j=1,2, …,m
	 或
	 Path=vi0vi1 …vim ，vij∈V且<vij-1, vij>∈E  j=1,2, …,m
	 路径上边或有向边(弧)的数目称为该路径的长度。
	 在一条路径中，若没有重复相同的顶点，该路径称为简单路径；第一个顶点和最后一个顶点相同的路径称为回路(环)；在一个回路中，若除第一个与最后一个顶点外，其余顶点不重复出现的回路称为简单回路(简单环)。
	 *
	 * 连通图、图的连通分量：对无向图G=(V，E)，若vi ，vj ∈V，vi和vj都是连通的，则称图G是连通图，否则称为非连通图。若G是非连通图，则极大的连通子图称为G的连通分量。
	 对有向图G=(V，E)，若vi ，vj ∈V，都有以vi为起点， vj 为终点以及以vj为起点，vi为终点的有向路径，称图G是强连通图，否则称为非强连通图。若G是非强连通图，则极大的强连通子图称为G的强连通分量。
	 “极大”的含义：指的是对子图再增加图G中的其它顶点，子图就不再连通。
	 生成树、生成森林：一个连通图(无向图)的生成树是一个极小连通子图，它含有图中全部n个顶点和只有足以构成一棵树的n-1条边，称为图的生成树。
	 关于无向图的生成树的几个结论：
	 ◆ 一棵有n个顶点的生成树有且仅有n-1条边；
	 ◆ 如果一个图有n个顶点和小于n-1条边，则是非连通图；
	 ◆ 如果多于n-1条边，则一定有环；
	 ◆ 有n-1条边的图不一定是生成树。
	
	 有向图的生成森林是这样一个子图，由若干棵有向树组成，含有图中全部顶点。
	 有向树是只有一个顶点的入度为0 ，其余顶点的入度均为1的有向图。
	
	 *
	 * 网：每个边(或弧)都附加一个权值的图，称为带权图。带权的连通图(包括弱连通的有向图)称为网或网络。网络是工程上常用的一个概念，用来表示一个工程或某种流程
	 */
	
	/**
	 * 图的存储结构
	 *
	 图的存储结构比较复杂，其复杂性主要表现在：
	 ◆ 任意顶点之间可能存在联系，无法以数据元素在存储区中的物理位置来表示元素之间的关系。
	 ◆ 图中顶点的度不一样，有的可能相差很大，若按度数最大的顶点设计结构，则会浪费很多存储单元，反之按每个顶点自己的度设计不同的结构，又会影响操作。
	 图的常用的存储结构有：邻接矩阵、邻接链表、十字链表、邻接多重表和边表。
	 */
	
	/*
	 邻接矩阵(数组)表示法
	
	 基本思想：对于有n个顶点的图，用一维数组vexs[n]存储顶点信息，用二维数组A[n][n]存储顶点之间关系的信息。该二维数组称为邻接矩阵。在邻接矩阵中，以顶点在vexs数组中的下标代表顶点，邻接矩阵中的元素A[i][j]存放的是顶点i到顶点j之间关系的信息。
	
	 1  无向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 无向无权图G=(V，E)有n(n≧1)个顶点，其邻接矩阵是n阶对称方阵。其元素的定义如下：
	            -- 1   若(vi , vj)∈E，即vi , vj邻接
	 A[i][j]=
	             -- 0   若(vi , vj)∉E，即vi , vj不邻接
	
	 (2)  带权图的邻接矩阵
	 无向带权图G=(V，E) 的邻接矩阵。其元素的定义如下：
	            -- Wij    若(vi , vj)∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	
	            -- ∞   若(vi , vj)∉E，即vi , vj不邻接时
	
	 (3)  无向图邻接矩阵的特性
	 ◆ 邻接矩阵是对称方阵
	 ◆ 对于顶点vi，其度数是第i行的非0元素的个数；
	 ◆ 无向图的边数是上(或下)三角形矩阵中非0元素个数。
	
	 2  有向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 若有向无权图G=(V，E)有n(n≧1)个顶点，则其邻接矩阵是n阶对称方阵。元素定义如下：
	            -- 1   若<vi, vj>∈E，从vi到vj有弧
	 A[i][j]=
	            -- 0   若<vi , vj>∉E  从vi到vj 没有弧
	
	 (2)  带权图的邻接矩阵
	 有向带权图G=(V，E)的邻接矩阵。其元素的定义如下：
	            -- wij    若<vi,vj>∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	            ∞   若<vi,vj>∉E，即vi , vj不邻接时
	
	 ⑶ 有向图邻接矩阵的特性
	 ◆ 对于顶点vi，第i行的非0元素的个数是其出度OD(vi)；第i列的非0元素的个数是其入度ID(vi) 。
	 ◆ 邻接矩阵中非0元素的个数就是图的弧的数目。
	
	 3  图的邻接矩阵的操作
	
	 图的邻接矩阵的实现比较容易，定义两个数组分别存储顶点信息(数据元素)和边或弧的信息(数据元素之间的关系) 。
	
	 */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	
	var ArcCell =
	/**
	 *
	 * @param {Number} adj
	 * @param {*} info
	 * @constructor
	 */
	function ArcCell(adj) {
	    var info = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ArcCell);
	
	    // 顶点类型。对于无权图，用1或0表示相邻否；对带权图，则为权值类型
	    this.adj = typeof adj === 'number' ? adj : Infinity;
	    // 该弧相关信息
	    this.info = info;
	};
	
	var AdjacencyMatrixGraph = function () {
	    /**
	     *
	     * @param {Array} vexs 顶点向量
	     * @param {Array | ArcCell} arcs 邻接矩阵
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	    function AdjacencyMatrixGraph() {
	        var vexs = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var arcs = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	        var vexnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var arcnum = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	        var kind = arguments.length <= 4 || arguments[4] === undefined ? DG : arguments[4];
	        (0, _classCallCheck3.default)(this, AdjacencyMatrixGraph);
	
	        // 顶点向量
	        this.vexs = vexs;
	        // 邻接矩阵
	        this.arcs = arcs;
	        // 图的当前顶点数
	        this.vexnum = vexnum;
	        // 图的当前弧数
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    AdjacencyMatrixGraph.prototype.createGraph = function createGraph() {
	        switch (this.kind) {
	            case DG:
	                return createDG(this); // 构造有向图
	            case DN:
	                return createDN(this); // 构造有向网
	            case UDG:
	                return createUDG(this); // 构造无向图
	            case UDN:
	                return createUDN(this); // 构造无向网
	            default:
	                throw new Error('非有效的图类型');
	        }
	    };
	
	    /**
	     * 查找顶点
	     * @param {*} vp 顶点向量
	     * @returns {number}
	     */
	
	
	    AdjacencyMatrixGraph.prototype.locateVex = function locateVex(vp) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.vexs[i] === vp) return i;
	        }
	
	        return -1;
	    };
	
	    /**
	     * 向图中增加顶点
	     * @param {*} vp 顶点向量
	     */
	
	
	    AdjacencyMatrixGraph.prototype.addVertex = function addVertex(vp) {
	        if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	        var k = this.vexnum;
	        this.vexs[this.vexnum++] = vp;
	
	        var value = this.kind === DG || this.kind === UDG ? 0 : Infinity;
	        for (var j = 0; j < this.vexnum; ++j) {
	            this.arcs[j] = this.arcs[j] || [];
	            this.arcs[k] = this.arcs[k] || [];
	            this.arcs[j][k] = this.arcs[j][k] || new ArcCell();
	            this.arcs[k][j] = this.arcs[k][j] || new ArcCell();
	            this.arcs[j][k].adj = this.arcs[k][j].adj = value;
	        }
	    };
	
	    /**
	     * 向图中增加一条弧
	     * @param {*} vex1 顶点1向量
	     * @param {*} vex2 顶点2向量
	     * @param {ArcCell} arc
	     * @returns {boolean}
	     */
	
	
	    AdjacencyMatrixGraph.prototype.addArc = function addArc(vex1, vex2, arc) {
	        arc = arc || new ArcCell(this.kind === DG || this.kind === UDG ? 1 : 'weight');
	        var k = this.locateVex(vex1);
	        var j = this.locateVex(vex2);
	
	        if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	        this.arcs[k][j].adj = arc.adj;
	        this.arcs[k][j].info = arc.info;
	        // 无向图或无向网
	        if (this.kind === UDG || this.kind === UDN) {
	            this.arcs[j][k].adj = arc.adj;
	            this.arcs[j][k].info = arc.info;
	        }
	
	        ++this.arcnum;
	
	        return true;
	    };
	
	    /**
	     * 删除顶点
	     * @param {String} vex 要删除的顶点
	     */
	
	
	    AdjacencyMatrixGraph.prototype.deleteVex = function deleteVex(vex) {
	        var n = this.vexnum - 1;
	        var m = this.locateVex(vex);
	
	        if (m < 0) return false;
	
	        // 将待删除顶点交换到最后一个顶点
	        var temp = this.vexs[m];
	        this.vexs[m] = this.vexs[n];
	        this.vexs[n] = temp;
	
	        // 将边的关系随之交换
	        for (var i = 0; i <= n; ++i) {
	            this.arcs[i][m] = this.arcs[i][n];
	            this.arcs[m][i] = this.arcs[n][i];
	        }
	
	        this.arcs[m][m].adj = 0;
	        this.vexs.length = --this.vexnum;
	        return true;
	    };
	
	    /**
	     * 删除边(v, w)
	     * @param {String} v
	     * @param {String} w
	     * @returns {boolean}
	     */
	
	
	    AdjacencyMatrixGraph.prototype.deleteArc = function deleteArc(v, w) {
	        var i = this.locateVex(v);
	        var j = this.locateVex(w);
	
	        if (i < 0 || j < 0) return false;
	
	        if (this.arcs[i][j].adj) {
	            this.arcs[i][j].adj = 0;
	            this.arcnum--;
	        }
	
	        return true;
	    };
	
	    // 判断一个邻接矩阵存储的有向图是否可传递
	
	
	    AdjacencyMatrixGraph.prototype.isPass = function isPass() {
	        if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	        for (var x = 0; x < this.vexnum; ++x) {
	            for (var y = 0; y < this.vexnum; ++y) {
	                if (this.arcs[x][y]) {
	                    for (var z = 0; z < this.vexnum; ++z) {
	                        if (z !== x && this.arcs[y][z] && !this.arcs[x][z]) return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    };
	
	    AdjacencyMatrixGraph.prototype.firstAdjVex = function firstAdjVex(v) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	        }
	
	        return -1;
	    };
	
	    AdjacencyMatrixGraph.prototype.nextAdjVex = function nextAdjVex(v, w) {
	        for (var i = w + 1; i < this.vexnum; ++i) {
	            if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	        }
	
	        return -1;
	    };
	
	    // 对邻接矩阵图作递归式深度优先遍历
	
	
	    AdjacencyMatrixGraph.prototype.DFSTraverse = function DFSTraverse(visitFn) {
	        var visited = [];
	        // 访问标志数组初始化
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        }for (var _i = 0; _i < this.vexnum; ++_i) {
	            if (!visited[_i]) dfs(this, _i);
	        }
	
	        function dfs(graph, vertex) {
	            visited[vertex] = true;
	            visitFn.call(graph, vertex);
	
	            for (var j = 0; j < graph.vexnum; ++j) {
	                if (graph.arcs[vertex][j].adj !== 0 && graph.arcs[vertex][j].adj !== Infinity && !visited[j]) dfs(graph, j);
	            }
	        }
	    };
	
	    // 非递归
	
	
	    AdjacencyMatrixGraph.prototype.DFSTraverse_NonRecurse = function DFSTraverse_NonRecurse(visitFn) {
	        var visited = [];
	        var stack = new _index2.default();
	        var me = this;
	        // 访问标志数组初始化
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        }for (var _i2 = 0; _i2 < this.vexnum; ++_i2) {
	            if (!visited[_i2]) {
	                stack.push(_i2);
	                visited[_i2] = true;
	                visitFn.call(me, _i2);
	
	                var vertex = void 0;
	                while ((vertex = stack.peek()) != null) {
	                    for (var j = 0; j < this.vexnum; ++j) {
	                        if (this.arcs[vertex][j].adj !== 0 && this.arcs[vertex][j].adj !== Infinity && !visited[j]) {
	                            visitFn.call(me, j);
	                            visited[j] = true;
	                            stack.push(j);
	                        } else stack.pop();
	                    }
	                }
	            }
	        }
	    };
	
	    // 对邻接矩阵图作广度优先遍历
	
	
	    AdjacencyMatrixGraph.prototype.BFSTraverse = function BFSTraverse(visitFn) {
	        var visited = [];
	        var queue = new _Queue2.default();
	
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        }for (var _i3 = 0; _i3 < this.vexnum; ++_i3) {
	            if (!visited[_i3]) {
	                visited[_i3] = true;
	                visitFn.call(this, _i3);
	                queue.enQueue(_i3);
	
	                while (queue.rear) {
	                    var u = queue.deQueue();
	
	                    for (var j = 0; j < this.vexnum; ++j) {
	                        if (this.arcs[u][j].adj !== 0 && this.arcs[u][j].adj !== Infinity && !visited[j]) {
	                            visited[j] = true;
	                            visitFn.call(this, j);
	                            queue.enQueue(j);
	                        }
	                    }
	                }
	            }
	        }
	    };
	
	    AdjacencyMatrixGraph.prototype.minSpanTree_PRIM = function minSpanTree_PRIM(u) {
	        var closedge = [];
	
	        // 初始化
	        for (var j = 0; j < this.vexnum; ++j) {
	            closedge[j] = { adjvex: u, lowcost: +this.arcs[j][u].adj };
	        }
	        closedge[u].lowcost = 0;
	
	        var te = [];
	        // 选择其余this.vexnum - 1个顶点
	        for (var _j = 0; _j < this.vexnum - 1; ++_j) {
	            var min = Infinity;
	            var k = void 0;
	            for (var v = 0; v < this.vexnum; ++v) {
	                if (closedge[v].lowcost !== 0 && closedge[v].lowcost < min) {
	                    min = closedge[v].lowcost;
	                    k = v;
	                }
	            }
	
	            te[_j] = {
	                vex1: closedge[k].adjvex,
	                vex2: k,
	                weight: closedge[k].lowcost
	            };
	            closedge[k].lowcost = 0;
	            for (var _v = 0; _v < this.vexnum; ++_v) {
	                if (this.arcs[_v][k].adj < closedge[_v].lowcost) {
	                    closedge[_v].lowcost = this.arcs[_v][k].adj;
	                    closedge[_v].adjvex = k;
	                }
	            }
	        }
	
	        return te;
	    };
	
	    AdjacencyMatrixGraph.prototype.minSpanTree_Kruskal = function minSpanTree_Kruskal() {
	        var set = [];
	        var te = [];
	
	        for (var i = 0; i < this.vexnum; ++i) {
	            set[i] = i;
	        }var k = 0;
	        var min = Infinity;
	        var a = 0;
	        var b = 0;
	        while (k < this.vexnum - 1) {
	            for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                for (var j = _i4 + 1; j < this.vexnum; ++j) {
	                    if (this.arcs[_i4][j].adj < min) {
	                        min = this.arcs[_i4][j].adj;
	                        a = _i4;
	                        b = j;
	                    }
	                }
	            }
	
	            if (set[a] !== set[b]) {
	                te[k++] = {
	                    vex1: a,
	                    vex2: b,
	                    weight: this.arcs[a][b].adj
	                };
	
	                for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                    if (set[_i5] === set[b] && _i5 !== b) set[_i5] = set[a];
	                }
	                set[b] = set[a];
	            }
	
	            min = this.arcs[a][b].adj = Infinity;
	        }
	
	        return te;
	    };
	
	    /**
	     * 用Dijkstra算法求有向网的v0顶点到其余顶点v的最短路径pre[v]及其带权长度dist[v]。
	     * 若pre[v][w]为true，则w是从v0到v当前求得最短路径上的顶点。
	     * final[v]为true当且仅当v∈S，即已经求得v0到v的最短路径
	     * @param v0
	     */
	
	
	    AdjacencyMatrixGraph.prototype.shortestPath_Dijkstra = function shortestPath_Dijkstra(v0) {
	        var pre = [];
	        var dist = [];
	        var final = [];
	        var w = void 0,
	            v = void 0;
	
	        for (var _v2 = 0; _v2 < this.vexnum; ++_v2) {
	            final[_v2] = false;
	            dist[_v2] = this.arcs[v0][_v2].adj;
	            pre[_v2] = pre[_v2] || [];
	            // 设空路径
	            for (w = 0; w < this.vexnum; ++w) {
	                pre[_v2][w] = false;
	            }if (dist[_v2] < Infinity) {
	                pre[_v2][v0] = true;
	                pre[_v2][_v2] = true;
	            }
	        }
	
	        // 初始化，v0顶点属于S集
	        dist[v0] = 0;
	        final[v0] = true;
	
	        // 开始主循环，每次求得v0到某个v顶点的最短路径，并加v到S集
	
	        // 其余的顶点
	        for (var i = 1; i < this.vexnum; ++i) {
	            var min = Infinity;
	            // 当前所指离v0顶点的最近距离
	            for (w = 0; w < this.vexnum; ++w) {
	                // w顶点在V - S中
	                // 且w顶点离v0顶点更近
	                if (!final[w] && dist[w] < min) {
	                    v = w;
	                    min = dist[w];
	                }
	            }
	
	            // 离v0顶点最近的v加入S集
	            final[v] = true;
	            // 更新当前最短路径及距离
	            for (w = 0; w < this.vexnum; ++w) {
	                if (!final[w] && min + this.arcs[v][w].adj < dist[w]) {
	                    dist[w] = min + this.arcs[v][w].adj;
	                    pre[w] = pre[v];
	                    pre[w][w] = true;
	                }
	            }
	        }
	
	        console.log(final);
	        console.log(pre);
	        console.log(dist);
	
	        return {
	            final: final,
	            pre: pre,
	            dist: dist
	        };
	    };
	
	    AdjacencyMatrixGraph.prototype.shortestPath_FLOYD = function shortestPath_FLOYD() {
	        var a = [];
	        var path = [];
	
	        for (var j = 0; j < this.vexnum; ++j) {
	            a[j] = a[j] || [];
	            path[j] = path[j] || [];
	            for (var k = 0; k < this.vexnum; ++k) {
	                if (j === k) a[j][k] = 0;else a[j][k] = this.arcs[j][k].adj;
	                path[j][k] = -1;
	            }
	        }
	
	        for (var m = 0; m < this.vexnum; ++m) {
	            for (var _j2 = 0; _j2 < this.vexnum; ++_j2) {
	                for (var _k = 0; _k < this.vexnum; ++_k) {
	                    if (a[_j2][m] + a[m][_k] < a[_j2][_k]) {
	                        a[_j2][_k] = a[_j2][m] + a[m][_k];
	                        path[_j2][_k] = m;
	                    }
	                }
	            }
	        }
	
	        for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	            for (var _k2 = 0; _k2 < this.vexnum; ++_k2) {
	                if (_j3 !== _k2) {
	                    console.log('%d到%d的最短路径为：', _j3, _k2);
	                    console.log('%d ', _j3);prn_pass(_j3, _k2);
	                    console.log('%d ', _k2);
	                    console.log('最短路径长度为： %d', a[_j3][_k2]);
	                }
	            }
	        }
	
	        function prn_pass(j, k) {
	            if (path[j][k] !== -1) {
	                prn_pass(j, path[j][k]);
	                console.log(', %d', path[j][k]);
	                prn_pass(path[j][k], k);
	            }
	        }
	    };
	
	    return AdjacencyMatrixGraph;
	}();
	
	exports.default = AdjacencyMatrixGraph;
	
	
	var createDG = createGraph(DG);
	var createDN = createGraph(DN);
	var createUDG = createGraph(UDG);
	var createUDN = createGraph(UDN);
	
	function createGraph(kind) {
	    var adj = void 0;
	    var setMatrixValue = void 0;
	
	    if (kind === 2 || kind === 4) {
	        adj = Infinity;
	        setMatrixValue = function setMatrixValue() {
	            return prompt('weight: ');
	        };
	    } else {
	        adj = 0;
	        setMatrixValue = function setMatrixValue() {
	            return 1;
	        };
	    }
	
	    return function (AdjacencyMatrixGraph) {
	        AdjacencyMatrixGraph.vexnum = parseInt(prompt('vexnum: '), 10);
	        AdjacencyMatrixGraph.arcnum = parseInt(prompt('arcnum: '), 10);
	        // incInfo为0则各弧不含其他信息
	        var incInfo = parseInt(prompt('incInfo: '), 10);
	
	        // 构造顶点向量
	        var i = void 0,
	            j = void 0;
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            AdjacencyMatrixGraph.vexs[i] = prompt('顶点向量vex: ');
	        } // 初始化邻接矩阵
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            for (j = 0; j < AdjacencyMatrixGraph.vexnum; ++j) {
	                AdjacencyMatrixGraph.arcs[i] = AdjacencyMatrixGraph.arcs[i] || [];
	                AdjacencyMatrixGraph.arcs[i][j] = new ArcCell(adj, null);
	            }
	        }
	
	        // 构造邻接矩阵
	        for (var k = 0; k < AdjacencyMatrixGraph.arcnum; ++k) {
	            // 输入一条边依附的顶点及权值
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            // 确定v1，v2在G中的位置
	            i = AdjacencyMatrixGraph.locateVex(v1);
	            j = AdjacencyMatrixGraph.locateVex(v2);
	
	            var w = setMatrixValue();
	            // 弧<v1, v2>的权值
	            AdjacencyMatrixGraph.arcs[i][j].adj = w;
	            if (incInfo) AdjacencyMatrixGraph.arcs[i][j].info = prompt('info: ');
	            if (kind === 3 || kind === 4) AdjacencyMatrixGraph.arcs[j][i] = AdjacencyMatrixGraph.arcs[i][j];
	        }
	    };
	}
	
	// 第一种创建图方法
	var vexs = ['a', 'b', 'c', 'd', 'e'];
	var arcs = [[{ "adj": Infinity, "info": null }, { "adj": "6", "info": null }, { "adj": "2", "info": null }, { "adj": Infinity, "info": null }, { "adj": Infinity, "info": null }], [{ "adj": "6", "info": null }, { "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": "4", "info": null }, { "adj": "3", "info": null }], [{ "adj": "2", "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "4", "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }, { "adj": Infinity, "info": null }]];
	var udn = new AdjacencyMatrixGraph(vexs, arcs, 5, 7, 4);
	
	// 第二种创建图方法
	var dn = new AdjacencyMatrixGraph([], [], 0, 0, 2);
	dn.addVertex('a');
	dn.addVertex('b');
	dn.addVertex('c');
	dn.addVertex('d');
	dn.addVertex('e');
	
	dn.addArc('a', 'b', {
	    adj: 6
	});
	dn.addArc('a', 'c', {
	    adj: 2
	});
	dn.addArc('c', 'b', {
	    adj: 3
	});
	dn.addArc('c', 'd', {
	    adj: 1
	});
	dn.addArc('d', 'b', {
	    adj: 4
	});
	dn.addArc('b', 'e', {
	    adj: 3
	});
	dn.addArc('d', 'e', {
	    adj: 5
	});
	
	console.log(dn);
	
	/*
	
	 // 第三种创建图方法
	 let g = new AdjacencyMatrixGraph();
	 g.kind = DN;
	 g.createGraph();
	 console.log(g);
	
	 */
	
	/*
	 图的遍历
	
	 图的遍历(Travering Graph)：从图的某一顶点出发，访遍图中的其余顶点，且每个顶点仅被访问一次。图的遍历算法是各种图的操作的基础。
	
	 ◆ 复杂性：图的任意顶点可能和其余的顶点相邻接，可能在访问了某个顶点后，沿某条路径搜索后又回到原顶点。
	 ◆ 解决办法：在遍历过程中记下已被访问过的顶点。设置一个辅助向量Visited[1…n](n为顶点数)，其初值为0，一旦访问了顶点vi后，使Visited[i]为1或为访问的次序号。
	 图的遍历算法有深度优先搜索算法和广度优先搜索算法。
	
	 深度优先搜索(Depth First Search--DFS)遍历类似树的先序遍历，是树的先序遍历的推广。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；然后找到vi的一个邻接顶点vi1 ；
	 ⑵：从vi1出发，深度优先搜索访问和vi1相邻接且未被访问的所有顶点；
	 ⑶：转⑴ ，直到和vi相邻接的所有顶点都被访问为止
	 ⑷ ：继续选取图中未被访问顶点vj作为起始顶点，转(1)，直到图中所有顶点都被访问为止。
	
	
	 广度优先搜索(Breadth First Search--BFS)遍历类似树的按层次遍历的过程。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；
	 ⑵：访问vi的所有相邻接且未被访问的所有顶点vi1，vi2，…，vim；
	 ⑶：以vi1，vi2， …，vim的次序，以vij(1≦j≦m)依此作为vi ，转⑴；
	 ⑷ ：继续选取图中未被访问顶点vk作为起始顶点，转⑴，直到图中所有顶点都被访问为止。
	
	 用广度优先搜索算法遍历图与深度优先搜索算法遍历图的唯一区别是邻接点搜索次序不同.
	 */
	
	console.log('DFSTraverse: udn');
	
	var g1 = new AdjacencyMatrixGraph([], [], 0, 0, UDG);
	g1.addVertex('v1');
	g1.addVertex('v3');
	g1.addVertex('v2');
	g1.addVertex('v4');
	g1.addVertex('v5');
	
	g1.addArc('v5', 'v4');
	g1.addArc('v3', 'v1');
	g1.addArc('v2', 'v1');
	g1.addArc('v3', 'v2');
	
	g1.DFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('DFSTraverse_NonRecurse: udn');
	g1.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('BFSTraverse: ');
	var bsfG = new AdjacencyMatrixGraph([], [], 0, 0, DG);
	bsfG.addVertex('v1');
	bsfG.addVertex('v2');
	bsfG.addVertex('v3');
	bsfG.addVertex('v4');
	bsfG.addVertex('v5');
	
	bsfG.addArc('v1', 'v4');
	bsfG.addArc('v1', 'v2');
	bsfG.addArc('v3', 'v5');
	bsfG.addArc('v3', 'v2');
	bsfG.addArc('v3', 'v1');
	bsfG.addArc('v4', 'v3');
	bsfG.addArc('v5', 'v4');
	
	bsfG.BFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	/*
	 最小生成树
	
	 如果连通图是一个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。
	
	 最小生成树(Minimum Spanning Tree) ：带权连通图中代价最小的生成树称为最小生成树。
	
	 最小生成树在实际中具有重要用途，如设计通信网。设图的顶点表示城市，边表示两个城市之间的通信线路，边的权值表示建造通信线路的费用。n个城市之间最多可以建n(n-1)/2条线路，如何选择其中的n-1条，使总的建造费用最低?
	
	 构造最小生成树的算法有许多，基本原则是：
	 ◆ 尽可能选取权值最小的边，但不能构成回路；
	 ◆ 选择n-1条边构成最小生成树。
	 以上的基本原则是基于MST的如下性质：
	 设G=(V，E)是一个带权连通图，U是顶点集V的一个非空子集。若u∈U ，v∈V-U，且(u, v)是U中顶点到V-U中顶点之间权值最小的边，则必存在一棵包含边(u, v)的最小生成树。
	
	 证明： 用反证法证明。
	 设图G的任何一棵最小生成树都不包含边(u,v)。设T是G的一棵生成树，则T是连通的，从u到v必有一条路径(u,…,v)，当将边(u,v)加入到T中时就构成了回路。则路径(u, …,v)中必有一条边(u’,v’) ，满足u’∈U ，v’∈V-U 。删去边(u’,v’) 便可消除回路，同时得到另一棵生成树T’。
	 由于(u,v)是U中顶点到V-U中顶点之间权值最小的边，故(u,v)的权值不会高于(u’,v’)的权值，T’的代价也不会高于T， T’是包含(u,v) 的一棵最小生成树，与假设矛盾。
	
	 */
	
	/*
	 普里姆(Prim)算法
	
	 适合边稠密的网
	
	 从连通网N=(U，E)中找最小生成树T=(U，TE) 。
	
	 1 算法思想
	 ⑴  若从顶点v0出发构造，U={v0}，TE={}；
	 ⑵ 先找权值最小的边(u，v)，其中u∈U且v∈V-U，并且子图不构成环，则U= U∪{v}，TE=TE∪{(u，v)} ；
	 ⑶ 重复⑵ ，直到U=V为止。则TE中必有n-1条边， T=(U，TE)就是最小生成树。
	
	 2.算法实现说明
	 为便于算法实现，设置一个一维数组closedge[n]，用来保存V- U中各顶点到U中顶点具有权值最小的边。
	 closedge[j].adjvex=k，表明边(vj, vk)是V-U中顶点vj到U中权值最小的边，而顶点vk是该边所依附的U中的顶点。 closedge[j].lowcost存放该边的权值。
	 假设从顶点vs开始构造最小生成树。初始时令：
	 Closedge[s].lowcost=0 ：表明顶点vs首先加入到U中；
	 Closedge[k].adjvex=s ，Closedge[k].lowcost=cost(k, s)
	 表示V-U中的各顶点到U中权值最小的边(k≠s) ，cost(k, s)表示边(vk, vs) 权值。
	
	 3.算法步骤
	 ⑴  从closedge中选择一条权值(不为0)最小的边(vk, vj) ，然后做：
	 ① 置closedge[k].lowcost为0 ，表示vk已加入到U中。
	 ②  根据新加入vk的更新closedge中每个元素：
	 vi∈V-U ，若cost(i, k)≦colsedge[i].lowcost，表明在U中新加入顶点vk后， (vi, vk)成为vi到U中权值最小的边，置：
	 Closedge[i].lowcost=cost(i, k)
	 Closedge[i].adjvex=k
	 ⑵  重复⑴n-1次就得到最小生成树。
	
	 算法分析：
	 设带权连通图有n个顶点，则算法的主要执行是二重循环： 求closedge中权值最小的边，频度为n-1； 修改closedge数组，频度为n 。因此，整个算法的时间复杂度是O(n2)，与边的数目无关。
	
	 */
	
	udn = new AdjacencyMatrixGraph([], [], 0, 0, 4);
	udn.addVertex('v1');
	udn.addVertex('v2');
	udn.addVertex('v3');
	udn.addVertex('v4');
	udn.addVertex('v5');
	udn.addVertex('v6');
	
	udn.addArc('v1', 'v2', { adj: 6 });
	udn.addArc('v1', 'v3', { adj: 1 });
	udn.addArc('v1', 'v4', { adj: 5 });
	udn.addArc('v2', 'v3', { adj: 5 });
	udn.addArc('v2', 'v5', { adj: 3 });
	udn.addArc('v3', 'v4', { adj: 5 });
	udn.addArc('v3', 'v5', { adj: 6 });
	udn.addArc('v3', 'v6', { adj: 4 });
	udn.addArc('v4', 'v6', { adj: 2 });
	udn.addArc('v5', 'v6', { adj: 6 });
	
	console.log('minSpanTree_PRIM: ');
	console.log(udn.minSpanTree_PRIM(0));
	
	/*
	 克鲁斯卡尔(Kruskal)算法
	
	 适合边稀疏的网
	
	 1 算法思想
	 设G=(V, E)是具有n个顶点的连通网，T=(U, TE)是其最小生成树。初值：U=V，TE={} 。
	 对G中的边按权值大小从小到大依次选取。
	 ⑴   选取权值最小的边(vi，vj)，若边(vi，vj)加入到TE后形成回路，则舍弃该边(边(vi，vj) ；否则，将该边并入到TE中，即TE=TE∪{(vi，vj)} 。
	 ⑵ 重复⑴ ，直到TE中包含有n-1条边为止。
	 如图7-22所提示。
	
	 2 算法实现说明
	 Kruskal算法实现的关键是：当一条边加入到TE的集合后，如何判断是否构成回路?
	 简单的解决方法是：定义一个一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。
	 ◆ 初值：Vset[i]=i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。
	 ◆ 当往T中增加一条边(vi，vj) 时，先检查Vset[i]和Vset[j]值：
	 ☆ 若Vset[i]=Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路；
	 ☆ 若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。
	 ◆ 加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号。
	
	 */
	
	console.log('minSpanTree_Kruskal: ');
	console.log(udn.minSpanTree_Kruskal());
	
	/*
	 最短路径
	
	 若用带权图表示交通网，图中顶点表示地点，边代表两地之间有直接道路，边上的权值表示路程(或所花费用或时间) 。从一个地方到另一个地方的路径长度表示该路径上各边的权值之和。问题：
	 ◆ 两地之间是否有通路?
	 ◆ 在有多条通路的情况下，哪条最短?
	 考虑到交通网的有向性，直接讨论的是带权有向图的最短路径问题，但解决问题的算法也适用于无向图。
	 将一个路径的起始顶点称为源点，最后一个顶点称为终点。
	
	
	 单源点最短路径
	
	 对于给定的有向图G=(V，E)及单个源点Vs，求Vs到G的其余各顶点的最短路径。
	 针对单源点的最短路径问题，Dijkstra提出了一种按路径长度递增次序产生最短路径的算法，即迪杰斯特拉(Dijkstra)算法。
	
	 1 基本思想
	 从图的给定源点到其它各个顶点之间客观上应存在一条最短路径，在这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。
	 即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，依此类推，直到求出长度最长的最短路径。
	
	 2 算法思想说明
	 设给定源点为Vs，S为已求得最短路径的终点集，开始时令S={Vs} 。当求得第一条最短路径(Vs ，Vi)后，S为{Vs，Vi} 。根据以下结论可求下一条最短路径。
	 设下一条最短路径终点为Vj ，则Vj只有：
	 ◆  源点到终点有直接的弧<Vs，Vj>；
	 ◆ 从Vs 出发到Vj 的这条最短路径所经过的所有中间顶点必定在S中。即只有这条最短路径的最后一条弧才是从S内某个顶点连接到S外的顶点Vj 。
	 若定义一个数组dist[n]，其每个dist[i]分量保存从Vs 出发中间只经过集合S中的顶点而到达Vi的所有路径中长度最小的路径长度值，则下一条最短路径的终点Vj必定是不在S中且值最小的顶点，即：
	 dist[i]=Min{ dist[k]| Vk∈V-S }
	 利用上述公式就可以依次找出下一条最短路径。
	
	 3  算法步骤
	 ① 令S={Vs} ，用带权的邻接矩阵表示有向图，对图中每个顶点Vi按以下原则置初值：
	 0    i =s
	 dist[i] =   Wsi     i≠s且<vs,vi>∈E， wsi为弧上的权值
	 ∞   i≠s且<vs,vi>不属于E
	 ② 选择一个顶点Vj ，使得：
	 dist[j]=Min{ dist[k]| Vk∈V-S }
	 Vj就是求得的下一条最短路径终点，将Vj 并入到S中，即S=S∪{Vj} 。
	 ③ 对V-S中的每个顶点Vk ，修改dist[k]，方法是：
	 若dist[j]+Wjk<dist[k]，则修改为：
	 dist[k]=dist[j]+Wjk (Vk∈V-S )
	 ④ 重复②，③，直到S=V为止。
	
	 4 算法实现
	 用带权的邻接矩阵表示有向图， 对Prim算法略加改动就成了Dijkstra算法，将Prim算法中求每个顶点Vk的lowcost值用dist[k]代替即可。
	 ◆  设数组pre[n]保存从Vs到其它顶点的最短路径。若pre[i]=k，表示从Vs 到Vi的最短路径中，Vi的前一个顶点是Vk，即最短路径序列是(Vs , …, Vk  , Vi) 。
	 ◆ 设数组final[n]，标识一个顶点是否已加入S中。
	
	 5  算法分析
	 Dijkstra算法的主要执行是：
	 ◆ 数组变量的初始化：时间复杂度是O(n) ；
	 ◆ 求最短路径的二重循环：时间复杂度是O(n2) ；
	 因此，整个算法的时间复杂度是O(n2) 。
	
	 */
	
	var dijTest = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('0', '1', { adj: 20 });
	dijTest.addArc('0', '4', { adj: 10 });
	dijTest.addArc('0', '2', { adj: 60 });
	dijTest.addArc('0', '5', { adj: 65 });
	dijTest.addArc('1', '2', { adj: 30 });
	dijTest.addArc('2', '3', { adj: 40 });
	dijTest.addArc('5', '2', { adj: 15 });
	dijTest.addArc('4', '5', { adj: 20 });
	dijTest.addArc('3', '4', { adj: 35 });
	dijTest.addArc('1', '3', { adj: 70 });
	
	dijTest.shortestPath_Dijkstra(0);
	
	/*
	 每一对顶点间的最短路径
	
	 用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。方法是：每次以一个不同的顶点为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，时间复杂度是O(n3) 。
	
	 弗罗伊德(Floyd)提出了另一个算法，其时间复杂度仍是O(n3) ， 但算法形式更为简明。
	
	 1 算法思想
	
	 设顶点集S(初值为空)，用数组A的每个元素A[i][j]保存从Vi只经过S中的顶点到达Vj的最短路径长度，其思想是：
	 ① 初始时令S={ } ， A[i][j]的赋初值方式是：
	 0    i =j时
	 A[i][j]=    Wij     i≠j且<vi,vj>∈E， wij为弧上的权值
	 ∞   i≠j且<vi,vj>不属于E
	 ② 将图中一个顶点Vk 加入到S中，修改A[i][j]的值，修改方法是：
	 A[i][j]=Min{A[i][j] , (A[i][k]+A[k][j]) }
	 原因： 从Vj只经过S中的顶点(Vk)到达Vj的路径长度可能比原来不经过Vk的路径更短。
	 ③ 重复②，直到G的所有顶点都加入到S中为止。
	
	 2 算法实现
	
	 ◆  定义二维数组Path[n][n](n为图的顶点数) ，元素Path[i][j]保存从Vi到Vj的最短路径所经过的顶点。
	 ◆ 若Path[i][j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径子序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i][k]和Path[k][j]的值再找到该路径上所经过的其它顶点，…依此类推。
	 ◆ 初始化为Path[i][j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i][j]变小时，令Path[i][j]=k。
	
	
	 */
	
	var floyd = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	floyd.addVertex('v0');
	floyd.addVertex('v1');
	floyd.addVertex('v2');
	floyd.addArc('v0', 'v2', { adj: 8 });
	floyd.addArc('v0', 'v1', { adj: 2 });
	floyd.addArc('v1', 'v2', { adj: 4 });
	floyd.addArc('v2', 'v0', { adj: 5 });
	
	floyd.shortestPath_FLOYD();
	
	// http://blog.csdn.net/hguisu/article/details/7719428
	// 添加《图的应用详解-数据结构》

/***/ },
/* 115 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = OLGraph;
	/*
	 十字链表法
	
	 十字链表(Orthogonal List)是有向图的另一种链式存储结构，是将有向图的正邻接表和逆邻接表结合起来得到的一种链表。
	
	 在这种结构中，每条弧的弧头结点和弧尾结点都存放在链表中，并将弧结点分别组织到以弧尾结点为头(顶点)结点和以弧头结点为头(顶点)结点的链表中。
	
	 ◆  data域：存储和顶点相关的信息；
	 ◆ 指针域firstin：指向以该顶点为弧头的第一条弧所对应的弧结点；
	 ◆ 指针域firstout：指向以该顶点为弧尾的第一条弧所对应的弧结点；
	 ◆ 尾域tailvex：指示弧尾顶点在图中的位置；
	 ◆ 头域headvex：指示弧头顶点在图中的位置；
	 ◆ 指针域hlink：指向弧头相同的下一条弧；
	 ◆ 指针域tlink：指向弧尾相同的下一条弧；
	 ◆ Info域：指向该弧的相关信息；
	
	 从这种存储结构图可以看出，从一个顶点结点的firstout出发，沿表结点的tlink指针构成了正邻接表的链表结构，而从一个顶点结点的firstin出发，沿表结点的hlink指针构成了逆邻接表的链表结构。
	
	 */
	
	/**
	 *
	 * @param {Number} headVex 弧的头顶点的位置
	 * @param {Number} tailVex 弧的尾顶点位置
	 * @param {ArcBox} hLink 弧头相同的弧的链域
	 * @param {ArcBox} tLink 弧尾相同的弧的链域
	 * @param {*} info
	 * @constructor
	 */
	function ArcBox(tailVex, headVex, hLink, tLink, info) {
	    this.headVex = headVex || 0;
	    this.tailVex = tailVex || 0;
	    this.hLink = hLink || null;
	    this.tLink = tLink || null;
	    this.info = info || null;
	}
	
	/**
	 *
	 * @param {*} data
	 * @param {ArcBox} firstIn 该顶点第一条入弧
	 * @param {ArcBox} firstOut 该顶点第一条出弧
	 * @constructor
	 */
	function OLVexNode(data, firstIn, firstOut) {
	    this.data = data || null;
	    this.firstIn = firstIn || null;
	    this.firstOut = firstOut || null;
	}
	
	/**
	 *
	 * @param {Array | OLVexNode} xList 表头向量
	 * @param {Number} vexnum 有向图的当前顶点数
	 * @param {Number} arcnum 有向图的当前弧数
	 * @constructor
	 */
	function OLGraph(xList, vexnum, arcnum) {
	    this.xList = xList || [];
	    this.vexnum = vexnum || 0;
	    this.arcnum = arcnum || 0;
	}
	OLGraph.prototype = {
	    constructor: OLGraph,
	
	    locateVex: function locateVex(vp) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.xList[i].data === vp) return i;
	        }
	
	        return -1;
	    },
	
	    // 删除顶点
	    deleteVertex: function deleteVertex(v) {
	        var m = this.locateVex(v);
	
	        if (m < 0) throw new Error('vertex not found!');
	
	        var n = this.vexnum;
	        var q, i, p;
	        // 删除所有以v为头的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是头链上的第一个结点
	            if (this.xList[i].firstIn.tailVex === m) {
	                q = this.xList[i].firstIn;
	                this.xList[i].firstIn = q.hLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstIn; p && p.hLink.tailVex !== m; p = p.hLink) {}
	                if (p) {
	                    q = p.hLink;
	                    p.hLink = q.hLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 删除所有以v为尾的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是尾链上的第一个结点
	            if (this.xList[i].firstOut.headVex === m) {
	                q = this.xList[i].firstOut;
	                this.xList[i].firstOut = q.tLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstOut; p && p.tLink.headVex !== m; p = p.tLink) {}
	                if (p) {
	                    q = p.tLink;
	                    p.tLink = q.tLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 顺次用结点m之后的顶点取代前一个顶点
	        for (i = m; i < n; ++i) {
	            // 修改表头向量
	            this.xList[i] = this.xList[i + 1];
	            for (p = this.xList[i].firstIn; p; p = p.hLink) {
	                p.headVex--;
	            }for (p = this.xList[i].firstOut; p; p = p.tLink) {
	                p.tailVex--;
	            }
	        }
	
	        this.vexnum--;
	        return true;
	    },
	
	    createDG: function createDG() {
	        this.vexnum = prompt('Vexnum: ');
	        this.arcnum = prompt('Arcnum: ');
	        // IncInfo为0则各弧不含其他信息
	        var incInfo = +prompt('IncInfo: ');
	
	        // 输入顶点值
	        for (var i = 0; i < this.vexnum; ++i) {
	            this.xList[i] = new OLVexNode(prompt('data: '), null, null);
	        }
	
	        for (var k = 0; k < this.arcnum; ++k) {
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            i = this.locateVex(v1);
	            var j = this.locateVex(v2);
	
	            if (i === -1 || j === -1) {
	                alert('无此顶点，请重新输入!');
	                k--;
	                continue;
	            }
	
	            var p = new ArcBox(i, j, this.xList[j].firstIn, this.xList[i].firstOut, incInfo && prompt('info: '));
	            this.xList[j].firstIn = this.xList[i].firstOut = p;
	        }
	    },
	
	    /**
	     * 求有向图的强连通分量
	     */
	    getSGraph: function getSGraph() {
	        var visited = [];
	        var finished = [];
	        var count = 0;
	
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第一次深度优先遍历建立finished数组
	        for (i = 0; i < this.vexnum; ++i) {
	            if (!visited[i]) dfs1(this, i);
	        }
	        // 清空visited数组
	        for (i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第二次逆向的深度优先遍历
	        for (var len = this.vexnum - 1; len >= 0; --len) {
	            i = finished[i];
	            if (!visited[i]) dfs2(this, i);
	        }
	
	        function dfs1(graph, v) {
	            visited[v] = true;
	            for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	                var w = p.headVex;
	                if (!visited[w]) dfs1(graph, w);
	            }
	            finished[++count] = v;
	        }
	
	        function dfs2(graph, v) {
	            visited[v] = true;
	            console.log('%d', v);
	            for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	                var w = p.tailVex;
	                if (!visited[w]) dfs2(graph, w);
	            }
	        }
	    }
	};
	
	//var g = new OLGraph();
	//g.createDG();
	//console.log(g);
	
	
	/*
	 有向图的强连通分量
	
	 对于有向图，在其每一个强连通分量中，任何两个顶点都是可达的。 V∈G，与V可相互到达的所有顶点就是包含V的强连通分量的所有顶点。
	
	 设从V可到达 (以V为起点的所有有向路径的终点)的顶点集合为T1(G)，而到达V (以V为终点的所有有向路径的起点)的顶点集合为T2(G)，则包含V的强连通分量的顶点集合是： T1(G)∩T2(G) 。
	
	 求有向图G的强连通分量的基本步骤是：
	 ⑴ 对G进行深度优先遍历，生成G的深度优先生成森林T。
	 ⑵  对森林T的顶点按中序遍历顺序进行编号。
	 ⑶  改变G中每一条弧的方向，构成一个新的有向图G’。
	 ⑷  按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。
	 ⑸  重复步骤⑷ ，直到G’中的所有顶点都被访问。
	
	 在算法实现时，建立一个数组in_order[n]存放深度优先生成森林的中序遍历序列。对每个顶点v，在调用DFS函数结束时，将顶点依次存放在数组in_order[n]中。图采用十字链表作为存储结构最合适。
	
	 */
	
	// todo to be tested
	OLGraph.prototype.connected_DG = function () {
	    var visited = [];
	    var in_order = [];
	    var count = 0;
	
	    for (var i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图正向遍历
	    for (i = 0; i < this.vexnum; ++i) {
	        if (!visited[i]) {
	            dfs(this, i, in_order);
	        }
	    }
	
	    for (i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图逆向遍历
	    var k = 1;
	    for (var j = this.vexnum - 1; j >= 0; --j) {
	        var v = in_order[j];
	        if (!visited[v]) {
	            console.log('第' + k++ + '个连通分量顶点');
	            rev_dfs(this, v);
	        }
	    }
	
	    function dfs(graph, v) {
	        visited[v] = true;
	
	        for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	            if (!visited[p.headVex]) {
	                dfs(graph, p.headVex);
	            }
	        }
	
	        in_order[count++] = v;
	    }
	
	    function rev_dfs(graph, v) {
	        visited[v] = true;
	        console.log('顶点：' + v);
	
	        for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	            if (!visited[p.tailVex]) {
	                rev_dfs(graph, p.tailVex);
	            }
	        }
	    }
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(8);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _DoubleLinkedList = __webpack_require__(53);
	
	var _DoubleLinkedList2 = _interopRequireDefault(_DoubleLinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIMIT = 20; /**
	                 * LRU( Least recently used )
	                 */
	
	var LRUCache = function () {
	    function LRUCache(sqList) {
	        var limit = arguments.length <= 1 || arguments[1] === undefined ? LIMIT : arguments[1];
	        (0, _classCallCheck3.default)(this, LRUCache);
	
	        this.limit = limit;
	        sqList = sqList && sqList.length ? sqList && sqList.length.slice(0, this.limit) : [];
	        this.__cache = new _DoubleLinkedList2.default(sqList, function (a, b) {
	            return a.key === b.key;
	        });
	    }
	
	    LRUCache.prototype[Symbol.iterator] = function () {
	        return this.__cache[Symbol.iterator]();
	    };
	
	    LRUCache.prototype.remove = function remove(key) {
	        return this.__cache.remove({ key: key });
	    };
	
	    LRUCache.prototype.clear = function clear() {
	        return this.___cache.clear();
	    };
	
	    LRUCache.prototype.get = function get(key) {
	        var index = this.__cache.indexOf({ key: key });
	
	        if (index >= 0) {
	            var data = this.__cache.findByIndex(index);
	            this.__cache.remove(data);
	            this.__cache.unshift(data);
	
	            return data;
	        }
	
	        return false;
	    };
	
	    LRUCache.prototype.add = function add(key, value) {
	        var data = this.get(key);
	        if (data) {
	            data.value = value;
	        } else {
	            if (this.size === this.limit) {
	                this.__cache.pop();
	            }
	
	            this.__cache.unshift({
	                key: key,
	                value: value
	            });
	        }
	    };
	
	    LRUCache.prototype.toString = function toString() {
	        var arr = [];
	        this.__cache.forEach(function (data) {
	            arr.push(data.key + ':' + data.value);
	        });
	
	        return arr.join(' > ');
	    };
	
	    LRUCache.prototype.toJSON = function toJSON() {
	        return this.__cache.toJSON();
	    };
	
	    (0, _createClass3.default)(LRUCache, [{
	        key: 'size',
	        get: function get() {
	            return this.__cache.size;
	        }
	    }]);
	    return LRUCache;
	}();
	
	exports.default = LRUCache;
	
	
	console.log('LRUCache');
	
	var a = new LRUCache([], 3);
	a.add('adam', 29);
	a.add('john', 26);
	a.add('angela', 24);
	console.log(a + '');
	a.get('john');
	console.log(a + '');
	a.add('zorro', 141);
	console.log(a + '');
	console.log(a.toJSON());
	
	for (var _iterator = a, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;
	
	    if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	    } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	    }
	
	    var item = _ref;
	
	    console.log(item);
	}
	
	a.remove('zorro');
	a.remove('john');
	a.remove('angela');
	console.log(a + '');
	
	// test case:
	// Input:
	// 2,[add(2,1),add(1,1),add(2,3),add(4,1),get(1),get(2)]
	// Expected:
	// [ false, { key: 2, value: 3 } ]
	console.log('add');
	
	var b = new LRUCache([], 2);
	b.add(2, 1);
	b.add(1, 1);
	b.add(2, 3);
	b.add(4, 1);
	console.log([b.get(1), b.get(2)]);
	
	console.log('~add');
	
	console.log('LRUCacheEnd');

/***/ },
/* 117 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.union = union;
	exports.mergeList = mergeList;
	exports.insert = insert;
	exports.del = del;
	exports.listComp = listComp;
	exports.reverse = reverse;
	exports.intersect = intersect;
	exports.intersect_true = intersect_true;
	exports.intersect_delete = intersect_delete;
	/**
	 * 线性表
	 */
	
	// 线性表的类型定义
	// 将所有在数组b中但不在数组a的数据元素插入到a中
	
	var a = [1, 2, 3, 4, 5];
	var b = [1, 3, 5, 7, 9];
	
	function union(a, b) {
	    var elem, equal;
	
	    for (var i = 0, bLen = b.length; i < bLen; i++) {
	        elem = b[i];
	        equal = false;
	
	        for (var j = 0, aLen = a.length; j < aLen; j++) {
	            if (elem === a[j]) {
	                equal = true;
	                break;
	            }
	        }
	
	        if (!equal) a.push(elem);
	    }
	}
	
	union(a, b);
	console.log(a);
	// [1, 2, 3, 4, 5, 7, 9]
	
	// 时间复杂度：O(aLen * bLen)
	
	// 已知数组a和数组b中的数据元素按值非递减排列
	// 归并a和b得到新的数组c，c的数据元素也按值非递减排列
	var a = [3, 5, 8, 11];
	var b = [2, 6, 8, 9, 11, 15, 20];
	
	function mergeList(a, b) {
	    var c = [],
	        aElem,
	        bElem;
	    var i = 0,
	        j = 0,
	        k = 0;
	    var aLen = a.length;
	    var bLen = b.length;
	
	    while (i < aLen && j < bLen) {
	        aElem = a[i];
	        bElem = b[j];
	
	        if (aElem < bElem) {
	            c[k++] = aElem;
	            i++;
	        } else {
	            c[k++] = bElem;
	            j++;
	        }
	    }
	
	    while (i < aLen) {
	        c[k++] = a[i++];
	    }
	
	    while (j < bLen) {
	        c[k++] = b[j++];
	    }
	
	    return c;
	}
	
	var c = mergeList(a, b);
	console.log(c);
	// [2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20]
	
	// 时间复杂度： O(aLen + bLen)
	
	// 线性表的顺序表示和实现
	// 使用伪数组模拟线性表插入操作的前后数据元素在存储空间中的位置变化
	var a = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 };
	a.length = 6;
	
	function insert(a, i, elem) {
	    if (!elem) return;
	
	    var len = a.length;
	    if (i >= len) {
	        while (len < i) {
	            a[len++] = undefined;
	            a.length++;
	        }
	        a[i] = elem;
	    } else {
	        while (len > i) {
	            a[len--] = a[len];
	        }
	        a[i] = elem;
	    }
	    a.length++;
	}
	
	insert(a, 3, 8);
	insert(a, 10, 10);
	console.log(a);
	
	// 使用伪数组模拟线性表删除操作的前后数据元素在存储空间中的位置变化
	
	function del(a, i) {
	    var temp = a[i];
	    var j = i + 1;
	    var len = a.length;
	
	    while (j < len) {
	        a[j - 1] = a[j++];
	    }
	    a.length--;
	    delete a[len - 1];
	
	    return temp;
	}
	
	del(a, 3);
	console.log(a);
	del(a, 10);
	console.log(a);
	
	// 时间复杂度： O(a.length)
	
	// 比较字符表A和B，并用返回值表示结果，值为1，表示A>B，值为-1，表示A<B，值为0，表示A=B
	function listComp(aList, bList) {
	    for (var i = 0; i < aList.length && i < bList.length; i++) {
	        if (aList[i] !== bList[i]) return aList[i] > bList[i] ? 1 : -1;
	    }
	
	    if (aList.length == bList.length) return 0;
	
	    return aList.length > bList.length ? 1 : -1;
	}
	
	function reverse(list) {
	    for (var i = 0, j = list.length - 1; i <= j; i++, j--) {
	        var temp = list[i];
	        list[i] = list[j];
	        list[j] = temp;
	    }
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(aList, bList) {
	    var cList = [];
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (aList[i] && bList[j]) {
	        if (aList[i] < bList[j]) i++;else if (aList[i] > bList[j]) j++;else {
	            cList[k++] = aList[i];
	            i++;
	            j++;
	        }
	    }
	
	    return cList;
	}
	
	console.log(intersect([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(a, b) {
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (a[i] && b[j]) {
	        if (a[i] < b[j]) i++;else if (a[i] > b[j]) j++;else {
	            a[k++] = a[i];
	            i++;
	            j++;
	        }
	    }
	
	    while (a[k]) {
	        a.splice(k, 1);
	    }return a;
	}
	
	console.log(intersect_true([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// a，b，c的元素均是非递减排列
	// 求a数组中非b数组和c数组的交集的元素。
	function intersect_delete(a, b, c) {
	    var i = 0,
	        j = 0,
	        k = 0,
	        m = 0;
	
	    while (i < a.length && j < b.length && k < c.length) {
	        if (b[j] < c[k]) j++;else if (b[j] > c[k]) k++;else {
	            // 找到了相同元素same
	            var same = b[j];
	
	            // j，k后移到新的元素
	            while (b[j] === same) {
	                j++;
	            }while (c[k] === same) {
	                k++;
	            } // 需保留的元素移动到新位置
	            while (i < a.length && a[i] < same) {
	                a[m++] = a[i++];
	            } // 跳过相同的元素
	            while (i < a.length && a[i] === same) {
	                i++;
	            }
	        }
	    }
	
	    // a的剩余元素重新存储
	    while (i < a.length) {
	        a[m++] = a[i++];
	    }a.length = m;
	
	    return a;
	}
	
	console.log(intersect_delete([1, 2, 3, 4, 5, 6, 9], [1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(8);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by ldp on 2015/1/19.
	 */
	
	// 循环队列
	var CycleQueue = function () {
	    function CycleQueue() {
	        var maxsize = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
	        (0, _classCallCheck3.default)(this, CycleQueue);
	
	        this.base = {};
	        this.front = this.rear = 0;
	        this.MAXQSIZE = maxsize;
	    }
	
	    CycleQueue.prototype.enQueue = function enQueue(data) {
	        if ((this.rear + 1) % this.MAXQSIZE === 0) throw new Error('cycleQueue is already full!');
	
	        this.base[this.rear] = data;
	        this.rear = (this.rear + 1) % this.MAXQSIZE;
	    };
	
	    CycleQueue.prototype.deQueue = function deQueue() {
	        if (this.front === this.rear) throw new Error('cycleQueue is already empty');
	
	        var elem = this.base[this.front];
	        this.front = (this.front + 1) % this.MAXQSIZE;
	
	        return elem;
	    };
	
	    CycleQueue.prototype.clear = function clear() {
	        this.base = {};
	        this.front = this.rear = 0;
	    };
	
	    CycleQueue.prototype.peekAt = function peekAt() {
	        var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	        index = (index + this.MAXQSIZE) % this.MAXQSIZE;
	
	        return this.base[index + this.front] || null;
	    };
	
	    CycleQueue.prototype.getHead = function getHead() {
	        var elem = this.base[this.front];
	        return elem ? elem : null;
	    };
	
	    CycleQueue.prototype.queueTraverse = function queueTraverse(iterator) {
	        for (var i = this.front, len = this.rear = this.front; i < len; i++) {
	            if (iterator(this.base[i], i)) break;
	        }
	    };
	
	    CycleQueue.prototype.toString = function toString() {
	        var base = [].slice.call(this.base);
	
	        return base.slice(this.front, this.rear - this.front);
	    };
	
	    (0, _createClass3.default)(CycleQueue, [{
	        key: 'size',
	        get: function get() {
	            return (this.rear - this.front + this.MAXQSIZE) % this.MAXQSIZE;
	        }
	    }]);
	    return CycleQueue;
	}();
	
	exports.default = CycleQueue;
	
	
	var queue = new CycleQueue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(8);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/2/26.
	 */
	
	/*
	优先队列(priority queue)
	
	普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。
	
	优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.
	
	
	入队操作
	①：完全二叉树的构建操作是“从上到下，从左到右”的形式，所以入队的节点是放在数组的最后，也就是树中叶子层的有序最右边空位。
	②：当节点插入到最后时，有可能破坏了堆的性质，此时我们要进行“上滤操作”，当然时间复杂度为O(lgN)。
	
	出队操作
	出队操作时，我们采取的方案是：弹出堆顶元素，然后将叶子层中的最右子节点赋给堆顶，同样这时也会可能存在破坏堆的性质，最后我们要被迫进行下滤操作。
	 */
	
	// 用堆实现优先队列
	
	var PriorityQueue = function () {
	    function PriorityQueue() {
	        (0, _classCallCheck3.default)(this, PriorityQueue);
	
	        this.heap = [];
	    }
	
	    PriorityQueue.prototype.enQueue = function enQueue(value) {
	        var priority = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	        if (typeof value === 'undefined') throw new Error('argument required');
	
	        // 将当前节点追加到堆尾
	        this.heap.push({
	            value: value,
	            priority: priority
	        });
	
	        // 如果只有一个节点，则不需要进行筛选操作
	        if (this.heap.length === 1) return;
	
	        // 获取最后一个非叶子节点，并进行堆调整
	        upHeapAdjust(this.heap, (this.heap.length >> 1) - 1);
	    };
	
	    PriorityQueue.prototype.deQueue = function deQueue() {
	        if (!this.heap.length) return null;
	
	        var heap = this.heap;
	        // 出队列操作，弹出数据头元素
	        var data = heap[0];
	        // 用尾元素填充头元素
	        heap[0] = heap[heap.length - 1];
	        // 删除尾节点
	        heap.pop();
	
	        //然后从根节点下滤堆
	        downHeapAdjust(heap, 0);
	
	        return data;
	    };
	
	    PriorityQueue.prototype.clear = function clear() {
	        this.heap = [];
	    };
	
	    (0, _createClass3.default)(PriorityQueue, [{
	        key: 'size',
	        get: function get() {
	            return this.heap.length;
	        }
	    }]);
	    return PriorityQueue;
	}();
	
	// 对堆进行上滤操作，使得满足堆性质
	
	
	exports.default = PriorityQueue;
	function upHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (parent >= 0) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        // 如果parent节点小于它的某个子节点的话，此时筛选操作
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            // 继续进行更上一层的过滤
	            parent = Math.ceil(parent / 2) - 1;
	        } else break;
	    }
	}
	
	// 对堆进行下滤操作，使得满足堆性质
	function downHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (2 * parent + 1 < len) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            parent = max;
	        } else break;
	    }
	}
	
	var test = new PriorityQueue();
	test.enQueue(8, 5);
	test.enQueue(7, 2);
	test.enQueue(6, 1);
	test.enQueue(5, 4);
	test.enQueue(4, 7);
	test.enQueue(3, 3);
	test.enQueue(2, 8);
	test.enQueue(1, 10);
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());

/***/ },
/* 120 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * AVL TREE Class
	 *
	 * @author Brice Chevalier
	 *
	 *
	 * @desc
	 *
	 *    Method                Time Complexity
	 *    ___________________________________
	 *
	 *    add                    O(log2(n))
	 *    remove                O(log2(n))
	 *    getFirst            O(1)
	 *    getLast                O(1)
	 *    getCount            O(1)
	 *    apply                O(n)
	 *    clear                O(n)
	 *
	 *    Memory Complexity in O(n)
	 */
	
	function Node(obj) {
	    this.object = obj;
	    this.height = 1;
	    this.left = null;
	    this.right = null;
	    this.previous = null;
	    this.next = null;
	    this.parent = null;
	}
	
	function AvlTree() {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	}
	AvlTree.cmp = function (a, b) {
	    if (a > b) return 1;else if (a < b) return -1;else return 0;
	};
	
	AvlTree.prototype._addLeft = function (node, parent) {
	    node.previous = parent.previous;
	    node.next = parent;
	    node.parent = parent;
	
	    parent.left = node;
	    parent.previous = node;
	
	    if (node.previous) {
	        node.previous.next = node;
	    }
	
	    if (parent === this.first) {
	        this.first = node;
	    }
	};
	
	AvlTree.prototype._addRight = function (node, parent) {
	    node.previous = parent;
	    node.next = parent.next;
	    node.parent = parent;
	
	    parent.right = node;
	    parent.next = node;
	
	    if (node.next) {
	        node.next.previous = node;
	    }
	
	    if (parent === this.last) {
	        this.last = node;
	    }
	};
	
	AvlTree.prototype.add = function (obj) {
	    this.count += 1;
	    var newNode = new Node(obj);
	
	    if (this.root === null) {
	        this.root = newNode;
	        this.first = this.root;
	        this.last = this.root;
	        return newNode;
	    }
	
	    var current = this.root;
	
	    while (true) {
	
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            // Adding to the left
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else {
	                current = current.left;
	            }
	        } else if (cmp > 0) {
	            // Adding to the right
	            if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                current = current.right;
	            }
	        } else {
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                if (current.right.height < current.left.height) {
	                    current = current.right;
	                } else {
	                    current = current.left;
	                }
	            }
	        }
	    }
	
	    this._balance(newNode.parent);
	
	    return newNode;
	};
	
	AvlTree.prototype._balanceLeftRight = function (node) {
	    var left = node.left;
	    var a = left.left;
	    var b = left.right.left;
	
	    left.right.left = left;
	    node.left = left.right;
	    left = node.left;
	    left.parent = node;
	
	    var leftLeft = left.left;
	    leftLeft.parent = left;
	    leftLeft.left = a;
	    leftLeft.right = b;
	    if (a !== null) {
	        a.parent = leftLeft;
	    }
	    if (b !== null) {
	        b.parent = leftLeft;
	    }
	
	    left.height = leftLeft.height + 1;
	};
	
	AvlTree.prototype._balanceLeftLeft = function (node) {
	    var left = node.left;
	    var c = left.right;
	
	    if (node === this.root) {
	        this.root = left;
	    } else {
	        if (node.parent.right === node) {
	            node.parent.right = left;
	        } else {
	            node.parent.left = left;
	        }
	    }
	
	    left.right = node;
	    left.parent = node.parent;
	    node.parent = left;
	    node.left = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balanceRightLeft = function (node) {
	    var right = node.right;
	    var a = right.right;
	    var b = right.left.right;
	
	    right.left.right = right;
	    node.right = right.left;
	    right = node.right;
	    right.parent = node;
	
	    var rightRight = right.right;
	    rightRight.parent = right;
	    rightRight.right = a;
	    rightRight.left = b;
	    if (a !== null) {
	        a.parent = rightRight;
	    }
	    if (b !== null) {
	        b.parent = rightRight;
	    }
	
	    node.right.height = rightRight.height + 1;
	};
	
	AvlTree.prototype._balanceRightRight = function (node) {
	    var right = node.right;
	    var c = right.left;
	
	    if (node === this.root) {
	        this.root = right;
	    } else {
	        if (node.parent.left === node) {
	            node.parent.left = right;
	        } else {
	            node.parent.right = right;
	        }
	    }
	
	    right.left = node;
	    right.parent = node.parent;
	    node.parent = right;
	    node.right = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balance = function (node) {
	    // Balancing the tree
	    var current = node;
	    while (current !== null) {
	        var leftHeight = current.left === null ? 0 : current.left.height;
	        var rightHeight = current.right === null ? 0 : current.right.height;
	        var newHeight = 1 + Math.max(leftHeight, rightHeight);
	
	        if (newHeight > current.height) {
	            current.height = newHeight;
	            if (leftHeight - rightHeight > 1) {
	
	                // Left case
	                if (current.left.right !== null && (current.left.left === null || current.left.left.height < current.left.right.height)) {
	                    // Left Right Case
	                    this._balanceLeftRight(current);
	                }
	
	                // Left Left Case
	                this._balanceLeftLeft(current);
	
	                // The tree has been balanced
	                break;
	            } else if (rightHeight - leftHeight > 1) {
	
	                // Right case
	                if (current.right.left !== null && (current.right.right === null || current.right.right.height < current.right.left.height)) {
	                    // Right Left Case
	                    this._balanceRightLeft(current);
	                }
	
	                // Right Right Case
	                this._balanceRightRight(current);
	
	                // The tree has been balanced
	                break;
	            } else {
	                // Node is balanced
	                current = current.parent;
	            }
	        } else {
	            break;
	        }
	    }
	};
	
	AvlTree.prototype.remove = function (obj) {
	    this._remove(obj, this.root);
	};
	
	AvlTree.prototype._remove = function (obj, node) {
	    var current = node;
	
	    while (current !== null) {
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            current = current.left;
	        } else if (cmp > 0) {
	            current = current.right;
	        } else {
	            if (obj === current.object) {
	
	                // Node removal
	                this.count -= 1;
	
	                if (current.previous === null) {
	                    this.first = current.next;
	                } else {
	                    current.previous.next = current.next;
	                }
	                if (current.next === null) {
	                    this.last = current.previous;
	                } else {
	                    current.next.previous = current.previous;
	                }
	
	                // Replacing the node by the smallest element greater than it
	                var parent = current.parent;
	                var left = current.left;
	                var right = current.right;
	
	                if (current.right === null) {
	                    if (parent === null) {
	                        this.root = left;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = left;
	                        } else {
	                            parent.left = left;
	                        }
	                    }
	
	                    if (left !== null) {
	                        left.parent = parent;
	                    }
	
	                    this._balance(parent);
	                    return 1;
	                }
	
	                var replacement = current.right;
	                var balanceFrom;
	
	                if (replacement.left === null) {
	                    balanceFrom = replacement;
	
	                    if (left !== null) {
	                        left.parent = replacement;
	                    }
	                    replacement.left = left;
	
	                    if (parent === null) {
	                        this.root = replacement;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = replacement;
	                        } else {
	                            parent.left = replacement;
	                        }
	                    }
	                    replacement.parent = parent;
	
	                    this._balance(balanceFrom);
	
	                    return 1;
	                }
	
	                replacement = replacement.left;
	                while (replacement.left !== null) {
	                    replacement = replacement.left;
	                }
	
	                if (replacement.right !== null) {
	                    replacement.right.parent = replacement.parent;
	                }
	                replacement.parent.left = replacement.right;
	
	                if (right !== null) {
	                    right.parent = replacement;
	                }
	                replacement.right = right;
	
	                balanceFrom = replacement.parent;
	
	                if (left !== null) {
	                    left.parent = replacement;
	                }
	                replacement.left = left;
	
	                if (parent === null) {
	                    this.root = replacement;
	                } else {
	                    if (parent.right === current) {
	                        parent.right = replacement;
	                    } else {
	                        parent.left = replacement;
	                    }
	                }
	                replacement.parent = parent;
	
	                this._balance(balanceFrom);
	
	                return 1;
	            } else {
	                if (!this._remove(obj, current.left)) {
	                    this._remove(obj, current.right);
	                }
	            }
	        }
	    }
	
	    return 0;
	};
	
	AvlTree.prototype.removeByRef = function (node) {
	    // Node removal
	    this.count -= 1;
	
	    if (node.previous === null) {
	        this.first = node.next;
	    } else {
	        node.previous.next = node.next;
	    }
	    if (node.next === null) {
	        this.last = node.previous;
	    } else {
	        node.next.previous = node.previous;
	    }
	
	    // Replacing the node by the smallest element greater than it
	    var parent = node.parent;
	    var left = node.left;
	    var right = node.right;
	
	    if (node.right === null) {
	        if (parent === null) {
	            this.root = left;
	        } else {
	            if (parent.right === node) {
	                parent.right = left;
	            } else {
	                parent.left = left;
	            }
	        }
	
	        if (left !== null) {
	            left.parent = parent;
	        }
	
	        this._balance(parent);
	        return 1;
	    }
	
	    var replacement = node.right;
	    var balanceFrom;
	
	    if (replacement.left === null) {
	        balanceFrom = replacement;
	
	        if (left !== null) {
	            left.parent = replacement;
	        }
	        replacement.left = left;
	
	        if (parent === null) {
	            this.root = replacement;
	        } else {
	            if (parent.right === node) {
	                parent.right = replacement;
	            } else {
	                parent.left = replacement;
	            }
	        }
	        replacement.parent = parent;
	
	        this._balance(balanceFrom);
	
	        return 1;
	    }
	
	    replacement = replacement.left;
	    while (replacement.left !== null) {
	        replacement = replacement.left;
	    }
	
	    if (replacement.right !== null) {
	        replacement.right.parent = replacement.parent;
	    }
	    replacement.parent.left = replacement.right;
	
	    if (right !== null) {
	        right.parent = replacement;
	    }
	    replacement.right = right;
	
	    balanceFrom = replacement.parent;
	
	    if (left !== null) {
	        left.parent = replacement;
	    }
	    replacement.left = left;
	
	    if (parent === null) {
	        this.root = replacement;
	    } else {
	        if (parent.right === node) {
	            parent.right = replacement;
	        } else {
	            parent.left = replacement;
	        }
	    }
	    replacement.parent = parent;
	
	    this._balance(balanceFrom);
	
	    return 1;
	};
	
	AvlTree.prototype.getFirst = function () {
	    return this.first;
	};
	
	AvlTree.prototype.getLast = function () {
	    return this.last;
	};
	
	AvlTree.prototype.getHeight = function () {
	    return this.root.height;
	};
	
	AvlTree.prototype.getRoot = function () {
	    return this.root;
	};
	
	AvlTree.prototype.getCount = function () {
	    return this.count;
	};
	
	AvlTree.prototype.forEach = function (processingFunc, params) {
	    for (var current = this.first; current; current = current.next) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.forEachReverse = function (processingFunc, params) {
	    for (var current = this.last; current; current = current.previous) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.clear = function () {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	};
	
	module.exports = AvlTree;
	
	console.log('\nAVL tree insert2: ');
	var test = new AvlTree();
	test.add(3);
	test.add(14);
	test.add(25);
	test.add(81);
	test.add(44);
	
	/*
	 14
	 /    \
	 3       44
	 /   \
	 25     81
	 */
	
	console.log('remove_Recursive 2:');
	
	test.remove(81);
	test.remove(3);
	test.remove(14);
	test.remove(25);
	test.remove(44);
	
	var str = 'cknobfjtlpqaegrmdhs';
	//var str = 'ckbfjlaegmdh';
	
	
	test = new AvlTree();
	for (var i = 0; i < str.length; ++i) {
	    test.add(str[i]);
	}
	
	test.remove('e');
	test.remove('h');
	test.remove('b');
	test.remove('l');
	test.remove('f');
	test.remove('j');
	test.remove('g');
	test.remove('d');
	test.remove('k');
	test.remove('a');
	test.remove('m');
	test.remove('n');
	test.remove('o');
	test.remove('p');
	test.remove('q');
	test.remove('r');
	test.remove('s');
	test.remove('t');
	test.remove('c');

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	/*
	 MIT License
	 Copyright (c) 2012 Santanu Basu
	 Copyright (c) 2013 Daniel Wirtz
	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:
	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.
	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	// Based on Santanu Basu's BPlusJS
	// https://github.com/santanubasu/BPlusJS
	// Modified for stand-alone use
	
	/**
	 * @license BTree.js
	 * Released under the MIT License
	 * see: https://github.com/dcodeIO/BTree.js for details
	 */
	(function (global) {
	
	    function isDefined(v) {
	        return typeof v != 'undefined';
	    }
	
	    var Node = function Node(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.data = [];
	    };
	
	    Node.prototype.getLeftPeer = function () {
	        return this.leftPeer;
	    };
	
	    Node.prototype.setLeftPeer = function (leftPeer) {
	        this.leftPeer = leftPeer;
	    };
	
	    Node.prototype.getRightPeer = function () {
	        return this.rightPeer;
	    };
	
	    Node.prototype.setRightPeer = function (rightPeer) {
	        this.rightPeer = rightPeer;
	    };
	
	    Node.prototype.getData = function () {
	        return this.data;
	    };
	
	    Node.prototype.getSurplus = function () {
	        return Math.max(0, Math.floor((this.data.length - this.mergeThreshold) / 2));
	    };
	
	    Node.prototype.getRightSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(this.data.length - surplus);
	    };
	
	    Node.prototype.getLeftSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(0, surplus);
	    };
	
	    var InternalNode = function InternalNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    InternalNode.prototype = Object.create(Node.prototype);
	
	    InternalNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        var left = 0;
	        var right = data.length - 1;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left < right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return right;
	        }
	    };
	
	    InternalNode.prototype.findChild = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        if (element.key <= key) {
	            child = element.right;
	        } else {
	            child = element.left;
	        }
	        return child;
	    };
	
	    InternalNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        var newNodes, leftElement, rightElement;
	        if (element.key <= key) {
	            child = element.right;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: element.key,
	                    left: element.left,
	                    right: newNodes[0]
	                };
	                rightElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        } else {
	            child = element.left;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                rightElement = {
	                    key: element.key,
	                    left: newNodes[2],
	                    right: element.right
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        }
	        return newNodes;
	    };
	
	    InternalNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new InternalNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new InternalNode({
	            data: this.data.slice(splitIndex + 1, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    InternalNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var mergeIndex = -1;
	        var child;
	        var retval;
	        if (element.key <= key) {
	            child = element.right;
	            retval = child.remove(key, element.left, index < this.data.length - 1 ? child.getRightPeer() : undefined);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index + 1;
	                } else {
	                    mergeIndex = index;
	                }
	            }
	        } else {
	            child = element.left;
	            retval = child.remove(key, index > 0 ? child.getLeftPeer() : undefined, element.right);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index;
	                } else {
	                    mergeIndex = index - 1;
	                }
	            }
	        }
	        if (mergeIndex >= 0) {
	            var mergeElement = this.data[mergeIndex];
	            if (retval.length == 5) {
	                mergeElement.key = retval[3];
	                return [retval[0]];
	            } else {
	                if (mergeIndex > 0) {
	                    this.data[mergeIndex - 1].right = retval[3];
	                }
	                if (mergeIndex < this.data.length - 1) {
	                    this.data[mergeIndex + 1].left = retval[3];
	                }
	                this.data.splice(mergeIndex, 1);
	                return [retval[0]].concat(this.merge(leftMergeOption, rightMergeOption));
	            }
	        } else {
	            return [retval[0]];
	        }
	    };
	
	    InternalNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.slice(1).concat([{
	                key: this.data[0].left.getData()[0].key,
	                left: leftSurplusData[leftSurplusData.length - 1].right,
	                right: this.data[0].left
	            }], this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = leftSurplusData[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat([{
	                key: rightSurplusData[0].left.getData()[0].key,
	                left: this.data[this.data.length - 1].right,
	                right: rightSurplusData[0].left
	            }], rightSurplusData.slice(0, rightSurplusData.length - 1));
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightSurplusData[rightSurplusData.length - 1].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedInternalNode;
	            if (!isDefined(leftData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    InternalNode.prototype.find = function (key) {
	        return this.findChild(key).find(key);
	    };
	
	    InternalNode.prototype.range = function (start, end) {
	        return this.findChild(start).range(start, end);
	    };
	
	    InternalNode.prototype.toString = function (indent) {
	        return this.data.map(function (element) {
	            return [indent + "[key=" + element.key, "\n" + indent + "    LEFT\n" + element.left.toString(indent + "    "), "\n" + indent + "    RIGHT\n" + element.right.toString(indent + "    ") + "\n" + indent + "]"];
	        }).join(",\n");
	    };
	
	    var LeafNode = function LeafNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    LeafNode.prototype = Object.create(Node.prototype);
	
	    LeafNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        if (data.length == 0) {
	            return 0;
	        }
	        var left = 0;
	        var right = data.length;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left !== right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return left;
	        }
	    };
	
	    LeafNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index == this.data.length) {
	            this.data.push({
	                key: key,
	                value: value
	            });
	        } else if (element.key === key) {
	            if (clobber) {
	                element.value = value;
	            } else {
	                return [element.value];
	            }
	            // This condition may never occur, given the way findIndex is written
	        } else if (element.key < key) {
	            this.data.splice(index + 1, 0, {
	                key: key,
	                value: value
	            });
	        } else {
	            this.data.splice(index, 0, {
	                key: key,
	                value: value
	            });
	        }
	        return this.split();
	    };
	
	    LeafNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new LeafNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new LeafNode({
	            data: this.data.slice(splitIndex, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    LeafNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            this.data.splice(index, 1);
	            return [element.value].concat(this.merge(leftMergeOption, rightMergeOption));
	        } else {
	            return [undefined];
	        }
	    };
	
	    LeafNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.concat(this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = this.data[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat(rightSurplusData);
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightMergeOption.getData()[0].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedLeafNode;
	            if (!isDefined(leftData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    LeafNode.prototype.find = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            return element.value;
	        }
	    };
	
	    LeafNode.prototype.range = function (start, end) {
	        var node = this;
	        var range = [];
	        while (isDefined(node)) {
	            var startIndex = node.findIndex(start);
	            var endIndex = node.findIndex(end);
	            var nodeData = node.getData();
	            if (startIndex < nodeData.length) {
	                for (var i = startIndex; i < endIndex; i++) {
	                    range.push(nodeData[i].value);
	                }
	            }
	            if (endIndex == nodeData.length) {
	                node = node.getRightPeer();
	            } else {
	                break;
	            }
	        }
	        return range;
	    };
	
	    LeafNode.prototype.toString = function (indent) {
	        return indent + "[" + this.data.map(function (element) {
	            return element.key;
	        }).toString() + "]";
	    };
	
	    var Tree = function Tree(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.root = new LeafNode({
	            order: this.order,
	            mergeThreshold: this.mergeThreshold,
	            data: []
	        });
	    };
	
	    Tree.prototype.toString = function () {
	        return this.root.toString("");
	    };
	
	    Tree.prototype.insert = function (key, value, clobber) {
	        var newNodes = this.root.insert(key, value, clobber);
	        if (newNodes.length == 3) {
	            this.root = new InternalNode({
	                order: this.order,
	                mergeThreshold: this.mergeThreshold,
	                data: [{
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                }]
	            });
	        } else if (newNodes.length == 1) {
	            return newNodes[0];
	        }
	        return value;
	    };
	
	    Tree.prototype.remove = function (key) {
	        var retval = this.root.remove(key);
	        if (retval.length == 2) {
	            this.root = retval[1];
	        }
	        return retval[0];
	    };
	
	    Tree.prototype.find = function (key) {
	        return this.root.find(key);
	    };
	
	    Tree.prototype.range = function (start, end) {
	        return this.root.range(start, end);
	    };
	
	    // Expose all types on top
	    Tree.Node = Node;
	    Tree.InternalNode = InternalNode;
	    Tree.LeafNode = LeafNode;
	
	    // Enable module loading if available
	    if (typeof module != 'undefined' && module["exports"]) {
	        // CommonJS
	        module["exports"] = Tree;
	    } else if ("function" != 'undefined' && __webpack_require__(151)["amd"]) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Tree;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Shim
	        if (!global["dcodeIO"]) {
	            global["dcodeIO"] = {};
	        }
	        global["dcodeIO"]["BPlusTree"] = Tree;
	    }
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)(module)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	/*
	 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	 http://www.apache.org/licenses/LICENSE-2.0
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: http://github.com/dcodeIO/btree.js for details
	 */
	(function (module, console) {
	    'use strict';
	
	    /**
	     * Concatenates multiple arrays into a new one.
	     * @param {...[Array]} var_args
	     * @returns {Array}
	     * @private
	     */
	
	    function concat(var_args) {
	        // Array#concat behaves strangely for empty arrays, so...
	        var a = [];
	        for (var i = 0; i < arguments.length; i++) {
	            Array.prototype.push.apply(a, arguments[i]);
	        }
	        return a;
	    }
	
	    /**
	     * Searches an array for the specified value.
	     * @param {Array} a
	     * @param {*} v
	     * @returns {number} Index or -1 if not found
	     * @private
	     */
	    function asearch(a, v) {
	        // This is faster than Array#indexOf because it's raw. However, we
	        // cannot use binary search because nodes do not have a comparable
	        // key. If the compiler is smart, it will inline this.
	        for (var i = 0; i < a.length; i++) {
	            if (a[i] === v) return i;
	        }
	        return -i;
	    }
	
	    /**
	     * btree namespace.
	     * @type {Object.<string,*>}
	     */
	    var btree = {};
	
	    /**
	     * Strictly compares two strings, character by character. No locales, no number extension.
	     * @param {string} a
	     * @param {string} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.strcmp = function strcmp(a, b) {
	        /** @type {number} */
	        var ac;
	        /** @type {number} */
	        var bc;
	        for (var i = 0; i < a.length; i++) {
	            if (i >= b.length) {
	                return 1;
	            }
	            if ((ac = a.charCodeAt(i)) < (bc = b.charCodeAt(i))) {
	                return -1;
	            } else if (ac > bc) {
	                return 1;
	            }
	            // If same, continue
	        }
	        return a.length == b.length ? 0 : -1;
	    };
	
	    /**
	     * Compares two numbers.
	     * @param {number} a
	     * @param {number} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.numcmp = function intcmp(a, b) {
	        return a < b ? -1 : a > b ? 1 : 0;
	    };
	
	    /**
	     * Creates a BTree class using the given order.
	     * Note that this method returns a class, not an instance.
	     * @param {number=} order Defaults to 2
	     * @param {function(?, ?):number=} compare Compare implementation to use on keys
	     * @returns {Function}
	     * @expose
	     */
	    btree.create = function (order, compare) {
	
	        // Validate order
	        if (typeof order == 'undefined') {
	            order = 52; // Benchmarks proofed that this is close to the optimum
	        } else if (typeof order == 'number') {
	            order = Math.floor(order);
	        } else {
	            order = parseInt(order, 10);
	        }
	        if (order < 1) order = 1;
	        var minOrder = order > 1 ? Math.floor(order / 2) : 1;
	
	        // Use numcmp by default
	        if (typeof compare != 'function') {
	            compare = btree.numcmp;
	        }
	
	        /**
	         * Validates a node and prints debugging info if something went wrong.
	         * @param {!TreeNode|!Tree} node
	         * @private
	         */
	        function validate(node) {
	            // This function will be stripped by the compiler
	            if (node instanceof Tree) return;
	            if (node.leaves.length + 1 != node.nodes.length) {
	                console.log("ERROR: Illegal leaf/node count in " + node + ": " + node.leaves.length + "/" + node.nodes.length);
	            }
	            for (var i = 0; i < node.leaves.length; i++) {
	                if (!node.leaves[i]) {
	                    console.log("ERROR: Illegal leaf in " + node + " at " + i + ": " + node.leaves[i]);
	                }
	            }
	            for (i = 0; i < node.nodes.length; i++) {
	                if (typeof node.nodes[i] == 'undefined') {
	                    console.log("ERROR: Illegal node in " + node + " at " + i + ": undefined");
	                }
	            }
	        }
	
	        /**
	         * Constructs a new TreeNode.
	         * @class A TreeNode.
	         * @param {!(TreeNode|Tree)} parent Parent node
	         * @param {Array.<!Leaf>=} leaves Leaf nodes
	         * @param {Array.<TreeNode>=} nodes Child nodes
	         * @constructor
	         */
	        var TreeNode = function TreeNode(parent, leaves, nodes) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode|!Tree}
	             */
	            this.parent = parent;
	
	            /**
	             * Leaf nodes (max. order).
	             * @type {!Array.<!Leaf>}
	             */
	            this.leaves = leaves || [];
	            this.leaves.forEach(function (leaf) {
	                leaf.parent = this;
	            }, this);
	
	            /**
	             * Child nodes (max. order+1).
	             * @type {!Array.<TreeNode>}
	             */
	            this.nodes = nodes || [null];
	            this.nodes.forEach(function (node) {
	                if (node !== null) node.parent = this;
	            }, this);
	        };
	
	        /**
	         * Searches for the node that would contain the specified key.
	         * @param {!*} key
	         * @returns {{leaf: !Leaf, index: number}|{node: !TreeNode, index: number}} Leaf if the key exists, else the insertion node
	         */
	        TreeNode.prototype.search = function (key) {
	            if (this.leaves.length > 0) {
	                var a = this.leaves[0];
	                if (compare(a.key, key) == 0) return { leaf: a, index: 0 };
	                if (compare(key, a.key) < 0) {
	                    if (this.nodes[0] !== null) {
	                        return this.nodes[0].search(key); // Left
	                    }
	                    return { node: this, index: 0 };
	                }
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(b.key, key) == 0) return { leaf: b, index: i };
	                    if (compare(key, b.key) < 0) {
	                        if (this.nodes[i] !== null) {
	                            return this.nodes[i].search(key); // Inner
	                        }
	                        return { node: this, index: i };
	                    }
	                    a = b;
	                }
	                if (this.nodes[i] !== null) {
	                    return this.nodes[i].search(key); // Right
	                }
	                return { node: this, index: i };
	            }
	            return { node: this, index: 0 };
	        };
	
	        /**
	         * Gets the value for the given key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         */
	        TreeNode.prototype.get = function (key) {
	            var result = this.search(key);
	            if (result.leaf) return result.leaf.value;
	            return undefined;
	        };
	
	        /**
	         * Inserts a key/value pair into this node.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if successfully set, false if already present and overwrite is `false`
	         */
	        TreeNode.prototype.put = function (key, value, overwrite) {
	            var result = this.search(key);
	            if (result.leaf) {
	                if (typeof overwrite !== 'undefined' && !overwrite) {
	                    return false;
	                }
	                result.leaf.value = value;
	                return true;
	            } // Key already exists
	            var node = result.node,
	                index = result.index;
	            node.leaves.splice(index, 0, new Leaf(node, key, value));
	            node.nodes.splice(index + 1, 0, null);
	            if (node.leaves.length > order) {
	                // Rebalance
	                node.split();
	            }
	            return true;
	        };
	
	        /**
	         * Deletes a key from this node.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         */
	        TreeNode.prototype.del = function (key) {
	            var result = this.search(key);
	            if (!result.leaf) return false;
	            var leaf = result.leaf,
	                node = leaf.parent,
	                index = result.index,
	                left = node.nodes[index];
	            if (left === null) {
	                node.leaves.splice(index, 1);
	                node.nodes.splice(index, 1);
	                node.balance();
	            } else {
	                var max = left.leaves[left.leaves.length - 1];
	                left.del(max.key);
	                max.parent = node;
	                node.leaves.splice(index, 1, max);
	            }
	            return true;
	        };
	
	        /**
	         * Balances this node to fulfill all conditions.
	         */
	        TreeNode.prototype.balance = function () {
	            if (this.parent instanceof Tree) {
	                // Special case: Root has just a single child and no leaves
	                if (this.leaves.length == 0 && this.nodes[0] !== null) {
	                    this.parent.root = this.nodes[0];
	                    this.parent.root.parent = this.parent;
	                }
	                return;
	            }
	            if (this.leaves.length >= minOrder) {
	                return;
	            }
	            var index = asearch(this.parent.nodes, this),
	                left = index > 0 ? this.parent.nodes[index - 1] : null,
	                right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null;
	            var sep, leaf, rest;
	            if (right !== null && right.leaves.length > minOrder) {
	                // Append the seperator from parent to this
	                sep = this.parent.leaves[index];
	                sep.parent = this;
	                this.leaves.push(sep);
	                // Replace the blank with the first right leaf
	                leaf = right.leaves.shift();
	                leaf.parent = this.parent;
	                this.parent.leaves[index] = leaf;
	                // Append the right rest to this
	                rest = right.nodes.shift();
	                if (rest !== null) rest.parent = this;
	                this.nodes.push(rest);
	            } else if (left !== null && left.leaves.length > minOrder) {
	                // Prepend the seperator from parent to this
	                sep = this.parent.leaves[index - 1];
	                sep.parent = this;
	                this.leaves.unshift(sep);
	                // Replace the blank with the last left leaf
	                leaf = left.leaves.pop();
	                leaf.parent = this.parent;
	                this.parent.leaves[index - 1] = leaf;
	                // Prepend the left rest to this
	                rest = left.nodes.pop();
	                if (rest !== null) rest.parent = this;
	                this.nodes.unshift(rest);
	            } else {
	                var subst;
	                if (right !== null) {
	                    // Combine this + seperator from the parent + right
	                    sep = this.parent.leaves[index];
	                    subst = new TreeNode(this.parent, concat(this.leaves, [sep], right.leaves), concat(this.nodes, right.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index, 2, subst);
	                } else if (left !== null) {
	                    // Combine left + seperator from parent + this
	                    sep = this.parent.leaves[index - 1];
	                    subst = new TreeNode(this.parent, concat(left.leaves, [sep], this.leaves), concat(left.nodes, this.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index - 1, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index - 1, 2, subst);
	                } else {
	                    // We should never end here
	                    throw new Error("Internal error: " + this.toString(true) + " has neither a left nor a right sibling");
	                }
	                this.parent.balance();
	            }
	            // validate(this);
	            // validate(this.parent);
	        };
	
	        /**
	         * Unsplits a child.
	         * @param {!Leaf} leaf
	         * @param {!TreeNode} rest
	         */
	        TreeNode.prototype.unsplit = function (leaf, rest) {
	            leaf.parent = this;
	            rest.parent = this;
	            var a = this.leaves[0];
	            if (compare(leaf.key, a.key) < 0) {
	                this.leaves.unshift(leaf);
	                this.nodes.splice(1, 0, rest);
	            } else {
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(leaf.key, b.key) < 0) {
	                        this.leaves.splice(i, 0, leaf);
	                        this.nodes.splice(i + 1, 0, rest);
	                        break;
	                    }
	                }
	                if (i == this.leaves.length) {
	                    this.leaves.push(leaf);
	                    this.nodes.push(rest);
	                }
	            }
	            if (this.leaves.length > order) {
	                this.split();
	            }
	        };
	
	        /**
	         * Splits this node.
	         */
	        TreeNode.prototype.split = function () {
	            var index = Math.floor(this.leaves.length / 2);
	            if (this.parent instanceof Tree) {
	                this.nodes = [new TreeNode(this, this.leaves.slice(0, index), this.nodes.slice(0, index + 1)), new TreeNode(this, this.leaves.slice(index + 1), this.nodes.slice(index + 1))];
	                this.leaves = [this.leaves[index]];
	            } else {
	                var leaf = this.leaves[index];
	                var rest = new TreeNode(this.parent, this.leaves.slice(index + 1), this.nodes.slice(index + 1));
	                this.leaves = this.leaves.slice(0, index);
	                this.nodes = this.nodes.slice(0, index + 1);
	                this.parent.unsplit(leaf, rest);
	            }
	        };
	
	        /**
	         * Returns a string representation of this node.
	         * @param {boolean=} includeNodes Whether to include sub-nodes or not
	         * @returns {string}
	         */
	        TreeNode.prototype.toString = function (includeNodes) {
	            var val = [];
	            for (var i = 0; i < this.leaves.length; i++) {
	                val.push(this.leaves[i].key);
	            }
	            var s = "[" + val.toString() + "]" + (this.parent instanceof Tree ? ":*" : ":" + this.parent);
	            if (includeNodes) {
	                for (i = 0; i < this.nodes.length; i++) {
	                    s += " -> " + this.nodes[i];
	                }
	            }
	            return s;
	        };
	
	        /**
	         * Prints out the nodes leaves and nodes.
	         * @param {number} indent
	         */
	        TreeNode.prototype.print = function (indent) {
	            var space = "";
	            for (var i = 0; i < indent; i++) {
	                space += " ";
	            }for (i = this.leaves.length - 1; i >= 0; i--) {
	                if (this.nodes[i + 1] !== null) this.nodes[i + 1].print(indent + 2);
	                console.log(space + this.leaves[i].key + (this.parent instanceof Tree ? "*" : ""));
	            }
	            if (this.nodes[0] !== null) this.nodes[0].print(indent + 2);
	        };
	
	        /**
	         * Constructs a new Leaf containing a value.
	         * @class A Leaf.
	         * @param {!TreeNode} parent
	         * @param {!*} key
	         * @param {*} value
	         * @constructor
	         */
	        var Leaf = function Leaf(parent, key, value) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode}
	             */
	            this.parent = parent;
	
	            /**
	             * Key.
	             * @type {!*}
	             */
	            this.key = key;
	
	            /**
	             * Value.
	             * @type {*}
	             */
	            this.value = value;
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Leaf.prototype.toString = function () {
	            return "" + this.key;
	        };
	
	        /**
	         * Constructs a new Tree.
	         * @class A Tree.
	         * @constructor
	         */
	        function Tree() {
	            this.root = new TreeNode(this);
	        }
	
	        /**
	         * Inserts a key/value pair into the tree.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if set, false if already present and overwrite is `false`
	         * @throws {Error} If the key is undefined or null or the value is undefined
	         * @expose
	         */
	        Tree.prototype.put = function (key, value, overwrite) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            if (typeof value === 'undefined') throw new Error("Illegal value: " + value);
	            return this.root.put(key, value, overwrite);
	        };
	
	        /**
	         * Gets the value of the specified key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         * @throws {Error} If the key is undefined or null
	         * @expose
	         */
	        Tree.prototype.get = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.get(key);
	        };
	
	        /**
	         * Deletes a key from the tree.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         * @expose
	         */
	        Tree.prototype.del = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.del(key);
	        };
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in ascending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkAsc = function (minKey, maxKey, callback) {
	            if (this.root.leaves.length == 0) {
	                return;
	            }
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (minKey === null) {
	                // If there is no minimum limit
	                ptr = this.root; // set ptr to the outer left node
	                while (ptr.nodes[0] !== null) {
	                    ptr = ptr.nodes[0];
	                }
	                index = 0; // and start at its first leaf
	            } else {
	                // Else lookup
	                var result = this.root.search(minKey);
	                if (result.leaf) {
	                    // If the minimum key itself exists
	                    ptr = result.leaf.parent; // set ptr to the containing node
	                    index = asearch(ptr.leaves, result.leaf); // and start at its index
	                } else {
	                    // If the key does not exist
	                    ptr = result.node; // set ptr to the insertion node
	                    index = result.index; // and start at the insertion index (key > minKey)
	                    if (index >= ptr.leaves.length) {
	                        // on overrun, begin at the separator in the parent
	                        if (ptr.parent instanceof Tree) {
	                            return; // empty range
	                        }
	                        index = asearch(ptr.parent.nodes, ptr);
	                        if (index >= ptr.parent.leaves.length) {
	                            return; // empty range
	                        }
	                        ptr = ptr.parent;
	                    }
	                }
	            }
	            // ptr/index now points at our first result
	            while (true) {
	                if (maxKey !== null && compare(ptr.leaves[index].key, maxKey) > 0) {
	                    break; // if there are no more keys less than maxKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index + 1] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index + 1];
	                    index = 0;
	                    while (ptr.nodes[0] !== null) {
	                        ptr = ptr.nodes[0];
	                    }
	                } else if (ptr.leaves.length > index + 1) {
	                    // Next
	                    index++;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr);
	                        ptr = ptr.parent;
	                    } while (index >= ptr.leaves.length);
	                }
	            }
	        };
	
	        /**
	         * Alias of {@link Tree#walkAsc}.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|(function(*, *):(boolean|undefined)))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walk = Tree.prototype.walkAsc;
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in descending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or null, walks till the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or null, starts at the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkDesc = function (minKey, maxKey, callback) {
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (maxKey === null) {
	                // If there is no maximum limit
	                ptr = this.root; // set ptr to the outer right node
	                while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                    ptr = ptr.nodes[ptr.nodes.length - 1];
	                }
	                index = ptr.leaves.length - 1; // and start at its last leaf
	            } else {
	                // Else lookup
	                var result = this.root.search(maxKey);
	                if (result.leaf) {
	                    // If the maximum key itself exists
	                    ptr = result.leaf.parent; // set ptr to the containing node
	                    index = asearch(ptr.leaves, result.leaf); // and start at its index
	                } else {
	                    // If the key does not exist
	                    ptr = result.node; // set ptr to the insertion node
	                    index = result.index - 1; // and start at the insertion index-1 (key < maxKey)
	                    while (index < 0) {
	                        // on underrun, begin at the separator in the parent
	                        if (ptr.parent instanceof Tree) {
	                            return; // empty range
	                        }
	                        index = asearch(ptr.parent.nodes, ptr) - 1;
	                        if (index < 0) {
	                            return; // empty range
	                        }
	                        ptr = ptr.parent;
	                    }
	                }
	            }
	            // ptr/index now points at our first result
	            while (true) {
	                if (minKey !== null && compare(ptr.leaves[index].key, minKey) < 0) {
	                    break; // if there are no more keys bigger than minKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index];
	                    while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                        ptr = ptr.nodes[ptr.nodes.length - 1];
	                    }
	                    index = ptr.leaves.length - 1;
	                } else if (index > 0) {
	                    // Next
	                    index--;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr) - 1;
	                        ptr = ptr.parent;
	                    } while (index < 0);
	                }
	            }
	        };
	
	        /**
	         * Counts the number of keys between minKey and maxKey (both inclusive).
	         * @param {*=} minKey If omitted, counts from the start
	         * @param {*=} maxKey If omitted, counts till the end
	         * @returns {number}
	         * @expose
	         */
	        Tree.prototype.count = function (minKey, maxKey) {
	            var n = 0;
	            this.walk(typeof minKey != 'undefined' ? minKey : null, typeof maxKey != 'undefined' ? maxKey : null, function (key, value) {
	                n++;
	            });
	            return n;
	        };
	
	        /**
	         * Prints out all nodes in the tree.
	         * @expose
	         */
	        Tree.prototype.print = function () {
	            this.root.print(0);
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Tree.prototype.toString = function () {
	            return "Tree(" + order + ") " + this.root.toString();
	        };
	
	        return Tree;
	    };
	
	    module.exports = btree;
	})(module, console);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)(module)))

/***/ },
/* 123 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.binarySearch = binarySearch;
	exports.binarySearchRecursive = binarySearchRecursive;
	/*
	 折半查找(Binary Search)
	
	 折半查找又称为二分查找，是一种效率较高的查找方法。
	 前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。
	 查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。
	
	 1  查找思想
	 用Low、High和Mid表示待查找区间的下界、上界和中间位置指针，初值为Low=0，High=n - 1。
	 ⑴  取中间位置Mid：Mid=Math.floor((Low+High)/2)；
	 ⑵  比较中间位置记录的关键字与给定的K值：
	 ①  相等： 查找成功；
	 ②  大于：待查记录在区间的前半段，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段，修改下界指针：Low=Mid+1，转⑴ ；
	 直到越界(Low>High)，查找失败。
	
	 2  算法分析
	 ①  查找时每经过一次比较，查找范围就缩小一半，该过程可用一棵二叉树表示：
	 ◆ 根结点就是第一次进行比较的中间位置的记录；
	 ◆ 排在中间位置前面的作为左子树的结点；
	 ◆ 排在中间位置后面的作为右子树的结点；
	 对各子树来说都是相同的。这样所得到的二叉树称为判定树(Decision Tree)。
	 ②  将二叉判定树的第Math.floor(Math.log(2, n))+1层上的结点补齐就成为一棵满二叉树，深度不变，h= Math.floor(Math.log(2, n + 1)) 。
	 ③  由满二叉树性质知，第i 层上的结点数为Math.pow(2, i-1)(i<=h) ，设表中每个记录的查找概率相等，即Pi=1/n，查找成功时的平均查找长度ASL：
	 (n+1)/n*Math.log(2,n+1)-1
	 当n很大 (n>50)时， ASL≈ Math.log(2,n+1)-1。
	
	
	 时间复杂度O(logn)
	 */
	
	// 非递归式
	function binarySearch(sTable, key) {
	    var low = 0;
	    var high = sTable.length - 1;
	
	    while (low <= high) {
	        var mid = low + high >> 1;
	        var elem = sTable[mid];
	
	        if (elem === key) return mid;else if (elem < key) low = mid + 1;else high = mid - 1;
	    }
	
	    return -1;
	}
	
	console.log('binarySearch: ');
	console.log(binarySearch([1, 2, 3, 4, 5], 1)); // 0
	
	// 递归式
	function binarySearchRecursive(sTable, key) {
	    var low = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var high = arguments.length <= 3 || arguments[3] === undefined ? sTable.length - 1 : arguments[3];
	
	    if (low > high) return -1;
	
	    var mid = low + high >> 1;
	    var elem = sTable[mid];
	
	    if (elem === key) return mid;else if (elem < key) return binarySearchRecursive(sTable, key, mid + 1, high);else return binarySearchRecursive(sTable, key, low, mid - 1);
	}
	
	console.log('binarySearchRecursive: ');
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 1)); // 0
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	exports.__esModule = true;
	
	var _createClass2 = __webpack_require__(8);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(19);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(18);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _xxhashjs = __webpack_require__(152);
	
	var _crypto = __webpack_require__(102);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。
	
	 为了降低冲突的概念，Bloom Filter使用了多个哈希函数，而不是一个。
	
	 Bloom Filter算法如下：
	 创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为h（i，str），且h（i，str）的范围是0到m-1 。
	
	 (1) 加入字符串过程
	 下面是每个字符串处理的过程，首先是将字符串str“记录”到BitSet中的过程：
	 对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后将BitSet的第h（1，str）、h（2，str）…… h（k，str）位设为1。
	
	 (2) 检查字符串是否存在的过程
	 下面是检查字符串str是否被BitSet记录过的过程：
	 对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。
	 若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）
	 　但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive。
	
	 (3) 删除字符串过程
	 字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。
	
	 Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。
	
	 Bloom Filter参数选择
	 (1)哈希函数选择
	 　　哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。
	
	 (2) m,n,k值，我们如何取值
	 我们定义：
	 可能把不属于这个集合的元素误认为属于这个集合（False Positive）
	 不会把属于这个集合的元素误认为不属于这个集合（False Negative）。
	
	 哈希函数的个数k、位数组大小m、加入的字符串数量n的关系。哈希函数个数k取10，位数组大小m设为字符串个数n的20倍时，false positive发生的概率是0.0000889 ，即10万次的判断中，会存在9次误判，对于一天1亿次的查询，误判的次数为9000次。
	
	 Bloomfilter 的应用场景
	 1.黑名单
	 最典型的一个应用就是黑名单功能，对用户名称或者IP或者Email进行过滤，每次检查时用key进行hash后，如果不在黑名单内的，肯定可以通行，如果在的则不允许通过，误判情况增加一个排除名单来进行排除。
	 误判情况：将正常用户判定为黑名单用户
	
	 2.爬虫重复URL检测
	 在爬取网站URL时，要检测这条URL是否已经访问过。
	 误判情况：没有访问过的误判为访问过
	
	 3.字典纠错
	 检查单词拼写是否正确
	 误判情况：错误的单词误判为正确。
	
	 4.磁盘文件检测
	 将磁盘中或者数据库中数据key存入该结构中，检测要访问的数据是否在磁盘或数据库中，然后再发起访问，避免空查询造成磁盘或数据库压力。
	 误判情况：不存在该数据却误判为有该数据。
	
	 5.CDN（squid）代理缓存技术
	 先查找本地有无cache，如果没有则到其他兄弟 cache服务器上去查找。为了避免无谓的查询，在每个cache服务器上保存其兄弟服务器的缓存关键字，以bloomfilter方式存储，再去其他cache服务器查找之前，先检查该结构是否有url，如果有存在url，再去对应服务器查找。
	 误判情况： 对应服务器不存在该URL的缓存。
	
	 Thanks to:
	 http://allenkim67.github.io/2016/05/17/nodejs-buffer-tutorial.html
	 https://github.com/ceejbot/xx-bloom
	 https://github.com/pierrec/js-xxhash
	 */
	
	var LN2_SQUARED = Math.LN2 * Math.LN2;
	
	var BloomFilter = function () {
	    function BloomFilter() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        (0, _classCallCheck3.default)(this, BloomFilter);
	
	        this.init(options);
	    }
	
	    BloomFilter.prototype.init = function init(options) {
	        if (options.seeds) {
	            this.seeds = options.seeds;
	            this.hashes = options.seeds.length;
	        } else {
	            this.seeds = [];
	            this.hashes = options.hashes || 0;
	
	            this._generateSeeds();
	        }
	
	        this.bits = options.bits || 1024;
	        this.buffer = Buffer.alloc(Math.ceil(this.bits / 8));
	
	        this.clear();
	    };
	
	    BloomFilter.optimize = function optimize(itemCount) {
	        var errorRate = arguments.length <= 1 || arguments[1] === undefined ? 0.005 : arguments[1];
	
	        var bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED);
	        var hashes = Math.round(bits / itemCount * Math.LN2);
	
	        return {
	            bits: bits,
	            hashes: hashes
	        };
	    };
	
	    BloomFilter.createOptimal = function createOptimal(itemCount, errorRate) {
	        var opts = this.optimize(itemCount, errorRate);
	
	        return new this(opts);
	    };
	
	    BloomFilter.prototype.clear = function clear() {
	        //  buf.fill(0) to initialize a Buffer to zeroes
	        this.buffer.fill(0);
	    };
	
	    BloomFilter.prototype._generateSeeds = function _generateSeeds() {
	        if (!this.seeds) this.seeds = [];
	
	        for (var i = 0; i < this.hashes; ++i) {
	            // Generates cryptographically strong pseudo-random data. Generate 4 bytes.
	            var buf = (0, _crypto.randomBytes)(4);
	            // Reads an unsigned 32-bit integer from the Buffer from index 0
	            this.seeds[i] = buf.readUInt32LE(0);
	
	            // Make sure we don't end up with two identical seeds,
	            // which is unlikely but possible.
	            for (var j = 0; j < i; ++j) {
	                if (this.seeds[i] === this.seeds[j]) {
	                    --i;
	                    break;
	                }
	            }
	        }
	    };
	
	    BloomFilter.prototype.add = function add(buf) {
	        if (Array.isArray(buf)) {
	            for (var _iterator = buf, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	                var _ref;
	
	                if (_isArray) {
	                    if (_i >= _iterator.length) break;
	                    _ref = _iterator[_i++];
	                } else {
	                    _i = _iterator.next();
	                    if (_i.done) break;
	                    _ref = _i.value;
	                }
	
	                var item = _ref;
	
	                this.add(item);
	            }
	        } else {
	            buf = Buffer.from(buf);
	
	            for (var i = 0; i < this.hashes; ++i) {
	                var hash = (0, _xxhashjs.h32)(buf, this.seeds[i]).toString();
	                var bit = hash % this.bits;
	                this._setBit(bit);
	            }
	        }
	    };
	
	    BloomFilter.prototype.has = function has(item) {
	        item = Buffer.from(item);
	
	        for (var i = 0; i < this.hashes; ++i) {
	            var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
	            var bit = hash % this.bits;
	
	            var isInSet = this._getBit(bit);
	            if (!isInSet) return false;
	        }
	
	        return true;
	    };
	
	    BloomFilter.prototype._setBit = function _setBit(bit) {
	        var pos = Math.floor(bit / 8);
	        var shift = bit % 8;
	
	        var bitField = this.buffer[pos];
	        bitField |= 0x1 << shift;
	        this.buffer[pos] = bitField;
	    };
	
	    BloomFilter.prototype._getBit = function _getBit(bit) {
	        var pos = Math.floor(bit / 8);
	        var shift = bit % 8;
	
	        var bitField = this.buffer[pos];
	
	        return (bitField & 0x1 << shift) !== 0;
	    };
	
	    return BloomFilter;
	}();
	
	exports.default = BloomFilter;
	
	
	var filter = new BloomFilter({ hashes: 8, bits: 1024 });
	filter.add(['cat', 'dog', 'coati', 'red panda']);
	console.log(filter.has('cat'));
	console.log(filter.has('coat'));
	console.log(filter.has('null'));
	
	var CountingBloomFilter = function (_BloomFilter) {
	    (0, _inherits3.default)(CountingBloomFilter, _BloomFilter);
	
	    function CountingBloomFilter() {
	        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        (0, _classCallCheck3.default)(this, CountingBloomFilter);
	        return (0, _possibleConstructorReturn3.default)(this, _BloomFilter.call(this, opts));
	    }
	
	    CountingBloomFilter.prototype.init = function init(opts) {
	        if (opts.seeds) {
	            this.seeds = opts.seeds;
	            this.hashes = opts.seeds.length;
	        } else {
	            this.hashes = opts.hashes || 8;
	            this._generateSeeds();
	        }
	
	        this.bits = opts.bits || 1024;
	        this.buffer = Buffer.alloc(this.bits);
	
	        this.clear();
	    };
	
	    CountingBloomFilter.createOptimal = function createOptimal(itemCount, errorRate) {
	        var opts = BloomFilter.optimize(itemCount, errorRate);
	        return new this(opts);
	    };
	
	    CountingBloomFilter.prototype.clear = function clear() {
	        _BloomFilter.prototype.clear.call(this);
	
	        this.overflow = 0;
	    };
	
	    CountingBloomFilter.prototype._setBit = function _setBit(bit) {
	        // no-op at overflow
	        if (this.buffer[bit] === 255) {
	            ++this.overflow;
	            return;
	        }
	
	        ++this.buffer[bit];
	    };
	
	    CountingBloomFilter.prototype._unSetBit = function _unSetBit(bit) {
	        if (this.buffer[bit] === 255 || this.buffer[bit] === 0) return;
	
	        --this.buffer[bit];
	    };
	
	    CountingBloomFilter.prototype._getBit = function _getBit(bit) {
	        return this.buffer[bit] !== 0;
	    };
	
	    CountingBloomFilter.prototype.remove = function remove(item) {
	        if (!Buffer.isBuffer(item)) item = Buffer.from(item);
	
	        for (var i = 0; i < this.seeds.length; ++i) {
	            var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
	            var bit = hash % this.bits;
	
	            this._unSetBit(bit);
	        }
	    };
	
	    (0, _createClass3.default)(CountingBloomFilter, [{
	        key: 'hasOverflowed',
	        get: function get() {
	            return this.overflow > 0;
	        }
	    }]);
	    return CountingBloomFilter;
	}(BloomFilter);
	
	console.log('CountingBloomFilter');
	var filter = new CountingBloomFilter({ hashes: 8, bits: 1024 });
	filter.add(['cat', 'dog', 'coati', 'red panda']);
	console.log(filter.has('cat'));
	filter.remove('cat');
	console.log(filter.has('cat'));
	console.log(filter.has('coat'));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.TrieTree = exports.DoubleLinkedTree = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/1/11.
	 */
	
	/*
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，也叫字典树，来表示这样的字符串的集合。
	
	 概念
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。键树又称为数字查找树（Digital Search Tree)或Trie树(trie为retrieve中间4个字符)，其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A,B,C,....Z的单词所在页,再对各部分标出第二字母为A,B,C,...Z的单词所在的页, ....等等。
	
	 键树是一种特殊的查找树，它的某个节点不是包含一个或多个关键字，而是只包含组成关键字的一部分（字符或数字），比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。
	
	 根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。事实上，还可以赋予“字符串”更广泛的含义，它可以是任何类型的对象组成的串。
	
	
	 键树的存储
	 1）双链树表示
	 2) 多重链表表示
	
	
	 键树的应用场景
	
	 Trie是一种非常简单高效的数据结构，但有大量的应用实例。
	 （1） 字符串检索
	 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
	 举例：
	 @  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
	 @  给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。
	
	 （2）字符串最长公共前缀
	 Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
	 举例：
	 @ 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？
	 解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
	 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
	 1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
	 2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；
	 （关于并查集，Tarjan算法，RMQ问题，网上有很多资料。）
	
	 （3）排序
	 Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
	 举例：
	 @ 给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。
	
	 （4） 作为其他数据结构和算法的辅助结构
	 如后缀树，AC自动机等
	 */
	
	/*
	 双链树表示
	
	 以树的孩子兄弟链表来表示键树，则每个分支结点包括三个域：
	 symbol域：存储关键字的一个字符；
	 first域：存储指向第一棵子树根的指针；
	 next域：存储指向右兄弟的指针。
	
	 同时，叶子结点不含first域，它的infoptr域存储指向该关键字记录的指针。
	 此时的键树又称双链树。
	 在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。
	 结点的结构中可以设置一个枚举变量表示结点的类型，叶子结点和分支结点。
	 叶子结点和分支结点都有symbol域和next域。不同的一个域可以用联合表示，叶子结点包含infoptr指向记录，而分支结点是first域指向其第一棵子树。
	
	
	 双链树的查找
	
	 假设给定值为K.ch(0..num-1), 其中K.ch[0]至 K.ch[num-2]表示待查关键字中num-1个字符， K.ch[num-1]为结束符$。
	 从双链树的根指针出发，顺first指针找到第一棵子树的根结点，以K.ch[0]和此结点的symbol域比较，若相等，则顺first域再比较下一字符，否则沿next域顺序查找。
	 若直至空仍比较不等，则查找不成功。
	
	 // 相关资料
	 http://www.cnblogs.com/rollenholt/archive/2012/04/24/2468932.html
	 http://blog.csdn.net/v_july_v/article/details/6897097
	 http://www.raychase.net/1783
	 */
	
	var LEAF = 'leaf';
	var BRANCH = 'branch';
	var TERMINAL = new String('$');
	
	var DoubleLinkedTree = exports.DoubleLinkedTree = function () {
	    function DoubleLinkedTree() {
	        var symbol = arguments.length <= 0 || arguments[0] === undefined ? 'root' : arguments[0];
	        var kind = arguments.length <= 1 || arguments[1] === undefined ? BRANCH : arguments[1];
	        var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, DoubleLinkedTree);
	
	        this.symbol = symbol;
	        this.next = null;
	        this.kind = kind;
	        this.info = info;
	        this.first = null;
	    }
	
	    DoubleLinkedTree.prototype.synoSearch = function synoSearch(key) {
	        var p = this.first;
	
	        for (var i = 0; p && i < key.length; ++i) {
	            if (p && p.kind === LEAF) break;
	            while (p && p.symbol < key[i]) {
	                p = p.next;
	            }if (p && p.symbol === key[i]) p = p.first;else p = null;
	        }
	
	        return p && p.kind === LEAF ? p.info : null;
	    };
	
	    DoubleLinkedTree.prototype.search = function search(key) {
	        var p = this.first;
	
	        for (var i = 0; p && i < key.length; ++i) {
	            while (p && p.symbol < key[i]) {
	                p = p.next;
	            }if (p && p.symbol === key[i]) p = p.first;else p = null;
	        }
	
	        return p && p.kind === LEAF ? p.info : null;
	    };
	
	    DoubleLinkedTree.prototype.insert = function insert(key, value) {
	        key += '';
	        var cur = this;
	
	        for (var i = 0; i < key.length; ++i) {
	            var c = key[i];
	            var p = cur;
	            cur = cur.first;
	            var node = new DoubleLinkedTree(c, BRANCH);
	
	            // 如果没有子结点则将新结点作为子结点
	            if (!cur) {
	                p.first = node;
	                node.parent = p;
	                cur = node;
	            } else {
	                // 在兄弟结点中找到对应结点
	                if (c < cur.symbol) {
	                    node.parent = cur.parent;
	                    node.next = cur;
	                    node.parent.first = node;
	                    cur = node;
	                } else if (c > cur.symbol) {
	                    var b = void 0;
	                    while (cur) {
	                        // 如果相等，退出该循环查找下一字符
	                        if (c === cur.symbol) break;
	                        // 如果小于当前字符，则插入到当前结点前面
	                        else if (c < cur.symbol) {
	                                node.parent = cur.parent;
	                                node.next = cur;
	                                b.next = node;
	                                cur = node;
	                                break;
	                            } else {
	                                b = cur;
	                                cur = cur.next;
	                            }
	                    }
	
	                    // 如果没有兄弟结点则插入到兄弟结点
	                    if (!cur) {
	                        b.next = node;
	                        node.parent = b.parent;
	                        cur = node;
	                    }
	                }
	            }
	        }
	
	        // 生成叶子结点
	        var success = false;
	        if (cur.kind === BRANCH) {
	            var child = cur.first;
	
	            // 如果不存在关键字则说明插入成功，否则插入失败
	            if (!(child && child.symbol === TERMINAL)) {
	                cur.first = new DoubleLinkedTree(TERMINAL, LEAF, value != null ? value : key);
	                cur.first.parent = cur;
	                cur.first.next = child;
	                success = true;
	            }
	        }
	
	        return success;
	    };
	
	    DoubleLinkedTree.prototype.remove = function remove(key) {
	        var p = this.first;
	        var i = 0;
	
	        while (p && i < key.length) {
	            while (p && p.symbol < key[i]) {
	                p = p.next;
	            }if (p && p.symbol === key[i]) {
	                p = p.first;
	                ++i;
	            } else return false;
	        }
	
	        var data = p.info;
	        while (!p.next && p.parent) {
	            p = p.parent;
	        }var top = p;
	
	        if (top == this) {
	            this.first = null;
	            return data;
	        }
	
	        p = top.parent;
	        if (p) {
	            p = p.first;
	            while (p) {
	                var pre = void 0;
	                if (p == top) {
	                    // 删除在first域上的子树结点
	                    if (!pre) top.parent.first = top.parent.first.next;
	                    // 删除在next域的兄弟结点
	                    else pre.next = pre.next.next;
	
	                    return data;
	                } else {
	                    pre = p;
	                    p = p.next;
	                }
	            }
	        }
	
	        return false;
	    };
	
	    return DoubleLinkedTree;
	}();
	
	var test = new DoubleLinkedTree();
	test.insert('CAI');
	test.insert('LAN');
	test.insert('CAO');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CHAO');
	test.insert('CHEN');
	test.insert('LI');
	test.insert('LIU');
	test.insert('ZHAO');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('CAI'));
	console.log(test.search('CHA'));
	console.log(test.search('CHANG'));
	console.log(test.search('ZHAOx'));
	
	console.log('\nremove:');
	console.log(test.remove('CAI'));
	console.log(test.remove('CAI'));
	console.log(test.remove('LAN'));
	console.log(test.remove('CAO'));
	console.log(test.remove('CHA'));
	console.log(test.remove('CHANG'));
	console.log(test.remove('CHAO'));
	console.log(test.remove('CHEN'));
	console.log(test.remove('LI'));
	console.log(test.remove('LIU'));
	console.log(test.remove('ZHAO'));
	
	/*
	 多重链表表示
	
	 若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树。
	 （Trie是从检索retrieve中取中间四个字符的，读音同try）。
	 若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。
	 在Trie树中有两种结点：
	 分支结点：含有d个指针域和一个指示该结点中非空指针域的个数的整数域。在分支结点中不设数据域，每个分支结点所表示的字符均有其父结点中指向该结点的指针所在位置决定。
	 叶子结点：含有关键字域和指向记录的指针域。
	
	
	 在Trie树上进行查找
	
	 从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功，若分支结点中和给定值相应的指针为空，或叶子结点中的关键字和给定值不相等，则查找不成功。
	
	
	 优化Trie树的深度
	
	 我们可对关键字集选择一种合适的分割。先按首字符不通分成多个子集之后，然后按最后一个字符不同分割每个子集，再按第二个字符。。。前后交叉分割。一缩减Trie树的深度
	 */
	// 求字符在字母表中的序号
	function order(c) {
	    return c ? c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1 : 0;
	}
	
	// 通过回溯法清理Trie树的函数
	function removeNode(trieNode, order, clear) {
	    trieNode.branch.nodes[order] = null;
	    --trieNode.branch.num;
	
	    if (!clear) return;
	
	    var nodes = trieNode.branch.nodes;
	    var parent = trieNode.parent;
	    var pre = trieNode;
	
	    while (parent) {
	        for (var i in nodes) {
	            if (nodes.hasOwnProperty(i) && nodes[i]) return;
	        }
	
	        var index = void 0;
	        var parentNodes = parent.branch.nodes;
	        for (var _i in parentNodes) {
	            if (parentNodes.hasOwnProperty(_i) && parentNodes[_i] && parentNodes[_i] == pre) index = _i;
	        }
	        parent.branch.nodes[index] = null;
	        --parent.branch.num;
	
	        pre = parent;
	        nodes = parent.branch.nodes;
	        parent = parent.parent;
	    }
	}
	
	var TrieTree = exports.TrieTree = function () {
	    function TrieTree() {
	        var kind = arguments.length <= 0 || arguments[0] === undefined ? BRANCH : arguments[0];
	        (0, _classCallCheck3.default)(this, TrieTree);
	
	        this.kind = kind;
	        this.parent = null;
	
	        if (kind === LEAF) {
	            this.leaf = {
	                key: null,
	                info: null
	            };
	        } else {
	            this.branch = {
	                // “$”为第一个字符，后续为26个字母
	                nodes: new Array(27),
	                num: 0
	            };
	        }
	    }
	
	    TrieTree.prototype.search = function search(key) {
	        var p = this,
	            i = 0;
	        for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {}
	
	        if (p) {
	            if (p.kind === LEAF && p.leaf.key === key) return p.leaf.info;
	            // 同义词
	            else if (p.kind === BRANCH) {
	                    p = p.branch.nodes[0];
	                    if (p && p.leaf.key === key) return p.leaf.info;
	                }
	        }
	
	        return null;
	    };
	
	    TrieTree.prototype.insert = function insert(key, value) {
	        // 建叶子结点
	        var q = new TrieTree(LEAF);
	        q.leaf.key = key;
	        q.leaf.info = value;
	
	        // 自上而下查找
	        var last = void 0;
	        var p = this,
	            i = 0;
	        for (; p && p.kind === BRANCH && i < key.length && p.branch.nodes[order(key[i])]; p = p.branch.nodes[order(key[i])], ++i) {
	            last = p;
	        } // 如果最后落到分支结点（无同义词）
	        // 直接连上叶子
	        if (p.kind === BRANCH) {
	            p.branch.nodes[order(key[i])] = q;
	            q.parent = p;
	            ++p.branch.num;
	        }
	        // 如果最后落到叶子结点（有同义词）
	        else {
	                if (p.leaf.key === key) return false;
	
	                // 建立新的分支结点
	                var r = new TrieTree(BRANCH);
	                // 用新的分支结点取代老叶子结点和上一层的联系
	                last.branch.nodes[order(key[i - 1])] = r;
	                r.parent = last;
	                r.branch.num = 2;
	                r.branch.nodes[order(key[i])] = q;
	                q.parent = r;
	                // 新分支结点与新老两个叶子结点相连
	                r.branch.nodes[order(p.leaf.key[i])] = p;
	                p.parent = r;
	            }
	
	        return true;
	    };
	
	    /**
	     *
	     * @param key
	     * @param {Boolean} clear 是否需要清理结点
	     * @returns {*} 如果删除成功返回info数据否则返回false
	     */
	
	
	    TrieTree.prototype.remove = function remove(key, clear) {
	        var last = void 0;
	        var p = this,
	            i = 0;
	        // 查找待删除元素
	        for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {
	            last = p;
	        }if (!p) return false;
	
	        clear = typeof clear !== 'undefined' ? clear : true;
	        var data = null;
	
	        if (p.kind === LEAF && p.leaf.key === key) {
	            data = p.leaf.info;
	            removeNode(last, order(key[i - 1]), clear);
	            return data;
	        } else if (p.kind === BRANCH) {
	            p = p.branch.nodes[0];
	            if (p && p.leaf.key === key) {
	                data = p.leaf.info;
	                removeNode(p.parent, 0, clear);
	                return data;
	            }
	        }
	
	        return false;
	    };
	
	    return TrieTree;
	}();
	
	var test = new TrieTree();
	
	test.insert('CHA');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CAI');
	test.insert('CHEN');
	test.insert('CAO');
	test.insert('CHAO');
	test.insert('LONG');
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');
	test.insert('WANG');
	test.insert('WEN');
	test.insert('WU');
	test.insert('YANG');
	test.insert('YUN');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('YUN'));
	console.log(test.search('ZHAO'));
	console.log(test.search('CHA'));
	
	test.remove('LAN');
	test.remove('LIU');
	test.remove('WANG');
	test.remove('WEN');
	test.remove('WU');
	test.remove('YANG');
	test.remove('YUN');
	test.remove('ZHAO');
	test.remove('CHA');
	test.remove('CHANG');
	test.remove('CAI');
	test.remove('CHEN');
	test.remove('CAO');
	test.remove('CHAO');
	test.remove('LONG');
	test.remove('LI');
	
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.LinkedListHashTable = exports.HashTable = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _LinkedList = __webpack_require__(54);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hashSize = buildHashSize(977, 20); /**
	                                        * HashTable
	                                        * Created by Luke on 2014/12/30.
	                                        */
	
	/**
	哈希(散列)查找
	
	基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。
	
	基本概念
	
	哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数。
	哈希函数是一种映象，是从关键字空间到存储地址空间的一种映象。可写成：addr(ai)=H(ki) ，其中i是表中一个元素，addr(ai)是ai的地址， ki是ai的关键字。
	
	哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表。
	
	哈希查找(又叫散列查找)：利用哈希函数进行查找的过程叫哈希查找。
	
	冲突：对于不同的关键字ki、kj，若kikj，但H(ki)=H(kj)的现象叫冲突(collision) 。
	
	同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。
	哈希函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；当冲突发生时，应该有处理冲突的方法。设计一个散列表应包括：
	①  散列表的空间范围，即确定散列函数的值域；
	②  构造合适的散列函数，使得对于所有可能的元素(记录的关键字)，函数值均在散列表的地址空间范围内，且出现冲突的可能尽量小；
	③  处理冲突的方法。即当冲突出现时如何解决。
	
	
	哈希函数的构造
	
	哈希函数是一种映象，其设定很灵活，只要使任何关键字的哈希函数值都落在表长允许的范围之内即可。哈希函数“好坏”的主要评价因素有：
	◆ 散列函数的构造简单；
	◆ 能“均匀”地将散列表中的关键字映射到地址空间。所谓“均匀”(uniform)是指发生冲突的可能性尽可能最少。
	
	1  直接定址法
	取关键字或关键字的某个线性函数作哈希地址，即H(key)=key    或   H(key)=a·key+b(a,b为常数)
	特点：直接定址法所得地址集合与关键字集合大小相等，不会发生冲突，但实际中很少使用。
	
	2  数字分析法
	对关键字进行分析，取关键字的若干位或组合作为哈希地址。
	适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。
	例： 设有80个记录，关键字为8位十进制数，哈希地址为2位十进制数。
	           
	8  1  3  4  6  5  3  2
	8  1  3  7  2  2  4  2
	8  1  3  8  7  4  2  2
	8  1  3  0  1  3  6  7
	8  1  3  2  2  8  1  7
	8  1  3  3  8  9  6  7
	8  1  3  6  8  5  3  7
	8  1  4  1  9  3  5  5
	分析：  只取8
	       只取1
	       只取3、4
	       只取2、7、5
	      数字分布近乎随机
	所以：取任意两位或两位与另两位的叠加作哈希地址
	
	3  平方取中法
	将关键字平方后取中间几位作为哈希地址。
	一个数平方后中间几位和数的每一位都有关，则由随机分布的关键字得到的散列地址也是随机的。散列函数所取的位数由散列表的长度决定。这种方法适于不知道全部关键字情况，是一种较为常用的方法。
	
	4  折叠法
	将关键字分割成位数相同的几部分(最后一部分可以不同)，然后取这几部分的叠加和作为哈希地址。
	数位叠加有移位叠加和间界叠加两种。
	◆ 移位叠加：将分割后的几部分低位对齐相加。
	◆ 间界叠加：从一端到另一端沿分割界来回折迭，然后对齐相加。
	适于关键字位数很多，且每一位上数字分布大致均匀情况。
	例： 设关键字为0442205864，哈希地址位数为4 。两种不同的地址计算方法如下：
	    5864                        5864
	    4220                        0224
	      04       移位叠加            04           间界叠加
	 ---------                  -------------
	   10088                        6091
	
	5  除留余数法
	取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p     (p<=m)
	是一种简单、常用的哈希函数构造方法。
	利用这种方法的关键是p的选取，p选的不好，容易产生同义词。p的选取的分析：
	◆  选取p=2i(p<=m)：运算便于用移位来实现，但等于将关键字的高位忽略而仅留下低位二进制数。高位不同而低位相同的关键字是同义词。
	◆ 选取p=q*f(q、f都是质因数，p<=m)：则所有含有q或f因子的关键字的散列地址均是q或f的倍数。
	◆ 选取p为素数或p=q*f(q、f是质数且均大于20，p<=m)：常用的选取方法，能减少冲突出现的可能性。
	
	6  随机数法
	取关键字的随机函数值作哈希地址，即H(key)=random(key)
	当散列表中关键字长度不等时，该方法比较合适。
	
	
	
	选取哈希函数，考虑以下因素
	◆ 计算哈希函数所需时间；
	◆ 关键字的长度；
	◆ 哈希表长度（哈希地址范围）；
	◆ 关键字分布情况；
	◆ 记录的查找频率。
	
	
	
	冲突处理的方法
	冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。
	
	1  开放定址法
	基本方法：当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。散列地址的计算公式是：
	Hi(key)=(H(key)+di)  MOD m，i=1, 2, …, k(k<=m-1)
	
	其中：H(key)：哈希函数；m：散列表长度；
	di：第i次探测时的增量序列；
	Hi(key) ：经第i次探测后得到的散列地址。
	
	⑴  线性探测法
	将散列表T[0 …m-1]看成循环向量。当发生冲突时，从初次发生冲突的位置依次向后探测其他的地址。
	增量序列为：di=1, 2, 3, …, m-1
	设初次发生冲突的地址是h，则依次探测T[h+1]，T[h+2]…，直到T[m-1]时又循环到表头，再次探测T[0]，T[1]…，直到T[h-1]。探测过程终止的情况是：
	◆ 探测到的地址为空：表中没有记录。若是查找则失败；若是插入则将记录写入到该地址；
	◆ 探测到的地址有给定的关键字：若是查找则成功；若是插入则失败；
	◆ 直到T[h]：仍未探测到空地址或给定的关键字，散列表满。
	
	例1 ：设散列表长为7，记录关键字组为：15, 14, 28, 26, 56, 23，散列函数：H(key)=key   MOD  7，冲突处理采用线性探测法。
	H(15)=15  MOD 7=1
	H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0  冲突   H1(28)=1  又冲突
	H2(28)=2           H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=2   又冲突    H3(56)=3
	H(23)=23  MOD 7=2     冲突      H1(23)=3     又冲突
	H3(23)=4
	
	0     1      2      3      4       5     6
	14    15     28     56     23      26
	
	线性探测法的特点
	◆ 优点：只要散列表未满，总能找到一个不冲突的散列地址；
	◆ 缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而又增加了更多的冲突机会(这种现象称为冲突的“聚集”)。
	
	⑵  二次探测法
	增量序列为：di=1²,-1²,2²,-2²,3²,……±k²  (k<=⌊m/2⌋)
	
	上述例题若采用二次探测法进行冲突处理，则：
	H(15)=15  MOD 7=1         H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0     冲突      H1(28)=1     又冲突
	H2(28)=4
	H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=0   又冲突    H3(56)=4    又冲突
	H4(56)=2
	H(23)=23  MOD 7=2      冲突
	H1(23)=3
	
	二次探测法的特点
	◆ 优点：探测序列跳跃式地散列到整个表中，不易产生冲突的“聚集”现象；
	◆ 缺点：不能保证探测到散列表的所有地址。
	
	⑶   伪随机探测法
	增量序列使用一个伪随机函数来产生一个落在闭区间[1，m-1]的随机序列。
	
	例2 ： 表长为11的哈希表中已填有关键字为17，60，29的记录，散列函数为H(key)=key  MOD  11 。 现有第4个记录，其关键字为38，按三种处理冲突的方法，将它填入表中。
	
	(1)  H(38)=38 MOD 11=5    冲突
	     H1=(5+1) MOD 11=6    冲突
	     H2=(5+2) MOD 11=7    冲突
	     H3=(5+3) MOD 11=8    不冲突
	(2)  H(38)=38 MOD 11=5      冲突
	     H1=(5+1²) MOD 11=6    冲突
	     H2=(5-1²) MOD 11=4     不冲突
	(3)  H(38)=38 MOD 11=5    冲突
	     设伪随机数序列为9，则H1=(5+9) MOD 11=3 不冲突
	
	
	2  再哈希法
	构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即：Hi=RHi(key)     i=1, 2, …, k
	RHi ：一组不同的哈希函数。第一次发生冲突时，用RH1计算，第二次发生冲突时，用RH2计算…依此类推知道得到某个Hi不再冲突为止。
	◆  优点：不易产生冲突的“聚集”现象；
	◆  缺点：计算时间增加。
	
	
	3  链地址法
	方法：将所有关键字为同义词(散列地址相同)的记录存储在一个单链表中，并用一维数组存放链表的头指针。
	设散列表长为m，定义一个一维指针数组：
	RecNode *linkhash[m]，其中RecNode是结点类型，每个分量的初值为空。凡散列地址为k的记录都插入到以linkhash[k]为头指针的链表中，插入位置可以在表头或表尾或按关键字排序插入。
	
	例： 已知一组关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79) ，哈希函数为：H(key)=key MOD 13，用链地址法处理冲突:
	
	 0
	 1  --> 14 -> 1 -> 27 -> 79
	 2
	 3  --> 68 -> 55
	 4
	 5
	 6  --> 19 -> 84
	 7  --> 20
	 8
	 9
	 10 --> 23 -> 10
	 11 --> 11
	 12
	
	 优点：不易产生冲突的“聚集”；删除记录也很简单。
	
	
	 4  建立公共溢出区
	 方法：在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。
	 设散列表长为m，设立基本散列表hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。
	
	 例： 已知一组关键字(15, 4, 18, 7, 37, 47) ，散列表长度为7 ，哈希函数为：H(key)=key MOD 7，用建立公共溢出区法处理冲突。得到的基本表和溢出表如下：
	                    散列地址    0     1     2     3     4     5     6
	 Hashtable表：
	                    关键字     7     15    37          4     47
	
	                    溢出地址    0     1     2     3     4     5     6
	 overtable表：
	                     关键字    18
	
	
	
	
	 哈希查找过程及分析
	
	 1   哈希查找过程
	 哈希表的主要目的是用于快速查找，且插入和删除操作都要用到查找。由于散列表的特殊组织形式，其查找有特殊的方法。
	
	 给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定关键字相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直到哈希表中某个位置为空或者表中所填记录的关键字等于给定值时为止。
	
	
	
	 哈希查找分析
	
	 从哈希查找过程可见：尽管散列表在关键字与记录的存储地址之间建立了直接映象，但由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用ASL。
	 哈希查找时关键字与给定值比较的次数取决于：
	 ◆ 哈希函数；
	 ◆ 处理冲突的方法；
	 ◆ 哈希表的填满因子α 。填满因子α的定义是：
	
	 α = 表中填入的记录数 / 哈希表长度
	
	
	 各种散列函数所构造的散列表的ASL如下：
	
	 ⑴   线性探测法的平均查找长度是：
	 S成功 约等于 1 / 2 * (1 + 1 / (1 - α))
	 S失败 约等于 1 / 2 * (1 + 1 / (1 - α) * (1 - α))
	
	 ⑵   二次探测、伪随机探测、再哈希法的平均查找长度是：
	 S成功 约等于 -1 / α * ln(1 - α)
	 S失败 约等于 1 / (1 - α)
	
	 ⑶   用链地址法解决冲突的平均查找长度是：
	 S成功 约等于 1 + α / 2
	 S失败 约等于 α + e的-α次幂
	
	
	 */
	
	var HashTable = exports.HashTable = function () {
	    function HashTable() {
	        (0, _classCallCheck3.default)(this, HashTable);
	
	        this.data = [];
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	    }
	
	    // 使用线性探测法解决冲突
	
	
	    HashTable.prototype.search = function search(key) {
	        var max = hashSize[this.sizeIndex];
	        var p = hash(key, max);
	        var c = 0;
	
	        while (p < max && this.data[p] != null && key !== this.data[p]) {
	            p = collision(key, ++c, max);
	        }
	
	        return {
	            success: key === this.data[p],
	            collisionTimes: c,
	            index: p
	        };
	    };
	
	    HashTable.prototype.insert = function insert(key) {
	        var max = hashSize[this.sizeIndex];
	        if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	        var ret = this.search(key);
	        var p = ret.index;
	        var c = ret.collisionTimes;
	
	        if (ret.success) return false;else if (c < hashSize[this.sizeIndex] / 2) {
	            this.data[p] = key;
	            ++this.count;
	            return true;
	        } else {
	            this.recreateHashTable();
	            return false;
	        }
	    };
	
	    HashTable.prototype.remove = function remove(key) {
	        if (!this.count) return false;
	
	        var max = hashSize[this.sizeIndex];
	        var p = hash(key, max);
	        var c = 0;
	
	        while (key !== this.data[p]) {
	            p = collision(key, ++c, max);
	        }if (key === this.data[p]) {
	            var data = this.data[p];
	            this.data.splice(p, 1);
	            --this.count;
	
	            return data;
	        }
	
	        return false;
	    };
	
	    HashTable.prototype.recreateHashTable = function recreateHashTable() {
	        return ++this.sizeIndex < hashSize.length;
	    };
	
	    return HashTable;
	}();
	
	;
	
	// ELFhash字符串散列函数
	function hash(str, max) {
	    var hash = 0;
	    for (var i = 0; i < str.length; i++) {
	        hash = (hash << 5) + hash + str.charCodeAt(i);
	        hash = hash & hash; // Convert to 32bit integer
	        hash = Math.abs(hash);
	    }
	    return hash % max;
	}
	
	function collision(key, times, max) {
	    // 线性探测法
	    return (hash(key, max) + times) % max;
	}
	
	function isPrime(n) {
	    if (n <= 3) return n > 1;
	    if (n % 2 === 0 || n % 3 === 0) return false;
	    for (var i = 5; i * i <= n; i += 6) {
	        if (n % i === 0 || n % (i + 2) === 0) return false;
	    }
	
	    return true;
	}
	
	function buildHashSize(begin, length) {
	    var hashSize = [];
	
	    while (1) {
	        if (hashSize.length >= length) break;
	        if (isPrime(begin)) hashSize.push(begin);
	        ++begin;
	    }
	
	    return hashSize;
	}
	
	// 开放定址法
	//hashSize = [5, 7]; // for test. will be deleted
	var test = new HashTable();
	test.insert('17');
	test.insert('60');
	test.insert('29');
	test.insert('38');
	test.insert('39');
	test.insert('40');
	
	test.remove('17');
	test.remove('60');
	test.remove('29');
	test.remove('38');
	test.remove('39');
	test.remove('40');
	
	// 使用链地址法解决冲突的哈希表
	
	var LinkedListHashTable = exports.LinkedListHashTable = function () {
	    function LinkedListHashTable() {
	        (0, _classCallCheck3.default)(this, LinkedListHashTable);
	
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	        this.hNodes = [];
	    }
	
	    LinkedListHashTable.prototype.search = function search(key) {
	        var max = hashSize[this.sizeIndex];
	        var i = hash(key, max);
	        var t = this.hNodes;
	
	        if (t[i] == null) return { success: false, index: i };
	
	        var p = t[i];
	        var data = null;
	
	        p.each(function (node) {
	            if (node.data === key) {
	                data = node.data;
	                return true;
	            }
	        });
	
	        return { success: data === key, index: i };
	    };
	
	    LinkedListHashTable.prototype.insert = function insert(key) {
	        var max = hashSize[this.sizeIndex];
	        if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	        var ret = this.search(key);
	        var index = ret.index;
	
	        if (ret.success) return false;
	
	        if (!this.hNodes[index]) this.hNodes[index] = new _LinkedList2.default();
	
	        if (this.hNodes[index].size() < hashSize[this.sizeIndex] / 2) {
	            this.hNodes[index].orderInsert(key);
	            ++this.count;
	            return true;
	        } else {
	            this.recreateHashTable();
	            return false;
	        }
	    };
	
	    LinkedListHashTable.prototype.remove = function remove(key) {
	        if (!this.count) return false;
	
	        var ret = this.search(key);
	
	        if (ret.success) {
	            var index = ret.index;
	            var data = ret.data;
	            this.hNodes[index]['remove'](key);
	            --this.count;
	            return data;
	        }
	
	        return false;
	    };
	
	    LinkedListHashTable.prototype.recreateHashTable = function recreateHashTable() {
	        return ++this.sizeIndex < hashSize.length;
	    };
	
	    return LinkedListHashTable;
	}();
	
	;
	
	var test2 = new LinkedListHashTable();
	test2.insert('17');
	test2.insert('60');
	test2.insert('29');
	test2.insert('38');
	test2.insert('39');
	test2.insert('40');
	
	test2.remove('17');
	test2.remove('60');
	test2.remove('29');
	test2.remove('38');
	test2.remove('39');
	test2.remove('40');

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(19);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(18);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinarySortedTree = __webpack_require__(56);
	
	var _BinarySortedTree2 = _interopRequireDefault(_BinarySortedTree);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RED = 'red'; /**
	                  * Red Black Tree
	                  * Created by Luke on 2014/12/30.
	                  */
	/*
	 http://blog.csdn.net/v_july_v/article/details/6105630
	
	 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
	 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
	
	 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。
	
	 红黑树的5个性质：
	 1.每个结点要么是红的要么是黑的。
	 2.根结点是黑的。
	 3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
	 4.如果一个结点是红的，那么它的两个儿子都是黑的。
	 5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
	
	 正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。
	
	
	 树的旋转
	
	当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。
	
	树的旋转分为左旋和右旋
	
	树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。
	
	
	红黑树的插入
	
	如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。
	但当遇到下述3种情况时又该如何调整呢？
	● 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况
	对此，我们的解决策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	于是，插入修复情况1转换成了插入修复情况2
	
	● 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	从而插入修复情况2转换成了插入修复情况3。
	
	● 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。
	
	经过上面情况3、情况4、情况5等3种插入修复情况的操作示意图，读者自会发现，后面的情况4、情况5都是针对情况3插入节点4以后，进行的一系列插入修复情况操作，不过，指向当前节点N指针一直在变化。所以，你可以想当然的认为：整个下来，情况3、4、5就是一个完整的插入修复情况的操作流程
	
	
	红黑树的删除
	
	在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。
	
	上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。
	
	 如果是以下情况，恢复比较简单：
	 a)当前节点是红+黑色
	 解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
	 b)当前节点是黑+黑且是根节点， 解法：什么都不做，结束。
	
	 但如果是以下情况呢？：
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
	 此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。
	
	 下面，咱们便来分别处理这4种删除修复情况。
	
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。
	
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变）
	
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持
	
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	
	
	 最后值得一提的是上述删除修复的情况1~4都只是树的局部，并非树的整体全部，且删除修复情况3、4在经过上面的调整后，调整还没结束,还得继续调整直至重新恢复平衡
	*/
	
	var BLACK = 'black';
	
	var RedBlackNode = function (_BSTNode) {
	    (0, _inherits3.default)(RedBlackNode, _BSTNode);
	
	    function RedBlackNode() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        (0, _classCallCheck3.default)(this, RedBlackNode);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, _BSTNode.call.apply(_BSTNode, [this, data].concat(rest)));
	
	        _this.leftChild = null;
	        _this.rightChild = null;
	        _this.parent = null;
	
	        _this.color = RED;
	        _this.data = data;
	        return _this;
	    }
	
	    return RedBlackNode;
	}(_BinarySortedTree2.default);
	
	var RedBlackLeaf = function RedBlackLeaf() {
	    (0, _classCallCheck3.default)(this, RedBlackLeaf);
	
	    this.color = BLACK;
	    this.leftChild = this;
	    this.rightChild = this;
	};
	
	var RedBlackTree = function () {
	    function RedBlackTree() {
	        (0, _classCallCheck3.default)(this, RedBlackTree);
	
	        // 哨兵
	        this.nil = new RedBlackLeaf();
	        this.root = this.nil;
	    }
	
	    /**
	     * 红黑树的递归查找算法
	     * @param data
	     */
	
	
	    RedBlackTree.prototype.find = function find(data) {
	        var z = this.root;
	        var me = this;
	
	        return function find(z, data) {
	            if (z == me.nil || data === z.data) return z;
	
	            if (data < z.data) return find(z.leftChild, data);else return find(z.rightChild, data);
	        }(z, data);
	    };
	
	    /**
	     * 红黑树的插入
	     * @param {*} data
	     */
	
	
	    RedBlackTree.prototype.add = function add(data) {
	        var z = new RedBlackNode(data);
	        z.leftChild = this.nil;
	        z.rightChild = this.nil;
	        var y = this.nil;
	        var x = this.root;
	
	        // 找到要插入位置的结点y
	        while (x != this.nil) {
	            y = x;
	
	            if (z.data < x.data) x = x.leftChild;else x = x.rightChild;
	        }
	
	        z.parent = y;
	
	        // 如果y不是根结点，根据大小插入到左或右子树
	        if (y != this.nil) {
	            if (z.data < y.data) y.leftChild = z;else y.rightChild = z;
	        }
	        // 否则插入到根结点
	        else this.root = z == this.nil ? null : z;
	
	        // 插入修复操作
	        this._addFixup(z);
	    };
	
	    /**
	     * 插入算法修复
	     * @param {RedBlackNode} z 待插入的结点
	     * @private
	     */
	
	
	    RedBlackTree.prototype._addFixup = function _addFixup(z) {
	
	        while (z != this.root && z.parent.color === RED) {
	            if (z.parent == z.parent.parent.leftChild) leftAddFixup(this, z);else rightAddFixup(this, z);
	        }
	
	        // 最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡
	        this.root.color = BLACK;
	    };
	
	    /**
	     * 红黑树的删除算法
	     * @param {RedBlackNode} z 待删除结点
	     */
	
	
	    RedBlackTree.prototype.removeNode = function removeNode(z) {
	        var x = void 0,
	            y = void 0;
	
	        // 找到待删除结点的父结点或相邻待替换结点
	        if (z.leftChild == this.nil || z.rightChild == this.nil) y = z;else y = this.successor(z);
	
	        if (y.leftChild != this.nil) x = y.leftChild;else x = y.rightChild;
	
	        x.parent = y.parent;
	
	        // 删除操作
	        if (y.parent == this.nil) this.root = x;else if (y == y.parent.leftChild) y.parent.leftChild = x;else y.parent.rightChild = x;
	
	        if (y != z) z.data = y.data;
	
	        // 删除修复
	        if (y.color === BLACK) this._removeFixup(x);
	    };
	
	    // 算法导论上的删除结点
	
	
	    RedBlackTree.prototype.removeNode2 = function removeNode2(z) {
	        var y = z;
	        var originalYColor = y.color;
	        var x = void 0;
	
	        if (z.leftChild == this.nil) {
	            x = z.rightChild;
	            this._transplant(z, z.rightChild);
	        } else if (z.rightChild == this.nil) {
	            x = z.leftChild;
	            this._transplant(z, z.leftChild);
	        } else {
	            y = this.min(z.rightChild);
	            originalYColor = y.color;
	            x = y.rightChild;
	
	            if (y.parent == z) x.parent = y;else {
	                this._transplant(y, y.rightChild);
	                y.rightChild = z.rightChild;
	                y.rightChild.parent = y;
	            }
	
	            this._transplant(z, y);
	            y.leftChild = z.leftChild;
	            y.leftChild.parent = y;
	            y.color = z.color;
	        }
	
	        if (originalYColor === BLACK) this._removeFixup(x);
	    };
	
	    RedBlackTree.prototype._transplant = function _transplant(u, v) {
	        if (u.parent == this.nil) this.root = v;else if (u == u.parent.leftChild) u.parent.leftChild = v;else u.parent.rightChild = v;
	
	        v.parent = u.parent;
	    };
	
	    /**
	     * 删除修复
	     * @param {RedBlackNode} z
	     * @private
	     */
	
	
	    RedBlackTree.prototype._removeFixup = function _removeFixup(z) {
	        while (z !== this.root && z.color === BLACK) {
	            if (z == z.parent.leftChild) leftRemoveFixup(this, z);else rightRemoveFixup(this, z);
	        }
	
	        z.color = BLACK;
	    };
	
	    RedBlackTree.prototype.successor = function successor(z) {
	        if (z.rightChild != this.nil) return this.min(z.rightChild);
	
	        var y = z.parent;
	
	        while (y != this.nil && z == y.rightChild) {
	            z = y;
	            y = y.parent;
	        }
	
	        return y;
	    };
	
	    RedBlackTree.prototype.min = function min(z) {
	        while (z.leftChild != this.nil) {
	            z = z.leftChild;
	        }
	
	        return z;
	    };
	
	    /**
	     * 根据key值删除结点
	     * @param {*} key
	     * @returns {*}
	     */
	
	
	    RedBlackTree.prototype.remove = function remove(key) {
	        var z = this.find(key);
	
	        if (z == this.nil) return false;
	
	        return this.removeNode(z);
	    };
	
	    return RedBlackTree;
	}();
	
	exports.default = RedBlackTree;
	
	
	RedBlackTree.prototype._rotateLeft = rotate('left');
	RedBlackTree.prototype._rotateRight = rotate('right');
	
	function rotate(dir) {
	    var c1 = void 0,
	        c2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	    }
	
	    return function (x) {
	        var y = x[c1];
	        x[c1] = y[c2];
	
	        if (y[c2] != this.nil) y[c2].parent = x;
	        y.parent = x.parent;
	
	        if (x.parent == this.nil) this.root = y;else if (x == x.parent[c2]) x.parent[c2] = y;else x.parent[c1] = y;
	
	        y[c2] = x;
	        x.parent = y;
	    };
	}
	
	function addFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        rotate1 = void 0,
	        rotate2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        rotate1 = '_rotateLeft';
	        rotate2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        rotate1 = '_rotateRight';
	        rotate2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var y = z.parent.parent[c1];
	
	        // 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	        // 将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	        if (y.color === RED) {
	            z.parent.color = BLACK;
	            y.color = BLACK;
	            z.parent.parent.color = RED;
	            z = z.parent.parent;
	        } else {
	            // 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	            // 解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	            // 从而插入修复情况2转换成了插入修复情况3。
	            if (z === z.parent[c1]) {
	                z = z.parent;
	                tree[rotate1](z);
	            }
	
	            // 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	            // 解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	            z.parent.color = BLACK;
	            z.parent.parent.color = RED;
	            tree[rotate2](z.parent.parent);
	        }
	    };
	}
	
	var leftAddFixup = addFixup('left');
	var rightAddFixup = addFixup('right');
	var leftRemoveFixup = removeFixup('left');
	var rightRemoveFixup = removeFixup('right');
	
	function removeFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        r1 = void 0,
	        r2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        r1 = '_rotateLeft';
	        r2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        r1 = '_rotateRight';
	        r2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var w = z.parent[c1];
	
	        // 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	        // 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法
	        if (w.color === RED) {
	            w.color = BLACK;
	            z.parent.color = RED;
	            tree[r1](z.parent);
	            w = z.parent[c1];
	        }
	
	        // 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	        // 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。
	        if (w[c2].color === BLACK && w[c1].color === BLACK) {
	            w.color = RED;
	            z = z.parent;
	        } else {
	            // 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	            // 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。
	            if (w[c1].color === BLACK) {
	                w[c2].color = BLACK;
	                w.color = RED;
	                tree[r2](w);
	                w = z.parent[c1];
	            }
	
	            // 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	            // 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	            w.color = z.parent.color;
	            z.parent.color = BLACK;
	            w[c1].color = BLACK;
	            tree[r1](z.parent);
	            z = tree.root;
	        }
	    };
	}
	
	var test = new RedBlackTree();
	test.add(13);
	test.add(8);
	test.add(17);
	test.add(1);
	test.add(6);
	test.add(11);
	test.add(15);
	test.add(22);
	test.add(25);
	test.add(27);
	
	test.remove(13);
	test.remove(8);
	test.remove(17);
	test.remove(1);
	test.remove(6);
	test.remove(11);
	test.remove(15);
	test.remove(22);
	test.remove(25);
	test.remove(27);

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.secondOptimal = secondOptimal;
	exports.createSOSTree = createSOSTree;
	
	var _BinaryTree = __webpack_require__(16);
	
	/**
	 * 由有序表sTable[low..high]及其累计权值表weights递归构造次优查找树
	 * @param {BinaryTree} tree
	 * @param {Array} sTable
	 * @param {Array} sWeights
	 * @param {Number} low
	 * @param {Number} high
	 */
	function secondOptimal(tree, sTable, sWeights, low, high) {
	    var i = low;
	    var min = Math.abs(sWeights[high] - sWeights[low]);
	    var dw = sWeights[high] + (sWeights[low - 1] || 0);
	
	    // 选择最小的△Pi值
	    for (var j = low + 1; j <= high; ++j) {
	        var t = Math.abs(dw - sWeights[j] - sWeights[j - 1]);
	        if (t < min) {
	            i = j;
	            min = t;
	        }
	    }
	
	    // 调整树根权，选择邻近权值较大的关键字
	    var a = 0,
	        b = void 0,
	        c = 0;
	    if (i - 1 >= low) b = sWeights[i] - sWeights[i - 1];
	    if (i - 2 >= low) a = sWeights[i - 1] - sWeights[i - 2];
	    if (i + 1 < high) c = sWeights[i + 1] - sWeights[i];
	    if (typeof b === 'number') {
	        if (a > c && a > b) --i;else if (a < c && c > b) ++i;
	    }
	
	    tree.data = sTable[i];
	    //左子树
	    if (i === low) tree.leftChild = null;else {
	        tree.leftChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.leftChild, sTable, sWeights, low, i - 1);
	    }
	    // 右子树
	    if (i === high) tree.rightChild = null;else {
	        tree.rightChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.rightChild, sTable, sWeights, i + 1, high);
	    }
	} /*
	   静态次优查找树
	  
	   适合各记录的查找概率不等的情况
	  
	   查找效率最高即平均查找长度最小，我们可以给出有序表在非等概率情况下应遵循的两个原则：
	   1、最先访问的结点应是访问概率最大的结点；
	   2、每次访问应使结点两边尚未访问的结点的被访概率之和尽可能相等。
	  
	  
	   这两个原则可用一句话来表示，即判定树为带权内路径长度之和最小的二叉树，亦即：PH = ∑wihi  最小，其中 n 为有序表长度，hi 为第 i 个结点在判定树上的层次数，wi = cpi，c 为某个常数，pi 为第 i 个结点的查找概率。
	  
	  
	   这样的树称为静态最优查找树（static optimal search tree），构造这样一棵树的时间代价太大，亦即时间复杂度很大，因此我们通常是构造次优查找树（nearly optimal search tree），构造它的时间代价远远低于构造最优查找树，但查找性能只比最优查找树差1%~2%，很少差3%以上。
	  
	   次优查找树的构造：
	  
	   设有序表每个记录的权值为 wl,wl+1,…,wh，第一个应访问的结点号为 i ，则有：
	   Δpi =   ∑wj - ∑wj   最小，即 Δpi = Min {Δpj }
	   再分别对 {rl,rl+1,…,ri-1} 和 {ri+1,ri+2,…,rh} 分别构造次优查找树
	   */
	
	
	var tree = new _BinaryTree.BinaryTree();
	secondOptimal(tree, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'], [1, 2, 4, 9, 12, 16, 20, 23, 28], 0, 8);
	console.log(tree);
	
	/**
	 * 由有序表构造一棵次优查找树
	 * @param {Object} obj 有序表，数据元素含有权域weight
	 */
	function createSOSTree(obj) {
	    var tree = void 0;
	    if (obj.elems.length === 0) tree = null;else {
	        // 求累计权值表
	        var sw = findSW(obj.weights);
	        tree = new _BinaryTree.BinaryTree();
	        secondOptimal(tree, obj.elems, sw, 0, obj.elems.length - 1);
	    }
	
	    return tree;
	}
	
	function findSW(sTable) {
	    var sw = [sTable[0]];
	
	    for (var i = 1; i < sTable.length; ++i) {
	        sw[i] = sw[i - 1] + sTable[i];
	    }
	
	    return sw;
	}
	
	var sosTree = createSOSTree({
	    elems: ['A', 'B', 'C', 'D', 'E'],
	    weights: [1, 30, 2, 29, 3]
	});
	sosTree.inOrderRecursive(function (value) {
	    console.log('inOrder: ' + value);
	});

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = fibonacciSearch;
	/*
	 Fibonacci查找
	
	 Fibonacci查找方法是根据Fibonacci数列的特点对查找表进行分割。Fibonacci数列的定义是：
	 F(0)=0，F(1)=1，F(j)=F(j-1)+F(j-2) 。
	
	 1  查找思想
	 设查找表中的记录数比某个Fibonacci数小1，即设n=F(j)-1。用Low、High和Mid表示待查找区间的下界、上界和分割位置，初值为Low=0，High=n - 1。
	 ⑴   取分割位置Mid：Mid=F(j-1) ；
	 ⑵   比较分割位置记录的关键字与给定的K值：
	 ① 相等： 查找成功；
	 ②  大于：待查记录在区间的前半段(区间长度为F(j-1)-1)，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段(区间长度为F(j-2)-1)，修改下界指针：Low=Mid+1，转⑴ ；直到越界(Low>High)，查找失败。
	
	 2  算法实现
	 在算法实现时，为了避免频繁计算Fibonacci数，可用两个变量f1和f2保存当前相邻的两个Fibonacci数，这样在以后的计算中可以依次递推计算出。
	
	 3  算法分析
	 由算法知，Fibonacci查找在最坏情况下性能比折半查找差，但平均搜索次数少于折半查找，而且折半查找要求记录按关键字有序；Fibonacci查找的优点是分割时只需进行加、减运算。
	
	 */
	
	function fib(n) {
	    if (n === 0) return 0;
	    if (n === 1) return 1;
	    var f = void 0;
	    var f0 = 0;
	    var f1 = 1;
	    for (var i = 2; i <= n; ++i) {
	        f = f0 + f1;
	        f0 = f1;
	        f1 = f;
	    }
	    return f;
	}
	
	/**
	 * 在有序表ST中用Fibonacci方法查找关键字为key的记录
	 * @param sTable
	 * @param key
	 * @param n
	 */
	function fibonacciSearch(sTable, key) {
	    var n = arguments.length <= 2 || arguments[2] === undefined ? sTable.length : arguments[2];
	
	    var low = 0;
	    var high = n - 1;
	    var f1 = fib(n);
	    var f2 = fib(n - 1);
	
	    while (low <= high) {
	        var mid = low + f1 - 1;
	        if (sTable[mid] === key) return mid;else if (key < sTable[mid]) {
	            high = mid - 1;
	            f2 = f1 - f2;
	            f1 = f1 - f2;
	        } else {
	            low = mid + 1;
	            f1 = f1 - f2;
	            f2 = f2 - f1;
	        }
	    }
	    return -1;
	}
	
	console.log('fibonacciSearch: ');
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 5)); // 4
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 130 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.default = sequentialSearch;
	/*
	 静态查找
	
	 线性表是查找表最简单的一种组织方式
	
	 顺序查找(Sequential Search)
	 1  查找思想
	 从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。
	
	 2  算法分析
	 不失一般性，设查找每个记录成功的概率相等，即Pi=1/n；查找第i个元素成功的比较次数Ci=n-i；
	 ◆ 查找成功时的平均查找长度ASL：(n+1)/2
	 ◆ 包含查找不成功时：查找失败的比较次数为n，若成功与不成功的概率相等，对每个记录的查找概率为Pi=1/(2n)，则平均查找长度ASL：3（n+1）/4
	 */
	
	function sequentialSearch(sTable, key) {
	  for (var i = sTable.length - 1; i >= 0 && sTable[i] !== key; --i) {}
	  return i;
	}
	
	console.log(sequentialSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.countSort = countSort;
	exports.radixSort = radixSort;
	
	var _index = __webpack_require__(57);
	
	/*
	 计数排序
	
	 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。
	
	 计数排序的特征
	
	 当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
	 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
	 通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：
	 1.找出待排序的数组中最大和最小的元素
	 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项
	 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
	 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
	 
	 简要分析：
	 1.计数排序仅适合于小范围的数据进行排序
	 2.不能对浮点数进行排序
	 3.时间复杂度为 O(n)
	 4.计数排序是稳定的（排序后值相同的元素相对于原先的位置是不会发生变化的）
	 */
	
	function maxElem(arr) {
	    var max = arr[0];
	
	    for (var i = 1, len = arr.length; i < len; ++i) {
	        if (max < arr[i]) max = arr[i];
	    }return max;
	}
	
	/**
	 *
	 * @param {Array} sqList 要排序的数组
	 * @param {Number} k 数组中最大的元素值
	 * @returns {Array}
	 */
	/**
	 * Created by ldp on 2015/2/18.
	 */
	
	function countSort() {
	    var sqList = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var k = arguments.length <= 1 || arguments[1] === undefined ? maxElem(sqList) : arguments[1];
	
	    var len = sqList.length;
	    var c = [];
	    var b = [];
	
	    // 初始化辅助数组
	    for (var i = 0; i <= k; ++i) {
	        c[i] = 0;
	    } // 计数数组A中值等于C数组下标的个数
	    for (var _i = 0; _i < len; ++_i) {
	        c[sqList[_i]]++;
	    } // 计数数组A中值小于等于C数组下标的个数
	    for (var _i2 = 1; _i2 <= k; ++_i2) {
	        c[_i2] += c[_i2 - 1];
	    }for (var _i3 = len - 1; _i3 >= 0; --_i3) {
	        b[c[sqList[_i3]] - 1] = sqList[_i3];
	        --c[sqList[_i3]];
	    }
	
	    for (var _i4 = 0; _i4 < len; ++_i4) {
	        sqList[_i4] = b[_i4];
	    }
	}
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	countSort(arr, 100);
	console.log(arr + '');
	
	/*
	 基数排序
	
	 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。
	 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
	 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。
	
	 效率
	
	 基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，k的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。
	 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k = logB(N)，N是待排序数据类型全集的势。虽然有B个不同的数字，需要B个不同的桶，但在每一轮处理中，判断每个待排序数据项只需要一次计算确定对应数位的值，因此在每一轮处理的时候都需要平均n次操作来把整数放到合适的桶中去，所以就有：
	 k约等于logB(N)
	 所以，基数排序的平均时间T就是：
	 T～= logB(N)·n
	 其中前一项是一个与输入数据无关的常数，当然该项不一定小于logn
	 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且在适当选择的B之下，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。
	
	 假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。
	
	 基数排序的简单描述就是将数字拆分为个位十位百位，每个位依次排序。因为这对算法稳定要求高，所以我们对数位排序用到上一个排序方法计数排序。因为基数排序要经过d (数据长度)次排序， 每次使用计数排序， 计数排序的复杂度为 On),  d 相当于常量和N无关，所以基数排序也是 O(n)。基数排序虽然是线性复杂度， 即对n个数字处理了n次，但是每一次代价都比较高， 而且使用计数排序的基数排序不能进行原地排序，需要更多的内存， 并且快速排序可能更好地利用硬件的缓存， 所以比较起来，像快速排序这些原地排序算法更可取。对于一个位数有限的十进制数，我们可以把它看作一个多元组，从高位到低位关键字重要程度依次递减。可以使用基数排序对一些位数有限的十进制数排序。
	 */
	
	// 求数据的最大位数
	function maxBit(arr) {
	    var d = 1;
	    var p = 10;
	
	    for (var i = 0, n = arr.length; i < n; ++i) {
	        while (arr[i] >= p) {
	            p *= 10;
	            ++d;
	        }
	    }
	
	    return d;
	}
	
	function radixSort() {
	    var arr = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var d = arguments.length <= 1 || arguments[1] === undefined ? maxBit(arr) : arguments[1];
	
	    var n = arr.length;
	    var temp = [];
	    // 计数器
	    var count = [];
	    var radix = 1;
	
	    // 进行d次排序
	    for (var i = 1; i <= d; ++i) {
	        // 每次分配前清空计数器
	        for (var j = 0; j < 10; ++j) {
	            count[j] = 0;
	        } // 统计每个桶中的记录数
	        for (var _j = 0; _j < n; ++_j) {
	            var k = Math.floor(arr[_j] / radix) % 10;
	            ++count[k];
	        }
	        for (var _j2 = 1; _j2 < 10; ++_j2) {
	            count[_j2] += count[_j2 - 1];
	        } // 将所有桶中记录依次收集到tmp中
	        for (var _j3 = n - 1; _j3 >= 0; --_j3) {
	            var _k = Math.floor(arr[_j3] / radix) % 10;
	            temp[--count[_k]] = arr[_j3];
	        }
	        //将临时数组的内容复制到arr中
	        for (var _j4 = 0; _j4 < n; ++_j4) {
	            arr[_j4] = temp[_j4];
	        }radix *= 10;
	    }
	}
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	radixSort(arr, 100);
	console.log(arr + '');
	
	/*
	 桶排序
	
	 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。
	
	 基本思想
	
	 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
	 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。
	
	 分析
	
	 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
	 对N个关键字进行桶排序的时间复杂度分为两个部分：
	     (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
	     (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。
	 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
	     (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
	     (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。
	
	 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
	 O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
	 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。
	
	 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
	 */
	
	var BUCKETSNUM = 10;
	
	function bucketSort(sqList) {
	    var n = sqList.length;
	    var bucketA = [];
	    var b = [];
	
	    // 初始化桶
	    for (var i = 0; i < BUCKETSNUM; ++i) {
	        b[i] = [];
	        bucketA[i] = 0;
	
	        for (var j = 0; j < n; ++j) {
	            b[i][j] = Infinity;
	        }
	    }
	
	    // 给桶填装数据
	    for (var _i5 = 0; _i5 < n; ++_i5) {
	        var data = sqList[_i5];
	        // noto: 这里的映射函数是针对1-100之间的实数
	        var bucket = Math.floor(data / BUCKETSNUM);
	        b[bucket][bucketA[bucket]] = data;
	        ++bucketA[bucket];
	    }
	
	    // 针对每个桶进行快速排序
	    for (var _i6 = 0; _i6 < BUCKETSNUM; ++_i6) {
	        if (bucketA[_i6] !== 0) {
	            (0, _index.quickSort)(b[_i6], 0, bucketA[_i6] - 1);
	            //for(let j = 1; j < bucketA[i]; ++j){
	            //    let p = b[i][j];
	            //    let k;
	            //    for(k = j - 1; k >= 0 && p < b[i][k]; --k){
	            //        b[i][k + 1] = b[i][k];
	            //    }
	            //    b[i][k + 1] = p;
	            //}
	        }
	    }
	
	    //console.log(b);
	    //console.log(bucketA);
	
	    // 复制回去
	    var num = 0;
	    for (var _i7 = 0; _i7 < BUCKETSNUM; ++_i7) {
	        if (bucketA[_i7] !== 0) {
	            for (var _j5 = 0; _j5 < bucketA[_i7]; ++_j5) {
	                sqList[num++] = b[_i7][_j5];
	            }
	        }
	    }
	}
	exports.bucketSort = bucketSort;
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95];
	bucketSort(arr);
	console.log(arr + '');
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95, Infinity, Infinity, Infinity];
	(0, _index.quickSort)(arr);
	console.log(arr + '');
	
	/*
	 性能分析
	 很明显，基数排序的性能比桶排序要略差。每一次关键字的桶分配都需要O(N)的时间复杂度，而且分配之后得到新的关键字序列又需要O(N)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2N) ，当然d要远远小于N，因此基本上还是线性级别的。基数排序的空间复杂度为O(N+M)，其中M为桶的数量。一般来说N>>M，因此额外空间需要大概N个左右。
	 但是，对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，基数排序的应用范围更加广泛。
	 */

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.straightInsertSort = straightInsertSort;
	exports.binaryInsertSort = binaryInsertSort;
	exports.path2InsertSort = path2InsertSort;
	exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
	exports.shellSort = shellSort;
	
	var _StaticLinkedList = __webpack_require__(55);
	
	var _StaticLinkedList2 = _interopRequireDefault(_StaticLinkedList);
	
	var _defaultComparision = __webpack_require__(24);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 插入排序
	
	 采用的是以 “玩桥牌者”的方法为基础的。即在考察记录Ri之前，设以前的所有记录R1, R2 ,…., Ri-1已排好序，然后将Ri插入到已排好序的诸记录的适当位置
	
	 最基本的插入排序是直接插入排序(Straight Insertion Sort) 。
	
	
	 直接插入排序
	
	 1  排序思想
	 将待排序的记录Ri，插入到已排好序的记录表R1, R2 ,…., Ri-1中，得到一个新的、记录数增加1的有序表。 直到所有的记录都插入完为止。
	 设待排序的记录顺序存放在数组R[1…n]中，在排序的某一时刻，将记录序列分成两部分：
	 ◆ R[1…i-1]：已排好序的有序部分；
	 ◆ R[i…n]：未排好序的无序部分。
	 显然，在刚开始排序时，R[1]是已经排好序的。
	
	 2.算法实现
	
	 3.算法分析
	 ⑴ 最好情况：若待排序记录按关键字从小到大排列(正序)，算法中的内循环无须执行，则一趟排序时：关键字比较次数1次，记录移动次数2次(R[i]→R[0], R[0]→R[j+1])。
	 则整个排序的关键字比较次数和记录移动次数分别是：
	 比较次数：n - 1          移动次数： 2 * (n - 1)
	
	 ⑵ 最坏情况：若待排序记录按关键字从大到小排列(逆序)，则一趟排序时：算法中的内循环体执行i-1，关键字比较次数i次，记录移动次数i+1。
	 则就整个排序而言：
	 比较次数： (n - 1) * (n + 1) / 2     移动次数: (n - 1) * (n + 4) / 2
	
	 一般地，认为待排序的记录可能出现的各种排列的概率相同，则取以上两种情况的平均值，作为排序的关键字比较次数和记录移动次数，约为n2/4，则复杂度为O(n2) 。
	
	
	 */
	
	/**
	 * Created by Luke on 2015/2/2.
	 */
	
	function straightInsertSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        // 设置哨兵, 当设置sqList[-1] = sqList[i]时，经测试效率更慢
	        // 因为js里面的变量作用域在函数内的
	        var temp = sqList[i];
	        // 查找插入位置，并将记录后移
	        var j = i - 1;
	        for (; j >= 0 && comp(temp, sqList[j]) < 0; --j) {
	            sqList[j + 1] = sqList[j];
	        } // 插入到正确位置
	        sqList[j + 1] = temp;
	    }
	}
	
	var a = [7, 4, -2, 19, 13, 6];
	straightInsertSort(a);
	console.log(a + '');
	
	/*
	 其它插入排序
	
	 1  折半插入排序
	 当将待排序的记录R[i] 插入到已排好序的记录子表R[1…i-1]中时，由于R1, R2 ,…, Ri-1已排好序，则查找插入位置可以用“折半查找”实现，则直接插入排序就变成为折半插入排序。
	
	 从时间上比较，折半插入排序仅仅减少了关键字的比较次数，却没有减少记录的移动次数，故时间复杂度仍然为O(n2) 。
	
	
	 */
	
	function binaryInsertSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        var low = 0;
	        var high = i - 1;
	
	        while (low <= high) {
	            var mid = low + high >> 1;
	
	            if (comp(temp, sqList[mid]) < 0) high = mid - 1;else low = mid + 1;
	        }
	
	        for (var j = i - 1; j >= high + 1; --j) {
	            sqList[j + 1] = sqList[j];
	        }
	
	        sqList[high + 1] = temp;
	    }
	}
	
	var b = [30, 13, 70, 85, 39, 42, 6, 20];
	binaryInsertSort(b);
	console.log(b + '');
	
	/*
	 2-路插入排序
	
	 是对折半插入排序的改进，以减少排序过程中移动记录的次数。附加n个记录的辅助空间，方法是：
	 ①  另设一个数组d，L[1]赋给d[1]，将d[1]看成是排好序的序列中中间位置的记录；
	 ②  分别将L[ ]中的第i个记录依次插入到d[1]之前或之后的有序序列中，具体方法：
	 ◆  L[i].key<d[1].key： L[i]插入到d[1]之前的有序表中；
	 ◆ L[i].key≥d[1].key： L[i]插入到d[1]之后的有序表中；
	 关键点：实现时将向量d看成是循环向量，并设两个指针first和final分别指示排序过程中得到的有序序列中的第一个和最后一个记录。
	
	 在2-路插入排序中，移动记录的次数约为n2/8 。但当L[1]是待排序记录中关键字最大或最小的记录时，2-路插入排序就完全失去了优越性。
	 */
	
	function path2InsertSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var d = [sqList[0]];
	    // first、final分别指示d中排好序的记录的第1个和最后1个记录的位置。
	    var first = 0;
	    var final = 0;
	    var len = sqList.length;
	
	    for (var i = 1; i < len; ++i) {
	        var item = sqList[i];
	
	        // 待插入记录小于d中最小值，插入到d[first]之前（不需移动d数组的元素）。
	        if (comp(item, d[first]) < 0) {
	            first = (first - 1) % len;
	            d[first] = item;
	        }
	        // 待插入记录大于d中最小值，插入到d[final]之后（不需移动d数组的元素）。
	        else if (comp(item, d[final]) > 0) {
	                d[++final] = item;
	            }
	            // 待插入记录大于d中最小值，小于d中最大值，插入到d的中间（需要移动d数组的元素）。
	            else {
	                    // 移动d尾部元素以便按序插入记录。
	                    var j = final++;
	                    while (comp(item, d[j]) < 0) {
	                        d[(j + 1) % len] = d[j];
	                        j = (j - 1) % len;
	                    }
	                    d[(j + 1) % len] = item;
	                }
	    }
	
	    // 循环把d赋给sqList
	    for (var _i = 0; _i < len; ++_i) {
	        sqList[_i] = d[(_i + first) % len];
	    }
	}
	
	var c = [49, 38, 65, 13, 97, 27, 76, 5, 100, 78, 15, 15, 20];
	path2InsertSort(c);
	console.log(c + '');
	
	/*
	表插入排序
	
	前面的插入排序不可避免地要移动记录，若不移动记录就需要改变数据结构。
	初始化：下标值为0的分量作为表头结点，关键字取为最大值，各分量的指针值为空；
	①  将静态链表中数组下标值为1的分量(结点)与表头结点构成一个循环链表；
	② i=2 ，将分量R[i]按关键字递减插入到循环链表；
	③  增加i ，重复②，直到全部分量插入到循环链表。
	
	和直接插入排序相比，不同的是修改2n次指针值以代替移动记录，而关键字的比较次数相同，故时间复杂度为O(n2)。
	
	表插入排序得到一个有序链表，对其可以方便地进行顺序查找，但不能实现随机查找。为了能实现有序表的折半查找根据需要，可以对记录进行重排.
	
	重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。
	
	例子中，链表中第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记录应移至数组的第一个分量，则将list[1]和list[6]互换，并为了不中断静态链表中的链，即在继续顺链表扫描时仍能找到互换之前在list[1]中的结点，令互换之后的list[1]中的游标改为6
	
	推广至一般情况，若第i个最小关键字的结点是数组中下标为p且p > i的分量，则互换list[i]和list[p]，且令list[i]中的游标改为p；
	由于此时数组中所有小于i的分量中已是到位记录，则当p<i时，应顺链继续查找直到p>=i为止。
	 */
	
	// 表插入排序
	function staticLinkedListInsertSort(sllist) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    // 构成循环链表
	    sllist[0].cur = 1;
	    sllist[1].cur = 0;
	
	    var p = void 0,
	        q = void 0;
	    for (var i = 2, len = sllist.length; i <= len; ++i) {
	        p = 0;
	        var x = sllist[i].data;
	
	        while (sllist[p].cur && comp(sllist[sllist[p].cur].data, x) < 0) {
	            p = sllist[p].cur;
	        } // 当遇到大于当前关键字的下标时，插入到其前驱和后继的中间
	        q = sllist[p].cur;
	        sllist[p].cur = i;
	        sllist[i].cur = q;
	    }
	}
	exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
	
	// 重排静态链表，静态链表下标已排好序
	function arrange(sllist) {
	    var p = sllist[0].cur;
	
	    for (var i = 1, len = sllist.length; i < len; ++i) {
	        // 第i个记录在list中的当前位置应不小于i
	        // 找到第i个记录，并用p指示其在list中当前位置
	        while (p < i) {
	            p = sllist[p].cur;
	        } // q指向尚未调整的表尾
	        var q = sllist[p].cur;
	
	        if (p !== i) {
	            // 交换记录，使第i个记录到位
	            var temp = sllist[p];
	            sllist[p] = sllist[i];
	            sllist[i] = temp;
	            // 指向被移走的记录，使得以后可有while循环找到
	            sllist[i].cur = p;
	        }
	
	        // p指向尚未调整的表尾
	        p = q;
	    }
	}
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 52];
	var d = new _StaticLinkedList2.default();
	d.create(arr);
	staticLinkedListInsertSort(d);
	console.log(d);
	arrange(d);
	console.log(d);
	
	/*
	希尔排序
	
	希尔排序(Shell Sort，又称缩小增量法)是一种分组插入排序方法。
	
	1  排序思想
	①   先取一个正整数d1(d1<n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；
	②   取新的增量d2<d1，重复①的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。
	
	2  排序示例
	设有10个待排序的记录，关键字分别为9, 13, 8, 2, 5, 13, 7, 1, 15, 11，增量序列是5, 3, 1，希尔排序的过程:
	初始关键字序列:    9     13     8      2      5      13      7      1      15      11
	第一趟排序后:      9     7      1      2      5      13      13     8      15      11
	第二趟排序后:      2     5      1      9      7      13      11     8      15      13
	第三趟排序后:      1     2      5      7      8      9      11     13      13      15
	
	
	希尔排序的分析比较复杂，涉及一些数学上的问题，其时间是所取的“增量”序列的函数。
	
	希尔排序特点
	子序列的构成不是简单的“逐段分割”，而是将相隔某个增量的记录组成一个子序列。
	希尔排序可提高排序速度，原因是：
	◆ 分组后n值减小，n²更小，而T(n)=O(n²),所以T(n)从总体上看是减小了；
	◆ 关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序。
	
	增量序列取法
	◆ 无除1以外的公因子；
	◆ 最后一个增量值必须为1。
	
	相关资料： http://wenku.baidu.com/link?url=q7kzOxXqc0BLaGUVDY43FQOh2aX1UqBHkkYd3VMwJhJo6rv4SiU686RW3kQCSqGEKytl12S8fBOpwhq-runhX_pbZcg6BeD-miYMPgDhXxK
	 */
	
	function shellInsert(sqList, dk, comp) {
	    for (var i = dk, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        if (comp(temp, sqList[i - dk]) < 0) {
	            var j = i - dk;
	            for (; j >= 0 && comp(temp, sqList[j]) < 0; j -= dk) {
	                sqList[j + dk] = sqList[j];
	            }sqList[j + dk] = temp;
	        }
	    }
	}
	
	function shellSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var delta = createDelta(sqList.length);
	    //console.log(delta);
	    for (var k = 0, t = delta.length; k < t; ++k) {
	        shellInsert(sqList, delta[k], comp);
	    }
	}
	
	function createDelta(n) {
	    var arr = [];
	    var t = Math.log(n - 1) / Math.log(2) | 0; // Math.log(n - 1) / Math.log(2), Math.log(n + 1) / Math.log(2)
	    for (var k = 0; k <= t; ++k) {
	        arr[k] = Math.pow(2, t - k) + 1;
	    } // Math.pow(2, t - i + 1) - 1, Math.pow(2, t - i) + 1
	
	    arr[arr.length] = 1;
	
	    return arr;
	}
	
	console.log('\n\nShell Sort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	shellSort(arr);
	console.log(arr + '');

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.linkedListNaturalMergeSort = exports.naturalMergeSort = undefined;
	exports.mergeSortRecursive = mergeSortRecursive;
	exports.mergeSortNonRecursive = mergeSortNonRecursive;
	exports.natureMergeSort = natureMergeSort;
	
	var _LinkedList = __webpack_require__(54);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _defaultComparision = __webpack_require__(24);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 归并排序
	
	 归并(Merging) ：是指将两个或两个以上的有序序列合并成一个有序序列。若采用线性表(无论是那种存储结构)易于实现，其时间复杂度为O(m+n) 。
	 归并思想实例：两堆扑克牌，都已从小到大排好序，要将两堆合并为一堆且要求从小到大排序。
	 ◆  将两堆最上面的抽出(设为C1，C2)比较大小，将小者置于一边作为新的一堆(不妨设C1<C2)；再从第一堆中抽出一张继续与C2进行比较，将较小的放置在新堆的最下面；
	 ◆ 重复上述过程，直到某一堆已抽完，然后将剩下一堆中的所有牌转移到新堆中。
	
	 1   排序思想
	 ①  初始时，将每个记录看成一个单独的有序序列，则n个待排序记录就是n个长度为1的有序子序列；
	 ②  对所有有序子序列进行两两归并，得到n/2个长度为2或1的有序子序列——一趟归并；
	 ③  重复② ，直到得到长度为n的有序序列为止。
	
	 上述排序过程中，子序列总是两两归并，称为2-路归并排序。其核心是如何将相邻的两个子序列归并成一个子序列。设相邻的两个子序列分别为：
	 {R[k], R[k+1], …, R[m]}和{R[m+1], R[m+2],…, R[h]}，将它们归并为一个有序的子序列：
	 {DR[l], DR[l+1], …, DR[m], DR[m+1], …, DR[h] }
	
	 例：设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41，归并排序的过程。
	 初始关键字: [23]   [38]   [22]   [45]   [23]   [67]   [31]   [15]   [41]
	              |      |      |      |      |      |      |      |
	              --------      --------      --------      --------
	 一趟归并后: [23    38]    [22     45]    [23     67]    [15     31]   [41]
	                 |              |             |              |
	                 ---------------               ---------------
	 二趟归并后: [22     23      38     45]    [15     23     31     67]    [41]
	                        |                              |
	                        --------------------------------
	 三趟归并后: [15     22      23     23     31     38     45     67]    [41]
	                                       |                                |
	                                       ----------------------------------
	 四趟归并后: [15     22      23     23     31     38     41     45     67
	
	
	 2  一趟归并排序
	 一趟归并排序都是从前到后，依次将相邻的两个有序子序列归并为一个，且除最后一个子序列外，其余每个子序列的长度都相同。设这些子序列的长度为d，则一趟归并排序的过程是：
	 从j=0开始，依次将相邻的两个有序子序列
	 R[j…j+d-1]和R[j+d…j+2d-1]进行归并；每次归并两个子序列后，j后移动2d个位置，即
	 j=j+2d；若剩下的元素不足两个子序列时，分以下两种情况处理：
	 ①  剩下的元素个数>d：再调用一次上述过程，将一个长度为d的子序列和不足d的子序列进行归并；
	 ②  剩下的元素个数≤d：将剩下的元素依次复制到归并后的序列中。
	
	
	 3.算法分析
	具有n个待排序记录的归并次数是㏒2n，而一趟归并的时间复杂度为O(n)，则整个归并排序的时间复杂度无论是最好还是最坏情况均为O(n㏒2n)。在排序过程中，使用了辅助向量DR，大小与待排序记录空间相同，则空间复杂度为O(n)。归并排序是稳定的。
	
	 */
	
	var nCount = 0; /**
	                 * Created by ldp on 2015/2/7.
	                 */
	
	var nonRecursiveCount = 0;
	var recursiveCount = 0;
	
	/**
	 * 将有序的sr[s1..e1]和sr[s2..e2]归并为有序的tr[s1..e2]
	 * @param sr
	 * @param s1
	 * @param e1
	 * @param e2
	 */
	function merge(sr, s1, e1, e2) {
	    var comp = arguments.length <= 4 || arguments[4] === undefined ? _defaultComparision2.default : arguments[4];
	
	    var temp = [];
	    var i = s1;
	    var j = e1 + 1;
	    var k = 0;
	
	    while (i <= e1 && j <= e2) {
	        if (comp(sr[i], sr[j]) < 0) temp[k++] = sr[i++];else temp[k++] = sr[j++];
	    }
	    while (i <= e1) {
	        temp[k++] = sr[i++];
	    }while (j <= e2) {
	        temp[k++] = sr[j++];
	    } // 复制回去
	    for (i = s1, k = 0; i <= e2; ++i, ++k) {
	        sr[i] = temp[k];
	    }
	}
	
	/**
	 * 2-路归并排序递归算法
	 * @param {Array} sr
	 * @param {Number} s
	 * @param {Number} t
	 */
	function mergeSortRecursive(sr) {
	    var s = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var t = arguments.length <= 2 || arguments[2] === undefined ? sr.length - 1 : arguments[2];
	    var comp = arguments.length <= 3 || arguments[3] === undefined ? _defaultComparision2.default : arguments[3];
	
	    if (s >= t) return;
	
	    // 将sr[s..t]平分为sr[s..m]和sr[m+1..t]
	    var m = s + t >> 1;
	    // 递归地将sr[s..m]归并为有序的sr[s..m]
	    mergeSortRecursive(sr, s, m, comp);
	    // 递归地将sr[m+1..t]归并为有序的sr[m+1..t]
	    mergeSortRecursive(sr, m + 1, t, comp);
	    // 将sr[s..m]和sr[m+1..t]归并到sr[s..t];
	    merge(sr, s, m, t, comp);
	}
	
	console.log('\n\nmergeSortRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortRecursive(arr);
	console.log(arr + '');
	
	function mergeSortNonRecursive(sr) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var j = void 0,
	        k = void 0;
	    for (var d = 1, n = sr.length - 1; d < n; d *= 2) {
	        // 一趟归并排序算法
	        j = 0;
	
	        // 子序列两两归并
	        while ((k = j + 2 * d - 1) < n) {
	            merge(sr, j, j + d - 1, k, comp);
	            j = k + 1;
	        }
	
	        // 剩余元素个数超过一个子序列长度
	        if (j + d - 1 < n) merge(sr, j, j + d - 1, n, comp);
	        // 剩余子序列复制
	        else merge(sr, j, n, n, comp);
	    }
	}
	
	console.log('\nmergeSortNonRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortNonRecursive(arr);
	console.log(arr + '');
	
	// 自然合并排序
	// http://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html
	// http://www.cnblogs.com/lanke/archive/2013/01/15/2860487.html
	/*
	自然归并是归并排序的一个变形，效率更高一些，可以在归并排序非递归实现的基础上进行修改.对于已经一个已经给定数组a,通常存在多个长度大于1的已经自然排好的子数组段,因此用一次对数组a的线性扫描就可以找出所有这些排好序的子数组段,然后再对这些子数组段俩俩合并.
	 */
	
	// 扫描得到子串的函数
	function pass(sqList, rec, comp) {
	    var num = 0;
	    rec[num++] = 0;
	    var len = sqList.length;
	
	    for (var i = 1; i < len; ++i) {
	        if (comp(sqList[i], sqList[i + 1]) > 0) rec[num++] = i + 1;
	    }
	    rec[num++] = len;
	
	    return num;
	}
	
	function natureMergeSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var rec = [];
	
	    //num=2说明已经排好序了
	    //每循环一次，进行一次pass()操作
	    for (var num = pass(sqList, rec, comp); num !== 2; num = pass(sqList, rec, comp)) {
	        for (var i = 0; i + 2 < num; i += 2) {
	            merge(sqList, rec[i], rec[i + 1] - 1, rec[i + 2] - 1, comp);
	        }
	    }
	}
	
	console.log('\nnatureMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	natureMergeSort(arr);
	console.log(arr + '');
	
	console.log(recursiveCount);
	console.log(nonRecursiveCount);
	console.log(nCount);
	
	// 双向自然合并排序算法
	/*
	双向自然合并排序是根据欲排序数据局部不是升序就是降序的自然有序特点,先线性扫描出自然有序的子数组段,再进行合并排序.扫描时的有序数段长度越长,段数越少,对应合并树的层数就会越少,算法的效率越高.
	 */
	var naturalMergeSort = exports.naturalMergeSort = function () {
	    return naturalMergeSort;
	
	    function naturalMergeSort(a) {
	        var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	        var b = [];
	        var n = a.length;
	        while (!mergeRuns(a, b, n, comp)) {}
	    }
	
	    function mergeRuns(a, b, n, comp) {
	        var i = 0;
	        var k = 0;
	        var asc = true;
	        var x = void 0;
	
	        while (i < n) {
	            k = i;
	            // 找到最后一个递增序列元素
	            do {
	                x = a[i++];
	            } while (i < n && comp(x, a[i]) <= 0);
	            // 找到最后一个递减序列元素
	            while (i < n && comp(x, a[i]) >= 0) {
	                x = a[i++];
	            } // 归并递增序列和递减序列，结果可能递增或递减
	            merge(a, b, k, i - 1, asc, comp);
	            asc = !asc;
	        }
	
	        // 当k等于0时代表a已经排好序了
	        return k === 0;
	    }
	
	    function merge(a, b, low, high, asc, comp) {
	        var k = asc ? low : high;
	        var c = asc ? 1 : -1;
	        var i = low;
	        var j = high;
	
	        while (i <= j) {
	            if (comp(a[i], a[j]) <= 0) b[k] = a[i++];else b[k] = a[j--];
	            k += c;
	        }
	        for (i = k = low, j = high; i <= j; ++i, ++k) {
	            a[i] = b[k];
	        }
	    }
	}();
	
	console.log('\nnaturalMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	naturalMergeSort(arr);
	console.log(arr + '');
	
	// 链表存储结构的自然合并排序
	var linkedListNaturalMergeSort = exports.linkedListNaturalMergeSort = function () {
	    return mergeSort;
	
	    function mergeSort(linkedlist) {
	        var needReplace = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	        var comp = arguments.length <= 2 || arguments[2] === undefined ? _defaultComparision2.default : arguments[2];
	
	        if (!linkedlist) return linkedlist;
	
	        var queue = new _Queue2.default();
	        var list = linkedlist.head;
	
	        if (!list || !list.next) return linkedlist;
	
	        var u = list;
	        var t = list;
	        var v = void 0;
	        // 将递增的结点放入到队列中（会被切断）
	        for (; t; t = u) {
	            while (u && u.next && comp(u.data, u.next.data) <= 0) {
	                u = u.next;
	            }v = u;
	            u = u.next;
	            v.next = null;
	            queue.enQueue(t);
	        }
	
	        t = queue.deQueue();
	        // 合并结点
	        while (queue.size) {
	            queue.enQueue(t);
	            var a = queue.deQueue();
	            var b = queue.deQueue();
	            t = merge(a, b, comp);
	        }
	
	        if (needReplace) linkedlist.head = t;
	
	        return t;
	    }
	
	    function merge(a, b, comp) {
	        var c = new _LinkedList2.default();
	        var head = { data: null, next: null };
	        c.head = head;
	        c = c.head;
	
	        while (a && b) {
	            if (comp(a.data, b.data) < 0) {
	                c.next = a;
	                c = a;
	                a = a.next;
	            } else {
	                c.next = b;
	                c = b;
	                b = b.next;
	            }
	        }
	
	        c.next = a ? a : b;
	
	        return head.next;
	    }
	}();
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	var linkedList = new _LinkedList2.default(arr);
	linkedListNaturalMergeSort(linkedList);
	console.log(linkedList + '');

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.simpleSelectionSort = simpleSelectionSort;
	exports.heapSort = heapSort;
	
	var _defaultComparision = __webpack_require__(24);
	
	var _defaultComparision2 = _interopRequireDefault(_defaultComparision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	选择排序
	
	选择排序(Selection Sort)的基本思想是：每次从当前待排序的记录中选取关键字最小的记录表，然后与待排序的记录序列中的第一个记录进行交换，直到整个记录序列有序为止。
	
	
	简单选择排序
	
	简单选择排序(Simple Selection Sort ，又称为直接选择排序)的基本操作是：通过n-i次关键字间的比较，从n-i+1个记录中选取关键字最小的记录，然后和第i个记录进行交换，i=1, 2, … n-1 。
	1  排序示例
	例：设有关键字序列为：7, 4, -2, 19, 13, 6，直接选择排序的过程：
	初始记录的关键字：  7     4    -2     19    13    6
	    第一趟排序：  -2     4     7     19    13    6
	    第二趟排序：  -2     4     7     19    13    6
	    第三趟排序：  -2     4     6     19    13    7
	    第四趟排序：  -2     4     6     7     13    19
	    第五趟排序：  -2     4     6     7     13    19
	    第六趟排序：  -2     4     6     7     13    19
	
	2.算法分析
	整个算法是二重循环：外循环控制排序的趟数，对n个记录进行排序的趟数为n-1趟；内循环控制每一趟的排序。
	进行第i趟排序时，关键字的比较次数为n-i，则：
	比较次数： n*(n - 1) / 2
	时间复杂度是：T(n)=O(n2)
	空间复杂度是：S(n)=O(1)
	从排序的稳定性来看，直接选择排序是不稳定的。
	
	 */
	
	function simpleSelectionSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    for (var i = 0, len = sqList.length; i < len; ++i) {
	        var k = i;
	        for (var j = k + 1; j < len; ++j) {
	            if (comp(sqList[j], sqList[k]) < 0) k = j;
	        }if (k !== i) {
	            var temp = sqList[k];
	            sqList[k] = sqList[i];
	            sqList[i] = temp;
	        }
	    }
	} /**
	   * Created by luke on 2015/2/2.
	   */
	
	var arr = [7, 4, -2, 19, 13, 6];
	simpleSelectionSort(arr);
	console.log(arr + '');
	
	/*
	树形选择排序
	
	首先对n个记录的关键字两两进行比较，选取n/2个较小者；然后这n/2个较小者两两进行比较，选取n/4个较小者… 如此重复，直到只剩1个关键字为止。
	该过程可用一棵有n个叶子结点的完全二叉树表示，每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点的关键字就是最小的关键字。
	输出最小关键字后，根据关系的可传递性，欲选取次小关键字，只需将叶子结点中的最小关键字改为“最大值” ，然后重复上述步骤即可。
	含有n个叶子结点的完全二叉树的深度为㏒2n+1，则总的时间复杂度为O(n㏒2n) 。
	
	但这种排序方法尚有辅助存储空间较多,和最大值进行多余比较等缺点。为了弥补这些缺陷，出现了另一种选择排序---堆排序
	 */
	
	/*
	堆排序
	
	1  堆的定义
	是n个元素的序列H={k1, k2 , … kn} ，满足：
	    ki≤k2i       当2i≤n时
	    ki≤k2i+1   当2i+1≤n时
	
	由堆的定义知，堆是一棵以k1为根的完全二叉树。若对该二叉树的结点进行编号(从上到下，从左到右)，得到的序列就是将二叉树的结点以顺序结构存放，堆的结构正好和该序列结构完全一致。
	
	2  堆的性质
	    1)  堆是一棵采用顺序存储结构的完全二叉树， k1是根结点；
	    2)  堆的根结点是关键字序列中的最小(或最大)值，分别称为小(或大)根堆；
	    3)  从根结点到每一叶子结点路径上的元素组成的序列都是按元素值(或关键字值)非递减(或非递增)的；
	    4)  堆中的任一子树也是堆。
	
	利用堆顶记录的关键字值最小(或最大)的性质，从当前待排序的记录中依次选取关键字最小(或最大)的记录，就可以实现对数据记录的排序，这种排序方法称为堆排序。
	
	3  堆排序思想
	
	①  对一组待排序的记录，按堆的定义建立堆；
	②  将堆顶记录和最后一个记录交换位置，则前n-1个记录是无序的，而最后一个记录是有序的；
	③  堆顶记录被交换后，前n-1个记录不再是堆，需将前n-1个待排序记录重新组织成为一个堆，然后将堆顶记录和倒数第二个记录交换位置，即将整个序列中次小关键字值的记录调整(排除)出无序区；
	④  重复上述步骤，直到全部记录排好序为止。
	
	结论：排序过程中，若采用小根堆，排序后得到的是非递减序列；若采用大根堆，排序后得到的是非递增序列。
	
	堆排序的关键
	①  如何由一个无序序列建成一个堆？
	②  如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？
	
	4  堆的调整——筛选
	⑴ 堆的调整思想
	输出堆顶元素之后，以堆中最后一个元素替代之；然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；重复上述操作，直到是叶子结点或其关键字值小于等于左、右子树的关键字的值，将得到新的堆。称这个从堆顶至叶子的调整过程为“筛选”。
	
	注意：筛选过程中，根结点的左、右子树都是堆，因此，筛选是从根结点到某个叶子结点的一次调整过程。
	
	5  堆的建立
	利用筛选算法，可以将任意无序的记录序列建成一个堆，设R[1],R[2], …,R[n]是待排序的记录序列。
	将二叉树的每棵子树都筛选成为堆。只有根结点的树是堆。第⌊n/2⌋个结点之后的所有结点都没有子树，即以第⌊n/2⌋个结点之后的结点为根的子树都是堆。因此，以这些结点为左、右孩子的结点，其左、右子树都是堆，则进行一次筛选就可以成为堆。同理，只要将这些结点的直接父结点进行一次筛选就可以成为堆…。
	只需从第⌊n/2⌋个记录到第1个记录依次进行筛选就可以建立堆。
	
	6   堆排序算法实现
	堆的根结点是关键字最小的记录，输出根结点后，是以序列的最后一个记录作为根结点，而原来堆的左、右子树都是堆，则进行一次筛选就可以成为堆。
	
	7  算法分析
	主要过程：初始建堆和重新调整成堆。设记录数为n，所对应的完全二叉树深度为h 。
	◆  初始建堆：每个非叶子结点都要从上到下做“筛选” 。第i层结点数≤2i-1，结点下移的最大深度是h-i，而每下移一层要比较2次，则比较次数C1(n)为：
	C1(n)≤4(n-㏒2n-1)
	◆  筛选调整：每次筛选要将根结点“下沉”到一个合适位置。第i次筛选时：堆中元素个数为n-i+1；堆的深度是㏒2(n-i+1)+1，则进行n-1次“筛选”的比较次数C2(n)为：
	C2(n)<2n㏒2n
	堆排序的比较次数的数量级为： T(n)=O(n㏒2n)；而附加空间就是交换时所用的临时空间，故空间复杂度为： S(n)=O(1) 。
	
	堆排序适合记录数较大的情况
	
	
	http://blog.csdn.net/zz198808/article/details/7678055
	 */
	
	/**
	 * 已知sqList[s..m]中记录的关键字除sqList[s]之外均满足堆的定义，
	 * 本函数调整sqList[s]的关键字，使sqList[s..m]成为一个大堆顶（对其中关键字而言）
	 * @param {Array} sqList
	 * @param {Number} s
	 * @param {Number} m
	 */
	function heapAdjust(sqList, s, m, comp) {
	    var rc = sqList[s];
	
	    // 沿关键字较大的孩子结点向下筛选
	    for (var j = 2 * s + 1; j <= m; j = j * 2 + 1) {
	        // j为关键字较大的记录下标
	        if (j < m && comp(sqList[j], sqList[j + 1]) < 0) ++j;
	        // rc应插入在位置s上
	        if (comp(rc, sqList[j]) >= 0) break;
	        sqList[s] = sqList[j];
	        s = j;
	    }
	
	    sqList[s] = rc;
	}
	
	function heapSort(sqList) {
	    var comp = arguments.length <= 1 || arguments[1] === undefined ? _defaultComparision2.default : arguments[1];
	
	    var len = sqList.length;
	    // 建立大堆顶
	    for (var i = (len >> 1) - 1; i >= 0; --i) {
	        heapAdjust(sqList, i, len - 1, comp);
	    }for (var _i = len - 1; _i > 0; --_i) {
	        // 将堆顶记录和当前未经排序子序列sqList[0..i]中
	        // 最后一个记录相互交换
	        var temp = sqList[_i];
	        sqList[_i] = sqList[0];
	        sqList[0] = temp;
	
	        // 将sqList[0..i - 1]重新调整为大堆顶
	        heapAdjust(sqList, 0, _i - 1, comp);
	    }
	}
	
	var arr = [1, 3, 4, 5, 7, 2, 6, 8, 0];
	heapSort(arr);
	console.log(arr + '');

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 堆分配存储表示
	 *
	 * 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在c语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间。
	 */
	
	var HString = function () {
	    function HString() {
	        (0, _classCallCheck3.default)(this, HString);
	
	        this.ch = {};
	        this.length = 0;
	    }
	
	    // 1 <= position <= this.length.在串的第position个字符之前插入串tHString
	
	
	    HString.prototype.strInsert = function strInsert(position, tHString) {
	        if (position < 1 || position > this.length + 1) throw new Error('unexpected position');
	
	        if (tHString.length) {
	            // 为插入t而腾出位置
	            var i = this.length - 1;
	            for (var len = position - 1; i >= len; --i) {
	                this.ch[i + tHString.length] = this.ch[i];
	            }stringCopy(this.ch, tHString.ch, position - 1, tHString.length - 1, 0);
	
	            this.length += tHString.length;
	        }
	    };
	
	    HString.prototype.strAssign = function strAssign(chars) {
	        stringCopy(this.ch, chars, 0, chars.length - 1, 0);
	        this.length = chars.length;
	    };
	
	    HString.prototype.strLength = function strLength() {
	        return this.length;
	    };
	
	    HString.prototype.strCompare = function strCompare(tHString) {
	        for (var i = 0, len = this.length; i < len && i < tHString.length; i++) {
	            if (this.ch[i] !== tHString.ch[i]) return this.ch[i] - tHString.ch[i];
	        }return this.length - tHString.length;
	    };
	
	    HString.prototype.clearString = function clearString() {
	        this.ch = {};
	        this.length = 0;
	    };
	
	    HString.prototype.concat = function concat(s) {
	        var t = new HString();
	
	        // t.ch[0..this.length - 1] = this.ch[0..this.length - 1]
	        stringCopy(t.ch, this.ch, 0, this.length - 1, 0);
	        t.length = this.length + s.length;
	        // t.ch[this.length..t.length - 1] = s.ch[0..s.length - 1]
	        stringCopy(t.ch, s.ch, this.length, s.length - 1, 0);
	
	        return t;
	    };
	
	    HString.prototype.substring = function substring(position, len) {
	        position = ~~position || 0;
	        len = ~~len || this.length;
	        if (position < 0 || position > this.length - 1 || len < 0 || len > this.length - position) throw new Error('unexpected parameter');
	
	        var sub = new HString();
	        stringCopy(sub.ch, this.ch, 0, len - 1, position);
	        sub.length = len;
	
	        return sub;
	    };
	
	    HString.prototype.toString = function toString() {
	        var s = '';
	        for (var i = 0, len = this.length; i < len; i++) {
	            s += this.ch[i];
	        }
	        return s;
	    };
	
	    return HString;
	}();
	
	exports.default = HString;
	
	
	function stringCopy(destination, target, destStart, length, targetStart) {
	    destStart = destStart || 0;
	    length = length || target.length;
	    targetStart = targetStart || 0;
	
	    for (var i = 0; i <= length; i++) {
	        destination[destStart + i] = target[targetStart + i];
	    }
	}

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(17);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Chunk = function Chunk() {
	    var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	    (0, _classCallCheck3.default)(this, Chunk);
	
	    this.chunkSize = chunkSize;
	    this.ch = [];
	    for (var i = 0; i < this.chunkSize; i++) {
	        this.ch[i] = '#';
	    }
	    // type: Chunk
	    this.next = null;
	}; /**
	    * 串的块链存储表示
	    *
	    * 和线性表的链式存储结构相类似，也可采用链式方式存储串值。由于串结构的特殊性--结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。
	    * 下面是结点大小为4（即每个结点存放4个字符）的链表
	    * head --> (a,b,c,d) --> (e,f,g,h) --> (i###)
	    * 下面是结点大小为1的链表
	    * head --> (a) --> (b) --> (c) --> ... --> (i)
	    *
	    * 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其它非串值字符。
	    * 为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度，称如此定义的串存储结构为块链结构。
	    *
	    * 由于一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行连接操作，但应注意连接时需处理第一个串尾的无效字符。
	    * 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响到串处理的效率。如果串很长，这要求我们考虑串值的存储密度：
	    * 存储密度 = 串值所占的存储位 / 实际分配的存储位
	    *
	    * 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。
	    */
	
	
	var LString = function () {
	    function LString() {
	        var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	        (0, _classCallCheck3.default)(this, LString);
	
	        // type Chunk
	        this.head = null;
	        // type: chunk
	        this.tail = null;
	        // 串的当前长度
	        this.length = 0;
	        this.chunkSize = chunkSize;
	    }
	
	    // 将字符串转换成LString类型
	
	
	    LString.prototype.strAssign = function strAssign(chars) {
	        this.head = this.tail = new Chunk(this.chunkSize);
	        this.length = chars.length;
	
	        var current = this.head;
	        for (var i = 0, len = chars.length; i < len; i++) {
	            current.ch[i % this.chunkSize] = chars[i];
	            if (i + 1 < len && (i + 1) % this.chunkSize === 0) {
	                current.next = new Chunk();
	                current = current.next;
	            }
	        }
	
	        this.tail = current;
	    };
	    // 字符串对比
	    // TODO 是否去掉chunkSize的对比
	
	
	    LString.prototype.strCompare = function strCompare(tLString) {
	        var current = this.head;
	        var curT = tLString.head;
	
	        if (this.length !== tLString.length) return false;
	
	        while (current) {
	            for (var i = 0; i < this.chunkSize; i++) {
	                if (current.ch[i] !== curT.ch[i]) return false;
	            }
	
	            current = current.next;
	            curT = curT.next;
	        }
	
	        return true;
	    };
	
	    LString.prototype.clearString = function clearString() {
	        this.head = this.tail = null;
	        this.length = 0;
	    };
	
	    LString.prototype.concat = function concat(tLSting) {
	        if (!tLSting.length) return;
	
	        var ret = new LString(this.chunkSize);
	
	        if (this.head === null) {
	            copyString(ret, tLSting);
	        } else {
	            ret.head = ret.tail = new Chunk(this.chunkSize);
	            copyString(ret, this);
	
	            var index = ret.tail.ch.indexOf('#');
	            if (index === -1) {
	                copyString(ret, tLSting);
	            } else {
	                copyString(ret, tLSting, ret.tail, tLSting.head, index);
	            }
	        }
	
	        return ret;
	    };
	
	    LString.prototype.substring = function substring(pos, len) {
	        pos = ~~pos || 0;
	        len = ~~len || this.length;
	        if (pos < 0 || pos > this.length - 1 || len < 0 || len > this.length - pos) throw new Error('unexpected parameter');
	
	        var sub = new LString(this.chunkSize);
	        var current = findPosChunk(this, pos);
	        var curS = sub.head = new Chunk(this.chunkSize);
	        var i = 0;
	        sub.length = len;
	
	        outerloop: while (current) {
	            for (var j = 0, size = this.chunkSize; j < size; j++) {
	                if (i === len) {
	                    break outerloop;
	                } else {
	                    curS.ch[j] = current.ch[(i + pos) % this.chunkSize];
	                    i++;
	                    if ((i + pos) % this.chunkSize === 0) {
	                        current = current.next;
	                    }
	                    if (i % this.chunkSize === 0 && (current.ch[i] || current.next)) {
	                        curS.next = new Chunk(this.chunkSize);
	                        curS = curS.next;
	                    }
	                }
	            }
	        }
	
	        return sub;
	    };
	
	    LString.prototype.toString = function toString() {
	        var current = this.head;
	
	        if (current === null) return '';
	
	        var str = '';
	        while (current) {
	            for (var i = 0, len = this.chunkSize; i < len; i++) {
	                var ch = current.ch[i];
	                if (ch === '#') {
	                    return str;
	                } else {
	                    str += current.ch[i];
	                }
	            }
	            current = current.next;
	        }
	
	        return str;
	    };
	
	    return LString;
	}();
	
	exports.default = LString;
	
	
	function findPosChunk(lString, pos) {
	    var current = lString.head;
	    while (current) {
	        for (var i = 0, len = lString.chunkSize; i < len; i++) {
	            if (pos-- === 0) return current;
	        }
	        current = current.next;
	    }
	}
	
	function copyString(destination, target, curD, currT, offset) {
	    offset = offset || 0;
	    currT = currT || target.head;
	    curD = curD || destination.head;
	    var k = 0;
	
	    while (currT) {
	        for (var i = 0, len = target.chunkSize; i < len; i++, k++) {
	            var j = k % curD.chunkSize + offset;
	            curD.ch[j % curD.chunkSize] = currT.ch[i];
	
	            if ((j + 1) % curD.chunkSize === 0 && (currT.ch[i + 1] || currT.next)) {
	                curD.next = new Chunk(destination.chunkSize);
	                curD = curD.next;
	            }
	        }
	
	        currT = currT.next;
	    }
	
	    destination.tail = curD;
	    destination.length += target.length;
	}
	
	var a = new LString();
	var b = new LString();
	var c = new LString();
	
	a.strAssign('abcdefg');
	console.log(a + '');
	b.strAssign('hijklmno');
	console.log(b + '');
	c.strAssign('abcdefg');
	console.log(a.strCompare(b));
	console.log(a.strCompare(c));
	var t = a.concat(b);
	console.log(t + '');
	t = t.substring(2, 5);
	console.log(t + '');
	
	// 判断是否为回文字符串
	function palindrome(lStr) {
	    var stack = new _index2.default();
	    var p = lStr.head;
	    var i = 0;
	
	    for (var k = 1; k <= lStr.length; ++k) {
	        if (k <= lStr.length / 2) stack.push(p.ch[i]);else if (k > (lStr.length + 1) / 2) {
	            var _c = stack.pop();
	            if (p.ch[i] !== _c) return false;
	        }
	
	        if (++i === lStr.chunkSize) {
	            p = p.next;
	            i = 0;
	        }
	    }
	
	    return true;
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 串（string）（或字符串）是由零个或多个字符组成的有限序列。串中字符的数目称为串的长度。零个字符的串称为空串（null string），它的长度为零。
	 * 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。
	 * 只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。
	 *
	 * 串有3种机内表示方法：
	 * 1.定长顺序存储表示
	 * 2.堆分配存储表示
	 * 3.串的块链存储表示
	 */
	
	/**
	 * 定长顺序存储表示
	 * 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组来描述。
	 * 以下标为0的数组分量存放串的实际长度。
	 */
	
	var SString = function () {
	    function SString(str) {
	        (0, _classCallCheck3.default)(this, SString);
	
	        this.MAXSTRLEN = 10;
	        if (str) {
	            this[0] = str.length;
	            for (var i = 1; i <= str.length; ++i) {
	                this[i] = str[i - 1];
	            }
	        }
	    }
	
	    // 返回由s1和s2连接而成的新串
	
	
	    SString.prototype.concat = function concat(s2) {
	        var t = new SString();
	        // 未截断
	        if (this[0] + s2[0] <= this.MAXSTRLEN) {
	            copyStr2T(this);
	            copyStr2T(s2, this[0]);
	            t[0] = this[0] + s2[0];
	
	            // 截断
	        } else if (this[0] < this.MAXSTRLEN) {
	            copyStr2T(this);
	            copyStr2T(s2, this[0], this.MAXSTRLEN - this[0]);
	            t[0] = this.MAXSTRLEN;
	
	            // 截断（仅取s1）
	        } else {
	            copyStr2T(this, 0, this.MAXSTRLEN);
	            t[0] = this[0] = this.MAXSTRLEN;
	        }
	
	        return t;
	
	        function copyStr2T(str) {
	            var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var end = arguments.length <= 2 || arguments[2] === undefined ? str[0] : arguments[2];
	
	            for (var i = 1, len = end || str[0]; i <= len; i++) {
	                t[start + i] = str[i];
	            }
	        }
	    };
	
	    SString.prototype.substring = function substring() {
	        var position = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var len = arguments.length <= 1 || arguments[1] === undefined ? this[0] : arguments[1];
	
	        position = ~~position;
	        len = ~~len;
	        if (position < 0 || position > this[0] - 1 || len < 0 || len > this[0] - position) throw new Error('unexpected parameter');
	
	        var sub = new SString();
	        for (var i = 1; i <= len; i++) {
	            sub[i] = this[position + i - 1];
	        }
	        sub[0] = len;
	
	        return sub;
	    };
	
	    /**
	     * 将串s中的子串t替换为v，返回替换次数
	     * todo to be tested
	     * @param {SString} t
	     * @param {SString} v
	     * @returns {number} 替换次数
	     */
	
	
	    SString.prototype.replace = function replace(t, v) {
	        for (var _n = 0, i = 1; i <= this[0] - t[0] + 1; i++) {
	            for (var j = i, _k = 1; t[_k] && this[j] === t[_k]; ++j, ++_k) {}
	
	            // 找到了与t匹配的字串：分三种情况处理
	            if (k > t[0]) {
	                var l = void 0;
	                // 新字串的长度与原子串相同时，直接替换
	                if (t[0] === v[0]) {
	                    for (l = 1; l <= t[0]; ++l) {
	                        this[i + l - 1] = v[l];
	                    }
	                }
	                // 新子串长度大于原子串时，先将后部右移
	                else if (t[0] < v[0]) {
	                        for (l = this[0]; l >= i + t[0]; --l) {
	                            this[l + v[0] - t[0]] = this[l];
	                        }for (l = 1; l <= v[0]; ++l) {
	                            this[i + l - 1] = v[l];
	                        }
	                    }
	                    // 新子串长度小于原子串时，先将后部左移
	                    else {
	                            for (l = i + v[0]; l <= this[0] + v[0] - t[0]; ++l) {
	                                this[l] = this[l - v[0] + t[0]];
	                            }for (l = 1; l <= v[0]; ++l) {
	                                this[i + l - 1] = v[l];
	                            }
	                        }
	
	                this[0] = this[0] - t[0] + v[0];
	                i += v[0];
	                ++_n;
	            }
	        }
	
	        return n;
	    };
	
	    SString.prototype.toString = function toString() {
	        var str = '';
	        for (var i = 1; this[i]; i++) {
	            str += this[i];
	        }
	        return str;
	    };
	    // 返回子串sstring在主串中的第position个字符之后的位置
	
	
	    SString.prototype.index = function index(sstring, position) {
	        var i = position || 1;
	        var j = 1;
	
	        while (i <= this[0] && j <= sstring[0]) {
	            if (this[i] === sstring[j]) {
	                i++;
	                j++;
	            } else {
	                i = i - j + 2;
	                j = 1;
	            }
	        }
	
	        return j > sstring[0] ? i - sstring[0] : -1;
	    };
	
	    SString.prototype.kmpIndex = function kmpIndex(sstring, position) {
	        var i = position || 1;
	        var j = 1;
	        var next = getNext(sstring);
	
	        while (i <= this[0] && j <= sstring[0]) {
	            if (j === 0 || this[i] === sstring[j]) {
	                ++i;
	                ++j;
	            } else {
	                j = next[j];
	            }
	        }
	
	        return j > sstring[0] ? i - sstring[0] : -1;
	    };
	
	    // 求包含在字符串中而str没有的字符串
	
	
	    SString.prototype.subtract = function subtract(str) {
	        var r = new SString();
	        r[0] = 0;
	
	        for (var i = 1; i <= this[0]; ++i) {
	            var _c = this[i];
	            // 判断当前字符c是否第一次出现
	            var j = 1;
	            for (; j < i && this[j] !== _c; ++j) {}
	            if (i === j) {
	                // 判断当前字符是否包含在str中
	                var _k2 = 1;
	                for (; _k2 <= str[0] && str[_k2] !== _c; ++_k2) {}
	                if (_k2 > str[0]) r[++r[0]] = _c;
	            }
	        }
	
	        return r;
	    };
	
	    // todo bug exists
	
	
	    SString.prototype.delete_substring = function delete_substring(str) {
	        var n = 0;
	        for (var i = 1; i <= this[0] - str[0] + 1; ++i) {
	            var j = 1;
	            for (; j <= str[0] && this[i + j - 1] === str[j]; ++j) {}
	            if (j > str[0] - 1) {
	                for (var _k3 = i; _k3 <= this[0] - str[0]; ++_k3) {
	                    this[_k3] = this[_k3 + str[0]];
	                }this[0] -= str[0];
	                ++n;
	            }
	        }
	
	        return n;
	    };
	
	    return SString;
	}();
	
	exports.default = SString;
	
	
	function getNext(sstring) {
	    var i = 1;
	    var next = { 1: 0 };
	    var j = 0;
	
	    while (i < sstring[0]) {
	        if (j === 0 || sstring[i] === sstring[j]) {
	            if (sstring[++i] !== sstring[++j]) {
	                next[i] = j;
	            } else {
	                next[i] = next[j];
	            }
	            //                next[++i] = ++j;
	        } else {
	            j = next[j];
	        }
	    }
	
	    return next;
	}
	
	var a = new SString();
	var b = new SString();
	for (var i = 0; i < 4; i++) {
	    a[i + 1] = i + '';
	    b[i + 1] = i + '';
	}
	a[0] = b[0] = 4;
	var t = a.concat(b);
	console.log(t + ''); // 01230123
	
	var d = new SString('acabaabaabcacaabc');
	var c = new SString('abaabc');
	
	console.log('index: ' + d.index(c));
	console.log('kmpIndex: ' + d.kmpIndex(c));
	
	a = new SString('abcdefg');
	b = new SString('asdfg');
	console.log(a.subtract(b) + '');
	
	a = new SString('abcdefgh');
	b = new SString('cdef');
	console.log(a.delete_substring(b) + '');
	console.log(a + '');
	
	/*
	 在顺序存储结构中，实现串操作的原操作为“字符串序列的复制”，操作时间复杂度基于复制的字符串序列的长度。
	 另一操作特点是，如果在操作中出现串值序列的长度超过MAXSTRLEN时，约定用截尾法处理，这种情况不仅在求连接串时可能发生，在串的其他操作中，如插入，置换等也可能发生，克服这个弊病唯有不限定串长的最大长度，即动态分配串值的存储空间。
	 */

/***/ },
/* 138 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 139 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 140 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(143);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(58)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(2).Buffer
	var Hash   = __webpack_require__(145)(Buffer)
	
	exports.sha1 = __webpack_require__(147)(Buffer, Hash)
	exports.sha256 = __webpack_require__(148)(Buffer, Hash)
	exports.sha512 = __webpack_require__(149)(Buffer, Hash)


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(39).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(39).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(39).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		h32: __webpack_require__(153)
	,	h64: __webpack_require__(154)
	}


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	xxHash implementation in pure Javascript
	
	Copyright (C) 2013, Pierre Curto
	MIT license
	*/
	var UINT32 = __webpack_require__(52).UINT32
	
	/*
		Merged this sequence of method calls as it speeds up
		the calculations by a factor of 2
	 */
	// this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
	UINT32.prototype.xxh_update = function (low, high) {
		var b00 = PRIME32_2._low
		var b16 = PRIME32_2._high
	
		var c16, c00
		c00 = low * b00
		c16 = c00 >>> 16
	
		c16 += high * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += low * b16
	
		var a00 = this._low + (c00 & 0xFFFF)
		var a16 = a00 >>> 16
	
		a16 += this._high + (c16 & 0xFFFF)
	
		var v = (a16 << 16) | (a00 & 0xFFFF)
		v = (v << 13) | (v >>> 19)
	
		a00 = v & 0xFFFF
		a16 = v >>> 16
	
		b00 = PRIME32_1._low
		b16 = PRIME32_1._high
	
		c00 = a00 * b00
		c16 = c00 >>> 16
	
		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16
	
		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF
	}
	
	/*
	 * Constants
	 */
	var PRIME32_1 = UINT32( '2654435761' )
	var PRIME32_2 = UINT32( '2246822519' )
	var PRIME32_3 = UINT32( '3266489917' )
	var PRIME32_4 = UINT32(  '668265263' )
	var PRIME32_5 = UINT32(  '374761393' )
	
	/**
	* Convert string to proper UTF-8 array
	* @param str Input string
	* @returns {Uint8Array} UTF8 array is returned as uint8 array
	*/
	function toUTF8Array (str) {
		var utf8 = []
		for (var i=0, n=str.length; i < n; i++) {
			var charcode = str.charCodeAt(i)
			if (charcode < 0x80) utf8.push(charcode)
			else if (charcode < 0x800) {
				utf8.push(0xc0 | (charcode >> 6),
				0x80 | (charcode & 0x3f))
			}
			else if (charcode < 0xd800 || charcode >= 0xe000) {
				utf8.push(0xe0 | (charcode >> 12),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
			// surrogate pair
			else {
				i++;
				// UTF-16 encodes 0x10000-0x10FFFF by
				// subtracting 0x10000 and splitting the
				// 20 bits of 0x0-0xFFFFF into two halves
				charcode = 0x10000 + (((charcode & 0x3ff)<<10)
				| (str.charCodeAt(i) & 0x3ff))
				utf8.push(0xf0 | (charcode >>18),
				0x80 | ((charcode>>12) & 0x3f),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
		}
	
		return new Uint8Array(utf8)
	}
	
	/**
	 * XXH object used as a constructor or a function
	 * @constructor
	 * or
	 * @param {Object|String} input data
	 * @param {Number|UINT32} seed
	 * @return ThisExpression
	 * or
	 * @return {UINT32} xxHash
	 */
	function XXH () {
		if (arguments.length == 2)
			return new XXH( arguments[1] ).update( arguments[0] ).digest()
	
		if (!(this instanceof XXH))
			return new XXH( arguments[0] )
	
		init.call(this, arguments[0])
	}
	
	/**
	 * Initialize the XXH instance with the given seed
	 * @method init
	 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
	 * @return ThisExpression
	 */
	 function init (seed) {
		this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed)
		this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2)
		this.v2 = this.seed.clone().add(PRIME32_2)
		this.v3 = this.seed.clone()
		this.v4 = this.seed.clone().subtract(PRIME32_1)
		this.total_len = 0
		this.memsize = 0
		this.memory = null
	
		return this
	}
	XXH.prototype.init = init
	
	/**
	 * Add data to be computed for the XXH hash
	 * @method update
	 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
	 * @return ThisExpression
	 */
	XXH.prototype.update = function (input) {
		var isString = typeof input == 'string'
		var isArrayBuffer
	
		// Convert all strings to utf-8 first (issue #5)
		if (isString) {
			input = toUTF8Array(input)
			isString = false
			isArrayBuffer = true
		}
	
		if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
		{
			isArrayBuffer = true
			input = new Uint8Array(input);
		}
	
		var p = 0
		var len = input.length
		var bEnd = p + len
	
		if (len == 0) return this
	
		this.total_len += len
	
		if (this.memsize == 0)
		{
			if (isString) {
				this.memory = ''
			} else if (isArrayBuffer) {
				this.memory = new Uint8Array(16)
			} else {
				this.memory = new Buffer(16)
			}
		}
	
		if (this.memsize + len < 16)   // fill in tmp buffer
		{
			// XXH_memcpy(this.memory + this.memsize, input, len)
			if (isString) {
				this.memory += input
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, len), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, len )
			}
	
			this.memsize += len
			return this
		}
	
		if (this.memsize > 0)   // some data left from previous update
		{
			// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
			if (isString) {
				this.memory += input.slice(0, 16 - this.memsize)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, 16 - this.memsize )
			}
	
			var p32 = 0
			if (isString) {
				this.v1.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v2.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v3.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v4.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
			} else {
				this.v1.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v2.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v3.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v4.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
			}
	
			p += 16 - this.memsize
			this.memsize = 0
			if (isString) this.memory = ''
		}
	
		if (p <= bEnd - 16)
		{
			var limit = bEnd - 16
	
			do
			{
				if (isString) {
					this.v1.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v2.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v3.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v4.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
				} else {
					this.v1.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v2.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v3.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v4.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
				}
				p += 4
			} while (p <= limit)
		}
	
		if (p < bEnd)
		{
			// XXH_memcpy(this.memory, p, bEnd-p);
			if (isString) {
				this.memory += input.slice(p)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(p, bEnd), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, p, bEnd )
			}
	
			this.memsize = bEnd - p
		}
	
		return this
	}
	
	/**
	 * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
	 * @method digest
	 * @return {UINT32} xxHash
	 */
	XXH.prototype.digest = function () {
		var input = this.memory
		var isString = typeof input == 'string'
		var p = 0
		var bEnd = this.memsize
		var h32, h
		var u = new UINT32
	
		if (this.total_len >= 16)
		{
			h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) )
		}
		else
		{
			h32  = this.seed.clone().add( PRIME32_5 )
		}
	
		h32.add( u.fromNumber(this.total_len) )
	
		while (p <= bEnd - 4)
		{
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
			}
			h32
				.add( u.multiply(PRIME32_3) )
				.rotl(17)
				.multiply( PRIME32_4 )
			p += 4
		}
	
		while (p < bEnd)
		{
			u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 )
			h32
				.add( u.multiply(PRIME32_5) )
				.rotl(11)
				.multiply(PRIME32_1)
		}
	
		h = h32.clone().shiftRight(15)
		h32.xor(h).multiply(PRIME32_2)
	
		h = h32.clone().shiftRight(13)
		h32.xor(h).multiply(PRIME32_3)
	
		h = h32.clone().shiftRight(16)
		h32.xor(h)
	
		// Reset the state
		this.init( this.seed )
	
		return h32
	}
	
	module.exports = XXH
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	xxHash64 implementation in pure Javascript
	
	Copyright (C) 2016, Pierre Curto
	MIT license
	*/
	var UINT64 = __webpack_require__(52).UINT64
	
	/*
	 * Constants
	 */
	var PRIME64_1 = UINT64( '11400714785074694791' )
	var PRIME64_2 = UINT64( '14029467366897019727' )
	var PRIME64_3 = UINT64(  '1609587929392839161' )
	var PRIME64_4 = UINT64(  '9650029242287828579' )
	var PRIME64_5 = UINT64(  '2870177450012600261' )
	
	/**
	* Convert string to proper UTF-8 array
	* @param str Input string
	* @returns {Uint8Array} UTF8 array is returned as uint8 array
	*/
	function toUTF8Array (str) {
		var utf8 = []
		for (var i=0, n=str.length; i < n; i++) {
			var charcode = str.charCodeAt(i)
			if (charcode < 0x80) utf8.push(charcode)
			else if (charcode < 0x800) {
				utf8.push(0xc0 | (charcode >> 6),
				0x80 | (charcode & 0x3f))
			}
			else if (charcode < 0xd800 || charcode >= 0xe000) {
				utf8.push(0xe0 | (charcode >> 12),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
			// surrogate pair
			else {
				i++;
				// UTF-16 encodes 0x10000-0x10FFFF by
				// subtracting 0x10000 and splitting the
				// 20 bits of 0x0-0xFFFFF into two halves
				charcode = 0x10000 + (((charcode & 0x3ff)<<10)
				| (str.charCodeAt(i) & 0x3ff))
				utf8.push(0xf0 | (charcode >>18),
				0x80 | ((charcode>>12) & 0x3f),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
		}
	
		return new Uint8Array(utf8)
	}
	
	/**
	 * XXH64 object used as a constructor or a function
	 * @constructor
	 * or
	 * @param {Object|String} input data
	 * @param {Number|UINT64} seed
	 * @return ThisExpression
	 * or
	 * @return {UINT64} xxHash
	 */
	function XXH64 () {
		if (arguments.length == 2)
			return new XXH64( arguments[1] ).update( arguments[0] ).digest()
	
		if (!(this instanceof XXH64))
			return new XXH64( arguments[0] )
	
		init.call(this, arguments[0])
	}
	
	/**
	 * Initialize the XXH64 instance with the given seed
	 * @method init
	 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
	 * @return ThisExpression
	 */
	 function init (seed) {
		this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed)
		this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2)
		this.v2 = this.seed.clone().add(PRIME64_2)
		this.v3 = this.seed.clone()
		this.v4 = this.seed.clone().subtract(PRIME64_1)
		this.total_len = 0
		this.memsize = 0
		this.memory = null
	
		return this
	}
	XXH64.prototype.init = init
	
	/**
	 * Add data to be computed for the XXH64 hash
	 * @method update
	 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
	 * @return ThisExpression
	 */
	XXH64.prototype.update = function (input) {
		var isString = typeof input == 'string'
		var isArrayBuffer
	
		// Convert all strings to utf-8 first (issue #5)
		if (isString) {
			input = toUTF8Array(input)
			isString = false
			isArrayBuffer = true
		}
	
		if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
		{
			isArrayBuffer = true
			input = new Uint8Array(input);
		}
	
		var p = 0
		var len = input.length
		var bEnd = p + len
	
		if (len == 0) return this
	
		this.total_len += len
	
		if (this.memsize == 0)
		{
			if (isString) {
				this.memory = ''
			} else if (isArrayBuffer) {
				this.memory = new Uint8Array(32)
			} else {
				this.memory = new Buffer(32)
			}
		}
	
		if (this.memsize + len < 32)   // fill in tmp buffer
		{
			// XXH64_memcpy(this.memory + this.memsize, input, len)
			if (isString) {
				this.memory += input
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, len), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, len )
			}
	
			this.memsize += len
			return this
		}
	
		if (this.memsize > 0)   // some data left from previous update
		{
			// XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);
			if (isString) {
				this.memory += input.slice(0, 32 - this.memsize)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, 32 - this.memsize )
			}
	
			var p64 = 0
			if (isString) {
				var other
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
					,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
					,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
					,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			} else {
				var other
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p64 += 8
				other = UINT64(
						(this.memory[p64+1] << 8) | this.memory[p64]
					,	(this.memory[p64+3] << 8) | this.memory[p64+2]
					,	(this.memory[p64+5] << 8) | this.memory[p64+4]
					,	(this.memory[p64+7] << 8) | this.memory[p64+6]
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			}
	
			p += 32 - this.memsize
			this.memsize = 0
			if (isString) this.memory = ''
		}
	
		if (p <= bEnd - 32)
		{
			var limit = bEnd - 32
	
			do
			{
				if (isString) {
					var other
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
						,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
						,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
						,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
						)
					this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				} else {
					var other
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
					p += 8
					other = UINT64(
							(input[p+1] << 8) | input[p]
						,	(input[p+3] << 8) | input[p+2]
						,	(input[p+5] << 8) | input[p+4]
						,	(input[p+7] << 8) | input[p+6]
						)
					this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				}
				p += 8
			} while (p <= limit)
		}
	
		if (p < bEnd)
		{
			// XXH64_memcpy(this.memory, p, bEnd-p);
			if (isString) {
				this.memory += input.slice(p)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(p, bEnd), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, p, bEnd )
			}
	
			this.memsize = bEnd - p
		}
	
		return this
	}
	
	/**
	 * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed
	 * @method digest
	 * @return {UINT64} xxHash
	 */
	XXH64.prototype.digest = function () {
		var input = this.memory
		var isString = typeof input == 'string'
		var p = 0
		var bEnd = this.memsize
		var h64, h
		var u = new UINT64
	
		if (this.total_len >= 32)
		{
			h64 = this.v1.clone().rotl(1)
			h64.add( this.v2.clone().rotl(7) )
			h64.add( this.v3.clone().rotl(12) )
			h64.add( this.v4.clone().rotl(18) )
	
			h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
	
			h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
	
			h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
	
			h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
			h64.multiply(PRIME64_1).add(PRIME64_4)
		}
		else
		{
			h64  = this.seed.clone().add( PRIME64_5 )
		}
	
		h64.add( u.fromNumber(this.total_len) )
	
		while (p <= bEnd - 8)
		{
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
				,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				,	(input[p+5] << 8) | input[p+4]
				,	(input[p+7] << 8) | input[p+6]
				)
			}
			u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1)
			h64
				.xor(u)
				.rotl(27)
				.multiply( PRIME64_1 )
				.add( PRIME64_4 )
			p += 8
		}
	
		if (p + 4 <= bEnd) {
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				,	0
				,	0
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				,	0
				,	0
				)
			}
			h64
				.xor( u.multiply(PRIME64_1) )
				.rotl(23)
				.multiply( PRIME64_2 )
				.add( PRIME64_3 )
			p += 4
		}
	
		while (p < bEnd)
		{
			u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 )
			h64
				.xor( u.multiply(PRIME64_5) )
				.rotl(11)
				.multiply(PRIME64_1)
		}
	
		h = h64.clone().shiftRight(33)
		h64.xor(h).multiply(PRIME64_2)
	
		h = h64.clone().shiftRight(29)
		h64.xor(h).multiply(PRIME64_3)
	
		h = h64.clone().shiftRight(32)
		h64.xor(h)
	
		// Reset the state
		this.init( this.seed )
	
		return h64
	}
	
	module.exports = XXH64
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 155 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyNTNiODI2YjkxOGJhY2Y1NGI5YiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1ZXVlL1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9CaW5hcnlUcmVlL0JpbmFyeVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0YWNrL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2RlZmF1bHRDb21wYXJpc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvY3JlYXRlLWhhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9Eb3VibGVMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0xpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvU3RhdGljTGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0JpbmFyeVNvcnRlZFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvZXhjaGFuZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtanMvbGliL2I2NC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyeXB0by1icm93c2VyaWZ5L2NyZWF0ZS1obWFjLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvbWQ1LmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvcGJrZGYyLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwid2VicGFjazovLy8uL34vY3VpbnQvbGliL3VpbnQzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L2N1aW50L2xpYi91aW50NjQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FycmF5L0Nyb3NzTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXJyYXkvVFNNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR2VuZXJhbGl6ZWRMaXN0L0dMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BTUxHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoLmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BZGphY2VuY3lNYXRyaXhHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvT0xHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTGluZWFyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVldWUvQ3ljbGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVldWUvUHJpb3JpdHlRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0FWTFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0JpbmFyeVNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0Jsb29tRmlsdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9IYXNoVGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9SZWRCbGFja1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9TT1NUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvZmlib25hY2NpU2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvc2VxdWVudGlhbFNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kaXN0cmlidXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvaW5zZXJ0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L21lcmdpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvc2VsZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9TdHJpbmcvSFN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RyaW5nL0xTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0cmluZy9TU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcGJrZGYyLWNvbXBhdC9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL34vcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGExLmpzIiwid2VicGFjazovLy8uL34vc2hhLmpzL3NoYTI1Ni5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGE1MTIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34veHhoYXNoanMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34veHhoYXNoanMvbGliL3h4aGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h4aGFzaGpzL2xpYi94eGhhc2g2NC5qcyIsIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKSJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQXJyYXkiLCJDcm9zc0xpc3QiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIlRTTWF0cml4IiwiQmluYXJ5VHJlZSIsImh1ZmZNYW5Db2RpbmciLCJHZW5lcmFsaXplZExpc3QiLCJHcmFwaCIsIkFkamFjZW5jeUxpc3RHcmFwaCIsIkFkamFjZW5jeU1hdHJpeEdyYXBoIiwiQU1MR3JhcGgiLCJPTEdyYXBoIiwiTGlzdCIsIkRvdWJsZUxpbmtlZExpc3QiLCJMaW5lYXJMaXN0IiwiU3RhdGljTGlua2VkTGlzdCIsIkxSVUNhY2hlIiwiUXVldWUiLCJDeWNsZVF1ZXVlIiwiUHJpb3JpdHlRdWV1ZSIsIlNlYXJjaCIsIkFWTFRyZWUiLCJiaW5hcnlTZWFyY2giLCJCaW5hcnlTb3J0ZWRUcmVlIiwiQlBsdXNUcmVlIiwiQlRyZWUiLCJEaWdpdGFsU2VhcmNoVHJlZSIsImZpYm9uYWNjaVNlYXJjaCIsIkhhc2hUYWJsZSIsIlJlZEJsYWNrVHJlZSIsInNlcXVlbnRpYWxTZWFyY2giLCJTT1NUcmVlIiwiQmxvb21GaWx0ZXIiLCJTb3J0IiwiZGlzdHJpYnV0aW9uIiwiZXhjaGFuZ2UiLCJpbnNlcnRpb24iLCJtZXJnaW5nIiwic2VsZWN0aW9uIiwiU3RhY2siLCJTdHJpbmciLCJIU3RyaW5nIiwiTFN0cmluZyIsIlNTdHJpbmciLCJyZWFyIiwiZnJvbnQiLCJzaXplIiwiaXNFbXB0eSIsImNsZWFyIiwiZ2V0SGVhZCIsImRhdGEiLCJlblF1ZXVlIiwiZWxlbSIsIm5leHQiLCJwIiwiZGVRdWV1ZSIsInF1ZXVlVHJhdmVyc2UiLCJpdGVyYXRvciIsImN1cnJlbnQiLCJwZWVrQXQiLCJpbmRleCIsImkiLCJ0b1N0cmluZyIsImFyciIsImxlbiIsInF1ZXVlIiwiY29uc29sZSIsImxvZyIsImpvaW4iLCJyZXBhaW50Q29sb3IiLCJtYXRyaXgiLCJqIiwiY29sb3IiLCJvbGQiLCJtIiwibGVuZ3RoIiwibiIsIngiLCJ5IiwiYSIsInNldENvbG9yIiwidHJlZSIsInByZU9yZGVyUmVjdXJzaXZlIiwidmlzaXQiLCJ2YWx1ZSIsImluT3JkZXJSZWN1cnNpdmUiLCJwb3N0T3JkZXJSZWN1cnNpdmUiLCJsZWZ0Q2hpbGQiLCJyaWdodENoaWxkIiwiaXNTaW1pbGFyIiwiY3JlYXRlQmluYXJ5VHJlZSIsIm5vZGUiLCJwYXJlbnROb2RlIiwiU3ltYm9sIiwicHJlT3JkZXJOb25SZWN1cnNpdmUiLCJzdGFjayIsInB1c2giLCJwb3AiLCJpbk9yZGVyTm9uUmVjdXJzaXZlIiwicG9zdE9yZGVyTm9uUmVjdXJzaXZlIiwibGV2ZWxPcmRlclRyYXZlcnNlIiwiZ2V0UHJlU2VxdWVuY2UiLCJrIiwiY291bnQiLCJyZWN1cnNlIiwiY291bnRMZWF2ZXMiLCJyZXZvbHV0ZUJpbmFyeVRyZWUiLCJyZXZvbHV0ZU5vblJlY3Vyc2l2ZSIsImdldFN1YkRlcHRoIiwiZ2V0RGVwdGgiLCJkZWxTdWJYIiwiY29weSIsImNiIiwic3RhY2sxIiwic3RhY2syIiwiQ3N0ciIsImNvbnN0cnVjdG9yIiwibmV3VHJlZSIsInEiLCJwZWVrIiwiZmluZE5lYXJBbmNpZW50IiwicE5vZGUiLCJxTm9kZSIsInBhdGhQIiwiZmluZFBhdGgiLCJwYXRoUSIsImx1c2hEZWdyZWUiLCJjb3VudEFyciIsImxheWVyIiwiciIsImhlaWdodCIsIm1heCIsImRlc2NOdW0iLCJkIiwiaXNGdWxsQmluYXJ5VHJlZSIsImZsYWciLCJwYXRoIiwiZm91bmQiLCJnbG9iYWwiLCJGdW5jdGlvbiIsInByaW50UGF0aF9tYXhEZXB0aFMxIiwibWF4aCIsImZpbmRfaCIsImgiLCJzIiwidGVzdCIsIlBhcmVudFRyZWUiLCJub2RlcyIsIm1heERlcHRoIiwiZGVwIiwicGFyZW50IiwiUGFyZW50VHJlZU5vZGUiLCJwdCIsIkNoaWxkVHJlZSIsInNlbGYiLCJzdWJEZXB0aCIsInJvb3RJbmRleCIsInNkIiwiY2hpbGQiLCJDaGlsZFRyZWVCb3giLCJmaXJzdENoaWxkIiwiQ2hpbGRUcmVlTm9kZSIsIkNoaWxkU2libGluZ1RyZWUiLCJuZXh0U2libGluZyIsInByaW50IiwibGVhZkNvdW50IiwiZ2V0RGVncmVlIiwiZGVncmVlIiwibWF4ZCIsInRvcCIsIm91dCIsInRyYWluQXJyYW5nZSIsInRyYWluIiwiYyIsImlzUmV2ZXJzZSIsInN0ciIsIm51bVRyYW5zZm9ybSIsIm51bWJlciIsInJhZCIsInBhcnNlSW50IiwiYnJhY2tldHNNYXRjaCIsInRleHQiLCJFcnJvciIsIk1hdGNoZXIiLCJsZWZ0IiwicmlnaHQiLCJwcm90b3R5cGUiLCJtYXRjaCIsIkxpbmVFZGl0b3IiLCJnZXRSZXN1bHQiLCJyZXN1bHQiLCJsZSIsInByaW90eSIsImRvb3AiLCJvcCIsIm9wbjEiLCJvcG4yIiwiTWF0aCIsInBvdyIsIm9wY29tcCIsImIiLCJjYWxJbmZpeEV4cHJlc3Npb24iLCJleHAiLCJjcyIsIm5zIiwicmVwbGFjZSIsInBhcnNlRmxvYXQiLCJOYU4iLCJleHAxIiwiZGVmYXVsdENvbXBhcmUiLCJOb2RlIiwicHJldiIsInNxTGlzdCIsImNvbXBhcmUiLCJoZWFkIiwidGFpbCIsIml0ZW0iLCJ1bnNoaWZ0Iiwic2hpZnQiLCJ1cGRhdGUiLCJmaW5kQnlJbmRleCIsInJlbW92ZSIsImluZGV4T2YiLCJyZXR1cm5Ob2RlIiwiZm9yRWFjaCIsInRvSlNPTiIsImxpc3QiLCJMaW5rZWRMaXN0IiwibWVyZ2VMaXN0IiwiY29tcEZuIiwiaGEiLCJoYiIsInBhIiwicGIiLCJkYXRhMSIsImRhdGEyIiwiYXBwZW5kIiwicHJldmlvdXMiLCJ0ZW1wIiwiaW5zZXJ0QWZ0ZXIiLCJ0YXJnZXQiLCJlYWNoIiwiY2FsbGJhY2siLCJvcmRlckluc2VydCIsImNtcCIsIm1lIiwicmV0IiwiaW5zZXJ0QmV0d2VlbiIsImRlbGV0ZV9iZXR3ZWVuIiwibWluIiwibGFzdCIsImRlbGV0ZV9lcXVhbCIsInJldmVyc2UiLCJpbnRlcnNlY3QiLCJiTGlzdCIsImNMaXN0IiwiaW50ZXJzZWN0X3RydWUiLCJwYyIsImludGVyc2VjdF9kZWxldGUiLCJKU09OIiwic3RyaW5naWZ5IiwibGlzdDIiLCJsaXN0MyIsInBvcFRlc3QiLCJNQVhTSVpFIiwiY3VyIiwiZmluZCIsImluaXQiLCJtYWxsb2MiLCJmcmVlIiwiY3JlYXRlIiwiYWRkIiwiZGlmZmVyZW5jZSIsInNsbGlzdCIsImFycjEiLCJhcnIyIiwic2wiLCJCU1ROb2RlIiwiYXJnIiwic2VhcmNoIiwia2V5Iiwic2VhcmNoTm9uUmVjdXJzaXZlIiwiaW5zZXJ0IiwiaW5zZXJ0Tm9uUmVjdXJzaXZlIiwiY3JlYXRlQlNUIiwidXNlTm9uUmVjdXJzaXZlIiwiZGVsZXRlTm9kZSIsInJlbW92ZU5vblJlY3Vyc2l2ZSIsImYiLCJmaW5kTmVpZ2hib3JFbGVtIiwiSW5maW5pdHkiLCJtZXJnZSIsImJzdCIsImluc2VydE5vZGUiLCJzcGxpdCIsImlzQlNUVHJlZSIsInBvcyIsImJzdDIiLCJwcmludE5vdExlc3NUaGFuIiwiYTEiLCJhMiIsImJ1YmJsZVNvcnQiLCJidWJibGVTb3J0MiIsImNvY2tUYWlsU29ydCIsImNvY2tUYWlsU29ydDIiLCJxdWlja1NvcnRSZWN1cnNpdmUiLCJxdWlja1NvcnRSZWN1cnNpdmUyIiwicXVpY2tTb3J0Tm9uUmVjdXJzaXZlIiwicXVpY2tTb3J0Iiwib2RkRXZlblNvcnQiLCJjb21wIiwiY2hhbmdlIiwibG93IiwiaGlnaCIsInBhcnRpdGlvbjEiLCJwYXJ0aXRpb24yIiwicmFuZCIsImZsb29yIiwicmFuZG9tIiwicGl2b3QiLCJwYXJ0aXRpb24iLCJlYXN5U29ydCIsIlJFRCIsIldISVRFIiwiQkxVRSIsImZsYWdBcnJhbmdlIiwiY29sb3JzIiwiT0xOb2RlIiwiZSIsImRvd24iLCJyaGVhZCIsImNoZWFkIiwibXUiLCJudSIsInR1IiwiY3JlYXRlU01hdHJpeCIsInQiLCJyb3ciLCJhZGRNYXRyaXgiLCJjcm9zc0xpc3QiLCJobCIsInByZSIsImxpc3RzIiwibGlzdHMyIiwiVHJpcGxlIiwiYWRkVHJpcGxlIiwidHJpcGxlIiwidHJhbnNwb3NlU01hdHJpeCIsImNvbCIsImZhc3RUcmFuc3Bvc2VTTWF0cml4IiwibnVtIiwiY3BvdCIsImEzIiwiYTQiLCJhNSIsImE2IiwiYTciLCJhOCIsIlJMU01hdHJpeCIsImFyZ3VtZW50cyIsInJwb3MiLCJtdWx0U01hdHJpeCIsIm5NYXRyaXgiLCJxTWF0cml4IiwiYXJvdyIsImN0ZW1wIiwidHAiLCJjY29sIiwiYnJvdyIsIl9jYWxjUG9zIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJ0MSIsImMxIiwiYzIiLCJjMyIsImM0IiwidDIiLCJIdWZmbWFuTm9kZSIsIndlaWdodCIsIndlaWdodHMiLCJodWZmbWFuVHJlZSIsImJ1aWxkSHVmZm1hblRyZWUiLCJoYyIsImNhbGNIdWZmbWFuQ29kZSIsImNkIiwic3RhcnQiLCJzdHJDb3B5Iiwic2VsZWN0IiwiczEiLCJzMiIsIkFUT00iLCJMSVNUIiwiR0xOb2RlIiwidGFnIiwidW5kZWZpbmVkIiwiYXRvbSIsInB0ciIsImhwIiwiZGVwdGgiLCJjb3B5TGlzdCIsImdMaXN0IiwiY3JlYXRlR0xpc3QiLCJzdHJpbmciLCJ0cmltIiwiaXNXb3JkIiwic3ViIiwic3Vic3RyIiwiaHN1YiIsImNoIiwiZXF1YWwiLCJnTGlzdDEiLCJnTGlzdDIiLCJjYWxsIiwib3JkZXJQcmludCIsIm9yZGVyUHJpbnQyIiwiR0xOb2RlMiIsIk1QTm9kZSIsImNvZWYiLCJVTlZJU0lURUQiLCJWSVNJVEVEIiwiRUJveCIsIm1hcmsiLCJpdmV4IiwianZleCIsImlsaW5rIiwiamxpbmsiLCJpbmZvIiwiQU1MVmV4Qm94IiwiZmlyc3RFZGdlIiwiYWRqTXVsaXN0IiwidmV4bnVtIiwiZWRnZW51bSIsImxvY2F0ZVZleCIsInYiLCJkZWxldGVBcmMiLCJ3IiwiY3JlYXRlR3JhcGgiLCJwcm9tcHQiLCJlcnJvciIsIkRHIiwiRE4iLCJVREciLCJVRE4iLCJBcmNOb2RlIiwiYWRqVmV4IiwibmV4dEFyYyIsIlZleE5vZGUiLCJmaXJzdEFyYyIsImluZGVncmVlIiwidmVydGljZXMiLCJhcmNudW0iLCJraW5kIiwidnAiLCJhZGRWZXJ0ZXgiLCJhZGRBcmMiLCJhcmMxIiwiYXJjMiIsImluY0luZm8iLCJhbGVydCIsImlzUGFzcyIsInoiLCJpc0FkaiIsImV4aXN0X3BhdGhfREZTIiwidmlzaXRlZCIsImV4aXN0X3BhdGgiLCJncmFwaCIsImV4aXN0X3BhdGhfQkZTIiwidSIsImV4aXN0X3BhdGhfbGVuIiwibCIsImZpbmRfYWxsX3BhdGgiLCJnZXRQYXRoTnVtX2xlbiIsInN1bSIsImdldFJvb3QiLCJkZnMiLCJnZXRMb25nZXN0UGF0aCIsIm1scCIsIm1heExlbiIsImNvdW50SW5kZWdyZWUiLCJERlNUcmF2ZXJzZSIsInZpc2l0Rm4iLCJERlNUcmF2ZXJzZV9Ob25SZWN1cnNlIiwiQkZTVHJhdmVyc2UiLCJjcmVhdGVERlNGb3Jlc3QiLCJERlNUcmVlIiwiZmlyc3QiLCJjcmVhdGVCRlNGb3Jlc3QiLCJub2RlMiIsImZpbmRBcnRpY3VsIiwiREZTQXJ0aWN1bCIsInYwIiwidG9wb2xvZ2ljU29ydCIsInRvcG9sb2dpY2FsT3JkZXIiLCJjcml0aWNhbFBhdGgiLCJ2ZSIsInZsIiwic2hvcnRlc3RQYXRoX0RpamtzdHJhIiwiZGlzdCIsImZpbmFsIiwiYWRqTGlzdEdyYXBoIiwiZyIsImcyIiwiYXJ0aWN1bFRlc3QiLCJ0b3BvbG9naWNUZXN0IiwiY3JpdGljYWxQYXRoVGVzdCIsImRpalRlc3QiLCJuaUJvTGFuX0RBRyIsInByaW50TmlCb0xhbiIsImV2YWx1YXRlX0RBRyIsImV2YWx1YXRlX2ltcCIsInYxIiwidjIiLCJjYWxjdWxhdGUiLCJvcGVyYXRpb24iLCJldmFsIiwiZGFnIiwiQXJjQ2VsbCIsImFkaiIsInZleHMiLCJhcmNzIiwiY3JlYXRlREciLCJjcmVhdGVETiIsImNyZWF0ZVVERyIsImNyZWF0ZVVETiIsInZleDEiLCJ2ZXgyIiwiYXJjIiwiZGVsZXRlVmV4IiwidmV4IiwiZmlyc3RBZGpWZXgiLCJuZXh0QWRqVmV4IiwidmVydGV4IiwibWluU3BhblRyZWVfUFJJTSIsImNsb3NlZGdlIiwiYWRqdmV4IiwibG93Y29zdCIsInRlIiwibWluU3BhblRyZWVfS3J1c2thbCIsInNldCIsInNob3J0ZXN0UGF0aF9GTE9ZRCIsInBybl9wYXNzIiwic2V0TWF0cml4VmFsdWUiLCJ1ZG4iLCJkbiIsImcxIiwiYnNmRyIsImZsb3lkIiwiQXJjQm94IiwidGFpbFZleCIsImhlYWRWZXgiLCJoTGluayIsInRMaW5rIiwiT0xWZXhOb2RlIiwiZmlyc3RJbiIsImZpcnN0T3V0IiwieExpc3QiLCJkZWxldGVWZXJ0ZXgiLCJnZXRTR3JhcGgiLCJmaW5pc2hlZCIsImRmczEiLCJkZnMyIiwiY29ubmVjdGVkX0RHIiwiaW5fb3JkZXIiLCJyZXZfZGZzIiwiTElNSVQiLCJsaW1pdCIsInNsaWNlIiwiX19jYWNoZSIsIl9fX2NhY2hlIiwiZ2V0IiwidW5pb24iLCJkZWwiLCJsaXN0Q29tcCIsImJMZW4iLCJhTGVuIiwiYUVsZW0iLCJiRWxlbSIsImFMaXN0Iiwic3BsaWNlIiwic2FtZSIsIm1heHNpemUiLCJiYXNlIiwiTUFYUVNJWkUiLCJoZWFwIiwicHJpb3JpdHkiLCJ1cEhlYXBBZGp1c3QiLCJkb3duSGVhcEFkanVzdCIsImNlaWwiLCJvYmoiLCJvYmplY3QiLCJBdmxUcmVlIiwicm9vdCIsIl9hZGRMZWZ0IiwiX2FkZFJpZ2h0IiwibmV3Tm9kZSIsIl9iYWxhbmNlIiwiX2JhbGFuY2VMZWZ0UmlnaHQiLCJsZWZ0TGVmdCIsIl9iYWxhbmNlTGVmdExlZnQiLCJfYmFsYW5jZVJpZ2h0TGVmdCIsInJpZ2h0UmlnaHQiLCJfYmFsYW5jZVJpZ2h0UmlnaHQiLCJsZWZ0SGVpZ2h0IiwicmlnaHRIZWlnaHQiLCJuZXdIZWlnaHQiLCJfcmVtb3ZlIiwicmVwbGFjZW1lbnQiLCJiYWxhbmNlRnJvbSIsInJlbW92ZUJ5UmVmIiwiZ2V0Rmlyc3QiLCJnZXRMYXN0IiwiZ2V0SGVpZ2h0IiwiZ2V0Q291bnQiLCJwcm9jZXNzaW5nRnVuYyIsInBhcmFtcyIsImZvckVhY2hSZXZlcnNlIiwiaXNEZWZpbmVkIiwib3B0aW9ucyIsIm9yZGVyIiwibWVyZ2VUaHJlc2hvbGQiLCJnZXRMZWZ0UGVlciIsImxlZnRQZWVyIiwic2V0TGVmdFBlZXIiLCJnZXRSaWdodFBlZXIiLCJyaWdodFBlZXIiLCJzZXRSaWdodFBlZXIiLCJnZXREYXRhIiwiZ2V0U3VycGx1cyIsImdldFJpZ2h0U3VycGx1c0RhdGEiLCJzdXJwbHVzIiwiZ2V0TGVmdFN1cnBsdXNEYXRhIiwiSW50ZXJuYWxOb2RlIiwiT2JqZWN0IiwiZmluZEluZGV4IiwibWlkIiwiZmluZENoaWxkIiwiZWxlbWVudCIsImNsb2JiZXIiLCJuZXdOb2RlcyIsImxlZnRFbGVtZW50IiwicmlnaHRFbGVtZW50Iiwic3BsaXRJbmRleCIsImxlZnROb2RlIiwicmlnaHROb2RlIiwibGVmdE1lcmdlT3B0aW9uIiwicmlnaHRNZXJnZU9wdGlvbiIsIm1lcmdlSW5kZXgiLCJyZXR2YWwiLCJtZXJnZUVsZW1lbnQiLCJjb25jYXQiLCJsZWZ0U3VycGx1cyIsImxlZnREYXRhIiwicmlnaHRTdXJwbHVzIiwicmlnaHREYXRhIiwibGVmdFN1cnBsdXNEYXRhIiwicmlnaHRTdXJwbHVzRGF0YSIsIm1lcmdlZEludGVybmFsTm9kZSIsInJhbmdlIiwiZW5kIiwiaW5kZW50IiwibWFwIiwiTGVhZk5vZGUiLCJtZXJnZWRMZWFmTm9kZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIm5vZGVEYXRhIiwiVHJlZSIsImRlZmluZSIsInZhcl9hcmdzIiwiYXBwbHkiLCJhc2VhcmNoIiwiYnRyZWUiLCJzdHJjbXAiLCJhYyIsImJjIiwiY2hhckNvZGVBdCIsIm51bWNtcCIsImludGNtcCIsIm1pbk9yZGVyIiwidmFsaWRhdGUiLCJsZWF2ZXMiLCJUcmVlTm9kZSIsImxlYWYiLCJwdXQiLCJvdmVyd3JpdGUiLCJMZWFmIiwiYmFsYW5jZSIsInNlcCIsInJlc3QiLCJzdWJzdCIsInVuc3BsaXQiLCJpbmNsdWRlTm9kZXMiLCJ2YWwiLCJzcGFjZSIsIndhbGtBc2MiLCJtaW5LZXkiLCJtYXhLZXkiLCJ3YWxrIiwid2Fsa0Rlc2MiLCJiaW5hcnlTZWFyY2hSZWN1cnNpdmUiLCJzVGFibGUiLCJMTjJfU1FVQVJFRCIsIkxOMiIsInNlZWRzIiwiaGFzaGVzIiwiX2dlbmVyYXRlU2VlZHMiLCJiaXRzIiwiYnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJvcHRpbWl6ZSIsIml0ZW1Db3VudCIsImVycm9yUmF0ZSIsInJvdW5kIiwiY3JlYXRlT3B0aW1hbCIsIm9wdHMiLCJmaWxsIiwiYnVmIiwicmVhZFVJbnQzMkxFIiwiaXNBcnJheSIsImZyb20iLCJoYXNoIiwiYml0IiwiX3NldEJpdCIsImhhcyIsImlzSW5TZXQiLCJfZ2V0Qml0IiwiYml0RmllbGQiLCJmaWx0ZXIiLCJDb3VudGluZ0Jsb29tRmlsdGVyIiwib3ZlcmZsb3ciLCJfdW5TZXRCaXQiLCJpc0J1ZmZlciIsIkxFQUYiLCJCUkFOQ0giLCJURVJNSU5BTCIsIkRvdWJsZUxpbmtlZFRyZWUiLCJzeW1ib2wiLCJzeW5vU2VhcmNoIiwic3VjY2VzcyIsInRvTG93ZXJDYXNlIiwicmVtb3ZlTm9kZSIsInRyaWVOb2RlIiwiYnJhbmNoIiwiaGFzT3duUHJvcGVydHkiLCJwYXJlbnROb2RlcyIsIlRyaWVUcmVlIiwiaGFzaFNpemUiLCJidWlsZEhhc2hTaXplIiwic2l6ZUluZGV4IiwiY29sbGlzaW9uIiwiY29sbGlzaW9uVGltZXMiLCJlcnJvcm1zZyIsInJlY3JlYXRlSGFzaFRhYmxlIiwiYWJzIiwidGltZXMiLCJpc1ByaW1lIiwiYmVnaW4iLCJMaW5rZWRMaXN0SGFzaFRhYmxlIiwiaE5vZGVzIiwidGVzdDIiLCJCTEFDSyIsIlJlZEJsYWNrTm9kZSIsIlJlZEJsYWNrTGVhZiIsIm5pbCIsIl9hZGRGaXh1cCIsImxlZnRBZGRGaXh1cCIsInJpZ2h0QWRkRml4dXAiLCJzdWNjZXNzb3IiLCJfcmVtb3ZlRml4dXAiLCJyZW1vdmVOb2RlMiIsIm9yaWdpbmFsWUNvbG9yIiwiX3RyYW5zcGxhbnQiLCJsZWZ0UmVtb3ZlRml4dXAiLCJyaWdodFJlbW92ZUZpeHVwIiwiX3JvdGF0ZUxlZnQiLCJyb3RhdGUiLCJfcm90YXRlUmlnaHQiLCJkaXIiLCJhZGRGaXh1cCIsInJvdGF0ZTEiLCJyb3RhdGUyIiwicmVtb3ZlRml4dXAiLCJyMSIsInIyIiwic2Vjb25kT3B0aW1hbCIsImNyZWF0ZVNPU1RyZWUiLCJzV2VpZ2h0cyIsImR3IiwiZWxlbXMiLCJzdyIsImZpbmRTVyIsInNvc1RyZWUiLCJmaWIiLCJmMCIsImYxIiwiZjIiLCJjb3VudFNvcnQiLCJyYWRpeFNvcnQiLCJtYXhFbGVtIiwibWF4Qml0IiwicmFkaXgiLCJCVUNLRVRTTlVNIiwiYnVja2V0U29ydCIsImJ1Y2tldEEiLCJidWNrZXQiLCJzdHJhaWdodEluc2VydFNvcnQiLCJiaW5hcnlJbnNlcnRTb3J0IiwicGF0aDJJbnNlcnRTb3J0Iiwic3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQiLCJzaGVsbFNvcnQiLCJhcnJhbmdlIiwic2hlbGxJbnNlcnQiLCJkayIsImRlbHRhIiwiY3JlYXRlRGVsdGEiLCJtZXJnZVNvcnRSZWN1cnNpdmUiLCJtZXJnZVNvcnROb25SZWN1cnNpdmUiLCJuYXR1cmVNZXJnZVNvcnQiLCJuQ291bnQiLCJub25SZWN1cnNpdmVDb3VudCIsInJlY3Vyc2l2ZUNvdW50Iiwic3IiLCJlMSIsImUyIiwicGFzcyIsInJlYyIsIm5hdHVyYWxNZXJnZVNvcnQiLCJtZXJnZVJ1bnMiLCJhc2MiLCJsaW5rZWRMaXN0TmF0dXJhbE1lcmdlU29ydCIsIm1lcmdlU29ydCIsImxpbmtlZGxpc3QiLCJuZWVkUmVwbGFjZSIsImxpbmtlZExpc3QiLCJzaW1wbGVTZWxlY3Rpb25Tb3J0IiwiaGVhcFNvcnQiLCJoZWFwQWRqdXN0IiwicmMiLCJzdHJJbnNlcnQiLCJwb3NpdGlvbiIsInRIU3RyaW5nIiwic3RyaW5nQ29weSIsInN0ckFzc2lnbiIsImNoYXJzIiwic3RyTGVuZ3RoIiwic3RyQ29tcGFyZSIsImNsZWFyU3RyaW5nIiwic3Vic3RyaW5nIiwiZGVzdGluYXRpb24iLCJkZXN0U3RhcnQiLCJ0YXJnZXRTdGFydCIsIkNodW5rIiwiY2h1bmtTaXplIiwidExTdHJpbmciLCJjdXJUIiwidExTdGluZyIsImNvcHlTdHJpbmciLCJmaW5kUG9zQ2h1bmsiLCJjdXJTIiwib3V0ZXJsb29wIiwibFN0cmluZyIsImN1ckQiLCJjdXJyVCIsIm9mZnNldCIsInBhbGluZHJvbWUiLCJsU3RyIiwiTUFYU1RSTEVOIiwiY29weVN0cjJUIiwic3N0cmluZyIsImttcEluZGV4IiwiZ2V0TmV4dCIsInN1YnRyYWN0IiwiZGVsZXRlX3N1YnN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUNyQ0FBLFFBQU9DLE9BQVAsR0FBaUI7QUFDYkMsWUFBTztBQUNIQyxvQkFBVyxtQkFBQUMsQ0FBUSxHQUFSLEVBQTZCQyxPQURyQztBQUVIQyxtQkFBVSxtQkFBQUYsQ0FBUSxHQUFSLEVBQTRCQztBQUZuQyxNQURNOztBQU1iRSxpQkFBWTtBQUNSO0FBQ0FBLHFCQUFZLG1CQUFBSCxDQUFRLEVBQVIsQ0FGSjtBQUdSO0FBQ0FJLHdCQUFlLG1CQUFBSixDQUFRLEdBQVIsRUFBc0NDO0FBSjdDLE1BTkM7O0FBZWJJLHNCQUFpQixtQkFBQUwsQ0FBUSxHQUFSLEVBQW1DQyxPQWZ2Qzs7QUFpQmJLLFlBQU87QUFDSEMsNkJBQW9CLG1CQUFBUCxDQUFRLEdBQVIsRUFBc0NDLE9BRHZEO0FBRUhPLCtCQUFzQixtQkFBQVIsQ0FBUSxHQUFSLEVBQXdDQyxPQUYzRDtBQUdIUSxtQkFBVSxtQkFBQVQsQ0FBUSxHQUFSLEVBQTRCQyxPQUhuQztBQUlIUyxrQkFBUyxtQkFBQVYsQ0FBUSxHQUFSLEVBQTJCQztBQUpqQyxNQWpCTTs7QUF3QmJVLFdBQU07QUFDRkMsMkJBQWtCLG1CQUFBWixDQUFRLEVBQVIsRUFBbUNDLE9BRG5EO0FBRUZZLHFCQUFZLG1CQUFBYixDQUFRLEdBQVIsQ0FGVjtBQUdGYywyQkFBa0IsbUJBQUFkLENBQVEsRUFBUixFQUFtQ0MsT0FIbkQ7QUFJRmMsbUJBQVUsbUJBQUFmLENBQVEsR0FBUixFQUFzQkM7QUFKOUIsTUF4Qk87O0FBK0JiZSxZQUFPO0FBQ0hDLHFCQUFZLG1CQUFBakIsQ0FBUSxHQUFSLEVBQThCQyxPQUR2QztBQUVIaUIsd0JBQWUsbUJBQUFsQixDQUFRLEdBQVIsRUFBaUNDLE9BRjdDO0FBR0hlLGdCQUFPLG1CQUFBaEIsQ0FBUSxFQUFSLEVBQXlCQztBQUg3QixNQS9CTTs7QUFxQ2JrQixhQUFRO0FBQ0pDLGtCQUFTLG1CQUFBcEIsQ0FBUSxHQUFSLENBREw7QUFFSnFCLHVCQUFjLG1CQUFBckIsQ0FBUSxHQUFSLENBRlY7QUFHSnNCLDJCQUFrQixtQkFBQXRCLENBQVEsRUFBUixFQUFxQ0MsT0FIbkQ7QUFJSnNCLG9CQUFXLG1CQUFBdkIsQ0FBUSxHQUFSLENBSlA7QUFLSndCLGdCQUFPLG1CQUFBeEIsQ0FBUSxHQUFSLENBTEg7QUFNSnlCLDRCQUFtQixtQkFBQXpCLENBQVEsR0FBUixDQU5mO0FBT0owQiwwQkFBaUIsbUJBQUExQixDQUFRLEdBQVIsRUFBb0NDLE9BUGpEO0FBUUowQixvQkFBVyxtQkFBQTNCLENBQVEsR0FBUixDQVJQO0FBU0o0Qix1QkFBYyxtQkFBQTVCLENBQVEsR0FBUixFQUFpQ0MsT0FUM0M7QUFVSjRCLDJCQUFrQixtQkFBQTdCLENBQVEsR0FBUixFQUFxQ0MsT0FWbkQ7QUFXSjZCLGtCQUFTLG1CQUFBOUIsQ0FBUSxHQUFSLENBWEw7QUFZSitCLHNCQUFhLG1CQUFBL0IsQ0FBUSxHQUFSO0FBWlQsTUFyQ0s7O0FBb0RiZ0MsV0FBTTtBQUNGQyx1QkFBYyxtQkFBQWpDLENBQVEsR0FBUixDQURaO0FBRUZrQyxtQkFBVSxtQkFBQWxDLENBQVEsRUFBUixDQUZSO0FBR0ZtQyxvQkFBVyxtQkFBQW5DLENBQVEsR0FBUixDQUhUO0FBSUZvQyxrQkFBUyxtQkFBQXBDLENBQVEsR0FBUixDQUpQO0FBS0ZxQyxvQkFBVyxtQkFBQXJDLENBQVEsR0FBUjtBQUxULE1BcERPOztBQTREYnNDLFlBQU8sbUJBQUF0QyxDQUFRLEVBQVIsRUFBeUJDLE9BNURuQjs7QUE4RGJzQyxhQUFRO0FBQ0pDLGtCQUFTLG1CQUFBeEMsQ0FBUSxHQUFSLEVBQTRCQyxPQURqQztBQUVKd0Msa0JBQVMsbUJBQUF6QyxDQUFRLEdBQVIsRUFBNEJDLE9BRmpDO0FBR0p5QyxrQkFBUyxtQkFBQTFDLENBQVEsR0FBUixFQUE0QkM7QUFIakM7QUE5REssRUFBakIsQzs7Ozs7O0FDREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzZ0RBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxnQzs7Ozs7O0FDSHZDO0FBQ0E7QUFDQSxrQ0FBaUMsUUFBUSxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3RFLEVBQUMsRTs7Ozs7O0FDSEQsd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxHOzs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLFVBQVU7QUFDYjtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDTEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEc7Ozs7OztBQzFCRCw4QkFBNkI7QUFDN0Isc0NBQXFDLGdDOzs7Ozs7QUNEckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLEc7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCOzs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7Ozs7Ozs7QUFPQTtLQUNxQmUsSztBQUNqQixzQkFBYztBQUFBOztBQUNWLGNBQUsyQixJQUFMLEdBQVksS0FBS0MsS0FBTCxHQUFhLElBQXpCO0FBQ0EsY0FBS0MsSUFBTCxHQUFZLENBQVo7QUFDSDs7cUJBQ0RDLE8sc0JBQVM7QUFDTCxnQkFBTyxLQUFLSCxJQUFMLEtBQWMsSUFBckI7QUFDSCxNOztxQkFDREksSyxvQkFBUztBQUNMLGNBQUtKLElBQUwsR0FBWSxLQUFLQyxLQUFMLEdBQWEsSUFBekI7QUFDQSxjQUFLQyxJQUFMLEdBQVksQ0FBWjtBQUNILE07O3FCQUNERyxPLHNCQUFXO0FBQ1AsZ0JBQU8sS0FBS0osS0FBTCxHQUFhLEtBQUtBLEtBQUwsQ0FBV0ssSUFBeEIsR0FBK0IsSUFBdEM7QUFDSCxNOztxQkFDREMsTyxvQkFBU0MsSSxFQUFNO0FBQ1gsYUFBSSxLQUFLUCxLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDckIsa0JBQUtELElBQUwsR0FBWSxLQUFLQyxLQUFMLEdBQWEsRUFBQ0ssTUFBTUUsSUFBUCxFQUFhQyxNQUFNLElBQW5CLEVBQXpCO0FBQ0gsVUFGRCxNQUVPO0FBQ0gsaUJBQUlDLElBQUksRUFBQ0osTUFBTUUsSUFBUCxFQUFhQyxNQUFNLElBQW5CLEVBQVI7QUFDQSxrQkFBS1QsSUFBTCxDQUFVUyxJQUFWLEdBQWlCQyxDQUFqQjtBQUNBLGtCQUFLVixJQUFMLEdBQVlVLENBQVo7QUFDSDtBQUNELGNBQUtSLElBQUw7QUFDSCxNOztxQkFDRFMsTyxzQkFBVztBQUNQLGFBQUksS0FBS1YsS0FBVCxFQUFnQjtBQUNaLGlCQUFJTyxPQUFPLEtBQUtQLEtBQUwsQ0FBV0ssSUFBdEI7QUFDQSxrQkFBS0wsS0FBTCxHQUFhLEtBQUtBLEtBQUwsQ0FBV1EsSUFBeEI7QUFDQSxpQkFBSSxLQUFLUixLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDckIsc0JBQUtELElBQUwsR0FBWSxJQUFaO0FBQ0g7QUFDRCxrQkFBS0UsSUFBTDtBQUNBLG9CQUFPTSxJQUFQO0FBQ0gsVUFSRCxNQVFPO0FBQ0gsb0JBQU8sSUFBUDtBQUNIO0FBQ0osTTs7cUJBQ0RJLGEsMEJBQWVDLFEsRUFBVTtBQUNyQixhQUFJQyxVQUFVLEtBQUtiLEtBQW5CO0FBQ0EsZ0JBQU9hLE9BQVAsRUFBZ0I7QUFDWixpQkFBSUQsU0FBU0MsUUFBUVIsSUFBakIsQ0FBSixFQUE0QjtBQUM1QlEsdUJBQVVBLFFBQVFMLElBQWxCO0FBQ0g7QUFDSixNOztxQkFDRE0sTSxxQkFBbUI7QUFBQSxhQUFYQyxLQUFXLHlEQUFILENBQUc7O0FBQ2YsYUFBSUEsUUFBUSxLQUFLZCxJQUFqQixFQUF1QjtBQUNuQixpQkFBSVksVUFBVSxLQUFLYixLQUFuQjtBQUNBLGtCQUFLLElBQUlnQixJQUFJLENBQWIsRUFBZ0JBLElBQUlELEtBQXBCLEVBQTJCQyxHQUEzQixFQUFnQztBQUM1QkgsMkJBQVVBLFFBQVFMLElBQWxCO0FBQ0g7QUFDRCxvQkFBT0ssUUFBUVIsSUFBZjtBQUNIOztBQUVELGdCQUFPLElBQVA7QUFDSCxNOztxQkFDRFksUSx1QkFBWTtBQUNSLGFBQUksS0FBS2pCLEtBQUwsS0FBZSxJQUFuQixFQUF5QjtBQUNyQixvQkFBTyxJQUFQO0FBQ0g7O0FBRUQsYUFBSWtCLE1BQU0sRUFBVjtBQUNBLGFBQUlMLFVBQVUsS0FBS2IsS0FBbkI7O0FBRUEsY0FBSyxJQUFJZ0IsSUFBSSxDQUFSLEVBQVdHLE1BQU0sS0FBS2xCLElBQTNCLEVBQWlDZSxJQUFJRyxHQUFyQyxFQUEwQ0gsR0FBMUMsRUFBK0M7QUFDM0NFLGlCQUFJRixDQUFKLElBQVNILFFBQVFSLElBQWpCO0FBQ0FRLHVCQUFVQSxRQUFRTCxJQUFsQjtBQUNIOztBQUVELGdCQUFPVSxHQUFQO0FBQ0gsTTs7Ozs7bUJBdEVnQjlDLEs7OztBQXlFckIsS0FBSWdELFFBQVEsSUFBSWhELEtBQUosRUFBWjtBQUNBZ0QsT0FBTWQsT0FBTixDQUFjLENBQWQ7QUFDQWMsT0FBTVYsT0FBTjtBQUNBVSxPQUFNZCxPQUFOLENBQWMsQ0FBZDtBQUNBYyxPQUFNZCxPQUFOLENBQWMsQ0FBZDtBQUNBZSxTQUFRQyxHQUFSLENBQVlGLE1BQU1OLE1BQU4sQ0FBYSxDQUFiLENBQVo7QUFDQU8sU0FBUUMsR0FBUixDQUFZRixNQUFNTixNQUFOLENBQWEsQ0FBYixDQUFaO0FBQ0FPLFNBQVFDLEdBQVIsQ0FBWUYsTUFBTU4sTUFBTixDQUFhLENBQWIsQ0FBWjtBQUNBTyxTQUFRQyxHQUFSLENBQVlGLE1BQU1OLE1BQU4sQ0FBYSxDQUFiLENBQVo7QUFDQU8sU0FBUUMsR0FBUixDQUFZRixNQUFNSCxRQUFOLEdBQWlCTSxJQUFqQixFQUFaOztBQUlBO0FBQ0EsVUFBU0MsWUFBVCxDQUFzQkMsTUFBdEIsRUFBOEJULENBQTlCLEVBQWlDVSxDQUFqQyxFQUFvQ0MsS0FBcEMsRUFBMEM7QUFDdEMsU0FBSUMsTUFBTUgsT0FBT1QsQ0FBUCxFQUFVVSxDQUFWLENBQVY7QUFDQSxTQUFJTixRQUFRLElBQUloRCxLQUFKLEVBQVo7QUFDQSxTQUFJeUQsSUFBSUosT0FBT0ssTUFBUCxHQUFnQixDQUF4QjtBQUNBLFNBQUlDLElBQUlOLE9BQU8sQ0FBUCxFQUFVSyxNQUFWLEdBQW1CLENBQTNCOztBQUVBVixXQUFNZCxPQUFOLENBQWMsRUFBQzBCLEdBQUdoQixDQUFKLEVBQU9pQixHQUFHUCxDQUFWLEVBQWQ7O0FBRUEsWUFBTU4sTUFBTXJCLElBQVosRUFBaUI7QUFDYixhQUFJbUMsSUFBSWQsTUFBTVYsT0FBTixFQUFSO0FBQ0EsYUFBSXNCLElBQUlFLEVBQUVGLENBQVY7QUFDQSxhQUFJQyxJQUFJQyxFQUFFRCxDQUFWOztBQUVBLGFBQUdELEtBQUssQ0FBUixFQUFXRyxTQUFTSCxJQUFJLENBQWIsRUFBZ0JDLENBQWhCO0FBQ1gsYUFBR0EsS0FBSyxDQUFSLEVBQVdFLFNBQVNILENBQVQsRUFBWUMsSUFBSSxDQUFoQjtBQUNYLGFBQUdELElBQUlILENBQVAsRUFBVU0sU0FBU0gsSUFBSSxDQUFiLEVBQWdCQyxDQUFoQjtBQUNWLGFBQUdBLElBQUlGLENBQVAsRUFBVUksU0FBU0gsQ0FBVCxFQUFZQyxJQUFJLENBQWhCO0FBQ2I7O0FBRUQsY0FBU0UsUUFBVCxDQUFrQkgsQ0FBbEIsRUFBcUJDLENBQXJCLEVBQXVCO0FBQ25CLGFBQUdSLE9BQU9PLENBQVAsRUFBVUMsQ0FBVixNQUFpQkwsR0FBcEIsRUFBeUI7QUFDckJILG9CQUFPTyxDQUFQLEVBQVVDLENBQVYsSUFBZU4sS0FBZjtBQUNBUCxtQkFBTWQsT0FBTixDQUFjLEVBQUMwQixHQUFHQSxDQUFKLEVBQU9DLEdBQUdBLENBQVYsRUFBZDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxLQUFJUixTQUFTLEVBQWI7O0FBRUEsTUFBSSxJQUFJVCxJQUFJLENBQVosRUFBZUEsSUFBSSxDQUFuQixFQUFzQkEsR0FBdEIsRUFBMEI7QUFDdEJTLFlBQU9ULENBQVAsSUFBWSxFQUFaO0FBQ0EsVUFBSSxJQUFJVSxJQUFJLENBQVosRUFBZUEsSUFBSSxDQUFuQixFQUFzQkEsR0FBdEIsRUFBMEI7QUFDdEJELGdCQUFPVCxDQUFQLEVBQVVVLENBQVYsSUFBZSxDQUFmO0FBQ0g7QUFDSjs7QUFFREYsY0FBYUMsTUFBYixFQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixDQUEzQjtBQUNBSixTQUFRQyxHQUFSLENBQVlHLE1BQVosRTs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFtRTtBQUNuRTtBQUNBLHNGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxlQUFjO0FBQ2QsZUFBYztBQUNkLGVBQWM7QUFDZCxnQkFBZTtBQUNmLGdCQUFlO0FBQ2YsZ0JBQWU7QUFDZixpQkFBZ0I7QUFDaEIsMEI7Ozs7OztBQzVEQTtBQUNBO0FBQ0EsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3FGQTs7OztBQUNBOzs7Ozs7QUF4RkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNDLGNBQVk7QUFDVDtBQUNBLFNBQUlXLE9BQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixHQUFrQixDQUFsQixJQUF5QixDQUF6QixDQUFYOztBQUVBZixhQUFRQyxHQUFSLENBQVksV0FBWjtBQUNBLFVBQUssU0FBU2UsaUJBQVQsQ0FBMkJMLENBQTNCLEVBQThCTSxLQUE5QixFQUFxQztBQUN0Q0EsZUFBTUYsS0FBS0osQ0FBTCxDQUFOO0FBQ0EsYUFBSUksS0FBSyxJQUFJSixDQUFKLEdBQVEsQ0FBYixDQUFKLEVBQXFCSyxrQkFBa0IsSUFBSUwsQ0FBSixHQUFRLENBQTFCLEVBQTZCTSxLQUE3QjtBQUNyQixhQUFJRixLQUFLLElBQUlKLENBQUosR0FBUSxDQUFiLENBQUosRUFBcUJLLGtCQUFrQixJQUFJTCxDQUFKLEdBQVEsQ0FBMUIsRUFBNkJNLEtBQTdCO0FBQ3hCLE1BSkksQ0FJSCxDQUpHLEVBSUEsVUFBQ0MsS0FBRCxFQUFXO0FBQ1psQixpQkFBUUMsR0FBUixDQUFZaUIsS0FBWjtBQUNILE1BTkksQ0FBTDs7QUFRQWxCLGFBQVFDLEdBQVIsQ0FBWSxVQUFaO0FBQ0EsVUFBSyxTQUFTa0IsZ0JBQVQsQ0FBMEJSLENBQTFCLEVBQTZCTSxLQUE3QixFQUFvQztBQUNyQyxhQUFJRixLQUFLLElBQUlKLENBQUosR0FBUSxDQUFiLENBQUosRUFBcUJRLGlCQUFpQixJQUFJUixDQUFKLEdBQVEsQ0FBekIsRUFBNEJNLEtBQTVCO0FBQ3JCQSxlQUFNRixLQUFLSixDQUFMLENBQU47QUFDQSxhQUFJSSxLQUFLLElBQUlKLENBQUosR0FBUSxDQUFiLENBQUosRUFBcUJRLGlCQUFpQixJQUFJUixDQUFKLEdBQVEsQ0FBekIsRUFBNEJNLEtBQTVCO0FBQ3hCLE1BSkksQ0FJSCxDQUpHLEVBSUEsVUFBQ0MsS0FBRCxFQUFXO0FBQ1psQixpQkFBUUMsR0FBUixDQUFZaUIsS0FBWjtBQUNILE1BTkksQ0FBTDs7QUFRQWxCLGFBQVFDLEdBQVIsQ0FBWSxZQUFaO0FBQ0EsVUFBSyxTQUFTbUIsa0JBQVQsQ0FBNEJULENBQTVCLEVBQStCTSxLQUEvQixFQUFzQztBQUN2QyxhQUFJRixLQUFLLElBQUlKLENBQUosR0FBUSxDQUFiLENBQUosRUFBcUJTLG1CQUFtQixJQUFJVCxDQUFKLEdBQVEsQ0FBM0IsRUFBOEJNLEtBQTlCO0FBQ3JCLGFBQUlGLEtBQUssSUFBSUosQ0FBSixHQUFRLENBQWIsQ0FBSixFQUFxQlMsbUJBQW1CLElBQUlULENBQUosR0FBUSxDQUEzQixFQUE4Qk0sS0FBOUI7QUFDckJBLGVBQU1GLEtBQUtKLENBQUwsQ0FBTjtBQUNILE1BSkksQ0FJSCxDQUpHLEVBSUEsVUFBQ08sS0FBRCxFQUFXO0FBQ1psQixpQkFBUUMsR0FBUixDQUFZaUIsS0FBWjtBQUNILE1BTkksQ0FBTDtBQU9ILEVBOUJBLEdBQUQ7O0FBbUNBO0tBQ2FoRixVLFdBQUFBLFU7QUFDVCwyQkFBOEQ7QUFBQSxhQUFsRDhDLElBQWtELHlEQUEzQyxJQUEyQztBQUFBLGFBQXJDcUMsU0FBcUMseURBQXpCLElBQXlCO0FBQUEsYUFBbkJDLFVBQW1CLHlEQUFOLElBQU07QUFBQTs7QUFDMUQsY0FBS3RDLElBQUwsR0FBWUEsSUFBWjtBQUNBO0FBQ0EsY0FBS3FDLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsY0FBS0MsVUFBTCxHQUFrQkEsVUFBbEI7QUFDSDs7QUFFRDs7OzBCQUNBQyxTLHNCQUFVUixJLEVBQU07QUFDWixnQkFBTyxDQUFDLEVBQUVBLFNBQ1IsS0FBS00sU0FBTCxJQUFrQixLQUFLQSxTQUFMLENBQWVFLFNBQWYsQ0FBeUJSLEtBQUtNLFNBQTlCLENBQW5CLElBQWlFLENBQUMsS0FBS0EsU0FBTixJQUFtQixDQUFDTixLQUFLTSxTQURqRixNQUVSLEtBQUtDLFVBQUwsSUFBbUIsS0FBS0EsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEJSLEtBQUtPLFVBQS9CLENBQXBCLElBQW9FLENBQUMsS0FBS0EsVUFBTixJQUFvQixDQUFDUCxLQUFLTyxVQUZyRixDQUFGLENBQVI7QUFHSCxNOzswQkFFREUsZ0IsNkJBQWlCVCxJLEVBQU07QUFDbkIsY0FBSyxTQUFTQyxpQkFBVCxDQUEyQlMsSUFBM0IsRUFBaUNkLENBQWpDLEVBQW9DTSxLQUFwQyxFQUEyQztBQUM1Q0EsbUJBQU1RLElBQU4sRUFBWVYsS0FBS0osQ0FBTCxDQUFaOztBQUVBLGlCQUFJdkIsVUFBSjtBQUNBLGlCQUFJMkIsS0FBSyxJQUFJSixDQUFKLEdBQVEsQ0FBYixDQUFKLEVBQXFCO0FBQ2pCdkIscUJBQUlxQyxLQUFLSixTQUFMLEdBQWlCLElBQUluRixVQUFKLEVBQXJCO0FBQ0E4RSxtQ0FBa0I1QixDQUFsQixFQUFxQixJQUFJdUIsQ0FBSixHQUFRLENBQTdCLEVBQWdDTSxLQUFoQztBQUNIO0FBQ0QsaUJBQUlGLEtBQUssSUFBSUosQ0FBSixHQUFRLENBQWIsQ0FBSixFQUFxQjtBQUNqQnZCLHFCQUFJcUMsS0FBS0gsVUFBTCxHQUFrQixJQUFJcEYsVUFBSixFQUF0QjtBQUNBOEUsbUNBQWtCNUIsQ0FBbEIsRUFBcUIsSUFBSXVCLENBQUosR0FBUSxDQUE3QixFQUFnQ00sS0FBaEM7QUFDSDs7QUFFRCxpQkFBSTdCLENBQUosRUFBT0EsRUFBRXNDLFVBQUYsR0FBZUQsSUFBZjtBQUNWLFVBZEksQ0FjSCxJQWRHLEVBY0csQ0FkSCxFQWNNLFVBQUNBLElBQUQsRUFBT1AsS0FBUCxFQUFpQjtBQUN4Qk8sa0JBQUt6QyxJQUFMLEdBQVlrQyxLQUFaO0FBQ0gsVUFoQkksQ0FBTDtBQWlCSCxNOztBQUVEOzs7MEJBQ0dTLE9BQU9wQyxROzs7Ozs7Z0NBQ0EsS0FBS1AsSTs7OzhCQUNSLEtBQUtxQyxTOzs7Ozt1REFBa0IsS0FBS0EsUzs7OzhCQUM1QixLQUFLQyxVOzs7Ozt1REFBbUIsS0FBS0EsVTs7Ozs7Ozs7OztBQUdwQzs7MEJBQ0FNLG9CLGlDQUFxQlgsSyxFQUFPO0FBQ3hCLGFBQUlZLFFBQVEscUJBQVo7QUFDQSxhQUFJekMsSUFBSSxJQUFSOztBQUVBLGdCQUFPQSxLQUFLeUMsTUFBTXBCLE1BQWxCLEVBQTBCO0FBQ3RCO0FBQ0EsaUJBQUlyQixDQUFKLEVBQU87QUFDSHlDLHVCQUFNQyxJQUFOLENBQVcxQyxDQUFYO0FBQ0FBLG1CQUFFSixJQUFGLElBQVVpQyxNQUFNN0IsRUFBRUosSUFBUixDQUFWO0FBQ0FJLHFCQUFJQSxFQUFFaUMsU0FBTjtBQUNILGNBSkQsTUFJTztBQUNIakMscUJBQUl5QyxNQUFNRSxHQUFOLEVBQUo7QUFDQTNDLHFCQUFJQSxFQUFFa0MsVUFBTjtBQUNIO0FBQ0o7QUFDSixNOztBQUVEOzs7MEJBQ0FVLG1CLGdDQUFvQmYsSyxFQUFPO0FBQ3ZCLGFBQUlZLFFBQVEscUJBQVo7QUFDQSxhQUFJekMsSUFBSSxJQUFSOztBQUVBLGdCQUFPQSxLQUFLeUMsTUFBTXBCLE1BQWxCLEVBQTBCO0FBQ3RCLGlCQUFJckIsQ0FBSixFQUFPO0FBQ0h5Qyx1QkFBTUMsSUFBTixDQUFXMUMsQ0FBWDtBQUNBQSxxQkFBSUEsRUFBRWlDLFNBQU47QUFDSCxjQUhELE1BR087QUFDSGpDLHFCQUFJeUMsTUFBTUUsR0FBTixFQUFKO0FBQ0EzQyxtQkFBRUosSUFBRixJQUFVaUMsTUFBTTdCLEVBQUVKLElBQVIsQ0FBVjtBQUNBSSxxQkFBSUEsRUFBRWtDLFVBQU47QUFDSDtBQUNKO0FBQ0osTTs7QUFFRDtBQUNBO0FBQ0E7OzswQkFDQVcscUIsa0NBQXNCaEIsSyxFQUFPO0FBQ3pCLGFBQUlZLFFBQVEscUJBQVo7QUFDQUEsZUFBTUMsSUFBTixDQUFXLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBWDs7QUFFQSxnQkFBT0QsTUFBTXBCLE1BQWIsRUFBcUI7QUFDakIsaUJBQUlJLElBQUlnQixNQUFNRSxHQUFOLEVBQVI7QUFDQSxpQkFBSU4sT0FBT1osRUFBRSxDQUFGLENBQVg7O0FBRUEscUJBQVFBLEVBQUUsQ0FBRixDQUFSO0FBQ0ksc0JBQUssQ0FBTDtBQUNJZ0IsMkJBQU1DLElBQU4sQ0FBVyxDQUFDTCxJQUFELEVBQU8sQ0FBUCxDQUFYLEVBREosQ0FDNEI7QUFDeEIseUJBQUlBLEtBQUtKLFNBQVQsRUFBb0JRLE1BQU1DLElBQU4sQ0FBVyxDQUFDTCxLQUFLSixTQUFOLEVBQWlCLENBQWpCLENBQVgsRUFGeEIsQ0FFMEQ7QUFDdEQ7QUFDSixzQkFBSyxDQUFMO0FBQ0lRLDJCQUFNQyxJQUFOLENBQVcsQ0FBQ0wsSUFBRCxFQUFPLENBQVAsQ0FBWDtBQUNBLHlCQUFJQSxLQUFLSCxVQUFULEVBQXFCTyxNQUFNQyxJQUFOLENBQVcsQ0FBQ0wsS0FBS0gsVUFBTixFQUFrQixDQUFsQixDQUFYO0FBQ3JCO0FBQ0osc0JBQUssQ0FBTDtBQUNJRywwQkFBS3pDLElBQUwsSUFBYWlDLE1BQU1RLEtBQUt6QyxJQUFYLENBQWI7QUFDQTtBQUNKO0FBQ0k7QUFiUjtBQWVIO0FBQ0osTTs7MEJBRURnQyxpQiw4QkFBa0JDLEssRUFBTztBQUNyQkEsZUFBTSxLQUFLakMsSUFBWDtBQUNBLGFBQUksS0FBS3FDLFNBQVQsRUFBb0IsS0FBS0EsU0FBTCxDQUFlTCxpQkFBZixDQUFpQ0MsS0FBakM7QUFDcEIsYUFBSSxLQUFLSyxVQUFULEVBQXFCLEtBQUtBLFVBQUwsQ0FBZ0JOLGlCQUFoQixDQUFrQ0MsS0FBbEM7QUFDeEIsTTs7MEJBRURFLGdCLDZCQUFpQkYsSyxFQUFPO0FBQ3BCLGFBQUksS0FBS0ksU0FBVCxFQUFvQixLQUFLQSxTQUFMLENBQWVGLGdCQUFmLENBQWdDRixLQUFoQztBQUNwQkEsZUFBTSxLQUFLakMsSUFBWDtBQUNBLGFBQUksS0FBS3NDLFVBQVQsRUFBcUIsS0FBS0EsVUFBTCxDQUFnQkgsZ0JBQWhCLENBQWlDRixLQUFqQztBQUN4QixNOzswQkFFREcsa0IsK0JBQW1CSCxLLEVBQU87QUFDdEIsYUFBSSxLQUFLSSxTQUFULEVBQW9CLEtBQUtBLFNBQUwsQ0FBZUQsa0JBQWYsQ0FBa0NILEtBQWxDO0FBQ3BCLGFBQUksS0FBS0ssVUFBVCxFQUFxQixLQUFLQSxVQUFMLENBQWdCRixrQkFBaEIsQ0FBbUNILEtBQW5DO0FBQ3JCQSxlQUFNLEtBQUtqQyxJQUFYO0FBQ0gsTTs7MEJBRURrRCxrQiwrQkFBbUJqQixLLEVBQU87QUFDdEIsYUFBSWxCLFFBQVEscUJBQVo7QUFDQUEsZUFBTWQsT0FBTixDQUFjLElBQWQ7O0FBRUEsZ0JBQU9jLE1BQU1yQixJQUFiLEVBQW1CO0FBQ2YsaUJBQUlVLElBQUlXLE1BQU1WLE9BQU4sRUFBUjtBQUNBRCxlQUFFSixJQUFGLElBQVVpQyxNQUFNN0IsRUFBRUosSUFBUixDQUFWO0FBQ0FJLGVBQUVpQyxTQUFGLElBQWV0QixNQUFNZCxPQUFOLENBQWNHLEVBQUVpQyxTQUFoQixDQUFmO0FBQ0FqQyxlQUFFa0MsVUFBRixJQUFnQnZCLE1BQU1kLE9BQU4sQ0FBY0csRUFBRWtDLFVBQWhCLENBQWhCO0FBQ0g7QUFDSixNOztBQUVEOzs7MEJBQ0FhLGMsMkJBQWVDLEMsRUFBRztBQUNkLGFBQUlDLFFBQVEsQ0FBWjtBQUNBLGFBQUlyRCxPQUFPLElBQVg7O0FBRUEsY0FBSyxTQUFTc0QsT0FBVCxDQUFpQmIsSUFBakIsRUFBdUI7QUFDeEIsaUJBQUlBLElBQUosRUFBVTtBQUNOLHFCQUFJLEVBQUVZLEtBQUYsS0FBWUQsQ0FBaEIsRUFDSXBELE9BQVF5QyxLQUFLekMsSUFBYixDQURKLEtBRUs7QUFDRHNELDZCQUFRYixLQUFLSixTQUFiO0FBQ0FpQiw2QkFBUWIsS0FBS0gsVUFBYjtBQUNIO0FBQ0o7QUFDSixVQVRJLENBU0gsSUFURyxDQUFMOztBQVdBLGdCQUFPdEMsSUFBUDtBQUNILE07O0FBRUQ7OzswQkFDQXVELFcsMEJBQWM7QUFDVixnQkFBTyxTQUFTRCxPQUFULENBQWlCYixJQUFqQixFQUF1QjtBQUMxQixpQkFBSSxDQUFDQSxJQUFMLEVBQVcsT0FBTyxDQUFQLENBQVgsS0FDSyxJQUFJLENBQUNBLEtBQUtKLFNBQU4sSUFBbUIsQ0FBQ0ksS0FBS0gsVUFBN0IsRUFBeUMsT0FBTyxDQUFQLENBQXpDLEtBQ0EsT0FBT2dCLFFBQVFiLEtBQUtKLFNBQWIsSUFBMEJpQixRQUFRYixLQUFLSCxVQUFiLENBQWpDO0FBQ1IsVUFKTSxDQUlMLElBSkssQ0FBUDtBQUtILE07O0FBRUQ7OzswQkFDQWtCLGtCLGlDQUFxQjtBQUFBLG9CQUNtQixDQUFDLEtBQUtsQixVQUFOLEVBQWtCLEtBQUtELFNBQXZCLENBRG5CO0FBQ2hCLGNBQUtBLFNBRFc7QUFDQSxjQUFLQyxVQURMOzs7QUFHakIsYUFBSSxLQUFLRCxTQUFULEVBQW9CLEtBQUtBLFNBQUwsQ0FBZW1CLGtCQUFmO0FBQ3BCLGFBQUksS0FBS2xCLFVBQVQsRUFBcUIsS0FBS0EsVUFBTCxDQUFnQmtCLGtCQUFoQjtBQUN4QixNOzswQkFFREMsb0IsbUNBQXNCO0FBQ2xCLGFBQUlaLFFBQVEsRUFBWjtBQUNBQSxlQUFNQyxJQUFOLENBQVcsSUFBWDs7QUFFQSxnQkFBTUQsTUFBTXBCLE1BQVosRUFBbUI7QUFDZixpQkFBSWdCLE9BQU9JLE1BQU1FLEdBQU4sRUFBWDtBQURlLHlCQUVxQixDQUFDTixLQUFLSCxVQUFOLEVBQWtCRyxLQUFLSixTQUF2QixDQUZyQjtBQUVkSSxrQkFBS0osU0FGUztBQUVFSSxrQkFBS0gsVUFGUDs7O0FBSWYsaUJBQUdHLEtBQUtKLFNBQVIsRUFBbUJRLE1BQU1DLElBQU4sQ0FBV0wsS0FBS0osU0FBaEI7QUFDbkIsaUJBQUdJLEtBQUtILFVBQVIsRUFBb0JPLE1BQU1DLElBQU4sQ0FBV0wsS0FBS0gsVUFBaEI7QUFDdkI7QUFDSixNOztBQUVEOzs7MEJBQ0FvQixXLHdCQUFZL0IsQyxFQUFHO0FBQ1gsYUFBSTBCLFFBQVEsQ0FBWjtBQUNBLGFBQUlSLFFBQVEscUJBQVo7QUFDQUEsZUFBTUMsSUFBTixDQUFXLElBQVg7O0FBRUEsZ0JBQU1ELE1BQU1wQixNQUFaLEVBQW1CO0FBQ2YsaUJBQUlnQixPQUFPSSxNQUFNRSxHQUFOLEVBQVg7O0FBRUEsaUJBQUdOLEtBQUt6QyxJQUFMLEtBQWMyQixDQUFqQixFQUFvQjtBQUNoQjBCLHlCQUFRWixLQUFLa0IsUUFBTCxFQUFSO0FBQ0E7QUFDSCxjQUhELE1BR087QUFDSCxxQkFBR2xCLEtBQUtKLFNBQVIsRUFBbUJRLE1BQU1DLElBQU4sQ0FBV0wsS0FBS0osU0FBaEI7QUFDbkIscUJBQUdJLEtBQUtILFVBQVIsRUFBb0JPLE1BQU1DLElBQU4sQ0FBV0wsS0FBS0gsVUFBaEI7QUFDdkI7QUFDSjs7QUFFRCxnQkFBT2UsS0FBUDtBQUNILE07OzBCQUVETSxRLHVCQUFXO0FBQ1AsYUFBSW5DLElBQUksS0FBS2EsU0FBTCxJQUFrQixLQUFLQSxTQUFMLENBQWVzQixRQUFmLEVBQWxCLElBQStDLENBQXZEO0FBQ0EsYUFBSWpDLElBQUksS0FBS1ksVUFBTCxJQUFtQixLQUFLQSxVQUFMLENBQWdCcUIsUUFBaEIsRUFBbkIsSUFBaUQsQ0FBekQ7QUFDQSxnQkFBTyxDQUFDbkMsSUFBSUUsQ0FBSixHQUFRRixDQUFSLEdBQVlFLENBQWIsSUFBa0IsQ0FBekI7QUFDSCxNOztBQUVEOzs7MEJBQ0FrQyxPLG9CQUFRakMsQyxFQUFHO0FBQ1AsYUFBSSxLQUFLM0IsSUFBTCxLQUFjMkIsQ0FBbEIsRUFBcUI7QUFDakIsa0JBQUtVLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxrQkFBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUNILFVBSEQsTUFHTztBQUNILGlCQUFJLEtBQUtELFNBQVQsRUFBb0IsS0FBS0EsU0FBTCxDQUFldUIsT0FBZixDQUF1QmpDLENBQXZCO0FBQ3BCLGlCQUFJLEtBQUtXLFVBQVQsRUFBcUIsS0FBS0EsVUFBTCxDQUFnQnNCLE9BQWhCLENBQXdCakMsQ0FBeEI7QUFDeEI7QUFDSixNOztBQUVEOzs7Ozs7OzBCQUtBa0MsSSxtQkFBd0I7QUFBQSxhQUFuQkMsRUFBbUIseURBQWQsWUFBVSxDQUFFLENBQUU7O0FBQ3BCO0FBQ0EsYUFBSUMsU0FBUyxxQkFBYjtBQUNBO0FBQ0EsYUFBSUMsU0FBUyxxQkFBYjtBQUNBRCxnQkFBT2pCLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSW1CLE9BQU8sS0FBS0MsV0FBaEI7QUFDQSxhQUFJQyxVQUFVLElBQUlGLElBQUosRUFBZDtBQUNBLGFBQUlHLElBQUlELE9BQVI7QUFDQUgsZ0JBQU9sQixJQUFQLENBQVlxQixPQUFaO0FBQ0EsYUFBSS9ELFVBQUo7O0FBRUEsZ0JBQU8yRCxPQUFPdEMsTUFBZCxFQUFzQjtBQUNsQjtBQUNBLG9CQUFRckIsSUFBSTJELE9BQU9NLElBQVAsRUFBWixFQUE0QjtBQUN4QixxQkFBSWpFLEVBQUVpQyxTQUFOLEVBQWlCK0IsRUFBRS9CLFNBQUYsR0FBYyxJQUFJNEIsSUFBSixFQUFkO0FBQ2pCRyxxQkFBSUEsRUFBRS9CLFNBQU47QUFDQTBCLHdCQUFPakIsSUFBUCxDQUFZMUMsRUFBRWlDLFNBQWQ7QUFDQTJCLHdCQUFPbEIsSUFBUCxDQUFZc0IsQ0FBWjtBQUNIOztBQUVEaEUsaUJBQUkyRCxPQUFPaEIsR0FBUCxFQUFKO0FBQ0FxQixpQkFBSUosT0FBT2pCLEdBQVAsRUFBSjs7QUFFQSxpQkFBSWdCLE9BQU90QyxNQUFYLEVBQW1CO0FBQ2ZyQixxQkFBSTJELE9BQU9oQixHQUFQLEVBQUo7QUFDQXFCLHFCQUFJSixPQUFPakIsR0FBUCxFQUFKO0FBQ0EscUJBQUkzQyxFQUFFa0MsVUFBTixFQUFrQjhCLEVBQUU5QixVQUFGLEdBQWUsSUFBSTJCLElBQUosRUFBZjtBQUNsQkcsbUJBQUVwRSxJQUFGLEdBQVNJLEVBQUVKLElBQVg7QUFDQThELG9CQUFHTSxDQUFILEVBQU1oRSxDQUFOO0FBQ0FnRSxxQkFBSUEsRUFBRTlCLFVBQU47QUFDQXlCLHdCQUFPakIsSUFBUCxDQUFZMUMsRUFBRWtDLFVBQWQsRUFQZSxDQU9hO0FBQzVCMEIsd0JBQU9sQixJQUFQLENBQVlzQixDQUFaO0FBQ0g7QUFDSjs7QUFFRCxnQkFBT0QsT0FBUDtBQUNILE07O0FBRUQ7OzswQkFDQUcsZSw0QkFBZ0JDLEssRUFBT0MsSyxFQUFPO0FBQzFCLGFBQUlDLFFBQVFDLFNBQVMsSUFBVCxFQUFlSCxLQUFmLEVBQXNCLENBQXRCLENBQVo7QUFDQSxhQUFJSSxRQUFRRCxTQUFTLElBQVQsRUFBZUYsS0FBZixFQUFzQixDQUF0QixDQUFaOztBQUVBLGNBQUssSUFBSTdELElBQUksQ0FBYixFQUFnQjhELE1BQU05RCxDQUFOLEtBQVlnRSxNQUFNaEUsQ0FBTixDQUFaLElBQXdCOEQsTUFBTTlELENBQU4sQ0FBeEMsRUFBa0RBLEdBQWxEO0FBQ0EsZ0JBQU84RCxNQUFNLEVBQUU5RCxDQUFSLENBQVA7QUFDSCxNOztBQUVEOzs7MEJBQ0FDLFEsdUJBQVcsQ0FDVixDOztBQUVEOzs7MEJBQ0FnRSxVLHlCQUFhO0FBQ1QsYUFBSUMsV0FBVyxFQUFmO0FBQ0EsYUFBSTlELFFBQVEscUJBQVo7QUFDQUEsZUFBTWQsT0FBTixDQUFjO0FBQ1Z3QyxtQkFBTSxJQURJO0FBRVZxQyxvQkFBTztBQUZHLFVBQWQ7QUFJQTtBQUNBLGFBQUlDLFVBQUo7QUFDQSxnQkFBT2hFLE1BQU1yQixJQUFiLEVBQW1CO0FBQ2ZxRixpQkFBSWhFLE1BQU1WLE9BQU4sRUFBSjtBQUNBd0Usc0JBQVNFLEVBQUVELEtBQVgsSUFBb0IsQ0FBQ0QsU0FBU0UsRUFBRUQsS0FBWCxLQUFxQixDQUF0QixJQUEyQixDQUEvQzs7QUFFQSxpQkFBSUMsRUFBRXRDLElBQUYsQ0FBT0osU0FBWCxFQUNJdEIsTUFBTWQsT0FBTixDQUFjO0FBQ1Z3Qyx1QkFBTXNDLEVBQUV0QyxJQUFGLENBQU9KLFNBREg7QUFFVnlDLHdCQUFPQyxFQUFFRCxLQUFGLEdBQVU7QUFGUCxjQUFkO0FBSUosaUJBQUlDLEVBQUV0QyxJQUFGLENBQU9ILFVBQVgsRUFDSXZCLE1BQU1kLE9BQU4sQ0FBYztBQUNWd0MsdUJBQU1zQyxFQUFFdEMsSUFBRixDQUFPSCxVQURIO0FBRVZ3Qyx3QkFBT0MsRUFBRUQsS0FBRixHQUFVO0FBRlAsY0FBZDtBQUlQOztBQUVEO0FBQ0EsYUFBSUUsU0FBU0QsRUFBRUQsS0FBZjtBQUNBLGFBQUlHLE1BQU1KLFNBQVMsQ0FBVCxDQUFWO0FBQ0EsY0FBSyxJQUFJbEUsSUFBSSxDQUFiLEVBQWdCa0UsU0FBU2xFLENBQVQsQ0FBaEIsRUFBNkJBLEdBQTdCO0FBQ0k7QUFDQSxpQkFBSWtFLFNBQVNsRSxDQUFULElBQWNzRSxHQUFsQixFQUF1QkEsTUFBTUosU0FBU2xFLENBQVQsQ0FBTjtBQUYzQixVQUlBLE9BQU9xRSxTQUFTQyxHQUFoQjtBQUNILE07O0FBRUQ7OzswQkFDQUMsTyxzQkFBVTtBQUNOLGdCQUFPLFNBQVM1QixPQUFULENBQWlCYixJQUFqQixFQUF1QjtBQUMxQixpQkFBSTBDLFVBQUo7QUFDQSxpQkFBSSxDQUFDMUMsSUFBTCxFQUFXLE9BQU8sQ0FBQyxDQUFSLENBQVgsS0FDSzBDLElBQUk3QixRQUFRYixLQUFLSixTQUFiLElBQTBCaUIsUUFBUWIsS0FBS0gsVUFBYixDQUExQixHQUFxRCxDQUF6RDs7QUFFTEcsa0JBQUt5QyxPQUFMLEdBQWVDLENBQWY7O0FBRUEsb0JBQU9BLENBQVA7QUFDSCxVQVJNLENBUUwsSUFSSyxDQUFQO0FBU0gsTTs7QUFFRDs7O2dCQUNPQyxnQiw2QkFBaUJyRCxJLEVBQU07QUFDMUIsYUFBSWhCLFFBQVEscUJBQVo7QUFDQSxhQUFJc0UsT0FBTyxDQUFYO0FBQ0F0RSxlQUFNZCxPQUFOLENBQWM4QixJQUFkOztBQUVBLGdCQUFPaEIsTUFBTXJCLElBQWIsRUFBbUI7QUFDZixpQkFBSVUsSUFBSVcsTUFBTVYsT0FBTixFQUFSOztBQUVBLGlCQUFJLENBQUNELENBQUwsRUFBUWlGLE9BQU8sQ0FBUCxDQUFSLEtBQ0ssSUFBSUEsSUFBSixFQUFVLE9BQU8sS0FBUCxDQUFWLEtBQ0E7QUFDRHRFLHVCQUFNZCxPQUFOLENBQWNHLEVBQUVpQyxTQUFoQjtBQUNBdEIsdUJBQU1kLE9BQU4sQ0FBY0csRUFBRWtDLFVBQWhCO0FBQ0g7QUFDSjs7QUFFRCxnQkFBTyxJQUFQO0FBQ0gsTTs7Ozs7QUFHTDs7O0FBQ0EsVUFBU29DLFFBQVQsQ0FBa0IzQyxJQUFsQixFQUF3QlUsSUFBeEIsRUFBcUM7QUFBQSxTQUFQOUIsQ0FBTyx5REFBSCxDQUFHOztBQUNqQyxTQUFJMkUsT0FBTyxFQUFYO0FBQ0EsU0FBSUMsUUFBUSxLQUFaOztBQUVBLFVBQUssU0FBU2pDLE9BQVQsQ0FBaUJ2QixJQUFqQixFQUF1QnBCLENBQXZCLEVBQTBCO0FBQzNCLGFBQUlvQixRQUFRVSxJQUFaLEVBQWtCO0FBQ2Q4QyxxQkFBUSxJQUFSO0FBQ0E7QUFDSDs7QUFFREQsY0FBSzNFLENBQUwsSUFBVW9CLElBQVY7QUFDQSxhQUFJQSxLQUFLTSxTQUFULEVBQW9CaUIsUUFBUXZCLEtBQUtNLFNBQWIsRUFBd0IxQixJQUFJLENBQTVCO0FBQ3BCLGFBQUlvQixLQUFLTyxVQUFMLElBQW1CLENBQUNpRCxLQUF4QixFQUErQmpDLFFBQVF2QixLQUFLTyxVQUFiLEVBQXlCM0IsSUFBSSxDQUE3QjtBQUMvQixhQUFJLENBQUM0RSxLQUFMLEVBQVlELEtBQUszRSxDQUFMLElBQVUsSUFBVjtBQUNmLE1BVkksQ0FVSG9CLElBVkcsRUFVR3BCLENBVkgsQ0FBTDs7QUFZQSxZQUFPMkUsSUFBUDtBQUNIOztBQUVELEtBQUlFLFNBQVNDLFNBQVMsY0FBVCxHQUFiOztBQUVBO0FBQ0EsVUFBU0Msb0JBQVQsQ0FBOEIzRCxJQUE5QixFQUFtQztBQUMvQixTQUFJNEQsT0FBTzVELEtBQUs0QixRQUFMLEVBQVg7QUFDQSxTQUFJMkIsT0FBTyxFQUFYOztBQUVBLFNBQUlLLE9BQU8sQ0FBWCxFQUFjLE9BQU8sS0FBUDtBQUNkQyxZQUFPN0QsSUFBUCxFQUFhLENBQWI7O0FBRUEsY0FBUzZELE1BQVQsQ0FBZ0I3RCxJQUFoQixFQUFzQjhELENBQXRCLEVBQXlCO0FBQ3JCUCxjQUFLTyxDQUFMLElBQVU5RCxJQUFWOztBQUVBLGFBQUk4RCxLQUFLRixPQUFPLENBQWhCLEVBQW1CO0FBQ2YsaUJBQUlHLElBQUksR0FBUjtBQUNBLGtCQUFLLElBQUluRixJQUFJLENBQWIsRUFBZ0IyRSxLQUFLM0UsQ0FBTCxDQUFoQixFQUF5QkEsR0FBekI7QUFBOEJtRixzQkFBS1IsS0FBSzNFLENBQUwsRUFBUVgsSUFBUixJQUFnQnNGLEtBQUszRSxJQUFJLENBQVQsSUFBYyxNQUFkLEdBQXVCLEVBQXZDLENBQUw7QUFBOUIsY0FDQUssUUFBUUMsR0FBUixDQUFZNkUsQ0FBWjtBQUNBO0FBQ0gsVUFMRCxNQUtPO0FBQ0gsaUJBQUkvRCxLQUFLTSxTQUFULEVBQW9CdUQsT0FBTzdELEtBQUtNLFNBQVosRUFBdUJ3RCxJQUFJLENBQTNCO0FBQ3BCLGlCQUFJOUQsS0FBS08sVUFBVCxFQUFxQnNELE9BQU83RCxLQUFLTyxVQUFaLEVBQXdCdUQsSUFBSSxDQUE1QjtBQUN4Qjs7QUFFRFAsY0FBS08sQ0FBTCxJQUFVLElBQVY7QUFDSDtBQUNKOztBQUVELEtBQUk5RCxPQUFPLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsR0FBa0IsQ0FBbEIsSUFBeUIsQ0FBekIsQ0FBWDtBQUNBLEtBQUlnRSxPQUFPLElBQUk3SSxVQUFKLEVBQVg7QUFDQTZJLE1BQUt2RCxnQkFBTCxDQUFzQlQsSUFBdEI7O0FBRUFmLFNBQVFDLEdBQVIsQ0FBWSxZQUFaO0FBQ0Esc0JBQWE4RSxJQUFiLGtIQUFrQjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsU0FBVnBFLENBQVU7O0FBQ2RYLGFBQVFDLEdBQVIsQ0FBWVUsQ0FBWjtBQUNIOztBQUdEOzs7O0FBSUE7QUFDQTtBQUNBOztLQUNhcUUsVSxXQUFBQSxVO0FBQ1QsMkJBQWM7QUFBQTs7QUFDVixjQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUNIOzswQkFFRHRDLFEsdUJBQVc7QUFDUCxhQUFJdUMsV0FBVyxDQUFmOztBQUVBLGNBQUssSUFBSXZGLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLc0YsS0FBTCxDQUFXeEUsTUFBL0IsRUFBdUNkLEdBQXZDLEVBQTRDO0FBQ3hDLGlCQUFJd0YsTUFBTSxDQUFWO0FBQ0Esa0JBQUssSUFBSTlFLElBQUlWLENBQWIsRUFBZ0JVLEtBQUssQ0FBckIsRUFBd0JBLElBQUksS0FBSzRFLEtBQUwsQ0FBV3RGLENBQVgsRUFBY3lGLE1BQTFDO0FBQWtERDtBQUFsRCxjQUNBLElBQUlBLE1BQU1ELFFBQVYsRUFBb0JBLFdBQVdDLEdBQVg7QUFDdkI7O0FBRUQsZ0JBQU9ELFFBQVA7QUFDSCxNOzs7OztLQUdDRyxjLEdBQ0YsMEJBQXFDO0FBQUEsU0FBekJyRyxJQUF5Qix5REFBbEIsSUFBa0I7QUFBQSxTQUFab0csTUFBWSx5REFBSCxDQUFHO0FBQUE7O0FBQ2pDO0FBQ0EsVUFBS3BHLElBQUwsR0FBWUEsSUFBWjtBQUNBO0FBQ0EsVUFBS29HLE1BQUwsR0FBY0EsTUFBZDtBQUNILEU7O0FBR0wsS0FBSUUsS0FBSyxJQUFJTixVQUFKLEVBQVQ7QUFDQU0sSUFBR0wsS0FBSCxDQUFTbkQsSUFBVCxDQUFjLElBQUl1RCxjQUFKLENBQW1CLEdBQW5CLEVBQXdCLENBQUMsQ0FBekIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDtBQUNBQyxJQUFHTCxLQUFILENBQVNuRCxJQUFULENBQWMsSUFBSXVELGNBQUosQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBZDs7QUFHQTs7S0FFYUUsUyxXQUFBQSxTO0FBQ1QsMEJBQWM7QUFBQTs7QUFDVixjQUFLTixLQUFMLEdBQWEsRUFBYjtBQUNIOzt5QkFFRHRDLFEsdUJBQVc7QUFDUCxhQUFJNkMsT0FBTyxJQUFYO0FBQ0EsZ0JBQU8sU0FBU0MsUUFBVCxDQUFrQkMsU0FBbEIsRUFBNkI7QUFDaEMsaUJBQUksQ0FBQ0YsS0FBS1AsS0FBTCxDQUFXUyxTQUFYLENBQUwsRUFBNEIsT0FBTyxDQUFQOztBQUU1QixpQkFBSUMsS0FBSyxDQUFUO0FBQ0Esa0JBQUssSUFBSXZHLElBQUlvRyxLQUFLUCxLQUFMLENBQVdTLFNBQVgsQ0FBYixFQUFvQ3RHLENBQXBDLEVBQXVDQSxJQUFJQSxFQUFFRCxJQUE3QyxFQUFtRDtBQUMvQyxxQkFBSWdGLElBQUlzQixTQUFTckcsRUFBRXdHLEtBQVgsQ0FBUjtBQUNBLHFCQUFJekIsSUFBSXdCLEVBQVIsRUFBWUEsS0FBS3hCLENBQUw7QUFDZjs7QUFFRCxvQkFBT3dCLEtBQUssQ0FBWjtBQUNILFVBVk0sQ0FVTCxLQUFLM0csSUFBTCxDQUFVLENBQVYsQ0FWSyxDQUFQO0FBV0gsTTs7OztBQUVMOzs7Ozs7OztLQU1NNkcsWSxHQUNGLHdCQUE0QztBQUFBLFNBQWhDN0csSUFBZ0MseURBQXpCLElBQXlCO0FBQUEsU0FBbkI4RyxVQUFtQix5REFBTixJQUFNO0FBQUE7O0FBQ3hDLFVBQUs5RyxJQUFMLEdBQVlBLElBQVo7QUFDQSxVQUFLOEcsVUFBTCxHQUFrQkEsVUFBbEI7QUFDSCxFOztBQUdMOzs7Ozs7Ozs7S0FPTUMsYSxHQUNGLHlCQUF1QztBQUFBLFNBQTNCSCxLQUEyQix5REFBbkIsSUFBbUI7QUFBQSxTQUFiekcsSUFBYSx5REFBTixJQUFNO0FBQUE7O0FBQ25DLFVBQUt5RyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxVQUFLekcsSUFBTCxHQUFZQSxJQUFaO0FBQ0gsRTs7QUFHTDs7Ozs7QUFNQTtBQUNBOzs7S0FDYTZHLGdCLFdBQUFBLGdCO0FBQ1QsaUNBQWdFO0FBQUEsYUFBcERoSCxJQUFvRCx5REFBN0MsSUFBNkM7QUFBQSxhQUF2QzhHLFVBQXVDLHlEQUExQixJQUEwQjtBQUFBLGFBQXBCRyxXQUFvQix5REFBTixJQUFNO0FBQUE7O0FBQzVELGNBQUtqSCxJQUFMLEdBQVlBLElBQVo7QUFDQSxjQUFLOEcsVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxjQUFLRyxXQUFMLEdBQW1CQSxXQUFuQjtBQUNIOztBQUVEOzs7Z0NBQ0FDLEssb0JBQVE7QUFDSixjQUFLLElBQUlOLFFBQVEsS0FBS0UsVUFBdEIsRUFBa0NGLEtBQWxDLEVBQXlDQSxRQUFRQSxNQUFNSyxXQUF2RCxFQUFvRTtBQUNoRWpHLHFCQUFRQyxHQUFSLENBQVksT0FBWixFQUFxQixLQUFLakIsSUFBMUIsRUFBZ0M0RyxNQUFNNUcsSUFBdEM7QUFDQTRHLG1CQUFNTSxLQUFOO0FBQ0g7QUFDSixNOztBQUVEOzs7Z0NBQ0FDLFMsd0JBQVk7QUFDUixhQUFJLENBQUMsS0FBS0wsVUFBVixFQUFzQixPQUFPLENBQVAsQ0FBdEIsS0FDSztBQUNELGlCQUFJekQsUUFBUSxDQUFaO0FBQ0Esa0JBQUssSUFBSXVELFFBQVEsS0FBS0UsVUFBdEIsRUFBa0NGLEtBQWxDLEVBQXlDQSxRQUFRQSxNQUFNSyxXQUF2RCxFQUFvRTtBQUNoRTVELDBCQUFTdUQsTUFBTU8sU0FBTixFQUFUO0FBQ0g7QUFDRCxvQkFBTzlELEtBQVA7QUFDSDtBQUNKLE07O0FBRUQ7OztnQ0FDQStELFMsd0JBQVk7QUFDUixhQUFJLENBQUMsS0FBS04sVUFBVixFQUFzQixPQUFPLENBQVAsQ0FBdEIsS0FDSztBQUNELGlCQUFJTyxTQUFTLENBQWI7QUFDQSxrQkFBSyxJQUFJakgsSUFBSSxLQUFLMEcsVUFBbEIsRUFBOEIxRyxDQUE5QixFQUFpQ0EsSUFBSUEsRUFBRTZHLFdBQXZDO0FBQW9ESTtBQUFwRCxjQUVBLEtBQUssSUFBSWpILEtBQUksS0FBSzBHLFVBQWxCLEVBQThCMUcsRUFBOUIsRUFBaUNBLEtBQUlBLEdBQUU2RyxXQUF2QyxFQUFvRDtBQUNoRCxxQkFBSTlCLElBQUkvRSxHQUFFZ0gsU0FBRixFQUFSO0FBQ0EscUJBQUlqQyxJQUFJa0MsTUFBUixFQUFnQkEsU0FBU2xDLENBQVQ7QUFDbkI7O0FBRUQsb0JBQU9rQyxNQUFQO0FBQ0g7QUFDSixNOztnQ0FFRDFELFEsdUJBQVc7QUFDUCxhQUFJLFNBQVM2QixNQUFiLEVBQXFCLE9BQU8sQ0FBUCxDQUFyQixLQUNLO0FBQ0QsaUJBQUk4QixPQUFPLENBQVg7QUFDQSxrQkFBSyxJQUFJbEgsSUFBSSxLQUFLMEcsVUFBbEIsRUFBOEIxRyxDQUE5QixFQUFpQ0EsSUFBSUEsRUFBRTZHLFdBQXZDLEVBQW9EO0FBQ2hELHFCQUFJOUIsSUFBSS9FLEVBQUV1RCxRQUFGLEVBQVI7QUFDQSxxQkFBSXdCLElBQUltQyxJQUFSLEVBQWNBLE9BQU9uQyxDQUFQO0FBQ2pCOztBQUVELG9CQUFPbUMsT0FBTyxDQUFkO0FBQ0g7QUFDSixNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hwQkw7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7S0FDcUJqSSxLO0FBQ2pCLHNCQUFjO0FBQUE7O0FBQ1YsY0FBS2tJLEdBQUwsR0FBVyxJQUFYO0FBQ0EsY0FBSzlGLE1BQUwsR0FBYyxDQUFkO0FBQ0g7O3FCQU1ENUIsTyxzQkFBUztBQUNMLGdCQUFPLEtBQUs0QixNQUFMLEtBQWdCLENBQXZCO0FBQ0gsTTs7cUJBQ0RxQixJLGlCQUFNOUMsSSxFQUFNO0FBQ1IsYUFBSXlDLE9BQU87QUFDUHpDLG1CQUFNQSxJQURDO0FBRVBHLG1CQUFNO0FBRkMsVUFBWDs7QUFLQXNDLGNBQUt0QyxJQUFMLEdBQVksS0FBS29ILEdBQWpCO0FBQ0EsY0FBS0EsR0FBTCxHQUFXOUUsSUFBWDtBQUNBLGNBQUtoQixNQUFMO0FBQ0gsTTs7cUJBQ0Q0QyxJLG1CQUFRO0FBQ0osZ0JBQU8sS0FBS2tELEdBQUwsS0FBYSxJQUFiLEdBQ0gsSUFERyxHQUVILEtBQUtBLEdBQUwsQ0FBU3ZILElBRmI7QUFHSCxNOztxQkFDRCtDLEcsa0JBQU87QUFDSCxhQUFJLEtBQUt3RSxHQUFMLEtBQWEsSUFBakIsRUFBdUIsT0FBTyxJQUFQOztBQUV2QixhQUFJQyxNQUFNLEtBQUtELEdBQWY7QUFDQSxjQUFLQSxHQUFMLEdBQVcsS0FBS0EsR0FBTCxDQUFTcEgsSUFBcEI7O0FBRUEsYUFBSSxLQUFLc0IsTUFBTCxHQUFjLENBQWxCLEVBQXFCLEtBQUtBLE1BQUw7O0FBR3JCLGdCQUFPK0YsSUFBSXhILElBQVg7QUFDSCxNOztxQkFDREYsSyxvQkFBUztBQUNMLGNBQUt5SCxHQUFMLEdBQVcsSUFBWDtBQUNBLGNBQUs5RixNQUFMLEdBQWMsQ0FBZDtBQUNILE07O3FCQUNEYixRLHVCQUFZO0FBQ1IsYUFBSSxLQUFLMkcsR0FBTCxLQUFhLElBQWpCLEVBQXVCLE9BQU8sSUFBUDs7QUFFdkIsYUFBSTFHLE1BQU0sRUFBVjtBQUNBLGFBQUlMLFVBQVUsS0FBSytHLEdBQW5COztBQUVBLGNBQUssSUFBSTVHLElBQUksQ0FBUixFQUFXRyxNQUFNLEtBQUtsQixJQUEzQixFQUFpQ2UsSUFBSUcsR0FBckMsRUFBMENILEdBQTFDLEVBQStDO0FBQzNDRSxpQkFBSUYsQ0FBSixJQUFTSCxRQUFRUixJQUFqQjtBQUNBUSx1QkFBVUEsUUFBUUwsSUFBbEI7QUFDSDs7QUFFRCxnQkFBT1UsR0FBUDtBQUNILE07Ozs7NkJBakRTO0FBQ04sb0JBQU8sS0FBS1ksTUFBWjtBQUNIOzs7OzttQkFSZ0JwQyxLOzs7QUEwRHJCLEtBQUl3RCxRQUFRLElBQUl4RCxLQUFKLEVBQVo7O0FBRUF3RCxPQUFNQyxJQUFOLENBQVcsQ0FBWDtBQUNBRCxPQUFNQyxJQUFOLENBQVcsS0FBWDs7QUFFQUQsT0FBTUUsR0FBTjtBQUNBRixPQUFNQyxJQUFOLENBQVcsRUFBQ2pCLEdBQUcsQ0FBSixFQUFYO0FBQ0FiLFNBQVFDLEdBQVIsQ0FBWTRCLEtBQVo7O0FBRUE7Ozs7QUFJQSxVQUFTNEUsWUFBVCxDQUFzQkMsS0FBdEIsRUFBNEI7QUFDeEIsU0FBSTdFLFFBQVEsSUFBSXhELEtBQUosRUFBWjtBQUNBLFNBQUkrRSxJQUFJLEVBQVI7QUFDQSxTQUFJekQsSUFBSSxDQUFSO0FBQ0EsU0FBSVUsSUFBSSxDQUFSOztBQUVBLFlBQU1xRyxNQUFNL0csQ0FBTixDQUFOLEVBQWU7QUFDWCxhQUFHK0csTUFBTS9HLENBQU4sTUFBYSxHQUFoQixFQUFxQmtDLE1BQU1DLElBQU4sQ0FBVzRFLE1BQU0vRyxDQUFOLENBQVgsRUFBckIsS0FDS3lELEVBQUUvQyxHQUFGLElBQVNxRyxNQUFNL0csQ0FBTixDQUFUO0FBQ0xBO0FBQ0g7O0FBRUQsWUFBTWtDLE1BQU1wQixNQUFaLEVBQW1CO0FBQ2YsYUFBSWtHLElBQUk5RSxNQUFNRSxHQUFOLEVBQVI7QUFDQXFCLFdBQUUvQyxHQUFGLElBQVNzRyxDQUFUO0FBQ0g7O0FBRUQsWUFBT3ZELElBQUksRUFBWDtBQUNIOztBQUVEcEQsU0FBUUMsR0FBUixDQUFZLG1CQUFtQndHLGFBQWEsZUFBYixDQUEvQixFLENBQWdFOzs7QUFHaEU7QUFDQSxVQUFTRyxTQUFULENBQW1CQyxHQUFuQixFQUF1QjtBQUNuQixTQUFJaEYsUUFBUSxJQUFJeEQsS0FBSixFQUFaO0FBQ0EsU0FBSXNCLElBQUksQ0FBUjs7QUFFQSxZQUFNa0gsSUFBSWxILENBQUosTUFBVyxHQUFqQixFQUFxQjtBQUNqQixhQUFHa0gsSUFBSWxILENBQUosTUFBVyxHQUFkLEVBQW1CLE9BQU8sS0FBUDtBQUNuQmtDLGVBQU1DLElBQU4sQ0FBVytFLElBQUlsSCxDQUFKLENBQVg7QUFDQUE7QUFDSDs7QUFFREE7O0FBRUEsWUFBTWtILElBQUlsSCxDQUFKLE1BQVcsR0FBakIsRUFBc0I7QUFDbEIsYUFBRyxDQUFDa0MsTUFBTXBCLE1BQVYsRUFBa0IsT0FBTyxLQUFQOztBQUVsQixhQUFJcUUsSUFBSWpELE1BQU1FLEdBQU4sRUFBUjtBQUNBLGFBQUcrQyxNQUFNK0IsSUFBSWxILENBQUosQ0FBVCxFQUFpQixPQUFPLEtBQVA7QUFDakJBO0FBQ0g7O0FBRUQsWUFBTyxDQUFDa0MsTUFBTXBCLE1BQWQ7QUFDSDs7QUFFRFQsU0FBUUMsR0FBUixDQUFZLGdCQUFnQjJHLFVBQVUsYUFBVixDQUE1QixFLENBQXdEOzs7QUFHeEQ7QUFDQTtBQUNBO0FBQ0EsVUFBU0UsWUFBVCxDQUFzQkMsTUFBdEIsRUFBOEJDLEdBQTlCLEVBQW1DO0FBQy9CLFNBQUlsQyxJQUFJLElBQUl6RyxLQUFKLEVBQVI7O0FBRUEsWUFBTzBJLE1BQVAsRUFBZTtBQUNYakMsV0FBRWhELElBQUYsQ0FBT2lGLFNBQVNDLEdBQWhCO0FBQ0FELGtCQUFTRSxTQUFTRixTQUFTLENBQWxCLEVBQXFCLEVBQXJCLENBQVQ7QUFDSDs7QUFFRCxTQUFJbEgsTUFBTSxFQUFWO0FBQ0EsWUFBT2lGLEVBQUV5QixHQUFULEVBQWM7QUFDVjFHLGFBQUlpQyxJQUFKLENBQVNnRCxFQUFFL0MsR0FBRixFQUFUO0FBQ0g7QUFDRC9CLGFBQVFDLEdBQVIsQ0FBWUosSUFBSUssSUFBSixDQUFTLEVBQVQsQ0FBWjtBQUNIOztBQUVENEcsY0FBYSxJQUFiLEVBQW1CLENBQW5CO0FBQ0FBLGNBQWEsSUFBYixFQUFtQixDQUFuQjs7QUFHQTtBQUNBLFVBQVNJLGFBQVQsQ0FBdUJMLEdBQXZCLEVBQTRCO0FBQ3hCLFNBQUloRixRQUFRLElBQUl4RCxLQUFKLEVBQVo7QUFDQSxTQUFJOEksT0FBTyxFQUFYOztBQUVBLFVBQUssSUFBSXhILElBQUksQ0FBUixFQUFXRyxNQUFNK0csSUFBSXBHLE1BQTFCLEVBQWtDZCxJQUFJRyxHQUF0QyxFQUEyQ0gsR0FBM0MsRUFBZ0Q7QUFDNUMsYUFBSWdILElBQUlFLElBQUlsSCxDQUFKLENBQVI7QUFDQSxhQUFJZ0gsTUFBTSxHQUFWLEVBQWU7QUFDWDlFLG1CQUFNQyxJQUFOLENBQVc2RSxDQUFYO0FBQ0gsVUFGRCxNQUVPLElBQUlBLE1BQU0sR0FBVixFQUFlO0FBQ2xCLGlCQUFJLENBQUM5RSxNQUFNcEIsTUFBUCxJQUFpQm9CLE1BQU1FLEdBQU4sT0FBZ0IsR0FBckMsRUFBMEMsTUFBTSxJQUFJcUYsS0FBSixDQUFVLHlCQUF5QlQsQ0FBbkMsQ0FBTjtBQUM3QyxVQUZNLE1BRUE7QUFDSFEscUJBQVFSLENBQVI7QUFDSDtBQUNKO0FBQ0QzRyxhQUFRQyxHQUFSLENBQVlrSCxJQUFaO0FBQ0g7O0FBRURuSCxTQUFRQyxHQUFSLENBQVlpSCxjQUFjLE9BQWQsQ0FBWjs7QUFFQSxVQUFTRyxPQUFULENBQWlCQyxJQUFqQixFQUF1QkMsS0FBdkIsRUFBOEI7QUFDMUIsVUFBS0QsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsVUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsVUFBSzFGLEtBQUwsR0FBYSxJQUFJeEQsS0FBSixFQUFiO0FBQ0g7QUFDRGdKLFNBQVFHLFNBQVIsR0FBb0I7QUFDaEJDLFlBQU8sZUFBVVosR0FBVixFQUFlO0FBQ2xCLGFBQUlNLE9BQU8sRUFBWDs7QUFFQSxjQUFLLElBQUl4SCxJQUFJLENBQVIsRUFBV0csTUFBTStHLElBQUlwRyxNQUExQixFQUFrQ2QsSUFBSUcsR0FBdEMsRUFBMkNILEdBQTNDLEVBQWdEO0FBQzVDLGlCQUFJZ0gsSUFBSUUsSUFBSWxILENBQUosQ0FBUjtBQUNBLGlCQUFJZ0gsTUFBTSxLQUFLVyxJQUFmLEVBQXFCO0FBQ2pCLHNCQUFLekYsS0FBTCxDQUFXQyxJQUFYLENBQWdCNkUsQ0FBaEI7QUFDSCxjQUZELE1BRU8sSUFBSUEsTUFBTSxLQUFLWSxLQUFmLEVBQXNCO0FBQ3pCLHFCQUFJLENBQUMsS0FBSzFGLEtBQUwsQ0FBV3BCLE1BQVosSUFBc0IsS0FBS29CLEtBQUwsQ0FBV0UsR0FBWCxPQUFxQixLQUFLdUYsSUFBcEQsRUFBMEQ7QUFDdEQsMkJBQU0sSUFBSUYsS0FBSixDQUFVLHlCQUF5QlQsQ0FBbkMsQ0FBTjtBQUNILGtCQUZELE1BRU87QUFDSFEsNkJBQVEsR0FBUjtBQUNIO0FBQ0osY0FOTSxNQU1BO0FBQ0hBLHlCQUFRUixDQUFSO0FBQ0g7QUFDSjtBQUNEM0csaUJBQVFDLEdBQVIsQ0FBWWtILElBQVo7QUFDQSxnQkFBT0EsSUFBUDtBQUNIO0FBcEJlLEVBQXBCO0FBc0JBLEtBQUkzRyxJQUFJLElBQUk2RyxPQUFKLENBQVksR0FBWixFQUFpQixHQUFqQixDQUFSO0FBQ0E3RyxHQUFFaUgsS0FBRixDQUFRLFdBQVI7O0FBRUEsVUFBU0MsVUFBVCxDQUFvQmIsR0FBcEIsRUFBeUI7QUFDckIsVUFBS2hGLEtBQUwsR0FBYSxJQUFJeEQsS0FBSixFQUFiO0FBQ0EsVUFBS3dJLEdBQUwsR0FBV0EsT0FBTyxFQUFsQjtBQUNIO0FBQ0RhLFlBQVdGLFNBQVgsR0FBdUI7QUFDbkJHLGdCQUFXLHFCQUFZO0FBQ25CLGFBQUk5RixRQUFRLEtBQUtBLEtBQWpCO0FBQ0EsYUFBSWdGLE1BQU0sS0FBS0EsR0FBZjtBQUNBLGNBQUssSUFBSWxILElBQUksQ0FBUixFQUFXRyxNQUFNK0csSUFBSXBHLE1BQTFCLEVBQWtDZCxJQUFJRyxHQUF0QyxFQUEyQ0gsR0FBM0MsRUFBZ0Q7QUFDNUMsaUJBQUlnSCxJQUFJRSxJQUFJbEgsQ0FBSixDQUFSO0FBQ0EscUJBQVFnSCxDQUFSO0FBQ0ksc0JBQUssR0FBTDtBQUNJOUUsMkJBQU1FLEdBQU47QUFDQTtBQUNKLHNCQUFLLEdBQUw7QUFDSUYsMkJBQU0vQyxLQUFOO0FBQ0E7QUFDSjtBQUNJK0MsMkJBQU1DLElBQU4sQ0FBVzZFLENBQVg7QUFDQTtBQVRSO0FBV0g7O0FBRUQsYUFBSWlCLFNBQVMsRUFBYjtBQUNBLGFBQUlwSSxVQUFVcUMsTUFBTXBCLE1BQXBCO0FBQ0EsZ0JBQU9qQixPQUFQLEVBQWdCO0FBQ1pvSSxzQkFBU3BJLFFBQVFSLElBQVIsR0FBZTRJLE1BQXhCO0FBQ0FwSSx1QkFBVUEsUUFBUUwsSUFBbEI7QUFDSDs7QUFFRCxnQkFBT3lJLE1BQVA7QUFDSDtBQTNCa0IsRUFBdkI7O0FBOEJBLEtBQUlDLEtBQUssSUFBSUgsVUFBSixDQUFlOzhCQUFmLENBQVQ7QUFFQTFILFNBQVFDLEdBQVIsQ0FBWTRILEdBQUdGLFNBQUgsRUFBWjs7QUFHQSxLQUFJRyxTQUFTO0FBQ1QsVUFBSyxDQURJO0FBRVQsVUFBSyxDQUZJO0FBR1QsVUFBSyxDQUhJO0FBSVQsVUFBSyxDQUpJO0FBS1QsVUFBSyxDQUxJO0FBTVQsVUFBSyxDQU5JO0FBT1QsVUFBSyxDQVBJO0FBUVQsVUFBSyxDQVJJO0FBU1QsVUFBSyxDQUFDO0FBVEcsRUFBYjs7QUFZQSxVQUFTQyxJQUFULENBQWNDLEVBQWQsRUFBa0JDLElBQWxCLEVBQXdCQyxJQUF4QixFQUE4QjtBQUMxQixhQUFRRixFQUFSO0FBQ0ksY0FBSyxHQUFMO0FBQ0ksb0JBQU9DLE9BQU9DLElBQWQ7QUFDSixjQUFLLEdBQUw7QUFDSSxvQkFBT0QsT0FBT0MsSUFBZDtBQUNKLGNBQUssR0FBTDtBQUNJLG9CQUFPRCxPQUFPQyxJQUFkO0FBQ0osY0FBSyxHQUFMO0FBQ0ksb0JBQU9ELE9BQU9DLElBQWQ7QUFDSixjQUFLLEdBQUw7QUFDSSxvQkFBT0QsT0FBT0MsSUFBZDtBQUNKLGNBQUssR0FBTDtBQUNJLG9CQUFPQyxLQUFLQyxHQUFMLENBQVNILElBQVQsRUFBZUMsSUFBZixDQUFQO0FBQ0o7QUFDSSxvQkFBTyxDQUFQO0FBZFI7QUFnQkg7O0FBRUQsVUFBU0csTUFBVCxDQUFnQnhILENBQWhCLEVBQW1CeUgsQ0FBbkIsRUFBc0I7QUFDbEIsWUFBT1IsT0FBT2pILENBQVAsSUFBWWlILE9BQU9RLENBQVAsQ0FBbkI7QUFDSDs7QUFFRCxVQUFTQyxrQkFBVCxDQUE0QkMsR0FBNUIsRUFBaUM7QUFDN0IsU0FBSUMsS0FBSyxFQUFUO0FBQ0EsU0FBSUMsS0FBSyxFQUFUO0FBQ0FGLFdBQU1BLElBQUlHLE9BQUosQ0FBWSxLQUFaLEVBQW1CLEVBQW5CLENBQU47QUFDQUgsWUFBTyxHQUFQO0FBQ0EsU0FBSUEsSUFBSSxDQUFKLE1BQVcsR0FBZixFQUFvQjtBQUNoQkEsZUFBTSxNQUFNQSxHQUFaO0FBQ0g7QUFDRCxTQUFJN0IsVUFBSjtBQUNBLFNBQUlxQixXQUFKO0FBQ0EsU0FBSUMsYUFBSjtBQUNBLFNBQUlDLGFBQUo7QUFDQSxVQUFLLElBQUl2SSxJQUFJLENBQWIsRUFBZ0JBLElBQUk2SSxJQUFJL0gsTUFBeEIsRUFBZ0MsRUFBRWQsQ0FBbEMsRUFBcUM7QUFDakNnSCxhQUFJNkIsSUFBSTdJLENBQUosQ0FBSjtBQUNBO0FBQ0EsYUFBSWdILEtBQUttQixNQUFULEVBQWlCO0FBQ2I7QUFDQTtBQUNBLG9CQUFPbkIsS0FBSyxHQUFMLElBQVk4QixHQUFHaEksTUFBZixJQUF5QjRILE9BQU9JLEdBQUdBLEdBQUdoSSxNQUFILEdBQVksQ0FBZixDQUFQLEVBQTBCa0csQ0FBMUIsS0FBZ0MsQ0FBaEUsRUFBbUU7QUFDL0Q7QUFDQXFCLHNCQUFLUyxHQUFHMUcsR0FBSCxFQUFMO0FBQ0E7QUFDQSxxQkFBSWlHLE1BQU0sR0FBTixJQUFhQSxNQUFNLEdBQXZCLEVBQTRCO0FBQ3hCO0FBQ0FFLDRCQUFPUSxHQUFHM0csR0FBSCxFQUFQO0FBQ0FrRyw0QkFBT1MsR0FBRzNHLEdBQUgsRUFBUDtBQUNBO0FBQ0EyRyx3QkFBRzVHLElBQUgsQ0FBUWlHLEtBQUtDLEVBQUwsRUFBU0MsSUFBVCxFQUFlQyxJQUFmLENBQVI7QUFDSDtBQUNKO0FBQ0Q7QUFDQSxpQkFBSXZCLEtBQUssR0FBVCxFQUFjOEIsR0FBRzNHLElBQUgsQ0FBUTZFLENBQVI7QUFDakIsVUFqQkQsTUFpQk87QUFDSDtBQUNBLG9CQUFPLEVBQUU2QixJQUFJN0ksQ0FBSixLQUFVbUksTUFBWixDQUFQLEVBQTRCO0FBQ3hCbkk7QUFDQWdILHNCQUFLNkIsSUFBSTdJLENBQUosQ0FBTDtBQUNIO0FBQ0QrSSxnQkFBRzVHLElBQUgsQ0FBUThHLFdBQVdqQyxDQUFYLENBQVI7QUFDQWhIO0FBQ0g7QUFDSjtBQUNELFlBQU8rSSxHQUFHakksTUFBSCxHQUFZaUksR0FBRyxDQUFILENBQVosR0FBb0JHLEdBQTNCO0FBQ0g7O0FBRUQsS0FBSUMsT0FBT1AsbUJBQW1CLGlCQUFuQixDQUFYO0FBQ0F2SSxTQUFRQyxHQUFSLENBQVk2SSxJQUFaLEU7Ozs7OztBQ3ZVQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHOzs7Ozs7QUNoQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRzs7Ozs7O0FDTkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7Ozs7O21CQ0F3QkMsYztBQUp4Qjs7OztBQUllLFVBQVNBLGNBQVQsQ0FBd0JsSSxDQUF4QixFQUEyQnlILENBQTNCLEVBQThCO0FBQ3pDLFVBQU96SCxJQUFJeUgsQ0FBWDtBQUNILEc7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0EsYzs7Ozs7O0FDSEEscUI7Ozs7OztBQ0FBLHVCOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7Ozs7OztBQ3hDQSxlQUFjLHNCOzs7Ozs7QUNBZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsK0JBQStCO0FBQ2pHLEc7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDSkE7QUFDQTtBQUNBLG9EQUFtRDtBQUNuRDtBQUNBLHdDQUF1QztBQUN2QyxHOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRCxzQkFBc0I7QUFDaEYsaUZBQWdGLHNCQUFzQjtBQUN0RyxHOzs7Ozs7QUNSQSxxQzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7Ozs7Ozs7O0FDakNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxjQUFjO0FBQ25CLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7OztBQ3BERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxcEJBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtkQUFpZCwrQkFBK0I7QUFDaGY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0IsWUFBWTtBQUM1QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMxTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFZLE9BQU8sT0FBTyxZQUFZLE9BQU8sT0FBTyxPQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNMQSw4QkFBNkIsbURBQW1EOzs7Ozs7O0FDQWhGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQzNiQSxnQiIsImZpbGUiOiIuL0RTLWRlYnVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRFNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRFNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDI1M2I4MjZiOTE4YmFjZjU0YjliXG4gKiovIiwiXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQXJyYXk6IHtcclxuICAgICAgICBDcm9zc0xpc3Q6IHJlcXVpcmUoJy4vQXJyYXkvQ3Jvc3NMaXN0JykuZGVmYXVsdCxcclxuICAgICAgICBUU01hdHJpeDogcmVxdWlyZSgnLi9BcnJheS9UU01hdHJpeCcpLmRlZmF1bHRcclxuICAgIH0sXHJcbiAgICBcclxuICAgIEJpbmFyeVRyZWU6IHtcclxuICAgICAgICAvLyBCaW5hcnlUaHJlYWRUcmVlOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvQmluYXJ5VGhyZWFkVHJlZScpLFxyXG4gICAgICAgIEJpbmFyeVRyZWU6IHJlcXVpcmUoJy4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJyksXHJcbiAgICAgICAgLy8gRUJUTm9kZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0VCVE5vZGUnKSxcclxuICAgICAgICBodWZmTWFuQ29kaW5nOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZycpLmRlZmF1bHQsXHJcbiAgICAgICAgLy8gTUZTZXQ6IHJlcXVpcmUoJy4vQmluYXJ5VHJlZS9NRlNldCcpLFxyXG4gICAgICAgIC8vIFBCVE5vZGU6IHJlcXVpcmUoJy4vQmluYXJ5VHJlZS9QQlROb2RlJylcclxuICAgIH0sXHJcbiAgICBcclxuICAgIEdlbmVyYWxpemVkTGlzdDogcmVxdWlyZSgnLi9HZW5lcmFsaXplZExpc3QvR0xpc3QnKS5kZWZhdWx0LFxyXG4gICAgXHJcbiAgICBHcmFwaDoge1xyXG4gICAgICAgIEFkamFjZW5jeUxpc3RHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9BZGphY2VuY3lMaXN0R3JhcGgnKS5kZWZhdWx0LFxyXG4gICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoJykuZGVmYXVsdCxcclxuICAgICAgICBBTUxHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9BTUxHcmFwaCcpLmRlZmF1bHQsXHJcbiAgICAgICAgT0xHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9PTEdyYXBoJykuZGVmYXVsdFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgTGlzdDoge1xyXG4gICAgICAgIERvdWJsZUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vTGlzdC9Eb3VibGVMaW5rZWRMaXN0JykuZGVmYXVsdCxcclxuICAgICAgICBMaW5lYXJMaXN0OiByZXF1aXJlKCcuL0xpc3QvTGluZWFyTGlzdCcpLFxyXG4gICAgICAgIFN0YXRpY0xpbmtlZExpc3Q6IHJlcXVpcmUoJy4vTGlzdC9TdGF0aWNMaW5rZWRMaXN0JykuZGVmYXVsdCxcclxuICAgICAgICBMUlVDYWNoZTogcmVxdWlyZSgnLi9MaXN0L0xSVScpLmRlZmF1bHRcclxuICAgIH0sXHJcbiAgICBcclxuICAgIFF1ZXVlOiB7XHJcbiAgICAgICAgQ3ljbGVRdWV1ZTogcmVxdWlyZSgnLi9RdWV1ZS9DeWNsZVF1ZXVlJykuZGVmYXVsdCxcclxuICAgICAgICBQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL1ByaW9yaXR5UXVldWUnKS5kZWZhdWx0LFxyXG4gICAgICAgIFF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL1F1ZXVlJykuZGVmYXVsdFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgU2VhcmNoOiB7XHJcbiAgICAgICAgQVZMVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQVZMVHJlZScpLFxyXG4gICAgICAgIGJpbmFyeVNlYXJjaDogcmVxdWlyZSgnLi9TZWFyY2gvQmluYXJ5U2VhcmNoJyksXHJcbiAgICAgICAgQmluYXJ5U29ydGVkVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQmluYXJ5U29ydGVkVHJlZScpLmRlZmF1bHQsXHJcbiAgICAgICAgQlBsdXNUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CUGx1c1RyZWUnKSxcclxuICAgICAgICBCVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQlRyZWUnKSxcclxuICAgICAgICBEaWdpdGFsU2VhcmNoVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUnKSxcclxuICAgICAgICBmaWJvbmFjY2lTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaCcpLmRlZmF1bHQsXHJcbiAgICAgICAgSGFzaFRhYmxlOiByZXF1aXJlKCcuL1NlYXJjaC9IYXNoVGFibGUnKSxcclxuICAgICAgICBSZWRCbGFja1RyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL1JlZEJsYWNrVHJlZScpLmRlZmF1bHQsXHJcbiAgICAgICAgc2VxdWVudGlhbFNlYXJjaDogcmVxdWlyZSgnLi9TZWFyY2gvc2VxdWVudGlhbFNlYXJjaCcpLmRlZmF1bHQsXHJcbiAgICAgICAgU09TVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvU09TVHJlZScpLFxyXG4gICAgICAgIEJsb29tRmlsdGVyOiByZXF1aXJlKCcuL1NlYXJjaC9CbG9vbUZpbHRlcicpXHJcbiAgICB9LFxyXG5cclxuICAgIFNvcnQ6IHtcclxuICAgICAgICBkaXN0cmlidXRpb246IHJlcXVpcmUoJy4vU29ydC9kaXN0cmlidXRpb24vaW5kZXgnKSxcclxuICAgICAgICBleGNoYW5nZTogcmVxdWlyZSgnLi9Tb3J0L2V4Y2hhbmdlL2luZGV4JyksXHJcbiAgICAgICAgaW5zZXJ0aW9uOiByZXF1aXJlKCcuL1NvcnQvaW5zZXJ0aW9uL2luZGV4JyksXHJcbiAgICAgICAgbWVyZ2luZzogcmVxdWlyZSgnLi9Tb3J0L21lcmdpbmcvaW5kZXgnKSxcclxuICAgICAgICBzZWxlY3Rpb246IHJlcXVpcmUoJy4vU29ydC9zZWxlY3Rpb24vaW5kZXgnKVxyXG4gICAgfSxcclxuXHJcbiAgICBTdGFjazogcmVxdWlyZSgnLi9TdGFjay9pbmRleCcpLmRlZmF1bHQsXHJcblxyXG4gICAgU3RyaW5nOiB7XHJcbiAgICAgICAgSFN0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvSFN0cmluZycpLmRlZmF1bHQsXHJcbiAgICAgICAgTFN0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvTFN0cmluZycpLmRlZmF1bHQsXHJcbiAgICAgICAgU1N0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvU1N0cmluZycpLmRlZmF1bHRcclxuICAgIH1cclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59IGVsc2Uge1xuICAvLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuICBCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuICBCdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9idWZmZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6Zif5YiXUXVldWVcclxuICpcclxuICog6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye677yIZmlyc3QgaW4gZmlyc3Qgb3V0LCBGSUZP77yJ55qE57q/5oCn6KGo44CC5a6D5Y+q5YWB6K645Zyo6KGo55qE5LiA56uv6L+b6KGM5o+S5YWl77yM6ICM5Zyo5Y+m5LiA56uv5Yig6Zmk5YWD57Sg44CCXHJcbiAqIOWFgeiuuOaPkuWFpeeahOS4gOerr+WPq+mYn+Wwvu+8iHJlYXLvvInvvIzlhYHorrjliKDpmaTnmoTkuIDnq6/lj6vpmJ/lpLTvvIhmcm9udO+8ieOAglxyXG4gKi9cclxuXHJcbi8vIOmTvumYn+WIl1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlYXIgPSB0aGlzLmZyb250ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYXIgPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBjbGVhciAoKSB7XHJcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuICAgIGdldEhlYWQgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb250ID8gdGhpcy5mcm9udC5kYXRhIDogbnVsbDtcclxuICAgIH1cclxuICAgIGVuUXVldWUgKGVsZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlYXIgPSB0aGlzLmZyb250ID0ge2RhdGE6IGVsZW0sIG5leHQ6IG51bGx9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBwID0ge2RhdGE6IGVsZW0sIG5leHQ6IG51bGx9O1xyXG4gICAgICAgICAgICB0aGlzLnJlYXIubmV4dCA9IHA7XHJcbiAgICAgICAgICAgIHRoaXMucmVhciA9IHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgZGVRdWV1ZSAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQpIHtcclxuICAgICAgICAgICAgbGV0IGVsZW0gPSB0aGlzLmZyb250LmRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLmZyb250Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZVRyYXZlcnNlIChpdGVyYXRvcikge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5mcm9udDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoY3VycmVudC5kYXRhKSkgYnJlYWs7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGVla0F0IChpbmRleCA9IDApIHtcclxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5mcm9udDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc2l6ZTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltpXSA9IGN1cnJlbnQuZGF0YTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG5xdWV1ZS5lblF1ZXVlKDEpO1xyXG5xdWV1ZS5kZVF1ZXVlKCk7XHJcbnF1ZXVlLmVuUXVldWUoMik7XHJcbnF1ZXVlLmVuUXVldWUoMyk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgwKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgxKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgyKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgzKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnRvU3RyaW5nKCkuam9pbigpKTtcclxuXHJcblxyXG5cclxuLy8g57G75Ly85bm/5bqm5LyY5YWI6YGN5Y6GXHJcbmZ1bmN0aW9uIHJlcGFpbnRDb2xvcihtYXRyaXgsIGksIGosIGNvbG9yKXtcclxuICAgIGxldCBvbGQgPSBtYXRyaXhbaV1bal07XHJcbiAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgIGxldCBtID0gbWF0cml4Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgbiA9IG1hdHJpeFswXS5sZW5ndGggLSAxO1xyXG5cclxuICAgIHF1ZXVlLmVuUXVldWUoe3g6IGksIHk6IGp9KTtcclxuXHJcbiAgICB3aGlsZShxdWV1ZS5yZWFyKXtcclxuICAgICAgICBsZXQgYSA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICBsZXQgeCA9IGEueDtcclxuICAgICAgICBsZXQgeSA9IGEueTtcclxuXHJcbiAgICAgICAgaWYoeCA+PSAxKSBzZXRDb2xvcih4IC0gMSwgeSk7XHJcbiAgICAgICAgaWYoeSA+PSAxKSBzZXRDb2xvcih4LCB5IC0gMSk7XHJcbiAgICAgICAgaWYoeCA8IG0pIHNldENvbG9yKHggKyAxLCB5KTtcclxuICAgICAgICBpZih5IDwgbikgc2V0Q29sb3IoeCwgeSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldENvbG9yKHgsIHkpe1xyXG4gICAgICAgIGlmKG1hdHJpeFt4XVt5XSA9PT0gb2xkKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeFt4XVt5XSA9IGNvbG9yO1xyXG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHt4OiB4LCB5OiB5fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgbWF0cml4ID0gW107XHJcblxyXG5mb3IobGV0IGkgPSAwOyBpIDwgODsgaSsrKXtcclxuICAgIG1hdHJpeFtpXSA9IFtdO1xyXG4gICAgZm9yKGxldCBqID0gMDsgaiA8IDg7IGorKyl7XHJcbiAgICAgICAgbWF0cml4W2ldW2pdID0gMDtcclxuICAgIH1cclxufVxyXG5cclxucmVwYWludENvbG9yKG1hdHJpeCwgNCwgNSwgMSk7XHJcbmNvbnNvbGUubG9nKG1hdHJpeCk7XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9RdWV1ZS9RdWV1ZS5qc1xuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDmoJHnmoTkuIDkupvmpoLlv7VcclxuICpcclxuICog5qCR77yIVHJlZe+8ieaYr27vvIhuPj0w77yJ5Liq57uT54K555qE5pyJ6ZmQ6ZuG44CC5Zyo5Lu75oSP5LiA5qO16Z2e56m65qCR5Lit77yaXHJcbiAqIO+8iDHvvInmnInkuJTku4XmnInkuIDkuKrnibnlrprnmoTnp7DkuLrmoLnvvIhSb29077yJ55qE57uT54K577ybXHJcbiAqIO+8iDLvvInlvZNuPjHml7bvvIzlhbbkvZnnu5Pngrnlj6/liIbkuLptKG0+MCnkuKrkupLkuI3nm7jkuqTnmoTmnInpmZDpm4ZUMSxUMixUMywuLi5Ube+8jOWFtuS4reavj+S4gOS4qumbhuWQiOacrOi6q+WPiOaYr+S4gOajteagke+8jOW5tuS4lOensOS4uuagueeahOWtkOagke+8iFN1YnRyZWXvvInjgIJcclxuICpcclxuICog5L6L5aaC77yM77yIYe+8ieaYr+WPquacieS4gOS4quaguee7k+eCueeahOagke+8m1xyXG4gKiDvvIhi77yJ5piv5pyJMTPkuKrnu5PngrnnmoTmoJHvvIzlhbbkuK1B5piv5qC577yM5YW25L2Z57uT54K55YiG5oiQM+S4quS6kuS4jeebuOS6pOeahOWtkOmbhu+8mlQxPXtCLEUsRixLLEx9LHQyPXtELEgsSSxKLE19O1QxLFQy5ZKMVDPpg73mmK/moLlB55qE5a2Q5qCR77yM5LiU5pys6Lqr5Lmf5piv5LiA5qO15qCR44CCXHJcbiAqXHJcbiAqIOagkeeahOe7k+eCueWMheWQq+S4gOS4quaVsOaNruWFg+e0oOWPiuiLpeW5suaMh+WQkeWFtuWtkOagkeeahOWIhuaUr+OAgue7k+eCueaLpeacieeahOWtkOagkeaVsOensOS4uue7k+eCueeahOW6pu+8iERlZ3JlZe+8ieOAguS+i+Wmgu+8jO+8iGLvvInkuK1B55qE5bqm5Li6M++8jEPnmoTluqbkuLox77yMRueahOW6puS4ujAu5bqm5Li6MOeahOe7k+eCueensOS4uuWPtuWtkO+8iExlYWbvvInmiJbogIXnu4jnq6/nu5PngrnjgILluqbkuI3kuLow55qE57uT54K556ew5Li66Z2e57uI56uv57uT54K55oiW5YiG5pSv57uT54K544CC5qCR55qE5bqm5piv5qCR5YaF5ZCE57uT54K555qE5bqm55qE5pyA5aSn5YC844CC77yIYu+8ieeahOagkeeahOW6puS4ujMu57uT54K555qE5a2Q5qCR55qE5qC556ew5Li66K+l57uT54K555qE5a2p5a2Q77yIQ2hpbGTvvInjgILnm7jlupTnmoTvvIzor6Xnu5Pngrnnp7DkuLrlranlrZDnmoTlj4zkurLvvIhQYXJlbnTvvInjgILlkIzkuIDkuKrlj4zkurLnmoTlranlrZDkuYvpl7TkupLnp7DlhYTlvJ/vvIhTaWJsaW5n77yJ44CC57uT54K555qE56WW5YWI5piv5LuO5qC55Yiw6K+l57uT54K55omA57uP5YiG5pSv5LiK55qE5omA5pyJ57uT54K544CC5Y+N5LmL77yM5Lul5p+Q57uT54K55Li65qC555qE5a2Q5qCR5Lit55qE5Lu75LiA57uT54K56YO956ew5Li66K+l57uT54K555qE5a2Q5a2Z44CCXHJcbiAqIOe7k+eCueeahOWxguasoe+8iExldmVs77yJ5LuO5qC55byA5aeL5a6a5LmJ6LW377yM5qC55Li656ys5LiA5bGC77yM6Lef55qE5a2p5a2Q5Li656ys5LqM5bGC44CC6Iul5p+Q57uT54K55Zyo56ysbOWxgu+8jOWImeWFtuWtkOagkeeahOagueWwseWcqOesrGwrMeWxguOAguWFtuWPjOS6suWcqOWQjOS4gOWxgueahOe7k+eCueS6kuS4uuWgguWFhOW8n+OAguS+i+Wmgu+8jOe7k+eCuUfkuI5F77yMRixILEksSuS6kuS4uuWgguWFhOW8n+OAguagkeS4ree7k+eCueeahOacgOWkp+WxguasoeensOS4uuagkeeahOa3seW6pu+8iERlcHRo77yJ5oiW6auY5bqm44CC77yIYu+8ieeahOagkeeahOa3seW6puS4ujTjgIJcclxuICpcclxuICog5aaC5p6c5bCG5qCR5Lit57uT54K555qE5ZCE5a2Q5qCR55yL5oiQ5LuO5bem6Iez5Y+z5piv5pyJ5qyh5bqP55qE77yI5Y2z5LiN6IO95Lqk5o2i77yJ77yM5YiZ56ew6K+l5qCR5Li65pyJ5bqP5qCR77yM5ZCm5YiZ56ew5Li65peg5bqP5qCR44CC5Zyo5pyJ5bqP5qCR5Lit5pyA5bem6L6555qE5a2Q5qCR55qE5qC556ew5Li656ys5LiA5Liq5a2p5a2Q77yM5pyA5Y+z6L6555qE56ew5Li65pyA5ZCO5LiA5Liq5a2p5a2Q44CCXHJcbiAqIOajruael++8iEZvcmVzdO+8ieaYr23vvIhtPj0w77yJ5qO15LqS5LiN55u45Lqk55qE5qCR55qE6ZuG5ZCI44CC5a+55qCR5Lit5q+P5Liq57uT54K56ICM6KiA77yM5YW25a2Q5qCR55qE6ZuG5ZCI5Y2z5Li65qOu5p6X44CCXHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIOS6jOWPieagke+8iEJpbmFyeSBUcmVl77yJ5piv5Y+m5LiA56eN5qCR5Z6L57uT5p6E77yM5a6D55qE54m554K55piv5q+P5Liq57uT54K56Iez5aSa5Y+q5pyJ5Lik5qO15a2Q5qCR77yI5Y2z5LqM5Y+J5qCR5Lit5LiN5a2Y5Zyo5bqm5aSn5LqOMueahOe7k+eCue+8ie+8jOW5tuS4lO+8jOS6jOWPieagkeeahOWtkOagkeacieW3puWPs+S5i+WIhu+8iOWFtuasoeW6j+S4jeiDveS7u+aEj+mioOWAkuOAgu+8iVxyXG4gKlxyXG4gKiDkuozlj4nmoJHnmoTmgKfotKhcclxuICogMS7lnKjkuozlj4nmoJHnmoTnrKxp5bGC5LiK6Iez5aSa5pyJMueahGktMeasoeaWueS4que7k+eCuShpPj0xKeOAglxyXG4gKiAyLua3seW6puS4umvnmoTkuozlj4nmoJHoh7PlpJrmnIky55qEa+asoeaWuS0x5Liq57uT54K577yMKGs+PTEp44CCXHJcbiAqIDMu5a+55Lu75L2V5LiA5qO15LqM5Y+J5qCRVO+8jOWmguaenOWFtue7iOerr+e7k+eCueaVsOS4um4w77yM5bqm5Li6MueahOe7k+eCueaVsOS4um4y77yM5YiZbjAgPSBuMiArIDE7XHJcbiAqICAgICAg5LiA5qO15rex5bqm5Li6a+S4lOaciTLnmoRr5qyh5pa5LTHkuKrnu5PngrnnmoTkuozlj4nmoJHnp7DkuLrmu6Hkuozlj4nmoJHjgIJcclxuICogICAgICDmt7HluqbkuLpr55qE77yM5pyJbuS4que7k+eCueeahOS6jOWPieagke+8jOW9k+S4lOS7heW9k+WFtuavj+S4gOS4que7k+eCuemDveS4jua3seW6puS4umvnmoTmu6Hkuozlj4nmoJHkuK3nvJblj7fku44x6IezbueahOe7k+eCueS4gOS4gOWvueW6lOaXtu+8jOensOS5i+S4uuWujOWFqOS6jOWPieagkeOAglxyXG4gKiDkuIvpnaLmmK/lrozlhajkuozlj4nmoJHnmoTkuKTkuKrnibnmgKdcclxuICogNC7lhbfmnIlu5Liq57uT54K555qE5a6M5YWo5LqM5Y+J5qCR55qE5rex5bqm5Li6TWF0aC5mbG9vcihsb2cgMiBuKSArIDFcclxuICogNS7lpoLmnpzlr7nkuIDmo7XmnIlu5Liq57uT54K555qE5a6M5YWo5LqM5Y+J5qCR77yI5YW25rex5bqm5Li6TWF0aC5mbG9vcihsb2cgMiBuKSArIDHvvInnmoTnu5PngrnmjInlsYLluo/nvJblj7fvvIjku47nrKwx5bGC5Yiw56ysTWF0aC5mbG9vcigyIG4pICsgMe+8jOavj+WxguS7juW3puWIsOWPs++8ie+8jOWImeWvueS7u+S4gOe7k+eCue+8iDE8PWk8PW7vvInmnInvvJpcclxuICogICAgICgxKeWmguaenGk9Me+8jOWImee7k+eCuWnjgIHmmK/kuozlj4nmoJHnmoTmoLnvvIzml6Dlj4zkurLvvJvlpoLmnpxpPjHvvIzliJnlhbblj4zkurJwYXJlbnQoaSnmmK/nu5PngrlNYXRoLmZsb29yKGkvMinjgIJcclxuICogICAgICgyKeWmguaenDJpID4gbu+8jOWImee7k+eCuWnml6Dlt6blranlrZDvvIjnu5Pngrlp5Li65Y+25a2Q57uT54K577yJ77yb5ZCm5YiZ5YW25bem5a2p5a2QTENoaWxkKGkp5piv57uT54K5MmkuXHJcbiAqICAgICAoMynlpoLmnpwyaSArIDEgPiBu77yM5YiZ57uT54K5aeaXoOWPs+WtqeWtkO+8m+WQpuWImeWFtuWPs+WtqeWtkFJDaGlsZChpKeaYr+e7k+eCuTJpICsgMTtcclxuICovXHJcblxyXG4vKlxyXG4g5LqM5Y+J5qCR55qE5a2Y5YKo57uT5p6EXHJcblxyXG4gMS7pobrluo/lrZjlgqjnu5PmnoRcclxuIOeUqOS4gOe7hOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeiHquS4iuiAjOS4i++8jOiHquW3puiHs+WPs+WtmOWCqOWujOWFqOS6jOWPieagkeS4iueahOe7k+eCueWFg+e0oO+8jOWNs+WwhuS6jOWPieagkeS4iue8luWPt+S4umnnmoTnu5PngrnlhYPntKDlrZjlgqjlnKjliqDkuIrlrprkuYnnmoTkuIDnu7TmlbDnu4TkuK3kuIvmoIfkuLppLTHnmoTliIbph4/kuK3jgILigJww4oCd6KGo56S65LiN5a2Y5Zyo5q2k57uT54K544CC6L+Z56eN6aG65bqP5a2Y5YKo57uT5p6E5LuF6YCC55So5LqO5a6M5YWo5LqM5Y+J5qCR44CCXHJcbiDlm6DkuLrvvIzlnKjmnIDlnY/mg4XlhrXkuIvvvIzkuIDkuKrmt7HluqbkuLpr5LiU5Y+q5pyJa+S4que7k+eCueeahOWNleaUr+agke+8iOagkeS4reS4jeWtmOWcqOW6puS4ujLnmoTnu5PngrnvvInljbTpnIDopoHplb/luqbkuLoy55qEbuasoeaWuS0x55qE5LiA57u05pWw57uE44CCXHJcblxyXG4gMi7pk77lvI/lrZjlgqjnu5PmnoRcclxuIOS6jOWPieagkeeahOe7k+eCueeUseS4gOS4quaVsOaNruWFg+e0oOWSjOWIhuWIq+aMh+WQkeWFtuW3puWPs+WtkOagkeeahOS4pOS4quWIhuaUr+aehOaIkO+8jOWImeihqOekuuS6jOWPieagkeeahOmTvuihqOS4reeahOe7k+eCueiHs+WwkeWMheWQq+S4ieS4quWfn++8muaVsOaNruWfn+WSjOW3puWPs+aMh+mSiOWfn+OAguacieaXtu+8jOS4uuS6huS+v+S6juaJvuWIsOe7k+eCueeahOWPjOS6su+8jOWImei/mOWPr+WcqOe7k+eCuee7k+aehOS4reWinuWKoOS4gOS4quaMh+WQkeWFtuWPjOS6sue7k+eCueeahOaMh+mSiOWfn+OAguWIqeeUqOi/meS4pOenjee7k+aehOaJgOW+l+eahOS6jOWPieagkeeahOWtmOWCqOe7k+aehOWIhuWIq+ensOS5i+S4uuS6jOWPiemTvuihqOWSjOS4ieWPiemTvuihqOOAglxyXG4g5Zyo5ZCr5pyJbuS4que7k+eCueeahOS6jOWPiemTvuihqOS4reaciW4rMeS4quepuumTvuWfn++8jOaIkeS7rOWPr+S7peWIqeeUqOi/meS6m+epuumTvuWfn+WtmOWCqOWFtuS7luacieeUqOS/oeaBr++8jOS7juiAjOW+l+WIsOWPpuS4gOenjemTvuW8j+WtmOWCqOe7k+aehC0tLee6v+e0oumTvuihqOOAglxyXG5cclxuIOWFiO+8iOague+8ieW6j+mBjeWOhu+8muagueW3puWPs1xyXG4g5Lit77yI5qC577yJ5bqP6YGN5Y6G77ya5bem5qC55Y+zXHJcbiDlkI7vvIjmoLnvvInluo/pgY3ljobvvJrlt6blj7PmoLlcclxuXHJcbiAqL1xyXG5cclxuXHJcbi8vIOmhuuW6j+WtmOWCqOe7k+aehFxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgLy8g6aG65bqP5a2Y5YKo57uT5p6E55qE6YGN5Y6GXHJcbiAgICBsZXQgdHJlZSA9IFsxLCAyLCAzLCA0LCA1LCAsIDYsICwgLCA3XTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygncHJlT3JkZXI6Jyk7XHJcbiAgICB2b2lkIGZ1bmN0aW9uIHByZU9yZGVyUmVjdXJzaXZlKHgsIHZpc2l0KSB7XHJcbiAgICAgICAgdmlzaXQodHJlZVt4XSk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgcHJlT3JkZXJSZWN1cnNpdmUoMiAqIHggKyAxLCB2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkgcHJlT3JkZXJSZWN1cnNpdmUoMiAqIHggKyAyLCB2aXNpdCk7XHJcbiAgICB9KDAsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdpbk9yZGVyOicpO1xyXG4gICAgdm9pZCBmdW5jdGlvbiBpbk9yZGVyUmVjdXJzaXZlKHgsIHZpc2l0KSB7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgaW5PcmRlclJlY3Vyc2l2ZSgyICogeCArIDEsIHZpc2l0KTtcclxuICAgICAgICB2aXNpdCh0cmVlW3hdKTtcclxuICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSBpbk9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgfSgwLCAodmFsdWUpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygncG9zdE9yZGVyOicpO1xyXG4gICAgdm9pZCBmdW5jdGlvbiBwb3N0T3JkZXJSZWN1cnNpdmUoeCwgdmlzaXQpIHtcclxuICAgICAgICBpZiAodHJlZVsyICogeCArIDFdKSBwb3N0T3JkZXJSZWN1cnNpdmUoMiAqIHggKyAxLCB2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkgcG9zdE9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgICAgIHZpc2l0KHRyZWVbeF0pO1xyXG4gICAgfSgwLCAodmFsdWUpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICB9KTtcclxufSgpKTtcclxuXHJcbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XHJcblxyXG4vLyDpk77lvI/lrZjlgqjnu5PmnoRcclxuZXhwb3J0IGNsYXNzIEJpbmFyeVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIGxlZnRDaGlsZCA9IG51bGwsIHJpZ2h0Q2hpbGQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvLyDlt6blj7PlranlrZDnu5PngrlcclxuICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreS4pOajteagkeaYr+WQpuebuOS8vFxyXG4gICAgaXNTaW1pbGFyKHRyZWUpIHtcclxuICAgICAgICByZXR1cm4gISEodHJlZSAmJlxyXG4gICAgICAgICgodGhpcy5sZWZ0Q2hpbGQgJiYgdGhpcy5sZWZ0Q2hpbGQuaXNTaW1pbGFyKHRyZWUubGVmdENoaWxkKSkgfHwgKCF0aGlzLmxlZnRDaGlsZCAmJiAhdHJlZS5sZWZ0Q2hpbGQpKSAmJlxyXG4gICAgICAgICgodGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5pc1NpbWlsYXIodHJlZS5yaWdodENoaWxkKSkgfHwgKCF0aGlzLnJpZ2h0Q2hpbGQgJiYgIXRyZWUucmlnaHRDaGlsZCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVCaW5hcnlUcmVlKHRyZWUpIHtcclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHByZU9yZGVyUmVjdXJzaXZlKG5vZGUsIHgsIHZpc2l0KSB7XHJcbiAgICAgICAgICAgIHZpc2l0KG5vZGUsIHRyZWVbeF0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHA7XHJcbiAgICAgICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIHAgPSBub2RlLmxlZnRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmVPcmRlclJlY3Vyc2l2ZShwLCAyICogeCArIDEsIHZpc2l0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gbm9kZS5yaWdodENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcclxuICAgICAgICAgICAgICAgIHByZU9yZGVyUmVjdXJzaXZlKHAsIDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocCkgcC5wYXJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB9KHRoaXMsIDAsIChub2RlLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUHJlZml4IGl0ZXJhdGlvbiAqL1xyXG4gICAgKiBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmRhdGE7XHJcbiAgICAgICAgaWYodGhpcy5sZWZ0Q2hpbGQpIHlpZWxkKiB0aGlzLmxlZnRDaGlsZDtcclxuICAgICAgICBpZih0aGlzLnJpZ2h0Q2hpbGQpIHlpZWxkKiB0aGlzLnJpZ2h0Q2hpbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5YWI5bqP6YGN5Y6G5LqM5Y+J5qCR55qE6Z2e6YCS5b2S566X5rOVXHJcbiAgICBwcmVPcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIGxldCBwID0gdGhpcztcclxuXHJcbiAgICAgICAgd2hpbGUgKHAgfHwgc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIOWQkeW3pui1sOWIsOWwveWktFxyXG4gICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAubGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDkuK3luo/pnZ7pgJLlvZLpgY3ljoZcclxuICAgIGluT3JkZXJOb25SZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBsZXQgcCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHdoaWxlIChwIHx8IHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHAgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDkuLrkuobljLrliIbkuKTmrKHov4fmoIjnmoTkuI3lkIzlpITnkIbmlrnlvI/vvIzlnKjloIbmoIjkuK3lop7liqDkuIDkuKptYXJr5Z+f77yMXHJcbiAgICAvLyBtYXJrPTDooajnpLrliJrliJrorr/pl67mraTnu5PngrnvvIxtYXJrPTHooajnpLrlt6blrZDmoJHlpITnkIbnu5PmnZ/ov5Tlm57vvIxcclxuICAgIC8vIG1hcms9MuihqOekuuWPs+WtkOagkeWkhOeQhue7k+adn+i/lOWbnuOAguavj+asoeagueaNruagiOmhtueahG1hcmvln5/lhrPlrprlgZrkvZXliqjkvZxcclxuICAgIHBvc3RPcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHN0YWNrLnB1c2goW3RoaXMsIDBdKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGFbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtub2RlLCAxXSk7ICAvLyDkv67mlLltYXJr5Z+fXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdENoaWxkKSBzdGFjay5wdXNoKFtub2RlLmxlZnRDaGlsZCwgMF0pOyAgLy8g6K6/6Zeu5bem5a2Q5qCRXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChbbm9kZSwgMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2goW25vZGUucmlnaHRDaGlsZCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSAmJiB2aXNpdChub2RlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcmVPcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIHZpc2l0KHRoaXMuZGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5wcmVPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLnByZU9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcclxuICAgIH1cclxuXHJcbiAgICBpbk9yZGVyUmVjdXJzaXZlKHZpc2l0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcclxuICAgICAgICB2aXNpdCh0aGlzLmRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcclxuICAgIH1cclxuXHJcbiAgICBwb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXZlbE9yZGVyVHJhdmVyc2UodmlzaXQpIHtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICBxdWV1ZS5lblF1ZXVlKHRoaXMpO1xyXG5cclxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICBsZXQgcCA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgcC5kYXRhICYmIHZpc2l0KHAuZGF0YSk7XHJcbiAgICAgICAgICAgIHAubGVmdENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgICAgICBwLnJpZ2h0Q2hpbGQgJiYgcXVldWUuZW5RdWV1ZShwLnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLlhYjluo/luo/liJfkuLpr55qE57uT54K555qE5YC8XHJcbiAgICBnZXRQcmVTZXF1ZW5jZShrKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBsZXQgZGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gaylcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gIG5vZGUuZGF0YTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0odGhpcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguS6jOWPieagkeS4reWPtuWtkOe7k+eCueeahOaVsOebrlxyXG4gICAgY291bnRMZWF2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybiAwO1xyXG4gICAgICAgICAgICBlbHNlIGlmICghbm9kZS5sZWZ0Q2hpbGQgJiYgIW5vZGUucmlnaHRDaGlsZCkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpICsgcmVjdXJzZShub2RlLnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH0odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Lqk5o2i5omA5pyJ57uT54K555qE5bem5Y+z5a2Q5qCRXHJcbiAgICByZXZvbHV0ZUJpbmFyeVRyZWUoKSB7XHJcbiAgICAgICAgW3RoaXMubGVmdENoaWxkLCB0aGlzLnJpZ2h0Q2hpbGRdID0gW3RoaXMucmlnaHRDaGlsZCwgdGhpcy5sZWZ0Q2hpbGRdO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnJldm9sdXRlQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5yZXZvbHV0ZUJpbmFyeVRyZWUoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXZvbHV0ZU5vblJlY3Vyc2l2ZSgpe1xyXG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgICAgIHN0YWNrLnB1c2godGhpcyk7XHJcblxyXG4gICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIFtub2RlLmxlZnRDaGlsZCwgbm9kZS5yaWdodENoaWxkXSA9IFtub2RlLnJpZ2h0Q2hpbGQsIG5vZGUubGVmdENoaWxkXTtcclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUubGVmdENoaWxkKSBzdGFjay5wdXNoKG5vZGUubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgaWYobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKG5vZGUucmlnaHRDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguS6jOWPieagkeS4reS7peWAvOS4unjnmoTnu5PngrnkuLrmoLnnmoTlrZDmoJHmt7HluqZcclxuICAgIGdldFN1YkRlcHRoKHgpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHN0YWNrLnB1c2godGhpcyk7XHJcblxyXG4gICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmRhdGEgPT09IHgpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gbm9kZS5nZXREZXB0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2gobm9kZS5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIGdldERlcHRoKCkge1xyXG4gICAgICAgIGxldCBtID0gdGhpcy5sZWZ0Q2hpbGQgJiYgdGhpcy5sZWZ0Q2hpbGQuZ2V0RGVwdGgoKSB8fCAwO1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5nZXREZXB0aCgpIHx8IDA7XHJcbiAgICAgICAgcmV0dXJuIChtID4gbiA/IG0gOiBuKSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yig6Zmk5omA5pyJ5Lul5YWD57SgeOS4uuagueeahOWtkOagkVxyXG4gICAgZGVsU3ViWCh4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PT0geCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5kZWxTdWJYKHgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQuZGVsU3ViWCh4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpnZ7pgJLlvZLlpI3liLbkuozlj4nmoJFcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIOaLt+i0nei/h+eoi+S4reS8muaJp+ihjOeahOWbnuiwg++8jOWPr+S7peeUqOadpeaLt+i0neWFtuWug+iHquWumuS5ieWxnuaAp1xyXG4gICAgICogQHJldHVybnMge0NzdHJ9IOi/lOWbnuaWsOeahOWunuS+i1xyXG4gICAgICovXHJcbiAgICBjb3B5KGNiID0gZnVuY3Rpb24oKXt9KSB7XHJcbiAgICAgICAgLy8g55So5p2l5a2Y5pS+5pys5L2T57uT54K555qE5qCIXHJcbiAgICAgICAgbGV0IHN0YWNrMSA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIC8vIOeUqOadpeWtmOaUvuaWsOS6jOWPieagkee7k+eCueeahOagiFxyXG4gICAgICAgIGxldCBzdGFjazIgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBzdGFjazEucHVzaCh0aGlzKTtcclxuICAgICAgICBsZXQgQ3N0ciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgbGV0IG5ld1RyZWUgPSBuZXcgQ3N0cigpO1xyXG4gICAgICAgIGxldCBxID0gbmV3VHJlZTtcclxuICAgICAgICBzdGFjazIucHVzaChuZXdUcmVlKTtcclxuICAgICAgICBsZXQgcDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrMS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8g5ZCR5bem6LWw5Yiw5bC95aS0XHJcbiAgICAgICAgICAgIHdoaWxlICgocCA9IHN0YWNrMS5wZWVrKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sZWZ0Q2hpbGQpIHEubGVmdENoaWxkID0gbmV3IENzdHIoKTtcclxuICAgICAgICAgICAgICAgIHEgPSBxLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwID0gc3RhY2sxLnBvcCgpO1xyXG4gICAgICAgICAgICBxID0gc3RhY2syLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YWNrMS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBzdGFjazEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBxID0gc3RhY2syLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAucmlnaHRDaGlsZCkgcS5yaWdodENoaWxkID0gbmV3IENzdHIoKTtcclxuICAgICAgICAgICAgICAgIHEuZGF0YSA9IHAuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNiKHEsIHApO1xyXG4gICAgICAgICAgICAgICAgcSA9IHEucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAucmlnaHRDaGlsZCk7ICAvLyDlkJHlj7PkuIDmraVcclxuICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3VHJlZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLkuozlj4nmoJHkuK3nu5Pngrlw5ZKMceeahOacgOi/keelluWFiFxyXG4gICAgZmluZE5lYXJBbmNpZW50KHBOb2RlLCBxTm9kZSkge1xyXG4gICAgICAgIGxldCBwYXRoUCA9IGZpbmRQYXRoKHRoaXMsIHBOb2RlLCAwKTtcclxuICAgICAgICBsZXQgcGF0aFEgPSBmaW5kUGF0aCh0aGlzLCBxTm9kZSwgMCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBwYXRoUFtpXSA9PSBwYXRoUVtpXSAmJiBwYXRoUFtpXTsgaSsrKTtcclxuICAgICAgICByZXR1cm4gcGF0aFBbLS1pXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0b2RvXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLkuIDmo7Xkuozlj4nmoJHnmoTnuYHojILluqZcclxuICAgIGx1c2hEZWdyZWUoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50QXJyID0gW107XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh7XHJcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXHJcbiAgICAgICAgICAgIGxheWVyOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8g5Yip55So5bGC5bqP6YGN5Y6G5p2l57uf6K6h5ZCE5bGC55qE57uT54K55pWwXHJcbiAgICAgICAgbGV0IHI7XHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgciA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgY291bnRBcnJbci5sYXllcl0gPSAoY291bnRBcnJbci5sYXllcl0gfHwgMCkgKyAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIubm9kZS5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiByLm5vZGUubGVmdENoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChyLm5vZGUucmlnaHRDaGlsZClcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHIubm9kZS5yaWdodENoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmnIDlkI7kuIDkuKrpmJ/liJflhYPntKDmiYDlnKjlsYLlsLHmmK/moJHnmoTpq5jluqZcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gci5sYXllcjtcclxuICAgICAgICBsZXQgbWF4ID0gY291bnRBcnJbMF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGNvdW50QXJyW2ldOyBpKyspXHJcbiAgICAgICAgICAgIC8vIOaxguWxguacgOWkp+e7k+eCueaVsFxyXG4gICAgICAgICAgICBpZiAoY291bnRBcnJbaV0gPiBtYXgpIG1heCA9IGNvdW50QXJyW2ldO1xyXG5cclxuICAgICAgICByZXR1cm4gaGVpZ2h0ICogbWF4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguagkee7k+eCueeahOWtkOWtmeaAu+aVsOWhq+WFpWRlc2NOdW3ln5/kuK3vvIzlubbov5Tlm55cclxuICAgIGRlc2NOdW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xyXG4gICAgICAgICAgICBsZXQgZDtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIGVsc2UgZCA9IHJlY3Vyc2Uobm9kZS5sZWZ0Q2hpbGQpICsgcmVjdXJzZShub2RlLnJpZ2h0Q2hpbGQpICsgMjtcclxuXHJcbiAgICAgICAgICAgIG5vZGUuZGVzY051bSA9IGQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICB9KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreS6jOWPieagkeaYr+WQpuWujOWFqOS6jOWPieagkVxyXG4gICAgc3RhdGljIGlzRnVsbEJpbmFyeVRyZWUodHJlZSkge1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIGxldCBmbGFnID0gMDtcclxuICAgICAgICBxdWV1ZS5lblF1ZXVlKHRyZWUpO1xyXG5cclxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICBsZXQgcCA9IHF1ZXVlLmRlUXVldWUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcCkgZmxhZyA9IDE7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIOaxguS7jnRyZWXliLBub2Rl57uT54K56Lev5b6E55qE6YCS5b2S566X5rOVXHJcbmZ1bmN0aW9uIGZpbmRQYXRoKHRyZWUsIG5vZGUsIGkgPSAwKSB7XHJcbiAgICBsZXQgcGF0aCA9IFtdO1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgdm9pZCBmdW5jdGlvbiByZWN1cnNlKHRyZWUsIGkpIHtcclxuICAgICAgICBpZiAodHJlZSA9PSBub2RlKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGF0aFtpXSA9IHRyZWU7XHJcbiAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSByZWN1cnNlKHRyZWUubGVmdENoaWxkLCBpICsgMSk7XHJcbiAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCAmJiAhZm91bmQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCBpICsgMSk7XHJcbiAgICAgICAgaWYgKCFmb3VuZCkgcGF0aFtpXSA9IG51bGw7XHJcbiAgICB9KHRyZWUsIGkpO1xyXG5cclxuICAgIHJldHVybiBwYXRoO1xyXG59XHJcblxyXG5sZXQgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzOycpKCk7XHJcblxyXG4vLyDmsYLmt7HluqbnrYnkuo7moJHnmoTpq5jluqblh4/kuIDnmoTmnIDpnaDlt6bnmoTnu5PngrlcclxuZnVuY3Rpb24gcHJpbnRQYXRoX21heERlcHRoUzEodHJlZSl7XHJcbiAgICBsZXQgbWF4aCA9IHRyZWUuZ2V0RGVwdGgoKTtcclxuICAgIGxldCBwYXRoID0gW107XHJcblxyXG4gICAgaWYgKG1heGggPCAyKSByZXR1cm4gZmFsc2U7XHJcbiAgICBmaW5kX2godHJlZSwgMSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZF9oKHRyZWUsIGgpIHtcclxuICAgICAgICBwYXRoW2hdID0gdHJlZTtcclxuXHJcbiAgICAgICAgaWYgKGggPT0gbWF4aCAtIDEpIHtcclxuICAgICAgICAgICAgbGV0IHMgPSAnICc7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBwYXRoW2ldOyBpKyspIHMgKz0gcGF0aFtpXS5kYXRhICsgKHBhdGhbaSArIDFdID8gJyAtPiAnIDogJycpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgZmluZF9oKHRyZWUubGVmdENoaWxkLCBoICsgMSk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIGZpbmRfaCh0cmVlLnJpZ2h0Q2hpbGQsIGggKyAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhdGhbaF0gPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgdHJlZSA9IFsxLCAyLCAzLCA0LCA1LCAsIDYsICwgLCA3XTtcclxudmFyIHRlc3QgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG50ZXN0LmNyZWF0ZUJpbmFyeVRyZWUodHJlZSk7XHJcblxyXG5jb25zb2xlLmxvZygnaXRlcmF0b3I6ICcpO1xyXG5mb3IobGV0IHggb2YgdGVzdCl7XHJcbiAgICBjb25zb2xlLmxvZyh4KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiDmoJHnmoQz56eN5bi455So6ZO+6KGo57uT5p6EXHJcbiAqL1xyXG5cclxuLy8gMS7lj4zkurLooajnpLrms5VcclxuLy8g5LyY54K577yacGFyZW50KHRyZWUsIHgp5pON5L2c5Y+v5Lul5Zyo5bi46YeP5pe26Ze05YaF5a6e546wXHJcbi8vIOe8uueCue+8muaxgue7k+eCueeahOWtqeWtkOaXtumcgOimgemBjeWOhuaVtOS4que7k+aehFxyXG5leHBvcnQgY2xhc3MgUGFyZW50VHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVwdGgoKSB7XHJcbiAgICAgICAgbGV0IG1heERlcHRoID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBkZXAgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+PSAwOyBqID0gdGhpcy5ub2Rlc1tpXS5wYXJlbnQpIGRlcCsrO1xyXG4gICAgICAgICAgICBpZiAoZGVwID4gbWF4RGVwdGgpIG1heERlcHRoID0gZGVwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1heERlcHRoO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBQYXJlbnRUcmVlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgcGFyZW50ID0gMCkge1xyXG4gICAgICAgIC8vIHR5cGU6IFBhcmVudFRyZWVcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIC8vIOWPjOS6suS9jee9ruWfnyB7TnVtYmVyfVxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgcHQgPSBuZXcgUGFyZW50VHJlZSgpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnUicsIC0xKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdBJywgMCkpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnQicsIDApKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0MnLCAwKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdEJywgMSkpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRScsIDEpKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0YnLCAzKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdHJywgNikpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnSCcsIDYpKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0knLCA2KSk7XHJcblxyXG5cclxuLy8g5a2p5a2Q6KGo56S65rOVXHJcblxyXG5leHBvcnQgY2xhc3MgQ2hpbGRUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREZXB0aCgpIHtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN1YkRlcHRoKHJvb3RJbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYubm9kZXNbcm9vdEluZGV4XSkgcmV0dXJuIDE7XHJcblxyXG4gICAgICAgICAgICBsZXQgc2QgPSAxO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gc2VsZi5ub2Rlc1tyb290SW5kZXhdOyBwOyBwID0gcC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHN1YkRlcHRoKHAuY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPiBzZCkgc2QgPSBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2QgKyAxO1xyXG4gICAgICAgIH0odGhpcy5kYXRhWzBdKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhXHJcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gZmlyc3RDaGlsZCDlranlrZDpk77ooajlpLTmjIfpkohcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBDaGlsZFRyZWVCb3gge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIGZpcnN0Q2hpbGQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICog5a2p5a2Q57uT54K5XHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGlsZFxyXG4gKiBAcGFyYW0ge0NoaWxkVHJlZU5vZGV9IG5leHRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBDaGlsZFRyZWVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoaWxkID0gbnVsbCwgbmV4dCA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcclxuICAgIH1cclxufVxyXG5cclxuLypcclxuIOWtqeWtkOihqOekuuazleS+v+S6jua2ieWPiuWtqeWtkOeahOaTjeS9nOeahOWunueOsO+8jOS9huS4jemAgueUqOS6jnBhcmVudOaTjeS9nOOAglxyXG4g5oiR5Lus5Y+v5Lul5oqK5Y+M5Lqy6KGo56S65rOV5ZKM5a2p5a2Q6KGo56S65rOV57uT5ZCI6LW35p2l44CCXHJcbiAqL1xyXG5cclxuXHJcbi8vIOWtqeWtkOWFhOW8n+ihqOekuuazlSjkuozlj4nmoJHooajnpLrms5UpXHJcbi8vIOWPr+WinuiuvuS4gOS4qnBhcmVudOWfn+WunueOsHBhcmVudOaTjeS9nFxyXG5leHBvcnQgY2xhc3MgQ2hpbGRTaWJsaW5nVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgZmlyc3RDaGlsZCA9IG51bGwsIG5leHRTaWJsaW5nID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gZmlyc3RDaGlsZDtcclxuICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6L6T5Ye65a2p5a2Q5YWE5byf6ZO+6KGo6KGo56S655qE5qCR55qE5ZCE6L65XHJcbiAgICBwcmludCgpIHtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHRoaXMuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJyVjICVjJywgdGhpcy5kYXRhLCBjaGlsZC5kYXRhKTtcclxuICAgICAgICAgICAgY2hpbGQucHJpbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5a2p5a2Q5YWE5byf6ZO+6KGo6KGo56S655qE5qCR55qE5Y+25a2Q5pWw55uuXHJcbiAgICBsZWFmQ291bnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0Q2hpbGQpIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHRoaXMuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ICs9IGNoaWxkLmxlYWZDb3VudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5qCR55qE5bqmXHJcbiAgICBnZXREZWdyZWUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0Q2hpbGQpIHJldHVybiAwO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGVncmVlID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIGRlZ3JlZSsrO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkID0gcC5nZXREZWdyZWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkID4gZGVncmVlKSBkZWdyZWUgPSBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVncmVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXREZXB0aCgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gZ2xvYmFsKSByZXR1cm4gMDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG1heGQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy5maXJzdENoaWxkOyBwOyBwID0gcC5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGQgPSBwLmdldERlcHRoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG1heGQpIG1heGQgPSBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWF4ZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZS5qc1xuICoqLyIsIi8qKlxyXG4gKiDmoIhcclxuICpcclxuICog5piv6ZmQ5a6a5LuF5Zyo6KGo5bC+6L+b6KGM5o+S5YWl5oiW5Yig6Zmk5pON5L2c55qE57q/5oCn6KGo44CC6KGo5bC+5Li65qCI6aG277yIdG9w77yJ77yM6KGo5aS05Li65qCI5bqV77yIYm90dG9t77yJ77yM5LiN5ZCr5YWD57Sg55qE56m66KGo5Li656m65qCI44CCXHJcbiAqIOagiOWPiOensOS4uuWQjui/m+WFiOWHuu+8iGxhc3QgaW4gZmlyc3Qgb3V077yJ55qE57q/5oCn6KGo44CCXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIOmhuuW6j+agiFxyXG4gKiDmoIjnmoTpobrluo/lrZjlgqjnu5PmnoTmmK/liKnnlKjkuIDnu4TlnLDlnYDov57nu63nmoTlrZjlgqjljZXlhYPkvp3mrKHlrZjmlL7oh7PmoIjlupXliLDmoIjpobbnmoTlhYPntKDvvIzlkIzml7bpmYTorr7mjIfpkoh0b3DmjIfnpLrmoIjpobblhYPntKDlnKjpobrluo/moIjkuK3nmoTkvY3nva7jgIJcclxuICpcclxuICovXHJcblxyXG4vLyDmoIjnmoTpk77lvI/ooajnpLpcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50b3AgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2l6ZSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBpc0VtcHR5KCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgcHVzaCAoZGF0YSkge1xyXG4gICAgICAgIGxldCBub2RlID0ge1xyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBuZXh0OiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy50b3A7XHJcbiAgICAgICAgdGhpcy50b3AgPSBub2RlO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICB9XHJcbiAgICBwZWVrICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b3AgPT09IG51bGwgP1xyXG4gICAgICAgICAgICBudWxsIDpcclxuICAgICAgICAgICAgdGhpcy50b3AuZGF0YTtcclxuICAgIH1cclxuICAgIHBvcCAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IG91dCA9IHRoaXMudG9wO1xyXG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AubmV4dDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dC5kYXRhO1xyXG4gICAgfVxyXG4gICAgY2xlYXIgKCkge1xyXG4gICAgICAgIHRoaXMudG9wID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy50b3A7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnNpemU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSBjdXJyZW50LmRhdGE7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuXHJcbnN0YWNrLnB1c2goMSk7XHJcbnN0YWNrLnB1c2goJ2FzZCcpO1xyXG5cclxuc3RhY2sucG9wKCk7XHJcbnN0YWNrLnB1c2goe2E6IDF9KTtcclxuY29uc29sZS5sb2coc3RhY2spO1xyXG5cclxuLyoqXHJcbiAqIOi/memHjOeUqOWtl+espuS4snRyYWlu6KGo56S654Gr6L2m77yMSOihqOekuuehrOW4re+8jFPooajnpLrova/luK1cclxuICogQHBhcmFtIHtTdHJpbmd9IHRyYWluXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFpbkFycmFuZ2UodHJhaW4pe1xyXG4gICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICBsZXQgcSA9IFtdO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IGogPSAwO1xyXG5cclxuICAgIHdoaWxlKHRyYWluW2ldKXtcclxuICAgICAgICBpZih0cmFpbltpXSA9PT0gJ0gnKSBzdGFjay5wdXNoKHRyYWluW2ldKTtcclxuICAgICAgICBlbHNlIHFbaisrXSA9IHRyYWluW2ldO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZShzdGFjay5sZW5ndGgpe1xyXG4gICAgICAgIGxldCBjID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcVtqKytdID0gYztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcSArICcnO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygndHJhaW5BcnJhbmdlOiAnICsgdHJhaW5BcnJhbmdlKCdIU1NIU1NTSEhISEhTJykpOyAgLy8gdHJhaW5BcnJhbmdlOiBTLFMsUyxTLFMsUyxILEgsSCxILEgsSCxIXHJcblxyXG5cclxuLy8g5Yik5pat5a2X56ym5Liy5Lit4oCcJuKAneWJjeWSjOKAnCbigJ3lkI7pg6jliIbmmK/lkKbkuLrpgIbkuLLvvIxcIkBcIuihqOekuue7k+adn+espu+8jOaYr+WImei/lOWbnnRydWXvvIzlkKbliJnov5Tlm55mYWxzZVxyXG5mdW5jdGlvbiBpc1JldmVyc2Uoc3RyKXtcclxuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgbGV0IGkgPSAwO1xyXG5cclxuICAgIHdoaWxlKHN0cltpXSAhPT0gJyYnKXtcclxuICAgICAgICBpZihzdHJbaV0gPT09ICdAJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHN0YWNrLnB1c2goc3RyW2ldKTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgaSsrO1xyXG5cclxuICAgIHdoaWxlKHN0cltpXSAhPT0gJ0AnKSB7XHJcbiAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgcyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGlmKHMgIT09IHN0cltpXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIXN0YWNrLmxlbmd0aDtcclxufVxyXG5cclxuY29uc29sZS5sb2coJ2lzUmV2ZXJzZTogJyArIGlzUmV2ZXJzZSgnYWJjZCZkY2JhQGEnKSk7ICAvLyB0cnVlXHJcblxyXG5cclxuLy8g5pWw5YC86L+b5Yi26L2s5o2iXHJcbi8vIOWFrOW8j++8miBOID0gKE4gLyBkKSAqIGQgKyBOICUgZFxyXG4vLyBO77ya5Y2B6L+b5Yi25pWw5YC877yMIGTvvJrpnIDopoHovazmjaLnmoTov5vliLbmlbBcclxuZnVuY3Rpb24gbnVtVHJhbnNmb3JtKG51bWJlciwgcmFkKSB7XHJcbiAgICBsZXQgcyA9IG5ldyBTdGFjaygpO1xyXG5cclxuICAgIHdoaWxlIChudW1iZXIpIHtcclxuICAgICAgICBzLnB1c2gobnVtYmVyICUgcmFkKTtcclxuICAgICAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIgLyA4LCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFyciA9IFtdO1xyXG4gICAgd2hpbGUgKHMudG9wKSB7XHJcbiAgICAgICAgYXJyLnB1c2gocy5wb3AoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhhcnIuam9pbignJykpO1xyXG59XHJcblxyXG5udW1UcmFuc2Zvcm0oMTM0OCwgOCk7XHJcbm51bVRyYW5zZm9ybSgxMzQ4LCAyKTtcclxuXHJcblxyXG4vLyDmi6zlj7fljLnphY3mo4Dmn6VcclxuZnVuY3Rpb24gYnJhY2tldHNNYXRjaChzdHIpIHtcclxuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgbGV0IHRleHQgPSAnJztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHJbaV07XHJcbiAgICAgICAgaWYgKGMgPT09ICdbJykge1xyXG4gICAgICAgICAgICBzdGFjay5wdXNoKGMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoIHx8IHN0YWNrLnBvcCgpICE9PSAnWycpIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBicmFja2V0czonICsgYyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dCArPSBjO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhicmFja2V0c01hdGNoKCdbYXNkXScpKTtcclxuXHJcbmZ1bmN0aW9uIE1hdGNoZXIobGVmdCwgcmlnaHQpIHtcclxuICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB0aGlzLnN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbn1cclxuTWF0Y2hlci5wcm90b3R5cGUgPSB7XHJcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGMgPSBzdHJbaV07XHJcbiAgICAgICAgICAgIGlmIChjID09PSB0aGlzLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChjKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSB0aGlzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2sucG9wKCkgIT09IHRoaXMubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBicmFja2V0czonICsgYyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gJywnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG59O1xyXG5sZXQgbSA9IG5ldyBNYXRjaGVyKCd7JywgJ30nKTtcclxubS5tYXRjaCgnW3sxMjN9MTIzJyk7XHJcblxyXG5mdW5jdGlvbiBMaW5lRWRpdG9yKHN0cikge1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgdGhpcy5zdHIgPSBzdHIgfHwgJyc7XHJcbn1cclxuTGluZUVkaXRvci5wcm90b3R5cGUgPSB7XHJcbiAgICBnZXRSZXN1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnN0YWNrO1xyXG4gICAgICAgIGxldCBzdHIgPSB0aGlzLnN0cjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjID0gc3RyW2ldO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gc3RhY2subGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnQuZGF0YSArIHJlc3VsdDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgbGUgPSBuZXcgTGluZUVkaXRvcignd2hsaSMjaWxyI2UocyMqcylcXFxyXG4gICAgXFxub3V0Y2hhQHB1dGNoYXIoKnM9IysrKScpO1xyXG5jb25zb2xlLmxvZyhsZS5nZXRSZXN1bHQoKSk7XHJcblxyXG5cclxubGV0IHByaW90eSA9IHtcclxuICAgIFwiK1wiOiAxLFxyXG4gICAgXCItXCI6IDEsXHJcbiAgICBcIiVcIjogMixcclxuICAgIFwiKlwiOiAyLFxyXG4gICAgXCIvXCI6IDIsXHJcbiAgICBcIl5cIjogMyxcclxuICAgIFwiKFwiOiAwLFxyXG4gICAgXCIpXCI6IDAsXHJcbiAgICBcImBcIjogLTFcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRvb3Aob3AsIG9wbjEsIG9wbjIpIHtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gb3BuMSArIG9wbjI7XHJcbiAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgLSBvcG4yO1xyXG4gICAgICAgIGNhc2UgXCIqXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBvcG4xICogb3BuMjtcclxuICAgICAgICBjYXNlIFwiL1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gb3BuMSAvIG9wbjI7XHJcbiAgICAgICAgY2FzZSBcIiVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgJSBvcG4yO1xyXG4gICAgICAgIGNhc2UgXCJeXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhvcG4xLCBvcG4yKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb3Bjb21wKGEsIGIpIHtcclxuICAgIHJldHVybiBwcmlvdHlbYV0gLSBwcmlvdHlbYl07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbEluZml4RXhwcmVzc2lvbihleHApIHtcclxuICAgIGxldCBjcyA9IFtdO1xyXG4gICAgbGV0IG5zID0gW107XHJcbiAgICBleHAgPSBleHAucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xyXG4gICAgZXhwICs9ICdgJztcclxuICAgIGlmIChleHBbMF0gPT09ICctJykge1xyXG4gICAgICAgIGV4cCA9IFwiMFwiICsgZXhwO1xyXG4gICAgfVxyXG4gICAgbGV0IGM7XHJcbiAgICBsZXQgb3A7XHJcbiAgICBsZXQgb3BuMTtcclxuICAgIGxldCBvcG4yO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHAubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gZXhwW2ldO1xyXG4gICAgICAgIC8vIOWmguaenOaYr+aTjeS9nOesplxyXG4gICAgICAgIGlmIChjIGluIHByaW90eSkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzlj7PovrnkuI3mmK/lt6bmi6zlj7fkuJTmk43kvZznrKbmoIjnmoTmoIjpobblhYPntKDkvJjlhYjmnYPmr5Tlj7PovrnlpKdcclxuICAgICAgICAgICAgLy8g5b6q546v6YGN5Y6G6L+b6KGM6L+e57ut6L+Q566XXHJcbiAgICAgICAgICAgIHdoaWxlIChjICE9ICcoJyAmJiBjcy5sZW5ndGggJiYgb3Bjb21wKGNzW2NzLmxlbmd0aCAtIDFdLCBjKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlh7rmoIjnmoTmk43kvZznrKZcclxuICAgICAgICAgICAgICAgIG9wID0gY3MucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkuI3mmK/lt6bmi6zlj7fmiJbogIXlj7Pmi6zlj7fvvIzor7TmmI7mmK/ov5DnrpfnrKZcclxuICAgICAgICAgICAgICAgIGlmIChvcCAhPSAnKCcgJiYgb3AgIT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Ye65qCI5L+d5a2Y5pWw5a2X55qE5qCI55qE5Lik5Liq5YWD57SgXHJcbiAgICAgICAgICAgICAgICAgICAgb3BuMiA9IG5zLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wbjEgPSBucy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlsIbkuI7mk43kvZznrKbov5DnrpflkI7nmoTnu5Pmnpzkv53lrZjliLDmoIjpobZcclxuICAgICAgICAgICAgICAgICAgICBucy5wdXNoKGRvb3Aob3AsIG9wbjEsIG9wbjIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDlpoLmnpzlj7PovrnkuI3mmK/lj7Pmi6zlj7fvvIzkv53lrZjliLDmk43kvZznrKbmoIjkuK1cclxuICAgICAgICAgICAgaWYgKGMgIT0gJyknKSBjcy5wdXNoKGMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOWkmuS9jeaVsOeahOaVsOWtl+eahOaDheWGtVxyXG4gICAgICAgICAgICB3aGlsZSAoIShleHBbaV0gaW4gcHJpb3R5KSkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgYyArPSBleHBbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbnMucHVzaChwYXJzZUZsb2F0KGMpKTtcclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBucy5sZW5ndGggPyBuc1swXSA6IE5hTjtcclxufVxyXG5cclxubGV0IGV4cDEgPSBjYWxJbmZpeEV4cHJlc3Npb24oJzUrMyo0LzItMl4zKzUlMicpO1xyXG5jb25zb2xlLmxvZyhleHAxKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU3RhY2svaW5kZXguanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS80LzEyLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9Tb3J0L2RlZmF1bHRDb21wYXJpc2lvbi5qc1xuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91dGlsL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgbWQ1ID0gdG9Db25zdHJ1Y3RvcihyZXF1aXJlKCcuL21kNScpKVxudmFyIHJtZDE2MCA9IHRvQ29uc3RydWN0b3IocmVxdWlyZSgncmlwZW1kMTYwJykpXG5cbmZ1bmN0aW9uIHRvQ29uc3RydWN0b3IgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXVxuICAgIHZhciBtPSB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICAgICAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBkaWdlc3Q6IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycylcbiAgICAgICAgdmFyIHIgPSBmbihidWYpXG4gICAgICAgIGJ1ZmZlcnMgPSBudWxsXG4gICAgICAgIHJldHVybiBlbmMgPyByLnRvU3RyaW5nKGVuYykgOiByXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGlmKCdtZDUnID09PSBhbGcpIHJldHVybiBuZXcgbWQ1KClcbiAgaWYoJ3JtZDE2MCcgPT09IGFsZykgcmV0dXJuIG5ldyBybWQxNjAoKVxuICByZXR1cm4gY3JlYXRlSGFzaChhbGcpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9jcmVhdGUtaGFzaC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLlVJTlQzMiA9IHJlcXVpcmUoJy4vbGliL3VpbnQzMicpXG5leHBvcnRzLlVJTlQ2NCA9IHJlcXVpcmUoJy4vbGliL3VpbnQ2NCcpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3VpbnQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOW+queOr+mTvuihqO+8iGNpcmN1bGFyIGxpbmtlZCBsaXN077yJXHJcbiAqIOaYr+WPpuS4gOenjeW9ouW8j+eahOmTvuW8j+WtmOWCqOe7k+aehOOAguWug+eahOeJueeCueaYr+ihqOS4reacgOWQjuS4gOS4que7k+eCueeahOaMh+mSiOWfn+aMh+WQkeWktOe7k+eCue+8jOaVtOS4quihqOW9ouaIkOS4gOS4queOr+OAglxyXG4gKiDlvqrnjq/pk77ooajnmoTmk43kvZzlkoznur/mgKfpk77ooajln7rmnKzkuIDoh7TvvIzku4XmnInnu4blvq7lt67liKvjgIJcclxuICovXHJcblxyXG4vKipcclxuICog5Y+M5ZCR6ZO+6KGoXHJcbiAqXHJcbiAqIOWPjOWQkemTvuihqOaYr+S4uuS6huWFi+acjeWNlemTvuihqOi/meenjeWNleWQkeaAp+eahOe8uueCueOAglxyXG4gKiDlj4zlkJHpk77ooajnmoTnu5PngrnkuK3mnInkuKTkuKrmjIfpkojln5/vvIzlhbbkuIDmjIflkJHnm7TmjqXlkI7nu6fvvIzlj6bkuIDmjIflkJHnm7TmjqXliY3otovjgIJcclxuICpcclxuICog5Y+M5ZCR6ZO+6KGo5Lmf5Y+v5Lul5pyJ5b6q546v6KGo44CCXHJcbiAqL1xyXG5cclxuY2xhc3MgTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmV2ID0gbnVsbCwgbmV4dCA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3Ioc3FMaXN0LCBjb21wYXJlID0gZGVmYXVsdENvbXBhcmUpIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xyXG5cclxuICAgICAgICBpZihzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHNxTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpe1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICB5aWVsZCBjdXJyZW50LmRhdGE7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCl7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1c2goZGF0YSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZGF0YSBhcmd1bWVudCByZXF1aXJlZCcpO1xyXG5cclxuICAgICAgICArK3RoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgTm9kZShkYXRhLCB0aGlzLnRhaWwsIG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICB1bnNoaWZ0KGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgYXJndW1lbnQgcmVxdWlyZWQnKTtcclxuXHJcbiAgICAgICAgKyt0aGlzLnNpemU7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gbmV3IE5vZGUoZGF0YSwgbnVsbCwgdGhpcy5oZWFkKTtcclxuICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC0tdGhpcy5zaXplO1xyXG5cclxuICAgICAgICB0aGlzLnRhaWwucHJldi5uZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcclxuICAgIH1cclxuXHJcbiAgICBzaGlmdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAtLXRoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5oZWFkLm5leHQucHJldiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHVwZGF0ZShpbmRleCwgZGF0YSl7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmZpbmRCeUluZGV4KGluZGV4LCB0cnVlKTtcclxuICAgICAgICBub2RlLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZShkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgYXJndW1lbnQgcmVxdWlyZWQnKTtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoZGF0YSwgY3VycmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgLS10aGlzLnNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IHRoaXMudGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YWlsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldi5uZXh0ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2ID0gY3VycmVudC5wcmV2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaW5kZXhPZihkYXRhKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoZGF0YSwgY3VycmVudC5kYXRhKSkgcmV0dXJuIGluZGV4O1xyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kQnlJbmRleChpbmRleCA9IDAsIHJldHVybk5vZGUpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgaiA9IDA7XHJcblxyXG4gICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgaWYgKGorKyA9PT0gaW5kZXgpIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldHVybk5vZGUgPyBjdXJyZW50IDogY3VycmVudC5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGZvckVhY2goY2IgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY2IoY3VycmVudC5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBsZXQgbGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goY3VycmVudC5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b0pTT04oKSArICcnO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxubGV0IGEgPSBuZXcgRG91YmxlTGlua2VkTGlzdChbMiwgM10pO1xyXG5hLnVuc2hpZnQoMSk7XHJcbmEucHVzaCg0KTtcclxuY29uc29sZS5sb2coYS5pbmRleE9mKDQpKTtcclxuY29uc29sZS5sb2coYS5maW5kQnlJbmRleCgyKSk7XHJcblxyXG5mb3IobGV0IGl0ZW0gb2YgYSl7XHJcbiAgICBjb25zb2xlLmxvZyhpdGVtKTtcclxufVxyXG5cclxuYS5wb3AoKTtcclxuYS5zaGlmdCgpO1xyXG5hLnJlbW92ZSgyKTtcclxuYS5yZW1vdmUoMzIpO1xyXG5hLnJlbW92ZSgzKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9Eb3VibGVMaW5rZWRMaXN0LmpzXG4gKiovIiwiLyoqXHJcbiAqIOeUseS6jumTvuihqOWcqOepuumXtOeahOWQiOeQhuWIqeeUqOS4iuWSjOaPkuWFpe+8jOWIoOmZpOaXtuS4jemcgOimgeenu+WKqOetieeahOacieeCue+8jOWboOatpOWcqOW+iOWkmuWcuuWQiOS4i++8jOWug+aYr+e6v+aAp+ihqOeahOmmlumAieWtmOWCqOe7k+aehOOAgueEtuiAjO+8jOWug+S5n+WtmOWcqOedgOWunueOsOafkOS6m+WfuuacrOaTjeS9nO+8jOWmguaxgue6v+aAp+ihqOmVv+W6puaXtuS4jeWmgumhuuW6j+WtmOWCqOe7k+aehOeahOe8uueCue+8m+WPpuS4gOaWuemdou+8jOeUseS6juWcqOmTvuihqOS4re+8jOe7k+eCueS5i+mXtOeahOWFs+ezu+S9v+eUqOaMh+mSiOadpeihqOekuu+8jOWImeaVsOaNruWFg+e0oOWcqOe6v+aAp+ihqOS4reeahOKAnOS9jeW6j+KAneeahOamguW/teW3sua3oeWMlu+8jOiAjOiiq+aVsOaNruWFg+e0oOWcqOe6v+aAp+mTvuihqOS4reeahOKAnOS9jee9ruKAneaJgOS7o+abv+OAguS4uuatpO+8jOS7juWunumZheWHuuWPkemHjeaWsOWumuS5iee6v+aAp+mTvuihqOWPiuWFtuWfuuacrOaTjeS9nFxyXG4gKi9cclxuXHJcbmNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIG5leHQgPSBudWxsKXtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3Ioc3FMaXN0KXtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChzcUxpc3QpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSlcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaChzcUxpc3RbaV0pO1xyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRpYyBtZXJnZUxpc3QgKGEsIGIsIGNvbXBhcmUgPSBjb21wRm4pIHtcclxuICAgICAgICBsZXQgaGEgPSBhLmhlYWQ7XHJcbiAgICAgICAgbGV0IGhiID0gYi5oZWFkO1xyXG4gICAgICAgIGxldCBwYSA9IGhhO1xyXG4gICAgICAgIGxldCBwYiA9IGhiO1xyXG4gICAgICAgIGxldCBjID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgICAgICBsZXQgcTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHBhICYmIHBiKSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhMSA9IHBhLmRhdGE7XHJcbiAgICAgICAgICAgIGxldCBkYXRhMiA9IHBiLmRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmUoZGF0YTEsIGRhdGEyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGhlYWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgcSA9IGEuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgbm9kZSB0byBjIGxpbmtlZExpc3RcclxuICAgICAgICAgICAgICAgIGMuYXBwZW5kKHEpO1xyXG4gICAgICAgICAgICAgICAgcGEgPSBhLmhlYWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxID0gYi5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XHJcbiAgICAgICAgICAgICAgICBwYiA9IGIuaGVhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhKSBjLmFwcGVuZChwYSk7XHJcbiAgICAgICAgZWxzZSBjLmFwcGVuZChwYik7XHJcblxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRlbGV0ZSBmaXJzdCBlbGVtZW50IGFuZCByZXR1cm4gaXRcclxuICAgIHNoaWZ0ICgpIHtcclxuICAgICAgICBsZXQgaGVhZCA9IHRoaXMuaGVhZDtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcclxuICAgICAgICBoZWFkLm5leHQgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgfVxyXG5cclxuICAgIHBvcCgpe1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgZWxlbTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFpbCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzLnRhaWwuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHByZXZpb3VzO1xyXG5cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICBlbGVtID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHRoaXMudGFpbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFwcGVuZCBub2RlXHJcbiAgICBhcHBlbmQgKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGRhdGFcclxuICAgIHB1c2ggKGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRhaWwuZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlIGRhdGFcclxuICAgIHJlbW92ZSAoZGF0YSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgZWxlbTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGN1cnJlbnQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLnRhaWwpIHRoaXMudGFpbCA9IHByZXZpb3VzO1xyXG5cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICBlbGVtID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHRoaXMudGFpbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGluZGV4T2YoZGF0YSl7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YSA9PT0gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHVuc2hpZnQgKGRhdGEpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgIHRlbXAubmV4dCA9IHRoaXMuaGVhZDtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgaW5zZXJ0QWZ0ZXIgKHRhcmdldCwgZGF0YSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEgPT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIHRlbXAubmV4dCA9IGN1cnJlbnQubmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy50YWlsKSB0aGlzLnRhaWwgPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXRlbSAoaW5kZXgpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKC0taW5kZXggPT09IDApIHJldHVybiBjdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWFjaCAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XHJcblxyXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50Lm5leHQpXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjdXJyZW50KSkgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCl7XHJcbiAgICAgICAgZm9yKGxldCBjdXJyZW50ID0gdGhpcy5oZWFkOyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5uZXh0KXtcclxuICAgICAgICAgICAgeWllbGQgY3VycmVudC5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaXplICgpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgc2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICsrc2l6ZTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBsZXQgc3RyID0gJyc7XHJcblxyXG4gICAgICAgIHRoaXMuZWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBzdHIgKz0gbm9kZS5kYXRhICsgKG5vZGUubmV4dCA/ICcsJyA6ICcnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICBvcmRlckluc2VydCAoZGF0YSwgY21wKSB7XHJcbiAgICAgICAgY21wID0gdHlwZW9mIGNtcCA9PT0gJ2Z1bmN0aW9uJyA/IGNtcCA6IChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhID4gYilcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChhID09PSBiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHJldCA9IGNtcChkYXRhLCBjdXJyZW50LmRhdGEpO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzmj5LlhaXlhYPntKDlpKfkuo7lvZPliY3lhYPntKDvvIzlh4blpIfkuIvmrKHpgY3ljoZcclxuICAgICAgICAgICAgaWYgKHJldCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c562J5LqO77yM55u05o6l5o+S5YWl5Yiw5ZCO6Z2iXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5bCP5LqO5YiZ5o+S5YWl5Yiw5YmN6IqC54K55ZKM5b2T5YmN6IqC54K55LitXHJcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrlt7Lnu4/mmK/mjpLluo/kuobvvIzmiYDku6XkuI3pnIDopoHlpJrkvZnliKTmlq3kuoZcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWQgPT09IHByZXZpb3VzICYmIHByZXZpb3VzID09PSBjdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2hpZnQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEJldHdlZW4oZGF0YSwgcHJldmlvdXMsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmj5LlhaXliLDmnIDlkI7kuIDkuKrnu5PngrlcclxuICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgdGhpcy50YWlsID0gcHJldmlvdXMubmV4dDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QmV0d2VlbihkYXRhLCBhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmIChhID09IGIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhID09IG1lLmhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLnVuc2hpZnQoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGVtcC5uZXh0ID0gYjtcclxuICAgICAgICAgICAgICAgIGEubmV4dCA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDliKDpmaTlhYPntKDpgJLlop7mjpLliJfnmoTpk77ooajkuK3lgLzlpKfkuo5taW7vvIzkuJTlsI/kuo5tYXjnmoTmiYDmnInlhYPntKBcclxuICAgIGRlbGV0ZV9iZXR3ZWVuIChtaW4sIG1heCkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICAvLyBw5piv5pyA5ZCO5LiA5Liq5LiN5aSn5LqObWlu55qE5YWD57SgXHJcbiAgICAgICAgd2hpbGUgKHAubmV4dCAmJiBwLm5leHQuZGF0YSA8PSBtaW4pIHAgPSBwLm5leHQ7XHJcblxyXG4gICAgICAgIC8vIOWmguaenOi/mOacieavlG1pbuabtOWkp+eahOWFg+e0oFxyXG4gICAgICAgIGxldCBxO1xyXG4gICAgICAgIGlmIChwLm5leHQpIHtcclxuICAgICAgICAgICAgcSA9IHAubmV4dDtcclxuICAgICAgICAgICAgLy8gceaYr+esrOS4gOS4quS4jeWwj+S6jm1heOeahOWFg+e0oFxyXG4gICAgICAgICAgICB3aGlsZSAocSAmJiBxLmRhdGEgPCBtYXgpIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgICAgIHAubmV4dCA9IHE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGFzdCA9IHEgfHwgcDtcclxuICAgICAgICB3aGlsZSAobGFzdC5uZXh0KSBsYXN0ID0gbGFzdC5uZXh0O1xyXG4gICAgICAgIHRoaXMudGFpbCA9IGxhc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yig6Zmk5YWD57Sg6YCS5aKe5o6S5YiX55qE6ZO+6KGo55qE6YeN5aSN5YWD57SgXHJcbiAgICBkZWxldGVfZXF1YWwgKCkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBxID0gcC5uZXh0O1xyXG5cclxuICAgICAgICB3aGlsZSAocC5uZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIOW9k+ebuOmCu+S4pOWFg+e0oOS4jeebuOetieaXtu+8jHAscemDveWQkeWQjuenu1xyXG4gICAgICAgICAgICBpZiAocC5kYXRhICE9PSBxLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgICAgICBxID0gcC5uZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHEuZGF0YSA9PT0gcC5kYXRhKSBxID0gcS5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIOWIoOmZpFxyXG4gICAgICAgICAgICAgICAgcC5uZXh0ID0gcTtcclxuICAgICAgICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgICAgICAgICAgcSA9IHAubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXZlcnNlICgpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgcSA9IHAubmV4dDtcclxuICAgICAgICBsZXQgcyA9IHEubmV4dDtcclxuICAgICAgICBwLm5leHQgPSBudWxsO1xyXG5cclxuICAgICAgICB3aGlsZSAocy5uZXh0KSB7XHJcbiAgICAgICAgICAgIHEubmV4dCA9IHA7XHJcbiAgICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgICAgICBxID0gcztcclxuICAgICAgICAgICAgcyA9IHMubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEubmV4dCA9IHA7XHJcbiAgICAgICAgcy5uZXh0ID0gcTtcclxuICAgICAgICB0aGlzLmhlYWQgPSBzO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wRm4oYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcblxyXG5cclxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXHJcbmZ1bmN0aW9uIGludGVyc2VjdChsaXN0LCBiTGlzdCkge1xyXG4gICAgbGV0IGNMaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxuXHJcbiAgICBsZXQgcCA9IGxpc3QuaGVhZDtcclxuICAgIGxldCBxID0gYkxpc3QuaGVhZDtcclxuXHJcbiAgICB3aGlsZSAocCAmJiBxKSB7XHJcbiAgICAgICAgaWYgKHAuZGF0YSA8IHEuZGF0YSkgcCA9IHAubmV4dDtcclxuICAgICAgICBlbHNlIGlmIChxLmRhdGEgPiBxLmRhdGEpIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNMaXN0LnB1c2gocS5kYXRhKTtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgcSA9IHEubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNMaXN0O1xyXG59XHJcblxyXG4vLyDmsYLlhYPntKDpgJLlop7mjpLliJfnmoTnur/mgKfooahB5ZKMQueahOWFg+e0oOeahOS6pOmbhuW5tuWtmOWFpeWbnmFcclxuZnVuY3Rpb24gaW50ZXJzZWN0X3RydWUobGlzdCwgYkxpc3QpIHtcclxuICAgIGxldCBwID0gbGlzdC5oZWFkO1xyXG4gICAgbGV0IHEgPSBiTGlzdC5oZWFkO1xyXG4gICAgbGV0IHBjID0gbGlzdC5oZWFkO1xyXG5cclxuICAgIHdoaWxlIChwICYmIHEpIHtcclxuICAgICAgICBpZiAocC5kYXRhIDwgcS5kYXRhKSBwID0gcC5uZXh0O1xyXG4gICAgICAgIGVsc2UgaWYgKHAuZGF0YSA+IHEuZGF0YSkgcSA9IHEubmV4dDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGMuZGF0YSA9IHAuZGF0YTtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgcSA9IHEubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmICghcCB8fCAhcSkge1xyXG4gICAgICAgICAgICAgICAgcGMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnRhaWwgPSBwYztcclxuICAgICAgICAgICAgfSBlbHNlIHBjID0gcGMubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGMubmV4dCA9IG51bGw7XHJcbiAgICBsaXN0LnRhaWwgPSBwYztcclxufVxyXG5cclxuLy8gYe+8jGLvvIxj55qE5YWD57Sg5Z2H5piv6Z2e6YCS5YeP5o6S5YiXXHJcbi8vIOaxgmHpk77ooajkuK3pnZ5i6ZO+6KGo5ZKMY+mTvuihqOeahOS6pOmbhueahOWFg+e0oOOAglxyXG5mdW5jdGlvbiBpbnRlcnNlY3RfZGVsZXRlKGxpc3QsIGIsIGMpIHtcclxuICAgIGxldCBwID0gYi5oZWFkO1xyXG4gICAgbGV0IHEgPSBjLmhlYWQ7XHJcbiAgICBsZXQgciA9IGxpc3QuaGVhZDtcclxuXHJcbiAgICB3aGlsZSAocCAmJiBxICYmIHIpIHtcclxuICAgICAgICBpZiAocC5kYXRhIDwgcS5kYXRhKSBwID0gcC5uZXh0O1xyXG4gICAgICAgIGVsc2UgaWYgKHAuZGF0YSA+IHEuZGF0YSkgcSA9IHEubmV4dDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g56Gu5a6a5b6F5Yig6Zmk5YWD57SgXHJcbiAgICAgICAgICAgIGxldCBlbGVtID0gcC5kYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIuZGF0YSA9PT0gZWxlbSAmJiByID09PSBsaXN0LmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g56Gu5a6a5pyA5ZCO5LiA5Liq5bCP5LqOZWxlbeeahOWFg+e0oOaMh+mSiFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHIubmV4dCAmJiByLm5leHQuZGF0YSA8IGVsZW0pIHIgPSByLm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHIubmV4dC5kYXRhID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSByLm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOehruWumuesrOS4gOS4quWkp+S6jmVsZW3nmoTlhYPntKDmjIfpkohcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocyAmJiBzLmRhdGEgPT09IGVsZW0pIHMgPSBzLm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6ZmkcuWSjHPkuYvpl7TnmoTlhYPntKBcclxuICAgICAgICAgICAgICAgICAgICByLm5leHQgPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgPT09IGVsZW0pIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChxICYmIHEuZGF0YSA9PT0gZWxlbSkgcSA9IHEubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdC50YWlsID0gcjtcclxufVxyXG5cclxudmFyIGxpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5saXN0LnB1c2goJ2InKTtcclxubGlzdC51bnNoaWZ0KCdhJyk7XHJcbmxpc3QuaW5zZXJ0QWZ0ZXIoJ2InLCAnYycpO1xyXG5jb25zb2xlLmxvZyhsaXN0Lml0ZW0oMikpO1xyXG5jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShsaXN0KSk7XHJcbmxpc3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgaWYgKG5vZGUuZGF0YSA9PT0gJ2InKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2dldCBiIGluIGVhY2gnKTtcclxuICAgIH1cclxufSk7XHJcbmxpc3QucmVtb3ZlKCdjJyk7XHJcbmxpc3QucmVtb3ZlKCdhJyk7XHJcbmNvbnNvbGUubG9nKGxpc3QpO1xyXG5cclxubGV0IGxpc3QyID0gbmV3IExpbmtlZExpc3QoKTtcclxubGlzdDIucHVzaCgnYycpO1xyXG5saXN0Mi51bnNoaWZ0KCdkJyk7XHJcbmxpc3QyLmluc2VydEFmdGVyKCdkJywgJ2InKTtcclxuY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobGlzdDIpKTtcclxuXHJcbmxldCBsaXN0MyA9IExpbmtlZExpc3QubWVyZ2VMaXN0KGxpc3QsIGxpc3QyKTtcclxuY29uc29sZS5sb2cobGlzdDMpO1xyXG5cclxuXHJcbnZhciBsaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxuXHJcbmxpc3Qub3JkZXJJbnNlcnQoNSk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoMik7XHJcbmxpc3Qub3JkZXJJbnNlcnQoMyk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoMSk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNCk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNCk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNik7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNik7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNyk7XHJcblxyXG5saXN0LmRlbGV0ZV9iZXR3ZWVuKDUsIDgpO1xyXG5jb25zb2xlLmxvZygnZGVsZXRlLWJldHdlZW46ICAnKTtcclxuY29uc29sZS5sb2cobGlzdCk7XHJcblxyXG5saXN0Lm9yZGVySW5zZXJ0KDIpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDMpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDEpO1xyXG5cclxubGlzdC5kZWxldGVfZXF1YWwoKTtcclxuY29uc29sZS5sb2cobGlzdCk7XHJcblxyXG5saXN0LnJldmVyc2UoKTtcclxuY29uc29sZS5sb2cobGlzdCk7XHJcblxyXG5sZXQgYSA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbmEub3JkZXJJbnNlcnQoMSk7XHJcbmEub3JkZXJJbnNlcnQoMyk7XHJcbmEub3JkZXJJbnNlcnQoNSk7XHJcbmEub3JkZXJJbnNlcnQoNyk7XHJcbmEub3JkZXJJbnNlcnQoOSk7XHJcblxyXG5sZXQgYiA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbmIub3JkZXJJbnNlcnQoMSk7XHJcbmIub3JkZXJJbnNlcnQoNSk7XHJcbmIub3JkZXJJbnNlcnQoOSk7XHJcbmIub3JkZXJJbnNlcnQoMTMpO1xyXG5iLm9yZGVySW5zZXJ0KDE3KTtcclxuY29uc29sZS5sb2coaW50ZXJzZWN0KGEsIGIpKTtcclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdF90cnVlKGEsIGIpKTtcclxuXHJcbmEgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5hLm9yZGVySW5zZXJ0KDEpO1xyXG5hLm9yZGVySW5zZXJ0KDMpO1xyXG5hLm9yZGVySW5zZXJ0KDUpO1xyXG5hLm9yZGVySW5zZXJ0KDcpO1xyXG5hLm9yZGVySW5zZXJ0KDkpO1xyXG5cclxubGV0IHRlc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDEpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDIpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDMpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDQpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDUpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDYpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDkpO1xyXG5cclxuaW50ZXJzZWN0X2RlbGV0ZSh0ZXN0LCBhLCBiKTtcclxuY29uc29sZS5sb2codGVzdCk7XHJcblxyXG52YXIgcG9wVGVzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbnBvcFRlc3QucHVzaCgxKTtcclxucG9wVGVzdC5wdXNoKDIpO1xyXG5wb3BUZXN0LnBvcCgpO1xyXG5wb3BUZXN0LnBvcCgpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9MaXN0L0xpbmtlZExpc3QuanNcbiAqKi8iLCIvLyDpnZnmgIHljZXpk77ooahcclxuLypcclxuIOacieaXtuWPr+WAn+eUqOS4gOe7tOaVsOe7hOadpeaPj+i/sOe6v+aAp+mTvuihqO+8jOi/meWwseaYr+e6v+aAp+ihqOeahOmdmeaAgeWNlemTvuihqOWtmOWCqOe7k+aehOOAglxyXG4g5Zyo6Z2Z5oCB6ZO+6KGo5Lit77yM5pWw57uE55qE5LiA5Liq5YiG6YeP6KGo56S65LiA5Liq57uT54K577yM5ZCM5pe255So5ri45qCH77yIY3Vy77yJ5Luj5pu/5oyH6ZKI5oyH56S657uT54K55Zyo5pWw57uE5Lit55qE55u45a+55L2N572u44CCXHJcbiDmlbDnu4TnmoTnrKww5YiG6YeP5Y+v55yL5oiQ5aS057uT54K577yM5YW25oyH6ZKI5Z+f5oyH56S66ZO+6KGo55qE56ys5LiA5Liq57uT54K544CCXHJcbiDov5nnp43lrZjlgqjnu5PmnoTpnIDopoHpooTlhYjliIbphY3kuIDkuKrovoPlpKfnmoTnqbrpl7TvvIzkvYblnKjnur/mgKfooajnmoTmj5LlhaXlkozliKDpmaTmk43kvZzml7bkuI3pnIDnp7vliqjlhYPntKDvvIxcclxuIOS7hemcgOimgeS/ruaUueaMh+mSiO+8jOaVheS7jeWFt+aciemTvuW8j+WtmOWCqOe7k+aehOeahOS4u+imgeS8mOeCuVxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY0xpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoTUFYU0laRSkge1xyXG4gICAgICAgIHRoaXNbLTFdID0ge2N1cjogMH07XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuTUFYU0laRSA9IE1BWFNJWkUgKyAxIHx8IDEwMDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjpnZnmgIHljZXpk77nur/mgKfooahM5Lit5p+l5om+56ysMeS4quWAvOS4umXnmoTlhYPntKDvvIxcclxuICAgICAqIOiLpeaJvuWIsO+8jOWImei/lOWbnuWug+WcqEzkuK3nmoTkvY3luo9cclxuICAgICAqIEBwYXJhbSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGZpbmQgKGRhdGEpIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXNbMF0uY3VyO1xyXG4gICAgICAgIHdoaWxlIChpICYmIHRoaXNbaV0uZGF0YSAhPT0gZGF0YSkge1xyXG4gICAgICAgICAgICBpID0gdGhpc1tpXS5jdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIbkuIDnu7TmlbDnu4TkuK3lkITliIbph4/pk77miJDkuIDkuKrlpIfnlKjpk77ooahcclxuICAgICAqIHRoaXNbMF0uY3Vy5Li65aS05oyH6ZKIXHJcbiAgICAgKi9cclxuICAgIGluaXQgKGxlbikge1xyXG4gICAgICAgIGxlbiA9IGxlbiA/IGxlbiArIDEgOiB0aGlzLk1BWFNJWkU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpc1tpXSA9IHRoaXNbaV0gfHwge2RhdGE6IG51bGwsIGN1cjogbnVsbH07XHJcbiAgICAgICAgICAgIHRoaXNbaV0uY3VyID0gaSArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzW2xlbiAtIDFdID0gdGhpc1tsZW4gLSAxXSB8fCB7fTtcclxuICAgICAgICB0aGlzW2xlbiAtIDFdLmN1ciA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOiLpeWkh+eUqOmTvuihqOmdnuepuu+8jOWImei/lOWbnuWIhumFjeeahOe7k+eCueS4i+agh++8jOWPjeWImei/lOWbnjBcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBtYWxsb2MgKCkge1xyXG4gICAgICAgIGxldCBpID0gdGhpc1stMV0uY3VyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1stMV0uY3VyICE9PSAndW5kZWZpbmVkJykgdGhpc1stMV0uY3VyID0gdGhpc1tpXS5jdXI7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWwhuS4i+agh+S4umvnmoTnqbrpl7Lnu5Pngrnlm57mlLbliLDlpIfnlKjpk77ooahcclxuICAgICAqIEBwYXJhbSBrXHJcbiAgICAgKi9cclxuICAgIGZyZWUgKGspIHtcclxuICAgICAgICB0aGlzW2tdLmN1ciA9IHRoaXNbMF0uY3VyO1xyXG4gICAgICAgIHRoaXNbMF0uY3VyID0gaztcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGUgKHNxTGlzdCkge1xyXG4gICAgICAgIC8vIOWIneWni+WMluWkh+eUqOepuumXtFxyXG4gICAgICAgIHRoaXMuaW5pdChzcUxpc3QubGVuZ3RoKTtcclxuICAgICAgICAvLyDnlJ/miJBz55qE5aS057uT54K5XHJcbiAgICAgICAgbGV0IHMgPSB0aGlzLm1hbGxvYygpO1xyXG4gICAgICAgIC8vIHLmjIflkJFz55qE5b2T5YmN5pyA5ZCO57uT54K5XHJcbiAgICAgICAgbGV0IHIgPSBzO1xyXG4gICAgICAgIGxldCBtID0gc3FMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8g5bu656uL6ZuG5ZCIQeeahOmTvuihqFxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgICAgICAgIC8v5YiG6YWN57uT54K5XHJcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5tYWxsb2MoKTtcclxuICAgICAgICAgICAgLy8g6L6T5YWlQeWFg+e0oOeahOWAvFxyXG4gICAgICAgICAgICB0aGlzW2ldLmRhdGEgPSBzcUxpc3Rbal07XHJcbiAgICAgICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxyXG4gICAgICAgICAgICB0aGlzW3JdLmN1ciA9IGk7XHJcbiAgICAgICAgICAgICsrdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHIgPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlsL7nu5PngrnnmoTmjIfpkojkuLrnqbpcclxuICAgICAgICB0aGlzW3JdLmN1ciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdG9kb1xyXG4gICAgYWRkIChpbmRleCwgZWxlbSkge1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZSAoaW5kZXgpIHtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOWcqOS4gOe7tOaVsOe7hOS4reW7uueri+ihqOekuumbhuWQiChBLUIpVShCLUEpXHJcbiAqIOeahOmdmeaAgemTvuihqO+8jHPkuLrlhbblpLTmjIfpkojjgIJcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5mdW5jdGlvbiBkaWZmZXJlbmNlKHNsbGlzdCwgYXJyMSwgYXJyMikge1xyXG4gICAgLy8g5Yid5aeL5YyW5aSH55So56m66Ze0XHJcbiAgICBzbGxpc3QuaW5pdCgpO1xyXG4gICAgLy8g55Sf5oiQc+eahOWktOe7k+eCuVxyXG4gICAgbGV0IHMgPSBzbGxpc3QubWFsbG9jKCk7XHJcbiAgICAvLyBy5oyH5ZCRc+eahOW9k+WJjeacgOWQjue7k+eCuVxyXG4gICAgbGV0IHIgPSBzO1xyXG4gICAgLy8g5Yig6ZmkQeWSjELnmoTlhYPntKDkuKrmlbBcclxuICAgIGxldCBtID0gYXJyMS5sZW5ndGg7XHJcbiAgICBsZXQgbiA9IGFycjIubGVuZ3RoO1xyXG5cclxuICAgIC8vIOW7uueri+mbhuWQiEHnmoTpk77ooahcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgICAgLy/liIbphY3nu5PngrlcclxuICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcclxuICAgICAgICAvLyDovpPlhaVB5YWD57Sg55qE5YC8XHJcbiAgICAgICAgc2xsaXN0W2ldLmRhdGEgPSBhcnIxW2pdO1xyXG4gICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxyXG4gICAgICAgIHNsbGlzdFtyXS5jdXIgPSBpO1xyXG4gICAgICAgIHIgPSBpO1xyXG4gICAgfVxyXG4gICAgLy8g5bC+57uT54K555qE5oyH6ZKI5Li656m6XHJcbiAgICBzbGxpc3Rbcl0uY3VyID0gMDtcclxuXHJcbiAgICAvLyDkvp3mrKHovpPlhaVC55qE5YWD57Sg77yM6Iul5LiN5Zyo5b2T5YmN6KGo5Lit77yM5YiZ5o+S5YWl77yMXHJcbiAgICAvLyDlkKbliJnliKDpmaRcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XHJcbiAgICAgICAgbGV0IGIgPSBhcnIyW2pdO1xyXG4gICAgICAgIGxldCBwID0gcztcclxuICAgICAgICAvLyBr5oyH5ZCR6ZuG5ZCI5Lit55qE56ys5LiA5Liq57uT54K5XHJcbiAgICAgICAgbGV0IGsgPSBzbGxpc3Rbc10uY3VyO1xyXG4gICAgICAgIC8vIOWcqOW9k+WJjeihqOS4reafpeaJvlxyXG4gICAgICAgIHdoaWxlIChrICE9PSBzbGxpc3Rbcl0uY3VyICYmIHNsbGlzdFtrXS5kYXRhICE9PSBiKSB7XHJcbiAgICAgICAgICAgIHAgPSBrO1xyXG4gICAgICAgICAgICBrID0gc2xsaXN0W2tdLmN1cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5b2T5YmN6KGo5Lit5LiN5a2Y5Zyo6K+l5YWD57Sg77yM5o+S5YWl5ZyocuaJgOaMh+e7k+eCueS5i+WQju+8jOS4lHLnmoTkvY3nva7kuI3lj5hcclxuICAgICAgICBpZiAoayA9PT0gc2xsaXN0W3JdLmN1cikge1xyXG4gICAgICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcclxuICAgICAgICAgICAgc2xsaXN0W2ldLmRhdGEgPSBiO1xyXG4gICAgICAgICAgICBzbGxpc3RbaV0uY3VyID0gc2xsaXN0W3JdLmN1cjtcclxuICAgICAgICAgICAgc2xsaXN0W3JdLmN1ciA9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyDor6XlhYPntKDlt7LlnKjooajkuK3vvIzliKDpmaTkuYtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzbGxpc3RbcF0uY3VyID0gc2xsaXN0W2tdLmN1cjtcclxuICAgICAgICAgICAgc2xsaXN0LmZyZWUoayk7XHJcbiAgICAgICAgICAgIC8vIOiLpeWIoOmZpOeahOaYr3LmiYDmjIfnu5PngrnvvIzliJnpnIDkv67mlLnlsL7mjIfpkohcclxuICAgICAgICAgICAgaWYgKHIgPT09IGspIHIgPSBwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubGV0IHNsID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoMTApO1xyXG5sZXQgcmV0ID0gZGlmZmVyZW5jZShzbCwgWzEsIDIsIDNdLCBbMywgNCwgNV0pO1xyXG5jb25zb2xlLmxvZyhzbCk7XHJcblxyXG5cclxubGV0IHRlc3QgPSBuZXcgU3RhdGljTGlua2VkTGlzdCgxMCk7XHJcbnRlc3QuY3JlYXRlKFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDldKTtcclxuY29uc29sZS5sb2codGVzdCk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9TdGF0aWNMaW5rZWRMaXN0LmpzXG4gKiovIiwiLypcclxuIOWKqOaAgeafpeaJvlxyXG5cclxuIOW9k+afpeaJvuihqOS7pee6v+aAp+ihqOeahOW9ouW8j+e7hOe7h+aXtu+8jOiLpeWvueafpeaJvuihqOi/m+ihjOaPkuWFpeOAgeWIoOmZpOaIluaOkuW6j+aTjeS9nO+8jOWwseW/hemhu+enu+WKqOWkp+mHj+eahOiusOW9le+8jOW9k+iusOW9leaVsOW+iOWkmuaXtu+8jOi/meenjeenu+WKqOeahOS7o+S7t+W+iOWkp+OAglxyXG4g5Yip55So5qCR55qE5b2i5byP57uE57uH5p+l5om+6KGo77yM5Y+v5Lul5a+55p+l5om+6KGo6L+b6KGM5Yqo5oCB6auY5pWI55qE5p+l5om+44CCXHJcblxyXG5cclxuIOS6jOWPieaOkuW6j+agkShCU1Qp55qE5a6a5LmJXHJcblxyXG4g5LqM5Y+J5o6S5bqP5qCRKEJpbmFyeSBTb3J0IFRyZWXmiJZCaW5hcnkgU2VhcmNoIFRyZWUpIOeahOWumuS5ieS4uu+8muS6jOWPieaOkuW6j+agkeaIluiAheaYr+epuuagke+8jOaIluiAheaYr+a7oei2s+S4i+WIl+aAp+i0qOeahOS6jOWPieagkeOAglxyXG4gKDEpIO+8muiLpeW3puWtkOagkeS4jeS4uuepuu+8jOWImeW3puWtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95bCP5LqO5qC557uT54K555qE5YC877ybXHJcbiAoMikg77ya6Iul5Y+z5a2Q5qCR5LiN5Li656m677yM5YiZ5Y+z5a2Q5qCR5LiK5omA5pyJ57uT54K555qE5YC8KOWFs+mUruWtlynpg73lpKfkuo7moLnnu5PngrnnmoTlgLzvvJtcclxuICgzKSDvvJrlt6bjgIHlj7PlrZDmoJHpg73liIbliKvmmK/kuozlj4nmjpLluo/moJHjgIJcclxuIOe7k+iuuu+8muiLpeaMieS4reW6j+mBjeWOhuS4gOajteS6jOWPieaOkuW6j+agke+8jOaJgOW+l+WIsOeahOe7k+eCueW6j+WIl+aYr+S4gOS4qumAkuWinuW6j+WIl+OAglxyXG5cclxuXHJcbiBCU1TmoJHnmoTmn6Xmib5cclxuIDEgIOafpeaJvuaAneaDs1xyXG4g6aaW5YWI5bCG57uZ5a6a55qES+WAvOS4juS6jOWPieaOkuW6j+agkeeahOaguee7k+eCueeahOWFs+mUruWtl+i/m+ihjOavlOi+g++8muiLpeebuOetie+8miDliJnmn6Xmib7miJDlip/vvJtcclxuIOKRoCDnu5nlrprnmoRL5YC85bCP5LqOQlNU55qE5qC557uT54K555qE5YWz6ZSu5a2X77ya57un57ut5Zyo6K+l57uT54K555qE5bem5a2Q5qCR5LiK6L+b6KGM5p+l5om+77ybXHJcbiDikaEg57uZ5a6a55qES+WAvOWkp+S6jkJTVOeahOaguee7k+eCueeahOWFs+mUruWtl++8mue7p+e7reWcqOivpee7k+eCueeahOWPs+WtkOagkeS4iui/m+ihjOafpeaJvuOAglxyXG5cclxuIOWcqOmaj+acuuaDheWGteS4i++8jOS6jOWPieaOkuW6j+agkeeahOW5s+Wdh+afpeaJvumVv+W6pkFTTOWSjOOPkihuKSjmoJHnmoTmt7HluqYp5piv562J5pWw6YeP57qn55qE44CCXHJcblxyXG5cclxuIEJTVOagkeeahOaPkuWFpVxyXG5cclxuIOWcqEJTVOagkeS4reaPkuWFpeS4gOS4quaWsOe7k+eCue+8jOimgeS/neivgeaPkuWFpeWQjuS7jea7oei2s0JTVOeahOaAp+i0qOOAglxyXG5cclxuIDEg5o+S5YWl5oCd5oOzXHJcbiDlnKhCU1TmoJHkuK3mj5LlhaXkuIDkuKrmlrDnu5Pngrl45pe277yM6IulQlNU5qCR5Li656m677yM5YiZ5Luk5paw57uT54K5eOS4uuaPkuWFpeWQjkJTVOagkeeahOaguee7k+eCue+8m+WQpuWIme+8jOWwhue7k+eCuXjnmoTlhbPplK7lrZfkuI7moLnnu5PngrlU55qE5YWz6ZSu5a2X6L+b6KGM5q+U6L6D77yaXHJcbiDikaAg6Iul55u4562J77yaIOS4jemcgOimgeaPkuWFpe+8m1xyXG4g4pGhICDoi6V4LmtleTxULT5rZXnvvJrnu5Pngrl45o+S5YWl5YiwVOeahOW3puWtkOagkeS4re+8m1xyXG4g4pGiICDoi6V4LmtleT5ULT5rZXnvvJrnu5Pngrl45o+S5YWl5YiwVOeahOWPs+WtkOagkeS4reOAglxyXG5cclxuIOeUsee7k+iuuuefpe+8jOWvueS6juS4gOS4quaXoOW6j+W6j+WIl+WPr+S7pemAmui/h+aehOmAoOS4gOajtUJTVOagkeiAjOWPmOaIkOS4gOS4quacieW6j+W6j+WIl+OAglxyXG4g55Sx566X5rOV55+l77yM5q+P5qyh5o+S5YWl55qE5paw57uT54K56YO95pivQlNU5qCR55qE5Y+25a2Q57uT54K577yM5Y2z5Zyo5o+S5YWl5pe25LiN5b+F56e75Yqo5YW25a6D57uT54K577yM5LuF6ZyA5L+u5pS55p+Q5Liq57uT54K555qE5oyH6ZKI44CCXHJcblxyXG5cclxuIEJTVOagkeeahOWIoOmZpFxyXG5cclxuIDEgIOWIoOmZpOaTjeS9nOi/h+eoi+WIhuaekFxyXG4g5LuOQlNU5qCR5LiK5Yig6Zmk5LiA5Liq57uT54K577yM5LuN54S26KaB5L+d6K+B5Yig6Zmk5ZCO5ruh6LazQlNU55qE5oCn6LSo44CC6K6+6KKr5Yig6Zmk57uT54K55Li6cO+8jOWFtueItue7k+eCueS4umYg77yM5Yig6Zmk5oOF5Ya15aaC5LiL77yaXHJcbiDikaAgIOiLpXDmmK/lj7blrZDnu5PngrnvvJog55u05o6l5Yig6ZmkcOOAglxyXG4g4pGhICDoi6Vw5Y+q5pyJ5LiA5qO15a2Q5qCRKOW3puWtkOagkeaIluWPs+WtkOagkSnvvJrnm7TmjqXnlKhw55qE5bem5a2Q5qCRKOaIluWPs+WtkOagkSnlj5bku6Nw55qE5L2N572u6ICM5oiQ5Li6ZueahOS4gOajteWtkOagkeOAguWNs+WOn+adpXDmmK9m55qE5bem5a2Q5qCR77yM5YiZcOeahOWtkOagkeaIkOS4umbnmoTlt6blrZDmoJHvvJvljp/mnaVw5pivZueahOWPs+WtkOagke+8jOWImXDnmoTlrZDmoJHmiJDkuLpm55qE5Y+z5a2Q5qCR44CCXHJcbiDikaIg6IulcOaXouacieW3puWtkOagkeWPiOacieWPs+WtkOagkSDvvJrlpITnkIbmlrnms5XmnInku6XkuIvkuKTnp43vvIzlj6/ku6Xku7vpgInlhbbkuK3kuIDnp43jgIJcclxuIOKXhiAg55SocOeahOebtOaOpeWJjempsee7k+eCueS7o+abv3DjgILljbPku45w55qE5bem5a2Q5qCR5Lit6YCJ5oup5YC85pyA5aSn55qE57uT54K5c+aUvuWcqHDnmoTkvY3nva4o55So57uT54K5c+eahOWGheWuueabv+aNoue7k+eCuXDlhoXlrrkp77yM54S25ZCO5Yig6Zmk57uT54K5c+OAgnPmmK9w55qE5bem5a2Q5qCR5Lit55qE5pyA5Y+z6L6555qE57uT54K55LiU5rKh5pyJ5Y+z5a2Q5qCR77yM5a+5c+eahOWIoOmZpOWQjOKRoeOAglxyXG4g4peGIOeUqHDnmoTnm7TmjqXlkI7nu6fnu5Pngrnku6Pmm79w44CC5Y2z5LuOcOeahOWPs+WtkOagkeS4remAieaLqeWAvOacgOWwj+eahOe7k+eCuXPmlL7lnKhw55qE5L2N572uKOeUqOe7k+eCuXPnmoTlhoXlrrnmm7/mjaLnu5Pngrlw5YaF5a65Ke+8jOeEtuWQjuWIoOmZpOe7k+eCuXPjgIJz5pivcOeahOWPs+WtkOagkeS4reeahOacgOW3pui+ueeahOe7k+eCueS4lOayoeacieW3puWtkOagke+8jOWvuXPnmoTliKDpmaTlkIzikaHjgIJcclxuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQmluYXJ5VHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCU1ROb2RlIGV4dGVuZHMgQmluYXJ5VHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvciguLi5hcmcpIHtcclxuICAgICAgICBzdXBlciguLi5hcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQlNU5qCR55qE5p+l5om+77yI6YCS5b2S77yJXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHNlYXJjaChrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSA9PT0ga2V5KSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IDwgdGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdENoaWxkLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodENoaWxkLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJTVOagkeeahOafpeaJvu+8iOmdnumAkuW9ku+8iVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBzZWFyY2hOb25SZWN1cnNpdmUoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChwICYmIHAuZGF0YSAhPT0ga2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgZWxzZSBwID0gcC5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFwIHx8IGtleSAhPT0gcC5kYXRhKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBlbHNlIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQlNU5qCR55qE5o+S5YWl77yI6YCS5b2S77yJXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGtleTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLmRhdGEpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgQlNUTm9kZShrZXkpO1xyXG4gICAgICAgIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZC5pbnNlcnQoa2V5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5yaWdodENoaWxkLmluc2VydChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmdnumAkuW9ku+8iVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0Tm9uUmVjdXJzaXZlKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwID0gdGhpcztcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICBpZiAocC5kYXRhID09PSBrZXkpIHJldHVybjtcclxuICAgICAgICAgICAgLy8gceS9nOS4unDnmoTniLboioLngrlcclxuICAgICAgICAgICAgcSA9IHA7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgZWxzZSBwID0gcC5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgQlNUTm9kZShrZXkpO1xyXG4gICAgICAgIGlmIChrZXkgPCBxLmRhdGEpIHEubGVmdENoaWxkID0gbm9kZTtcclxuICAgICAgICBlbHNlIHEucmlnaHRDaGlsZCA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKnnlKhCU1TmoJHnmoTmj5LlhaXmk43kvZzlu7rnq4vkuIDmo7VCU1TmoJFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufHVuZGVmaW5lZH0gdXNlTm9uUmVjdXJzaXZlIOaYr+WQpuS9v+eUqOmdnumAkuW9klxyXG4gICAgICovXHJcbiAgICBjcmVhdGVCU1QoYXJyLCB1c2VOb25SZWN1cnNpdmUpIHtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBpZiAodXNlTm9uUmVjdXJzaXZlKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vblJlY3Vyc2l2ZShhcnJbaV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChhcnJbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDkvb/nlKjpgJLlvZLnmoTmlrnms5XliKDpmaTkuI7lhbPplK7lrZfnrKblkIjnmoTnu5PngrlcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IOmcgOimgeafpeaJvueahOWFs+mUruWtl1xyXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg54i26IqC54K577yM5YaF6YOo6LCD55So6ZyA6KaB55So5YiwXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgcGFyZW50KSB7XHJcbiAgICAgICAgLy8g56m657uT54K555qE5oOF5Ya1XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIOaJvuWIsOWFs+mUruWtl1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIGRlbGV0ZU5vZGUodGhpcywgcGFyZW50KTtcclxuICAgICAgICAvLyDmn6Xmib7lt6blrZDmoJHvvIzlpoLmnpzmnInnmoTor51cclxuICAgICAgICBlbHNlIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSByZXR1cm4gdGhpcy5sZWZ0Q2hpbGQucmVtb3ZlKGtleSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOafpeaJvuWPs+WtkOagke+8jOWmguaenOacieeahOivnVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSByZXR1cm4gdGhpcy5yaWdodENoaWxkLnJlbW92ZShrZXksIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pyq5om+5YiwXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6Z2e6YCS5b2S5Yig6Zmk5LiO5YWz6ZSu5a2X56ym5ZCI55qE57uT54K5XHJcbiAgICAgKiBAcGFyYW0geyp9IGtleSDpnIDopoHmn6Xmib7nmoTlhbPplK7lrZdcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICByZW1vdmVOb25SZWN1cnNpdmUoa2V5KSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xyXG4gICAgICAgIGxldCBmO1xyXG5cclxuICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgIT09IGtleSkge1xyXG4gICAgICAgICAgICBmID0gcDtcclxuICAgICAgICAgICAgaWYgKGtleSA8IHAuZGF0YSkgcCA9IHAubGVmdENoaWxkO1xyXG4gICAgICAgICAgICBlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmsqHmnInopoHliKDpmaTnmoTnu5PngrlcclxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8g5om+5Yiw5LqG6KaB5Yig6Zmk55qE57uT54K5cFxyXG4gICAgICAgIGxldCBzID0gcDtcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICAvLyDlpoLmnpzmnInlt6blj7PlrZDmoJFcclxuICAgICAgICBpZiAocC5sZWZ0Q2hpbGQgJiYgcC5yaWdodENoaWxkKSB7XHJcbiAgICAgICAgICAgIGYgPSBwO1xyXG4gICAgICAgICAgICBzID0gcC5sZWZ0Q2hpbGQ7XHJcblxyXG4gICAgICAgICAgICAvLyDmib7liLDlt6blrZDmoJHnmoTmnIDlpKflj7PlrZDmoJHvvIzljbPku4XlsI/kuo7lt6blrZDmoJHnmoTlgLznmoTnu5PngrlcclxuICAgICAgICAgICAgd2hpbGUgKHMucmlnaHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IHM7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDoi6Vz5pyJ5bem5a2Q5qCR77yM5Y+z5a2Q5qCR5Li656m6XHJcbiAgICAgICAgaWYgKHMubGVmdENoaWxkKSBxID0gcy5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgZWxzZSBxID0gcy5yaWdodENoaWxkO1xyXG5cclxuICAgICAgICAvLyDlj6rmnInkuIDkuKrmoLnnu5PngrnnmoTmg4XlhrVcclxuICAgICAgICBpZiAoIWYpIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZWxzZSBpZiAoZi5sZWZ0Q2hpbGQgPT0gcykgZi5sZWZ0Q2hpbGQgPSBxO1xyXG4gICAgICAgIGVsc2UgZi5yaWdodENoaWxkID0gcTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmib7liLDlsI/kuo5455qE5pyA5aSn5YWD57Sg5ZKM5aSn5LqOeOeahOacgOWwj+WFg+e0oFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFttaW4sIG1heF1cclxuICAgICAqL1xyXG4gICAgZmluZE5laWdoYm9yRWxlbSh4KSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0eXBlb2YgdGhpcy5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcclxuICAgICAgICBsZXQgcmV0ID0gW107XHJcblxyXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZSh0cmVlLCB4KSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgcmVjdXJzZSh0cmVlLmxlZnRDaGlsZCwgeCk7XHJcbiAgICAgICAgICAgIGlmIChsYXN0IDwgeCAmJiB0cmVlLmRhdGEgPj0geCkgcmV0WzBdID0gbGFzdDtcclxuICAgICAgICAgICAgaWYgKGxhc3QgPD0geCAmJiB0cmVlLmRhdGEgPiB4KSByZXRbMV0gPSB0cmVlLmRhdGE7XHJcbiAgICAgICAgICAgIGxhc3QgPSB0cmVlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCB4KTtcclxuICAgICAgICB9KHRoaXMsIHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5oqK5LqM5Y+J5o6S5bqP5qCRYnN05ZCI5bm25Yiw6K+l5qCR5LitXHJcbiAgICAgKiBAcGFyYW0ge0JTVE5vZGV9IGJzdFxyXG4gICAgICovXHJcbiAgICBtZXJnZShic3QpIHtcclxuICAgICAgICBpZiAoYnN0LmxlZnRDaGlsZCkgdGhpcy5tZXJnZShic3QubGVmdENoaWxkKTtcclxuICAgICAgICBpZiAoYnN0LnJpZ2h0Q2hpbGQpIHRoaXMubWVyZ2UoYnN0LnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0KGJzdC5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaKiue7k+eCueaPkuWFpeWIsOWQiOmAguS9jee9rlxyXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBub2RlIOW+heaPkuWFpeeahOe7k+eCuVxyXG4gICAgICovXHJcbiAgICBpbnNlcnROb2RlKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZS5kYXRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPiB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLnJpZ2h0Q2hpbGQuaW5zZXJ0Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmRhdGEgPCB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5sZWZ0Q2hpbGQuaW5zZXJ0Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbm9kZS5sZWZ0Q2hpbGQgPSBub2RlLnJpZ2h0Q2hpbGQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YiG6KOC5Li65Lik5qO15LqM5Y+J5o6S5bqP5qCRXHJcbiAgICAgKiBAcGFyYW0geyp9IHhcclxuICAgICAqIEByZXR1cm5zIHtCU1ROb2RlW2EsIGJdfSBh55qE5YWD57Sg5YWo6YOo5bCP5LqO562J5LqOeO+8jGLnmoTlhYPntKDlhajpg6jlpKfkuo54XHJcbiAgICAgKi9cclxuICAgIHNwbGl0KHgpIHtcclxuICAgICAgICBsZXQgYSA9IG5ldyBCU1ROb2RlKCk7XHJcbiAgICAgICAgbGV0IGIgPSBuZXcgQlNUTm9kZSgpO1xyXG5cclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHNwbGl0KHRyZWUsIHgpIHtcclxuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSBzcGxpdCh0cmVlLmxlZnRDaGlsZCwgeCk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHNwbGl0KHRyZWUucmlnaHRDaGlsZCwgeCk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmRhdGEgPD0geCkgYS5pbnNlcnROb2RlKHRyZWUpO1xyXG4gICAgICAgICAgICBlbHNlIGIuaW5zZXJ0Tm9kZSh0cmVlKTtcclxuICAgICAgICB9KHRoaXMsIHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gW2EsIGJdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patdHJlZeaYr+WQpuaYr+S6jOWPieaOkuW6j+agkVxyXG4gICAgICogQHBhcmFtIHRyZWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQlNUVHJlZSh0cmVlKSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0eXBlb2YgdHJlZS5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcclxuICAgICAgICBsZXQgZmxhZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gaXNCU1RUcmVlKHRyZWUpIHtcclxuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkICYmIGZsYWcpIGlzQlNUVHJlZSh0cmVlLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmRhdGEgPCBsYXN0KSBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxhc3QgPSB0cmVlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQgJiYgZmxhZykgaXNCU1RUcmVlKHRyZWUucmlnaHRDaGlsZCk7XHJcblxyXG4gICAgICAgIH0odHJlZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmbGFnO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICog5Yig6Zmk57uT54K5XHJcbiAqIEBwYXJhbSB7QlNUTm9kZX0gcCDopoHliKDpmaTnmoTnu5PngrlcclxuICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg6KaB5Yig6Zmk55qE57uT54K555qE54i26IqC54K5XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSDov5Tlm57liKDpmaTmiJDlip9cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZU5vZGUocCwgcGFyZW50KSB7XHJcbiAgICAvLyDlj7blrZDnu5PngrnmiJblj6rmnInkuIDkuKrnu5PngrlcclxuICAgIGlmICghcC5sZWZ0Q2hpbGQgJiYgIXAucmlnaHRDaGlsZCkge1xyXG4gICAgICAgIC8vIOW9k+WJjee7k+eCueaYr+WFtueItue7k+eCueeahOW3puWtkOagkei/mOaYr+WPs+WtkOagkVxyXG4gICAgICAgIGxldCBwb3MgPSBwYXJlbnQgJiYgcGFyZW50LmxlZnRDaGlsZCA9PSBwID8gJ2xlZnRDaGlsZCcgOiAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50W3Bvc10gPSBudWxsO1xyXG4gICAgICAgIC8vIOWPquacieS4gOS4que7k+eCueeahOaDheWGtVxyXG4gICAgICAgIGVsc2UgIHAuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyDlj6rmnInlt6blrZDmoJFcclxuICAgIGVsc2UgaWYgKCFwLnJpZ2h0Q2hpbGQpIHtcclxuICAgICAgICBwLmRhdGEgPSBwLmxlZnRDaGlsZC5kYXRhO1xyXG4gICAgICAgIHAubGVmdENoaWxkID0gcC5sZWZ0Q2hpbGQubGVmdENoaWxkO1xyXG4gICAgfVxyXG4gICAgLy8g5Y+q5pyJ5Y+z5a2Q5qCRXHJcbiAgICBlbHNlIGlmICghcC5sZWZ0Q2hpbGQpIHtcclxuICAgICAgICBwLmRhdGEgPSBwLnJpZ2h0Q2hpbGQuZGF0YTtcclxuICAgICAgICBwLnJpZ2h0Q2hpbGQgPSBwLnJpZ2h0Q2hpbGQucmlnaHRDaGlsZDtcclxuICAgIH1cclxuICAgIC8vIOW3puWPs+WtkOagkemDveaciVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHMgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAvLyBx5Li654i257uT54K5XHJcbiAgICAgICAgbGV0IHEgPSBwO1xyXG4gICAgICAgIC8vIOaJvuWIsOW3puWtkOagkeeahOacgOWkp+WPs+WtkOagke+8jOWNs+S7heWwj+S6juW3puWtkOagkeeahOWAvOeahOe7k+eCuVxyXG4gICAgICAgIHdoaWxlIChzLnJpZ2h0Q2hpbGQpIHtcclxuICAgICAgICAgICAgcSA9IHM7XHJcbiAgICAgICAgICAgIHMgPSBzLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XHJcbiAgICAgICAgaWYgKHEgIT0gcCkgcS5yaWdodENoaWxkID0gcy5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgZWxzZSBxLmxlZnRDaGlsZCA9IHMubGVmdENoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5sZXQgYnN0ID0gbmV3IEJTVE5vZGUoKTtcclxuYnN0LmNyZWF0ZUJTVChbNDUsIDI0LCA1MywgMTIsIDI0LCA5MF0pO1xyXG5jb25zb2xlLmxvZyhic3Quc2VhcmNoKDEyKSk7XHJcbmNvbnNvbGUubG9nKGJzdC5zZWFyY2goMTMpKTtcclxuXHJcbmxldCBic3QyID0gbmV3IEJTVE5vZGUoKTtcclxuYnN0Mi5jcmVhdGVCU1QoWzQ1LCAyNCwgNTMsIDEyLCAyNCwgOTBdLCB0cnVlKTtcclxuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTIpKTtcclxuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTMpKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5maW5kU2libGluZ0VsZW06ICcpO1xyXG5jb25zb2xlLmxvZyhic3QuZmluZE5laWdoYm9yRWxlbSgxMikgKyAnJyk7XHJcbmNvbnNvbGUubG9nKGJzdC5maW5kTmVpZ2hib3JFbGVtKDkwKSArICcnKTtcclxuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oNDUpICsgJycpO1xyXG5cclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSg0NSkpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDEpKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSg1MykpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDEyKSk7XHJcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoOTApKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSgyNCkpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDIpKTtcclxuXHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNDUpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgxKSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNTMpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgxMikpO1xyXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDkwKSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMjQpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgyKSk7XHJcblxyXG5jb25zb2xlLmxvZygnXFxuaXNCU1RUcmVlOiAnKTtcclxuY29uc29sZS5sb2coQlNUTm9kZS5pc0JTVFRyZWUoYnN0KSk7XHJcbi8vY29uc29sZS5sb2coQlNUTm9kZS5pc0JTVFRyZWUoc29zVHJlZSkpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiDku47lpKfliLDlsI/ovpPlh7rkuozlj4nmjpLluo/moJHkuK3miYDmnInkuI3lsI/kuo5455qE5YWD57SgXHJcbiAqIEBwYXJhbSBic3RcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIHByaW50Tm90TGVzc1RoYW4oYnN0LCB4KSB7XHJcbiAgICBpZiAoYnN0LnJpZ2h0Q2hpbGQpIHByaW50Tm90TGVzc1RoYW4oYnN0LnJpZ2h0Q2hpbGQsIHgpO1xyXG4gICAgaWYgKGJzdC5kYXRhIDwgeCkgcmV0dXJuO1xyXG4gICAgY29uc29sZS5sb2coYnN0LmRhdGEpO1xyXG4gICAgaWYgKGJzdC5sZWZ0Q2hpbGQpIHByaW50Tm90TGVzc1RoYW4oYnN0LmxlZnRDaGlsZCwgeCk7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCdcXG5wcmludE5vdExlc3NUaGFuOiAnKTtcclxucHJpbnROb3RMZXNzVGhhbihic3QyLCA5MCk7XHJcbmNvbnNvbGUubG9nKCdcXG4nKTtcclxucHJpbnROb3RMZXNzVGhhbihic3QyLCAxMik7XHJcblxyXG5cclxuYnN0Lm1lcmdlKGJzdDIpO1xyXG5cclxubGV0IGExID0gbmV3IEJTVE5vZGUoNSk7XHJcbmxldCBhMiA9IG5ldyBCU1ROb2RlKDkxKTtcclxuYnN0Mi5pbnNlcnROb2RlKGExKTtcclxuYnN0Mi5pbnNlcnROb2RlKGEyKTtcclxuXHJcbmJzdDIuc3BsaXQoNDUpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TZWFyY2gvQmluYXJ5U29ydGVkVHJlZS5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8yLzIuXHJcbiAqL1xyXG5cclxuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XHJcblxyXG4vKlxyXG4g5Lqk5o2i5o6S5bqPXHJcblxyXG4g5piv5LiA57G75Z+65LqO5Lqk5o2i55qE5o6S5bqP77yM57O757uf5Zyw5Lqk5o2i5Y+N5bqP55qE6K6w5b2V55qE5YG25a+577yM55u05Yiw5LiN5YaN5pyJ6L+Z5qC355qE5YG25a+55Li65q2i44CC5YW25Lit5pyA5Z+65pys55qE5piv5YaS5rOh5o6S5bqPKEJ1YmJsZSBTb3J0KeOAglxyXG5cclxuIOWGkuazoeaOkuW6j1xyXG4gMSAg5o6S5bqP5oCd5oOzXHJcbiDkvp3mrKHmr5TovoPnm7jpgrvnmoTkuKTkuKrorrDlvZXnmoTlhbPplK7lrZfvvIzoi6XkuKTkuKrorrDlvZXmmK/lj43luo/nmoQo5Y2z5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2X5aSn5LqO5ZCO5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2XKe+8jOWImei/m+ihjOS6pOaNou+8jOebtOWIsOayoeacieWPjeW6j+eahOiusOW9leS4uuatouOAglxyXG4gICAgIOKRoCDpppblhYjlsIZMLT5SWzFd5LiOTC0+UlsyXeeahOWFs+mUruWtl+i/m+ihjOavlOi+g++8jOiLpeS4uuWPjeW6jyhMLT5SWzFd55qE5YWz6ZSu5a2X5aSn5LqOTC0+UlsyXeeahOWFs+mUruWtlynvvIzliJnkuqTmjaLkuKTkuKrorrDlvZXvvJvnhLblkI7mr5TovoNMLT5SWzJd5LiOTC0+UlszXeeahOWFs+mUruWtl++8jOS+neatpOexu+aOqO+8jOebtOWIsEwtPlJbbi0xXeS4jkwtPlJbbl3nmoTlhbPplK7lrZfmr5TovoPlkI7kuLrmraLvvIznp7DkuLrkuIDotp/lhpLms6HmjpLluo/vvIxMLT5SW25d5Li65YWz6ZSu5a2X5pyA5aSn55qE6K6w5b2V44CCXHJcbiAgICAg4pGhICDnhLblkI7ov5vooYznrKzkuozotp/lhpLms6HmjpLluo/vvIzlr7nliY1uLTHkuKrorrDlvZXov5vooYzlkIzmoLfnmoTmk43kvZzjgIJcclxuIOS4gOiIrOWcsO+8jOesrGnotp/lhpLms6HmjpLluo/mmK/lr7lMLT5SWzEg4oCmIG4taSsxXeS4reeahOiusOW9lei/m+ihjOeahO+8jOWboOatpO+8jOiLpeW+heaOkuW6j+eahOiusOW9leaciW7kuKrvvIzliJnopoHnu4/ov4duLTHotp/lhpLms6HmjpLluo/miY3og73kvb/miYDmnInnmoTorrDlvZXmnInluo/jgIJcclxuXHJcbiAyICDmjpLluo/npLrkvotcclxuIOiuvuaciTnkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLoyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXHJcblxyXG4g5Yid5aeL5YWz6ZSu5a2X5bqP5YiXOiAgMjMgICAgMzggICAgIDIyICAgICA0NSAgICAgMjMgICAgIDY3ICAgICAzMSAgICAgMTUgICAgNDFcclxuIOesrOS4gOi2n+aOkuW6j+WQjjogICAgMjMgICAgMjIgICAgIDM4ICAgICAyMyAgICAgNDUgICAgIDMxICAgICAxNSAgICAgNDEgICAgNjdcclxuIOesrOS6jOi2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAzOCAgICAgMzEgICAgIDE1ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOS4iei2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAzMSAgICAgMTUgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOWbm+i2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAxNSAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOS6lOi2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDE1ICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOWFrei2n+aOkuW6j+WQjjogICAgMjIgICAgMTUgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOS4g+i2n+aOkuW6j+WQjjogICAgMTUgICAgMjIgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuXHJcbjMu566X5rOV5YiG5p6QXHJcbiDml7bpl7TlpI3mnYLluqZcclxuIOKXhiAg5pyA5aW95oOF5Ya1KOato+W6jynvvJrmr5TovoPmrKHmlbDvvJpuLTHvvJvnp7vliqjmrKHmlbDvvJow77ybXHJcbiDil4YgIOacgOWdj+aDheWGtSjpgIbluo8p77yaXHJcbiDmr5TovoPmrKHmlbDvvJogbiAqIChuIC0gMSkgLyAyXHJcbiDnp7vliqjmrKHmlbDvvJogMypuKihuIC0gMSkgLyAyXHJcblxyXG4g5pWF5pe26Ze05aSN5p2C5bqm77yaVChuKT1PKG7CsilcclxuIOepuumXtOWkjeadguW6pu+8mlMobik9TygxKVxyXG5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIGxldCBjaGFuZ2UgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBsZW4gLSBpOyArK2opIHtcclxuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2ogKyAxXSwgc3FMaXN0W2pdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtqXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtqXSA9IHNxTGlzdFtqICsgMV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gdGVtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaGFuZ2UpIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxuYnViYmxlU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZygnYnViYmxlU29ydDpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8vIOWGkuazoeaUuei/mzFcclxuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZVNvcnQyKHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XHJcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIGxldCBjaGFuZ2UgPSBsZW4gLSAxO1xyXG5cclxuICAgIHdoaWxlIChjaGFuZ2UpIHtcclxuICAgICAgICBsZXQgYyA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2U7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICAvLyBj5oyH56S66L+Z5LiA6Laf5YaS5rOh5Lit5Y+R55Sf5Lqk5o2i55qE5YWD57SgXHJcbiAgICAgICAgICAgICAgICBjID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZSA9IGM7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbmJ1YmJsZVNvcnQyKGFycik7XHJcbmNvbnNvbGUubG9nKCdidWJibGVTb3J0MjpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8vIOebuOmCu+S4pOi2n+WPjeaWueWQkei1t+azoeeahOWGkuazoeaOkuW6j+eul+azlVxyXG5leHBvcnQgZnVuY3Rpb24gY29ja1RhaWxTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XHJcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIC8vIOWGkuazoeS4iuS4i+eVjFxyXG4gICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBsZW4gLSAxO1xyXG4gICAgbGV0IGNoYW5nZSA9IDE7XHJcbiAgICBsZXQgdGVtcDtcclxuXHJcbiAgICB3aGlsZSAobG93IDwgaGlnaCAmJiBjaGFuZ2UpIHtcclxuICAgICAgICBjaGFuZ2UgPSAwO1xyXG5cclxuICAgICAgICAvLyDku47kuIrlkJHkuIvotbfms6FcclxuICAgICAgICBmb3IgKGxldCBpID0gbG93OyBpIDwgaGlnaDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDkv67mlLnkuIrnlYxcclxuICAgICAgICAtLWhpZ2g7XHJcblxyXG4gICAgICAgIC8vIOS7juS4i+WQkeS4iui1t+azoVxyXG4gICAgICAgIGZvciAobGV0IGkgPSBoaWdoOyBpID4gbG93OyAtLWkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSAtIDFdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgLSAxXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOS/ruaUueS4i+eVjFxyXG4gICAgICAgICsrbG93O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5jb2NrVGFpbFNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coJ2NvY2tUYWlsU29ydDpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8vIOaUuei/mzNcclxuZXhwb3J0IGZ1bmN0aW9uIGNvY2tUYWlsU29ydDIoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcclxuICAgIGxldCBiID0ge307XHJcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIC8vIGTkuLrlhpLms6HmlrnlkJHmoIfor4bvvIwgMeS4uuWQkeS4iu+8jC0x5Li65ZCR5LiLXHJcbiAgICBsZXQgZCA9IDE7XHJcbiAgICAvLyBiWzBd5Li65YaS5rOh5LiK55WM77yMYlsyXeS4uuWGkuazoeS4iueVjO+8jGJbMV3ml6DnlKhcclxuICAgIGJbMF0gPSAwO1xyXG4gICAgYlsyXSA9IGxlbiAtIDE7XHJcbiAgICBsZXQgY2hhbmdlID0gMTtcclxuXHJcbiAgICB3aGlsZSAoYlswXSA8IGJbMl0gJiYgY2hhbmdlKSB7XHJcbiAgICAgICAgY2hhbmdlID0gMDtcclxuXHJcbiAgICAgICAgLy8g57uf5LiA55qE5YaS5rOh566X5rOVXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGJbMSAtIGRdOyBpICE9PSBiWzEgKyBkXTsgaSArPSBkKSB7XHJcbiAgICAgICAgICAgIC8vIOazqOaEj+i/meS4quS6pOaNouadoeS7tlxyXG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgZF0pICogZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyBkXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgZF0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5L+u5pS56L6555WMXHJcbiAgICAgICAgYlsxICsgZF0gLT0gZDtcclxuICAgICAgICAvLyDmjaLkuKrmlrnlkJFcclxuICAgICAgICBkICo9IC0xO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5jb2NrVGFpbFNvcnQyKGFycik7XHJcbmNvbnNvbGUubG9nKCdjb2NrVGFpbFNvcnQyOlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDlv6vpgJ/mjpLluo9cclxuXHJcbiAxICDmjpLluo/mgJ3mg7NcclxuIOmAmui/h+S4gOi2n+aOkuW6j++8jOWwhuW+heaOkuW6j+iusOW9leWIhuWJsuaIkOeLrOeri+eahOS4pOmDqOWIhu+8jOWFtuS4reS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wdh+avlOWPpuS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wwj++8jOWGjeWIhuWIq+Wvuei/meS4pOmDqOWIhuiusOW9lei/m+ihjOS4i+S4gOi2n+aOkuW6j++8jOS7pei+vuWIsOaVtOS4quW6j+WIl+acieW6j+OAglxyXG5cclxuIDIgIOaOkuW6j+i/h+eoi1xyXG4g6K6+5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX5pivUltz4oCmdF0g77yM5Zyo6K6w5b2V5bqP5YiX5Lit5Lu75Y+W5LiA5Liq6K6w5b2VKOS4gOiIrOWPllJbc10p5L2c5Li65Y+C54WnKOWPiOensOS4uuWfuuWHhuaIluaeoui9tCnvvIzku6VSW3NdLmtleeS4uuWfuuWHhumHjeaWsOaOkuWIl+WFtuS9meeahOaJgOacieiusOW9le+8jOaWueazleaYr++8mlxyXG4gICAgIOKXhiDmiYDmnInlhbPplK7lrZfmr5Tln7rlh4blsI/nmoTmlL5SW3Nd5LmL5YmN77ybXHJcbiAgICAg4peGIOaJgOacieWFs+mUruWtl+avlOWfuuWHhuWkp+eahOaUvlJbc13kuYvlkI7jgIJcclxuIOS7pVJbc10ua2V55pyA5ZCO5omA5Zyo5L2N572uaeS9nOS4uuWIhueVjO+8jOWwhuW6j+WIl1Jbc+KApnRd5YiG5Ymy5oiQ5Lik5Liq5a2Q5bqP5YiX77yM56ew5Li65LiA6Laf5b+r6YCf5o6S5bqP44CCXHJcblxyXG4gMyAg5LiA6Laf5b+r6YCf5o6S5bqP5pa55rOVXHJcbiDku47luo/liJfnmoTkuKTnq6/kuqTmm7/miavmj4/lkITkuKrorrDlvZXvvIzlsIblhbPplK7lrZflsI/kuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXkvp3mrKHmlL7nva7liLDluo/liJfnmoTliY3ovrnvvJvogIzlsIblhbPplK7lrZflpKfkuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXku47luo/liJfnmoTmnIDlkI7nq6/otbfvvIzkvp3mrKHmlL7nva7liLDluo/liJfnmoTlkI7ovrnvvIznm7TliLDmiavmj4/lrozmiYDmnInnmoTorrDlvZXjgIJcclxuXHJcbiDorr7nva7mjIfpkohsb3fvvIxoaWdo77yM5Yid5YC85Li656ysMeS4quWSjOacgOWQjuS4gOS4quiusOW9leeahOS9jee9ruOAglxyXG4g6K6+5Lik5Liq5Y+Y6YePae+8jGrvvIzliJ3lp4vml7bku6RpPWxvd++8jGo9aGlnaO+8jOS7pVJbbG93XS5rZXnkvZzkuLrln7rlh4Yo5bCGUltsb3dd5L+d5a2Y5ZyodGVtcOS4rSkg44CCXHJcbiDikaAg5LuOauaJgOaMh+S9jee9ruWQkeWJjeaQnOe0ou+8muWwhnRlbXDkuI5SW2pdLmtleei/m+ihjOavlOi+g++8mlxyXG4gICAg4peGIOiLpXRlbXDiiaRSW2pdLmtleSDvvJrku6RqPWotMe+8jOeEtuWQjue7p+e7rei/m+ihjOavlOi+g++8jCDnm7TliLBpPWrmiJZ0ZW1wPlJbal0ua2V55Li65q2i77ybXHJcbiAgICDil4Yg6IuldGVtcD5SW2pdLmtleSDvvJpSW2pd74OeUltpXe+8jOiFvuepulJbal3nmoTkvY3nva7vvIwg5LiU5LukaT1pKzHvvJtcclxuIOKRoSDku45p5omA5oyH5L2N572u6LW35ZCR5ZCO5pCc57Si77ya5bCGdGVtcOS4jlJbaV0ua2V56L+b6KGM5q+U6L6D77yaXHJcbiAgICDil4Yg6IuldGVtcOKJpVJbaV0ua2V5IO+8muS7pGk9aSsx77yM54S25ZCO57un57ut6L+b6KGM5q+U6L6D77yMIOebtOWIsGk9auaIlnRlbXA8UltpXS5rZXnkuLrmraLvvJtcclxuICAgIOKXhiDoi6V0ZW1wPFJbaV0ua2V5IO+8mlJbaV3vg55SW2pd77yM6IW+56m6UltpXeeahOS9jee9ru+8jCDkuJTku6RqPWotMe+8m1xyXG4g4pGiIOmHjeWkjeKRoOOAgeKRoe+8jOebtOiHs2k9auS4uuatou+8jGnlsLHmmK90ZW1wKOWfuuWHhinmiYDlupTmlL7nva7nmoTkvY3nva7jgIJcclxuXHJcbiDnrpfms5XliIbmnpBcclxuIOW/q+mAn+aOkuW6j+eahOS4u+imgeaXtumXtOaYr+iKsei0ueWcqOWIkuWIhuS4iu+8jOWvuemVv+W6puS4umvnmoTorrDlvZXluo/liJfov5vooYzliJLliIbml7blhbPplK7lrZfnmoTmr5TovoPmrKHmlbDmmK9rLTEg44CC6K6+6ZW/5bqm5Li6bueahOiusOW9leW6j+WIl+i/m+ihjOaOkuW6j+eahOavlOi+g+asoeaVsOS4ukMobinvvIzliJlDKG4pPW4tMStDKGspK0Mobi1rLTEpIOOAglxyXG4g4peGICDmnIDlpb3mg4XlhrXvvJrmr4/mrKHliJLliIblvpfliLDnmoTlrZDluo/liJflpKfoh7Tnm7jnrYnvvIzliJlcclxuIEMobik8PWjDl24rMmjDl0Mobi8yaCkg77yM5b2Tbi8yaD0x5pe25o6S5bqP57uT5p2f44CCXHJcbiDljbNDKG4p4omkTyhuw5fjj5Iybikg77ybXHJcbiDil4YgIOacgOWdj+aDheWGte+8muavj+asoeWIkuWIhuW+l+WIsOeahOWtkOW6j+WIl+S4reacieS4gOS4quS4uuepuu+8jOWPpuS4gOS4quWtkOW6j+WIl+eahOmVv+W6puS4um4tMeOAguWNs+avj+asoeWIkuWIhuaJgOmAieaLqeeahOWfuuWHhuaYr+W9k+WJjeW+heaOkuW6j+W6j+WIl+S4reeahOacgOWwjyjmiJbmnIDlpKcp5YWz6ZSu5a2X44CCXHJcbiDmr5TovoPmrKHmlbDvvJo6ICDljbNDKG4pPU8objIpXHJcbiDil4YgIOS4gOiIrOaDheWGte+8miDlr7lu5Liq6K6w5b2V6L+b6KGM5b+r6YCf5o6S5bqP5omA6ZyA55qE5pe26Ze0VChuKee7hOaIkOaYr++8mlxyXG4gICAgIOKRoCDlr7lu5Liq6K6w5b2V6L+b6KGM5LiA6Laf5YiS5YiG5omA6ZyA55qE5pe26Ze05piv77yabsOXQyDvvIxD5piv5bi45pWw77ybXHJcbiAgICAg4pGhIOWvueaJgOW+l+WIsOeahOS4pOS4quWtkOW6j+WIl+i/m+ihjOW/q+mAn+aOkuW6j+eahOaXtumXtO+8mlxyXG4gICAgICAgIFRhdmcobik9QyhuKStUYXZnKGstMSkrVGF2ZyhuLWspICAgICAgICAgIOKApuKAplxyXG5cclxuIOW/q+mAn+aOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puaYr++8mlQobik9Tyhu44+SMm4pXHJcbiDku47miYDpnIDopoHnmoTpmYTliqDnqbrpl7TmnaXnnIvvvIzlv6vpgJ/mjpLluo/nrpfms5XmmK/pgJLlvZLosIPnlKjvvIzns7vnu5/lhoXnlKjloIbmoIjkv53lrZjpgJLlvZLlj4LmlbDvvIzlvZPmr4/mrKHliJLliIbmr5TovoPlnYfljIDml7bvvIzmoIjnmoTmnIDlpKfmt7HluqbkuLpb44+SMm5dKzEg44CCXHJcblxyXG4g5b+r6YCf5o6S5bqP55qE56m66Ze05aSN5p2C5bqm5piv77yaUyhuKT1PKOOPkjJuKVxyXG4g5LuO5o6S5bqP55qE56iz5a6a5oCn5p2l55yL77yM5b+r6YCf5o6S5bqP5piv5LiN56iz5a6a55qE44CCXHJcblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHBhcnRpdGlvbjEoc3FMaXN0LCBsb3csIGhpZ2gpIHtcclxuICAgIGxldCB0ZW1wID0gc3FMaXN0W2xvd107XHJcblxyXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCAmJiBzcUxpc3RbaGlnaF0gPj0gdGVtcCktLWhpZ2g7XHJcbiAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbaGlnaF07XHJcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2ggJiYgc3FMaXN0W2xvd10gPD0gdGVtcCkrK2xvdztcclxuICAgICAgICBzcUxpc3RbaGlnaF0gPSBzcUxpc3RbbG93XTtcclxuICAgIH1cclxuXHJcbiAgICBzcUxpc3RbbG93XSA9IHRlbXA7XHJcblxyXG4gICAgcmV0dXJuIGxvdztcclxufVxyXG5cclxuLy8g5LyY5YyW5LiA6Laf5b+r6YCf5o6S5bqP5pa55rOV77yaIOmaj+acuuWMlnBhcnRpdGlvblxyXG4vLyDmnIDlnY/mg4XlhrXmlYjnjoflpKfluYXmj5DljYfvvIzml7bpl7TlpI3mnYLluqZUKG4pPU8obuOPkjJuKVxyXG5mdW5jdGlvbiBwYXJ0aXRpb24yKHNxTGlzdCwgbG93LCBoaWdoKSB7XHJcbiAgICBsZXQgdGVtcDtcclxuICAgIGxldCBuID0gaGlnaCAtIGxvdyArIDE7XHJcbiAgICBsZXQgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG4pICsgbG93O1xyXG5cclxuICAgIC8vbGV0IHJhbmQgPSAobG93ICsgaGlnaCkgPj4gMTtcclxuICAgIHRlbXAgPSBzcUxpc3RbaGlnaF07XHJcbiAgICBzcUxpc3RbaGlnaF0gPSBzcUxpc3RbcmFuZF07XHJcbiAgICBzcUxpc3RbcmFuZF0gPSB0ZW1wO1xyXG5cclxuICAgIGxldCBpID0gbG93IC0gMTtcclxuICAgIGxldCBwaXZvdCA9IHNxTGlzdFtoaWdoXTtcclxuXHJcbiAgICBmb3IgKGxldCBqID0gbG93OyBqIDwgaGlnaDsgKytqKSB7XHJcbiAgICAgICAgaWYgKHNxTGlzdFtqXSA8PSBwaXZvdCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtqXTtcclxuICAgICAgICAgICAgc3FMaXN0W2pdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgKytpO1xyXG4gICAgc3FMaXN0W2hpZ2hdID0gc3FMaXN0W2ldO1xyXG4gICAgc3FMaXN0W2ldID0gcGl2b3Q7XHJcblxyXG4gICAgcmV0dXJuIGk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCkge1xyXG4gICAgbGV0IHRlbXA7XHJcbiAgICBsZXQgaSA9IGxvdztcclxuICAgIGxldCBqID0gaGlnaCArIDE7XHJcbiAgICBsZXQgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkgKyBsb3cgKyAxO1xyXG4gICAgLy9sZXQgcmFuZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xyXG5cclxuICAgIHRlbXAgPSBzcUxpc3RbbG93XTtcclxuICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W3JhbmRdO1xyXG4gICAgc3FMaXN0W3JhbmRdID0gdGVtcDtcclxuXHJcbiAgICBsZXQgeCA9IHNxTGlzdFtsb3ddO1xyXG5cclxuICAgIHdoaWxlICgxKSB7XHJcbiAgICAgICAgd2hpbGUgKGNvbXAoc3FMaXN0WysraV0sIHgpIDwgMCAmJiBpIDwgaGlnaCk7XHJcbiAgICAgICAgd2hpbGUgKGNvbXAoc3FMaXN0Wy0tal0sIHgpID4gMCk7XHJcbiAgICAgICAgaWYgKGkgPj0gaikgYnJlYWs7XHJcbiAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3Rbal07XHJcbiAgICAgICAgc3FMaXN0W2pdID0gdGVtcDtcclxuICAgIH1cclxuXHJcbiAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtqXTtcclxuICAgIHNxTGlzdFtqXSA9IHg7XHJcblxyXG4gICAgcmV0dXJuIGo7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBxdWlja1NvcnRSZWN1cnNpdmUoXHJcbiAgICBzcUxpc3QgPSBbXSxcclxuICAgIGxvdyA9IDAsXHJcbiAgICBoaWdoID0gc3FMaXN0Lmxlbmd0aCAtIDEsXHJcbiAgICBjb21wID0gZGVmYXVsdENvbXBhcmVcclxuKSB7XHJcbiAgICBpZiAobG93ID49IGhpZ2gpIHJldHVybjtcclxuXHJcbiAgICBsZXQgayA9IHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCk7XHJcbiAgICBxdWlja1NvcnRSZWN1cnNpdmUoc3FMaXN0LCBsb3csIGsgLSAxLCBjb21wKTtcclxuICAgIHF1aWNrU29ydFJlY3Vyc2l2ZShzcUxpc3QsIGsgKyAxLCBoaWdoLCBjb21wKTtcclxufVxyXG5cclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbnF1aWNrU29ydFJlY3Vyc2l2ZShhcnIpO1xyXG5jb25zb2xlLmxvZygncXVpY2tTb3J0UmVjdXJzaXZlOlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuLypcclxu5b+r5o6S6YCS5b2S566X5rOV5LyY5YyW77yM5Zyo5pyA5Z2P5oOF5Ya15LiL5aCG5qCI5rex5bqm5Li6Tyhsb2duKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHF1aWNrU29ydFJlY3Vyc2l2ZTIoXHJcbiAgICBzcUxpc3QgPSBbXSxcclxuICAgIGxvdyA9IDAsXHJcbiAgICBoaWdoID0gc3FMaXN0Lmxlbmd0aCAtIDEsXHJcbiAgICBjb21wID0gZGVmYXVsdENvbXBhcmVcclxuKSB7XHJcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xyXG4gICAgICAgIGxldCBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuXHJcbiAgICAgICAgLy8g5a+55Lik5Liq5a2Q5pWw57uE5Lit6L6D5bCP55qE5LiA5Liq5a2Q5pWw57uE6L+b6KGM6YCS5b2S6LCD55So44CCXHJcbiAgICAgICAgLy8g6L6D5bCP5a2Q5pWw57uE55qE5aSn5bCP5pyA5aSa5Li65Y6f5pWw57uE5aSn5bCP5LiA5Y2K77yMXHJcbiAgICAgICAgLy8g55Sx5LqO5q+P5qyh6YCS5b2S6LCD55So55qE5pWw57uE5aSn5bCP6Iez5bCR5YeP5bCR5LiA5Y2K77yM5omA5Lul6YCS5b2S6LCD55So55qE5qyh5pWwXHJcbiAgICAgICAgLy8g5pyA5aSa5Li6Tyhsb2duKVxyXG4gICAgICAgIGlmIChrIC0gbG93ICsgMSA8IGhpZ2ggLSBrKSB7XHJcbiAgICAgICAgICAgIHF1aWNrU29ydFJlY3Vyc2l2ZTIoc3FMaXN0LCBsb3csIGsgLSAxLCBjb21wKTtcclxuICAgICAgICAgICAgbG93ID0gayArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXVpY2tTb3J0UmVjdXJzaXZlMihzcUxpc3QsIGsgKyAxLCBoaWdoLCBjb21wKTtcclxuICAgICAgICAgICAgaGlnaCA9IGsgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5xdWlja1NvcnRSZWN1cnNpdmUyKGFycik7XHJcbmNvbnNvbGUubG9nKCdxdWlja1NvcnRSZWN1cnNpdmUyOlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHF1aWNrU29ydE5vblJlY3Vyc2l2ZShcclxuICAgIHNxTGlzdCA9IFtdLFxyXG4gICAgbG93ID0gMCxcclxuICAgIGhpZ2ggPSBzcUxpc3QubGVuZ3RoIC0gMSxcclxuICAgIGNvbXAgPSBkZWZhdWx0Q29tcGFyZVxyXG4pIHtcclxuICAgIGxldCBzdGFjayA9IFtdO1xyXG4gICAgbGV0IGs7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgICAgICAgIGsgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xyXG4gICAgICAgICAgICAvLyDnrKzkuozkuKrlrZDluo/liJfnmoTkuIos5LiL55WM5YiG5Yir5YWl5qCIXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaGlnaCwgayArIDEpO1xyXG4gICAgICAgICAgICAvL3N0YWNrLnB1c2goayArIDEpO1xyXG4gICAgICAgICAgICBoaWdoID0gayAtIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsb3cgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICBoaWdoID0gc3RhY2sucG9wKCk7XHJcbiAgICB9IHdoaWxlICgxKTtcclxufVxyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxucXVpY2tTb3J0Tm9uUmVjdXJzaXZlKGFycik7XHJcbmNvbnNvbGUubG9nKCdxdWlja1NvcnROb25SZWN1cnNpdmU6XFxuJyArIGFyciArICcnKTtcclxuXHJcbi8vIOS8mOWMlueJiOacrFxyXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0KFxyXG4gICAgc3FMaXN0ID0gW10sXHJcbiAgICBsb3cgPSAwLFxyXG4gICAgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxLFxyXG4gICAgY29tcCA9IGRlZmF1bHRDb21wYXJlXHJcbikge1xyXG4gICAgbGV0IHN0YWNrID0gW107XHJcbiAgICBsZXQgcGl2b3Q7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIC8vIOWmguaenOW9k+WJjeWtkOW6j+WIl+mVv+W6puWkp+S6jjPkuJTlsJrmnKrmjpLlpb3luo9cclxuICAgICAgICBpZiAoaGlnaCAtIGxvdyA+IDIpIHtcclxuICAgICAgICAgICAgLy8g6L+b6KGM5LiA6Laf5YiS5YiGXHJcbiAgICAgICAgICAgIHBpdm90ID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOWQp+mVv+eahOWtkOW6j+WIl+i+ueeVjOWFpeagiO+8jFxyXG4gICAgICAgICAgICAvLyDnn63nmoTlrZDluo/liJfnlZnlvoXkuIvmrKHmjpLluo9cclxuICAgICAgICAgICAgaWYgKGhpZ2ggLSBwaXZvdCA+IHBpdm90IC0gbG93KSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGhpZ2gsIHBpdm90ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBwaXZvdCAtIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBpdm90IC0gMSwgbG93KTtcclxuICAgICAgICAgICAgICAgIC8vc3RhY2sucHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgbG93ID0gcGl2b3QgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWmguaenOW9k+WJjeWtkOW6j+WIl+mVv+W6puWwj+S6jjPvvIzkuJTlsJrmnKrmjpLlpb3luo/vvIxcclxuICAgICAgICAvLyDnm7TmjqXov5vooYzmr5TovoPmjpLluo/kubDlvZPliY3lrZDluo/liJfmoIflv5fkuLrlt7LmjpLlpb3luo9cclxuICAgICAgICBlbHNlIGlmIChsb3cgPCBoaWdoICYmIGhpZ2ggLSBsb3cgPCAzKSB7XHJcbiAgICAgICAgICAgIGVhc3lTb3J0KHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuICAgICAgICAgICAgbG93ID0gaGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5aaC5p6c5b2T5YmN5a2Q5bqP5YiX5bey5o6S5aW95bqP5L2G5qCI5Lit6L+Y5pyJ5pyq5o6S5bqP55qE5a2Q5bqP5YiXXHJcbiAgICAgICAgLy8g5LuO5qCI5Lit5Y+W5Ye65LiA5Liq5a2Q5bqP5YiXXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsb3cgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgaGlnaCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlYXN5U29ydChzcUxpc3QsIGxvdywgaGlnaCwgY29tcCkge1xyXG4gICAgbGV0IHRlbXA7XHJcblxyXG4gICAgaWYgKGhpZ2ggLSBsb3cgPT09IDEpIHtcclxuICAgICAgICBpZiAoY29tcChzcUxpc3RbbG93XSwgc3FMaXN0W2hpZ2hdKSA+IDApIHtcclxuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtoaWdoXTtcclxuICAgICAgICAgICAgc3FMaXN0W2hpZ2hdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbbG93ICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2xvdyArIDFdO1xyXG4gICAgICAgICAgICBzcUxpc3RbbG93ICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcChzcUxpc3RbbG93ICsgMV0sIHNxTGlzdFtoaWdoXSkgPiAwKSB7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbbG93ICsgMV07XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHNxTGlzdFtoaWdoXTtcclxuICAgICAgICAgICAgc3FMaXN0W2hpZ2hdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvd10sIHNxTGlzdFtsb3cgKyAxXSkgPiAwKSB7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbbG93XTtcclxuICAgICAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbbG93ICsgMV07XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5xdWlja1NvcnQoYXJyKTtcclxuY29uc29sZS5sb2coJ3F1aWNrU29ydDpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8vIOWlh+WBtuS6pOaNouaOkuW6j1xyXG5leHBvcnQgZnVuY3Rpb24gb2RkRXZlblNvcnQoc3FMaXN0ID0gW10sIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xyXG4gICAgbGV0IGNoYW5nZSA9IDE7XHJcbiAgICBsZXQgdGVtcDtcclxuICAgIGxldCBsZW4gPSBzcUxpc3QubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChjaGFuZ2UpIHtcclxuICAgICAgICBjaGFuZ2UgPSAwO1xyXG4gICAgICAgIC8vIOWvueaJgOacieWlh+aVsOi/m+ihjOS4gOi2n+avlOi+g1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuIC0gMTsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgMV0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWvueaJgOacieWBtuaVsOi/m+ihjOS4gOi2n+avlOi+g1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgMV0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbm9kZEV2ZW5Tb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKCdvZGRFdmVuU29ydDpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbuaKiueUseS4ieenjeminOiJsue7hOaIkOeahOW6j+WIl+mHjeaOkuS4uuaMieeFp+e6oueZveiTneeahOmhuuW6j+aOkuWIl++8jFxyXG7mgJ3ot6/vvJpcclxu6K6+56uL5LiJ5Liq5oyH6ZKI77yM5YW25LitauihqOekuuW9k+WJjeWFg+e0oO+8m2nku6XliY3nmoTlhYPntKDlhajpg6jkuLrnuqLoibLvvJtr5Lul5ZCO55qE6aKc6Imy5YWo5Li66JOd6Imy44CC6L+Z5qC35bCx5Y+v5Lul5qC55o2uaueahOminOiJsuaKiuWFtuS6pOaNouWIsOW6j+WIl+eahOWJjemdouaIluiAheWQjumdouOAglxyXG4gKi9cclxuY29uc3QgUkVEID0gMDtcclxuY29uc3QgV0hJVEUgPSAxO1xyXG5jb25zdCBCTFVFID0gMjtcclxuXHJcbmZ1bmN0aW9uIGZsYWdBcnJhbmdlKGNvbG9ycykge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IGogPSAwO1xyXG4gICAgbGV0IGsgPSBjb2xvcnMubGVuZ3RoIC0gMTtcclxuICAgIGxldCB0ZW1wO1xyXG5cclxuICAgIHdoaWxlIChqIDw9IGspIHtcclxuICAgICAgICBzd2l0Y2ggKGNvbG9yc1tqXSkge1xyXG4gICAgICAgICAgICBjYXNlIFJFRDpcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBjb2xvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSBjb2xvcnNbal07XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbal0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgKytqO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV0hJVEU6XHJcbiAgICAgICAgICAgICAgICArK2o7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCTFVFOlxyXG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbG9yc1tqXTtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tqXSA9IGNvbG9yc1trXTtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1trXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICAtLWs7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudmFyIGFyciA9IFsyLCAxLCAwLCAyLCAxLCAxLCAwLCAyLCAwLCAyLCAxXTtcclxuZmxhZ0FycmFuZ2UoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvZXhjaGFuZ2UvaW5kZXguanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgIH1cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYXNlNjQtanMvbGliL2I2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJy4vY3JlYXRlLWhhc2gnKVxuXG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoMTI4KVxuemVyb0J1ZmZlci5maWxsKDApXG5cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSkgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxuICB0aGlzLl9vcGFkID0gb3BhZFxuICB0aGlzLl9hbGcgPSBhbGdcblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicpID8gMTI4IDogNjRcblxuICBrZXkgPSB0aGlzLl9rZXkgPSAhQnVmZmVyLmlzQnVmZmVyKGtleSkgPyBuZXcgQnVmZmVyKGtleSkgOiBrZXlcblxuICBpZihrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG4gIH0gZWxzZSBpZihrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCB6ZXJvQnVmZmVyXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSwgZW5jKVxuICByZXR1cm4gdGhpc1xufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICByZXR1cm4gY3JlYXRlSGFzaCh0aGlzLl9hbGcpLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KGVuYylcbn1cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3J5cHRvLWJyb3dzZXJpZnkvY3JlYXRlLWhtYWMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBoYXNoOiBoYXNoIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9oZWxwZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9ybmcnKVxuXG5mdW5jdGlvbiBlcnJvciAoKSB7XG4gIHZhciBtID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKVxuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgIG0sXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cDovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVIYXNoID0gcmVxdWlyZSgnLi9jcmVhdGUtaGFzaCcpXG5cbmV4cG9ydHMuY3JlYXRlSG1hYyA9IHJlcXVpcmUoJy4vY3JlYXRlLWhtYWMnKVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIG5ldyBCdWZmZXIocm5nKHNpemUpKSlcbiAgICB9IGNhdGNoIChlcnIpIHsgY2FsbGJhY2soZXJyKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIocm5nKHNpemUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYSwgZikge1xuICBmb3IodmFyIGkgaW4gYSlcbiAgICBmKGFbaV0sIGkpXG59XG5cbmV4cG9ydHMuZ2V0SGFzaGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gWydzaGExJywgJ3NoYTI1NicsICdzaGE1MTInLCAnbWQ1JywgJ3JtZDE2MCddXG59XG5cbnZhciBwID0gcmVxdWlyZSgnLi9wYmtkZjInKShleHBvcnRzKVxuZXhwb3J0cy5wYmtkZjIgPSBwLnBia2RmMlxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcC5wYmtkZjJTeW5jXG5cblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG5lYWNoKFsnY3JlYXRlQ3JlZGVudGlhbHMnXG4sICdjcmVhdGVDaXBoZXInXG4sICdjcmVhdGVDaXBoZXJpdidcbiwgJ2NyZWF0ZURlY2lwaGVyJ1xuLCAnY3JlYXRlRGVjaXBoZXJpdidcbiwgJ2NyZWF0ZVNpZ24nXG4sICdjcmVhdGVWZXJpZnknXG4sICdjcmVhdGVEaWZmaWVIZWxsbWFuJ1xuXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjEgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG5cbn1cblxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cbmZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdClcbntcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XG59XG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZDUoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX21kNSwgMTYpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L21kNS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBia2RmMkV4cG9ydCA9IHJlcXVpcmUoJ3Bia2RmMi1jb21wYXQvcGJrZGYyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3J5cHRvLCBleHBvcnRzKSB7XG4gIGV4cG9ydHMgPSBleHBvcnRzIHx8IHt9XG5cbiAgdmFyIGV4cG9ydGVkID0gcGJrZGYyRXhwb3J0KGNyeXB0bylcblxuICBleHBvcnRzLnBia2RmMiA9IGV4cG9ydGVkLnBia2RmMlxuICBleHBvcnRzLnBia2RmMlN5bmMgPSBleHBvcnRlZC5wYmtkZjJTeW5jXG5cbiAgcmV0dXJuIGV4cG9ydHNcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L3Bia2RmMi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgZyA9ICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdpbmRvdyA/IGdsb2JhbCA6IHdpbmRvdykgfHwge31cbiAgX2NyeXB0byA9IChcbiAgICBnLmNyeXB0byB8fCBnLm1zQ3J5cHRvIHx8IHJlcXVpcmUoJ2NyeXB0bycpXG4gIClcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgLy8gTW9kZXJuIEJyb3dzZXJzXG4gICAgaWYoX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBCdWZmZXIoc2l6ZSk7IC8vaW4gYnJvd3NlcmlmeSwgdGhpcyBpcyBhbiBleHRlbmRlZCBVaW50OEFycmF5XG4gICAgICAvKiBUaGlzIHdpbGwgbm90IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMuXG4gICAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAgKi9cbiAgICBcbiAgICAgIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2NyeXB0by5yYW5kb21CeXRlcykge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSlcbiAgICB9XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclxcbicrXG4gICAgICAgICd1c2UgY2hyb21lLCBGaXJlRm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExJ1xuICAgICAgKVxuICB9XG59KCkpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuXHRDLWxpa2UgdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VycyBpbiBKYXZhc2NyaXB0XG5cdENvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5cdE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKHJvb3QpIHtcblxuXHQvLyBMb2NhbCBjYWNoZSBmb3IgdHlwaWNhbCByYWRpY2VzXG5cdHZhciByYWRpeFBvd2VyQ2FjaGUgPSB7XG5cdFx0MzY6IFVJTlQzMiggTWF0aC5wb3coMzYsIDUpIClcblx0LFx0MTY6IFVJTlQzMiggTWF0aC5wb3coMTYsIDcpIClcblx0LFx0MTA6IFVJTlQzMiggTWF0aC5wb3coMTAsIDkpIClcblx0LFx0MjogIFVJTlQzMiggTWF0aC5wb3coMiwgMzApIClcblx0fVxuXHR2YXIgcmFkaXhDYWNoZSA9IHtcblx0XHQzNjogVUlOVDMyKDM2KVxuXHQsXHQxNjogVUlOVDMyKDE2KVxuXHQsXHQxMDogVUlOVDMyKDEwKVxuXHQsXHQyOiAgVUlOVDMyKDIpXG5cdH1cblxuXHQvKipcblx0ICpcdFJlcHJlc2VudHMgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8TnVtYmVyfSBsb3cgYml0cyAgICAgfCBpbnRlZ2VyIGFzIGEgc3RyaW5nIFx0XHQgfCBpbnRlZ2VyIGFzIGEgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcnxVbmRlZmluZWR9IGhpZ2ggYml0cyB8IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBcblx0ICovXG5cdGZ1bmN0aW9uIFVJTlQzMiAobCwgaCkge1xuXHRcdGlmICggISh0aGlzIGluc3RhbmNlb2YgVUlOVDMyKSApXG5cdFx0XHRyZXR1cm4gbmV3IFVJTlQzMihsLCBoKVxuXG5cdFx0dGhpcy5fbG93ID0gMFxuXHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0dGhpcy5yZW1haW5kZXIgPSBudWxsXG5cdFx0aWYgKHR5cGVvZiBoID09ICd1bmRlZmluZWQnKVxuXHRcdFx0cmV0dXJuIGZyb21OdW1iZXIuY2FsbCh0aGlzLCBsKVxuXG5cdFx0aWYgKHR5cGVvZiBsID09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIGZyb21TdHJpbmcuY2FsbCh0aGlzLCBsLCBoKVxuXG5cdFx0ZnJvbUJpdHMuY2FsbCh0aGlzLCBsLCBoKVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3Qgd2l0aCBpdHMgbG93IGFuZCBoaWdoIGJpdHNcblx0ICogQG1ldGhvZCBmcm9tQml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0c1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tQml0cyAobCwgaCkge1xuXHRcdHRoaXMuX2xvdyA9IGwgfCAwXG5cdFx0dGhpcy5faGlnaCA9IGggfCAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQzMi5wcm90b3R5cGUuZnJvbUJpdHMgPSBmcm9tQml0c1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IGZyb20gYSBudW1iZXJcblx0ICogQG1ldGhvZCBmcm9tTnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbU51bWJlciAodmFsdWUpIHtcblx0XHR0aGlzLl9sb3cgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2YWx1ZSA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnJvbU51bWJlclxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IGZyb20gYSBzdHJpbmdcblx0ICogQG1ldGhvZCBmcm9tU3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlZ2VyIGFzIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHMsIHJhZGl4KSB7XG5cdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQocywgcmFkaXggfHwgMTApXG5cblx0XHR0aGlzLl9sb3cgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2YWx1ZSA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZ1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQzMl8gdG8gYSBudW1iZXJcblx0ICogQG1ldGhvZCB0b051bWJlclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb252ZXJ0ZWQgVUlOVDMyXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAodGhpcy5faGlnaCA8PCAxNikgfCB0aGlzLl9sb3dcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQzMl8gdG8gYSBzdHJpbmdcblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBjb252ZXJ0ZWQgVUlOVDMyXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4KSB7XG5cdFx0cmFkaXggPSByYWRpeCB8fCAxMFxuXHRcdHZhciByYWRpeFVpbnQgPSByYWRpeENhY2hlW3JhZGl4XSB8fCBuZXcgVUlOVDMyKHJhZGl4KVxuXG5cdFx0aWYgKCAhdGhpcy5ndChyYWRpeFVpbnQpICkgcmV0dXJuIHRoaXMudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblxuXHRcdHZhciBzZWxmID0gdGhpcy5jbG9uZSgpXG5cdFx0dmFyIHJlcyA9IG5ldyBBcnJheSgzMilcblx0XHRmb3IgKHZhciBpID0gMzE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRzZWxmLmRpdihyYWRpeFVpbnQpXG5cdFx0XHRyZXNbaV0gPSBzZWxmLnJlbWFpbmRlci50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXHRcdFx0aWYgKCAhc2VsZi5ndChyYWRpeFVpbnQpICkgYnJlYWtcblx0XHR9XG5cdFx0cmVzW2ktMV0gPSBzZWxmLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cblx0XHRyZXR1cm4gcmVzLmpvaW4oJycpXG5cdH1cblxuXHQvKipcblx0ICogQWRkIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3cgKyBvdGhlci5fbG93XG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblxuXHRcdGExNiArPSB0aGlzLl9oaWdoICsgb3RoZXIuX2hpZ2hcblxuXHRcdHRoaXMuX2xvdyA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBhMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3QgdHdvIF9VSU5UMzJfLiBUaGUgY3VycmVudCBfVUlOVDMyXyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIHN1YnRyYWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdC8vVE9ETyBpbmxpbmVcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNlxuXHRcdFx0YiA9IGIwMCArIGIxNlxuXHRcdFx0YSpiID0gKGEwMCArIGExNikoYjAwICsgYjE2KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGExNmIwMCArIGExNmIxNlxuXG5cdFx0XHRhMTZiMTYgb3ZlcmZsb3dzIHRoZSAzMmJpdHNcblx0XHQgKi9cblx0XHR2YXIgYTE2ID0gdGhpcy5faGlnaFxuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3dcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2hpZ2hcblx0XHR2YXIgYjAwID0gb3RoZXIuX2xvd1xuXG4vKiBSZW1vdmVkIHRvIGluY3JlYXNlIHNwZWVkIHVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzIChpLmUuIG5vdCBtdWx0aXBseWluZyBieSAwIG9yIDEpXG5cdFx0Ly8gdGhpcyA9PSAwIG9yIG90aGVyID09IDE6IG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoKGEwMCA9PSAwICYmIGExNiA9PSAwKSB8fCAoYjAwID09IDEgJiYgYjE2ID09IDApKSByZXR1cm4gdGhpc1xuXG5cdFx0Ly8gb3RoZXIgPT0gMCBvciB0aGlzID09IDE6IHRoaXMgPSBvdGhlclxuXHRcdGlmICgoYjAwID09IDAgJiYgYjE2ID09IDApIHx8IChhMDAgPT0gMSAmJiBhMTYgPT0gMCkpIHtcblx0XHRcdHRoaXMuX2xvdyA9IG90aGVyLl9sb3dcblx0XHRcdHRoaXMuX2hpZ2ggPSBvdGhlci5faGlnaFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG4qL1xuXG5cdFx0dmFyIGMxNiwgYzAwXG5cdFx0YzAwID0gYTAwICogYjAwXG5cdFx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdFx0YzE2ICs9IGExNiAqIGIwMFxuXHRcdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblxuXHRcdHRoaXMuX2xvdyA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBjMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDMyXyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fbG93ID09IDApICYmIChvdGhlci5faGlnaCA9PSAwKSApIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcblxuXHRcdC8vIG90aGVyID09IDFcblx0XHRpZiAob3RoZXIuX2hpZ2ggPT0gMCAmJiBvdGhlci5fbG93ID09IDEpIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBvdGhlciA+IHRoaXM6IDBcblx0XHRpZiAoIG90aGVyLmd0KHRoaXMpICkge1xuXHRcdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0dGhpcy5fbG93ID0gMVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2xvdyA9IDBcblx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9oaWdoIHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9sb3cgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2xvdyAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gKH50aGlzLl9oaWdoICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRXF1YWxzXG5cdCAqIEBtZXRob2QgZXFcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5lcXVhbHMgPSBVSU5UMzIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9sb3cgPT0gb3RoZXIuX2xvdykgJiYgKHRoaXMuX2hpZ2ggPT0gb3RoZXIuX2hpZ2gpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoIDwgb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPiBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoID4gb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPCBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBPUlxuXHQgKiBAbWV0aG9kIG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyB8PSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCB8PSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93ICY9IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoICY9IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbG93ID0gfnRoaXMuX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB+dGhpcy5faGlnaCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIFhPUlxuXHQgKiBAbWV0aG9kIHhvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93IF49IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoIF49IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgcmlnaHRcblx0ICogQG1ldGhvZCBzaGlmdFJpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnNoaWZ0ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0aWYgKG4gPiAxNikge1xuXHRcdFx0dGhpcy5fbG93ID0gdGhpcy5faGlnaCA+PiAobiAtIDE2KVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2hcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPj4gbikgfCAoICh0aGlzLl9oaWdoIDw8ICgxNi1uKSkgJiAweEZGRkYgKVxuXHRcdFx0dGhpcy5faGlnaCA+Pj0gblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCBsZWZ0XG5cdCAqIEBtZXRob2Qgc2hpZnRMZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93IG92ZXJmbG93XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdGwgPSBmdW5jdGlvbiAobiwgYWxsb3dPdmVyZmxvdykge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3cgPDwgKG4gLSAxNilcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobiA9PSAxNikge1xuXHRcdFx0dGhpcy5faGlnaCA9IHRoaXMuX2xvd1xuXHRcdFx0dGhpcy5fbG93ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gKHRoaXMuX2hpZ2ggPDwgbikgfCAodGhpcy5fbG93ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPDwgbikgJiAweEZGRkZcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHQvLyBPdmVyZmxvdyBvbmx5IGFsbG93ZWQgb24gdGhlIGhpZ2ggYml0cy4uLlxuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UMzIucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2IDw8IG4pIHwgKHYgPj4+ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQzMi5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0dmFyIHYgPSAodGhpcy5faGlnaCA8PCAxNikgfCB0aGlzLl9sb3dcblx0XHR2ID0gKHYgPj4+IG4pIHwgKHYgPDwgKDMyIC0gbikpXG5cdFx0dGhpcy5fbG93ID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2ID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQzMih0aGlzLl9sb3csIHRoaXMuX2hpZ2gpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDMyXG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDMyXG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQzMiddID0gVUlOVDMyXG5cdH1cblxufSkodGhpcylcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2N1aW50L2xpYi91aW50MzIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuXHRDLWxpa2UgdW5zaWduZWQgNjQgYml0cyBpbnRlZ2VycyBpbiBKYXZhc2NyaXB0XG5cdENvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5cdE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKHJvb3QpIHtcblxuXHQvLyBMb2NhbCBjYWNoZSBmb3IgdHlwaWNhbCByYWRpY2VzXG5cdHZhciByYWRpeFBvd2VyQ2FjaGUgPSB7XG5cdFx0MTY6IFVJTlQ2NCggTWF0aC5wb3coMTYsIDUpIClcblx0LFx0MTA6IFVJTlQ2NCggTWF0aC5wb3coMTAsIDUpIClcblx0LFx0MjogIFVJTlQ2NCggTWF0aC5wb3coMiwgNSkgKVxuXHR9XG5cdHZhciByYWRpeENhY2hlID0ge1xuXHRcdDE2OiBVSU5UNjQoMTYpXG5cdCxcdDEwOiBVSU5UNjQoMTApXG5cdCxcdDI6ICBVSU5UNjQoMilcblx0fVxuXG5cdC8qKlxuXHQgKlx0UmVwcmVzZW50cyBhbiB1bnNpZ25lZCA2NCBiaXRzIGludGVnZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGhpZ2ggYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBoaWdoIGJpdHMgKDgpXG5cdCAqIG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0cyAoMzIpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIGJpdHMgKDMyKVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGludGVnZXIgYXMgYSBzdHJpbmcgXHRcdCB8IGludGVnZXIgYXMgYSBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ8VW5kZWZpbmVkfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gXG5cdCAqL1xuXHRmdW5jdGlvbiBVSU5UNjQgKGEwMCwgYTE2LCBhMzIsIGE0OCkge1xuXHRcdGlmICggISh0aGlzIGluc3RhbmNlb2YgVUlOVDY0KSApXG5cdFx0XHRyZXR1cm4gbmV3IFVJTlQ2NChhMDAsIGExNiwgYTMyLCBhNDgpXG5cblx0XHR0aGlzLnJlbWFpbmRlciA9IG51bGxcblx0XHRpZiAodHlwZW9mIGEwMCA9PSAnc3RyaW5nJylcblx0XHRcdHJldHVybiBmcm9tU3RyaW5nLmNhbGwodGhpcywgYTAwLCBhMTYpXG5cblx0XHRpZiAodHlwZW9mIGExNiA9PSAndW5kZWZpbmVkJylcblx0XHRcdHJldHVybiBmcm9tTnVtYmVyLmNhbGwodGhpcywgYTAwKVxuXG5cdFx0ZnJvbUJpdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3Qgd2l0aCBpdHMgbG93IGFuZCBoaWdoIGJpdHNcblx0ICogQG1ldGhvZCBmcm9tQml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBoaWdoIGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgaGlnaCBiaXRzICg4KVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHMgKDMyKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzICgzMilcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbUJpdHMgKGEwMCwgYTE2LCBhMzIsIGE0OCkge1xuXHRcdGlmICh0eXBlb2YgYTMyID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aGlzLl9hMDAgPSBhMDAgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9IGEwMCA+Pj4gMTZcblx0XHRcdHRoaXMuX2EzMiA9IGExNiAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTQ4ID0gYTE2ID4+PiAxNlxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHR0aGlzLl9hMDAgPSBhMDAgfCAwXG5cdFx0dGhpcy5fYTE2ID0gYTE2IHwgMFxuXHRcdHRoaXMuX2EzMiA9IGEzMiB8IDBcblx0XHR0aGlzLl9hNDggPSBhNDggfCAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQ2NC5wcm90b3R5cGUuZnJvbUJpdHMgPSBmcm9tQml0c1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IGZyb20gYSBudW1iZXJcblx0ICogQG1ldGhvZCBmcm9tTnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbU51bWJlciAodmFsdWUpIHtcblx0XHR0aGlzLl9hMDAgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IHZhbHVlID4+PiAxNlxuXHRcdHRoaXMuX2EzMiA9IDBcblx0XHR0aGlzLl9hNDggPSAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQ2NC5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZyb21OdW1iZXJcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCBmcm9tIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgZnJvbVN0cmluZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZWdlciBhcyBhIHN0cmluZ1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tU3RyaW5nIChzLCByYWRpeCkge1xuXHRcdHJhZGl4ID0gcmFkaXggfHwgMTBcblxuXHRcdHRoaXMuX2EwMCA9IDBcblx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblxuXHRcdC8qXG5cdFx0XHRJbiBKYXZhc2NyaXB0LCBiaXR3aXNlIG9wZXJhdG9ycyBvbmx5IG9wZXJhdGUgb24gdGhlIGZpcnN0IDMyIGJpdHMgXG5cdFx0XHRvZiBhIG51bWJlciwgZXZlbiB0aG91Z2ggcGFyc2VJbnQoKSBlbmNvZGVzIG51bWJlcnMgd2l0aCBhIDUzIGJpdHMgXG5cdFx0XHRtYW50aXNzYS5cblx0XHRcdFRoZXJlZm9yZSBVSU5UNjQoPE51bWJlcj4pIGNhbiBvbmx5IHdvcmsgb24gMzIgYml0cy5cblx0XHRcdFRoZSByYWRpeCBtYXhpbXVtIHZhbHVlIGlzIDM2IChhcyBwZXIgRUNNQSBzcGVjcykgKDI2IGxldHRlcnMgKyAxMCBkaWdpdHMpXG5cdFx0XHRtYXhpbXVtIGlucHV0IHZhbHVlIGlzIG0gPSAzMmJpdHMgYXMgMSA9IDJeMzIgLSAxXG5cdFx0XHRTbyB0aGUgbWF4aW11bSBzdWJzdHJpbmcgbGVuZ3RoIG4gaXM6XG5cdFx0XHQzNl4obisxKSAtIDEgPSAyXjMyIC0gMVxuXHRcdFx0MzZeKG4rMSkgPSAyXjMyXG5cdFx0XHQobisxKWxuKDM2KSA9IDMybG4oMilcblx0XHRcdG4gPSAzMmxuKDIpL2xuKDM2KSAtIDFcblx0XHRcdG4gPSA1LjE4OTY0NDkxNTY4NzY5MlxuXHRcdFx0biA9IDVcblx0XHQgKi9cblx0XHR2YXIgcmFkaXhVaW50ID0gcmFkaXhQb3dlckNhY2hlW3JhZGl4XSB8fCBuZXcgVUlOVDY0KCBNYXRoLnBvdyhyYWRpeCwgNSkgKVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDUpIHtcblx0XHRcdHZhciBzaXplID0gTWF0aC5taW4oNSwgbGVuIC0gaSlcblx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlSW50KCBzLnNsaWNlKGksIGkgKyBzaXplKSwgcmFkaXggKVxuXHRcdFx0dGhpcy5tdWx0aXBseShcblx0XHRcdFx0XHRzaXplIDwgNVxuXHRcdFx0XHRcdFx0PyBuZXcgVUlOVDY0KCBNYXRoLnBvdyhyYWRpeCwgc2l6ZSkgKVxuXHRcdFx0XHRcdFx0OiByYWRpeFVpbnRcblx0XHRcdFx0KVxuXHRcdFx0XHQuYWRkKCBuZXcgVUlOVDY0KHZhbHVlKSApXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDY0XyB0byBhIG51bWJlciAobGFzdCAzMiBiaXRzIGFyZSBkcm9wcGVkKVxuXHQgKiBAbWV0aG9kIHRvTnVtYmVyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbnZlcnRlZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9hMTYgPDwgMTYpIHwgdGhpcy5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UNjRfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJhZGl4ID0gcmFkaXggfHwgMTBcblx0XHR2YXIgcmFkaXhVaW50ID0gcmFkaXhDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQ2NChyYWRpeClcblxuXHRcdGlmICggIXRoaXMuZ3QocmFkaXhVaW50KSApIHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cblx0XHR2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKVxuXHRcdHZhciByZXMgPSBuZXcgQXJyYXkoNjQpXG5cdFx0Zm9yICh2YXIgaSA9IDYzOyBpID49IDA7IGktLSkge1xuXHRcdFx0c2VsZi5kaXYocmFkaXhVaW50KVxuXHRcdFx0cmVzW2ldID0gc2VsZi5yZW1haW5kZXIudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblx0XHRcdGlmICggIXNlbGYuZ3QocmFkaXhVaW50KSApIGJyZWFrXG5cdFx0fVxuXHRcdHJlc1tpLTFdID0gc2VsZi50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0cmV0dXJuIHJlcy5qb2luKCcnKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR2YXIgYTAwID0gdGhpcy5fYTAwICsgb3RoZXIuX2EwMFxuXG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblx0XHRhMTYgKz0gdGhpcy5fYTE2ICsgb3RoZXIuX2ExNlxuXG5cdFx0dmFyIGEzMiA9IGExNiA+Pj4gMTZcblx0XHRhMzIgKz0gdGhpcy5fYTMyICsgb3RoZXIuX2EzMlxuXG5cdFx0dmFyIGE0OCA9IGEzMiA+Pj4gMTZcblx0XHRhNDggKz0gdGhpcy5fYTQ4ICsgb3RoZXIuX2E0OFxuXG5cdFx0dGhpcy5fYTAwID0gYTAwICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gYTE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gYTMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gYTQ4ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0IHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBzdWJ0cmFjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNiArIGEzMiArIGE0OFxuXHRcdFx0YiA9IGIwMCArIGIxNiArIGIzMiArIGI0OFxuXHRcdFx0YSpiID0gKGEwMCArIGExNiArIGEzMiArIGE0OCkoYjAwICsgYjE2ICsgYjMyICsgYjQ4KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGEwMGIzMiArIGEwMGI0OFxuXHRcdFx0XHQrIGExNmIwMCArIGExNmIxNiArIGExNmIzMiArIGExNmI0OFxuXHRcdFx0XHQrIGEzMmIwMCArIGEzMmIxNiArIGEzMmIzMiArIGEzMmI0OFxuXHRcdFx0XHQrIGE0OGIwMCArIGE0OGIxNiArIGE0OGIzMiArIGE0OGI0OFxuXG5cdFx0XHRhMTZiNDgsIGEzMmIzMiwgYTQ4YjE2LCBhNDhiMzIgYW5kIGE0OGI0OCBvdmVyZmxvdyB0aGUgNjQgYml0c1xuXHRcdFx0c28gaXQgY29tZXMgZG93biB0bzpcblx0XHRcdGEqYlx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMDBiMzIgKyBhMDBiNDhcblx0XHRcdFx0KyBhMTZiMDAgKyBhMTZiMTYgKyBhMTZiMzJcblx0XHRcdFx0KyBhMzJiMDAgKyBhMzJiMTZcblx0XHRcdFx0KyBhNDhiMDBcblx0XHRcdFx0PSBhMDBiMDBcblx0XHRcdFx0KyBhMDBiMTYgKyBhMTZiMDBcblx0XHRcdFx0KyBhMDBiMzIgKyBhMTZiMTYgKyBhMzJiMDBcblx0XHRcdFx0KyBhMDBiNDggKyBhMTZiMzIgKyBhMzJiMTYgKyBhNDhiMDBcblx0XHQgKi9cblx0XHR2YXIgYTAwID0gdGhpcy5fYTAwXG5cdFx0dmFyIGExNiA9IHRoaXMuX2ExNlxuXHRcdHZhciBhMzIgPSB0aGlzLl9hMzJcblx0XHR2YXIgYTQ4ID0gdGhpcy5fYTQ4XG5cdFx0dmFyIGIwMCA9IG90aGVyLl9hMDBcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2ExNlxuXHRcdHZhciBiMzIgPSBvdGhlci5fYTMyXG5cdFx0dmFyIGI0OCA9IG90aGVyLl9hNDhcblxuXHRcdHZhciBjMDAgPSBhMDAgKiBiMDBcblxuXHRcdHZhciBjMTYgPSBjMDAgPj4+IDE2XG5cdFx0YzE2ICs9IGEwMCAqIGIxNlxuXHRcdHZhciBjMzIgPSBjMTYgPj4+IDE2XG5cdFx0YzE2ICY9IDB4RkZGRlxuXHRcdGMxNiArPSBhMTYgKiBiMDBcblxuXHRcdGMzMiArPSBjMTYgPj4+IDE2XG5cdFx0YzMyICs9IGEwMCAqIGIzMlxuXHRcdHZhciBjNDggPSBjMzIgPj4+IDE2XG5cdFx0YzMyICY9IDB4RkZGRlxuXHRcdGMzMiArPSBhMTYgKiBiMTZcblx0XHRjNDggKz0gYzMyID4+PiAxNlxuXHRcdGMzMiAmPSAweEZGRkZcblx0XHRjMzIgKz0gYTMyICogYjAwXG5cblx0XHRjNDggKz0gYzMyID4+PiAxNlxuXHRcdGM0OCArPSBhMDAgKiBiNDhcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGExNiAqIGIzMlxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTMyICogYjE2XG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhNDggKiBiMDBcblxuXHRcdHRoaXMuX2EwMCA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IGMxNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IGMzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IGM0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZpZGUgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdC5cblx0ICogVGhlIHJlbWFpbmRlciBpcyBtYWRlIGF2YWlsYWJsZSBhcyB0aGUgX3JlbWFpbmRlcl8gcHJvcGVydHkgb25cblx0ICogdGhlIF9VSU5UNjRfIG9iamVjdC4gSXQgY2FuIGJlIG51bGwsIG1lYW5pbmcgdGhlcmUgYXJlIG5vIHJlbWFpbmRlci5cblx0ICogQG1ldGhvZCBkaXZcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICggKG90aGVyLl9hMTYgPT0gMCkgJiYgKG90aGVyLl9hMzIgPT0gMCkgJiYgKG90aGVyLl9hNDggPT0gMCkgKSB7XG5cdFx0XHRpZiAob3RoZXIuX2EwMCA9PSAwKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG5cblx0XHRcdC8vIG90aGVyID09IDE6IHRoaXNcblx0XHRcdGlmIChvdGhlci5fYTAwID09IDEpIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIgPSBuZXcgVUlOVDY0KDApXG5cdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgPiB0aGlzOiAwXG5cdFx0aWYgKCBvdGhlci5ndCh0aGlzKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQ2NCgwKVxuXHRcdFx0dGhpcy5fYTAwID0gMVxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBTaGlmdCB0aGUgZGl2aXNvciBsZWZ0IHVudGlsIGl0IGlzIGhpZ2hlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdHZhciBfb3RoZXIgPSBvdGhlci5jbG9uZSgpXG5cdFx0dmFyIGkgPSAtMVxuXHRcdHdoaWxlICggIXRoaXMubHQoX290aGVyKSApIHtcblx0XHRcdC8vIEhpZ2ggYml0IGNhbiBvdmVyZmxvdyB0aGUgZGVmYXVsdCAxNmJpdHNcblx0XHRcdC8vIEl0cyBvayBzaW5jZSB3ZSByaWdodCBzaGlmdCBhZnRlciB0aGlzIGxvb3Bcblx0XHRcdC8vIFRoZSBvdmVyZmxvd24gYml0IG11c3QgYmUga2VwdCB0aG91Z2hcblx0XHRcdF9vdGhlci5zaGlmdExlZnQoMSwgdHJ1ZSlcblx0XHRcdGkrK1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgcmVtYWluZGVyXG5cdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHQvLyBJbml0aWFsaXplIHRoZSBjdXJyZW50IHJlc3VsdCB0byAwXG5cdFx0dGhpcy5fYTAwID0gMFxuXHRcdHRoaXMuX2ExNiA9IDBcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gNDgpIHtcblx0XHRcdFx0XHR0aGlzLl9hNDggfD0gMSA8PCAoaSAtIDQ4KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPj0gMzIpIHtcblx0XHRcdFx0XHR0aGlzLl9hMzIgfD0gMSA8PCAoaSAtIDMyKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9hMTYgfD0gMSA8PCAoaSAtIDE2KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2EwMCB8PSAxIDw8IGlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogTmVnYXRlIHRoZSBjdXJyZW50IF9VSU5UNjRfXG5cdCAqIEBtZXRob2QgbmVnYXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ID0gKCB+dGhpcy5fYTAwICYgMHhGRkZGICkgKyAxXG5cdFx0dGhpcy5fYTAwID0gdiAmIDB4RkZGRlxuXHRcdHYgPSAofnRoaXMuX2ExNiAmIDB4RkZGRikgKyAodiA+Pj4gMTYpXG5cdFx0dGhpcy5fYTE2ID0gdiAmIDB4RkZGRlxuXHRcdHYgPSAofnRoaXMuX2EzMiAmIDB4RkZGRikgKyAodiA+Pj4gMTYpXG5cdFx0dGhpcy5fYTMyID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9ICh+dGhpcy5fYTQ4ICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblxuXHQgKiBAbWV0aG9kIGVxXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuZXF1YWxzID0gVUlOVDY0LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiAodGhpcy5fYTQ4ID09IG90aGVyLl9hNDgpICYmICh0aGlzLl9hMDAgPT0gb3RoZXIuX2EwMClcblx0XHRcdCAmJiAodGhpcy5fYTMyID09IG90aGVyLl9hMzIpICYmICh0aGlzLl9hMTYgPT0gb3RoZXIuX2ExNilcblx0fVxuXG5cdC8qKlxuXHQgKiBHcmVhdGVyIHRoYW4gKHN0cmljdClcblx0ICogQG1ldGhvZCBndFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gVUlOVDY0LnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICh0aGlzLl9hNDggPiBvdGhlci5fYTQ4KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hNDggPCBvdGhlci5fYTQ4KSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTMyID4gb3RoZXIuX2EzMikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTMyIDwgb3RoZXIuX2EzMikgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2ExNiA+IG90aGVyLl9hMTYpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2ExNiA8IG90aGVyLl9hMTYpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9hMDAgPiBvdGhlci5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQ2NC5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5fYTQ4IDwgb3RoZXIuX2E0OCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTQ4ID4gb3RoZXIuX2E0OCkgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2EzMiA8IG90aGVyLl9hMzIpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2EzMiA+IG90aGVyLl9hMzIpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMTYgPCBvdGhlci5fYTE2KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMTYgPiBvdGhlci5fYTE2KSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYTAwIDwgb3RoZXIuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgT1Jcblx0ICogQG1ldGhvZCBvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgfD0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiB8PSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyIHw9IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggfD0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwICY9IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgJj0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiAmPSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4ICY9IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBYT1Jcblx0ICogQG1ldGhvZCB4b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCBePSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2IF49IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgXj0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCBePSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYTAwID0gfnRoaXMuX2EwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IH50aGlzLl9hMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSB+dGhpcy5fYTMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gfnRoaXMuX2E0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IHJpZ2h0XG5cdCAqIEBtZXRob2Qgc2hpZnRSaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gVUlOVDY0LnByb3RvdHlwZS5zaGlmdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA+PSA0OCkge1xuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTQ4ID4+IChuIC0gNDgpXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIGlmIChuID49IDMyKSB7XG5cdFx0XHRuIC09IDMyXG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAxNikge1xuXHRcdFx0biAtPSAxNlxuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTE2ID4+IG4pIHwgKHRoaXMuX2EzMiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMzIgPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2EwMCA+PiBuKSB8ICh0aGlzLl9hMTYgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMTYgPj4gbikgfCAodGhpcy5fYTMyIDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgbGVmdFxuXHQgKiBAbWV0aG9kIHNoaWZ0TGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyBvdmVyZmxvd1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRsID0gZnVuY3Rpb24gKG4sIGFsbG93T3ZlcmZsb3cpIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPj0gNDgpIHtcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2EwMCA8PCAobiAtIDQ4KVxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAzMikge1xuXHRcdFx0biAtPSAzMlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAxNikge1xuXHRcdFx0biAtPSAxNlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2EzMiA8PCBuKSB8ICh0aGlzLl9hMTYgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTE2IDw8IG4pIHwgKHRoaXMuX2EwMCA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2E0OCA8PCBuKSB8ICh0aGlzLl9hMzIgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTMyIDw8IG4pIHwgKHRoaXMuX2ExNiA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMDAgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0fVxuXHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0dGhpcy5fYTQ4ICY9IDB4RkZGRlxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UNjQucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA9PSAwKSByZXR1cm4gdGhpc1xuXHRcdGlmIChuID49IDMyKSB7XG5cdFx0XHQvLyBBLkIuQy5EXG5cdFx0XHQvLyBCLkMuRC5BIHJvdGwoMTYpXG5cdFx0XHQvLyBDLkQuQS5CIHJvdGwoMzIpXG5cdFx0XHR2YXIgdiA9IHRoaXMuX2EwMFxuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTMyXG5cdFx0XHR0aGlzLl9hMzIgPSB2XG5cdFx0XHR2ID0gdGhpcy5fYTQ4XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMTZcblx0XHRcdHRoaXMuX2ExNiA9IHZcblx0XHRcdGlmIChuID09IDMyKSByZXR1cm4gdGhpc1xuXHRcdFx0biAtPSAzMlxuXHRcdH1cblxuXHRcdHZhciBoaWdoID0gKHRoaXMuX2E0OCA8PCAxNikgfCB0aGlzLl9hMzJcblx0XHR2YXIgbG93ID0gKHRoaXMuX2ExNiA8PCAxNikgfCB0aGlzLl9hMDBcblxuXHRcdHZhciBfaGlnaCA9IChoaWdoIDw8IG4pIHwgKGxvdyA+Pj4gKDMyIC0gbikpXG5cdFx0dmFyIF9sb3cgPSAobG93IDw8IG4pIHwgKGhpZ2ggPj4+ICgzMiAtIG4pKVxuXG5cdFx0dGhpcy5fYTAwID0gX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IF9sb3cgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gX2hpZ2ggJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBfaGlnaCA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQ2NC5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID09IDApIHJldHVybiB0aGlzXG5cdFx0aWYgKG4gPj0gMzIpIHtcblx0XHRcdC8vIEEuQi5DLkRcblx0XHRcdC8vIEQuQS5CLkMgcm90cigxNilcblx0XHRcdC8vIEMuRC5BLkIgcm90cigzMilcblx0XHRcdHZhciB2ID0gdGhpcy5fYTAwXG5cdFx0XHR0aGlzLl9hMDAgPSB0aGlzLl9hMzJcblx0XHRcdHRoaXMuX2EzMiA9IHZcblx0XHRcdHYgPSB0aGlzLl9hNDhcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2ExNlxuXHRcdFx0dGhpcy5fYTE2ID0gdlxuXHRcdFx0aWYgKG4gPT0gMzIpIHJldHVybiB0aGlzXG5cdFx0XHRuIC09IDMyXG5cdFx0fVxuXG5cdFx0dmFyIGhpZ2ggPSAodGhpcy5fYTQ4IDw8IDE2KSB8IHRoaXMuX2EzMlxuXHRcdHZhciBsb3cgPSAodGhpcy5fYTE2IDw8IDE2KSB8IHRoaXMuX2EwMFxuXG5cdFx0dmFyIF9oaWdoID0gKGhpZ2ggPj4+IG4pIHwgKGxvdyA8PCAoMzIgLSBuKSlcblx0XHR2YXIgX2xvdyA9IChsb3cgPj4+IG4pIHwgKGhpZ2ggPDwgKDMyIC0gbikpXG5cblx0XHR0aGlzLl9hMDAgPSBfbG93ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gX2xvdyA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSBfaGlnaCAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IF9oaWdoID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDY0X1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQ2NCh0aGlzLl9hMDAsIHRoaXMuX2ExNiwgdGhpcy5fYTMyLCB0aGlzLl9hNDgpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDY0XG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDY0XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQ2NCddID0gVUlOVDY0XG5cdH1cblxufSkodGhpcylcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2N1aW50L2xpYi91aW50NjQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDljYHlrZfpk77ooahcclxuICpcclxuICog5b2T55+p6Zi155qE6Z2e6Zu25Liq5pWw5ZKM5L2N572u5Zyo5pON5L2c6L+H56iL5Lit5Y+Y5YyW5aSn5pe277yM5bCx5LiN5a6c6YeH55So6aG65bqP5a2Y5YKo57uT5p6E5p2l6KGo56S65LiJ5YWD57uE55qE57q/5oCn6KGo44CC5L6L5aaC77yM5Zyo5L2c4oCc5bCG55+p6Zi1QuWKoOWIsOefqemYtUHkuIrigJ3nmoTmk43kvZzml7bvvIznlLHkuo7pnZ7pm7blhYPnmoTmj5LlhaXmiJbliKDpmaTlsIbkvJrlvJXotbdBLmRhdGHkuK3lhYPntKDnmoTnp7vliqjjgILkuLrmraTvvIzlr7nov5nnp43nsbvlnovnmoTnn6npmLXvvIzph4fnlKjpk77lvI/lrZjlgqjnu5PmnoTooajnpLrkuInlhYPnu4TnmoTnur/mgKfooajmm7TkuLrmgbDlvZPjgIJcclxuICpcclxuICog5Zyo6ZO+6KGo5Lit77yM5q+P5Liq6Z2e6Zu25YWD5Y+v55So5LiA5Liq5ZCrNeS4quWfn+eahOe7k+eCueihqOekuu+8jOWFtuS4rWnvvIxq5ZKMZei/mTPkuKrln5/liIbliKvooajnpLror6XpnZ7pm7blhYPmiYDlnKjnmoTooYzvvIzliJflkozpnZ7pm7blhYPnmoTlgLzvvIzlkJHlj7Pln59yaWdodOeUqOS7pemTvuaOpeWQjOS4gOihjOS4reS4i+S4gOS4qumdnumbtuWFg++8jOWQkeS4i+Wfn2Rvd27nlKjku6Xpk77mjqXlkIzkuIDliJfkuK3kuIvkuIDkuKrpnZ7pm7blhYPjgILlkIzkuIDooYznmoTpnZ7pm7blhYPpgJrov4dyaWdodOWfn+mTvuaOpeaIkOS4gOS4que6v+aAp+ihqO+8jOWQjOS4gOWIl+S4reeahOmdnumbtuWFg+mAmuW4uGRvd27ln5/pk77mjqXmiJDkuIDkuKrnur/mgKfpk77ooajvvIzmr4/kuIDkuKrpnZ7pm7blhYPml6LmmK/mn5DkuKrooYzpk77ooajkuK3nmoTkuIDkuKrnu5PngrnvvIzlj4jmmK/mn5DkuKrliJfpk77ooajkuK3nmoTkuIDkuKrnu5PngrnvvIzmlbTkuKrnn6npmLXmnoTmiJDkuobkuIDkuKrljYHlrZfkuqTlj4nnmoTpk77ooajjgIJcclxuICpcclxuICog5Y+v55So5Lik5Liq5YiG5Yir5a2Y5YKo6KGM6ZO+6KGo55qE5aS05oyH6ZKI5ZKM5YiX6ZO+6KGo55qE5aS05oyH6ZKI55qE5LiA57u05pWw57uE5p2l6KGo56S644CCXHJcbiAqL1xyXG5cclxuLy8g56iA55aP55+p6Zi155qE5Y2B5a2X6ZO+6KGo5a2Y5YKo6KGo56S6XHJcbmNsYXNzIE9MTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpID0gMCwgaiA9IDAsIGUpIHtcclxuICAgICAgICAvLyDor6XpnZ7pm7blhYPnmoTooYzlkozliJfkuIvmoIdcclxuICAgICAgICB0aGlzLmkgPSBpO1xyXG4gICAgICAgIHRoaXMuaiA9IGo7XHJcbiAgICAgICAgdGhpcy5lID0gZTtcclxuICAgICAgICAvLyDor6XpnZ7pm7blhYPmiYDlnKjooYzooajlkozliJfooajnmoTlkI7nu6fpk77ln59cclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDsgIC8vIHR5cGU6IE9MTm9kZVxyXG4gICAgICAgIHRoaXMuZG93biA9IG51bGw7ICAgLy8gdHlwZTogT0xOb2RlXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyb3NzTGlzdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyDooYzlkozliJfpk77ooajlpLTmjIfpkojlkJHph4/ln7rlnYDnlLFDcmVhdGVTTWF0cml45YiG6YWNXHJcbiAgICAgICAgdGhpcy5yaGVhZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hlYWQgPSBbXTtcclxuICAgICAgICAvLyDnqIDnlo/nn6npmLXnmoTooYzmlbDvvIzliJfmlbBcclxuICAgICAgICB0aGlzLm11ID0gMDtcclxuICAgICAgICB0aGlzLm51ID0gMDtcclxuICAgICAgICB0aGlzLnR1ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOefqemYteWIneWni+WMllxyXG4gICAgICogQHBhcmFtIG1cclxuICAgICAqIEBwYXJhbSBuXHJcbiAgICAgKiBAcGFyYW0gdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCDkuoznu7TmlbDnu4TvvIzmr4/ooYznmoTlhYPntKDliIbliKvmmK9baSwgaiwgZV1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlU01hdHJpeChtLCBuLCB0LCBsaXN0KSB7XHJcbiAgICAgICAgdGhpcy5tdSA9IG07XHJcbiAgICAgICAgdGhpcy5udSA9IG47XHJcbiAgICAgICAgdGhpcy50dSA9IHQ7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGxpc3QubGVuZ3RoOyByb3crKykge1xyXG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBPTE5vZGUoLi4ubGlzdFtyb3ddKTtcclxuICAgICAgICAgICAgbGV0IFtpLCBqXSA9IGxpc3Rbcm93XTtcclxuICAgICAgICAgICAgbGV0IHE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaGVhZFtpXSA9PSBudWxsIHx8IHRoaXMucmhlYWRbaV0uaiA+IGopIHtcclxuICAgICAgICAgICAgICAgIHAucmlnaHQgPSB0aGlzLnJoZWFkW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaGVhZFtpXSA9IHA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmn6Xor6LlnKjooYzooajkuK3nmoTmj5LlhaXkvY3nva5cclxuICAgICAgICAgICAgICAgIGZvciAocSA9IHRoaXMucmhlYWRbaV07IHEucmlnaHQgJiYgcS5yaWdodC5qIDwgajsgcSA9IHEucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcC5yaWdodCA9IHEucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBxLnJpZ2h0ID0gcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlYWRbal0gPT0gbnVsbCB8fCB0aGlzLmNoZWFkW2pdLmkgPiBpKSB7XHJcbiAgICAgICAgICAgICAgICBwLmRvd24gPSB0aGlzLmNoZWFkW2pdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVhZFtqXSA9IHA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHEgPSB0aGlzLmNoZWFkW2pdOyBxLmRvd24gJiYgcS5kb3duLmkgPCBpOyBxID0gcS5kb3duKTtcclxuICAgICAgICAgICAgICAgIHAuZG93biA9IHEuZG93bjtcclxuICAgICAgICAgICAgICAgIHEuZG93biA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g55+p6Zi155u45YqgXHJcbiAgICBhZGRNYXRyaXgoY3Jvc3NMaXN0KSB7XHJcbiAgICAgICAgbGV0IGhsID0gW107XHJcbiAgICAgICAgLy9obOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IHRoaXMubnU7IGorKylcclxuICAgICAgICAgICAgaGxbal0gPSB0aGlzLmNoZWFkW2pdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLm11OyBpKyspIHtcclxuICAgICAgICAgICAgLy9wYeWSjHBi5oyH5ZCR5q+P5LiA6KGM55qE56ys5LiA5Liq6Z2eMOWFg+e7k+eCue+8jOebtOiHs+acgOWQjuS4gOihjFxyXG4gICAgICAgICAgICBsZXQgcGEgPSB0aGlzLnJoZWFkW2ldO1xyXG4gICAgICAgICAgICBsZXQgcGIgPSBjcm9zc0xpc3QucmhlYWRbaV07XHJcbiAgICAgICAgICAgIGxldCBwcmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy/lpITnkIZC55qE5LiA6KGM77yM55u06Iez5pys6KGM5Lit5peg6Z2eMOWFg+e0oOeahOe7k+eCuVxyXG4gICAgICAgICAgICB3aGlsZSAocGIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwLCBxO1xyXG4gICAgICAgICAgICAgICAgLy8g5paw5o+S5YWl5LiA5Liq57uT54K55YiwcGHnmoTlt6bkvqdcclxuICAgICAgICAgICAgICAgIGlmICghcGEgfHwgcGEuaiA+IHBiLmopIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gbmV3IE9MTm9kZShwYi5pLCBwYi5qLCBwYi5lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy/ooYzooajnmoTmjIfpkojlj5jljJZcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZSkgdGhpcy5yaGVhZFtwLmldID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHByZS5yaWdodCA9IHA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHAucmlnaHQgPSBwYTtcclxuICAgICAgICAgICAgICAgICAgICBwcmUgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL+WIl+ihqOeahOaMh+mSiOWPmOWMllxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChobFtwLmpdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS7jmhsW3Aual3lvIDlp4vmib7liLDmlrDnu5PngrnlnKjlkIzkuIDliJfkuK3nmoTliY3pqbHnu5PngrnvvIzlubborqlobFtwLmpd5oyH5ZCR5a6DXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGhsW3Aual07IHEgJiYgcS5pIDwgcC5pO3EgPSBxLmRvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobFtwLmpdID0gcTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8v5Zyo5YiX6KGo5Lit5o+S5YWl5paw57uT54K577yM5qC55o2u6KGM5pWw5Yik5pat5o+S5YWl5YmN6Z2i6L+Y5piv5ZCO6Z2iXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWFkW3Aual0gfHwgdGhpcy5jaGVhZFtwLmpdLmkgPiBwLmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC5kb3duID0gdGhpcy5jaGVhZFtwLmpdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWFkW3Aual0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuZG93biA9IGhsW3Aual0uZG93bjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGxbcC5qXS5kb3duID0gcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGhsW3Aual0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBiID0gcGIucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhLmogPCBwYi5qKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGEgPSBwYS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lvZNwYS5qID09PSBwYi5q5pe277yM5bCGQuS4reW9k+WJjee7k+eCueeahOWAvOWKoOWIsEHkuK3lvZPliY3nu5PngrnkuIpcclxuICAgICAgICAgICAgICAgICAgICBwYS5lICs9IHBiLmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8v5b2TcGEuZSA9PT0gMOaXtu+8jOWIoOmZpOivpee7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYS5lID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiLpeaXoOWJjempsee7k+eCue+8jOWwhuesrOS4gOS4qumdnjDlhYPnu5Pngrnnva7kuLrlvZPliY3nu5PngrnnmoTlkI7nu6fnu5PngrnvvIxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5YmN6amx57uT54K555qE5ZCO57un57uT54K55Li65b2T5YmN57uT54K555qE5ZCO57un57uT54K5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlKSB0aGlzLnJoZWFkW3BhLmldID0gcGEucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcHJlLnJpZ2h0ID0gcGEucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhID0gcGEucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WIl+ihqOeahOaMh+mSiOWPmOWMllxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGxbcC5qXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/ku45obFtwLmpd5byA5aeL5om+5Yiw5paw57uT54K55Zyo5ZCM5LiA5YiX5Lit55qE5YmN6amx57uT54K577yM5bm26K6paGxbcC5qXeaMh+WQkeWug1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gaGxbcC5qXTsgcSAmJiBxLmkgPCBwLmk7IHEgPSBxLmRvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxbcC5qXSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWFkW3Aual0gPT0gcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlYWRbcC5qXSA9IGhsW3Aual0gPSBwLmRvd247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsW3Aual0uZG93biA9IHAuZG93bjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBiID0gcGIucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxubGV0IGxpc3RzID0gW1xyXG4gICAgWzEsIDQsIDVdLFxyXG4gICAgWzIsIDIsIC0xXSxcclxuICAgIFsxLCAxLCAzXSxcclxuICAgIFszLCAxLCAyXVxyXG5dO1xyXG5sZXQgYSA9IG5ldyBDcm9zc0xpc3QoKTtcclxuYS5jcmVhdGVTTWF0cml4KDQsIDQsIDQsIGxpc3RzKTtcclxuY29uc29sZS5sb2coYSk7XHJcblxyXG5sZXQgbGlzdHMyID0gW1xyXG4gICAgWzEsIDQsIC01XSxcclxuICAgIFsyLCAzLCAxXSxcclxuICAgIFsxLCAxLCAzXSxcclxuICAgIFszLCAyLCAyXVxyXG5dO1xyXG5sZXQgYiA9IG5ldyBDcm9zc0xpc3QoKTtcclxuYi5jcmVhdGVTTWF0cml4KDQsIDQsIDQsIGxpc3RzMik7XHJcbmNvbnNvbGUubG9nKGIpO1xyXG5cclxuYS5hZGRNYXRyaXgoYik7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9BcnJheS9Dcm9zc0xpc3QuanNcbiAqKi8iLCIvKipcclxuICog57O75pWw55+p6Zi155qE5LiJ5YWD57uE6aG65bqP6KGo5a2Y5YKo6KGo56S6XHJcbiAqL1xyXG5cclxuY2xhc3MgVHJpcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGksIGosIGVsZW0pIHtcclxuICAgICAgICAvLyDor6XpnZ7pm7blhYPnmoTooYzkuIvmoIflkozliJfkuIvmoIdcclxuICAgICAgICB0aGlzLmkgPSBpIHx8IDA7XHJcbiAgICAgICAgdGhpcy5qID0gaiB8fCAwO1xyXG4gICAgICAgIHRoaXMuZSA9IGVsZW0gfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRTTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKG11LCBudSkge1xyXG4gICAgICAgIC8vIOmdnumbtuWFg+S4ieWFg+e7hOihqFxyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgIC8vIOefqemYteeahOihjOaVsO+8jOWIl+aVsFxyXG4gICAgICAgIHRoaXMubXUgPSBtdSB8fCAwO1xyXG4gICAgICAgIHRoaXMubnUgPSBudSB8fCAwO1xyXG4gICAgfVxyXG4gICAgYWRkVHJpcGxlICh0cmlwbGUpIHtcclxuICAgICAgICBpZiAodHJpcGxlIGluc3RhbmNlb2YgVHJpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmKHRyaXBsZS5pID49IHRoaXMubXUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm11ID0gdHJpcGxlLmkgKyAxO1xyXG4gICAgICAgICAgICBpZih0cmlwbGUuaiA+PSB0aGlzLm51KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5udSA9IHRyaXBsZS5qICsgMTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHRyaXBsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyDph4fnlKjkuInlhYPnu4TooajlrZjlgqjooajnpLrvvIzmsYLnqIDnlo/nn6npmLXnmoTovaznva7nn6npmLV0XHJcbiAgICAvLyDmjInnhadiLmRhdGHkuK3kuInlhYPnu4TnmoTmrKHluo/kvp3mrKHlnKhhLmRhdGHkuK3mib7liLDnm7jlupTnmoTkuInlhYPnu4Tov5vooYzovaznva5cclxuICAgIHRyYW5zcG9zZVNNYXRyaXggKCkge1xyXG4gICAgICAgIGxldCB0ID0gbmV3IFRTTWF0cml4KCk7XHJcbiAgICAgICAgdC5tdSA9IHRoaXMubnU7XHJcbiAgICAgICAgdC5udSA9IHRoaXMubXU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBxID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udTsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgdGhpcy5kYXRhLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtwXS5qID09PSBjb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZGF0YVtxKytdID0gbmV3IFRyaXBsZSh0aGlzLmRhdGFbcF0uaiwgdGhpcy5kYXRhW3BdLmksIHRoaXMuZGF0YVtwXS5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICAvLyDph4fnlKjkuInlhYPnu4TooajlrZjlgqjooajnpLrvvIzmsYLnqIDnlo/nn6npmLXnmoTovaznva7nn6npmLV0XHJcbiAgICAvKlxyXG4gICAgIOaMieeFp2EuZGF0YeS4reS4ieWFg+e7hOeahOasoeW6j+i/m+ihjOi9rOe9ru+8jOW5tuWwhui9rOe9ruWQjueahOS4ieWFg+e7hOe9ruWFpWLkuK3mgbDlvZPnmoTkvY3nva7jgIJcclxuICAgICDlpoLmnpzog73pooTlhYjnoa7lrprnn6npmLVN5Lit5q+P5LiA5YiX77yI5Y2zVOS4reavj+S4gOihjO+8ieeahOesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reW6lOacieeahOS9jee9ru+8jFxyXG4gICAgIOmCo+S5iOWcqOWvuWEuZGF0YeS4reeahOS4ieWFg+e7hOS+neasoeWBmui9rOe9ruaXtu+8jOS+v+WPr+ebtOaOpeaUvuWIsGIuZGF0YeS4reaBsOW9k+eahOS9jee9ruS4iuWOu+OAglxyXG4gICAgIOS4uuS6huWFtumineWumui/meS6m+S9jee9ru+8jOWcqOi9rOe9ruWJje+8jOW6lOWFiOaxguW+l03nmoTmr4/kuIDliJfkuK3pnZ7pm7blhYPnmoTkuKrmlbDvvIzov5vogIzmsYLlvpfmr4/kuIDliJfnmoTnrKzkuIDkuKrpnZ7pm7blhYPlnKhiLmRhdGHkuK3lupTmnInnmoTkvY3nva7jgIJcclxuICAgICDlnKjmraTvvIzpnIDopoHorr5udW3lkoxjcG905Lik5Liq5Y+Y6YeP44CCbnVtW2NvbF3ooajnpLrnn6npmLVN5Lit56ysY29s5YiX5Lit6Z2e6Zu25YWD55qE5Liq5pWw77yMXHJcbiAgICAgY3BvdFtjb2xd5oyH56S6TeS4reesrGNvbOWIl+eahOesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reeahOaBsOW9k+S9jee9ruOAguaYvueEtuacie+8mlxyXG4gICAgIGNwb3RbMF0gPSAxO1xyXG4gICAgIGNwb3RbY29sXSA9IGNwb3RbY29sIC0gMV0gKyBudW1bY29sIC0gMV0gICAgMiA8PSBjb2wgPD0gYS5udVxyXG4gICAgICovXHJcbiAgICBmYXN0VHJhbnNwb3NlU01hdHJpeCgpe1xyXG4gICAgICAgIGxldCB0ID0gbmV3IFRTTWF0cml4KCk7XHJcbiAgICAgICAgdC5tdSA9IHRoaXMubnU7XHJcbiAgICAgICAgdC5udSA9IHRoaXMubXU7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZXQgbnVtID0gW107XHJcbiAgICAgICAgICAgIGZvcihsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udTsgY29sKyspXHJcbiAgICAgICAgICAgICAgICBudW1bY29sXSA9IDA7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICArK251bVt0aGlzLmRhdGFbaV0ual07ICAvLyDmsYLnn6npmLXkuK3mr4/kuIDliJflkKvpnZ7pm7blhYPkuKrmlbBcclxuICAgICAgICAgICAgLy8g5rGC56ysY29s5YiX5Lit56ys5LiA5Liq6Z2e6Zu25YWD5ZyoYi5kYXRh5Lit55qE5bqP5Y+3XHJcbiAgICAgICAgICAgIGxldCBjcG90ID0gWzBdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGNvbCA9IDE7IGNvbCA8IHRoaXMubnU7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgLy8g5LiK5LiA5YiX5LmL5YmN55qE5bqP5Y+3K+S4iuS4gOWIl+eahOmdnumbtuWFg+S4quaVsCA9IOivpeWIl+eahOW6j+WPt1xyXG4gICAgICAgICAgICAgICAgY3BvdFtjb2xdID0gY3BvdFtjb2wgLSAxXSArIG51bVtjb2wgLSAxXTtcclxuICAgICAgICAgICAgZm9yKGxldCBwID0gMDsgcCA8IHRoaXMuZGF0YS5sZW5ndGg7IHArKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29sID0gdGhpcy5kYXRhW3BdLmo7XHJcbiAgICAgICAgICAgICAgICBsZXQgcSA9IGNwb3RbY29sXTtcclxuICAgICAgICAgICAgICAgIHQuZGF0YVtxXSA9IG5ldyBUcmlwbGUodGhpcy5kYXRhW3BdLmosIHRoaXMuZGF0YVtwXS5pLCB0aGlzLmRhdGFbcF0uZSk7XHJcbiAgICAgICAgICAgICAgICAvLyDnu5nor6XliJfnmoTluo/lj7crMe+8jOeUqOS9nOebuOWQjOWIl+aVsOeahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgKytjcG90W2NvbF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgYTEgPSBuZXcgVHJpcGxlKDEsIDIsIDEyKTtcclxubGV0IGEyID0gbmV3IFRyaXBsZSgxLCAzLCA5KTtcclxubGV0IGEzID0gbmV3IFRyaXBsZSgzLCAxLCAtMyk7XHJcbmxldCBhNCA9IG5ldyBUcmlwbGUoMywgNiwgMTQpO1xyXG5sZXQgYTUgPSBuZXcgVHJpcGxlKDQsIDMsIDI0KTtcclxubGV0IGE2ID0gbmV3IFRyaXBsZSg1LCAyLCAxOCk7XHJcbmxldCBhNyA9IG5ldyBUcmlwbGUoNiwgMSwgMTUpO1xyXG5sZXQgYTggPSBuZXcgVHJpcGxlKDYsIDQsIC03KTtcclxuXHJcbmxldCBtYXRyaXggPSBuZXcgVFNNYXRyaXgoKTtcclxubWF0cml4LmFkZFRyaXBsZShhMSk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTIpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGEzKTtcclxubWF0cml4LmFkZFRyaXBsZShhNCk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTUpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGE2KTtcclxubWF0cml4LmFkZFRyaXBsZShhNyk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTgpO1xyXG5cclxuY29uc29sZS5sb2cobWF0cml4LnRyYW5zcG9zZVNNYXRyaXgoKSk7XHJcbmNvbnNvbGUubG9nKG1hdHJpeC5mYXN0VHJhbnNwb3NlU01hdHJpeCgpKTtcclxuXHJcbi8qXHJcbiDkuInlhYPnu4Tpobrluo/ooajlj4jnp7DmnInluo/nmoTlj4zkuIvmoIfms5XvvIzlroPnmoTnibnngrnmmK/vvIzpnZ7pm7blhYPlnKjooajkuK3mjInooYzluo/mnInluo/lrZjlgqjvvIzlm6DmraTkvr/kuo7ov5vooYzkvp3ooYzpobrluo/lpITnkIbnmoTnn6npmLXov5DnrpfjgIJcclxuIOeEtuiAjO+8jOiLpemcgOaMieihjOWPt+WtmOWPluafkOS4gOihjOeahOmdnumbtuWFg++8jOWImeS7juWktOW8gOWni+i/m+ihjOafpeaJvuOAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDooYzpgLvovpHpk77mjqXnmoTpobrluo/ooahcclxuICpcclxuICog5Li65LqG5L6/5LqO6ZqP5py65a2Y5Y+W5Lu75oSP5LiA6KGM55qE6Z2e6Zu25YWD77yM5YiZ6ZyA55+l6YGT5q+P5LiA6KGM55qE56ys5LiA5Liq6Z2e6Zu25YWD5Zyo5LiJ5YWD57uE6KGo5Lit55qE5L2N572u44CCXHJcbiAqIOS4uuatpOWPr+WwhuW/q+mAn+i9rOe9ruefqemYteeahOeul+azleS4reWIm+W7uueahO+8jOaMh+ekuuKAnOihjOKAneS/oeaBr+eahOi+heWKqeaVsOe7hGNwb3Tlm7rlrprlnKjnqIDnlo/nn6npmLXnmoTlrZjlgqjnu5PmnoTkuK3jgIJcclxuICog56ew6L+Z56eN4oCc5bim6KGM6ZO+5o6l5L+h5oGv4oCd55qE5LiJ5YWD57uE6KGo5Li66KGM6YC76L6R6ZO+5o6l55qE6aG65bqP6KGoXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUkxTTWF0cml4IGV4dGVuZHMgVFNNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMucnBvcyA9IFswXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5rGC55+p6Zi15LmY56evUSA9IE0gKiBO77yM6YeH55So6KGM6YC76L6R6ZO+5o6l5a2Y5YKo6KGo56S6XHJcbiAgICAgKiBAcGFyYW0gbk1hdHJpeFxyXG4gICAgICogQHJldHVybnMge1JMU01hdHJpeH1cclxuICAgICAqL1xyXG4gICAgbXVsdFNNYXRyaXgobk1hdHJpeCl7XHJcbiAgICAgICAgaWYodGhpcy5udSAhPT0gbk1hdHJpeC5tdSkgdGhyb3cgRXJyb3IoJ251IGlzIG5vdCBlcXVpdmFsZW50IHRvIG11Jyk7XHJcblxyXG4gICAgICAgIC8vIOWIneWni+WMllFcclxuICAgICAgICBsZXQgcU1hdHJpeCA9IG5ldyBSTFNNYXRyaXgodGhpcy5tdSwgbk1hdHJpeC5udSk7XHJcbiAgICAgICAgLy8gUeaYr+mdnumbtuefqemYtVxyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5sZW5ndGggKiBuTWF0cml4LmRhdGEubGVuZ3RoICE9PSAwKXtcclxuICAgICAgICAgICAgLy8g5aSE55CGTeeahOavj+S4gOihjFxyXG4gICAgICAgICAgICBmb3IobGV0IGFyb3cgPSAwOyBhcm93IDwgdGhpcy5tdTsgYXJvdysrKXtcclxuICAgICAgICAgICAgICAgIC8vIOW9k+WJjeihjOWQhOWFg+e0oOe0r+WKoOWZqOa4hembtlxyXG4gICAgICAgICAgICAgICAgbGV0IGN0ZW1wID0gW107XHJcbiAgICAgICAgICAgICAgICBxTWF0cml4LnJwb3NbYXJvd10gPSBxTWF0cml4LmRhdGEubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgIGxldCB0cCwgY2NvbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihhcm93IDwgdGhpcy5tdSlcclxuICAgICAgICAgICAgICAgICAgICB0cCA9IHRoaXMucnBvc1thcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdHAgPSB0aGlzLmRhdGEubGVuZ3RoICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL+WvueW9k+WJjeihjOS4reavj+S4gOS4qumdnumbtuWFg+aJvuWIsOWvueW6lOWFg+WcqE7kuK3nmoTooYzlj7dcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcCA9IHRoaXMucnBvc1thcm93XTsgcCA8IHRwOyBwKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBicm93ID0gdGhpcy5kYXRhW3BdLmo7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYnJvdyA8IG5NYXRyaXgubXUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuTWF0cml4LnJwb3NbYnJvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG5NYXRyaXguZGF0YS5sZW5ndGggKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHEgPSBuTWF0cml4LnJwb3NbYnJvd107IHEgPCB0OyBxKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDkuZjnp6/lhYPntKDlnKhR5Lit55qE5bqP5Y+3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjb2wgPSBuTWF0cml4LmRhdGFbcV0uajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RlbXBbY2NvbF0gPSAoY3RlbXBbY2NvbF0gfHwgMCkgKyB0aGlzLmRhdGFbcF0uZSAqIG5NYXRyaXguZGF0YVtxXS5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDljovnvKnlrZjlgqjor6XooYzpnZ7pm7blhYNcclxuICAgICAgICAgICAgICAgIGZvcihjY29sID0gMTsgY2NvbCA8IHFNYXRyaXgubnU7IGNjb2wrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3RlbXBbY2NvbF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigrK3FNYXRyaXguZGF0YS5sZW5ndGggPiBSTFNNYXRyaXguTUFYU0laRSkgdGhyb3cgRXJyb3IoJ292ZXJmbG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFNYXRyaXguZGF0YVtxTWF0cml4LmRhdGEubGVuZ3RoIC0gMV0gPSBuZXcgVHJpcGxlKGFyb3csIGNjb2wsIGN0ZW1wW2Njb2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxTWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIF9jYWxjUG9zICgpe1xyXG4gICAgICAgIGxldCBudW0gPSBbXTtcclxuICAgICAgICBmb3IobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnU7IGNvbCsrKVxyXG4gICAgICAgICAgICBudW1bY29sXSA9IDA7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgKytudW1bdGhpcy5kYXRhW2ldLmpdOyAgLy8g5rGC55+p6Zi15Lit5q+P5LiA5YiX5ZCr6Z2e6Zu25YWD5Liq5pWwXHJcbiAgICAgICAgLy8g5rGC56ysY29s5YiX5Lit56ys5LiA5Liq6Z2e6Zu25YWD5ZyoYi5kYXRh5Lit55qE5bqP5Y+3XHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSAxOyBjb2wgPCB0aGlzLm51OyBjb2wrKylcclxuICAgICAgICAgICAgLy8g5LiK5LiA5YiX5LmL5YmN55qE5bqP5Y+3K+S4iuS4gOWIl+eahOmdnumbtuWFg+S4quaVsCA9IOivpeWIl+eahOW6j+WPt1xyXG4gICAgICAgICAgICB0aGlzLnJwb3NbY29sXSA9IHRoaXMucnBvc1tjb2wgLSAxXSArIG51bVtjb2wgLSAxXTtcclxuICAgIH1cclxufVxyXG5STFNNYXRyaXguTUFYU0laRSA9IDEwMDtcclxuXHJcblxyXG5sZXQgYjEgPSBuZXcgVHJpcGxlKDEsIDEsIDMpO1xyXG5sZXQgYjIgPSBuZXcgVHJpcGxlKDEsIDMsIDUpO1xyXG5sZXQgYjMgPSBuZXcgVHJpcGxlKDIsIDIsIC0xKTtcclxubGV0IGI0ID0gbmV3IFRyaXBsZSgzLCAxLCAyKTtcclxuXHJcbmxldCB0MSA9IG5ldyBSTFNNYXRyaXgoKTtcclxudDEuYWRkVHJpcGxlKGIxKTtcclxudDEuYWRkVHJpcGxlKGIyKTtcclxudDEuYWRkVHJpcGxlKGIzKTtcclxudDEuYWRkVHJpcGxlKGI0KTtcclxudDEuX2NhbGNQb3MoKTtcclxuXHJcbmxldCBjMSA9IG5ldyBUcmlwbGUoMSwgMiwgMik7XHJcbmxldCBjMiA9IG5ldyBUcmlwbGUoMiwgMSwgMSk7XHJcbmxldCBjMyA9IG5ldyBUcmlwbGUoMywgMSwgLTIpO1xyXG5sZXQgYzQgPSBuZXcgVHJpcGxlKDMsIDIsIDQpO1xyXG5cclxubGV0IHQyID0gbmV3IFJMU01hdHJpeCgpO1xyXG50Mi5hZGRUcmlwbGUoYzEpO1xyXG50Mi5hZGRUcmlwbGUoYzIpO1xyXG50Mi5hZGRUcmlwbGUoYzMpO1xyXG50Mi5hZGRUcmlwbGUoYzQpO1xyXG50Mi5fY2FsY1BvcygpO1xyXG5cclxudDEubXVsdFNNYXRyaXgodDIpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0FycmF5L1RTTWF0cml4LmpzXG4gKiovIiwiLyoqXHJcbiAqIOi1q+Wkq+abvO+8iEh1ZmZtYW7vvInmoJHvvIzlj4jnp7DmnIDkvJjmoJHvvIzmmK/kuIDnsbvluKbmnYPot6/lvoTplb/luqbmnIDnn63nmoTmoJHvvIzmnInnnYDlub/ms5vlupTnlKjjgIJcclxuICpcclxuICog5LuO5qCR5Lit5LiA5Liq57uT54K55Yiw5Y+m5LiA5Liq57uT54K55LmL6Ze055qE5YiG5pSv5p6E5oiQ6L+Z5Lik5Liq57uT54K55LmL6Ze055qE6Lev5b6E77yM6Lev5b6E5LiK55qE5YiG5pSv5pWw55uu56ew5L2c6Lev5b6E6ZW/5bqm44CCXHJcbiAqIOagkeeahOi3r+W+hOmVv+W6puaYr+S7juagkeagueWIsOavj+S4gOS4que7k+eCueeahOi3r+W+hOS5i+WSjOOAglxyXG4gKiDnu5PngrnnmoTluKbmnYPot6/lvoTplb/luqbkuLrku47or6Xnu5PngrnliLDmoJHmoLnkuYvpl7TnmoTot6/lvoTplb/luqbkuI7nu5PngrnkuIrmnYPnmoTkuZjnp6/jgILmoJHnmoTluKbmnYPot6/lvoTplb/luqbkuLrmoJHkuK3miYDmnInlj7blrZDnu5PngrnnmoTluKbmnYPot6/lvoTplb/luqbkuYvlkozjgIJcclxuICpcclxuICog5p6E6YCg6LWr5aSr5pu85qCR55qE5q2l6aqk77yaXHJcbiAqIO+8iDHvvInmoLnmja7nu5nlrprnmoRu5Liq5p2D5YC8e3cxLHcyLC4uLndufeaehOaIkG7mo7Xkuozlj4nmoJHnmoTpm4blkIhGID0ge1QxLFQyLC4uLlRufe+8jOWFtuS4reavj+ajteS6jOWPieagkVRp5Lit5Y+q5pyJ5LiA5Liq5bim5p2D5Li6d2nnmoTmoLnnu5PngrnvvIzlhbblt6blj7PlrZDmoJHlnYfnqbrjgIJcclxuICog77yIMu+8ieWcqEbkuK3pgInlj5bkuKTmo7XmoLnnu5PngrnnmoTmnYPlgLzmnIDlsI/nmoTmoJHkvZzkuLrlt6blj7PlrZDmoJHmnoTpgKDkuIDmo7XmlrDnmoTkuozlj4nmoJHvvIzkuJTnva7mlrDnmoTkuozlj4nmoJHnmoTmoLnnu5PngrnnmoTmnYPlgLzkuLrlhbblt6blj7PlrZDmoJHkuIrmoLnnu5PngrnnmoTmnYPlgLzkuYvlkozjgIJcclxuICog77yIM++8ieWcqEbkuK3liKDpmaTov5nkuKTmo7XmoJHvvIzlkIzml7blsIbmlrDlvpfliLDnmoTkuozlj4nmoJHliqDlhaVG5Lit44CCXHJcbiAqIO+8iDTvvInph43lpI3vvIgy77yJ5ZKM77yIM++8ie+8jOebtOWIsEblj6rlkKvkuIDmo7XmoJHkuLrmraLjgILov5nmo7XmoJHkvr/mmK/otavlpKvmm7zmoJHjgIJcclxuICovXHJcbi8qXHJcbui1q+Wkq+abvOe8lueggVxyXG5odHRwOi8vemgud2lraXBlZGlhLm9yZy93aWtpLyVFOSU5QyU4RCVFNSVBNCVBQiVFNiU5QiVCQyVFNyVCQyU5NiVFNyVBMCU4MVxyXG5cclxu5YGH6K6+55S15oql6ZyA5Lyg6YCB55qE55S15paH5Li64oCcQSBCIEEgQyBDIEQgQeKAne+8jOWug+WPquaciTTnp43lrZfnrKblj6rpnIDkuKTkuKrlrZfnrKbkuLLkvr/lj6/liIbovqjjgILlgYforr5BLEIsQyxE55qE57yW56CB5YiG5Yir5Li6MDAsMDEsMTDlkowxMe+8jOWImeS4iui/sDfkuKrlrZfnrKbnmoTnlLXmlofkvr/kuLrigJwwMDAxMDAxMDEwMTEwMOKAne+8jOWvueaWueaOpeaUtuaXtu+8jOWPr+aMieS6jOS9jeS4gOWIhui/m+ihjOivkeeggeOAglxyXG7lnKjkvKDpgIHnlLXmlofml7bvvIzluIzmnJvmgLvplb/lsL3lj6/og73lnLDnn63jgILlpoLmnpzlr7nmr4/kuKrlrZfnrKborr7orqHplb/luqbkuI3nrYnnmoTnvJbnoIHvvIzkuJTorqnnlLXmlofkuK3lh7rnjrDmrKHmlbDovoPlpJrnmoTlrZfnrKbph4fnlKjlsL3lj6/og73nn63nmoTnvJbnoIHvvIzliJnkvKDpgIHnlLXmlofnmoTmgLvplb/kvr/lj6/lh4/lsJHjgIJcclxu5aaC5p6c5raJ5Y+KQSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAsMDAsMeWSjDAx77yM5YiZ5LiK6L+wN+S4quWtl+espueahOeUteaWh+WPr+i9rOaNouaIkOaAu+mVv+S4ujnnmoTlrZfnrKbkuLLigJwwMDAwMTEwMTDigJ3jgILkvYbmmK/vvIzov5nmoLfnmoTnlLXmlofml6Dms5Xnv7vor5HvvIzlm6DkuLrlj6/mnInlpJrnp43or5Hms5XjgIJcclxu5Zug5q2k77yM6Iul6KaB6K6+6K6h6ZW/55+t5LiN562J55qE57yW56CB77yM5YiZ5b+F6aG75piv5Lu75oSP5Liq5a2X56ym55qE57yW56CB6YO95LiN5piv5Y+m5LiA5Liq5a2X56ym57yW56CB55qE5YmN57yA77yM6L+Z56eN57yW56CB56ew5L2c5YmN57yA57yW56CB44CCXHJcbuWPr+WIqeeUqOS6jOWPieagkeadpeiuvuiuoeS6jOi/m+WItueahOWJjee8gOe8lueggeOAguWBh+iuvuacieS4gOajteS6jOWPieagke+8jOWFtjTkuKrlj7blrZDnu5PngrnliIbliKvooajnpLpBLEIsQyxE6L+ZNOS4quWtl+espu+8jOS4lOe6puWumuW3puWIhuaUr+ihqOekuuWtl+espuKAnDDigJ3vvIzlj7PliIbmlK/ooajnpLrlrZfnrKbigJwx4oCd77yM5YiZ5Y+v5Lul5LuO5qC557uT54K55Yiw5Y+25a2Q57uT54K555qE6Lev5b6E5LiK5YiG5pSv5a2X56ym57uE5oiQ55qE5a2X56ym5Liy5L2c5Li66K+l5Y+25a2Q57uT54K55a2X56ym55qE57yW56CB44CC5omA5b6X5LqM6L+b5Yi25YmN57yA57yW56CB5YiG5Yir5Li6MCwxMCwxMTAsMTExLlxyXG7orr7orqHnlLXmlofmgLvplb/mnIDnn63nmoTkuozov5vliLbliY3nvIDnvJbnoIHljbPku6Vu56eN5a2X56ym5Ye6546w55qE6aKR546H5L2c5p2D44CCXHJcbiAqL1xyXG5cclxuLy8g6LWr5aSr5pu85qCR5ZKM6LWr5aSr5pu857yW56CB55qE5a2Y5YKo57uT5p6EXHJcbmZ1bmN0aW9uIEh1ZmZtYW5Ob2RlKHdlaWdodCwgcGFyZW50LCBsZWZ0Q2hpbGQsIHJpZ2h0Q2hpbGQpIHtcclxuICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0IHx8IDA7XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCAwO1xyXG4gICAgdGhpcy5sZWZ0Q2hpbGQgPSBsZWZ0Q2hpbGQgfHwgMDtcclxuICAgIHRoaXMucmlnaHRDaGlsZCA9IHJpZ2h0Q2hpbGQgfHwgMDtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBodWZmTWFuQ29kaW5nKHdlaWdodHMpIHtcclxuICAgIGxldCBuID0gd2VpZ2h0cy5sZW5ndGg7XHJcbiAgICBpZiAobiA8IDEpIHJldHVybjtcclxuXHJcbiAgICBsZXQgaHVmZm1hblRyZWUgPSBidWlsZEh1ZmZtYW5UcmVlKHdlaWdodHMsIG4pO1xyXG5cclxuICAgIC8vIOS7juWPtuWtkOWIsOaguemAhuWQkeaxguavj+S4quWtl+espueahOi1q+Wkq+abvOe8lueggVxyXG4gICAgbGV0IGhjID0gY2FsY0h1ZmZtYW5Db2RlKGh1ZmZtYW5UcmVlLCBuKTtcclxuXHJcbiAgICByZXR1cm4gW2h1ZmZtYW5UcmVlLCBoY107XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjYWxjSHVmZm1hbkNvZGUoaHVmZm1hblRyZWUsIG4pIHtcclxuICAgIC8vIOS7juWPtuWtkOWIsOaguemAhuWQkeaxguavj+S4quWtl+espueahOi1q+Wkq+abvOe8lueggVxyXG4gICAgbGV0IGhjID0gW107XHJcbiAgICBsZXQgY2QgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gbiAtIDE7XHJcbiAgICAgICAgZm9yIChsZXQgYyA9IGksIGYgPSBodWZmbWFuVHJlZVtpXS5wYXJlbnQ7IGYgIT0gMDsgYyA9IGYsIGYgPSBodWZmbWFuVHJlZVtmXS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGh1ZmZtYW5UcmVlW2ZdLmxlZnRDaGlsZCA9PSBjKSBjZFstLXN0YXJ0XSA9ICcwJztcclxuICAgICAgICAgICAgZWxzZSBjZFstLXN0YXJ0XSA9ICcxJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGhjW2ldID0gc3RyQ29weShjZCwgc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoYztcclxufVxyXG5cclxuLy8g5Yib5bu65LiA5qO15Y+25a2Q57uT54K55pWw5Li6bueahEh1ZmZtYW7moJFcclxuZnVuY3Rpb24gYnVpbGRIdWZmbWFuVHJlZSh3ZWlnaHRzLCBuKSB7XHJcbiAgICBuID0gbiB8fCB3ZWlnaHRzLmxlbmd0aDtcclxuICAgIGxldCBtID0gMiAqIG4gLSAxO1xyXG4gICAgbGV0IGh1ZmZtYW5UcmVlID0gW107XHJcblxyXG4gICAgLy8g5Yid5aeL5YyWXHJcbiAgICBsZXQgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgaHVmZm1hblRyZWVbaV0gPSBuZXcgSHVmZm1hbk5vZGUod2VpZ2h0c1tpXSwgMCwgMCwgMCk7XHJcbiAgICBmb3IgKDsgaSA8IG07IGkrKylcclxuICAgICAgICBodWZmbWFuVHJlZVtpXSA9IG5ldyBIdWZmbWFuTm9kZSgwLCAwLCAwLCAwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gbjsgaSA8IG07IGkrKykge1xyXG4gICAgICAgIC8vIOWcqEhUWzEuLmktMV3pgInmi6lwYXJlbnTkuLow5LiUd2VpZ2h05pyA5bCP55qE5Lik5Liq57uT54K577yM6L+U5Zue5YW25bqP5Y+35Li6W3MxLCBzMl1cclxuICAgICAgICBsZXQgcmV0ID0gc2VsZWN0KGh1ZmZtYW5UcmVlLCBpKTtcclxuICAgICAgICBsZXQgczEgPSByZXRbMF07XHJcbiAgICAgICAgbGV0IHMyID0gcmV0WzFdO1xyXG4gICAgICAgIGh1ZmZtYW5UcmVlW3MxXS5wYXJlbnQgPSBpO1xyXG4gICAgICAgIGh1ZmZtYW5UcmVlW3MyXS5wYXJlbnQgPSBpO1xyXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLmxlZnRDaGlsZCA9IHMxO1xyXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLnJpZ2h0Q2hpbGQgPSBzMjtcclxuICAgICAgICBodWZmbWFuVHJlZVtpXS53ZWlnaHQgPSBodWZmbWFuVHJlZVtzMV0ud2VpZ2h0ICsgaHVmZm1hblRyZWVbczJdLndlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaHVmZm1hblRyZWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0ckNvcHkoc3RyLCBzdGFydCkge1xyXG4gICAgbGV0IHMgPSAnJztcclxuICAgIGZvciAoOyBzdHJbc3RhcnRdOyBzdGFydCsrKSB7XHJcbiAgICAgICAgcyArPSBzdHJbc3RhcnRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdChodWZmbWFuVHJlZSwgbGVuKSB7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBodWZmbWFuVHJlZVtpXTtcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IDApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAocmV0Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goaSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gaHVmZm1hblRyZWVbcmV0WzBdXS53ZWlnaHQgPiBodWZmbWFuVHJlZVtyZXRbMV1dLndlaWdodFxyXG4gICAgICAgICAgICAgICAgPyAwIDogMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlLndlaWdodCA8IGh1ZmZtYW5UcmVlW3JldFtpbmRleF1dLndlaWdodClcclxuICAgICAgICAgICAgICAgIHJldFtpbmRleF0gPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocmV0WzBdID4gcmV0WzFdKSB7XHJcbiAgICAgICAgbGV0IHRlbXAgPSByZXRbMF07XHJcbiAgICAgICAgcmV0WzBdID0gcmV0WzFdO1xyXG4gICAgICAgIHJldFsxXSA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuY29uc29sZS5sb2coJy0tLS0tLS1odWZmbWFuIGNvZGluZyAxOi0tLS0tLScpO1xyXG5jb25zb2xlLmxvZyhodWZmTWFuQ29kaW5nKFs1LCAyOSwgNywgOCwgMTQsIDIzLCAzLCAxMV0pKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcuanNcbiAqKi8iLCIvKipcclxuICog5bm/5LmJ6KGoXHJcbiAqXHJcbiAqIOW5v+S5ieihqOaYr+e6v+aAp+ihqOeahOaOqOW5v+OAguW5v+azm+eUqOS6juS6uuW3peaZuuiDveeahOihqOWkhOeQhuivreiogExpc3DvvIzmiorlub/kuYnooajkvZzkuLrln7rmnKznmoTmlbDmja7nu5PmnoTjgIJcclxuICog5bm/5LmJ6KGo5LiA6Iis6K6w5L2c77yaXHJcbiAqICAgICAgTFMgPSAoYTEsIGEyLCAuLi4sIGFuKVxyXG4gKiBMU+aYr+W5v+S5ieihqOeahOWQjeensO+8jG7mmK/lroPnmoTplb/luqbvvIxhaeWPr+S7peaYr+WNleS4quWFg+e0oO+8jOS5n+WPr+S7peaYr+W5v+S5ieihqO+8jOWIhuWIq+ensOS4uuW5v+S5ieihqExT55qE5Y6f5a2Q5ZKM5a2Q6KGo44CC5Lmg5oOv5LiK77yM55So5aSn5YaZ5a2X5q+N6KGo56S65bm/5LmJ6KGo55qE5ZCN56ew77yM5bCP5YaZ5a2X5q+N6KGo56S65Y6f5a2Q44CC5b2T5bm/5LmJ6KGoTFPpnZ7nqbrml7bvvIznp7DnrKzkuIDkuKrlhYPntKBhMeS4ukxT55qE6KGo5aS077yM56ew5YW25L2Z5YWD57Sg57uE5oiQ55qE6KGoKGEyLCBhMywgLi4uLCBhbinmmK9MU+eahOihqOWwvuOAglxyXG4gKlxyXG4gKiDkuIvpnaLliJfkuL7kuIDkupvlub/kuYnooajnmoTkvovlrZDvvJpcclxuICogMS5BID0gKCkgLS0tLSBB5piv5LiA5Liq56m66KGo77yM5a6D55qE6ZW/5bqm5Li6MOOAglxyXG4gKiAyLkIgPSAoZSkgLS0tLSDliJfooahC5Y+q5pyJ5LiA5Liq5Y6f5a2QZe+8jELnmoTplb/luqbkuLox44CCXHJcbiAqIDMuQyA9IChhLCAoYiwgYywgZCkpIC0tLS0g5YiX6KGoQ+eahOmVv+W6puS4ujLvvIzkuKTkuKrlhYPntKDliIbliKvkuLrljp/lrZBh5ZKM5a2Q6KGoKGIsIGMsIGQp44CCXHJcbiAqIDQuRCA9IChBLCBCLCBDKSAtLS0tIOWIl+ihqETnmoTplb/luqbkuLozLDPkuKrlhYPntKDpg73mmK/liJfooajjgILmmL7npLrvvIzlsIblrZDooajnmoTlgLzku6PlhaXlkI7vvIzliJnmnIlEID0gKCgpLCAoZSksIChhLCAoYiwgYywgZCkpKeOAglxyXG4gKiA1LkUgPSAoYSwgRSkgLS0tLSDov5nmmK/kuIDkuKrpgJLlvZLnmoTooajvvIzlroPnmoTplb/luqbkuLoyLkXnm7jlvZPkuo7kuIDkuKrml6DpmZDnmoTliJfooahFID0gKGEsIChhLCAoYSwgLi4uKSkp44CCXHJcbiAqXHJcbiAqIDHvvInliJfooajnmoTlhYPntKDlj6/ku6XmmK/lrZDooajvvIzogIzlrZDooajnmoTlhYPntKDov5jlj6/ku6XmmK/lrZDooajjgILnlLHmraTvvIzliJfooajmmK/kuIDkuKrlpJrlsYLmrKHnmoTnu5PmnoTvvIzlj6/ku6XnlKjlm77lvaLosaHlnLDooajnpLrjgIJcclxuICogMinliJfooajlj6/kuLrlhbblroPliJfooajmiYDlhbHkuqvjgILliJfooahB77yMQuWSjEPkuLpE55qE5a2Q6KGo77yM5YiZ5ZyoROS4reWPr+S7peS4jeW/heWIl+WHuuWtkOihqOeahOWAvOOAglxyXG4gKiAz77yJ5YiX6KGo5Y+v5Lul5piv5LiA5Liq6YCS5b2S55qE6KGo77yM5Y2z5YiX6KGo5Lmf5Y+v5Lul5piv5YW25pys6Lqr55qE5LiA5Liq5a2Q6KGo44CC5L6L5aaC5YiX6KGoReOAglxyXG4gKlxyXG4gKiDku7vkvZXkuIDkuKrpnZ7nqbrliJfooajlhbbooajlpLTlj6/og73mmK/ljp/lrZDvvIzkuZ/lj6/og73mmK/liJfooajvvIzogIzlhbbooajlsL7lv4XlrprkuLrliJfooajjgIJcclxuICpcclxuICovXHJcblxyXG4vKlxyXG4g5bm/5LmJ6KGo55qE6YCS5b2S566X5rOVXHJcblxyXG4g6YCS5b2S5a6a5LmJ55qE5b2S57qz6aG55o+P6L+w5LqG5aaC5L2V5a6e546w5LuO5b2T5YmN54q25oCB5Yiw57uI57uT54q25oCB55qE6L2s5YyW44CCXHJcblxyXG4g55Sx5LqO6YCS5b2S5Ye95pWw55qE6K6+6K6h55So55qE5piv5b2S57qz5oCd57u055qE5pa55rOV77yM5YiZ5Zyo6K6+6K6h6YCS5b2S5Ye95pWw5pe277yM5bqU5rOo5oSP77yaXHJcbiDvvIgx77yJ6aaW5YWI5bqU5Lmm5YaZ5Ye95pWw55qE6aaW6YOo5ZKM6KeE5qC86K+05piO77yM5Lil5qC85a6a5LmJ5Ye95pWw55qE5Yqf6IO95ZKM5o6l5Y+j77yI6YCS5b2S6LCD55So55qE55WM6Z2i77yJ77yM5a+55rGC57K+5Ye95pWw5Lit5omA5b6X55qE5ZKM5Y6f6Zeu6aKY5oCn6LSo55u45ZCM55qE5a2X6Zeu6aKY77yM5Y+q6KaB5o6l5Y+j5LiA6Ie077yM5L6/5Y+v6L+b6KGM6YCS5b2S6LCD55So44CCXHJcbiDvvIgy77yJ5a+55Ye95pWw5Lit55qE5q+P5LiA5Liq6YCS5b2S6LCD55So6YO955yL5oiQ5Y+q5piv5LiA5Liq566A5Y2V55qE5pON5L2c77yM5Y+q6KaB5o6l5Y+j5LiA6Ie077yM5b+F6IO95a6e546w6KeE5qC86K+05piO5Lit5a6a5LmJ55qE5Yqf6IO977yM5YiH5b+M5oOz5b6X5aSq5rex5aSq6L+c44CCXHJcbiAqL1xyXG5cclxuLypcclxuIOaxguW5v+S5ieihqOeahOa3seW6plxyXG5cclxuIOW5v+S5ieihqOeahOa3seW6puWumuS5ieS4uuW5v+S5ieihqOS4reaLrOW8p+eahOmHjeaVsO+8jOaYr+W5v+S5ieihqOeahOS4gOenjemHj+W6puOAglxyXG4g6K6+6Z2e56m65bm/5LmJ6KGo5Li6OlxyXG4gTFMgPSAoYTEsIGEyLCAuLi4sIGFuKVxyXG5cclxuIOWFtuS4rWFpKGkgPSAxLCAyLCAuLi4sIG4p5oiW5Li65Y6f5a2Q5oiW5Li6TFPnmoTlrZDooajvvIzliJnmsYJMU+eahOa3seW6puWPr+WIhuino+S4um7kuKrlrZDpl67popjvvIzmr4/kuKrlrZDpl67popjkuLrmsYJhaeeahOa3seW6pu+8jOiLpWFp5piv5Y6f5a2Q77yM5YiZ55Sx5a6a5LmJ5YW25rex5bqm5Li66Zu277yM6IulYWnmmK/lub/kuYnooajvvIzliJnpgJLlvZLlpITnkIbvvIzogIxMU+eahOa3seW6puS4uuWQhGFpKGkgPSAxLCAyLCAuLi4sIG4p55qE5rex5bqm5pyA5aSn5YC85YqgMS7nqbrooajkuZ/mmK/lub/kuYnooajvvIzkuJTmt7HluqbkuLoxLlxyXG5cclxuIOW5v+S5ieihqOeahOa3seW6pkRFUFRIKExTKeeahOmAkuW9kuWumuS5ieS4uu+8mlxyXG4g5Z+65pys6aG577yaICAgIERFUFRIKExTKSA9IDEgICDlvZNMU+S4uuepuuihqOaXtlxyXG4gREVQVEgoTFMpID0gMCAgIOW9k0xT5Li65Y6f5a2Q5pe2XHJcbiDlvZLnurPpobnvvJogICAgREVQVEgoTFMpID0gMSArIE1BWHtERVBUSChhaSl9ICAxIDw9IGkgPD0gblxyXG4gKi9cclxuXHJcbmNvbnN0IEFUT00gPSBTeW1ib2woKTtcclxuY29uc3QgTElTVCA9IFN5bWJvbCgpO1xyXG5cclxubGV0IGdsb2JhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbi8vIOS9v+eUqOmTvumYn+WIl1xyXG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vUXVldWUvUXVldWUuanMnO1xyXG5cclxuLy8g5bm/5LmJ6KGo55qE5aS05bC+6ZO+6KGo5a2Y5YKo6KGo56S6XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdMTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIC8vIOWFrOWFsemDqOWIhu+8jOeUqOS6juWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxyXG4gICAgICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvLyBhdG9t5piv5Y6f5a2Q57uT54K555qE5YC85Z+fXHJcbiAgICAgICAgdGhpcy5hdG9tID0gbnVsbDtcclxuICAgICAgICAvLyBwdHLmmK/ooajnu5PngrnnmoTmjIfpkojln59cclxuICAgICAgICB0aGlzLnB0ciA9IHtcclxuICAgICAgICAgICAgLy8gcHRyLmhw5ZKMcHRyLnRw5YiG5Yir5oyH5ZCR6KGo5aS05ZKM6KGo5bC+XHJcbiAgICAgICAgICAgIGhwOiBudWxsLFxyXG4gICAgICAgICAgICB0cDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6YeH55So5aS05bC+6ZO+6KGo5a2Y5YKo57uT5p6E77yM5rGC5bm/5LmJ6KGo55qE5rex5bqmXHJcbiAgICBkZXB0aCAoKXtcclxuICAgICAgICByZXR1cm4gZ2V0RGVwdGgodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5aSN5Yi25bm/5LmJ6KGoXHJcbiAgICBjb3B5TGlzdCAoZ0xpc3QpIHtcclxuICAgICAgICBnTGlzdC50YWcgPSB0aGlzLnRhZztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudGFnID09PSBBVE9NKSB7XHJcbiAgICAgICAgICAgIGdMaXN0LmF0b20gPSB0aGlzLmF0b207XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHRyLmhwKSB7XHJcbiAgICAgICAgICAgICAgICBnTGlzdC5wdHIuaHAgPSBuZXcgR0xOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ci5ocC5jb3B5TGlzdChnTGlzdC5wdHIuaHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ci50cCkge1xyXG4gICAgICAgICAgICAgICAgZ0xpc3QucHRyLnRwID0gbmV3IEdMTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIudHAuY29weUxpc3QoZ0xpc3QucHRyLnRwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDph4fnlKjlpLTlsL7pk77ooajlrZjlgqjnu5PmnoTvvIznlLHlub/kuYnooajnmoTkuablhpnlvaLlvI/kuLLliJvlu7rlub/kuYnooahcclxuICAgIGNyZWF0ZUdMaXN0IChzdHJpbmcpIHtcclxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xyXG5cclxuICAgICAgICAvLyDliJvlu7rljZXljp/lrZDlub/kuYnooahcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICBpZiAoaXNXb3JkKHN0cmluZykpIHtcclxuICAgICAgICAgICAgdGhpcy50YWcgPSBBVE9NO1xyXG4gICAgICAgICAgICB0aGlzLmF0b20gPSBzdHJpbmc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50YWcgPSBMSVNUO1xyXG4gICAgICAgICAgICBsZXQgcCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyDohLHlpJblsYLmi6zlj7dcclxuICAgICAgICAgICAgbGV0IHN1YiA9IHN0cmluZy5zdWJzdHIoMSwgc3RyaW5nLmxlbmd0aCAtIDIpO1xyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhzdWI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbiA9IHN1Yi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2g7XHJcblxyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3ViW2krK107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09ICcoJykgKytrO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09ICcpJykgLS1rO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA8IG4gJiYgKGNoICE9ICcsJyB8fCBrICE9IDApKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBp5Li656ys5LiA5Liq6YCX5Y+35YiG6ZqU57Si5byVXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBoc3ViID0gc3ViLnN1YnN0cigwLCBpIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViID0gc3ViLnN1YnN0cihpLCBuIC0gaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOacgOWQjuS4gOe7hFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoc3ViID0gc3ViO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGhzdWIgPT09ICcoKScpIHAucHRyLmhwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIOWIm+W7uuihqOWktOe7k+eCuVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wdHIuaHAgPSBuZXcgR0xOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wdHIuaHAuY3JlYXRlR0xpc3QoaHN1Yik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcSA9IHA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5Yib5bu66KGo5bC+57uT54K5XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBHTE5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnRhZyA9IExJU1Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5wdHIudHAgPSBwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChzdWIpO1xyXG5cclxuICAgICAgICAgICAgcS5wdHIudHAgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZXF1YWwoZ0xpc3QxLCBnTGlzdDIpIHtcclxuICAgICAgICAvLyDnqbrooajml7bnm7jnrYnnmoRcclxuICAgICAgICBpZiAoIWdMaXN0MSAmJiAhZ0xpc3QyKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoZ0xpc3QxLnRhZyA9PT0gQVRPTSAmJiBnTGlzdDIudGFnID09PSBBVE9NICYmIGdMaXN0MS5hdG9tID09PSBnTGlzdDIuYXRvbSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGlmIChnTGlzdDEudGFnID09PSBMSVNUICYmIGdMaXN0Mi50YWcgPT09IExJU1QpIHtcclxuICAgICAgICAgICAgLy8g6KGo5aS06KGo5bC+6YO955u4562JXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsKGdMaXN0MS5wdHIuaHAsIGdMaXN0Mi5wdHIuaHApICYmIHRoaXMuZXF1YWwoZ0xpc3QxLnB0ci50cCwgZ0xpc3QyLnB0ci50cCkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOmAkuW9kumAhui9rOW5v+S5ieihqFxyXG4gICAgcmV2ZXJzZSgpIHtcclxuICAgICAgICBsZXQgcHRyID0gW107XHJcbiAgICAgICAgLy8g5b2TQeS4jeS4uuWOn+WtkOS4lOihqOWwvumdnuepuuaXtuaJjemcgOmAhui9rFxyXG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gTElTVCAmJiB0aGlzLnB0ci50cCkge1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHAsIGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8g6YCG6L2s5ZCE5a2Q6KGoXHJcbiAgICAgICAgICAgICAgICBpZiAocC5wdHIuaHApIHAucHRyLmhwLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwdHJbaV0gPSBwLnB0ci5ocDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g6YeN5paw5oyJ6YCG5bqP5o6S5YiX5ZCE5a2Q6KGo55qE6aG65bqPXHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApXHJcbiAgICAgICAgICAgICAgICBwLnB0ci5ocCA9IHB0clstLWldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICAgIGlmICh0aGlzID09IGdsb2JhbCB8fCB0aGlzID09IG51bGwpIHN0ciA9ICcoKSc7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy50YWcgPT09IEFUT00pIHN0ciA9IHRoaXMuYXRvbTsgIC8vIOWOn+WtkFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdHIgKz0gJygnO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCkge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IHRoaXMudG9TdHJpbmcuY2FsbChwLnB0ci5ocCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5wdHIudHApIHN0ciArPSAnLCAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ciArPSAnKSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOaMieWxguW6j+i+k+WHuuW5v+S5ieihqFxyXG4gICAgLy8g5bGC5bqP6YGN5Y6G55qE6Zeu6aKY77yM5LiA6Iis6YO95piv5YCf5Yqp6Zif5YiX5p2l5a6M5oiQ55qE77yM5q+P5qyh5LuO6Zif5aS0XHJcbiAgICAvLyDlj5blh7rkuIDkuKrlhYPntKDnmoTlkIzml7bmiorlroPkuIvkuIDlsYLnmoTlranlrZDmj5LlhaXpmJ/lsL7vvIzov5nmmK/lsYLluo/pgY3ljobnmoTln7rmnKzmgJ3mg7NcclxuICAgIG9yZGVyUHJpbnQgKCl7XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gW107XHJcbiAgICAgICAgZm9yKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKSBxdWV1ZS5wdXNoKHApO1xyXG5cclxuICAgICAgICB3aGlsZShxdWV1ZS5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZXQgciA9IHF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGlmKHIudGFnID09PSBBVE9NKSBjb25zb2xlLmxvZyhyLmF0b20pO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcihyID0gci5wdHIuaHA7IHI7IHIgPSByLnB0ci50cClcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9yZGVyUHJpbnQyICgpe1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG5cclxuICAgICAgICBmb3IobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApIHF1ZXVlLmVuUXVldWUocCk7XHJcblxyXG4gICAgICAgIHdoaWxlKHF1ZXVlLnNpemUpe1xyXG4gICAgICAgICAgICBsZXQgciA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgaWYoci50YWcgPT09IEFUT00pIGNvbnNvbGUubG9nKHIuYXRvbSk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yKHIgPSByLnB0ci5ocDsgcjsgciA9IHIucHRyLnRwKVxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIOW5v+S5ieihqOeahOaJqeWxlee6v+aAp+mTvuihqOWtmOWCqOihqOekulxyXG5jbGFzcyBHTE5vZGUyIHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgLy8g5YWs5YWx6YOo5YiG77yM55So5LqO5Yy65YiG5Y6f5a2Q57uT54K55ZKM6KGo57uT54K5XHJcbiAgICAgICAgdGhpcy50YWcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIOWOn+WtkOe7k+eCueeahOWAvOWfn1xyXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XHJcbiAgICAgICAgLy8g6KGo57uT54K555qE6KGo5aS05oyH6ZKIXHJcbiAgICAgICAgdGhpcy5ocCA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIOebuOW9k+S6jue6v+aAp+mTvuihqOeahG5leHTvvIzmjIflkJHkuIvkuIDkuKrlhYPntKDnu5PngrlcclxuICAgICAgICB0aGlzLnRwID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGVwdGgoZ0xpc3QpIHtcclxuICAgIGlmICghZ0xpc3QpIHJldHVybiAxO1xyXG4gICAgZWxzZSBpZiAoZ0xpc3QudGFnID09PSBBVE9NKSByZXR1cm4gMDtcclxuXHJcbiAgICBsZXQgbSA9IGdldERlcHRoKGdMaXN0LnB0ci5ocCkgKyAxO1xyXG4gICAgbGV0IG4gPSBnZXREZXB0aChnTGlzdC5wdHIudHApO1xyXG5cclxuICAgIHJldHVybiBtID4gbiA/IG0gOiBuO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1dvcmQoc3RyKXtcclxuICAgIHJldHVybiAvXltcXHctXSskLy50ZXN0KHN0cik7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gbeWFg+WkmumhueW8j+ihqOekulxyXG5cclxuIOWmguaenOeUqOe6v+aAp+ihqOadpeihqOekuizliJnmr4/kuKrmlbDmja7lhYPntKDpnIDopoFtKzHkuKrmlbDmja7pobnvvIzku6XlrZjlgqjkuIDkuKrns7vmlbDlkoxt5Liq5oyH5pWw5YC877yM6L+Z5bCG5Lqn55Sf5Lik5Liq6Zeu6aKY44CCXHJcbiDkuIDmmK/ml6DorrrlpJrpobnlvI/kuK3lkITpobnnmoTlj5jlhYPmlbDmmK/lpJrmmK/lsJHvvIzoi6Xpg73mjIlt5Liq5Y+Y5YWD5YiG6YWN5a2Y5YKo56m66Ze077yM5YiZ5bCG6YCg5oiQ5rWq6LS577yb5Y+N5LmL77yM6Iul5oyJ5ZCE6aG55a6e6ZmF55qE5Y+Y5YWD5pWw5YiG6YWN5a2Y5YKo56m66Ze077yM5bCx5Lya6YCg5oiQ57uT54K555qE5aSn5bCP5LiN5YyA77yM57uZ5pON5L2c5bim5p2l5LiN5L6/44CC5LqM5piv5a+5beWAvOS4jeWQjOeahOWkmumhueW8j++8jOe6v+aAp+ihqOS4reeahOe7k+eCueWkp+Wwj+S5n+S4jeWQjO+8jOi/meWQjOagt+W8lei1t+WtmOWCqOeuoeeQhueahOS4jeS+v+OAglxyXG4g5pWF5LiN6YCC5LqO55So57q/5oCn6KGo6KGo56S644CCXHJcblxyXG4g5L6L5aaC5LiJ5YWD5aSa6aG55byP77yaXHJcbiBQKHgsIHksIHopID0geCgxMCl5KDMpeigyKSArIDJ4KDYpeSgzKXooMikgKyAzeCg1KXkoMil6KDIpICsgeCg0KXkoNCl6ICsgMnl6ICsgMTVcclxuXHJcbiDlpoLoi6XmlLnlhpnkuLrvvJpcclxuIFAoeCwgeSwgeikgPSAoKHgoMTApICsgMngoNikpeSgzKSArIDN4KDUpeSgyKSl6KDIpICsgKCh4KDQpICsgNngoMykpeSg0KSArIDJ5KXogKyAxNVxyXG5cclxuIOeUqOW5v+S5ieihqOihqOekuu+8mlxyXG4gUCA9IHooKEEsIDIpLCAoQiwgMSksICgxNSwgMCkpXHJcbiBBID0geSgoQywgMyksIChELCAyKSlcclxuIEIgPSB5KChFLCA0KSwgKEYsIDEpKVxyXG4gQyA9IHgoKDEsIDEwKSwgKDIsIDYpKVxyXG4gRCA9IHgoKDMsIDUpKVxyXG4gRSA9IHgoKDEsIDQpLCAoNiwgMykpXHJcbiBGID0geCgoMiwgMCkpXHJcblxyXG5cclxuICovXHJcblxyXG5mdW5jdGlvbiBNUE5vZGUoKSB7XHJcbiAgICAvLyDljLrliIbljp/lrZDnu5Pngrnlkozooajnu5PngrlcclxuICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xyXG4gICAgLy8g5oyH5pWw5Z+fXHJcbiAgICB0aGlzLmV4cCA9IDA7XHJcblxyXG4gICAgLy8g57O75pWw5Z+fXHJcbiAgICB0aGlzLmNvZWYgPSAwO1xyXG4gICAgLy8g6KGo57uT54K555qE6KGo5aS05oyH6ZKIXHJcbiAgICB0aGlzLmhwID0gbnVsbDtcclxuXHJcbiAgICAvLyDnm7jlvZPkuo7nur/mgKfooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XHJcbiAgICB0aGlzLnRwID0gbnVsbDtcclxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0dlbmVyYWxpemVkTGlzdC9HTGlzdC5qc1xuICoqLyIsIi8qXHJcbiDpgrvmjqXlpJrph43ooahcclxuXHJcbiDpgrvmjqXlpJrph43ooagoQWRqYWNlbmN5IE11bHRpbGlzdCnmmK/ml6DlkJHlm77nmoTlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoTjgIJcclxuXHJcbiDpgrvmjqXooajmmK/ml6DlkJHlm77nmoTkuIDnp43mnInmlYjnmoTlrZjlgqjnu5PmnoTvvIzlnKjml6DlkJHlm77nmoTpgrvmjqXooajkuK3vvIzkuIDmnaHovrkodix3KeeahOS4pOS4quihqOe7k+eCueWIhuWIq+WInemAieWcqOS7pXblkox35Li65aS057uT54K555qE6ZO+6KGo5Lit77yM5b6I5a655piT5rGC5b6X6aG254K55ZKM6L6555qE5L+h5oGv77yM5L2G5Zyo5raJ5Y+K5Yiw6L6555qE5pON5L2c5Lya5bim5p2l5LiN5L6/44CCXHJcblxyXG4g6YK75o6l5aSa6YeN6KGo55qE57uT5p6E5ZKM5Y2B5a2X6ZO+6KGo57G75Ly877yM5q+P5p2h6L6555So5LiA5Liq57uT54K56KGo56S677yb6YK75o6l5aSa6YeN6KGo5Lit55qE6aG254K557uT54K557uT5p6E5LiO6YK75o6l6KGo5Lit55qE5a6M5YWo55u45ZCM77yM6ICM6KGo57uT54K55YyF5ous5YWt5Liq5Z+f44CCXHJcblxyXG4g4peGICBEYXRh5Z+f77ya5a2Y5YKo5ZKM6aG254K555u45YWz55qE5L+h5oGv77ybXHJcbiDil4Yg5oyH6ZKI5Z+fZmlyc3RlZGdl77ya5oyH5ZCR5L6d6ZmE5LqO6K+l6aG254K555qE56ys5LiA5p2h6L655omA5a+55bqU55qE6KGo57uT54K577ybXHJcbiDil4Yg5qCH5b+X5Z+fbWFya++8mueUqOS7peagh+ivhuivpeadoei+ueaYr+WQpuiiq+iuv+mXrui/h++8m1xyXG4g4peGIGl2ZXjlkoxqdmV45Z+f77ya5YiG5Yir5L+d5a2Y6K+l6L655omA5L6d6ZmE55qE5Lik5Liq6aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXHJcbiDil4YgaW5mb+Wfn++8muS/neWtmOivpei+ueeahOebuOWFs+S/oeaBr++8m1xyXG4g4peGIOaMh+mSiOWfn2lsaW5r77ya5oyH5ZCR5LiL5LiA5p2h5L6d6ZmE5LqO6aG254K5aXZleOeahOi+ue+8m1xyXG4g4peGIOaMh+mSiOWfn2psaW5r77ya5oyH5ZCR5LiL5LiA5p2h5L6d6ZmE5LqO6aG254K5anZleOeahOi+ue+8m1xyXG5cclxuIOmCu+aOpeWkmumHjeihqOS4jumCu+aOpeihqOeahOWMuuWIq++8mlxyXG4g5ZCO6ICF55qE5ZCM5LiA5p2h6L6555So5Lik5Liq6KGo57uT54K56KGo56S677yM6ICM5YmN6ICF5Y+q55So5LiA5Liq6KGo57uT54K56KGo56S677yb6Zmk5qCH5b+X5Z+f5aSW77yM6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo6KGo6L6+55qE5L+h5oGv5piv55u45ZCM55qE77yM5Zug5q2k77yM5pON5L2c55qE5a6e546w5Lmf5Z+65pys55u45Ly844CCXHJcblxyXG4gKi9cclxuXHJcbmNvbnN0IFVOVklTSVRFRCA9IDA7XHJcbmNvbnN0IFZJU0lURUQgPSAxO1xyXG5cclxuXHJcbmNsYXNzIEVCb3gge1xyXG4gICAgLyoqXHJcbiAgICAgKiDovrnnmoTnu5PngrnooajnpLpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXJrIOiuv+mXruagh+iusCAwIC0tIOacquiuv+mXriAgMSA9PSDlt7Lorr/pl65cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGp2ZXgg6K+l6L655L6d6ZmE55qE5Lik5Liq6aG254K555qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0ge0VCb3h9IGlsaW5rIOWIhuWIq+aMh+WQkeS+nemZhOi/meS4pOS4qumhtueCueeahOS4i+S4gOadoei+uVxyXG4gICAgICogQHBhcmFtIHtFQm94fSBqbGluayDliIbliKvmjIflkJHkvp3pmYTov5nkuKTkuKrpobbngrnnmoTkuIvkuIDmnaHovrlcclxuICAgICAqIEBwYXJhbSB7Kn0gaW5mbyDor6Xovrnkv6Hmga9cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXJrLCBpdmV4LCBqdmV4LCBpbGluaywgamxpbmssIGluZm8pe1xyXG4gICAgICAgIHRoaXMubWFyayA9IG1hcmsgfHwgVU5WSVNJVEVEO1xyXG4gICAgICAgIHRoaXMuaXZleCA9IGl2ZXggfHwgMDtcclxuICAgICAgICB0aGlzLmp2ZXggPSBqdmV4IHx8IDA7XHJcbiAgICAgICAgdGhpcy5pbGluayA9IGlsaW5rIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5qbGluayA9IGpsaW5rIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbyB8fCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBBTUxWZXhCb3gge1xyXG4gICAgLyoqXHJcbiAgICAgKiDpobbngrnnmoTnu5PngrnooajnpLpcclxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gICAgICogQHBhcmFtIHtFQm94fSBmaXJzdEVkZ2Ug5oyH5ZCR56ys5LiA5p2h5L6d6ZmE6K+l6aG254K555qE6L65XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZmlyc3RFZGdlKXtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5maXJzdEVkZ2UgPSBmaXJzdEVkZ2UgfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQU1MR3JhcGgge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheSB8IEFNTFZleEJveH0gYWRqTXVsaXN0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmV4bnVtXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZWRnZW51bVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFkak11bGlzdCwgdmV4bnVtLCBlZGdlbnVtKXtcclxuICAgICAgICB0aGlzLmFkak11bGlzdCA9IGFkak11bGlzdCB8fCBbXTtcclxuICAgICAgICB0aGlzLnZleG51bSA9IHZleG51bSB8fCAwO1xyXG4gICAgICAgIHRoaXMuZWRnZW51bSA9IGVkZ2VudW0gfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBsb2NhdGVWZXggKHYpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWRqTXVsaXN0W2ldLmRhdGEgPT09IHYpIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlQXJjKHYsIHcpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMubG9jYXRlVmV4KHYpO1xyXG4gICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgodyk7XHJcblxyXG4gICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggbm90IGZvdW5kIScpO1xyXG5cclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICAvLyDlnKhp6ZO+6KGo5Lit5Yig6Zmk6K+l6L65XHJcbiAgICAgICAgaWYgKHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZS5qdmV4ID09PSBqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZS5pbGluaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2U7IHAgJiYgcC5pbGluay5qdmV4ICE9PSBqOyBwID0gcC5pbGluayk7XHJcbiAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcclxuICAgICAgICAgICAgcC5pbGluayA9IHAuaWxpbmsuaWxpbms7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDlnKhq6ZO+6KGo5Lit5Yig6Zmk6K+l6L65XHJcbiAgICAgICAgaWYgKHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZS5pdmV4ID09PSBpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZS5qbGluaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2U7IHAgJiYgcC5qbGluay5pdmV4ICE9PSBpOyBwID0gcC5qbGluayk7XHJcbiAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcclxuICAgICAgICAgICAgcC5qbGluayA9IHAuamxpbmsuamxpbms7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmVkZ2VudW0tLTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVHcmFwaCgpIHtcclxuICAgICAgICB2YXIgdmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcclxuICAgICAgICB0aGlzLnZleG51bSA9IHZleG51bTtcclxuICAgICAgICB2YXIgZWRnZW51bSA9ICtwcm9tcHQoJ2VkZ2VudW06ICcpO1xyXG4gICAgICAgIHRoaXMuZWRnZW51bSA9IGVkZ2VudW07XHJcblxyXG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdmV4bnVtOyArK20pIHtcclxuICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3RbbV0gPSBuZXcgQU1MVmV4Qm94KHByb21wdCgnZGF0YTogJyksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChtID0gMDsgbSA8IGVkZ2VudW07ICsrbSkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHByb21wdCgndGFpbFZleDogJyk7XHJcbiAgICAgICAgICAgIHZhciBoID0gcHJvbXB0KCdoZWFkVmV4OiAnKTtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh0KTtcclxuICAgICAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleChoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndmVydGV4IG5vdCBmb3VuZCEgVHJ5IGFnYWluOicpO1xyXG4gICAgICAgICAgICAgICAgbS0tO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwID0gbmV3IEVCb3goMCwgaSwgaiwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBxLCByO1xyXG5cclxuICAgICAgICAgICAgLy8g5o+S5YWlaemTvuihqOWwvumDqFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlID0gcDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEgPSB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxLml2ZXggPT09IGkpIHEgPSBxLmlsaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcSA9IHEuamxpbms7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoci5pdmV4ID09PSBpKSByLmlsaW5rID0gcDtcclxuICAgICAgICAgICAgICAgIGVsc2Ugci5qbGluayA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOaPkuWFpWrpk77ooajlsL7pg6hcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZSA9IHA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHEpIHtcclxuICAgICAgICAgICAgICAgICAgICByID0gcTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocS5qdmV4ID09PSBqKSBxID0gcS5qbGluaztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHEgPSBxLmlsaW5rO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHIuanZleCA9PT0gaikgci5qbGluayA9IHA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHIuaWxpbmsgPSBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vL3ZhciBnID0gbmV3IEFNTEdyYXBoKCk7XHJcbi8vZy5jcmVhdGVHcmFwaCgpO1xyXG4vL2NvbnNvbGUubG9nKGcpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9HcmFwaC9BTUxHcmFwaC5qc1xuICoqLyIsIi8qIENyZWF0ZSBCeSBMdWtlICovXHJcblxyXG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vU3RhY2svaW5kZXgnO1xyXG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vUXVldWUvUXVldWUnO1xyXG5pbXBvcnQgeyBDaGlsZFNpYmxpbmdUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcclxuXHJcbi8vIOWbvueahOaVsOe7hO+8iOmCu+aOpeefqemYte+8ieWtmOWCqOihqOekulxyXG5jb25zdCBERyA9IDE7ICAgICAvLyDmnInlkJHlm75cclxuY29uc3QgRE4gPSAyOyAgICAgLy8g5pyJ5ZCR572RXHJcbmNvbnN0IFVERyA9IDM7ICAgIC8vIOaXoOWQkeWbvlxyXG5jb25zdCBVRE4gPSA0OyAgICAvLyDml6DlkJHnvZFcclxuXHJcblxyXG4vKlxyXG4g6YK75o6l6ZO+6KGo5rOVXHJcblxyXG4g5Z+65pys5oCd5oOz77ya5a+55Zu+55qE5q+P5Liq6aG254K55bu656uL5LiA5Liq5Y2V6ZO+6KGo77yM5a2Y5YKo6K+l6aG254K55omA5pyJ6YK75o6l6aG254K55Y+K5YW255u45YWz5L+h5oGv44CC5q+P5LiA5Liq5Y2V6ZO+6KGo6K6+5LiA5Liq6KGo5aS057uT54K544CCXHJcblxyXG4g56ysaeS4quWNlemTvuihqOihqOekuuS+nemZhOS6jumhtueCuVZp55qE6L65KOWvueacieWQkeWbvuaYr+S7pemhtueCuVZp5Li65aS05oiW5bC+55qE5bynKeOAglxyXG5cclxuIDEgIOe7k+eCuee7k+aehOS4jumCu+aOpemTvuihqOekuuS+i1xyXG5cclxuIOmTvuihqOS4reeahOe7k+eCueensOS4uuihqOe7k+eCue+8jOavj+S4que7k+eCueeUseS4ieS4quWfn+e7hOaIkOOAguWFtuS4remCu+aOpeeCueWfnyhhZGp2ZXgp5oyH56S65LiO6aG254K5VmnpgrvmjqXnmoTpobbngrnlnKjlm77kuK3nmoTkvY3nva4o6aG254K557yW5Y+3Ke+8jOmTvuWfnyhuZXh0YXJjKeaMh+WQkeS4i+S4gOS4quS4jumhtueCuVZp6YK75o6l55qE6KGo57uT54K577yM5pWw5o2u5Z+fKGluZm8p5a2Y5YKo5ZKM6L655oiW5byn55u45YWz55qE5L+h5oGv77yM5aaC5p2D5YC8562J44CC5a+55LqO5peg5p2D5Zu+77yM5aaC5p6c5rKh5pyJ5LiO6L6555u45YWz55qE5YW25LuW5L+h5oGv77yM5Y+v55yB55Wl5q2k5Z+f44CCXHJcblxyXG4g5q+P5Liq6ZO+6KGo6K6+5LiA5Liq6KGo5aS057uT54K5KOensOS4uumhtueCuee7k+eCuSnvvIznlLHkuKTkuKrln5/nu4TmiJDjgILpk77ln58oZmlyc3RhcmMp5oyH5ZCR6ZO+6KGo5Lit55qE56ys5LiA5Liq57uT54K577yM5pWw5o2u5Z+fKGRhdGEpIOWtmOWCqOmhtueCueWQjeaIluWFtuS7luS/oeaBr+OAglxyXG5cclxuIOWcqOWbvueahOmCu+aOpemTvuihqOihqOekuuS4re+8jOaJgOaciemhtueCuee7k+eCueeUqOS4gOS4quWQkemHjyDku6Xpobrluo/nu5PmnoTlvaLlvI/lrZjlgqjvvIzlj6/ku6Xpmo/mnLrorr/pl67ku7vmhI/pobbngrnnmoTpk77ooajvvIzor6XlkJHph4/np7DkuLrooajlpLTlkJHph4/vvIzlkJHph4/nmoTkuIvmoIfmjIfnpLrpobbngrnnmoTluo/lj7fjgIJcclxuXHJcbiDnlKjpgrvmjqXpk77ooajlrZjlgqjlm77ml7bvvIzlr7nml6DlkJHlm77vvIzlhbbpgrvmjqXpk77ooajmmK/llK/kuIDnmoTvvJvlr7nmnInlkJHlm77vvIzlhbbpgrvmjqXpk77ooajmnInkuKTnp43lvaLlvI/jgIJcclxuXHJcblxyXG4gMiAg6YK75o6l6KGo5rOV55qE54m554K5XHJcblxyXG4g4peGIOihqOWktOWQkemHj+S4reavj+S4quWIhumHj+WwseaYr+S4gOS4quWNlemTvuihqOeahOWktOe7k+eCue+8jOWIhumHj+S4quaVsOWwseaYr+WbvuS4reeahOmhtueCueaVsOebru+8m1xyXG4g4peGIOWcqOi+ueaIluW8p+eogOeWj+eahOadoeS7tuS4i++8jOeUqOmCu+aOpeihqOihqOekuuavlOeUqOmCu+aOpeefqemYteihqOekuuiKguecgeWtmOWCqOepuumXtO+8m1xyXG4g4peGIOWcqOaXoOWQkeWbvu+8jOmhtueCuVZp55qE5bqm5piv56ysaeS4qumTvuihqOeahOe7k+eCueaVsO+8m1xyXG4g4peGIOWvueacieWQkeWbvuWPr+S7peW7uueri+ato+mCu+aOpeihqOaIlumAhumCu+aOpeihqOOAguato+mCu+aOpeihqOaYr+S7pemhtueCuVZp5Li65Ye65bqmKOWNs+S4uuW8p+eahOi1t+eCuSnogIzlu7rnq4vnmoTpgrvmjqXooajvvJvpgIbpgrvmjqXooajmmK/ku6XpobbngrlWaeS4uuWFpeW6pijljbPkuLrlvKfnmoTnu4jngrkp6ICM5bu656uL55qE6YK75o6l6KGo77ybXHJcbiDil4Yg5Zyo5pyJ5ZCR5Zu+5Lit77yM56ysaeS4qumTvuihqOS4reeahOe7k+eCueaVsOaYr+mhtueCuVZp55qE5Ye6ICjmiJblhaUp5bqm77yb5rGC5YWlICjmiJblh7op5bqm77yM6aG76YGN5Y6G5pW05Liq6YK75o6l6KGo77ybXHJcbiDil4Yg5Zyo6YK75o6l6KGo5LiK5a655piT5om+5Ye65Lu75LiA6aG254K555qE56ys5LiA5Liq6YK75o6l54K55ZKM5LiL5LiA5Liq6YK75o6l54K577ybXHJcblxyXG4gKi9cclxuXHJcblxyXG5jbGFzcyBBcmNOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhZGpWZXhcclxuICAgICAqIEBwYXJhbSB7QXJjTm9kZX0gbmV4dEFyY1xyXG4gICAgICogQHBhcmFtIHsqfSBpbmZvXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWRqVmV4ID0gMCwgbmV4dEFyYyA9IG51bGwsIGluZm8gPSBudWxsKXtcclxuICAgICAgICAvLyDor6XlvKfmiYDmjIflkJHnmoTpobbngrnnmoTkvY3nva5cclxuICAgICAgICB0aGlzLmFkalZleCA9IGFkalZleDtcclxuICAgICAgICAvLyDmjIflkJHkuIvkuIDmnaHlvKfnmoTmjIfpkohcclxuICAgICAgICB0aGlzLm5leHRBcmMgPSBuZXh0QXJjO1xyXG4gICAgICAgIC8vIOivpeW8p+ebuOWFs+S/oeaBr+eahOaMh+mSiFxyXG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFZleE5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXHJcbiAgICAgKiBAcGFyYW0ge0FyY05vZGV9IGZpcnN0QXJjXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZWdyZWVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmaXJzdEFyYyA9IG51bGwsIGluZGVncmVlID0gMCl7XHJcbiAgICAgICAgLy8g6aG254K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvLyDmjIflkJHnrKzkuIDmnaHkvp3pmYTor6XpobbngrnnmoTlvKfnmoTmjIfpkohcclxuICAgICAgICB0aGlzLmZpcnN0QXJjID0gZmlyc3RBcmM7XHJcbiAgICAgICAgLy8gIOmhtueCueeahOW6piwg5pyJ5ZCR5Zu+5piv5YWl5bqm5oiW5Ye65bqm5oiW5rKh5pyJXHJcbiAgICAgICAgdGhpcy5pbmRlZ3JlZSA9IGluZGVncmVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGphY2VuY3lMaXN0R3JhcGgge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheSB8IFZleE5vZGV9IHZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmV4bnVtXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJjbnVtXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2luZFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzID0gW10sIHZleG51bSA9IDAsIGFyY251bSA9IDAsIGtpbmQgPSBERyl7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgIC8vIOWbvueahOW9k+WJjemhtueCueaVsOWSjOW8p+aVsFxyXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xyXG4gICAgICAgIHRoaXMuYXJjbnVtID0gYXJjbnVtO1xyXG4gICAgICAgIC8vIOWbvueahOenjeexu+agh+W/l1xyXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5p+l5om+6aG254K55L2N572uXHJcbiAgICBsb2NhdGVWZXgodnApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uZGF0YSA9PT0gdnApIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOa3u+WKoOmhtueCuVxyXG4gICAgYWRkVmVydGV4KHZwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG9jYXRlVmV4KHZwKSAhPT0gLTEpIHRocm93IG5ldyBFcnJvcignVmVydGV4IGhhcyBleGlzdGVkIScpO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmV4bnVtKytdID0gbmV3IFZleE5vZGUodnAsIG51bGwsIDApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZleG51bTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOW8p1xyXG4gICAgICog5aaC5p6c5piv5peg5ZCR5Zu+5oiW6ICF5peg5ZCR572RLGFyYzHlkoxhcmMy5peg6aG65bqP6KaB5rGCXHJcbiAgICAgKiDlpoLmnpzmmK/mnInlkJHlm77miJbogIXmnInlkJHnvZHvvIzlj6rkvJrmt7vliqBhcmMx77yM5Zug5q2k5q2j6YK75o6l6KGo5ZKM6YCG6YK75o6l6KGo55qE6aG65bqP6ZyA6KaB5rOo5oSPXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJjMVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyYzJcclxuICAgICAqIEBwYXJhbSB7Kn0gaW5mb1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGFkZEFyYyhhcmMxLCBhcmMyLCBpbmZvKSB7XHJcbiAgICAgICAgbGV0IGsgPSB0aGlzLmxvY2F0ZVZleChhcmMxKTtcclxuICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KGFyYzIpO1xyXG5cclxuICAgICAgICBpZiAoayA9PT0gLTEgfHwgaiA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XHJcblxyXG4gICAgICAgIC8vIOi+ueeahOi1t+Wni+ihqOe7k+eCuei1i+WAvFxyXG4gICAgICAgIGxldCBwID0gbmV3IEFyY05vZGUoaywgbnVsbCwgaW5mbyk7XHJcbiAgICAgICAgLy8g6L6555qE5pyr5bC+6KGo57uT54K56LWL5YC8XHJcbiAgICAgICAgbGV0IHEgPSBuZXcgQXJjTm9kZShqLCBudWxsLCBpbmZvKTtcclxuXHJcbiAgICAgICAgLy8g5piv5peg5ZCR5Zu+77yM55So5aS05o+S5YWl5rOV5o+S5YWl5Yiw5Lik5Liq5Y2V6ZO+6KGoXHJcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gVURHIHx8IHRoaXMua2luZCA9PT0gVUROKSB7XHJcbiAgICAgICAgICAgIHEubmV4dEFyYyA9IHRoaXMudmVydGljZXNba10uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNba10uZmlyc3RBcmMgPSBxO1xyXG4gICAgICAgICAgICBwLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjID0gcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5bu656uL5pyJ5ZCR5Zu+55qE6YK75o6l6ZO+6KGo77yM55So5aS05o+S5YWl5rOVXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAubmV4dEFyYyA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbal0uZmlyc3RBcmMgPSBwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgKyt0aGlzLmFyY251bTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyDlhbbku5blm77nsbvlnovnmoTliJvlu7rmmoLml7bmsqHlvIRcclxuICAgIGNyZWF0ZUdyYXBoKCkge1xyXG4gICAgICAgIHRoaXMudmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcclxuICAgICAgICB0aGlzLmFyY251bSA9ICtwcm9tcHQoJ2FyY251bTogJyk7XHJcbiAgICAgICAgLy8gaW5jSW5mb+S4ujDliJnlkITlvKfkuI3lkKvlhbbku5bkv6Hmga9cclxuICAgICAgICBsZXQgaW5jSW5mbyA9ICtwcm9tcHQoJ2luY0luZm86ICcpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttXSA9IG5ldyBWZXhOb2RlKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbV0uZGF0YSA9IHByb21wdCgndmVydGV4OiAnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobSA9IDA7IG0gPCB0aGlzLmFyY251bTsgKyttKSB7XHJcbiAgICAgICAgICAgIGxldCBoID0gcHJvbXB0KCflvKflpLQ6ICcpO1xyXG4gICAgICAgICAgICBsZXQgdCA9IHByb21wdCgn5byn5bC+OiAnKTtcclxuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmxvY2F0ZVZleCh0KTtcclxuICAgICAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleChoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ+mhtueCueS4uuaJvuWIsO+8jOivt+mHjeaWsOi+k+WFpe+8gScpO1xyXG4gICAgICAgICAgICAgICAgbS0tO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBwID0gbmV3IEFyY05vZGUoaiwgbnVsbCwgaW5jSW5mbyAmJiBwcm9tcHQoJ2luZm86ICcpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYykgdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYyA9IHA7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcSA9IHRoaXMudmVydGljZXNbaV0uZmlyc3RBcmM7IHEubmV4dEFyYzsgcSA9IHEubmV4dEFyYyk7XHJcbiAgICAgICAgICAgICAgICBxLm5leHRBcmMgPSBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreS4gOS4qumCu+aOpeihqOWtmOWCqOeahOacieWQkeWbvuaYr+WQpuWPr+S8oOmAklxyXG4gICAgaXNQYXNzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmtpbmQgIT09IERHKSB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBoIGtpbmQgc2hvdWxkIGJlIERHJyk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52ZXhudW07ICsreCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1t4XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHEgPSB0aGlzLnZlcnRpY2VzW3ldLmZpcnN0QXJjOyBxOyBxID0gcS5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHogPSBxLmFkalZleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeiAhPT0geCAmJiB0aGlzLmlzQWRqKHgsIHopKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreacieWQkeWbvuaYr+WQpuWtmOWcqOi+uShtLG4pXHJcbiAgICBpc0FkaihtLCBuKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbbV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgaWYgKHAuYWRqVmV4ID09PSBuKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rex5bqm5LyY5YWI5Yik5patPGI+5pyJ5ZCR5Zu+PGI+55qE6aG254K5aeWIsOmhtueCuWrmmK/lkKbmnInot6/lvoTvvIzlrp7liJnov5Tlm550cnVl77yM5ZCm5YiZ6L+U5ZueZmFsc2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxyXG4gICAgICovXHJcbiAgICBleGlzdF9wYXRoX0RGUyhpLCBqKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBpID0gdGhpcy5sb2NhdGVWZXgoaSk7XHJcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xyXG5cclxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHRocm93IG5ldyBFcnJvcigndmVydGV4IG5vdCBmb3VuZCEnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV4aXN0X3BhdGgodGhpcywgaSwgaik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGV4aXN0X3BhdGgoZ3JhcGgsIGksIGopIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGopIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtrXSAmJiBleGlzdF9wYXRoKGdyYXBoLCBrLCBqKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlub/luqbkvJjlhYjliKTmlq08Yj7mnInlkJHlm748Yj7nmoTpobbngrlp5Yiw6aG254K5auaYr+WQpuaciei3r+W+hO+8jOWunuWImei/lOWbnnRydWXvvIzlkKbliJnov5Tlm55mYWxzZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqXHJcbiAgICAgKi9cclxuICAgIGV4aXN0X3BhdGhfQkZTKGksIGopIHtcclxuICAgICAgICBpID0gdGhpcy5sb2NhdGVWZXgoaSk7XHJcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgbGV0IHUgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdV0gPSAxO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gaikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRba10pIHF1ZXVlLmVuUXVldWUoayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWremCu+aOpeihqOaWueW8j+WtmOWCqOeahOacieWQkeWbvueahOmhtueCuWnliLBq5piv5ZCm5a2Y5Zyo6ZW/5bqm5Li6a+eahOeugOWNlei3r+W+hFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xyXG4gICAgICovXHJcbiAgICBleGlzdF9wYXRoX2xlbihpLCBqLCBrKSB7XHJcbiAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KGkpO1xyXG4gICAgICAgIGogPSB0aGlzLmxvY2F0ZVZleChqKTtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG5cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIHJlY3Vyc2UoZ3JhcGgsIGksIGosIGspIHtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5LqG5LiA5p2h6Lev5b6E77yM5LiU6ZW/5bqm56ym5ZCIXHJcbiAgICAgICAgICAgIGlmIChpID09PSBqICYmIGsgPT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChrID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtsXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDliankvZnot6/lvoTplb/luqblh4/kuIBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UoZ3JhcGgsIGwsIGosIGsgLSAxKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g5YWB6K645pu+57uP6KKr6K6/6Zeu6L+H55qE57uT54K55Ye6546w5Zyo5Y+m5LiA5p2h6Lev5b6E5LiKXHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pKHRoaXMsIGksIGosIGspO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rGC5pyJ5ZCR5Zu+5Lit6aG254K5deWIsHbkuYvpl7TnmoTmiYDmnInnroDljZXot6/lvoTvvIxr5Li65b2T5YmN6Lev5b6E6ZW/5bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBncmFwaC5maW5kX2FsbF9wYXRoKCd2MScsICd2MicsIDApO1xyXG4gICAgICovXHJcbiAgICBmaW5kX2FsbF9wYXRoKHUsIHYsIGspIHtcclxuICAgICAgICB1ID0gdGhpcy5sb2NhdGVWZXgodSk7XHJcbiAgICAgICAgdiA9IHRoaXMubG9jYXRlVmV4KHYpO1xyXG4gICAgICAgIGxldCBwYXRoID0gW107XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuXHJcbiAgICAgICAgZmluZFBhdGgodGhpcywgdSwgdiwgayk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRQYXRoKGdyYXBoLCB1LCB2LCBrKSB7XHJcbiAgICAgICAgICAgIC8vIOWKoOWFpeW9k+WJjei3r+W+hOS4rVxyXG4gICAgICAgICAgICBwYXRoW2tdID0gdTtcclxuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDE7XHJcblxyXG4gICAgICAgICAgICAvLyDmib7liLDkuIDmnaHnroDljZXot6/lvoRcclxuICAgICAgICAgICAgaWYgKHUgPT09IHYpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBvbmUgcGF0aCEnKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBwYXRoW2ldOyArK2kpIGNvbnNvbGUubG9nKHBhdGhbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW3VdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDnu6fnu63lr7vmib5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbF0pIGZpbmRQYXRoKGdyYXBoLCBsLCB2LCBrICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdV0gPSAwO1xyXG4gICAgICAgICAgICAvLyDlm57muq9cclxuICAgICAgICAgICAgcGF0aFtrXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rGC5pyJ5ZCR5Zu+55qE6aG254K55LmL6Ze06ZW/5bqm5Li6bGVu55qE566A5Y2V6Lev5b6E5p2h5pWwXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5cclxuICAgICAqL1xyXG4gICAgZ2V0UGF0aE51bV9sZW4oaSwgaiwgbGVuKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiByZWN1cnNlKGdyYXBoLCBpLCBqLCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGogJiYgbGVuID09PSAwKSByZXR1cm4gMTtcclxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSBzdW0gKz0gcmVjdXJzZShsLCBqLCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKHRoaXMsIGksIGosIGxlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmsYLmnInlkJHml6Dnjq/lm77nmoTmoLlcclxuICAgICAqL1xyXG4gICAgZ2V0Um9vdCgpe1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIOavj+asoemDveimgeWwhuiuv+mXruaVsOe7hOa4hembtlxyXG4gICAgICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHZpc2l0ZWRbd10gPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8g5LuO6aG254K5aeWHuuWPkei/m+ihjOa3seW6puS8mOWFiOmBjeWOhlxyXG4gICAgICAgICAgICBkZnModGhpcywgaSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvcih3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpe1xyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6caeaYr+ague+8jOWImea3seW6puS8mOWFiOmBjeWOhuWPr+S7peiuv+mXruWIsOaJgOaciee7k+eCuVxyXG4gICAgICAgICAgICAgICAgaWYoIXZpc2l0ZWRbd10pIGZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZmxhZykgY29uc29sZS5sb2coJ0ZvdW5kIGEgcm9vdCB2ZXJ0ZXg6ICVkJywgaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHYpe1xyXG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW3ZdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKXtcclxuICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZighdmlzaXRlZFt3XSkgZGZzKGdyYXBoLCB3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaxguS4gOS4quacieWQkeaXoOeOr+WbvuS4reacgOmVv+eahOi3r+W+hFxyXG4gICAgICovXHJcbiAgICBnZXRMb25nZXN0UGF0aCgpe1xyXG4gICAgICAgIGxldCBtbHAgPSBbXTtcclxuICAgICAgICBsZXQgcGF0aCA9IFtdO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IG1heExlbiA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuY291bnRJbmRlZ3JlZSgpO1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZpc2l0ZWRbal0gPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8g5LuO5q+P5LiA5Liq6Zu25YWl5bqm57uT54K55byA5aeL5rex5bqm5LyY5YWI6YGN5Y6GXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2VzW2ldLmluZGVncmVlID09PSAwKSBkZnModGhpcywgaSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnTG9uZ2VzdCBQYXRoOicpO1xyXG4gICAgICAgIC8vIOi+k+WHuuacgOmVv+i3r+W+hFxyXG4gICAgICAgIGZvcihpID0gMDsgbWxwW2ldOyArK2kpIGNvbnNvbGUubG9nKG1scC5qb2luKCcsJykpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIGksIGxlbil7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBwYXRoW2xlbl0gPSBpO1xyXG5cclxuICAgICAgICAgICAgLy8g5paw55qE5pyA6ZW/6Lev5b6EXHJcbiAgICAgICAgICAgIGlmKGxlbiA+IG1heExlbiAmJiAhZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmMpIHtcclxuICAgICAgICAgICAgICAgIC8vIOS/neWtmOS4i+adpVxyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8PSBsZW47ICsraikgbWxwW2pdID0gcGF0aFtqXTtcclxuICAgICAgICAgICAgICAgIG1heExlbiA9IGxlbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCF2aXNpdGVkW3ddKSBkZnMoZ3JhcGgsIHcsIGxlbiArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXRoW2ldID0gMDtcclxuICAgICAgICAgICAgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDpgrvmjqXooajnmoTpgJLlvZLlvI/mt7HluqbkvJjlhYjpgY3ljoZcclxuICAgIERGU1RyYXZlcnNlKHZpc2l0Rm4pIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnModGhpcywgaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHYpIHtcclxuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChncmFwaCwgdik7XHJcblxyXG4gICAgICAgICAgICBsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW3ZdLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuYWRqVmV4XSkgZGZzKGdyYXBoLCBwLmFkalZleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDpgrvmjqXooajnmoTpnZ7pgJLlvZLmt7HluqbkvJjlhYjmkJzntKJcclxuICAgIERGU1RyYXZlcnNlX05vblJlY3Vyc2UodmlzaXRGbikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdjtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodiA9IHN0YWNrLnBlZWsoKSkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1t2XS5maXJzdEFyYztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW3AuYWRqVmV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgcC5hZGpWZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwLmFkalZleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzdGFjay5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDpgrvmjqXooajnmoTlub/luqbkvJjlhYjmkJzntKJcclxuICAgIEJGU1RyYXZlcnNlKHZpc2l0Rm4pIHtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKGkpO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXMudmVydGljZXNbd10uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuYWRqVmV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIHAuYWRqVmV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5hZGpWZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDlu7rnq4vml6DlkJHlm77nmoTmt7HluqbkvJjlhYjnlJ/miJDmo67mnpfnmoTlranlrZDlhYTlvJ/pk77ooajmoJFcclxuICAgIGNyZWF0ZURGU0ZvcmVzdCgpIHtcclxuICAgICAgICBsZXQgdHJlZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IHE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgLy8g5paw55qE55Sf5oiQ5qCR55qE5qC557uT54K5XHJcbiAgICAgICAgICAgICAgICBsZXQgcCA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKHRoaXMudmVydGljZXNbaV0uZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5qO155Sf5oiQ5qCR55qE5qC5XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyZWUpIHRyZWUgPSBwO1xyXG4gICAgICAgICAgICAgICAgLy8g5YW25a6D55Sf5oiQ5qCR55qE5qC5XHJcbiAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHHkuLrlvZPliY3nlJ/miJDmoJHnmoTmoLlcclxuICAgICAgICAgICAgICAgIHEgPSBwO1xyXG4gICAgICAgICAgICAgICAgLy8g5bu656uL5LulcOS4uuagueeahOeUn+aIkOagkVxyXG4gICAgICAgICAgICAgICAgREZTVHJlZSh0aGlzLCBpLCBwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcblxyXG4gICAgICAgIC8vIOS7peesrHbkuKrpobbngrnop6blj5Hmt7HluqbkvJjlhYjpgY3ljoblm77vvIzlu7rnq4vku6V0cmVl5Li65qC555qE55Sf5oiQ5qCRXHJcbiAgICAgICAgZnVuY3Rpb24gREZTVHJlZShncmFwaCwgdiwgdHJlZSkge1xyXG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGV0IHcgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcclxuICAgICAgICAgICAgbGV0IHE7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAodykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3cuYWRqVmV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbdy5hZGpWZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKGdyYXBoLnZlcnRpY2VzW3cuYWRqVmV4XS5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd+aYr3bnmoTnrKzkuIDkuKrmnKrooqvorr/pl67nmoTpgrvmjqXnu5PngrlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZS5maXJzdENoaWxkID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd+aYr3bnmoTlhbblroPmnKrooqvorr/pl67nmoTpgrvmjqXpobbngrlcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBxID0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgREZTVHJlZShncmFwaCwgdy5hZGpWZXgsIHEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHcgPSB3Lm5leHRBcmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQkZTRm9yZXN0KCkge1xyXG4gICAgICAgIGxldCB0cmVlID0gbnVsbDtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgQ2hpbGRTaWJsaW5nVHJlZSh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgcS5uZXh0U2libGluZyA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgcSA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXMudmVydGljZXNbd10uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW3AuYWRqVmV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAuYWRqVmV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZTIgPSBuZXcgQ2hpbGRTaWJsaW5nVHJlZSh0aGlzLnZlcnRpY2VzW3AuYWRqVmV4XS5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmZpcnN0Q2hpbGQgPSBub2RlMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBwcmUubmV4dFNpYmxpbmcgPSBub2RlMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBub2RlMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9XHJcblxyXG4gICAgZmluZEFydGljdWwoKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgY291bnQgPSAxO1xyXG4gICAgICAgIGxldCBsb3cgPSBbXTtcclxuICAgICAgICBsb3dbMF0gPSBjb3VudDtcclxuICAgICAgICB2aXNpdGVkWzBdID0gMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSAwO1xyXG4gICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1swXS5maXJzdEFyYztcclxuICAgICAgICBsZXQgdiA9IHAuYWRqVmV4O1xyXG5cclxuICAgICAgICBERlNBcnRpY3VsKHRoaXMsIHYpO1xyXG4gICAgICAgIGlmIChjb3VudCA8IHRoaXMudmV4bnVtKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKDAgKyAnICAnICsgdGhpcy52ZXJ0aWNlc1swXS5kYXRhKTtcclxuICAgICAgICAgICAgd2hpbGUgKHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcclxuICAgICAgICAgICAgICAgIHYgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW3ZdID09PSAwKSBERlNBcnRpY3VsKHRoaXMsIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBERlNBcnRpY3VsKGdyYXBoLCB2MCkge1xyXG4gICAgICAgICAgICBsZXQgbWluID0gdmlzaXRlZFt2MF0gPSArK2NvdW50O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbdjBdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdyA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbd10gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBERlNBcnRpY3VsKGdyYXBoLCB3KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG93W3ddIDwgbWluKSBtaW4gPSBsb3dbd107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd1t3XSA+PSB2aXNpdGVkW3YwXSkgY29uc29sZS5sb2codjAgKyAnICAnICsgZ3JhcGgudmVydGljZXNbdjBdLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddIDwgbWluKSBtaW4gPSB2aXNpdGVkW3ddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvd1t2MF0gPSBtaW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOe7n+iuoeWQhOmhtueCueWFpeW6pueahOWHveaVsFxyXG4gICAgY291bnRJbmRlZ3JlZSgpIHtcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMudmV4bnVtOyArK2spIHRoaXMudmVydGljZXNba10uaW5kZWdyZWUgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMudmV4bnVtOyArK2spIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNba10uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpXHJcbiAgICAgICAgICAgICAgICArK3RoaXMudmVydGljZXNbcC5hZGpWZXhdLmluZGVncmVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbi8vIOaLk+aJkeaOkuW6j+eul+azlVxyXG4gICAgdG9wb2xvZ2ljU29ydCgpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICB0aGlzLnRvcG9sb2dpY2FsT3JkZXIgPSBbXTtcclxuICAgICAgICB0aGlzLmNvdW50SW5kZWdyZWUoKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2VzW2ldLmluZGVncmVlID09PSAwKSBzdGFjay5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBpID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMudG9wb2xvZ2ljYWxPcmRlci5wdXNoKGkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xyXG4gICAgICAgICAgICArK2NvdW50O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICgtLXRoaXMudmVydGljZXNba10uaW5kZWdyZWUgPT09IDApIHN0YWNrLnB1c2goayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoY291bnQgPj0gdGhpcy52ZXhudW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOi+k+WHuuacieWQkeWbvueahOWQhOmhueWFs+mUrua0u+WKqFxyXG4gICAgY3JpdGljYWxQYXRoKCkge1xyXG4gICAgICAgIGlmICghdGhpcy50b3BvbG9naWNTb3J0KCkpIHRocm93IG5ldyBFcnJvcignQU9F572R5Lit5a2Y5Zyo5Zue6Lev77yBJyk7XHJcblxyXG4gICAgICAgIGxldCB2ZSA9IFtdO1xyXG4gICAgICAgIC8vIOS6i+S7tuacgOaXqeWPkeeUn+aXtumXtOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikgdmVbal0gPSAwO1xyXG4gICAgICAgIC8vIOiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZl5YC8XHJcbiAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCB0aGlzLnZleG51bTsgKyttKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gdGhpcy50b3BvbG9naWNhbE9yZGVyW21dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICh2ZVtqXSArIHAuaW5mbyA+IHZlW2tdKSB2ZVtrXSA9IHZlW2pdICsgcC5pbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2bCA9IFtdO1xyXG4gICAgICAgIC8vIOS6i+S7tuacgOaZmuWPkeeUn+aXtumXtOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikgdmxbal0gPSB2ZVt0aGlzLnZleG51bSAtIDFdO1xyXG4gICAgICAgIC8vIOiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtHZs55qE5YC8XHJcbiAgICAgICAgZm9yIChsZXQgbSA9IHRoaXMudmV4bnVtIC0gMTsgbSA+PSAwOyAtLW0pIHtcclxuICAgICAgICAgICAgbGV0IGogPSB0aGlzLnRvcG9sb2dpY2FsT3JkZXJbbV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZsW2tdIC0gcC5pbmZvIDwgdmxbal0pIHZsW2pdID0gdmxba10gLSBwLmluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6L6T5Ye65omA5pyJ5YWz6ZSu5rS75YqoXHJcbiAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCB0aGlzLnZleG51bTsgKyttKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW21dLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZlW21dICsgcC5pbmZvID09PSB2bFtrXSkgY29uc29sZS5sb2coJzwlZCwgJWQ+JywgbSwgayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2hvcnRlc3RQYXRoX0RpamtzdHJhKHYwKSB7XHJcbiAgICAgICAgbGV0IGRpc3QgPSBbXTtcclxuICAgICAgICBsZXQgcHJlID0gW107XHJcbiAgICAgICAgbGV0IGZpbmFsID0gW107XHJcbiAgICAgICAgbGV0IHc7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdilcclxuICAgICAgICAgICAgZGlzdFt2XSA9IEluZmluaXR5O1xyXG4gICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW3YwXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYylcclxuICAgICAgICAgICAgZGlzdFtwLmFkalZleF0gPSBwLmluZm87XHJcblxyXG4gICAgICAgIGxldCB2O1xyXG4gICAgICAgIGZvciAodiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XHJcbiAgICAgICAgICAgIGZpbmFsW3ZdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHByZVt2XSA9IHByZVt2XSB8fCBbXTtcclxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHByZVt2XVt3XSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRpc3Rbdl0gPCBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgcHJlW3ZdW3YwXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcmVbdl1bdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXN0W3YwXSA9IDA7XHJcbiAgICAgICAgZmluYWxbdjBdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgZGlzdFt3XSA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRpc3Rbd107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpbmFsW3ZdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW3ZdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICB3ID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmFsW3ddICYmIG1pbiArIHAuaW5mbyA8IGRpc3Rbd10pIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0W3ddID0gbWluICsgcC5pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcclxuICAgICAgICAgICAgICAgICAgICBwcmVbd11bd10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhmaW5hbCk7XHJcbiAgICAgICAgY29uc29sZS5sb2cocHJlKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhkaXN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmluYWw6IGZpbmFsLFxyXG4gICAgICAgICAgICBwcmU6IHByZSxcclxuICAgICAgICAgICAgZGlzdDogZGlzdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vLyDml6DlkJHlm77nmoTpgrvmjqXooahcclxudmFyIGFkakxpc3RHcmFwaCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIFVERyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MScsICd2MicpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MScsICd2MycpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MScsICd2NCcpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MicsICd2MycpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2NCcpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2NScpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2NCcsICd2NScpO1xyXG5cclxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoKTtcclxuXHJcbi8vIOacieWQkeWbvueahOmAhumCu+aOpeihqFxyXG52YXIgZyA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcclxuZy5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmcuYWRkVmVydGV4KCd2MicpO1xyXG5nLmFkZFZlcnRleCgndjMnKTtcclxuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmcuYWRkVmVydGV4KCd2NScpO1xyXG5cclxuZy5hZGRBcmMoJ3YxJywgJ3YyJyk7XHJcbmcuYWRkQXJjKCd2MScsICd2NCcpO1xyXG5nLmFkZEFyYygndjMnLCAndjInKTtcclxuZy5hZGRBcmMoJ3YzJywgJ3YxJyk7XHJcbmcuYWRkQXJjKCd2NCcsICd2MycpO1xyXG5nLmFkZEFyYygndjMnLCAndjUnKTtcclxuZy5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XHJcblxyXG5jb25zb2xlLmxvZyhnKTtcclxuXHJcbi8vIOacieWQkeWbvueahOato+mCu+aOpeihqFxyXG52YXIgZyA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcclxuZy5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmcuYWRkVmVydGV4KCd2MicpO1xyXG5nLmFkZFZlcnRleCgndjMnKTtcclxuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmcuYWRkVmVydGV4KCd2NScpO1xyXG5cclxuZy5hZGRBcmMoJ3YyJywgJ3YxJyk7XHJcbmcuYWRkQXJjKCd2NCcsICd2MScpO1xyXG5nLmFkZEFyYygndjInLCAndjMnKTtcclxuZy5hZGRBcmMoJ3YxJywgJ3YzJyk7XHJcbmcuYWRkQXJjKCd2MycsICd2NCcpO1xyXG5nLmFkZEFyYygndjUnLCAndjMnKTtcclxuZy5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XHJcblxyXG5jb25zb2xlLmxvZyhnKTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggREZTVHJhdmVyc2U6ICcpO1xyXG52YXIgYWRqTGlzdEdyYXBoID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgVURHKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjEnKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjInKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjMnKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjQnKTtcclxuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3YyJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YyJywgJ3YxJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3YxJyk7XHJcblxyXG5hZGpMaXN0R3JhcGguREZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIERGU1RyYXZlcnNlX05vblJlY3Vyc2U6ICcpO1xyXG5hZGpMaXN0R3JhcGguREZTVHJhdmVyc2VfTm9uUmVjdXJzZShmdW5jdGlvbiAodikge1xyXG4gICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1t2XS5kYXRhKTtcclxufSk7XHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggQkZTVHJhdmVyc2U6ICcpO1xyXG52YXIgZzIgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XHJcbmcyLmFkZFZlcnRleCgndjEnKTtcclxuZzIuYWRkVmVydGV4KCd2MicpO1xyXG5nMi5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmcyLmFkZFZlcnRleCgndjQnKTtcclxuZzIuYWRkVmVydGV4KCd2NScpO1xyXG5cclxuZzIuYWRkQXJjKCd2NCcsICd2MScpO1xyXG5nMi5hZGRBcmMoJ3YyJywgJ3YxJyk7XHJcbmcyLmFkZEFyYygndjUnLCAndjMnKTtcclxuZzIuYWRkQXJjKCd2MicsICd2MycpO1xyXG5nMi5hZGRBcmMoJ3YxJywgJ3YzJyk7XHJcbmcyLmFkZEFyYygndjMnLCAndjQnKTtcclxuZzIuYWRkQXJjKCd2NCcsICd2NScpO1xyXG5cclxuZzIuQkZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XHJcbn0pO1xyXG5cclxuY29uc29sZS5sb2coJ0RGUzogZXhwZWN0IGZhbHNlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0X3BhdGhfREZTKCd2MScsICd2NCcpKTtcclxuY29uc29sZS5sb2coJ0RGUzogZXhwZWN0IHRydWU6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RfcGF0aF9ERlMoJ3YxJywgJ3YyJykpO1xyXG5cclxuY29uc29sZS5sb2coJ0JGUyA6IGV4cGVjdCBmYWxzZTogJyArIGFkakxpc3RHcmFwaC5leGlzdF9wYXRoX0JGUygndjEnLCAndjQnKSk7XHJcbmNvbnNvbGUubG9nKCdCRlMgOmV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0X3BhdGhfQkZTKCd2MScsICd2MicpKTtcclxuXHJcblxyXG5cclxuLypcclxuIOWbvueahOi/numAmuaAp+mXrumimFxyXG5cclxuIOaXoOWQkeWbvueahOi/numAmuWIhumHj+S4jueUn+aIkOagkVxyXG5cclxuIDEg5peg5ZCR5Zu+55qE6L+e6YCa5YiG6YeP5ZKM55Sf5oiQ5qCRXHJcbiDlr7nkuo7ml6DlkJHlm77vvIzlr7nlhbbov5vooYzpgY3ljobml7bvvJpcclxuIOKXhiDoi6XmmK/ov57pgJrlm77vvJrku4XpnIDku47lm77kuK3ku7vkuIDpobbngrnlh7rlj5HvvIzlsLHog73orr/pl67lm77kuK3nmoTmiYDmnInpobbngrnvvJtcclxuIOKXhiDoi6XmmK/pnZ7ov57pgJrlm77vvJrpnIDku47lm77kuK3lpJrkuKrpobbngrnlh7rlj5HjgILmr4/mrKHku47kuIDkuKrmlrDpobbngrnlh7rlj5HmiYDorr/pl67nmoTpobbngrnpm4bluo/liJfmgbDlpb3mmK/lkITkuKrov57pgJrliIbph4/nmoTpobbngrnpm4bvvJtcclxuXHJcbiDikbQg6IulRz0oVixFKeaYr+aXoOWQkei/numAmuWbvu+8jCDpobbngrnpm4blkozovrnpm4bliIbliKvmmK9WKEcpIO+8jEUoRykg44CC6Iul5LuOR+S4reS7u+aEj+eCueWHuuWPkemBjeWOhuaXtu+8jCBFKEcp6KKr5YiG5oiQ5Lik5Liq5LqS5LiN55u45Lqk55qE6ZuG5ZCI77yaXHJcbiBUKEcpIO+8mumBjeWOhui/h+eoi+S4reaJgOe7j+i/h+eahOi+ueeahOmbhuWQiO+8m1xyXG4gQihHKSDvvJrpgY3ljobov4fnqIvkuK3mnKrnu4/ov4fnmoTovrnnmoTpm4blkIjvvJtcclxuIOaYvueEtu+8miBFKEcpPVQoRyniiKpCKEcpIO+8jFQoRyniiKlCKEcpPcOYXHJcbiDmmL7nhLbvvIzlm75H4oCZPShWLCBUKEcpKeaYr0fnmoTmnoHlsI/ov57pgJrlrZDlm77vvIzkuJRH4oCZ5piv5LiA5qO15qCR44CCR+KAmeensOS4uuWbvkfnmoTkuIDmo7XnlJ/miJDmoJHjgIJcclxuIOS7juS7u+aEj+eCueWHuuWPkeaMiURGU+eul+azleW+l+WIsOeUn+aIkOagkUfigJnnp7DkuLrmt7HluqbkvJjlhYjnlJ/miJDmoJHvvJvmjIlCRlPnrpfms5XlvpfliLDnmoRH4oCZ56ew5Li65bm/5bqm5LyY5YWI55Sf5oiQ5qCR44CCXHJcblxyXG4g4pG1ICDoi6VHPShWLEUp5piv5peg5ZCR6Z2e6L+e6YCa5Zu+77yM5a+55Zu+6L+b6KGM6YGN5Y6G5pe25b6X5Yiw6Iul5bmy5Liq6L+e6YCa5YiG6YeP55qE6aG254K56ZuG77yaVjEoRykgLFYyKEcpICzigKYsVm4oRynlkoznm7jlupTmiYDnu4/ov4fnmoTovrnpm4bvvJpUMShHKSAsVDIoRykgLCDigKYsVG4oRykg44CCXHJcbiDliJnlr7nlupTnmoTpobbngrnpm4blkozovrnpm4bnmoTkuozlhYPnu4TvvJpHaT0oVmkoRyksVGkoRykpXHJcbiAoMeKJpmniiaZuKeaYr+WvueW6lOWIhumHj+eahOeUn+aIkOagke+8jOaJgOaciei/meS6m+eUn+aIkOagkeaehOaIkOS6huWOn+adpemdnui/numAmuWbvueahOeUn+aIkOajruael+OAglxyXG5cclxuIOivtOaYju+8muW9k+e7meWumuaXoOWQkeWbvuimgeaxgueUu+WHuuWFtuWvueW6lOeahOeUn+aIkOagkeaIlueUn+aIkOajruael+aXtu+8jOW/hemhu+WFiOe7meWHuuebuOW6lOeahOmCu+aOpeihqO+8jOeEtuWQjuaJjeiDveagueaNrumCu+aOpeihqOeUu+WHuuWFtuWvueW6lOeahOeUn+aIkOagkeaIlueUn+aIkOajruael+OAglxyXG5cclxuXHJcbiAyICDlm77nmoTnlJ/miJDmoJHlkoznlJ/miJDmo67mnpfnrpfms5VcclxuXHJcbiDlr7nlm77nmoTmt7HluqbkvJjlhYjmkJzntKLpgY3ljoZERlMo5oiWQkZTKeeul+azleeojeS9nOS/ruaUue+8jOWwseWPr+W+l+WIsOaehOmAoOWbvueahERGU+eUn+aIkOagkeeul+azleOAglxyXG4g5Zyo566X5rOV5Lit77yM5qCR55qE5a2Y5YKo57uT5p6E6YeH55So5a2p5a2Q4oCU5YWE5byf6KGo56S65rOV44CC6aaW5YWI5bu656uL5LuO5p+Q5Liq6aG254K5VuWHuuWPke+8jOW7uueri+S4gOS4quagkee7k+eCue+8jOeEtuWQjuWGjeWIhuWIq+S7pVbnmoTpgrvmjqXngrnkuLrotbflp4vngrnvvIzlu7rnq4vnm7jlupTnmoTlrZDnlJ/miJDmoJHvvIzlubblsIblhbbkvZzkuLpWIOe7k+eCueeahOWtkOagkemTvuaOpeWIsFbnu5PngrnkuIrjgILmmL7nhLbvvIznrpfms5XmmK/kuIDkuKrpgJLlvZLnrpfms5XjgIJcclxuXHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZURGU0ZvcmVzdCgpKTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKGFkakxpc3RHcmFwaC5jcmVhdGVCRlNGb3Jlc3QoKSk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDlnKjmn5Dlm77kuK3vvIzoi6XliKDpmaTpobbngrlW5Lul5Y+KVuebuOWFs+eahOi+ueWQju+8jOWbvueahOS4gOS4qui/numAmuWIhumHj+WIhuWJsuS4uuS4pOS4quaIluS4pOS4quS7peS4iueahOi/numAmuWIhumHj++8jOWImeensOmhtueCuVbkuLror6Xlm77nmoTkuIDkuKrlhbPoioLngrnjgILkuIDkuKrmsqHmnInlhbPoioLngrnnmoTov57pgJrlm77np7DkuLrph43ov57pgJrlm77jgIJcclxuIOWcqOmHjei/numAmuWbvuS4re+8jOS7u+aEj+S4gOWvuemhtueCueS5i+mXtOiHs+WwkeWtmOWcqOS4pOadoei3r+W+hO+8jOWImeWGjeWIoOWOu+afkOS4qumhtueCueWNs+ebuOWFs+WQhOi+ueWQjuS5n+S4jeegtOWdj+WbvueahOi/numAmuaAp+OAguiLpeWcqOWbvueahOi/numAmuWbvuS4iuWIoOWOu2vkuKroioLngrnmiY3og73noLTlnY/lm77nmoTov57pgJrmgKfvvIzliJnnp7BL5Li65q2k5Zu+55qE6L+e6YCa5bqm44CCXHJcbiDku5bku6zluLjluLjlnKjpgJrkv6HnvZHnu5znmoTlm77miJboiKrnqbrnvZHkuK3lupTnlKjvvIxL6LaK5aSn77yM57O757uf6LaK56iz5a6a77yM5Y+N5LmL77yM5oiY5LqJ5Lit6Iul6KaB5pGn5q+B5pWM5pa555qE6L+Q6L6T57q/77yM5Y+q6aG756C05Z2P5YW26L+Q6L6T572R5Lit55qE5YWz6IqC54K55Y2z5Y+v44CCXHJcbiAqL1xyXG5cclxuXHJcblxyXG52YXIgYXJ0aWN1bFRlc3QgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBVREcpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0EnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdCJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnQycpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0QnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdFJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRicpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0cnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdIJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSScpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0onKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdLJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnTCcpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ00nKTtcclxuXHJcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdCJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdDJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdGJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdMJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnQycsICdCJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnRCcsICdCJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdCJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdCJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnTScsICdCJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnRCcsICdFJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdIJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdJJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdLJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdLJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnSicsICdMJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnSicsICdNJyk7XHJcbmFydGljdWxUZXN0LmFkZEFyYygnTCcsICdNJyk7XHJcblxyXG5hcnRpY3VsVGVzdC5maW5kQXJ0aWN1bCgpO1xyXG5cclxuXHJcbi8qXHJcbiDmnInlkJHml6Dnjq/lm77lj4rlhbblupTnlKhcclxuXHJcbiDmnInlkJHml6Dnjq/lm74oRGlyZWN0ZWQgQWN5Y2xpbmcgR3JhcGgp77ya5piv5Zu+5Lit5rKh5pyJ5Zue6LevKOeOrynnmoTmnInlkJHlm77jgILmmK/kuIDnsbvlhbfmnInku6PooajmgKfnmoTlm77vvIzkuLvopoHnlKjkuo7noJTnqbblt6XnqIvpobnnm67nmoTlt6Xluo/pl67popjjgIHlt6XnqIvml7bpl7Tov5vluqbpl67popjnrYnjgIJcclxuXHJcbiDkuIDkuKrlt6XnqIsocHJvamVjdCnpg73lj6/liIbkuLroi6XlubLkuKrnp7DkuLrmtLvliqgoYWN0aXZlKeeahOWtkOW3peeoiyjmiJblt6Xluo8p77yM5ZCE5Liq5a2Q5bel56iL5Y+X5Yiw5LiA5a6a55qE5p2h5Lu257qm5p2f77ya5p+Q5Liq5a2Q5bel56iL5b+F6aG75byA5aeL5LqO5Y+m5LiA5Liq5a2Q5bel56iL5a6M5oiQ5LmL5ZCO77yb5pW05Liq5bel56iL5pyJ5LiA5Liq5byA5aeL54K5KOi1t+eCuSnlkozkuIDkuKrnu4jngrnjgILkurrku6zlhbPlv4PvvJpcclxuIOKXhiDlt6XnqIvog73lkKbpobrliKnlrozmiJA/5b2x5ZON5bel56iL55qE5YWz6ZSu5rS75Yqo5piv5LuA5LmIP1xyXG4g4peGIOS8sOeul+aVtOS4quW3peeoi+WujOaIkOaJgOW/hemhu+eahOacgOefreaXtumXtOaYr+WkmuWwkT9cclxuXHJcbiDlr7nlt6XnqIvnmoTmtLvliqjliqDku6Xmir3osaHvvJrlm77kuK3pobbngrnooajnpLrmtLvliqjvvIzmnInlkJHovrnooajnpLrmtLvliqjkuYvpl7TnmoTkvJjlhYjlhbPns7vvvIzov5nmoLfnmoTmnInlkJHlm77np7DkuLrpobbngrnooajnpLrmtLvliqjnmoTnvZEoQWN0aXZpdHkgT24gVmVydGV4IE5ldHdvcmsg77yMQU9W572RKSDjgIJcclxuXHJcblxyXG4g5ouT5omR5o6S5bqPXHJcblxyXG4gMSDlrprkuYlcclxuIOaLk+aJkeaOkuW6jyhUb3BvbG9naWNhbCBTb3J0KSDvvJrnlLHmn5DkuKrpm4blkIjkuIrnmoTkuIDkuKrlgY/luo/lvpfliLDor6Xpm4blkIjkuIrnmoTkuIDkuKrlhajluo/nmoTmk43kvZzjgIJcclxuXHJcbiDil4Yg6ZuG5ZCI5LiK55qE5YWz57O777ya6ZuG5ZCIQeS4iueahOWFs+ezu+aYr+S7jkHliLBB55qE5YWz57O7KEHvgrRBKSDjgIJcclxuIOKXhiDlhbPns7vnmoToh6rlj43mgKfvvJroi6XvgKJh4oiIQeaciShh77yMYSniiIhS77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/oh6rlj43nmoTjgIJcclxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAglxyXG4g4peGIOWFs+ezu+eahOWvueensOaAp+S4juWPjeWvueensOaAp++8muWmguaenOWvueS6jmHvvIxi4oiIQSDvvIzlj6ropoHmnIkoYe+8jGIp4oiIUuWwseaciShi77yMYSniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5a+556ew55qE44CC5aaC5p6c5a+55LqOYe+8jGLiiIhBIO+8jOS7heW9k2E9YuaXtuaciShh77yMYiniiIhS5ZKMKGLvvIxhKeKIiFIg77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/lj43lr7nnp7DnmoTjgIJcclxuIOKXhiDlhbPns7vnmoTkvKDpgJLmgKfvvJroi6Vh77yMYu+8jGPiiIhB77yM6IulKGHvvIxiKeKIiFLvvIzlubbkuJQoYu+8jGMp4oiIUiDvvIzliJkoYe+8jGMp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+S8oOmAkueahOOAglxyXG4g4peGIOWBj+W6j++8muiLpembhuWQiEHkuIrnmoTlhbPns7tS5piv6Ieq5Y+N55qE77yM5Y+N5a+556ew55qE5ZKM5Lyg6YCS55qE77yM5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vjgIJcclxuIOKXhiDlhajluo/vvJrorr5S5piv6ZuG5ZCIQeS4iueahOWBj+W6j+WFs+ezu++8jO+AomHvvIxi4oiIQe+8jOW/heaciWFSYuaIlmJSYe+8jCDliJnnp7BS5piv6ZuG5ZCIQeS4iueahOWFqOW6j+WFs+ezu+OAglxyXG5cclxuIOWNs+WBj+W6j+aYr+aMh+mbhuWQiOS4reS7heaciemDqOWIhuWFg+e0oOS5i+mXtOWPr+S7peavlOi+g++8jOiAjOWFqOW6j+aYr+aMh+mbhuWQiOS4reS7u+aEj+S4pOS4quWFg+e0oOS5i+mXtOmDveWPr+S7peavlOi+g+OAglxyXG4g5ZyoQU9W572R5Lit77yM6Iul5pyJ5pyJ5ZCR6L65PGksIGo+77yM5YiZaeaYr2rnmoTnm7TmjqXliY3pqbHvvIxq5pivaeeahOebtOaOpeWQjue7p++8m+aOqOiAjOW5v+S5i++8jOiLpeS7jumhtueCuWnliLDpobbngrlq5pyJ5pyJ5ZCR6Lev5b6E77yM5YiZaeaYr2rnmoTliY3pqbHvvIxq5pivaeeahOWQjue7p+OAglxyXG4g5ZyoQU9W572R5Lit77yM5LiN6IO95pyJ546v77yM5ZCm5YiZ77yM5p+Q6aG55rS75Yqo6IO95ZCm6L+b6KGM5piv5Lul6Ieq6Lqr55qE5a6M5oiQ5L2c5Li65YmN5o+Q5p2h5Lu244CCXHJcbiDmo4Dmn6Xmlrnms5XvvJrlr7nmnInlkJHlm77nmoTpobbngrnov5vooYzmi5PmiZHmjpLluo/vvIzoi6XmiYDmnInpobbngrnpg73lnKjlhbbmi5PmiZHmnInluo/luo/liJfkuK3vvIzliJnml6Dnjq/jgIJcclxuIOacieWQkeWbvueahOaLk+aJkeaOkuW6j++8muaehOmAoEFPVue9keS4remhtueCueeahOS4gOS4quaLk+aJkee6v+aAp+W6j+WIlyh24oCZMSx24oCZMiwg4ouvLHbigJluKe+8jOS9v+W+l+ivpee6v+aAp+W6j+WIl+S4jeS7heS/neaMgeWOn+adpeacieWQkeWbvuS4remhtueCueS5i+mXtOeahOS8mOWFiOWFs+ezu++8jOiAjOS4lOWvueWOn+WbvuS4reayoeacieS8mOWFiOWFs+ezu+eahOmhtueCueS5i+mXtOS5n+W7uueri+S4gOenjSjkurrkuLrnmoQp5LyY5YWI5YWz57O744CCXHJcblxyXG4gMiDmi5PmiZHmjpLluo/nrpfms5VcclxuIOeul+azleaAneaDs1xyXG5cclxuIOKRoCDlnKhBT1bnvZHkuK3pgInmi6nkuIDkuKrmsqHmnInliY3pqbHnmoTpobbngrnkuJTovpPlh7rvvJtcclxuIOKRoSDlnKhBT1bnvZHkuK3liKDpmaTor6Xpobbngrnku6Xlj4rku47or6Xpobbngrnlh7rlj5HnmoQo5Lul6K+l6aG254K55Li65bC+55qE5bynKeaJgOacieacieWQkeW8pyjovrkpIO+8m1xyXG4g4pGiIOmHjeWkjeKRoOOAgeKRoe+8jOebtOWIsOWbvuS4reWFqOmDqOmhtueCuemDveW3sui+k+WHuijlm77kuK3ml6Dnjq8p5oiW5Zu+5Lit5LiN5a2Y5Zyo5peg5YmN6amx55qE6aG254K5KOWbvuS4reW/heacieeOrynjgIJcclxuXHJcbiAzICDnrpfms5Xlrp7njrDor7TmmI5cclxuIOKXhiDph4fnlKjmraPpgrvmjqXpk77kvZzkuLpBT1bnvZHnmoTlrZjlgqjnu5PmnoTvvJtcclxuIOKXhiDorr7nq4vloIbmoIjvvIznlKjmnaXmmoLlrZjlhaXluqbkuLow55qE6aG254K577ybXHJcbiDil4Yg5Yig6Zmk6aG254K55Lul5a6D5Li65bC+55qE5byn77ya5byn5aS06aG254K555qE5YWl5bqm5YePMeOAglxyXG5cclxuIOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08obitlKSDjgIJcclxuXHJcbiAqL1xyXG5cclxudmFyIHRvcG9sb2dpY1Rlc3QgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2MScpO1xyXG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjInKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2NCcpO1xyXG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjUnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3Y2Jyk7XHJcblxyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjInLCAndjEnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y0JywgJ3YxJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2MycsICd2MScpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjInLCAndjMnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y1JywgJ3YzJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NCcsICd2NicpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjQnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y1JywgJ3Y2Jyk7XHJcblxyXG5jb25zb2xlLmxvZygndG9wb2xvZ2ljU29ydDogJyk7XHJcbmNvbnNvbGUubG9nKHRvcG9sb2dpY1Rlc3QudG9wb2xvZ2ljU29ydCgpKTtcclxuXHJcblxyXG5cclxuLypcclxuIOWFs+mUrui3r+W+hChDcml0aWNhbCBQYXRoKVxyXG5cclxuIOS4jkFPVue9keebuOWvueW6lOeahOaYr0FPRShBY3Rpdml0eSBPbiBFZGdlKSDvvIzmmK/ovrnooajnpLrmtLvliqjnmoTmnInlkJHml6Dnjq/lm77vvIzlpoLlm743LTI05omA56S644CC5Zu+5Lit6aG254K56KGo56S65LqL5Lu2KEV2ZW50Ke+8jOavj+S4quS6i+S7tuihqOekuuWcqOWFtuWJjeeahOaJgOaciea0u+WKqOW3sue7j+WujOaIkO+8jOWFtuWQjueahOa0u+WKqOWPr+S7peW8gOWni++8m+W8p+ihqOekuua0u+WKqO+8jOW8p+S4iueahOadg+WAvOihqOekuuebuOW6lOa0u+WKqOaJgOmcgOeahOaXtumXtOaIlui0ueeUqOOAglxyXG5cclxuIDEg5LiOQU9F5pyJ5YWz55qE56CU56m26Zeu6aKYXHJcbiDil4Yg5a6M5oiQ5pW05Liq5bel56iL6Iez5bCR6ZyA6KaB5aSa5bCR5pe26Ze0P1xyXG4g4peGIOWTquS6m+a0u+WKqOaYr+W9seWTjeW3peeoi+i/m+W6pijotLnnlKgp55qE5YWz6ZSuP1xyXG4g5bel56iL5a6M5oiQ5pyA55+t5pe26Ze077ya5LuO6LW354K55Yiw57uI54K555qE5pyA6ZW/6Lev5b6E6ZW/5bqmKOi3r+W+hOS4iuWQhOa0u+WKqOaMgee7reaXtumXtOS5i+WSjCkg44CC6ZW/5bqm5pyA6ZW/55qE6Lev5b6E56ew5Li65YWz6ZSu6Lev5b6E77yM5YWz6ZSu6Lev5b6E5LiK55qE5rS75Yqo56ew5Li65YWz6ZSu5rS75Yqo44CC5YWz6ZSu5rS75Yqo5piv5b2x5ZON5pW05Liq5bel56iL55qE5YWz6ZSu44CCXHJcbiDorr52MOaYr+i1t+eCue+8jOS7jnYw5YiwdmnnmoTmnIDplb/ot6/lvoTplb/luqbnp7DkuLrkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtO+8jOWNs+aYr+S7pXZp5Li65bC+55qE5omA5pyJ5rS75Yqo55qE5pyA5pep5Y+R55Sf5pe26Ze044CCXHJcbiDoi6XmtLvliqhhaeaYr+W8pzxqLCBrPu+8jOaMgee7reaXtumXtOaYr2R1dCg8aiwgaz4p77yM6K6+77yaXHJcbiDil4YgZShpKe+8muihqOekuua0u+WKqGFp55qE5pyA5pep5byA5aeL5pe26Ze077ybXHJcbiDil4YgbChpKe+8muWcqOS4jeW9seWTjei/m+W6pueahOWJjeaPkOS4i++8jOihqOekuua0u+WKqGFp55qE5pyA5pma5byA5aeL5pe26Ze077ybIOWImWwoaSktZShpKeihqOekuua0u+WKqGFp55qE5pe26Ze05L2Z6YeP77yM6IulbChpKS1lKGkpPTDvvIzooajnpLrmtLvliqhhaeaYr+WFs+mUrua0u+WKqOOAglxyXG4g4peGIHZlKGkp77ya6KGo56S65LqL5Lu2dmnnmoTmnIDml6nlj5HnlJ/ml7bpl7TvvIzljbPku47otbfngrnliLDpobbngrl2aeeahOacgOmVv+i3r+W+hOmVv+W6pu+8m1xyXG4g4peGIHZsKGkp77ya6KGo56S65LqL5Lu2dmnnmoTmnIDmmZrlj5HnlJ/ml7bpl7TjgILliJnmnInku6XkuIvlhbPns7vvvJpcclxuIGUoaSk9dmUoailcclxuIGwoaSk9IHZsKGspLWR1dCg8aiwgaz4pXHJcbiAwICAgIGo9MO+8jOihqOekunZq5piv6LW354K5XHJcbiB2ZShqKT1cclxuIE1heHt2ZShpKStkdXQoPGksIGo+KXw8dmksIHZqPuaYr+e9keS4reeahOW8p31cclxuXHJcbiDlkKvkuYnmmK/vvJrmupDngrnkuovku7bnmoTmnIDml6nlj5HnlJ/ml7bpl7Torr7kuLow77yb6Zmk5rqQ54K55aSW77yM5Y+q5pyJ6L+b5YWl6aG254K5dmrnmoTmiYDmnInlvKfmiYDku6PooajnmoTmtLvliqjlhajpg6jnu5PmnZ/lkI7vvIzkuovku7Z2auaJjeiDveWPkeeUn+OAguWNs+WPquaciXZq55qE5omA5pyJ5YmN6amx5LqL5Lu2dmnnmoTmnIDml6nlj5HnlJ/ml7bpl7R2ZShpKeiuoeeul+WHuuadpeWQju+8jOaJjeiDveiuoeeul3ZlKGopIOOAglxyXG4g5pa55rOV5piv77ya5a+55omA5pyJ5LqL5Lu26L+b6KGM5ouT5omR5o6S5bqP77yM54S25ZCO5L6d5qyh5oyJ5ouT5omR6aG65bqP6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pep5Y+R55Sf5pe26Ze044CCXHJcbiB2ZShuLTEpICAgIGo9bi0x77yM6KGo56S6dmrmmK/nu4jngrlcclxuIHZsKGopPVxyXG4gTWlue3ZsKGspLWR1dCg8aiwgaz4pfDx2aiwgdms+5piv572R5Lit55qE5bynfVxyXG4g5ZCr5LmJ5piv77ya5Y+q5pyJdmrnmoTmiYDmnInlkI7nu6fkuovku7Z2a+eahOacgOaZmuWPkeeUn+aXtumXtHZsKGsp6K6h566X5Ye65p2l5ZCO77yM5omN6IO96K6h566Xdmwoaikg44CCXHJcbiDmlrnms5XmmK/vvJrmjInmi5PmiZHmjpLluo/nmoTpgIbpobrluo/vvIzkvp3mrKHorqHnrpfmr4/kuKrkuovku7bnmoTmnIDmmZrlj5HnlJ/ml7bpl7TjgIJcclxuXHJcblxyXG4gMiDmsYJBT0XkuK3lhbPplK7ot6/lvoTlkozlhbPplK7mtLvliqhcclxuIOKRtCDnrpfms5XmgJ3mg7NcclxuIOKRoCDliKnnlKjmi5PmiZHmjpLluo/msYLlh7pBT0XnvZHnmoTkuIDkuKrmi5PmiZHluo/liJfvvJtcclxuIOKRoSAg5LuO5ouT5omR5o6S5bqP55qE5bqP5YiX55qE56ys5LiA5Liq6aG254K5KOa6kOeCuSnlvIDlp4vvvIzmjInmi5PmiZHpobrluo/kvp3mrKHorqHnrpfmr4/kuKrkuovku7bnmoTmnIDml6nlj5HnlJ/ml7bpl7R2ZShpKSDvvJtcclxuIOKRoiAg5LuO5ouT5omR5o6S5bqP55qE5bqP5YiX55qE5pyA5ZCO5LiA5Liq6aG254K5KOaxh+eCuSnlvIDlp4vvvIzmjInpgIbmi5PmiZHpobrluo/kvp3mrKHorqHnrpfmr4/kuKrkuovku7bnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bChpKSDvvJtcclxuXHJcbiDorr5BT0XnvZHmnIlu5Liq5LqL5Lu277yMZeS4qua0u+WKqO+8jOWImeeul+azleeahOS4u+imgeaJp+ihjOaYr++8mlxyXG4g4peGIOi/m+ihjOaLk+aJkeaOkuW6j++8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcclxuIOKXhiDmsYLmr4/kuKrkuovku7bnmoR2ZeWAvOWSjHZs5YC877ya5pe26Ze05aSN5p2C5bqm5pivTyhuK2UpIO+8m1xyXG4g4peGIOagueaNrnZl5YC85ZKMdmzlgLzmib7lhbPplK7mtLvliqjvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg77ybXHJcbiDlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg44CCXHJcblxyXG4gKi9cclxuXHJcblxyXG52YXIgY3JpdGljYWxQYXRoVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YwJyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MScpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjInKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NCcpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjUnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y2Jyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NycpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjgnKTtcclxuXHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MScsICd2MCcsIDMpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjInLCAndjAnLCAxMCk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NCcsICd2MScsIDEzKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y0JywgJ3YyJywgMTIpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjMnLCAndjEnLCA5KTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y1JywgJ3YyJywgNyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NycsICd2NCcsIDYpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjcnLCAndjMnLCA0KTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y3JywgJ3Y1JywgMTEpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjYnLCAndjMnLCA4KTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y4JywgJ3Y3JywgNSk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2OCcsICd2NicsIDIpO1xyXG5cclxuY3JpdGljYWxQYXRoVGVzdC5jcml0aWNhbFBhdGgoKTtcclxuXHJcblxyXG5cclxuXHJcbnZhciBkaWpUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgW10sIDAsIDAsIEROKTtcclxuXHJcbmRpalRlc3QuYWRkVmVydGV4KCcwJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCcxJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCcyJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCczJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCc0Jyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCc1Jyk7XHJcblxyXG5kaWpUZXN0LmFkZEFyYygnMScsICcwJywgMjApO1xyXG5kaWpUZXN0LmFkZEFyYygnNCcsICcwJywgMTApO1xyXG5kaWpUZXN0LmFkZEFyYygnMicsICcwJywgNjApO1xyXG5kaWpUZXN0LmFkZEFyYygnNScsICcwJywgNjUpO1xyXG5kaWpUZXN0LmFkZEFyYygnMicsICcxJywgMzApO1xyXG5kaWpUZXN0LmFkZEFyYygnMycsICcyJywgNDApO1xyXG5kaWpUZXN0LmFkZEFyYygnMicsICc1JywgMTUpO1xyXG5kaWpUZXN0LmFkZEFyYygnNScsICc0JywgMjApO1xyXG5kaWpUZXN0LmFkZEFyYygnNCcsICczJywgMzUpO1xyXG5kaWpUZXN0LmFkZEFyYygnMycsICcxJywgNzApO1xyXG5cclxuZGlqVGVzdC5zaG9ydGVzdFBhdGhfRGlqa3N0cmEoMCk7XHJcblxyXG5cclxuKGZ1bmN0aW9uKCl7XHJcbiAgICAvKipcclxuICAgICAqIOi+k+WHuuacieWQkeaXoOeOr+WbvuW9ouW8j+ihqOekuueahOmAhuazouWFsOW8j1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBuaUJvTGFuX0RBRyhncmFwaCl7XHJcbiAgICAgICAgZ3JhcGguY291bnRJbmRlZ3JlZSgpO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBncmFwaC52ZXhudW07ICsraSl7XHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOacieWQkeaXoOeOr+WbvueahOaguVxyXG4gICAgICAgICAgICBpZihncmFwaC52ZXJ0aWNlc1tpXS5pbmRlZ3JlZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJpbnROaUJvTGFuKGdyYXBoLCBpKXtcclxuICAgICAgICBsZXQgYyA9IGdyYXBoLnZlcnRpY2VzW2ldLmRhdGE7XHJcbiAgICAgICAgbGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYztcclxuXHJcbiAgICAgICAgLy8g5a2Q6KGo6L6+5byPXHJcbiAgICAgICAgaWYocCkge1xyXG4gICAgICAgICAgICBwcmludE5pQm9MYW4oZ3JhcGgsIHAuYWRqVmV4KTtcclxuICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBwLm5leHRBcmMuYWRqVmV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGMgKyAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnu5nmnInlkJHml6Dnjq/lm77ooajnpLrnmoTooajovr7lvI/msYLlgLxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVfREFHKGdyYXBoKXtcclxuICAgICAgICBncmFwaC5jb3VudEluZGVncmVlKCk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGdyYXBoLnZleG51bTsgKytpKXtcclxuICAgICAgICAgICAgaWYoIWdyYXBoLnZlcnRpY2VzW2ldLmluZGVncmVlKSByZXR1cm4gZXZhbHVhdGVfaW1wKGdyYXBoLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVfaW1wKGcsIGkpe1xyXG4gICAgICAgIGlmKC9eXFxkKyQvLnRlc3QoZy52ZXJ0aWNlc1tpXS5kYXRhKSkgcmV0dXJuIGcudmVydGljZXNbaV0uZGF0YTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBnLnZlcnRpY2VzW2ldLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICBsZXQgdjEgPSBldmFsdWF0ZV9pbXAoZywgcC5hZGpWZXgpO1xyXG4gICAgICAgICAgICBsZXQgdjIgPSBldmFsdWF0ZV9pbXAoZywgcC5uZXh0QXJjLmFkalZleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGUodjEsIGcudmVydGljZXNbaV0uZGF0YSwgdjIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGUoYSwgb3BlcmF0aW9uLCBiKXtcclxuICAgICAgICAvLyDlgbfkuIDkuIvmh5IuLlxyXG4gICAgICAgIHJldHVybiBldmFsKGEgKyBvcGVyYXRpb24gKyBiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAoKDEgKyAyKSAqICgyICogKDMgKyA0KSkgKyAoMyArIDQpICogNSkgKiAoKDMgKyA0KSAqIDUpXHJcbiAgICBsZXQgZGFnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xyXG5cclxuICAgIGxldCBhMSA9IG5ldyBTdHJpbmcoJyonKTtcclxuICAgIGxldCBhMiA9IG5ldyBTdHJpbmcoJysnKTtcclxuICAgIGxldCBhMyA9IG5ldyBTdHJpbmcoJyonKTtcclxuICAgIGxldCBhNCA9IG5ldyBTdHJpbmcoJyonKTtcclxuICAgIGxldCBhNSA9IG5ldyBTdHJpbmcoJysnKTtcclxuICAgIGxldCBhNiA9IG5ldyBTdHJpbmcoJyonKTtcclxuICAgIGxldCBhNyA9IG5ldyBTdHJpbmcoJysnKTtcclxuXHJcbiAgICAvLyAxMlxyXG4gICAgZGFnLmFkZFZlcnRleChhMSk7XHJcbiAgICBkYWcuYWRkVmVydGV4KGEyKTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTMpO1xyXG4gICAgZGFnLmFkZFZlcnRleChhNCk7XHJcbiAgICBkYWcuYWRkVmVydGV4KGE1KTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTYpO1xyXG4gICAgZGFnLmFkZFZlcnRleChhNyk7XHJcbiAgICBkYWcuYWRkVmVydGV4KDEpO1xyXG4gICAgZGFnLmFkZFZlcnRleCgyKTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoMyk7XHJcbiAgICBkYWcuYWRkVmVydGV4KDQpO1xyXG4gICAgZGFnLmFkZFZlcnRleCg1KTtcclxuXHJcbiAgICAvLyAxNFxyXG4gICAgZGFnLmFkZEFyYyhhMiwgYTEpO1xyXG4gICAgZGFnLmFkZEFyYyhhNCwgYTEpO1xyXG4gICAgZGFnLmFkZEFyYyhhMywgYTIpO1xyXG4gICAgZGFnLmFkZEFyYyhhNCwgYTIpO1xyXG4gICAgZGFnLmFkZEFyYyhhNSwgYTMpO1xyXG4gICAgZGFnLmFkZEFyYyhhNiwgYTMpO1xyXG4gICAgZGFnLmFkZEFyYyhhNywgYTYpO1xyXG4gICAgZGFnLmFkZEFyYyhhNywgYTQpO1xyXG4gICAgZGFnLmFkZEFyYyg1LCBhNCk7XHJcbiAgICBkYWcuYWRkQXJjKDEsIGE1KTtcclxuICAgIGRhZy5hZGRBcmMoMiwgYTUpO1xyXG4gICAgZGFnLmFkZEFyYygyLCBhNik7XHJcbiAgICBkYWcuYWRkQXJjKDMsIGE3KTtcclxuICAgIGRhZy5hZGRBcmMoNCwgYTcpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCduaUJvTGFuX0RBRzogJyk7XHJcbiAgICBuaUJvTGFuX0RBRyhkYWcpO1xyXG4gICAgY29uc29sZS5sb2coJ2V2YWx1YXRlX0RBRzogJyArIGV2YWx1YXRlX0RBRyhkYWcpKTsgIC8vIDI2OTVcclxufSkoKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoLmpzXG4gKiovIiwiLyogY3JlYXRlIGJ5IEx1a2UgKi9cclxuLyoqXHJcbiAqIOWbvihHcmFwaClcclxuICpcclxuICog5Zu+KEdyYXBoKeaYr+S4gOenjeavlOe6v+aAp+ihqOWSjOagkeabtOS4uuWkjeadgueahOaVsOaNrue7k+aehOOAglxyXG4gKlxyXG4gKiDnur/mgKfnu5PmnoTvvJrmmK/noJTnqbbmlbDmja7lhYPntKDkuYvpl7TnmoTkuIDlr7nkuIDlhbPns7vjgILlnKjov5nnp43nu5PmnoTkuK3vvIzpmaTnrKzkuIDkuKrlkozmnIDlkI7kuIDkuKrlhYPntKDlpJbvvIzku7vkvZXkuIDkuKrlhYPntKDpg73mnInllK/kuIDnmoTkuIDkuKrnm7TmjqXliY3pqbHlkoznm7TmjqXlkI7nu6fjgIJcclxuICpcclxuICog5qCR57uT5p6E77ya5piv56CU56m25pWw5o2u5YWD57Sg5LmL6Ze055qE5LiA5a+55aSa55qE5YWz57O744CC5Zyo6L+Z56eN57uT5p6E5Lit77yM5q+P5Liq5YWD57Sg5a+55LiLKOWxginlj6/ku6XmnIkw5Liq5oiW5aSa5Liq5YWD57Sg55u46IGU57O777yM5a+55LiKKOWxginlj6rmnInllK/kuIDnmoTkuIDkuKrlhYPntKDnm7jlhbPvvIzmlbDmja7lhYPntKDkuYvpl7TmnInmmI7mmL7nmoTlsYLmrKHlhbPns7vjgIJcclxuICpcclxuICog5Zu+57uT5p6E77ya5piv56CU56m25pWw5o2u5YWD57Sg5LmL6Ze055qE5aSa5a+55aSa55qE5YWz57O744CC5Zyo6L+Z56eN57uT5p6E5Lit77yM5Lu75oSP5Lik5Liq5YWD57Sg5LmL6Ze05Y+v6IO95a2Y5Zyo5YWz57O744CC5Y2z57uT54K55LmL6Ze055qE5YWz57O75Y+v5Lul5piv5Lu75oSP55qE77yM5Zu+5Lit5Lu75oSP5YWD57Sg5LmL6Ze06YO95Y+v6IO955u45YWz44CCXHJcbiAqXHJcbiAqIOWbvueahOW6lOeUqOaegeS4uuW5v+azm++8jOW3sua4l+WFpeWIsOivuOWmguivreiogOWtpuOAgemAu+i+keWtpuOAgeeJqeeQhuOAgeWMluWtpuOAgeeUteiur+OAgeiuoeeul+acuuenkeWtpuS7peWPiuaVsOWtpueahOWFtuWug+WIhuaUr+OAglxyXG4gKlxyXG4gKiDlm77nmoTln7rmnKzmpoLlv7VcclxuICpcclxuICog5LiA5Liq5Zu+KEcp5a6a5LmJ5Li65LiA5Liq5YG25a+5KFYsRSkg77yM6K6w5Li6Rz0oVixFKSDjgILlhbbkuK3vvJogVuaYr+mhtueCuShWZXJ0ZXgp55qE6Z2e56m65pyJ6ZmQ6ZuG5ZCI77yM6K6w5Li6VihHKe+8m0XmmK/ml6Dluo/pm4ZWJlbnmoTkuIDkuKrlrZDpm4bvvIzorrDkuLpFKEcpIO+8jOWFtuWFg+e0oOaYr+WbvueahOW8pyhBcmMp44CCXHJcbiAqIOWwhumhtueCuembhuWQiOS4uuepuueahOWbvuensOS4uuepuuWbvuOAguWFtuW9ouW8j+WMluWumuS5ieS4uu+8mlxyXG4gRz0oViDvvIxFKVxyXG4gVj17dnx24oiIZGF0YSBvYmplY3R9XHJcbiBFPXs8dix3Pnwgdix34oiIVuKIp3Aodix3KX1cclxuIFAodix3KeihqOekuuS7jumhtueCuXbliLDpobbngrl35pyJ5LiA5p2h55u05o6l6YCa6Lev44CCXHJcbiAqXHJcbiAqIOW8pyhBcmMpIO+8muihqOekuuS4pOS4qumhtueCuXblkox35LmL6Ze05a2Y5Zyo5LiA5Liq5YWz57O777yM55So6aG254K55YG25a+5PHYsdz7ooajnpLrjgILpgJrluLjmoLnmja7lm77nmoTpobbngrnlgbblr7nlsIblm77liIbkuLrmnInlkJHlm77lkozml6DlkJHlm77jgIJcclxuICog5pyJ5ZCR5Zu+KERpZ3JhcGgp77yaIOiLpeWbvkfnmoTlhbPns7vpm4blkIhFKEcp5Lit77yM6aG254K55YG25a+5PHYsdz7nmoR25ZKMd+S5i+mXtOaYr+acieW6j+eahO+8jOensOWbvkfmmK/mnInlkJHlm77jgIJcclxuICogICDlnKjmnInlkJHlm77kuK3vvIzoi6UgPHYsdz7iiIhFKEcpIO+8jOihqOekuuS7jumhtueCuXbliLDpobbngrl35pyJ5LiA5p2h5byn44CCIOWFtuS4re+8mnbnp7DkuLrlvKflsL4odGFpbCnmiJblp4vngrkoaW5pdGlhbCBub2RlKe+8jHfnp7DkuLrlvKflpLQoaGVhZCnmiJbnu4jngrkodGVybWluYWwgbm9kZSkg44CCXHJcbiAqIOaXoOWQkeWbvihVbmRpZ3JhcGgp77yaIOiLpeWbvkfnmoTlhbPns7vpm4blkIhFKEcp5Lit77yM6aG254K55YG25a+5PHYsdz7nmoR25ZKMd+S5i+mXtOaYr+aXoOW6j+eahO+8jOensOWbvkfmmK/ml6DlkJHlm77jgIJcclxuICogICDlnKjml6DlkJHlm77kuK3vvIzoi6XvgKI8dix3PuKIiEUoRykg77yM5pyJPHcsdj7iiIhFKEcpIO+8jOWNs0UoRynmmK/lr7nnp7DvvIzliJnnlKjml6Dluo/lr7kodix3KSDooajnpLp25ZKMd+S5i+mXtOeahOS4gOadoei+uShFZGdlKe+8jOWboOatpCh2LHcpIOWSjCh3LHYp5Luj6KGo55qE5piv5ZCM5LiA5p2h6L6544CCXHJcbiAqXHJcbiAqIOS+izHvvJrorr7mnInmnInlkJHlm75HMeWSjOaXoOWQkeWbvkcy77yM5b2i5byP5YyW5a6a5LmJ5YiG5Yir5piv77yaXHJcbiBHMT0oVjEg77yMRTEpXHJcbiBWMT17YSxiLGMsZCxlfVxyXG4gRTE9ezxhLGI+LDxhLGM+LCA8YSxlPiw8YyxkPiw8YyxlPiAsPGQsYT4sPGQsYj4sPGUsZD59XHJcbiBHMj0oVjIg77yMRTIpXHJcbiBWMj17YSxiLGMsZH1cclxuIEUyPXsoYSxiKSwgKGEsYyksIChhLGQpLCAoYixkKSwgKGIsYyksIChjLGQpfVxyXG4gKlxyXG4gKiDlrozlhajml6DlkJHlm77vvJrlr7nkuo7ml6DlkJHlm77vvIzoi6Xlm77kuK3pobbngrnmlbDkuLpuIO+8jOeUqGXooajnpLrovrnnmoTmlbDnm67vvIzliJllIOKIiFsw77yMbihuLTEpLzJdIOOAguWFt+aciW4obi0xKS8y5p2h6L6555qE5peg5ZCR5Zu+56ew5Li65a6M5YWo5peg5ZCR5Zu+44CCXHJcbiDlrozlhajml6DlkJHlm77lj6blpJbnmoTlrprkuYnmmK/vvJpcclxuICog5a+55LqO5peg5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74CidmnvvIx2aiDiiIhWIO+8jOW9k3Zp4omgdmrml7bvvIzmnIkodmkgLHZqKeKIiEXvvIzljbPlm77kuK3ku7vmhI/kuKTkuKrkuI3lkIznmoTpobbngrnpl7Tpg73mnInkuIDmnaHml6DlkJHovrnvvIzov5nmoLfnmoTml6DlkJHlm77np7DkuLrlrozlhajml6DlkJHlm77jgIJcclxuICpcclxuICog5a6M5YWo5pyJ5ZCR5Zu+77ya5a+55LqO5pyJ5ZCR5Zu+77yM6Iul5Zu+5Lit6aG254K55pWw5Li6biDvvIznlKhl6KGo56S65byn55qE5pWw55uu77yM5YiZZeKIiFsw77yMbihuLTEpXSDjgILlhbfmnIluKG4tMSnmnaHovrnnmoTmnInlkJHlm77np7DkuLrlrozlhajmnInlkJHlm77jgIJcclxuIOWujOWFqOacieWQkeWbvuWPpuWklueahOWumuS5ieaYr++8mlxyXG4gKiDlr7nkuo7mnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZq4oiIViDvvIzlvZN2aSDiiaB2auaXtu+8jOaciTx2aSAsdmo+4oiIReKIpzx2aiAsIHZpID7iiIhFIO+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeW8p++8jOi/meagt+eahOacieWQkeWbvuensOS4uuWujOWFqOacieWQkeWbvuOAglxyXG4gKlxyXG4gKiDmnInlvojlsJHovrnmiJblvKfnmoTlm77vvIhlPG7jj5Ju77yJ55qE5Zu+56ew5Li656iA55aP5Zu+77yM5Y+N5LmL56ew5Li656ig5a+G5Zu+44CCXHJcbiAqIOadgyhXZWlnaHQp77ya5LiO5Zu+55qE6L655ZKM5byn55u45YWz55qE5pWw44CC5p2D5Y+v5Lul6KGo56S65LuO5LiA5Liq6aG254K55Yiw5Y+m5LiA5Liq6aG254K555qE6Led56a75oiW6ICX6LS544CCXHJcbiAqXHJcbiAqIOWtkOWbvuWSjOeUn+aIkOWtkOWbvu+8muiuvuacieWbvkc9KFbvvIxFKeWSjEfigJk9KFbigJnvvIxF4oCZKe+8jOiLpVbigJniiIhW5LiUReKAmeKIiEUg77yM5YiZ56ew5Zu+R+KAmeaYr0fnmoTlrZDlm77vvJvoi6VW4oCZPVbkuJRF4oCZ4oiIRe+8jOWImeensOWbvkfigJnmmK9H55qE5LiA5Liq55Sf5oiQ5a2Q5Zu+44CCXHJcbiAqIOmhtueCueeahOmCu+aOpShBZGphY2VudCnvvJrlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6Xovrkodix3KeKIiEXvvIzliJnnp7Dpobbngrl25ZKMdyDkupLkuLrpgrvmjqXngrnvvIzljbN25ZKMd+ebuOmCu+aOpeOAgui+uSh2LHcp5L6d6ZmEKGluY2lkZW50KeS4jumhtueCuXblkox3IOOAglxyXG4gKiDlr7nkuo7mnInlkJHlm75HPShWIO+8jEUp77yM6Iul5pyJ5ZCR5bynPHYsdz7iiIhF77yM5YiZ56ew6aG254K5diDigJzpgrvmjqXliLDigJ3pobbngrl377yM6aG254K5dyDigJzpgrvmjqXoh6rigJ3pobbngrl2IO+8jOW8pzx2LHc+IOS4jumhtueCuXblkox3IOKAnOebuOWFs+iBlOKAnSDjgIJcclxuICpcclxuICog6aG254K555qE5bqm44CB5YWl5bqm44CB5Ye65bqm77ya5a+55LqO5peg5ZCR5Zu+Rz0oVu+8jEUp77yMIO+AonZp4oiIVu+8jOWbvkfkuK3kvp3pmYTkuo52aeeahOi+ueeahOaVsOebruensOS4uumhtueCuXZp55qE5bqmKGRlZ3JlZSnvvIzorrDkuLpURCh2aSnjgIJcclxuIOaYvueEtu+8jOWcqOaXoOWQkeWbvuS4re+8jOaJgOaciemhtueCueW6pueahOWSjOaYr+WbvuS4rei+ueeahDLlgI3jgIIg5Y2zICAg4oiRVEQodmkpPTJlICAgICAgaT0xLCAyLCDigKYsIG4g77yMZeS4uuWbvueahOi+ueaVsOOAglxyXG4g5a+55pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74Cidmkg4oiIViDvvIzlm75H5Lit5LuldmnkvZzkuLrotbfngrnnmoTmnInlkJHovrko5bynKeeahOaVsOebruensOS4uumhtueCuXZp55qE5Ye65bqmKE91dGRlZ3JlZSnvvIzorrDkuLpPRCh2aSkg77yb5LuldmnkvZzkuLrnu4jngrnnmoTmnInlkJHovrko5bynKeeahOaVsOebruensOS4uumhtueCuXZp55qE5YWl5bqmKEluZGVncmVlKe+8jOiusOS4uklEKHZpKSDjgILpobbngrl2aeeahOWHuuW6puS4juWFpeW6puS5i+WSjOensOS4unZp55qE5bqm77yM6K6w5Li6VEQodmkpIOOAguWNs1xyXG4gVEQodmkpPU9EKHZpKStJRCh2aSlcclxuICpcclxuICog6Lev5b6EKFBhdGgp44CB6Lev5b6E6ZW/5bqm44CB5Zue6LevKEN5Y2xlKSDvvJrlr7nml6DlkJHlm75HPShW77yMRSnvvIzoi6Xku47pobbngrl2aee7j+i/h+iLpeW5suadoei+ueiDveWIsOi+vnZq77yM56ew6aG254K5dmnlkox2auaYr+i/numAmueahO+8jOWPiOensOmhtueCuXZp5YiwdmrmnInot6/lvoTjgIJcclxuIOWvueacieWQkeWbvkc9KFbvvIxFKe+8jOS7jumhtueCuXZp5YiwdmrmnInmnInlkJHot6/lvoTvvIzmjIfnmoTmmK/ku47pobbngrl2aee7j+i/h+iLpeW5suadoeacieWQkei+uSjlvKcp6IO95Yiw6L6+dmrjgIJcclxuIOaIlui3r+W+hOaYr+WbvkfkuK3ov57mjqXkuKTpobbngrnkuYvpl7TmiYDnu4/ov4fnmoTpobbngrnluo/liJfjgILljbNcclxuIFBhdGg9dmkwdmkx4oCmdmltIO+8jHZpauKIiFbkuJQodmlqLTEsIHZpainiiIhFICAgaj0xLDIsIOKApixtXHJcbiDmiJZcclxuIFBhdGg9dmkwdmkxIOKApnZpbSDvvIx2aWriiIhW5LiUPHZpai0xLCB2aWo+4oiIRSAgaj0xLDIsIOKApixtXHJcbiDot6/lvoTkuIrovrnmiJbmnInlkJHovrko5bynKeeahOaVsOebruensOS4uuivpei3r+W+hOeahOmVv+W6puOAglxyXG4g5Zyo5LiA5p2h6Lev5b6E5Lit77yM6Iul5rKh5pyJ6YeN5aSN55u45ZCM55qE6aG254K577yM6K+l6Lev5b6E56ew5Li6566A5Y2V6Lev5b6E77yb56ys5LiA5Liq6aG254K55ZKM5pyA5ZCO5LiA5Liq6aG254K555u45ZCM55qE6Lev5b6E56ew5Li65Zue6LevKOeOrynvvJvlnKjkuIDkuKrlm57ot6/kuK3vvIzoi6XpmaTnrKzkuIDkuKrkuI7mnIDlkI7kuIDkuKrpobbngrnlpJbvvIzlhbbkvZnpobbngrnkuI3ph43lpI3lh7rnjrDnmoTlm57ot6/np7DkuLrnroDljZXlm57ot68o566A5Y2V546vKeOAglxyXG4gKlxyXG4gKiDov57pgJrlm77jgIHlm77nmoTov57pgJrliIbph4/vvJrlr7nml6DlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDvvIx2aiDiiIhW77yMdmnlkox2aumDveaYr+i/numAmueahO+8jOWImeensOWbvkfmmK/ov57pgJrlm77vvIzlkKbliJnnp7DkuLrpnZ7ov57pgJrlm77jgILoi6VH5piv6Z2e6L+e6YCa5Zu+77yM5YiZ5p6B5aSn55qE6L+e6YCa5a2Q5Zu+56ew5Li6R+eahOi/numAmuWIhumHj+OAglxyXG4g5a+55pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74Cidmkg77yMdmog4oiIVu+8jOmDveacieS7pXZp5Li66LW354K577yMIHZqIOS4uue7iOeCueS7peWPiuS7pXZq5Li66LW354K577yMdmnkuLrnu4jngrnnmoTmnInlkJHot6/lvoTvvIznp7Dlm75H5piv5by66L+e6YCa5Zu+77yM5ZCm5YiZ56ew5Li66Z2e5by66L+e6YCa5Zu+44CC6IulR+aYr+mdnuW8uui/numAmuWbvu+8jOWImeaegeWkp+eahOW8uui/numAmuWtkOWbvuensOS4ukfnmoTlvLrov57pgJrliIbph4/jgIJcclxuIOKAnOaegeWkp+KAneeahOWQq+S5ie+8muaMh+eahOaYr+WvueWtkOWbvuWGjeWinuWKoOWbvkfkuK3nmoTlhbblroPpobbngrnvvIzlrZDlm77lsLHkuI3lho3ov57pgJrjgIJcclxuIOeUn+aIkOagkeOAgeeUn+aIkOajruael++8muS4gOS4qui/numAmuWbvijml6DlkJHlm74p55qE55Sf5oiQ5qCR5piv5LiA5Liq5p6B5bCP6L+e6YCa5a2Q5Zu+77yM5a6D5ZCr5pyJ5Zu+5Lit5YWo6YOobuS4qumhtueCueWSjOWPquaciei2s+S7peaehOaIkOS4gOajteagkeeahG4tMeadoei+ue+8jOensOS4uuWbvueahOeUn+aIkOagkeOAglxyXG4g5YWz5LqO5peg5ZCR5Zu+55qE55Sf5oiQ5qCR55qE5Yeg5Liq57uT6K6677yaXHJcbiDil4Yg5LiA5qO15pyJbuS4qumhtueCueeahOeUn+aIkOagkeacieS4lOS7heaciW4tMeadoei+ue+8m1xyXG4g4peGIOWmguaenOS4gOS4quWbvuaciW7kuKrpobbngrnlkozlsI/kuo5uLTHmnaHovrnvvIzliJnmmK/pnZ7ov57pgJrlm77vvJtcclxuIOKXhiDlpoLmnpzlpJrkuo5uLTHmnaHovrnvvIzliJnkuIDlrprmnInnjq/vvJtcclxuIOKXhiDmnIluLTHmnaHovrnnmoTlm77kuI3kuIDlrprmmK/nlJ/miJDmoJHjgIJcclxuXHJcbiDmnInlkJHlm77nmoTnlJ/miJDmo67mnpfmmK/ov5nmoLfkuIDkuKrlrZDlm77vvIznlLHoi6XlubLmo7XmnInlkJHmoJHnu4TmiJDvvIzlkKvmnInlm77kuK3lhajpg6jpobbngrnjgIJcclxuIOacieWQkeagkeaYr+WPquacieS4gOS4qumhtueCueeahOWFpeW6puS4ujAg77yM5YW25L2Z6aG254K555qE5YWl5bqm5Z2H5Li6MeeahOacieWQkeWbvuOAglxyXG5cclxuICpcclxuICog572R77ya5q+P5Liq6L65KOaIluW8pynpg73pmYTliqDkuIDkuKrmnYPlgLznmoTlm77vvIznp7DkuLrluKbmnYPlm77jgILluKbmnYPnmoTov57pgJrlm74o5YyF5ous5byx6L+e6YCa55qE5pyJ5ZCR5Zu+KeensOS4uue9keaIlue9kee7nOOAgue9kee7nOaYr+W3peeoi+S4iuW4uOeUqOeahOS4gOS4quamguW/te+8jOeUqOadpeihqOekuuS4gOS4quW3peeoi+aIluafkOenjea1geeoi1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDlm77nmoTlrZjlgqjnu5PmnoRcclxuICpcclxuIOWbvueahOWtmOWCqOe7k+aehOavlOi+g+Wkjeadgu+8jOWFtuWkjeadguaAp+S4u+imgeihqOeOsOWcqO+8mlxyXG4g4peGIOS7u+aEj+mhtueCueS5i+mXtOWPr+iDveWtmOWcqOiBlOezu++8jOaXoOazleS7peaVsOaNruWFg+e0oOWcqOWtmOWCqOWMuuS4reeahOeJqeeQhuS9jee9ruadpeihqOekuuWFg+e0oOS5i+mXtOeahOWFs+ezu+OAglxyXG4g4peGIOWbvuS4remhtueCueeahOW6puS4jeS4gOagt++8jOacieeahOWPr+iDveebuOW3ruW+iOWkp++8jOiLpeaMieW6puaVsOacgOWkp+eahOmhtueCueiuvuiuoee7k+aehO+8jOWImeS8mua1qui0ueW+iOWkmuWtmOWCqOWNleWFg++8jOWPjeS5i+aMieavj+S4qumhtueCueiHquW3seeahOW6puiuvuiuoeS4jeWQjOeahOe7k+aehO+8jOWPiOS8muW9seWTjeaTjeS9nOOAglxyXG4g5Zu+55qE5bi455So55qE5a2Y5YKo57uT5p6E5pyJ77ya6YK75o6l55+p6Zi144CB6YK75o6l6ZO+6KGo44CB5Y2B5a2X6ZO+6KGo44CB6YK75o6l5aSa6YeN6KGo5ZKM6L656KGo44CCXHJcbiAqL1xyXG5cclxuLypcclxuIOmCu+aOpeefqemYtSjmlbDnu4Qp6KGo56S65rOVXHJcblxyXG4g5Z+65pys5oCd5oOz77ya5a+55LqO5pyJbuS4qumhtueCueeahOWbvu+8jOeUqOS4gOe7tOaVsOe7hHZleHNbbl3lrZjlgqjpobbngrnkv6Hmga/vvIznlKjkuoznu7TmlbDnu4RBW25dW25d5a2Y5YKo6aG254K55LmL6Ze05YWz57O755qE5L+h5oGv44CC6K+l5LqM57u05pWw57uE56ew5Li66YK75o6l55+p6Zi144CC5Zyo6YK75o6l55+p6Zi15Lit77yM5Lul6aG254K55ZyodmV4c+aVsOe7hOS4reeahOS4i+agh+S7o+ihqOmhtueCue+8jOmCu+aOpeefqemYteS4reeahOWFg+e0oEFbaV1bal3lrZjmlL7nmoTmmK/pobbngrlp5Yiw6aG254K5auS5i+mXtOWFs+ezu+eahOS/oeaBr+OAglxyXG5cclxuIDEgIOaXoOWQkeWbvueahOaVsOe7hOihqOekulxyXG5cclxuICgxKSAg5peg5p2D5Zu+55qE6YK75o6l55+p6Zi1XHJcbiDml6DlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcclxuICAgICAgICAgICAgLS0gMSAgIOiLpSh2aSAsIHZqKeKIiEXvvIzljbN2aSAsIHZq6YK75o6lXHJcbiBBW2ldW2pdPVxyXG4gICAgICAgICAgICAgLS0gMCAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6lXHJcblxyXG4gKDIpICDluKbmnYPlm77nmoTpgrvmjqXnn6npmLVcclxuIOaXoOWQkeW4puadg+Wbvkc9KFbvvIxFKSDnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcclxuICAgICAgICAgICAgLS0gV2lqICAgIOiLpSh2aSAsIHZqKeKIiEXvvIzljbN2aSAsIHZq6YK75o6l77yM5p2D5YC85Li6d2lqXHJcbiBBW2ldW2pdPVxyXG5cclxuICAgICAgICAgICAgLS0g4oieICAg6IulKHZpICwgdmop4oiJRe+8jOWNs3ZpICwgdmrkuI3pgrvmjqXml7ZcclxuXHJcbiAoMykgIOaXoOWQkeWbvumCu+aOpeefqemYteeahOeJueaAp1xyXG4g4peGIOmCu+aOpeefqemYteaYr+WvueensOaWuemYtVxyXG4g4peGIOWvueS6jumhtueCuXZp77yM5YW25bqm5pWw5piv56ysaeihjOeahOmdnjDlhYPntKDnmoTkuKrmlbDvvJtcclxuIOKXhiDml6DlkJHlm77nmoTovrnmlbDmmK/kuIoo5oiW5LiLKeS4ieinkuW9ouefqemYteS4remdnjDlhYPntKDkuKrmlbDjgIJcclxuXHJcbiAyICDmnInlkJHlm77nmoTmlbDnu4TooajnpLpcclxuXHJcbiAoMSkgIOaXoOadg+WbvueahOmCu+aOpeefqemYtVxyXG4g6Iul5pyJ5ZCR5peg5p2D5Zu+Rz0oVu+8jEUp5pyJbihu4omnMSnkuKrpobbngrnvvIzliJnlhbbpgrvmjqXnn6npmLXmmK9u6Zi25a+556ew5pa56Zi144CC5YWD57Sg5a6a5LmJ5aaC5LiL77yaXHJcbiAgICAgICAgICAgIC0tIDEgICDoi6U8dmksIHZqPuKIiEXvvIzku452aeWIsHZq5pyJ5bynXHJcbiBBW2ldW2pdPVxyXG4gICAgICAgICAgICAtLSAwICAg6IulPHZpICwgdmo+4oiJRSAg5LuOdmnliLB2aiDmsqHmnInlvKdcclxuXHJcbiAoMikgIOW4puadg+WbvueahOmCu+aOpeefqemYtVxyXG4g5pyJ5ZCR5bim5p2D5Zu+Rz0oVu+8jEUp55qE6YK75o6l55+p6Zi144CC5YW25YWD57Sg55qE5a6a5LmJ5aaC5LiL77yaXHJcbiAgICAgICAgICAgIC0tIHdpaiAgICDoi6U8dmksdmo+4oiIRe+8jOWNs3ZpICwgdmrpgrvmjqXvvIzmnYPlgLzkuLp3aWpcclxuIEFbaV1bal09XHJcbiAgICAgICAgICAgIOKIniAgIOiLpTx2aSx2aj7iiIlF77yM5Y2zdmkgLCB2auS4jemCu+aOpeaXtlxyXG5cclxuIOKRtiDmnInlkJHlm77pgrvmjqXnn6npmLXnmoTnibnmgKdcclxuIOKXhiDlr7nkuo7pobbngrl2ae+8jOesrGnooYznmoTpnZ4w5YWD57Sg55qE5Liq5pWw5piv5YW25Ye65bqmT0Qodmkp77yb56ysaeWIl+eahOmdnjDlhYPntKDnmoTkuKrmlbDmmK/lhbblhaXluqZJRCh2aSkg44CCXHJcbiDil4Yg6YK75o6l55+p6Zi15Lit6Z2eMOWFg+e0oOeahOS4quaVsOWwseaYr+WbvueahOW8p+eahOaVsOebruOAglxyXG5cclxuIDMgIOWbvueahOmCu+aOpeefqemYteeahOaTjeS9nFxyXG5cclxuIOWbvueahOmCu+aOpeefqemYteeahOWunueOsOavlOi+g+WuueaYk++8jOWumuS5ieS4pOS4quaVsOe7hOWIhuWIq+WtmOWCqOmhtueCueS/oeaBryjmlbDmja7lhYPntKAp5ZKM6L655oiW5byn55qE5L+h5oGvKOaVsOaNruWFg+e0oOS5i+mXtOeahOWFs+ezuykg44CCXHJcblxyXG4gKi9cclxuXHJcbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XHJcbmltcG9ydCB7IENoaWxkU2libGluZ1RyZWUgfSBmcm9tICcuLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnO1xyXG5cclxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XHJcbmNvbnN0IERHID0gMTsgICAgIC8vIOacieWQkeWbvlxyXG5jb25zdCBETiA9IDI7ICAgICAvLyDmnInlkJHnvZFcclxuY29uc3QgVURHID0gMzsgICAgLy8g5peg5ZCR5Zu+XHJcbmNvbnN0IFVETiA9IDQ7ICAgIC8vIOaXoOWQkee9kVxyXG5cclxuXHJcbmNsYXNzIEFyY0NlbGwge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFkalxyXG4gICAgICogQHBhcmFtIHsqfSBpbmZvXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWRqLCBpbmZvID0gbnVsbCl7XHJcbiAgICAgICAgLy8g6aG254K557G75Z6L44CC5a+55LqO5peg5p2D5Zu+77yM55SoMeaIljDooajnpLrnm7jpgrvlkKbvvJvlr7nluKbmnYPlm77vvIzliJnkuLrmnYPlgLznsbvlnotcclxuICAgICAgICB0aGlzLmFkaiA9IHR5cGVvZiBhZGogPT09ICdudW1iZXInID8gYWRqIDogSW5maW5pdHk7XHJcbiAgICAgICAgLy8g6K+l5byn55u45YWz5L+h5oGvXHJcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkamFjZW5jeU1hdHJpeEdyYXBoIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZleHMg6aG254K55ZCR6YePXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgQXJjQ2VsbH0gYXJjcyDpgrvmjqXnn6npmLVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBraW5kXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmV4cyA9IFtdLCBhcmNzID0gW10sIHZleG51bSA9IDAsIGFyY251bSA9IDAsIGtpbmQgPSBERyl7XHJcbiAgICAgICAgLy8g6aG254K55ZCR6YePXHJcbiAgICAgICAgdGhpcy52ZXhzID0gdmV4cztcclxuICAgICAgICAvLyDpgrvmjqXnn6npmLVcclxuICAgICAgICB0aGlzLmFyY3MgPSBhcmNzO1xyXG4gICAgICAgIC8vIOWbvueahOW9k+WJjemhtueCueaVsFxyXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xyXG4gICAgICAgIC8vIOWbvueahOW9k+WJjeW8p+aVsFxyXG4gICAgICAgIHRoaXMuYXJjbnVtID0gYXJjbnVtO1xyXG4gICAgICAgIC8vIOWbvueahOenjeexu+agh+W/l1xyXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlR3JhcGgoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcclxuICAgICAgICAgICAgY2FzZSBERzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVERyh0aGlzKTsgICAgIC8vIOaehOmAoOacieWQkeWbvlxyXG4gICAgICAgICAgICBjYXNlIEROOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUROKHRoaXMpOyAgICAgLy8g5p6E6YCg5pyJ5ZCR572RXHJcbiAgICAgICAgICAgIGNhc2UgVURHOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVVERyh0aGlzKTsgICAgLy8g5p6E6YCg5peg5ZCR5Zu+XHJcbiAgICAgICAgICAgIGNhc2UgVUROOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVVETih0aGlzKTsgICAgLy8g5p6E6YCg5peg5ZCR572RXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+mdnuacieaViOeahOWbvuexu+WeiycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOafpeaJvumhtueCuVxyXG4gICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGxvY2F0ZVZleCAodnApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmV4c1tpXSA9PT0gdnApIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5ZCR5Zu+5Lit5aKe5Yqg6aG254K5XHJcbiAgICAgKiBAcGFyYW0geyp9IHZwIOmhtueCueWQkemHj1xyXG4gICAgICovXHJcbiAgICBhZGRWZXJ0ZXgodnApIHtcclxuICAgICAgICBpZiAodGhpcy5sb2NhdGVWZXgodnApICE9PSAtMSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggaGFzIGV4aXN0ZWQhJyk7XHJcblxyXG4gICAgICAgIGxldCBrID0gdGhpcy52ZXhudW07XHJcbiAgICAgICAgdGhpcy52ZXhzW3RoaXMudmV4bnVtKytdID0gdnA7XHJcblxyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMua2luZCA9PT0gREcgfHwgdGhpcy5raW5kID09PSBVREcgP1xyXG4gICAgICAgICAgICAwIDogSW5maW5pdHk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXSA9IHRoaXMuYXJjc1tqXSB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2tdID0gdGhpcy5hcmNzW2tdIHx8IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10gPSB0aGlzLmFyY3Nbal1ba10gfHwgbmV3IEFyY0NlbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2tdW2pdID0gdGhpcy5hcmNzW2tdW2pdIHx8IG5ldyBBcmNDZWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5hZGogPSB0aGlzLmFyY3Nba11bal0uYWRqID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5ZCR5Zu+5Lit5aKe5Yqg5LiA5p2h5bynXHJcbiAgICAgKiBAcGFyYW0geyp9IHZleDEg6aG254K5MeWQkemHj1xyXG4gICAgICogQHBhcmFtIHsqfSB2ZXgyIOmhtueCuTLlkJHph49cclxuICAgICAqIEBwYXJhbSB7QXJjQ2VsbH0gYXJjXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgYWRkQXJjKHZleDEsIHZleDIsIGFyYykge1xyXG4gICAgICAgIGFyYyA9IGFyYyB8fCBuZXcgQXJjQ2VsbCh0aGlzLmtpbmQgPT09IERHIHx8IHRoaXMua2luZCA9PT0gVURHID8gMSA6ICd3ZWlnaHQnKTtcclxuICAgICAgICBsZXQgayA9IHRoaXMubG9jYXRlVmV4KHZleDEpO1xyXG4gICAgICAgIGxldCBqID0gdGhpcy5sb2NhdGVWZXgodmV4Mik7XHJcblxyXG4gICAgICAgIGlmIChrID09PSAtMSB8fCBqID09PSAtMSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmNcXCdzIFZlcnRleCBkbyBub3QgZXhpc3RlZCEnKTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmNzW2tdW2pdLmFkaiA9IGFyYy5hZGo7XHJcbiAgICAgICAgdGhpcy5hcmNzW2tdW2pdLmluZm8gPSBhcmMuaW5mbztcclxuICAgICAgICAvLyDml6DlkJHlm77miJbml6DlkJHnvZFcclxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmFkaiA9IGFyYy5hZGo7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5pbmZvID0gYXJjLmluZm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICArK3RoaXMuYXJjbnVtO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOmhtueCuVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZleCDopoHliKDpmaTnmoTpobbngrlcclxuICAgICAqL1xyXG4gICAgZGVsZXRlVmV4KHZleCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy52ZXhudW0gLSAxO1xyXG4gICAgICAgIGxldCBtID0gdGhpcy5sb2NhdGVWZXgodmV4KTtcclxuXHJcbiAgICAgICAgaWYgKG0gPCAwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIOWwhuW+heWIoOmZpOmhtueCueS6pOaNouWIsOacgOWQjuS4gOS4qumhtueCuVxyXG4gICAgICAgIGxldCB0ZW1wID0gdGhpcy52ZXhzW21dO1xyXG4gICAgICAgIHRoaXMudmV4c1ttXSA9IHRoaXMudmV4c1tuXTtcclxuICAgICAgICB0aGlzLnZleHNbbl0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAvLyDlsIbovrnnmoTlhbPns7vpmo/kuYvkuqTmjaJcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2ldW21dID0gdGhpcy5hcmNzW2ldW25dO1xyXG4gICAgICAgICAgICB0aGlzLmFyY3NbbV1baV0gPSB0aGlzLmFyY3Nbbl1baV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFyY3NbbV1bbV0uYWRqID0gMDtcclxuICAgICAgICB0aGlzLnZleHMubGVuZ3RoID0gLS10aGlzLnZleG51bTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOi+uSh2LCB3KVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZGVsZXRlQXJjKHYsIHcpIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXMubG9jYXRlVmV4KHYpO1xyXG4gICAgICAgIGxldCBqID0gdGhpcy5sb2NhdGVWZXgodyk7XHJcblxyXG4gICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hcmNzW2ldW2pdLmFkaikge1xyXG4gICAgICAgICAgICB0aGlzLmFyY3NbaV1bal0uYWRqID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIpOaWreS4gOS4qumCu+aOpeefqemYteWtmOWCqOeahOacieWQkeWbvuaYr+WQpuWPr+S8oOmAklxyXG4gICAgaXNQYXNzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmtpbmQgIT09IERHKSB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBoIGtpbmQgc2hvdWxkIGJlIERHJyk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52ZXhudW07ICsreCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMudmV4bnVtOyArK3kpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbeF1beV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMudmV4bnVtOyArK3opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHogIT09IHggJiYgdGhpcy5hcmNzW3ldW3pdICYmICF0aGlzLmFyY3NbeF1bel0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZpcnN0QWRqVmV4KHYpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtpXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gSW5maW5pdHkpIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIG5leHRBZGpWZXgodiwgdykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB3ICsgMTsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtpXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gSW5maW5pdHkpIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWvuemCu+aOpeefqemYteWbvuS9nOmAkuW9kuW8j+a3seW6puS8mOWFiOmBjeWOhlxyXG4gICAgREZTVHJhdmVyc2UodmlzaXRGbikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgLy8g6K6/6Zeu5qCH5b+X5pWw57uE5Yid5aeL5YyWXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzKHRoaXMsIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2ZXJ0ZXgpIHtcclxuICAgICAgICAgICAgdmlzaXRlZFt2ZXJ0ZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmlzaXRGbi5jYWxsKGdyYXBoLCB2ZXJ0ZXgpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaC52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IDAgJiYgZ3JhcGguYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gSW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAmJiAhdmlzaXRlZFtqXSkgZGZzKGdyYXBoLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDpnZ7pgJLlvZJcclxuICAgIERGU1RyYXZlcnNlX05vblJlY3Vyc2UodmlzaXRGbikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICAgICAgbGV0IG1lID0gdGhpcztcclxuICAgICAgICAvLyDorr/pl67moIflv5fmlbDnu4TliJ3lp4vljJZcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKG1lLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCh2ZXJ0ZXggPSBzdGFjay5wZWVrKCkpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhdmlzaXRlZFtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKG1lLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbal0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDlr7npgrvmjqXnn6npmLXlm77kvZzlub/luqbkvJjlhYjpgY3ljoZcclxuICAgIEJGU1RyYXZlcnNlKHZpc2l0Rm4pIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgaSk7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3VdW2pdLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3NbdV1bal0uYWRqICE9PSBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbal0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtaW5TcGFuVHJlZV9QUklNKHUpIHtcclxuICAgICAgICBsZXQgY2xvc2VkZ2UgPSBbXTtcclxuXHJcbiAgICAgICAgLy8g5Yid5aeL5YyWXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgIGNsb3NlZGdlW2pdID0ge2FkanZleDogdSwgbG93Y29zdDogK3RoaXMuYXJjc1tqXVt1XS5hZGp9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbG9zZWRnZVt1XS5sb3djb3N0ID0gMDtcclxuXHJcbiAgICAgICAgbGV0IHRlID0gW107XHJcbiAgICAgICAgLy8g6YCJ5oup5YW25L2ZdGhpcy52ZXhudW0gLSAx5Liq6aG254K5XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bSAtIDE7ICsraikge1xyXG4gICAgICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGxldCBrO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjbG9zZWRnZVt2XS5sb3djb3N0ICE9PSAwICYmIGNsb3NlZGdlW3ZdLmxvd2Nvc3QgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjbG9zZWRnZVt2XS5sb3djb3N0O1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSB2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ZVtqXSA9IHtcclxuICAgICAgICAgICAgICAgIHZleDE6IGNsb3NlZGdlW2tdLmFkanZleCxcclxuICAgICAgICAgICAgICAgIHZleDI6IGssXHJcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IGNsb3NlZGdlW2tdLmxvd2Nvc3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2xvc2VkZ2Vba10ubG93Y29zdCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtrXS5hZGogPCBjbG9zZWRnZVt2XS5sb3djb3N0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkZ2Vbdl0ubG93Y29zdCA9IHRoaXMuYXJjc1t2XVtrXS5hZGo7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkZ2Vbdl0uYWRqdmV4ID0gaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRlO1xyXG4gICAgfVxyXG5cclxuICAgIG1pblNwYW5UcmVlX0tydXNrYWwoKSB7XHJcbiAgICAgICAgbGV0IHNldCA9IFtdO1xyXG4gICAgICAgIGxldCB0ZSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgc2V0W2ldID0gaTtcclxuXHJcbiAgICAgICAgbGV0IGsgPSAwO1xyXG4gICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgYSA9IDA7XHJcbiAgICAgICAgbGV0IGIgPSAwO1xyXG4gICAgICAgIHdoaWxlKGsgPCB0aGlzLnZleG51bSAtIDEpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGogPSBpICsgMTsgaiA8IHRoaXMudmV4bnVtOyArK2ope1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJjc1tpXVtqXS5hZGogPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdGhpcy5hcmNzW2ldW2pdLmFkajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2V0W2FdICE9PSBzZXRbYl0pe1xyXG4gICAgICAgICAgICAgICAgdGVbaysrXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXgxOiBhLFxyXG4gICAgICAgICAgICAgICAgICAgIHZleDI6IGIsXHJcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiB0aGlzLmFyY3NbYV1bYl0uYWRqXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihzZXRbaV0gPT09IHNldFtiXSAmJiBpICE9PSBiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRbaV0gPSBzZXRbYV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXRbYl0gPSBzZXRbYV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1pbiA9IHRoaXMuYXJjc1thXVtiXS5hZGogPSBJbmZpbml0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUqERpamtzdHJh566X5rOV5rGC5pyJ5ZCR572R55qEdjDpobbngrnliLDlhbbkvZnpobbngrl255qE5pyA55+t6Lev5b6EcHJlW3Zd5Y+K5YW25bim5p2D6ZW/5bqmZGlzdFt2XeOAglxyXG4gICAgICog6IulcHJlW3ZdW3dd5Li6dHJ1Ze+8jOWImXfmmK/ku452MOWIsHblvZPliY3msYLlvpfmnIDnn63ot6/lvoTkuIrnmoTpobbngrnjgIJcclxuICAgICAqIGZpbmFsW3Zd5Li6dHJ1ZeW9k+S4lOS7heW9k3biiIhT77yM5Y2z5bey57uP5rGC5b6XdjDliLB255qE5pyA55+t6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0gdjBcclxuICAgICAqL1xyXG4gICAgc2hvcnRlc3RQYXRoX0RpamtzdHJhKHYwKSB7XHJcbiAgICAgICAgbGV0IHByZSA9IFtdO1xyXG4gICAgICAgIGxldCBkaXN0ID0gW107XHJcbiAgICAgICAgbGV0IGZpbmFsID0gW107XHJcbiAgICAgICAgbGV0IHcsIHY7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xyXG4gICAgICAgICAgICBmaW5hbFt2XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkaXN0W3ZdID0gdGhpcy5hcmNzW3YwXVt2XS5hZGo7XHJcbiAgICAgICAgICAgIHByZVt2XSA9IHByZVt2XSB8fCBbXTtcclxuICAgICAgICAgICAgLy8g6K6+56m66Lev5b6EXHJcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSBwcmVbdl1bd10gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGRpc3Rbdl0gPCBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgcHJlW3ZdW3YwXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcmVbdl1bdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDliJ3lp4vljJbvvIx2MOmhtueCueWxnuS6jlPpm4ZcclxuICAgICAgICBkaXN0W3YwXSA9IDA7XHJcbiAgICAgICAgZmluYWxbdjBdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8g5byA5aeL5Li75b6q546v77yM5q+P5qyh5rGC5b6XdjDliLDmn5DkuKp26aG254K555qE5pyA55+t6Lev5b6E77yM5bm25YqgduWIsFPpm4ZcclxuXHJcbiAgICAgICAgLy8g5YW25L2Z55qE6aG254K5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgLy8g5b2T5YmN5omA5oyH56a7djDpobbngrnnmoTmnIDov5Hot53nprtcclxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHtcclxuICAgICAgICAgICAgICAgIC8vIHfpobbngrnlnKhWIC0gU+S4rVxyXG4gICAgICAgICAgICAgICAgLy8g5LiUd+mhtueCueemu3Yw6aG254K55pu06L+RXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmFsW3ddICYmIGRpc3Rbd10gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gdztcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0W3ddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDnprt2MOmhtueCueacgOi/keeahHbliqDlhaVT6ZuGXHJcbiAgICAgICAgICAgIGZpbmFsW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8g5pu05paw5b2T5YmN5pyA55+t6Lev5b6E5Y+K6Led56a7XHJcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmFsW3ddICYmIG1pbiArIHRoaXMuYXJjc1t2XVt3XS5hZGogPCBkaXN0W3ddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFt3XSA9IG1pbiArIHRoaXMuYXJjc1t2XVt3XS5hZGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddID0gcHJlW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZVt3XVt3XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGZpbmFsKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhwcmUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRpc3QpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaW5hbDogZmluYWwsXHJcbiAgICAgICAgICAgIHByZTogcHJlLFxyXG4gICAgICAgICAgICBkaXN0OiBkaXN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzaG9ydGVzdFBhdGhfRkxPWUQoKSB7XHJcbiAgICAgICAgbGV0IGEgPSBbXTtcclxuICAgICAgICBsZXQgcGF0aCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgYVtqXSA9IGFbal0gfHwgW107XHJcbiAgICAgICAgICAgIHBhdGhbal0gPSBwYXRoW2pdIHx8IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMudmV4bnVtOyArK2spIHtcclxuICAgICAgICAgICAgICAgIGlmKGogPT09IGspIGFbal1ba10gPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBhW2pdW2tdID0gdGhpcy5hcmNzW2pdW2tdLmFkajtcclxuICAgICAgICAgICAgICAgIHBhdGhbal1ba10gPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCB0aGlzLnZleG51bTsgKyttKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFbal1bbV0gKyBhW21dW2tdIDwgYVtqXVtrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhW2pdW2tdID0gYVtqXVttXSArIGFbbV1ba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbal1ba10gPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogIT09IGspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWTliLAlZOeahOacgOefrei3r+W+hOS4uu+8micsIGosIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZCAnLCBqKTsgcHJuX3Bhc3Moaiwgayk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfmnIDnn63ot6/lvoTplb/luqbkuLrvvJogJWQnLCBhW2pdW2tdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcHJuX3Bhc3Moaiwgaykge1xyXG4gICAgICAgICAgICBpZiAocGF0aFtqXVtrXSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHBybl9wYXNzKGosIHBhdGhbal1ba10pO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJywgJWQnLCBwYXRoW2pdW2tdKTtcclxuICAgICAgICAgICAgICAgIHBybl9wYXNzKHBhdGhbal1ba10sIGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgY3JlYXRlREcgPSBjcmVhdGVHcmFwaChERyk7XHJcbmxldCBjcmVhdGVETiA9IGNyZWF0ZUdyYXBoKEROKTtcclxubGV0IGNyZWF0ZVVERyA9IGNyZWF0ZUdyYXBoKFVERyk7XHJcbmxldCBjcmVhdGVVRE4gPSBjcmVhdGVHcmFwaChVRE4pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlR3JhcGgoa2luZCkge1xyXG4gICAgbGV0IGFkajtcclxuICAgIGxldCBzZXRNYXRyaXhWYWx1ZTtcclxuXHJcbiAgICBpZiAoa2luZCA9PT0gMiB8fCBraW5kID09PSA0KSB7XHJcbiAgICAgICAgYWRqID0gSW5maW5pdHk7XHJcbiAgICAgICAgc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9tcHQoJ3dlaWdodDogJyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRqID0gMDtcclxuICAgICAgICBzZXRNYXRyaXhWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKEFkamFjZW5jeU1hdHJpeEdyYXBoKSB7XHJcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtID0gcGFyc2VJbnQocHJvbXB0KCd2ZXhudW06ICcpLCAxMCk7XHJcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtID0gcGFyc2VJbnQocHJvbXB0KCdhcmNudW06ICcpLCAxMCk7XHJcbiAgICAgICAgLy8gaW5jSW5mb+S4ujDliJnlkITlvKfkuI3lkKvlhbbku5bkv6Hmga9cclxuICAgICAgICBsZXQgaW5jSW5mbyA9IHBhcnNlSW50KHByb21wdCgnaW5jSW5mbzogJyksIDEwKTtcclxuXHJcbiAgICAgICAgLy8g5p6E6YCg6aG254K55ZCR6YePXHJcbiAgICAgICAgbGV0IGksIGo7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bTsgKytpKSBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhzW2ldID0gcHJvbXB0KCfpobbngrnlkJHph492ZXg6ICcpO1xyXG5cclxuICAgICAgICAvLyDliJ3lp4vljJbpgrvmjqXnn6npmLVcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldID0gQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal0gPSBuZXcgQXJjQ2VsbChhZGosIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmnoTpgKDpgrvmjqXnn6npmLVcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY251bTsgKytrKSB7XHJcbiAgICAgICAgICAgIC8vIOi+k+WFpeS4gOadoei+ueS+nemZhOeahOmhtueCueWPiuadg+WAvFxyXG4gICAgICAgICAgICBsZXQgdjEgPSBwcm9tcHQoJ3YxOiAnKTtcclxuICAgICAgICAgICAgbGV0IHYyID0gcHJvbXB0KCd2MjogJyk7XHJcblxyXG4gICAgICAgICAgICAvLyDnoa7lrpp2Me+8jHYy5ZyoR+S4reeahOS9jee9rlxyXG4gICAgICAgICAgICBpID0gQWRqYWNlbmN5TWF0cml4R3JhcGgubG9jYXRlVmV4KHYxKTtcclxuICAgICAgICAgICAgaiA9IEFkamFjZW5jeU1hdHJpeEdyYXBoLmxvY2F0ZVZleCh2Mik7XHJcblxyXG4gICAgICAgICAgICBsZXQgdyA9IHNldE1hdHJpeFZhbHVlKCk7XHJcbiAgICAgICAgICAgIC8vIOW8pzx2MSwgdjI+55qE5p2D5YC8XHJcbiAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal0uYWRqID0gdztcclxuICAgICAgICAgICAgaWYgKGluY0luZm8pIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal0uaW5mbyA9IHByb21wdCgnaW5mbzogJyk7XHJcbiAgICAgICAgICAgIGlmIChraW5kID09PSAzIHx8IGtpbmQgPT09IDQpIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3Nbal1baV0gPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8vIOesrOS4gOenjeWIm+W7uuWbvuaWueazlVxyXG5sZXQgdmV4cyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XHJcbmxldCBhcmNzID0gW1xyXG4gICAgW1xyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjZcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjJcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIHtcImFkalwiOiBcIjZcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjRcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIHtcImFkalwiOiBcIjJcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjFcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjRcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjFcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjVcIiwgXCJpbmZvXCI6IG51bGx9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBcIjVcIiwgXCJpbmZvXCI6IG51bGx9LFxyXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9XHJcbiAgICBdXHJcbl07XHJcbmxldCB1ZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgodmV4cywgYXJjcywgNSwgNywgNCk7XHJcblxyXG4vLyDnrKzkuoznp43liJvlu7rlm77mlrnms5VcclxubGV0IGRuID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgMik7XHJcbmRuLmFkZFZlcnRleCgnYScpO1xyXG5kbi5hZGRWZXJ0ZXgoJ2InKTtcclxuZG4uYWRkVmVydGV4KCdjJyk7XHJcbmRuLmFkZFZlcnRleCgnZCcpO1xyXG5kbi5hZGRWZXJ0ZXgoJ2UnKTtcclxuXHJcbmRuLmFkZEFyYygnYScsICdiJywge1xyXG4gICAgYWRqOiA2XHJcbn0pO1xyXG5kbi5hZGRBcmMoJ2EnLCAnYycsIHtcclxuICAgIGFkajogMlxyXG59KTtcclxuZG4uYWRkQXJjKCdjJywgJ2InLCB7XHJcbiAgICBhZGo6IDNcclxufSk7XHJcbmRuLmFkZEFyYygnYycsICdkJywge1xyXG4gICAgYWRqOiAxXHJcbn0pO1xyXG5kbi5hZGRBcmMoJ2QnLCAnYicsIHtcclxuICAgIGFkajogNFxyXG59KTtcclxuZG4uYWRkQXJjKCdiJywgJ2UnLCB7XHJcbiAgICBhZGo6IDNcclxufSk7XHJcbmRuLmFkZEFyYygnZCcsICdlJywge1xyXG4gICAgYWRqOiA1XHJcbn0pO1xyXG5cclxuY29uc29sZS5sb2coZG4pO1xyXG5cclxuLypcclxuXHJcbiAvLyDnrKzkuInnp43liJvlu7rlm77mlrnms5VcclxuIGxldCBnID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKCk7XHJcbiBnLmtpbmQgPSBETjtcclxuIGcuY3JlYXRlR3JhcGgoKTtcclxuIGNvbnNvbGUubG9nKGcpO1xyXG5cclxuICovXHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG4g5Zu+55qE6YGN5Y6GXHJcblxyXG4g5Zu+55qE6YGN5Y6GKFRyYXZlcmluZyBHcmFwaCnvvJrku47lm77nmoTmn5DkuIDpobbngrnlh7rlj5HvvIzorr/pgY3lm77kuK3nmoTlhbbkvZnpobbngrnvvIzkuJTmr4/kuKrpobbngrnku4Xooqvorr/pl67kuIDmrKHjgILlm77nmoTpgY3ljobnrpfms5XmmK/lkITnp43lm77nmoTmk43kvZznmoTln7rnoYDjgIJcclxuXHJcbiDil4Yg5aSN5p2C5oCn77ya5Zu+55qE5Lu75oSP6aG254K55Y+v6IO95ZKM5YW25L2Z55qE6aG254K555u46YK75o6l77yM5Y+v6IO95Zyo6K6/6Zeu5LqG5p+Q5Liq6aG254K55ZCO77yM5rK/5p+Q5p2h6Lev5b6E5pCc57Si5ZCO5Y+I5Zue5Yiw5Y6f6aG254K544CCXHJcbiDil4Yg6Kej5Yaz5Yqe5rOV77ya5Zyo6YGN5Y6G6L+H56iL5Lit6K6w5LiL5bey6KKr6K6/6Zeu6L+H55qE6aG254K544CC6K6+572u5LiA5Liq6L6F5Yqp5ZCR6YePVmlzaXRlZFsx4oCmbl0obuS4uumhtueCueaVsCnvvIzlhbbliJ3lgLzkuLow77yM5LiA5pem6K6/6Zeu5LqG6aG254K5dmnlkI7vvIzkvb9WaXNpdGVkW2ld5Li6MeaIluS4uuiuv+mXrueahOasoeW6j+WPt+OAglxyXG4g5Zu+55qE6YGN5Y6G566X5rOV5pyJ5rex5bqm5LyY5YWI5pCc57Si566X5rOV5ZKM5bm/5bqm5LyY5YWI5pCc57Si566X5rOV44CCXHJcblxyXG4g5rex5bqm5LyY5YWI5pCc57SiKERlcHRoIEZpcnN0IFNlYXJjaC0tREZTKemBjeWOhuexu+S8vOagkeeahOWFiOW6j+mBjeWOhu+8jOaYr+agkeeahOWFiOW6j+mBjeWOhueahOaOqOW5v+OAglxyXG5cclxuIOeul+azleaAneaDs1xyXG4g6K6+5Yid5aeL54q25oCB5pe25Zu+5Lit55qE5omA5pyJ6aG254K55pyq6KKr6K6/6Zeu77yM5YiZ77yaXHJcbiDikbQg77ya5LuO5Zu+5Lit5p+Q5Liq6aG254K5dmnlh7rlj5HvvIzorr/pl652ae+8m+eEtuWQjuaJvuWIsHZp55qE5LiA5Liq6YK75o6l6aG254K5dmkxIO+8m1xyXG4g4pG177ya5LuOdmkx5Ye65Y+R77yM5rex5bqm5LyY5YWI5pCc57Si6K6/6Zeu5ZKMdmkx55u46YK75o6l5LiU5pyq6KKr6K6/6Zeu55qE5omA5pyJ6aG254K577ybXHJcbiDikbbvvJrovazikbQg77yM55u05Yiw5ZKMdmnnm7jpgrvmjqXnmoTmiYDmnInpobbngrnpg73ooqvorr/pl67kuLrmraJcclxuIOKRtyDvvJrnu6fnu63pgInlj5blm77kuK3mnKrooqvorr/pl67pobbngrl2auS9nOS4uui1t+Wni+mhtueCue+8jOi9rCgxKe+8jOebtOWIsOWbvuS4reaJgOaciemhtueCuemDveiiq+iuv+mXruS4uuatouOAglxyXG5cclxuXHJcbiDlub/luqbkvJjlhYjmkJzntKIoQnJlYWR0aCBGaXJzdCBTZWFyY2gtLUJGUynpgY3ljobnsbvkvLzmoJHnmoTmjInlsYLmrKHpgY3ljobnmoTov4fnqIvjgIJcclxuXHJcbiDnrpfms5XmgJ3mg7NcclxuIOiuvuWIneWni+eKtuaAgeaXtuWbvuS4reeahOaJgOaciemhtueCueacquiiq+iuv+mXru+8jOWIme+8mlxyXG4g4pG0IO+8muS7juWbvuS4reafkOS4qumhtueCuXZp5Ye65Y+R77yM6K6/6ZeudmnvvJtcclxuIOKRte+8muiuv+mXrnZp55qE5omA5pyJ55u46YK75o6l5LiU5pyq6KKr6K6/6Zeu55qE5omA5pyJ6aG254K5dmkx77yMdmky77yM4oCm77yMdmlt77ybXHJcbiDikbbvvJrku6V2aTHvvIx2aTLvvIwg4oCm77yMdmlt55qE5qyh5bqP77yM5LuldmlqKDHiiaZq4ommbSnkvp3mraTkvZzkuLp2aSDvvIzovazikbTvvJtcclxuIOKRtyDvvJrnu6fnu63pgInlj5blm77kuK3mnKrooqvorr/pl67pobbngrl2a+S9nOS4uui1t+Wni+mhtueCue+8jOi9rOKRtO+8jOebtOWIsOWbvuS4reaJgOaciemhtueCuemDveiiq+iuv+mXruS4uuatouOAglxyXG5cclxuIOeUqOW5v+W6puS8mOWFiOaQnOe0oueul+azlemBjeWOhuWbvuS4jua3seW6puS8mOWFiOaQnOe0oueul+azlemBjeWOhuWbvueahOWUr+S4gOWMuuWIq+aYr+mCu+aOpeeCueaQnOe0ouasoeW6j+S4jeWQjC5cclxuICovXHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdERlNUcmF2ZXJzZTogdWRuJyk7XHJcblxyXG5sZXQgZzEgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBVREcpO1xyXG5nMS5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmcxLmFkZFZlcnRleCgndjMnKTtcclxuZzEuYWRkVmVydGV4KCd2MicpO1xyXG5nMS5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmcxLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmcxLmFkZEFyYygndjUnLCAndjQnKTtcclxuZzEuYWRkQXJjKCd2MycsICd2MScpO1xyXG5nMS5hZGRBcmMoJ3YyJywgJ3YxJyk7XHJcbmcxLmFkZEFyYygndjMnLCAndjInKTtcclxuXHJcblxyXG5nMS5ERlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xyXG4gICAgY29uc29sZS5sb2codGhpcy52ZXhzW3ZdKTtcclxufSk7XHJcblxyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZygnREZTVHJhdmVyc2VfTm9uUmVjdXJzZTogdWRuJyk7XHJcbmcxLkRGU1RyYXZlcnNlX05vblJlY3Vyc2UoZnVuY3Rpb24gKHYpIHtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMudmV4c1t2XSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coJ0JGU1RyYXZlcnNlOiAnKTtcclxubGV0IGJzZkcgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBERyk7XHJcbmJzZkcuYWRkVmVydGV4KCd2MScpO1xyXG5ic2ZHLmFkZFZlcnRleCgndjInKTtcclxuYnNmRy5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmJzZkcuYWRkVmVydGV4KCd2NCcpO1xyXG5ic2ZHLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmJzZkcuYWRkQXJjKCd2MScsICd2NCcpO1xyXG5ic2ZHLmFkZEFyYygndjEnLCAndjInKTtcclxuYnNmRy5hZGRBcmMoJ3YzJywgJ3Y1Jyk7XHJcbmJzZkcuYWRkQXJjKCd2MycsICd2MicpO1xyXG5ic2ZHLmFkZEFyYygndjMnLCAndjEnKTtcclxuYnNmRy5hZGRBcmMoJ3Y0JywgJ3YzJyk7XHJcbmJzZkcuYWRkQXJjKCd2NScsICd2NCcpO1xyXG5cclxuYnNmRy5CRlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xyXG4gICAgY29uc29sZS5sb2codGhpcy52ZXhzW3ZdKTtcclxufSk7XHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG4g5pyA5bCP55Sf5oiQ5qCRXHJcblxyXG4g5aaC5p6c6L+e6YCa5Zu+5piv5LiA5Liq5bim5p2D5Zu+77yM5YiZ5YW255Sf5oiQ5qCR5Lit55qE6L655Lmf5bim5p2D77yM55Sf5oiQ5qCR5Lit5omA5pyJ6L6555qE5p2D5YC85LmL5ZKM56ew5Li655Sf5oiQ5qCR55qE5Luj5Lu344CCXHJcblxyXG4g5pyA5bCP55Sf5oiQ5qCRKE1pbmltdW0gU3Bhbm5pbmcgVHJlZSkg77ya5bim5p2D6L+e6YCa5Zu+5Lit5Luj5Lu35pyA5bCP55qE55Sf5oiQ5qCR56ew5Li65pyA5bCP55Sf5oiQ5qCR44CCXHJcblxyXG4g5pyA5bCP55Sf5oiQ5qCR5Zyo5a6e6ZmF5Lit5YW35pyJ6YeN6KaB55So6YCU77yM5aaC6K6+6K6h6YCa5L+h572R44CC6K6+5Zu+55qE6aG254K56KGo56S65Z+O5biC77yM6L656KGo56S65Lik5Liq5Z+O5biC5LmL6Ze055qE6YCa5L+h57q/6Lev77yM6L6555qE5p2D5YC86KGo56S65bu66YCg6YCa5L+h57q/6Lev55qE6LS555So44CCbuS4quWfjuW4guS5i+mXtOacgOWkmuWPr+S7peW7um7vgrQobi0xKS8y5p2h57q/6Lev77yM5aaC5L2V6YCJ5oup5YW25Lit55qEbi0x5p2h77yM5L2/5oC755qE5bu66YCg6LS555So5pyA5L2OP1xyXG5cclxuIOaehOmAoOacgOWwj+eUn+aIkOagkeeahOeul+azleacieiuuOWkmu+8jOWfuuacrOWOn+WImeaYr++8mlxyXG4g4peGIOWwveWPr+iDvemAieWPluadg+WAvOacgOWwj+eahOi+ue+8jOS9huS4jeiDveaehOaIkOWbnui3r++8m1xyXG4g4peGIOmAieaLqW4tMeadoei+ueaehOaIkOacgOWwj+eUn+aIkOagkeOAglxyXG4g5Lul5LiK55qE5Z+65pys5Y6f5YiZ5piv5Z+65LqOTVNU55qE5aaC5LiL5oCn6LSo77yaXHJcbiDorr5HPShW77yMRSnmmK/kuIDkuKrluKbmnYPov57pgJrlm77vvIxV5piv6aG254K56ZuGVueahOS4gOS4qumdnuepuuWtkOmbhuOAguiLpXXiiIhVIO+8jHbiiIhWLVXvvIzkuJQodSwgdinmmK9V5Lit6aG254K55YiwVi1V5Lit6aG254K55LmL6Ze05p2D5YC85pyA5bCP55qE6L6577yM5YiZ5b+F5a2Y5Zyo5LiA5qO15YyF5ZCr6L65KHUsIHYp55qE5pyA5bCP55Sf5oiQ5qCR44CCXHJcblxyXG4g6K+B5piO77yaIOeUqOWPjeivgeazleivgeaYjuOAglxyXG4g6K6+5Zu+R+eahOS7u+S9leS4gOajteacgOWwj+eUn+aIkOagkemDveS4jeWMheWQq+i+uSh1LHYp44CC6K6+VOaYr0fnmoTkuIDmo7XnlJ/miJDmoJHvvIzliJlU5piv6L+e6YCa55qE77yM5LuOdeWIsHblv4XmnInkuIDmnaHot6/lvoQodSzigKYsdinvvIzlvZPlsIbovrkodSx2KeWKoOWFpeWIsFTkuK3ml7blsLHmnoTmiJDkuoblm57ot6/jgILliJnot6/lvoQodSwg4oCmLHYp5Lit5b+F5pyJ5LiA5p2h6L65KHXigJksduKAmSkg77yM5ruh6LazdeKAmeKIiFUg77yMduKAmeKIiFYtVSDjgILliKDljrvovrkodeKAmSx24oCZKSDkvr/lj6/mtojpmaTlm57ot6/vvIzlkIzml7blvpfliLDlj6bkuIDmo7XnlJ/miJDmoJFU4oCZ44CCXHJcbiDnlLHkuo4odSx2KeaYr1XkuK3pobbngrnliLBWLVXkuK3pobbngrnkuYvpl7TmnYPlgLzmnIDlsI/nmoTovrnvvIzmlYUodSx2KeeahOadg+WAvOS4jeS8mumrmOS6jih14oCZLHbigJkp55qE5p2D5YC877yMVOKAmeeahOS7o+S7t+S5n+S4jeS8mumrmOS6jlTvvIwgVOKAmeaYr+WMheWQqyh1LHYpIOeahOS4gOajteacgOWwj+eUn+aIkOagke+8jOS4juWBh+iuvuefm+ebvuOAglxyXG5cclxuICovXHJcblxyXG4vKlxyXG4g5pmu6YeM5aeGKFByaW0p566X5rOVXHJcblxyXG4g6YCC5ZCI6L6556ig5a+G55qE572RXHJcblxyXG4g5LuO6L+e6YCa572RTj0oVe+8jEUp5Lit5om+5pyA5bCP55Sf5oiQ5qCRVD0oVe+8jFRFKSDjgIJcclxuXHJcbiAxIOeul+azleaAneaDs1xyXG4g4pG0ICDoi6Xku47pobbngrl2MOWHuuWPkeaehOmAoO+8jFU9e3Ywfe+8jFRFPXt977ybXHJcbiDikbUg5YWI5om+5p2D5YC85pyA5bCP55qE6L65KHXvvIx2Ke+8jOWFtuS4rXXiiIhV5LiUduKIiFYtVe+8jOW5tuS4lOWtkOWbvuS4jeaehOaIkOeOr++8jOWImVU9IFXiiKp7dn3vvIxURT1UReKIqnsode+8jHYpfSDvvJtcclxuIOKRtiDph43lpI3ikbUg77yM55u05YiwVT1W5Li65q2i44CC5YiZVEXkuK3lv4XmnIluLTHmnaHovrnvvIwgVD0oVe+8jFRFKeWwseaYr+acgOWwj+eUn+aIkOagkeOAglxyXG5cclxuIDIu566X5rOV5a6e546w6K+05piOXHJcbiDkuLrkvr/kuo7nrpfms5Xlrp7njrDvvIzorr7nva7kuIDkuKrkuIDnu7TmlbDnu4RjbG9zZWRnZVtuXe+8jOeUqOadpeS/neWtmFYtIFXkuK3lkITpobbngrnliLBV5Lit6aG254K55YW35pyJ5p2D5YC85pyA5bCP55qE6L6544CCXHJcbiBjbG9zZWRnZVtqXS5hZGp2ZXg9a++8jOihqOaYjui+uSh2aiwgdmsp5pivVi1V5Lit6aG254K5dmrliLBV5Lit5p2D5YC85pyA5bCP55qE6L6577yM6ICM6aG254K5dmvmmK/or6XovrnmiYDkvp3pmYTnmoRV5Lit55qE6aG254K544CCIGNsb3NlZGdlW2pdLmxvd2Nvc3TlrZjmlL7or6XovrnnmoTmnYPlgLzjgIJcclxuIOWBh+iuvuS7jumhtueCuXZz5byA5aeL5p6E6YCg5pyA5bCP55Sf5oiQ5qCR44CC5Yid5aeL5pe25Luk77yaXHJcbiBDbG9zZWRnZVtzXS5sb3djb3N0PTAg77ya6KGo5piO6aG254K5dnPpppblhYjliqDlhaXliLBV5Lit77ybXHJcbiBDbG9zZWRnZVtrXS5hZGp2ZXg9cyDvvIxDbG9zZWRnZVtrXS5sb3djb3N0PWNvc3QoaywgcylcclxuIOihqOekulYtVeS4reeahOWQhOmhtueCueWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrkoa+KJoHMpIO+8jGNvc3QoaywgcynooajnpLrovrkodmssIHZzKSDmnYPlgLzjgIJcclxuXHJcbiAzLueul+azleatpemqpFxyXG4g4pG0ICDku45jbG9zZWRnZeS4remAieaLqeS4gOadoeadg+WAvCjkuI3kuLowKeacgOWwj+eahOi+uSh2aywgdmopIO+8jOeEtuWQjuWBmu+8mlxyXG4g4pGgIOe9rmNsb3NlZGdlW2tdLmxvd2Nvc3TkuLowIO+8jOihqOekunZr5bey5Yqg5YWl5YiwVeS4reOAglxyXG4g4pGhICDmoLnmja7mlrDliqDlhaV2a+eahOabtOaWsGNsb3NlZGdl5Lit5q+P5Liq5YWD57Sg77yaXHJcbiDvgKJ2aeKIiFYtVSDvvIzoi6Vjb3N0KGksIGsp4ommY29sc2VkZ2VbaV0ubG93Y29zdO+8jOihqOaYjuWcqFXkuK3mlrDliqDlhaXpobbngrl2a+WQju+8jCAodmksIHZrKeaIkOS4unZp5YiwVeS4readg+WAvOacgOWwj+eahOi+ue+8jOe9ru+8mlxyXG4gQ2xvc2VkZ2VbaV0ubG93Y29zdD1jb3N0KGksIGspXHJcbiBDbG9zZWRnZVtpXS5hZGp2ZXg9a1xyXG4g4pG1ICDph43lpI3ikbRuLTHmrKHlsLHlvpfliLDmnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiDnrpfms5XliIbmnpDvvJpcclxuIOiuvuW4puadg+i/numAmuWbvuaciW7kuKrpobbngrnvvIzliJnnrpfms5XnmoTkuLvopoHmiafooYzmmK/kuozph43lvqrnjq/vvJog5rGCY2xvc2VkZ2XkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIzpopHluqbkuLpuLTHvvJsg5L+u5pS5Y2xvc2VkZ2XmlbDnu4TvvIzpopHluqbkuLpuIOOAguWboOatpO+8jOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08objIp77yM5LiO6L6555qE5pWw55uu5peg5YWz44CCXHJcblxyXG4gKi9cclxuXHJcbnVkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIDQpO1xyXG51ZG4uYWRkVmVydGV4KCd2MScpO1xyXG51ZG4uYWRkVmVydGV4KCd2MicpO1xyXG51ZG4uYWRkVmVydGV4KCd2MycpO1xyXG51ZG4uYWRkVmVydGV4KCd2NCcpO1xyXG51ZG4uYWRkVmVydGV4KCd2NScpO1xyXG51ZG4uYWRkVmVydGV4KCd2NicpO1xyXG5cclxudWRuLmFkZEFyYygndjEnLCAndjInLCB7YWRqOiA2fSk7XHJcbnVkbi5hZGRBcmMoJ3YxJywgJ3YzJywge2FkajogMX0pO1xyXG51ZG4uYWRkQXJjKCd2MScsICd2NCcsIHthZGo6IDV9KTtcclxudWRuLmFkZEFyYygndjInLCAndjMnLCB7YWRqOiA1fSk7XHJcbnVkbi5hZGRBcmMoJ3YyJywgJ3Y1Jywge2FkajogM30pO1xyXG51ZG4uYWRkQXJjKCd2MycsICd2NCcsIHthZGo6IDV9KTtcclxudWRuLmFkZEFyYygndjMnLCAndjUnLCB7YWRqOiA2fSk7XHJcbnVkbi5hZGRBcmMoJ3YzJywgJ3Y2Jywge2FkajogNH0pO1xyXG51ZG4uYWRkQXJjKCd2NCcsICd2NicsIHthZGo6IDJ9KTtcclxudWRuLmFkZEFyYygndjUnLCAndjYnLCB7YWRqOiA2fSk7XHJcblxyXG5jb25zb2xlLmxvZygnbWluU3BhblRyZWVfUFJJTTogJyk7XHJcbmNvbnNvbGUubG9nKHVkbi5taW5TcGFuVHJlZV9QUklNKDApKTtcclxuXHJcblxyXG5cclxuLypcclxuIOWFi+mygeaWr+WNoeWwlChLcnVza2FsKeeul+azlVxyXG5cclxuIOmAguWQiOi+ueeogOeWj+eahOe9kVxyXG5cclxuIDEg566X5rOV5oCd5oOzXHJcbiDorr5HPShWLCBFKeaYr+WFt+aciW7kuKrpobbngrnnmoTov57pgJrnvZHvvIxUPShVLCBURSnmmK/lhbbmnIDlsI/nlJ/miJDmoJHjgILliJ3lgLzvvJpVPVbvvIxURT17fSDjgIJcclxuIOWvuUfkuK3nmoTovrnmjInmnYPlgLzlpKflsI/ku47lsI/liLDlpKfkvp3mrKHpgInlj5bjgIJcclxuIOKRtCAgIOmAieWPluadg+WAvOacgOWwj+eahOi+uSh2ae+8jHZqKe+8jOiLpei+uSh2ae+8jHZqKeWKoOWFpeWIsFRF5ZCO5b2i5oiQ5Zue6Lev77yM5YiZ6IiN5byD6K+l6L65KOi+uSh2ae+8jHZqKSDvvJvlkKbliJnvvIzlsIbor6XovrnlubblhaXliLBUReS4re+8jOWNs1RFPVRF4oiqeyh2ae+8jHZqKX0g44CCXHJcbiDikbUg6YeN5aSN4pG0IO+8jOebtOWIsFRF5Lit5YyF5ZCr5pyJbi0x5p2h6L655Li65q2i44CCXHJcbiDlpoLlm743LTIy5omA5o+Q56S644CCXHJcblxyXG4gMiDnrpfms5Xlrp7njrDor7TmmI5cclxuIEtydXNrYWznrpfms5Xlrp7njrDnmoTlhbPplK7mmK/vvJrlvZPkuIDmnaHovrnliqDlhaXliLBUReeahOmbhuWQiOWQju+8jOWmguS9leWIpOaWreaYr+WQpuaehOaIkOWbnui3rz9cclxuIOeugOWNleeahOino+WGs+aWueazleaYr++8muWumuS5ieS4gOS4quS4gOe7tOaVsOe7hFZzZXRbbl0g77yM5a2Y5pS+5Zu+VOS4reavj+S4qumhtueCueaJgOWcqOeahOi/numAmuWIhumHj+eahOe8luWPt+OAglxyXG4g4peGIOWIneWAvO+8mlZzZXRbaV09ae+8jOihqOekuuavj+S4qumhtueCueWQhOiHque7hOaIkOS4gOS4qui/numAmuWIhumHj++8jOi/numAmuWIhumHj+eahOe8luWPt+eugOWNleWcsOS9v+eUqOmhtueCueWcqOWbvuS4reeahOS9jee9rijnvJblj7cp44CCXHJcbiDil4Yg5b2T5b6AVOS4reWinuWKoOS4gOadoei+uSh2ae+8jHZqKSDml7bvvIzlhYjmo4Dmn6VWc2V0W2ld5ZKMVnNldFtqXeWAvO+8mlxyXG4g4piGIOiLpVZzZXRbaV09VnNldFtqXe+8muihqOaYjnZp5ZKMdmrlpITlnKjlkIzkuIDkuKrov57pgJrliIbph4/kuK3vvIzliqDlhaXmraTovrnkvJrlvaLmiJDlm57ot6/vvJtcclxuIOKYhiDoi6VWc2V0W2ld4omgVnNldFtqXe+8jOWImeWKoOWFpeatpOi+ueS4jeS8muW9ouaIkOWbnui3r++8jOWwhuatpOi+ueWKoOWFpeWIsOeUn+aIkOagkeeahOi+uembhuS4reOAglxyXG4g4peGIOWKoOWFpeS4gOadoeaWsOi+ueWQju+8jOWwhuS4pOS4quS4jeWQjOeahOi/numAmuWIhumHj+WQiOW5tu+8muWwhuS4gOS4qui/numAmuWIhumHj+eahOe8luWPt+aNouaIkOWPpuS4gOS4qui/numAmuWIhumHj+eahOe8luWPt+OAglxyXG5cclxuICovXHJcblxyXG5jb25zb2xlLmxvZygnbWluU3BhblRyZWVfS3J1c2thbDogJyk7XHJcbmNvbnNvbGUubG9nKHVkbi5taW5TcGFuVHJlZV9LcnVza2FsKCkpO1xyXG5cclxuXHJcblxyXG5cclxuLypcclxuIOacgOefrei3r+W+hFxyXG5cclxuIOiLpeeUqOW4puadg+WbvuihqOekuuS6pOmAmue9ke+8jOWbvuS4remhtueCueihqOekuuWcsOeCue+8jOi+ueS7o+ihqOS4pOWcsOS5i+mXtOacieebtOaOpemBk+i3r++8jOi+ueS4iueahOadg+WAvOihqOekuui3r+eoiyjmiJbmiYDoirHotLnnlKjmiJbml7bpl7QpIOOAguS7juS4gOS4quWcsOaWueWIsOWPpuS4gOS4quWcsOaWueeahOi3r+W+hOmVv+W6puihqOekuuivpei3r+W+hOS4iuWQhOi+ueeahOadg+WAvOS5i+WSjOOAgumXrumimO+8mlxyXG4g4peGIOS4pOWcsOS5i+mXtOaYr+WQpuaciemAmui3rz9cclxuIOKXhiDlnKjmnInlpJrmnaHpgJrot6/nmoTmg4XlhrXkuIvvvIzlk6rmnaHmnIDnn60/XHJcbiDogIPomZHliLDkuqTpgJrnvZHnmoTmnInlkJHmgKfvvIznm7TmjqXorqjorrrnmoTmmK/luKbmnYPmnInlkJHlm77nmoTmnIDnn63ot6/lvoTpl67popjvvIzkvYbop6PlhrPpl67popjnmoTnrpfms5XkuZ/pgILnlKjkuo7ml6DlkJHlm77jgIJcclxuIOWwhuS4gOS4qui3r+W+hOeahOi1t+Wni+mhtueCueensOS4uua6kOeCue+8jOacgOWQjuS4gOS4qumhtueCueensOS4uue7iOeCueOAglxyXG5cclxuXHJcbiDljZXmupDngrnmnIDnn63ot6/lvoRcclxuXHJcbiDlr7nkuo7nu5nlrprnmoTmnInlkJHlm75HPShW77yMRSnlj4rljZXkuKrmupDngrlWc++8jOaxglZz5YiwR+eahOWFtuS9meWQhOmhtueCueeahOacgOefrei3r+W+hOOAglxyXG4g6ZKI5a+55Y2V5rqQ54K555qE5pyA55+t6Lev5b6E6Zeu6aKY77yMRGlqa3N0cmHmj5Dlh7rkuobkuIDnp43mjInot6/lvoTplb/luqbpgJLlop7mrKHluo/kuqfnlJ/mnIDnn63ot6/lvoTnmoTnrpfms5XvvIzljbPov6rmnbDmlq/nibnmi4koRGlqa3N0cmEp566X5rOV44CCXHJcblxyXG4gMSDln7rmnKzmgJ3mg7NcclxuIOS7juWbvueahOe7meWumua6kOeCueWIsOWFtuWug+WQhOS4qumhtueCueS5i+mXtOWuouinguS4iuW6lOWtmOWcqOS4gOadoeacgOefrei3r+W+hO+8jOWcqOi/mee7hOacgOefrei3r+W+hOS4re+8jOaMieWFtumVv+W6pueahOmAkuWinuasoeW6j++8jOS+neasoeaxguWHuuWIsOS4jeWQjOmhtueCueeahOacgOefrei3r+W+hOWSjOi3r+W+hOmVv+W6puOAglxyXG4g5Y2z5oyJ6ZW/5bqm6YCS5aKe55qE5qyh5bqP55Sf5oiQ5ZCE6aG254K555qE5pyA55+t6Lev5b6E77yM5Y2z5YWI5rGC5Ye66ZW/5bqm5pyA5bCP55qE5LiA5p2h5pyA55+t6Lev5b6E77yM54S25ZCO5rGC5Ye66ZW/5bqm56ys5LqM5bCP55qE5pyA55+t6Lev5b6E77yM5L6d5q2k57G75o6o77yM55u05Yiw5rGC5Ye66ZW/5bqm5pyA6ZW/55qE5pyA55+t6Lev5b6E44CCXHJcblxyXG4gMiDnrpfms5XmgJ3mg7Por7TmmI5cclxuIOiuvue7meWumua6kOeCueS4ulZz77yMU+S4uuW3suaxguW+l+acgOefrei3r+W+hOeahOe7iOeCuembhu+8jOW8gOWni+aXtuS7pFM9e1ZzfSDjgILlvZPmsYLlvpfnrKzkuIDmnaHmnIDnn63ot6/lvoQoVnMg77yMVmkp5ZCO77yMU+S4untWc++8jFZpfSDjgILmoLnmja7ku6XkuIvnu5Porrrlj6/msYLkuIvkuIDmnaHmnIDnn63ot6/lvoTjgIJcclxuIOiuvuS4i+S4gOadoeacgOefrei3r+W+hOe7iOeCueS4ulZqIO+8jOWImVZq5Y+q5pyJ77yaXHJcbiDil4YgIOa6kOeCueWIsOe7iOeCueacieebtOaOpeeahOW8pzxWc++8jFZqPu+8m1xyXG4g4peGIOS7jlZzIOWHuuWPkeWIsFZqIOeahOi/meadoeacgOefrei3r+W+hOaJgOe7j+i/h+eahOaJgOacieS4remXtOmhtueCueW/heWumuWcqFPkuK3jgILljbPlj6rmnInov5nmnaHmnIDnn63ot6/lvoTnmoTmnIDlkI7kuIDmnaHlvKfmiY3mmK/ku45T5YaF5p+Q5Liq6aG254K56L+e5o6l5YiwU+WklueahOmhtueCuVZqIOOAglxyXG4g6Iul5a6a5LmJ5LiA5Liq5pWw57uEZGlzdFtuXe+8jOWFtuavj+S4qmRpc3RbaV3liIbph4/kv53lrZjku45WcyDlh7rlj5HkuK3pl7Tlj6rnu4/ov4fpm4blkIhT5Lit55qE6aG254K56ICM5Yiw6L6+VmnnmoTmiYDmnInot6/lvoTkuK3plb/luqbmnIDlsI/nmoTot6/lvoTplb/luqblgLzvvIzliJnkuIvkuIDmnaHmnIDnn63ot6/lvoTnmoTnu4jngrlWauW/heWumuaYr+S4jeWcqFPkuK3kuJTlgLzmnIDlsI/nmoTpobbngrnvvIzljbPvvJpcclxuIGRpc3RbaV09TWlueyBkaXN0W2tdfCBWa+KIiFYtUyB9XHJcbiDliKnnlKjkuIrov7DlhazlvI/lsLHlj6/ku6Xkvp3mrKHmib7lh7rkuIvkuIDmnaHmnIDnn63ot6/lvoTjgIJcclxuXHJcbiAzICDnrpfms5XmraXpqqRcclxuIOKRoCDku6RTPXtWc30g77yM55So5bim5p2D55qE6YK75o6l55+p6Zi16KGo56S65pyJ5ZCR5Zu+77yM5a+55Zu+5Lit5q+P5Liq6aG254K5VmnmjInku6XkuIvljp/liJnnva7liJ3lgLzvvJpcclxuIDAgICAgaSA9c1xyXG4gZGlzdFtpXSA9ICAgV3NpICAgICBp4omgc+S4lDx2cyx2aT7iiIhF77yMIHdzaeS4uuW8p+S4iueahOadg+WAvFxyXG4g4oieICAgaeKJoHPkuJQ8dnMsdmk+5LiN5bGe5LqORVxyXG4g4pGhIOmAieaLqeS4gOS4qumhtueCuVZqIO+8jOS9v+W+l++8mlxyXG4gZGlzdFtqXT1NaW57IGRpc3Rba118IFZr4oiIVi1TIH1cclxuIFZq5bCx5piv5rGC5b6X55qE5LiL5LiA5p2h5pyA55+t6Lev5b6E57uI54K577yM5bCGVmog5bm25YWl5YiwU+S4re+8jOWNs1M9U+KIqntWan0g44CCXHJcbiDikaIg5a+5Vi1T5Lit55qE5q+P5Liq6aG254K5Vmsg77yM5L+u5pS5ZGlzdFtrXe+8jOaWueazleaYr++8mlxyXG4g6IulZGlzdFtqXStXams8ZGlzdFtrXe+8jOWImeS/ruaUueS4uu+8mlxyXG4gZGlzdFtrXT1kaXN0W2pdK1dqayAo74CiVmviiIhWLVMgKVxyXG4g4pGjIOmHjeWkjeKRoe+8jOKRou+8jOebtOWIsFM9VuS4uuatouOAglxyXG5cclxuIDQg566X5rOV5a6e546wXHJcbiDnlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIwg5a+5UHJpbeeul+azleeVpeWKoOaUueWKqOWwseaIkOS6hkRpamtzdHJh566X5rOV77yM5bCGUHJpbeeul+azleS4reaxguavj+S4qumhtueCuVZr55qEbG93Y29zdOWAvOeUqGRpc3Rba13ku6Pmm7/ljbPlj6/jgIJcclxuIOKXhiAg6K6+5pWw57uEcHJlW25d5L+d5a2Y5LuOVnPliLDlhbblroPpobbngrnnmoTmnIDnn63ot6/lvoTjgILoi6VwcmVbaV09a++8jOihqOekuuS7jlZzIOWIsFZp55qE5pyA55+t6Lev5b6E5Lit77yMVmnnmoTliY3kuIDkuKrpobbngrnmmK9Wa++8jOWNs+acgOefrei3r+W+hOW6j+WIl+aYryhWcyAsIOKApiwgVmsgICwgVmkpIOOAglxyXG4g4peGIOiuvuaVsOe7hGZpbmFsW25d77yM5qCH6K+G5LiA5Liq6aG254K55piv5ZCm5bey5Yqg5YWlU+S4reOAglxyXG5cclxuIDUgIOeul+azleWIhuaekFxyXG4gRGlqa3N0cmHnrpfms5XnmoTkuLvopoHmiafooYzmmK/vvJpcclxuIOKXhiDmlbDnu4Tlj5jph4/nmoTliJ3lp4vljJbvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4pIO+8m1xyXG4g4peGIOaxguacgOefrei3r+W+hOeahOS6jOmHjeW+queOr++8muaXtumXtOWkjeadguW6puaYr08objIpIO+8m1xyXG4g5Zug5q2k77yM5pW05Liq566X5rOV55qE5pe26Ze05aSN5p2C5bqm5pivTyhuMikg44CCXHJcblxyXG4gKi9cclxuXHJcbmxldCBkaWpUZXN0ID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgRE4pO1xyXG5cclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzAnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzEnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzInKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzMnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzQnKTtcclxuZGlqVGVzdC5hZGRWZXJ0ZXgoJzUnKTtcclxuXHJcbmRpalRlc3QuYWRkQXJjKCcwJywgJzEnLCB7YWRqOiAyMH0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMCcsICc0Jywge2FkajogMTB9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzAnLCAnMicsIHthZGo6IDYwfSk7XHJcbmRpalRlc3QuYWRkQXJjKCcwJywgJzUnLCB7YWRqOiA2NX0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMScsICcyJywge2FkajogMzB9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzInLCAnMycsIHthZGo6IDQwfSk7XHJcbmRpalRlc3QuYWRkQXJjKCc1JywgJzInLCB7YWRqOiAxNX0pO1xyXG5kaWpUZXN0LmFkZEFyYygnNCcsICc1Jywge2FkajogMjB9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzMnLCAnNCcsIHthZGo6IDM1fSk7XHJcbmRpalRlc3QuYWRkQXJjKCcxJywgJzMnLCB7YWRqOiA3MH0pO1xyXG5cclxuZGlqVGVzdC5zaG9ydGVzdFBhdGhfRGlqa3N0cmEoMCk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuLypcclxuIOavj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hFxyXG5cclxuIOeUqERpamtzdHJh566X5rOV5Lmf5Y+v5Lul5rGC5b6X5pyJ5ZCR5Zu+Rz0oVu+8jEUp5Lit5q+P5LiA5a+56aG254K56Ze055qE5pyA55+t6Lev5b6E44CC5pa55rOV5piv77ya5q+P5qyh5Lul5LiA5Liq5LiN5ZCM55qE6aG254K55Li65rqQ54K56YeN5aSNRGlqa3N0cmHnrpfms5Xkvr/lj6/msYLlvpfmr4/kuIDlr7npobbngrnpl7TnmoTmnIDnn63ot6/lvoTvvIzml7bpl7TlpI3mnYLluqbmmK9PKG4zKSDjgIJcclxuXHJcbiDlvJfnvZfkvIrlvrcoRmxveWQp5o+Q5Ye65LqG5Y+m5LiA5Liq566X5rOV77yM5YW25pe26Ze05aSN5p2C5bqm5LuN5pivTyhuMykg77yMIOS9hueul+azleW9ouW8j+abtOS4uueugOaYjuOAglxyXG5cclxuIDEg566X5rOV5oCd5oOzXHJcblxyXG4g6K6+6aG254K56ZuGUyjliJ3lgLzkuLrnqbop77yM55So5pWw57uEQeeahOavj+S4quWFg+e0oEFbaV1bal3kv53lrZjku45WaeWPque7j+i/h1PkuK3nmoTpobbngrnliLDovr5WaueahOacgOefrei3r+W+hOmVv+W6pu+8jOWFtuaAneaDs+aYr++8mlxyXG4g4pGgIOWIneWni+aXtuS7pFM9eyB9IO+8jCBBW2ldW2pd55qE6LWL5Yid5YC85pa55byP5piv77yaXHJcbiAwICAgIGkgPWrml7ZcclxuIEFbaV1bal09ICAgIFdpaiAgICAgaeKJoGrkuJQ8dmksdmo+4oiIRe+8jCB3aWrkuLrlvKfkuIrnmoTmnYPlgLxcclxuIOKIniAgIGniiaBq5LiUPHZpLHZqPuS4jeWxnuS6jkVcclxuIOKRoSDlsIblm77kuK3kuIDkuKrpobbngrlWayDliqDlhaXliLBT5Lit77yM5L+u5pS5QVtpXVtqXeeahOWAvO+8jOS/ruaUueaWueazleaYr++8mlxyXG4gQVtpXVtqXT1NaW57QVtpXVtqXSAsIChBW2ldW2tdK0Fba11bal0pIH1cclxuIOWOn+WboO+8miDku45WauWPque7j+i/h1PkuK3nmoTpobbngrkoVmsp5Yiw6L6+VmrnmoTot6/lvoTplb/luqblj6/og73mr5Tljp/mnaXkuI3nu4/ov4dWa+eahOi3r+W+hOabtOefreOAglxyXG4g4pGiIOmHjeWkjeKRoe+8jOebtOWIsEfnmoTmiYDmnInpobbngrnpg73liqDlhaXliLBT5Lit5Li65q2i44CCXHJcblxyXG4gMiDnrpfms5Xlrp7njrBcclxuXHJcbiDil4YgIOWumuS5ieS6jOe7tOaVsOe7hFBhdGhbbl1bbl0obuS4uuWbvueahOmhtueCueaVsCkg77yM5YWD57SgUGF0aFtpXVtqXeS/neWtmOS7jlZp5YiwVmrnmoTmnIDnn63ot6/lvoTmiYDnu4/ov4fnmoTpobbngrnjgIJcclxuIOKXhiDoi6VQYXRoW2ldW2pdPWvvvJrku45WaeWIsFZqIOe7j+i/h1ZrIO+8jOacgOefrei3r+W+hOW6j+WIl+aYryhWaSAsIOKApiwgVmsgLCDigKYsIFZqKSDvvIzliJnot6/lvoTlrZDluo/liJfvvJooVmkgLCDigKYsIFZrKeWSjChWayAsIOKApiwgVmop5LiA5a6a5piv5LuOVmnliLBWa+WSjOS7jlZr5YiwVmog55qE5pyA55+t6Lev5b6E44CC5LuO6ICM5Y+v5Lul5qC55o2uUGF0aFtpXVtrXeWSjFBhdGhba11bal3nmoTlgLzlho3mib7liLDor6Xot6/lvoTkuIrmiYDnu4/ov4fnmoTlhbblroPpobbngrnvvIzigKbkvp3mraTnsbvmjqjjgIJcclxuIOKXhiDliJ3lp4vljJbkuLpQYXRoW2ldW2pdPS0x77yM6KGo56S65LuOVmnliLBWaiDkuI3nu4/ov4fku7vkvZUoU+S4reeahOS4remXtCnpobbngrnjgILlvZPmn5DkuKrpobbngrlWa+WKoOWFpeWIsFPkuK3lkI7kvb9BW2ldW2pd5Y+Y5bCP5pe277yM5LukUGF0aFtpXVtqXT1r44CCXHJcblxyXG5cclxuICovXHJcblxyXG5sZXQgZmxveWQgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XHJcbmZsb3lkLmFkZFZlcnRleCgndjAnKTtcclxuZmxveWQuYWRkVmVydGV4KCd2MScpO1xyXG5mbG95ZC5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmZsb3lkLmFkZEFyYygndjAnLCAndjInLCB7YWRqOiA4fSk7XHJcbmZsb3lkLmFkZEFyYygndjAnLCAndjEnLCB7YWRqOiAyfSk7XHJcbmZsb3lkLmFkZEFyYygndjEnLCAndjInLCB7YWRqOiA0fSk7XHJcbmZsb3lkLmFkZEFyYygndjInLCAndjAnLCB7YWRqOiA1fSk7XHJcblxyXG5mbG95ZC5zaG9ydGVzdFBhdGhfRkxPWUQoKTtcclxuXHJcbi8vIGh0dHA6Ly9ibG9nLmNzZG4ubmV0L2hndWlzdS9hcnRpY2xlL2RldGFpbHMvNzcxOTQyOFxyXG4vLyDmt7vliqDjgIrlm77nmoTlupTnlKjor6bop6Mt5pWw5o2u57uT5p6E44CLXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvR3JhcGgvQWRqYWNlbmN5TWF0cml4R3JhcGguanNcbiAqKi8iLCIvKlxyXG4g5Y2B5a2X6ZO+6KGo5rOVXHJcblxyXG4g5Y2B5a2X6ZO+6KGoKE9ydGhvZ29uYWwgTGlzdCnmmK/mnInlkJHlm77nmoTlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoTvvIzmmK/lsIbmnInlkJHlm77nmoTmraPpgrvmjqXooajlkozpgIbpgrvmjqXooajnu5PlkIjotbfmnaXlvpfliLDnmoTkuIDnp43pk77ooajjgIJcclxuXHJcbiDlnKjov5nnp43nu5PmnoTkuK3vvIzmr4/mnaHlvKfnmoTlvKflpLTnu5PngrnlkozlvKflsL7nu5Pngrnpg73lrZjmlL7lnKjpk77ooajkuK3vvIzlubblsIblvKfnu5PngrnliIbliKvnu4Tnu4fliLDku6XlvKflsL7nu5PngrnkuLrlpLQo6aG254K5Kee7k+eCueWSjOS7peW8p+WktOe7k+eCueS4uuWktCjpobbngrkp57uT54K555qE6ZO+6KGo5Lit44CCXHJcblxyXG4g4peGICBkYXRh5Z+f77ya5a2Y5YKo5ZKM6aG254K555u45YWz55qE5L+h5oGv77ybXHJcbiDil4Yg5oyH6ZKI5Z+fZmlyc3Rpbu+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WktOeahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xyXG4g4peGIOaMh+mSiOWfn2ZpcnN0b3V077ya5oyH5ZCR5Lul6K+l6aG254K55Li65byn5bC+55qE56ys5LiA5p2h5byn5omA5a+55bqU55qE5byn57uT54K577ybXHJcbiDil4Yg5bC+5Z+fdGFpbHZleO+8muaMh+ekuuW8p+WwvumhtueCueWcqOWbvuS4reeahOS9jee9ru+8m1xyXG4g4peGIOWktOWfn2hlYWR2ZXjvvJrmjIfnpLrlvKflpLTpobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcclxuIOKXhiDmjIfpkojln59obGlua++8muaMh+WQkeW8p+WktOebuOWQjOeahOS4i+S4gOadoeW8p++8m1xyXG4g4peGIOaMh+mSiOWfn3RsaW5r77ya5oyH5ZCR5byn5bC+55u45ZCM55qE5LiL5LiA5p2h5byn77ybXHJcbiDil4YgSW5mb+Wfn++8muaMh+WQkeivpeW8p+eahOebuOWFs+S/oeaBr++8m1xyXG5cclxuIOS7jui/meenjeWtmOWCqOe7k+aehOWbvuWPr+S7peeci+WHuu+8jOS7juS4gOS4qumhtueCuee7k+eCueeahGZpcnN0b3V05Ye65Y+R77yM5rK/6KGo57uT54K555qEdGxpbmvmjIfpkojmnoTmiJDkuobmraPpgrvmjqXooajnmoTpk77ooajnu5PmnoTvvIzogIzku47kuIDkuKrpobbngrnnu5PngrnnmoRmaXJzdGlu5Ye65Y+R77yM5rK/6KGo57uT54K555qEaGxpbmvmjIfpkojmnoTmiJDkuobpgIbpgrvmjqXooajnmoTpk77ooajnu5PmnoTjgIJcclxuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWFkVmV4IOW8p+eahOWktOmhtueCueeahOS9jee9rlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGFpbFZleCDlvKfnmoTlsL7pobbngrnkvY3nva5cclxuICogQHBhcmFtIHtBcmNCb3h9IGhMaW5rIOW8p+WktOebuOWQjOeahOW8p+eahOmTvuWfn1xyXG4gKiBAcGFyYW0ge0FyY0JveH0gdExpbmsg5byn5bC+55u45ZCM55qE5byn55qE6ZO+5Z+fXHJcbiAqIEBwYXJhbSB7Kn0gaW5mb1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEFyY0JveCh0YWlsVmV4LCBoZWFkVmV4LCBoTGluaywgdExpbmssIGluZm8pIHtcclxuICAgIHRoaXMuaGVhZFZleCA9IGhlYWRWZXggfHwgMDtcclxuICAgIHRoaXMudGFpbFZleCA9IHRhaWxWZXggfHwgMDtcclxuICAgIHRoaXMuaExpbmsgPSBoTGluayB8fCBudWxsO1xyXG4gICAgdGhpcy50TGluayA9IHRMaW5rIHx8IG51bGw7XHJcbiAgICB0aGlzLmluZm8gPSBpbmZvIHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGRhdGFcclxuICogQHBhcmFtIHtBcmNCb3h9IGZpcnN0SW4g6K+l6aG254K556ys5LiA5p2h5YWl5bynXHJcbiAqIEBwYXJhbSB7QXJjQm94fSBmaXJzdE91dCDor6XpobbngrnnrKzkuIDmnaHlh7rlvKdcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBPTFZleE5vZGUoZGF0YSwgZmlyc3RJbiwgZmlyc3RPdXQpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbnVsbDtcclxuICAgIHRoaXMuZmlyc3RJbiA9IGZpcnN0SW4gfHwgbnVsbDtcclxuICAgIHRoaXMuZmlyc3RPdXQgPSBmaXJzdE91dCB8fCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtBcnJheSB8IE9MVmV4Tm9kZX0geExpc3Qg6KGo5aS05ZCR6YePXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW0g5pyJ5ZCR5Zu+55qE5b2T5YmN6aG254K55pWwXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW0g5pyJ5ZCR5Zu+55qE5b2T5YmN5byn5pWwXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT0xHcmFwaCh4TGlzdCwgdmV4bnVtLCBhcmNudW0pIHtcclxuICAgIHRoaXMueExpc3QgPSB4TGlzdCB8fCBbXTtcclxuICAgIHRoaXMudmV4bnVtID0gdmV4bnVtIHx8IDA7XHJcbiAgICB0aGlzLmFyY251bSA9IGFyY251bSB8fCAwO1xyXG59XHJcbk9MR3JhcGgucHJvdG90eXBlID0ge1xyXG4gICAgY29uc3RydWN0b3I6IE9MR3JhcGgsXHJcblxyXG4gICAgbG9jYXRlVmV4OiBmdW5jdGlvbiAodnApIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueExpc3RbaV0uZGF0YSA9PT0gdnApIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyDliKDpmaTpobbngrlcclxuICAgIGRlbGV0ZVZlcnRleDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbSA9IHRoaXMubG9jYXRlVmV4KHYpO1xyXG5cclxuICAgICAgICBpZiAobSA8IDApIHRocm93IG5ldyBFcnJvcigndmVydGV4IG5vdCBmb3VuZCEnKTtcclxuXHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLnZleG51bTtcclxuICAgICAgICB2YXIgcSwgaSwgcDtcclxuICAgICAgICAvLyDliKDpmaTmiYDmnInku6V25Li65aS055qE6L65XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzlvoXliKDpmaTnmoTovrnmmK/lpLTpk77kuIrnmoTnrKzkuIDkuKrnu5PngrlcclxuICAgICAgICAgICAgaWYgKHRoaXMueExpc3RbaV0uZmlyc3RJbi50YWlsVmV4ID09PSBtKSB7XHJcbiAgICAgICAgICAgICAgICBxID0gdGhpcy54TGlzdFtpXS5maXJzdEluO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdEluID0gcS5oTGluaztcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47IHAgJiYgcC5oTGluay50YWlsVmV4ICE9PSBtOyBwID0gcC5oTGluayk7XHJcbiAgICAgICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHEgPSBwLmhMaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIHAuaExpbmsgPSBxLmhMaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWIoOmZpOaJgOacieS7pXbkuLrlsL7nmoTovrlcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIOWmguaenOW+heWIoOmZpOeahOi+ueaYr+WwvumTvuS4iueahOesrOS4gOS4que7k+eCuVxyXG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5maXJzdE91dC5oZWFkVmV4ID09PSBtKSB7XHJcbiAgICAgICAgICAgICAgICBxID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDtcclxuICAgICAgICAgICAgICAgIHRoaXMueExpc3RbaV0uZmlyc3RPdXQgPSBxLnRMaW5rO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAocCA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQ7IHAgJiYgcC50TGluay5oZWFkVmV4ICE9PSBtOyBwID0gcC50TGluayk7XHJcbiAgICAgICAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHEgPSBwLnRMaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIHAudExpbmsgPSBxLnRMaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOmhuuasoeeUqOe7k+eCuW3kuYvlkI7nmoTpobbngrnlj5bku6PliY3kuIDkuKrpobbngrlcclxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIOS/ruaUueihqOWktOWQkemHj1xyXG4gICAgICAgICAgICB0aGlzLnhMaXN0W2ldID0gdGhpcy54TGlzdFtpICsgMV07XHJcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMueExpc3RbaV0uZmlyc3RJbjsgcDsgcCA9IHAuaExpbmspXHJcbiAgICAgICAgICAgICAgICBwLmhlYWRWZXgtLTtcclxuICAgICAgICAgICAgZm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspXHJcbiAgICAgICAgICAgICAgICBwLnRhaWxWZXgtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmV4bnVtLS07XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZURHOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52ZXhudW0gPSBwcm9tcHQoJ1ZleG51bTogJyk7XHJcbiAgICAgICAgdGhpcy5hcmNudW0gPSBwcm9tcHQoJ0FyY251bTogJyk7XHJcbiAgICAgICAgLy8gSW5jSW5mb+S4ujDliJnlkITlvKfkuI3lkKvlhbbku5bkv6Hmga9cclxuICAgICAgICB2YXIgaW5jSW5mbyA9ICtwcm9tcHQoJ0luY0luZm86ICcpO1xyXG5cclxuICAgICAgICAvLyDovpPlhaXpobbngrnlgLxcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy54TGlzdFtpXSA9IG5ldyBPTFZleE5vZGUocHJvbXB0KCdkYXRhOiAnKSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuYXJjbnVtOyArK2spIHtcclxuICAgICAgICAgICAgdmFyIHYxID0gcHJvbXB0KCd2MTogJyk7XHJcbiAgICAgICAgICAgIHZhciB2MiA9IHByb21wdCgndjI6ICcpO1xyXG5cclxuICAgICAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KHYxKTtcclxuICAgICAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleCh2Mik7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEgfHwgaiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KCfml6DmraTpobbngrnvvIzor7fph43mlrDovpPlhaUhJyk7XHJcbiAgICAgICAgICAgICAgICBrLS07XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgQXJjQm94KGksIGosIHRoaXMueExpc3Rbal0uZmlyc3RJbiwgdGhpcy54TGlzdFtpXS5maXJzdE91dCwgaW5jSW5mbyAmJiBwcm9tcHQoJ2luZm86ICcpKTtcclxuICAgICAgICAgICAgdGhpcy54TGlzdFtqXS5maXJzdEluID0gdGhpcy54TGlzdFtpXS5maXJzdE91dCA9IHA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOaxguacieWQkeWbvueahOW8uui/numAmuWIhumHj1xyXG4gICAgICovXHJcbiAgICBnZXRTR3JhcGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIHZhciBmaW5pc2hlZCA9IFtdO1xyXG4gICAgICAgIHZhciBjb3VudCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIOesrOS4gOasoea3seW6puS8mOWFiOmBjeWOhuW7uueri2ZpbmlzaGVk5pWw57uEXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnMxKHRoaXMsIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDmuIXnqbp2aXNpdGVk5pWw57uEXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgICAgICAvLyDnrKzkuozmrKHpgIblkJHnmoTmt7HluqbkvJjlhYjpgY3ljoZcclxuICAgICAgICBmb3IgKHZhciBsZW4gPSB0aGlzLnZleG51bSAtIDE7IGxlbiA+PSAwOyAtLWxlbikge1xyXG4gICAgICAgICAgICBpID0gZmluaXNoZWRbaV07XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzMih0aGlzLCBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRmczEoZ3JhcGgsIHYpIHtcclxuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcclxuICAgICAgICAgICAgICAgIHZhciB3ID0gcC5oZWFkVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3ddKSBkZnMxKGdyYXBoLCB3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5pc2hlZFsrK2NvdW50XSA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZnMyKGdyYXBoLCB2KSB7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJWQnLCB2KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHAudGFpbFZleDtcclxuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3XSkgZGZzMihncmFwaCwgdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vL3ZhciBnID0gbmV3IE9MR3JhcGgoKTtcclxuLy9nLmNyZWF0ZURHKCk7XHJcbi8vY29uc29sZS5sb2coZyk7XHJcblxyXG5cclxuLypcclxuIOacieWQkeWbvueahOW8uui/numAmuWIhumHj1xyXG5cclxuIOWvueS6juacieWQkeWbvu+8jOWcqOWFtuavj+S4gOS4quW8uui/numAmuWIhumHj+S4re+8jOS7u+S9leS4pOS4qumhtueCuemDveaYr+WPr+i+vueahOOAgiBW4oiIR++8jOS4jlblj6/nm7jkupLliLDovr7nmoTmiYDmnInpobbngrnlsLHmmK/ljIXlkKtW55qE5by66L+e6YCa5YiG6YeP55qE5omA5pyJ6aG254K544CCXHJcblxyXG4g6K6+5LuOVuWPr+WIsOi+viAo5LulVuS4uui1t+eCueeahOaJgOacieacieWQkei3r+W+hOeahOe7iOeCuSnnmoTpobbngrnpm4blkIjkuLpUMShHKe+8jOiAjOWIsOi+vlYgKOS7pVbkuLrnu4jngrnnmoTmiYDmnInmnInlkJHot6/lvoTnmoTotbfngrkp55qE6aG254K56ZuG5ZCI5Li6VDIoRynvvIzliJnljIXlkKtW55qE5by66L+e6YCa5YiG6YeP55qE6aG254K56ZuG5ZCI5piv77yaIFQxKEcp4oipVDIoRykg44CCXHJcblxyXG4g5rGC5pyJ5ZCR5Zu+R+eahOW8uui/numAmuWIhumHj+eahOWfuuacrOatpemqpOaYr++8mlxyXG4g4pG0IOWvuUfov5vooYzmt7HluqbkvJjlhYjpgY3ljobvvIznlJ/miJBH55qE5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6XVOOAglxyXG4g4pG1ICDlr7nmo67mnpdU55qE6aG254K55oyJ5Lit5bqP6YGN5Y6G6aG65bqP6L+b6KGM57yW5Y+344CCXHJcbiDikbYgIOaUueWPmEfkuK3mr4/kuIDmnaHlvKfnmoTmlrnlkJHvvIzmnoTmiJDkuIDkuKrmlrDnmoTmnInlkJHlm75H4oCZ44CCXHJcbiDikbcgIOaMieKRteS4reagh+WHuueahOmhtueCuee8luWPt++8jOS7jue8luWPt+acgOWkp+eahOmhtueCueW8gOWni+WvuUfigJnov5vooYzmt7HluqbkvJjlhYjmkJzntKLvvIzlvpfliLDkuIDmo7Xmt7HluqbkvJjlhYjnlJ/miJDmoJHjgILoi6XkuIDmrKHlrozmlbTnmoTmkJzntKLov4fnqIvmsqHmnInpgY3ljoZH4oCZ55qE5omA5pyJ6aG254K577yM5YiZ5LuO5pyq6K6/6Zeu55qE6aG254K55Lit6YCJ5oup5LiA5Liq57yW5Y+35pyA5aSn55qE6aG254K577yM55Sx5a6D5byA5aeL5YaN6L+b6KGM5rex5bqm5LyY5YWI5pCc57Si77yM5bm25b6X5Yiw5Y+m5LiA5qO15rex5bqm5LyY5YWI55Sf5oiQ5qCR44CC5Zyo6K+l5q2l6aqk5Lit77yM5q+P5LiA5qyh5rex5bqm5LyY5YWI5pCc57Si5omA5b6X5Yiw55qE55Sf5oiQ5qCR5Lit55qE6aG254K55bCx5pivR+eahOS4gOS4quW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxyXG4g4pG4ICDph43lpI3mraXpqqTikbcg77yM55u05YiwR+KAmeS4reeahOaJgOaciemhtueCuemDveiiq+iuv+mXruOAglxyXG5cclxuIOWcqOeul+azleWunueOsOaXtu+8jOW7uueri+S4gOS4quaVsOe7hGluX29yZGVyW25d5a2Y5pS+5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6X55qE5Lit5bqP6YGN5Y6G5bqP5YiX44CC5a+55q+P5Liq6aG254K5du+8jOWcqOiwg+eUqERGU+WHveaVsOe7k+adn+aXtu+8jOWwhumhtueCueS+neasoeWtmOaUvuWcqOaVsOe7hGluX29yZGVyW25d5Lit44CC5Zu+6YeH55So5Y2B5a2X6ZO+6KGo5L2c5Li65a2Y5YKo57uT5p6E5pyA5ZCI6YCC44CCXHJcblxyXG4gKi9cclxuXHJcbi8vIHRvZG8gdG8gYmUgdGVzdGVkXHJcbk9MR3JhcGgucHJvdG90eXBlLmNvbm5lY3RlZF9ERyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2aXNpdGVkID0gW107XHJcbiAgICB2YXIgaW5fb3JkZXIgPSBbXTtcclxuICAgIHZhciBjb3VudCA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcbiAgICAvLyDlr7nlm77mraPlkJHpgY3ljoZcclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgIGRmcyh0aGlzLCBpLCBpbl9vcmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcbiAgICAvLyDlr7nlm77pgIblkJHpgY3ljoZcclxuICAgIHZhciBrID0gMTtcclxuICAgIGZvciAodmFyIGogPSB0aGlzLnZleG51bSAtIDE7IGogPj0gMDsgLS1qKSB7XHJcbiAgICAgICAgdmFyIHYgPSBpbl9vcmRlcltqXTtcclxuICAgICAgICBpZiAoIXZpc2l0ZWRbdl0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+esrCcgKyBrKysgKyAn5Liq6L+e6YCa5YiG6YeP6aG254K5Jyk7XHJcbiAgICAgICAgICAgIHJldl9kZnModGhpcywgdik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdikge1xyXG4gICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwID0gZ3JhcGgueExpc3Rbdl0uZmlyc3RPdXQ7IHA7IHAgPSBwLnRMaW5rKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmhlYWRWZXhdKSB7XHJcbiAgICAgICAgICAgICAgICBkZnMoZ3JhcGgsIHAuaGVhZFZleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluX29yZGVyW2NvdW50KytdID0gdjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXZfZGZzKGdyYXBoLCB2KSB7XHJcbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+mhtueCue+8micgKyB2KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLnRhaWxWZXhdKSB7XHJcbiAgICAgICAgICAgICAgICByZXZfZGZzKGdyYXBoLCBwLnRhaWxWZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0dyYXBoL09MR3JhcGguanNcbiAqKi8iLCIvKipcclxuICogTFJVKCBMZWFzdCByZWNlbnRseSB1c2VkIClcclxuICovXHJcblxyXG5pbXBvcnQgRG91YmxlTGlua2VkTGlzdCBmcm9tICcuL0RvdWJsZUxpbmtlZExpc3QnO1xyXG5cclxuY29uc3QgTElNSVQgPSAyMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExSVUNhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNxTGlzdCwgbGltaXQgPSBMSU1JVCl7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xyXG4gICAgICAgIHNxTGlzdCA9IChzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkgPyBzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aC5zbGljZSgwLCB0aGlzLmxpbWl0KSA6IFtdO1xyXG4gICAgICAgIHRoaXMuX19jYWNoZSA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KHNxTGlzdCwgZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmtleSA9PT0gYi5rZXk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2l6ZSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuc2l6ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVtb3ZlKGtleSl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZS5yZW1vdmUoeyBrZXkgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX19jYWNoZS5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXQoa2V5KXtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9fY2FjaGUuaW5kZXhPZih7IGtleSB9KTtcclxuXHJcbiAgICAgICAgaWYoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX19jYWNoZS5maW5kQnlJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIHRoaXMuX19jYWNoZS5yZW1vdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuX19jYWNoZS51bnNoaWZ0KGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGFkZChrZXksIHZhbHVlKXtcclxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoZGF0YSkge1xyXG4gICAgICAgICAgICBkYXRhLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zaXplID09PSB0aGlzLmxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FjaGUucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19jYWNoZS51bnNoaWZ0KHtcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpe1xyXG4gICAgICAgIGxldCBhcnIgPSBbXTtcclxuICAgICAgICB0aGlzLl9fY2FjaGUuZm9yRWFjaChmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgYXJyLnB1c2goYCR7IGRhdGEua2V5IH06JHsgZGF0YS52YWx1ZSB9YCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIuam9pbignID4gJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9KU09OKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZS50b0pTT04oKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc29sZS5sb2coJ0xSVUNhY2hlJyk7XHJcblxyXG5sZXQgYSA9IG5ldyBMUlVDYWNoZShbXSwgMyk7XHJcbmEuYWRkKCdhZGFtJywgMjkpO1xyXG5hLmFkZCgnam9obicsIDI2KTtcclxuYS5hZGQoJ2FuZ2VsYScsIDI0KTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuYS5nZXQoJ2pvaG4nKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuYS5hZGQoJ3pvcnJvJywgMTQxKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuY29uc29sZS5sb2coYS50b0pTT04oKSk7XHJcblxyXG5mb3IobGV0IGl0ZW0gb2YgYSl7XHJcbiAgICBjb25zb2xlLmxvZyhpdGVtKTtcclxufVxyXG5cclxuYS5yZW1vdmUoJ3pvcnJvJyk7XHJcbmEucmVtb3ZlKCdqb2huJyk7XHJcbmEucmVtb3ZlKCdhbmdlbGEnKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuXHJcbi8vIHRlc3QgY2FzZTpcclxuLy8gSW5wdXQ6XHJcbi8vIDIsW2FkZCgyLDEpLGFkZCgxLDEpLGFkZCgyLDMpLGFkZCg0LDEpLGdldCgxKSxnZXQoMildXHJcbi8vIEV4cGVjdGVkOlxyXG4vLyBbIGZhbHNlLCB7IGtleTogMiwgdmFsdWU6IDMgfSBdXHJcbmNvbnNvbGUubG9nKCdhZGQnKTtcclxuXHJcbmxldCBiID0gbmV3IExSVUNhY2hlKFtdLCAyKTtcclxuYi5hZGQoMiwxKTtcclxuYi5hZGQoMSwxKTtcclxuYi5hZGQoMiwzKTtcclxuYi5hZGQoNCwxKTtcclxuY29uc29sZS5sb2coW2IuZ2V0KDEpLCBiLmdldCgyKV0pO1xyXG5cclxuY29uc29sZS5sb2coJ35hZGQnKTtcclxuXHJcbmNvbnNvbGUubG9nKCdMUlVDYWNoZUVuZCcpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9MaXN0L0xSVS5qc1xuICoqLyIsIi8qKlxyXG4gKiDnur/mgKfooahcclxuICovXHJcblxyXG4vLyDnur/mgKfooajnmoTnsbvlnovlrprkuYlcclxuLy8g5bCG5omA5pyJ5Zyo5pWw57uEYuS4reS9huS4jeWcqOaVsOe7hGHnmoTmlbDmja7lhYPntKDmj5LlhaXliLBh5LitXHJcblxyXG52YXIgYSA9IFsxLCAyLCAzLCA0LCA1XTtcclxudmFyIGIgPSBbMSwgMywgNSwgNywgOV07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdW5pb24oYSwgYikge1xyXG4gICAgdmFyIGVsZW0sIGVxdWFsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBiTGVuID0gYi5sZW5ndGg7IGkgPCBiTGVuOyBpKyspIHtcclxuICAgICAgICBlbGVtID0gYltpXTtcclxuICAgICAgICBlcXVhbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgYUxlbiA9IGEubGVuZ3RoOyBqIDwgYUxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtID09PSBhW2pdKSB7XHJcbiAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFlcXVhbCkgYS5wdXNoKGVsZW0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bmlvbihhLCBiKTtcclxuY29uc29sZS5sb2coYSk7XHJcbi8vIFsxLCAyLCAzLCA0LCA1LCA3LCA5XVxyXG5cclxuLy8g5pe26Ze05aSN5p2C5bqm77yaTyhhTGVuICogYkxlbilcclxuXHJcbi8vIOW3suefpeaVsOe7hGHlkozmlbDnu4Ri5Lit55qE5pWw5o2u5YWD57Sg5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXHJcbi8vIOW9kuW5tmHlkoxi5b6X5Yiw5paw55qE5pWw57uEY++8jGPnmoTmlbDmja7lhYPntKDkuZ/mjInlgLzpnZ7pgJLlh4/mjpLliJdcclxudmFyIGEgPSBbMywgNSwgOCwgMTFdO1xyXG52YXIgYiA9IFsyLCA2LCA4LCA5LCAxMSwgMTUsIDIwXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxpc3QoYSwgYikge1xyXG4gICAgdmFyIGMgPSBbXSwgYUVsZW0sIGJFbGVtO1xyXG4gICAgdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7XHJcbiAgICB2YXIgYUxlbiA9IGEubGVuZ3RoO1xyXG4gICAgdmFyIGJMZW4gPSBiLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IGFMZW4gJiYgaiA8IGJMZW4pIHtcclxuICAgICAgICBhRWxlbSA9IGFbaV07XHJcbiAgICAgICAgYkVsZW0gPSBiW2pdO1xyXG5cclxuICAgICAgICBpZiAoYUVsZW0gPCBiRWxlbSkge1xyXG4gICAgICAgICAgICBjW2srK10gPSBhRWxlbTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNbaysrXSA9IGJFbGVtO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChpIDwgYUxlbikge1xyXG4gICAgICAgIGNbaysrXSA9IGFbaSsrXTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoaiA8IGJMZW4pIHtcclxuICAgICAgICBjW2srK10gPSBiW2orK107XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGM7XHJcbn1cclxuXHJcbnZhciBjID0gbWVyZ2VMaXN0KGEsIGIpO1xyXG5jb25zb2xlLmxvZyhjKTtcclxuLy8gWzIsIDMsIDUsIDYsIDgsIDgsIDksIDExLCAxMSwgMTUsIDIwXVxyXG5cclxuLy8g5pe26Ze05aSN5p2C5bqm77yaIE8oYUxlbiArIGJMZW4pXHJcblxyXG4vLyDnur/mgKfooajnmoTpobrluo/ooajnpLrlkozlrp7njrBcclxuLy8g5L2/55So5Lyq5pWw57uE5qih5ouf57q/5oCn6KGo5o+S5YWl5pON5L2c55qE5YmN5ZCO5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo56m66Ze05Lit55qE5L2N572u5Y+Y5YyWXHJcbnZhciBhID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDV9O1xyXG5hLmxlbmd0aCA9IDY7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KGEsIGksIGVsZW0pIHtcclxuICAgIGlmICghZWxlbSkgcmV0dXJuO1xyXG5cclxuICAgIHZhciBsZW4gPSBhLmxlbmd0aDtcclxuICAgIGlmIChpID49IGxlbikge1xyXG4gICAgICAgIHdoaWxlIChsZW4gPCBpKSB7XHJcbiAgICAgICAgICAgIGFbbGVuKytdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBhLmxlbmd0aCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2ldID0gZWxlbTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKGxlbiA+IGkpIHtcclxuICAgICAgICAgICAgYVtsZW4tLV0gPSBhW2xlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFbaV0gPSBlbGVtO1xyXG4gICAgfVxyXG4gICAgYS5sZW5ndGgrKztcclxufVxyXG5cclxuaW5zZXJ0KGEsIDMsIDgpO1xyXG5pbnNlcnQoYSwgMTAsIDEwKTtcclxuY29uc29sZS5sb2coYSk7XHJcblxyXG4vLyDkvb/nlKjkvKrmlbDnu4TmqKHmi5/nur/mgKfooajliKDpmaTmk43kvZznmoTliY3lkI7mlbDmja7lhYPntKDlnKjlrZjlgqjnqbrpl7TkuK3nmoTkvY3nva7lj5jljJZcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWwoYSwgaSkge1xyXG4gICAgdmFyIHRlbXAgPSBhW2ldO1xyXG4gICAgdmFyIGogPSBpICsgMTtcclxuICAgIHZhciBsZW4gPSBhLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaiA8IGxlbikge1xyXG4gICAgICAgIGFbaiAtIDFdID0gYVtqKytdO1xyXG4gICAgfVxyXG4gICAgYS5sZW5ndGgtLTtcclxuICAgIGRlbGV0ZSBhW2xlbiAtIDFdO1xyXG5cclxuICAgIHJldHVybiB0ZW1wO1xyXG59XHJcblxyXG5kZWwoYSwgMyk7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG5kZWwoYSwgMTApO1xyXG5jb25zb2xlLmxvZyhhKTtcclxuXHJcbi8vIOaXtumXtOWkjeadguW6pu+8miBPKGEubGVuZ3RoKVxyXG5cclxuLy8g5q+U6L6D5a2X56ym6KGoQeWSjELvvIzlubbnlKjov5Tlm57lgLzooajnpLrnu5PmnpzvvIzlgLzkuLox77yM6KGo56S6QT5C77yM5YC85Li6LTHvvIzooajnpLpBPELvvIzlgLzkuLow77yM6KGo56S6QT1CXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q29tcChhTGlzdCwgYkxpc3QpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYUxpc3QubGVuZ3RoICYmIGkgPCBiTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhTGlzdFtpXSAhPT0gYkxpc3RbaV0pIHJldHVybiBhTGlzdFtpXSA+IGJMaXN0W2ldID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhTGlzdC5sZW5ndGggPT0gYkxpc3QubGVuZ3RoKSByZXR1cm4gMDtcclxuXHJcbiAgICByZXR1cm4gYUxpc3QubGVuZ3RoID4gYkxpc3QubGVuZ3RoID8gMSA6IC0xO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZShsaXN0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxpc3QubGVuZ3RoIC0gMTsgaSA8PSBqOyBpKyssIGotLSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gbGlzdFtpXTtcclxuICAgICAgICBsaXN0W2ldID0gbGlzdFtqXTtcclxuICAgICAgICBsaXN0W2pdID0gdGVtcDtcclxuICAgIH1cclxufVxyXG5cclxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3QoYUxpc3QsIGJMaXN0KSB7XHJcbiAgICB2YXIgY0xpc3QgPSBbXTtcclxuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xyXG5cclxuICAgIHdoaWxlIChhTGlzdFtpXSAmJiBiTGlzdFtqXSkge1xyXG4gICAgICAgIGlmIChhTGlzdFtpXSA8IGJMaXN0W2pdKSBpKys7XHJcbiAgICAgICAgZWxzZSBpZiAoYUxpc3RbaV0gPiBiTGlzdFtqXSkgaisrO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjTGlzdFtrKytdID0gYUxpc3RbaV07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY0xpc3Q7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdChbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcclxuXHJcbi8vIOaxguWFg+e0oOmAkuWinuaOkuWIl+eahOe6v+aAp+ihqEHlkoxC55qE5YWD57Sg55qE5Lqk6ZuG5bm25a2Y5YWl5ZueYVxyXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0X3RydWUoYSwgYikge1xyXG4gICAgdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGFbaV0gJiYgYltqXSkge1xyXG4gICAgICAgIGlmIChhW2ldIDwgYltqXSkgaSsrO1xyXG4gICAgICAgIGVsc2UgaWYgKGFbaV0gPiBiW2pdKSBqKys7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFbaysrXSA9IGFbaV07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoYVtrXSkgYS5zcGxpY2UoaywgMSk7XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdF90cnVlKFsxLCAzLCA1LCA3LCA5XSwgWzEsIDUsIDksIDEzLCAxN10pICsgJycpO1xyXG5cclxuLy8gYe+8jGLvvIxj55qE5YWD57Sg5Z2H5piv6Z2e6YCS5YeP5o6S5YiXXHJcbi8vIOaxgmHmlbDnu4TkuK3pnZ5i5pWw57uE5ZKMY+aVsOe7hOeahOS6pOmbhueahOWFg+e0oOOAglxyXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0X2RlbGV0ZShhLCBiLCBjKSB7XHJcbiAgICB2YXIgaSA9IDAsIGogPSAwLCBrID0gMCwgbSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBqIDwgYi5sZW5ndGggJiYgayA8IGMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGJbal0gPCBjW2tdKSBqKys7XHJcbiAgICAgICAgZWxzZSBpZiAoYltqXSA+IGNba10pIGsrKztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5LqG55u45ZCM5YWD57Sgc2FtZVxyXG4gICAgICAgICAgICB2YXIgc2FtZSA9IGJbal07XHJcblxyXG4gICAgICAgICAgICAvLyBq77yMa+WQjuenu+WIsOaWsOeahOWFg+e0oFxyXG4gICAgICAgICAgICB3aGlsZSAoYltqXSA9PT0gc2FtZSkgaisrO1xyXG4gICAgICAgICAgICB3aGlsZSAoY1trXSA9PT0gc2FtZSkgaysrO1xyXG4gICAgICAgICAgICAvLyDpnIDkv53nlZnnmoTlhYPntKDnp7vliqjliLDmlrDkvY3nva5cclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldIDwgc2FtZSkgYVttKytdID0gYVtpKytdO1xyXG4gICAgICAgICAgICAvLyDot7Pov4fnm7jlkIznmoTlhYPntKBcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldID09PSBzYW1lKSBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGHnmoTliankvZnlhYPntKDph43mlrDlrZjlgqhcclxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGgpIGFbbSsrXSA9IGFbaSsrXTtcclxuICAgIGEubGVuZ3RoID0gbTtcclxuXHJcbiAgICByZXR1cm4gYTtcclxufVxyXG5cclxuY29uc29sZS5sb2coaW50ZXJzZWN0X2RlbGV0ZShbMSwgMiwgMywgNCwgNSwgNiwgOV0sIFsxLCAzLCA1LCA3LCA5XSwgWzEsIDUsIDksIDEzLCAxN10pICsgJycpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9MaXN0L0xpbmVhckxpc3QuanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS8xLzE5LlxyXG4gKi9cclxuXHJcbi8vIOW+queOr+mYn+WIl1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDeWNsZVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heHNpemUgPSAxMDApe1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xyXG4gICAgICAgIHRoaXMuTUFYUVNJWkUgPSBtYXhzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGVuUXVldWUoZGF0YSkge1xyXG4gICAgICAgIGlmICgodGhpcy5yZWFyICsgMSkgJSB0aGlzLk1BWFFTSVpFID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2N5Y2xlUXVldWUgaXMgYWxyZWFkeSBmdWxsIScpO1xyXG5cclxuICAgICAgICB0aGlzLmJhc2VbdGhpcy5yZWFyXSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5yZWFyID0gKHRoaXMucmVhciArIDEpICUgdGhpcy5NQVhRU0laRTtcclxuICAgIH1cclxuICAgIGRlUXVldWUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQgPT09IHRoaXMucmVhcikgdGhyb3cgbmV3IEVycm9yKCdjeWNsZVF1ZXVlIGlzIGFscmVhZHkgZW1wdHknKTtcclxuXHJcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VbdGhpcy5mcm9udF07XHJcbiAgICAgICAgdGhpcy5mcm9udCA9ICh0aGlzLmZyb250ICsgMSkgJSB0aGlzLk1BWFFTSVpFO1xyXG5cclxuICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlYXIgLSB0aGlzLmZyb250ICsgdGhpcy5NQVhRU0laRSkgJSB0aGlzLk1BWFFTSVpFO1xyXG4gICAgfVxyXG4gICAgcGVla0F0KGluZGV4ID0gMCkge1xyXG4gICAgICAgIGluZGV4ID0gKGluZGV4ICsgdGhpcy5NQVhRU0laRSkgJSB0aGlzLk1BWFFTSVpFO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlW2luZGV4ICsgdGhpcy5mcm9udF0gfHwgbnVsbDtcclxuICAgIH1cclxuICAgIGdldEhlYWQoKSB7XHJcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VbdGhpcy5mcm9udF07XHJcbiAgICAgICAgcmV0dXJuIGVsZW0gPyBlbGVtIDogbnVsbDtcclxuICAgIH1cclxuICAgIHF1ZXVlVHJhdmVyc2UoaXRlcmF0b3IpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5mcm9udCwgbGVuID0gdGhpcy5yZWFyID0gdGhpcy5mcm9udDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcih0aGlzLmJhc2VbaV0sIGkpKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICB2YXIgYmFzZSA9IFtdLnNsaWNlLmNhbGwodGhpcy5iYXNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJhc2Uuc2xpY2UodGhpcy5mcm9udCwgdGhpcy5yZWFyIC0gdGhpcy5mcm9udCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBxdWV1ZSA9IG5ldyBDeWNsZVF1ZXVlKCk7XHJcbnF1ZXVlLmVuUXVldWUoMSk7XHJcbnF1ZXVlLmRlUXVldWUoKTtcclxucXVldWUuZW5RdWV1ZSgyKTtcclxucXVldWUuZW5RdWV1ZSgzKTtcclxuY29uc29sZS5sb2cocXVldWUucGVla0F0KDApKTtcclxuY29uc29sZS5sb2cocXVldWUucGVla0F0KDEpKTtcclxuY29uc29sZS5sb2cocXVldWUucGVla0F0KDIpKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9RdWV1ZS9DeWNsZVF1ZXVlLmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMjYuXHJcbiAqL1xyXG5cclxuLypcclxu5LyY5YWI6Zif5YiXKHByaW9yaXR5IHF1ZXVlKVxyXG5cclxu5pmu6YCa55qE6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye655qE5pWw5o2u57uT5p6E77yM5YWD57Sg5Zyo6Zif5YiX5bC+6L+95Yqg77yM6ICM5LuO6Zif5YiX5aS05Yig6Zmk44CC5Zyo5LyY5YWI6Zif5YiX5Lit77yM5YWD57Sg6KKr6LWL5LqI5LyY5YWI57qn44CC5b2T6K6/6Zeu5YWD57Sg5pe277yM5YW35pyJ5pyA6auY5LyY5YWI57qn55qE5YWD57Sg5pyA5YWI5Yig6Zmk44CC5LyY5YWI6Zif5YiX5YW35pyJ5pyA6auY57qn5YWI5Ye6IO+8iGxhcmdlc3QtaW7vvIxmaXJzdC1vdXTvvInnmoTooYzkuLrnibnlvoHjgIJcclxuXHJcbuS8mOWFiOmYn+WIl+aYrzDkuKrmiJblpJrkuKrlhYPntKDnmoTpm4blkIgs5q+P5Liq5YWD57Sg6YO95pyJ5LiA5Liq5LyY5YWI5p2D5oiW5YC8LOWvueS8mOWFiOmYn+WIl+aJp+ihjOeahOaTjeS9nOaciTEpIOafpeaJvjsyKSDmj5LlhaXkuIDkuKrmlrDlhYPntKA7Mykg5Yig6ZmkLuWcqOacgOWwj+S8mOWFiOmYn+WIlyhtaW4gcHJpb3JpdHlxIHUgZSB1IGUp5LitLOafpeaJvuaTjeS9nOeUqOadpeaQnOe0ouS8mOWFiOadg+acgOWwj+eahOWFg+e0oCzliKDpmaTmk43kvZznlKjmnaXliKDpmaTor6XlhYPntKA75a+55LqO5pyA5aSn5LyY5YWI6Zif5YiXKG1heCBwcmlvcml0eSBxdWV1ZSks5p+l5om+5pON5L2c55So5p2l5pCc57Si5LyY5YWI5p2D5pyA5aSn55qE5YWD57SgLOWIoOmZpOaTjeS9nOeUqOadpeWIoOmZpOivpeWFg+e0oC7kvJjlhYjmnYPpmJ/liJfkuK3nmoTlhYPntKDlj6/ku6XmnInnm7jlkIznmoTkvJjlhYjmnYMs5p+l5om+5LiO5Yig6Zmk5pON5L2c5Y+v5qC55o2u5Lu75oSP5LyY5YWI5p2D6L+b6KGMLlxyXG5cclxuXHJcbuWFpemYn+aTjeS9nFxyXG7ikaDvvJrlrozlhajkuozlj4nmoJHnmoTmnoTlu7rmk43kvZzmmK/igJzku47kuIrliLDkuIvvvIzku47lt6bliLDlj7PigJ3nmoTlvaLlvI/vvIzmiYDku6XlhaXpmJ/nmoToioLngrnmmK/mlL7lnKjmlbDnu4TnmoTmnIDlkI7vvIzkuZ/lsLHmmK/moJHkuK3lj7blrZDlsYLnmoTmnInluo/mnIDlj7PovrnnqbrkvY3jgIJcclxu4pGh77ya5b2T6IqC54K55o+S5YWl5Yiw5pyA5ZCO5pe277yM5pyJ5Y+v6IO956C05Z2P5LqG5aCG55qE5oCn6LSo77yM5q2k5pe25oiR5Lus6KaB6L+b6KGM4oCc5LiK5ruk5pON5L2c4oCd77yM5b2T54S25pe26Ze05aSN5p2C5bqm5Li6TyhsZ04p44CCXHJcblxyXG7lh7rpmJ/mk43kvZxcclxu5Ye66Zif5pON5L2c5pe277yM5oiR5Lus6YeH5Y+W55qE5pa55qGI5piv77ya5by55Ye65aCG6aG25YWD57Sg77yM54S25ZCO5bCG5Y+25a2Q5bGC5Lit55qE5pyA5Y+z5a2Q6IqC54K56LWL57uZ5aCG6aG277yM5ZCM5qC36L+Z5pe25Lmf5Lya5Y+v6IO95a2Y5Zyo56C05Z2P5aCG55qE5oCn6LSo77yM5pyA5ZCO5oiR5Lus6KaB6KKr6L+r6L+b6KGM5LiL5ruk5pON5L2c44CCXHJcbiAqL1xyXG5cclxuLy8g55So5aCG5a6e546w5LyY5YWI6Zif5YiXXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBzaXplKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgZW5RdWV1ZSh2YWx1ZSwgcHJpb3JpdHkgPSAwKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCByZXF1aXJlZCcpO1xyXG5cclxuICAgICAgICAvLyDlsIblvZPliY3oioLngrnov73liqDliLDloIblsL5cclxuICAgICAgICB0aGlzLmhlYXAucHVzaCh7XHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDlpoLmnpzlj6rmnInkuIDkuKroioLngrnvvIzliJnkuI3pnIDopoHov5vooYznrZvpgInmk43kvZxcclxuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyDojrflj5bmnIDlkI7kuIDkuKrpnZ7lj7blrZDoioLngrnvvIzlubbov5vooYzloIbosIPmlbRcclxuICAgICAgICB1cEhlYXBBZGp1c3QodGhpcy5oZWFwLCAodGhpcy5oZWFwLmxlbmd0aCA+PiAxKSAtIDEpO1xyXG4gICAgfVxyXG4gICAgZGVRdWV1ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBsZXQgaGVhcCA9IHRoaXMuaGVhcDtcclxuICAgICAgICAvLyDlh7rpmJ/liJfmk43kvZzvvIzlvLnlh7rmlbDmja7lpLTlhYPntKBcclxuICAgICAgICBsZXQgZGF0YSA9IGhlYXBbMF07XHJcbiAgICAgICAgLy8g55So5bC+5YWD57Sg5aGr5YWF5aS05YWD57SgXHJcbiAgICAgICAgaGVhcFswXSA9IGhlYXBbaGVhcC5sZW5ndGggLSAxXTtcclxuICAgICAgICAvLyDliKDpmaTlsL7oioLngrlcclxuICAgICAgICBoZWFwLnBvcCgpO1xyXG5cclxuICAgICAgICAvL+eEtuWQjuS7juagueiKgueCueS4i+a7pOWghlxyXG4gICAgICAgIGRvd25IZWFwQWRqdXN0KGhlYXAsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpe1xyXG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyDlr7nloIbov5vooYzkuIrmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcclxuZnVuY3Rpb24gdXBIZWFwQWRqdXN0KGhlYXAsIHBhcmVudCkge1xyXG4gICAgbGV0IGxlbiA9IGhlYXAubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChwYXJlbnQgPj0gMCkge1xyXG4gICAgICAgIGxldCBsZWZ0Q2hpbGQgPSAyICogcGFyZW50ICsgMTtcclxuICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XHJcbiAgICAgICAgbGV0IG1heCA9IGxlZnRDaGlsZDtcclxuXHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQgPCBsZW4pIHtcclxuICAgICAgICAgICAgbWF4ID0gaGVhcFtsZWZ0Q2hpbGRdLnByaW9yaXR5IDwgaGVhcFtyaWdodENoaWxkXS5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgPyByaWdodENoaWxkIDogbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5aaC5p6ccGFyZW506IqC54K55bCP5LqO5a6D55qE5p+Q5Liq5a2Q6IqC54K555qE6K+d77yM5q2k5pe2562b6YCJ5pON5L2cXHJcbiAgICAgICAgaWYgKGhlYXBbcGFyZW50XS5wcmlvcml0eSA8IGhlYXBbbWF4XS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICBsZXQgdGVtcCA9IGhlYXBbcGFyZW50XTtcclxuICAgICAgICAgICAgaGVhcFtwYXJlbnRdID0gaGVhcFttYXhdO1xyXG4gICAgICAgICAgICBoZWFwW21heF0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgLy8g57un57ut6L+b6KGM5pu05LiK5LiA5bGC55qE6L+H5rukXHJcbiAgICAgICAgICAgIHBhcmVudCA9IE1hdGguY2VpbChwYXJlbnQgLyAyKSAtIDE7XHJcbiAgICAgICAgfSBlbHNlIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyDlr7nloIbov5vooYzkuIvmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcclxuZnVuY3Rpb24gZG93bkhlYXBBZGp1c3QoaGVhcCwgcGFyZW50KSB7XHJcbiAgICBsZXQgbGVuID0gaGVhcC5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKDIgKiBwYXJlbnQgKyAxIDwgbGVuKSB7XHJcbiAgICAgICAgbGV0IGxlZnRDaGlsZCA9IDIgKiBwYXJlbnQgKyAxO1xyXG4gICAgICAgIGxldCByaWdodENoaWxkID0gbGVmdENoaWxkICsgMTtcclxuICAgICAgICBsZXQgbWF4ID0gbGVmdENoaWxkO1xyXG5cclxuICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xyXG4gICAgICAgICAgICBtYXggPSBoZWFwW2xlZnRDaGlsZF0ucHJpb3JpdHkgPCBoZWFwW3JpZ2h0Q2hpbGRdLnByaW9yaXR5XHJcbiAgICAgICAgICAgICAgICA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGVhcFtwYXJlbnRdLnByaW9yaXR5IDwgaGVhcFttYXhdLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wID0gaGVhcFtwYXJlbnRdO1xyXG4gICAgICAgICAgICBoZWFwW3BhcmVudF0gPSBoZWFwW21heF07XHJcbiAgICAgICAgICAgIGhlYXBbbWF4XSA9IHRlbXA7XHJcblxyXG4gICAgICAgICAgICBwYXJlbnQgPSBtYXg7XHJcbiAgICAgICAgfSBlbHNlIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgdGVzdCA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XHJcbnRlc3QuZW5RdWV1ZSg4LCA1KTtcclxudGVzdC5lblF1ZXVlKDcsIDIpO1xyXG50ZXN0LmVuUXVldWUoNiwgMSk7XHJcbnRlc3QuZW5RdWV1ZSg1LCA0KTtcclxudGVzdC5lblF1ZXVlKDQsIDcpO1xyXG50ZXN0LmVuUXVldWUoMywgMyk7XHJcbnRlc3QuZW5RdWV1ZSgyLCA4KTtcclxudGVzdC5lblF1ZXVlKDEsIDEwKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9RdWV1ZS9Qcmlvcml0eVF1ZXVlLmpzXG4gKiovIiwiLyoqXHJcbiAqIEFWTCBUUkVFIENsYXNzXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJpY2UgQ2hldmFsaWVyXHJcbiAqXHJcbiAqXHJcbiAqIEBkZXNjXHJcbiAqXHJcbiAqICAgIE1ldGhvZCAgICAgICAgICAgICAgICBUaW1lIENvbXBsZXhpdHlcclxuICogICAgX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cclxuICpcclxuICogICAgYWRkICAgICAgICAgICAgICAgICAgICBPKGxvZzIobikpXHJcbiAqICAgIHJlbW92ZSAgICAgICAgICAgICAgICBPKGxvZzIobikpXHJcbiAqICAgIGdldEZpcnN0ICAgICAgICAgICAgTygxKVxyXG4gKiAgICBnZXRMYXN0ICAgICAgICAgICAgICAgIE8oMSlcclxuICogICAgZ2V0Q291bnQgICAgICAgICAgICBPKDEpXHJcbiAqICAgIGFwcGx5ICAgICAgICAgICAgICAgIE8obilcclxuICogICAgY2xlYXIgICAgICAgICAgICAgICAgTyhuKVxyXG4gKlxyXG4gKiAgICBNZW1vcnkgQ29tcGxleGl0eSBpbiBPKG4pXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTm9kZShvYmopIHtcclxuICAgIHRoaXMub2JqZWN0ID0gb2JqO1xyXG4gICAgdGhpcy5oZWlnaHQgPSAxO1xyXG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XHJcbiAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBBdmxUcmVlKCkge1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgdGhpcy5maXJzdCA9IG51bGw7XHJcbiAgICB0aGlzLmxhc3QgPSBudWxsO1xyXG59XHJcbkF2bFRyZWUuY21wID0gZnVuY3Rpb24oYSwgYil7XHJcbiAgICBpZihhID4gYikgcmV0dXJuIDE7XHJcbiAgICBlbHNlIGlmKGEgPCBiKSByZXR1cm4gLTE7XHJcbiAgICBlbHNlIHJldHVybiAwO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZExlZnQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICBub2RlLnByZXZpb3VzID0gcGFyZW50LnByZXZpb3VzO1xyXG4gICAgbm9kZS5uZXh0ID0gcGFyZW50O1xyXG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgcGFyZW50LmxlZnQgPSBub2RlO1xyXG4gICAgcGFyZW50LnByZXZpb3VzID0gbm9kZTtcclxuXHJcbiAgICBpZiAobm9kZS5wcmV2aW91cykge1xyXG4gICAgICAgIG5vZGUucHJldmlvdXMubmV4dCA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhcmVudCA9PT0gdGhpcy5maXJzdCkge1xyXG4gICAgICAgIHRoaXMuZmlyc3QgPSBub2RlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgbm9kZS5wcmV2aW91cyA9IHBhcmVudDtcclxuICAgIG5vZGUubmV4dCA9IHBhcmVudC5uZXh0O1xyXG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgcGFyZW50LnJpZ2h0ID0gbm9kZTtcclxuICAgIHBhcmVudC5uZXh0ID0gbm9kZTtcclxuXHJcbiAgICBpZiAobm9kZS5uZXh0KSB7XHJcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyZW50ID09PSB0aGlzLmxhc3QpIHtcclxuICAgICAgICB0aGlzLmxhc3QgPSBub2RlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdGhpcy5jb3VudCArPSAxO1xyXG4gICAgdmFyIG5ld05vZGUgPSBuZXcgTm9kZShvYmopO1xyXG5cclxuICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJvb3QgPSBuZXdOb2RlO1xyXG4gICAgICAgIHRoaXMuZmlyc3QgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5yb290O1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5yb290O1xyXG5cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcblxyXG4gICAgICAgIHZhciBjbXAgPSBBdmxUcmVlLmNtcChvYmosIGN1cnJlbnQub2JqZWN0KTtcclxuICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIGxlZnRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVmdChuZXdOb2RlLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSaWdodChuZXdOb2RlLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMZWZ0KG5ld05vZGUsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmlnaHQobmV3Tm9kZSwgY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmhlaWdodCA8IGN1cnJlbnQubGVmdC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9iYWxhbmNlKG5ld05vZGUucGFyZW50KTtcclxuXHJcbiAgICByZXR1cm4gbmV3Tm9kZTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlTGVmdFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgdmFyIGEgPSBsZWZ0LmxlZnQ7XHJcbiAgICB2YXIgYiA9IGxlZnQucmlnaHQubGVmdDtcclxuXHJcbiAgICBsZWZ0LnJpZ2h0LmxlZnQgPSBsZWZ0O1xyXG4gICAgbm9kZS5sZWZ0ID0gbGVmdC5yaWdodDtcclxuICAgIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICBsZWZ0LnBhcmVudCA9IG5vZGU7XHJcblxyXG4gICAgdmFyIGxlZnRMZWZ0ID0gbGVmdC5sZWZ0O1xyXG4gICAgbGVmdExlZnQucGFyZW50ID0gbGVmdDtcclxuICAgIGxlZnRMZWZ0LmxlZnQgPSBhO1xyXG4gICAgbGVmdExlZnQucmlnaHQgPSBiO1xyXG4gICAgaWYgKGEgIT09IG51bGwpIHtcclxuICAgICAgICBhLnBhcmVudCA9IGxlZnRMZWZ0O1xyXG4gICAgfVxyXG4gICAgaWYgKGIgIT09IG51bGwpIHtcclxuICAgICAgICBiLnBhcmVudCA9IGxlZnRMZWZ0O1xyXG4gICAgfVxyXG5cclxuICAgIGxlZnQuaGVpZ2h0ID0gbGVmdExlZnQuaGVpZ2h0ICsgMTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlTGVmdExlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICB2YXIgYyA9IGxlZnQucmlnaHQ7XHJcblxyXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xyXG4gICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5yaWdodCA9IGxlZnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxlZnQucmlnaHQgPSBub2RlO1xyXG4gICAgbGVmdC5wYXJlbnQgPSBub2RlLnBhcmVudDtcclxuICAgIG5vZGUucGFyZW50ID0gbGVmdDtcclxuICAgIG5vZGUubGVmdCA9IGM7XHJcbiAgICBpZihjICE9PSBudWxsKSB7XHJcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodExlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgIHZhciBhID0gcmlnaHQucmlnaHQ7XHJcbiAgICB2YXIgYiA9IHJpZ2h0LmxlZnQucmlnaHQ7XHJcblxyXG4gICAgcmlnaHQubGVmdC5yaWdodCA9IHJpZ2h0O1xyXG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0LmxlZnQ7XHJcbiAgICByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICByaWdodC5wYXJlbnQgPSBub2RlO1xyXG5cclxuICAgIHZhciByaWdodFJpZ2h0ID0gcmlnaHQucmlnaHQ7XHJcbiAgICByaWdodFJpZ2h0LnBhcmVudCA9IHJpZ2h0O1xyXG4gICAgcmlnaHRSaWdodC5yaWdodCA9IGE7XHJcbiAgICByaWdodFJpZ2h0LmxlZnQgPSBiO1xyXG4gICAgaWYgKGEgIT09IG51bGwpIHtcclxuICAgICAgICBhLnBhcmVudCA9IHJpZ2h0UmlnaHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGIucGFyZW50ID0gcmlnaHRSaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBub2RlLnJpZ2h0LmhlaWdodCA9IHJpZ2h0UmlnaHQuaGVpZ2h0ICsgMTtcclxufTtcclxuXHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5fYmFsYW5jZVJpZ2h0UmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgIHZhciBjID0gcmlnaHQubGVmdDtcclxuXHJcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcmlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudC5sZWZ0ID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByaWdodDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByaWdodC5sZWZ0ID0gbm9kZTtcclxuICAgIHJpZ2h0LnBhcmVudCA9IG5vZGUucGFyZW50O1xyXG4gICAgbm9kZS5wYXJlbnQgPSByaWdodDtcclxuICAgIG5vZGUucmlnaHQgPSBjO1xyXG4gICAgaWYoYyAhPT0gbnVsbCkge1xyXG4gICAgICAgIGMucGFyZW50ID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBub2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0IC0gMTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIC8vIEJhbGFuY2luZyB0aGUgdHJlZVxyXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xyXG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgbGVmdEhlaWdodCA9IChjdXJyZW50LmxlZnQgPT09IG51bGwpID8gMCA6IGN1cnJlbnQubGVmdC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0SGVpZ2h0ID0gKGN1cnJlbnQucmlnaHQgPT09IG51bGwpID8gMCA6IGN1cnJlbnQucmlnaHQuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSAxICsgTWF0aC5tYXgobGVmdEhlaWdodCwgcmlnaHRIZWlnaHQpO1xyXG5cclxuICAgICAgICBpZiAobmV3SGVpZ2h0ID4gY3VycmVudC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgY3VycmVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0SGVpZ2h0IC0gcmlnaHRIZWlnaHQgPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0LnJpZ2h0ICE9PSBudWxsICYmIChjdXJyZW50LmxlZnQubGVmdCA9PT0gbnVsbCB8fCBjdXJyZW50LmxlZnQubGVmdC5oZWlnaHQgPCBjdXJyZW50LmxlZnQucmlnaHQuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnQgUmlnaHQgQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VMZWZ0UmlnaHQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBMZWZ0IENhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VMZWZ0TGVmdChjdXJyZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdHJlZSBoYXMgYmVlbiBiYWxhbmNlZFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRIZWlnaHQgLSBsZWZ0SGVpZ2h0ID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmxlZnQgIT09IG51bGwgJiYgKGN1cnJlbnQucmlnaHQucmlnaHQgPT09IG51bGwgfHwgY3VycmVudC5yaWdodC5yaWdodC5oZWlnaHQgPCBjdXJyZW50LnJpZ2h0LmxlZnQuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJpZ2h0IExlZnQgQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodExlZnQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgUmlnaHQgQ2FzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZVJpZ2h0UmlnaHQoY3VycmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRyZWUgaGFzIGJlZW4gYmFsYW5jZWRcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpcyBiYWxhbmNlZFxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdGhpcy5fcmVtb3ZlKG9iaiwgdGhpcy5yb290KTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAob2JqLCBub2RlKSB7XHJcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XHJcblxyXG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgY21wID0gQXZsVHJlZS5jbXAob2JqLCBjdXJyZW50Lm9iamVjdCk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gY3VycmVudC5vYmplY3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgLT0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wcmV2aW91cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMubmV4dCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2luZyB0aGUgbm9kZSBieSB0aGUgc21hbGxlc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gaXRcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY3VycmVudC5yaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2UocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhbGFuY2VGcm9tO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5yaWdodCA9IHJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQucGFyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LmxlZnQgPSBsZWZ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3ZlKG9iaiwgY3VycmVudC5sZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShvYmosIGN1cnJlbnQucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUucmVtb3ZlQnlSZWYgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgLy8gTm9kZSByZW1vdmFsXHJcbiAgICB0aGlzLmNvdW50IC09IDE7XHJcblxyXG4gICAgaWYgKG5vZGUucHJldmlvdXMgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLmZpcnN0ID0gbm9kZS5uZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5uZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZS5wcmV2aW91cztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZS5wcmV2aW91cztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXBsYWNpbmcgdGhlIG5vZGUgYnkgdGhlIHNtYWxsZXN0IGVsZW1lbnQgZ3JlYXRlciB0aGFuIGl0XHJcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XHJcbiAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcclxuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XHJcblxyXG4gICAgaWYgKG5vZGUucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9iYWxhbmNlKHBhcmVudCk7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlcGxhY2VtZW50ID0gbm9kZS5yaWdodDtcclxuICAgIHZhciBiYWxhbmNlRnJvbTtcclxuXHJcbiAgICBpZiAocmVwbGFjZW1lbnQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcGxhY2VtZW50LmxlZnQgPSBsZWZ0O1xyXG5cclxuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xyXG5cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XHJcbiAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVwbGFjZW1lbnQucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICByZXBsYWNlbWVudC5yaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xyXG5cclxuICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcclxuXHJcbiAgICBiYWxhbmNlRnJvbSA9IHJlcGxhY2VtZW50LnBhcmVudDtcclxuXHJcbiAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcclxuXHJcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XHJcblxyXG4gICAgcmV0dXJuIDE7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRGaXJzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmZpcnN0O1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0TGFzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmxhc3Q7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290O1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb3VudDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAocHJvY2Vzc2luZ0Z1bmMsIHBhcmFtcykge1xyXG4gICAgZm9yICh2YXIgY3VycmVudCA9IHRoaXMuZmlyc3Q7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50Lm5leHQpIHtcclxuICAgICAgICBwcm9jZXNzaW5nRnVuYyhjdXJyZW50Lm9iamVjdCwgcGFyYW1zKTtcclxuICAgIH1cclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKHByb2Nlc3NpbmdGdW5jLCBwYXJhbXMpIHtcclxuICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmxhc3Q7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzKSB7XHJcbiAgICAgICAgcHJvY2Vzc2luZ0Z1bmMoY3VycmVudC5vYmplY3QsIHBhcmFtcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXZsVHJlZTtcclxuXHJcblxyXG5jb25zb2xlLmxvZygnXFxuQVZMIHRyZWUgaW5zZXJ0MjogJyk7XHJcbnZhciB0ZXN0ID0gbmV3IEF2bFRyZWUoKTtcclxudGVzdC5hZGQoMyk7XHJcbnRlc3QuYWRkKDE0KTtcclxudGVzdC5hZGQoMjUpO1xyXG50ZXN0LmFkZCg4MSk7XHJcbnRlc3QuYWRkKDQ0KTtcclxuXHJcbi8qXHJcbiAxNFxyXG4gLyAgICBcXFxyXG4gMyAgICAgICA0NFxyXG4gLyAgIFxcXHJcbiAyNSAgICAgODFcclxuICovXHJcblxyXG5cclxuY29uc29sZS5sb2coJ3JlbW92ZV9SZWN1cnNpdmUgMjonKTtcclxuXHJcbnRlc3QucmVtb3ZlKDgxKTtcclxudGVzdC5yZW1vdmUoMyk7XHJcbnRlc3QucmVtb3ZlKDE0KTtcclxudGVzdC5yZW1vdmUoMjUpO1xyXG50ZXN0LnJlbW92ZSg0NCk7XHJcblxyXG5cclxubGV0IHN0ciA9ICdja25vYmZqdGxwcWFlZ3JtZGhzJztcclxuLy92YXIgc3RyID0gJ2NrYmZqbGFlZ21kaCc7XHJcblxyXG5cclxudGVzdCA9IG5ldyBBdmxUcmVlKCk7XHJcbmZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpe1xyXG4gICAgdGVzdC5hZGQoc3RyW2ldKTtcclxufVxyXG5cclxuXHJcbnRlc3QucmVtb3ZlKCdlJyk7XHJcbnRlc3QucmVtb3ZlKCdoJyk7XHJcbnRlc3QucmVtb3ZlKCdiJyk7XHJcbnRlc3QucmVtb3ZlKCdsJyk7XHJcbnRlc3QucmVtb3ZlKCdmJyk7XHJcbnRlc3QucmVtb3ZlKCdqJyk7XHJcbnRlc3QucmVtb3ZlKCdnJyk7XHJcbnRlc3QucmVtb3ZlKCdkJyk7XHJcbnRlc3QucmVtb3ZlKCdrJyk7XHJcbnRlc3QucmVtb3ZlKCdhJyk7XHJcbnRlc3QucmVtb3ZlKCdtJyk7XHJcbnRlc3QucmVtb3ZlKCduJyk7XHJcbnRlc3QucmVtb3ZlKCdvJyk7XHJcbnRlc3QucmVtb3ZlKCdwJyk7XHJcbnRlc3QucmVtb3ZlKCdxJyk7XHJcbnRlc3QucmVtb3ZlKCdyJyk7XHJcbnRlc3QucmVtb3ZlKCdzJyk7XHJcbnRlc3QucmVtb3ZlKCd0Jyk7XHJcbnRlc3QucmVtb3ZlKCdjJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0FWTFRyZWUuanNcbiAqKi8iLCIvKlxyXG4gTUlUIExpY2Vuc2VcclxuIENvcHlyaWdodCAoYykgMjAxMiBTYW50YW51IEJhc3VcclxuIENvcHlyaWdodCAoYykgMjAxMyBEYW5pZWwgV2lydHpcclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxyXG4gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxyXG4gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vLyBCYXNlZCBvbiBTYW50YW51IEJhc3UncyBCUGx1c0pTXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW50YW51YmFzdS9CUGx1c0pTXHJcbi8vIE1vZGlmaWVkIGZvciBzdGFuZC1hbG9uZSB1c2VcclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBCVHJlZS5qc1xyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9CVHJlZS5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGVmaW5lZCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAxMDA7XHJcbiAgICAgICAgdGhpcy5tZXJnZVRocmVzaG9sZCA9IG9wdGlvbnMubWVyZ2VUaHJlc2hvbGQgfHwgNDA7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gW107XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldExlZnRQZWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRQZWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRMZWZ0UGVlciA9IGZ1bmN0aW9uIChsZWZ0UGVlcikge1xyXG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBsZWZ0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRQZWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuc2V0UmlnaHRQZWVyID0gZnVuY3Rpb24gKHJpZ2h0UGVlcikge1xyXG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gcmlnaHRQZWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldFN1cnBsdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKHRoaXMuZGF0YS5sZW5ndGggLSB0aGlzLm1lcmdlVGhyZXNob2xkKSAvIDIpKTtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRTdXJwbHVzRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VycGx1cyA9IHRoaXMuZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3BsaWNlKHRoaXMuZGF0YS5sZW5ndGggLSBzdXJwbHVzKTtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0TGVmdFN1cnBsdXNEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdXJwbHVzID0gdGhpcy5nZXRTdXJwbHVzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zcGxpY2UoMCwgc3VycGx1cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBJbnRlcm5hbE5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgdGhpcy5sZWZ0UGVlciA9IG9wdGlvbnMubGVmdFBlZXI7XHJcbiAgICAgICAgdGhpcy5yaWdodFBlZXIgPSBvcHRpb25zLnJpZ2h0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xyXG5cclxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVttaWRdLmtleSA8IGtleSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdLmtleSA+IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChsZWZ0IDwgcmlnaHQgJiYgIWZvdW5kKTtcclxuICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1pZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmRDaGlsZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY2xvYmJlcikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICB2YXIgbmV3Tm9kZXMsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIG5ld05vZGVzID0gY2hpbGQuaW5zZXJ0KGtleSwgdmFsdWUsIGNsb2JiZXIpO1xyXG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRFbGVtZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1swXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5ld05vZGVzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xyXG4gICAgICAgICAgICBuZXdOb2RlcyA9IGNoaWxkLmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcclxuICAgICAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5ld05vZGVzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbGVtZW50LnJpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSwgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdOb2RlcztcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2UoMCwgc3BsaXRJbmRleCksXHJcbiAgICAgICAgICAgIGxlZnRQZWVyOiB0aGlzLmxlZnRQZWVyLFxyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZShzcGxpdEluZGV4ICsgMSwgdGhpcy5kYXRhLmxlbmd0aCksXHJcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXHJcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xyXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRMZWZ0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIHZhciBtZXJnZUluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGNoaWxkO1xyXG4gICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IGNoaWxkLnJlbW92ZShrZXksIGVsZW1lbnQubGVmdCwgaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSA/IGNoaWxkLmdldFJpZ2h0UGVlcigpIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMSAmJiByZXR2YWwubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcmV0dmFsWzBdLCByZXR2YWxbM11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHZhbFsxXSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xyXG4gICAgICAgICAgICByZXR2YWwgPSBjaGlsZC5yZW1vdmUoa2V5LCBpbmRleCA+IDAgPyBjaGlsZC5nZXRMZWZ0UGVlcigpIDogdW5kZWZpbmVkLCBlbGVtZW50LnJpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMSAmJiByZXR2YWwubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcmV0dmFsWzBdLCByZXR2YWxbM11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHZhbFsxXSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyZ2VJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXJnZUVsZW1lbnQgPSB0aGlzLmRhdGFbbWVyZ2VJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID09IDUpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudC5rZXkgPSByZXR2YWxbM107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbWVyZ2VJbmRleCAtIDFdLnJpZ2h0ID0gcmV0dmFsWzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVttZXJnZUluZGV4ICsgMV0ubGVmdCA9IHJldHZhbFszXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UobWVyZ2VJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXV0uY29uY2F0KHRoaXMubWVyZ2UobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcclxuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGxlZnRTdXJwbHVzID0gMDtcclxuICAgICAgICB2YXIgbGVmdERhdGE7XHJcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XHJcbiAgICAgICAgdmFyIHJpZ2h0RGF0YTtcclxuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xyXG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIHJpZ2h0U3VycGx1cyA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnRTdXJwbHVzRGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXRSaWdodFN1cnBsdXNEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5zbGljZSgxKS5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0U3VycGx1c0RhdGFbbGVmdFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmRhdGFbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcclxuICAgICAgICAgICAgcmV0dmFsWzFdID0gbGVmdE1lcmdlT3B0aW9uO1xyXG4gICAgICAgICAgICByZXR2YWxbMl0gPSBsZWZ0U3VycGx1c0RhdGFbMF0ua2V5O1xyXG4gICAgICAgICAgICByZXR2YWxbM10gPSB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRTdXJwbHVzID4gbGVmdFN1cnBsdXMpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0U3VycGx1c0RhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0U3VycGx1c0RhdGFbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCByaWdodFN1cnBsdXNEYXRhLnNsaWNlKDAsIHJpZ2h0U3VycGx1c0RhdGEubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xyXG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR2YWxbMl0gPSByaWdodFN1cnBsdXNEYXRhW3JpZ2h0U3VycGx1c0RhdGEubGVuZ3RoIC0gMV0ua2V5O1xyXG4gICAgICAgICAgICByZXR2YWxbM10gPSByaWdodE1lcmdlT3B0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtZXJnZWRJbnRlcm5hbE5vZGU7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnREYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcmlnaHREYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHREYXRhWzBdLmxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHJpZ2h0RGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0RlZmluZWQocmlnaHREYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGVmdERhdGEuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdERhdGFbbGVmdERhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHRoaXMuZGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0RGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RGF0YVswXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLCByaWdodERhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnREYXRhW2xlZnREYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuZGF0YVswXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLmRhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRJbnRlcm5hbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENoaWxkKGtleSkuZmluZChrZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kQ2hpbGQoc3RhcnQpLnJhbmdlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGluZGVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbaW5kZW50ICsgXCJba2V5PVwiICsgZWxlbWVudC5rZXksIFwiXFxuXCIgKyBpbmRlbnQgKyBcIiAgICBMRUZUXFxuXCIgKyBlbGVtZW50LmxlZnQudG9TdHJpbmcoaW5kZW50ICsgXCIgICAgXCIpLCBcIlxcblwiICsgaW5kZW50ICsgXCIgICAgUklHSFRcXG5cIiArIGVsZW1lbnQucmlnaHQudG9TdHJpbmcoaW5kZW50ICsgXCIgICAgXCIpICsgXCJcXG5cIiArIGluZGVudCArIFwiXVwiXTtcclxuICAgICAgICB9KS5qb2luKFwiLFxcblwiKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIExlYWZOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBvcHRpb25zLmxlZnRQZWVyO1xyXG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gb3B0aW9ucy5yaWdodFBlZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICB2YXIgbWlkID0gbGVmdCArIE1hdGguZmxvb3IoKHJpZ2h0IC0gbGVmdCkgLyAyKTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW21pZF0ua2V5IDwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW21pZF0ua2V5ID4ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGxlZnQgIT09IHJpZ2h0ICYmICFmb3VuZCk7XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNsb2JiZXIpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbWVudC52YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhpcyBjb25kaXRpb24gbWF5IG5ldmVyIG9jY3VyLCBnaXZlbiB0aGUgd2F5IGZpbmRJbmRleCBpcyB3cml0dGVuXHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmtleSA8IGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4ICsgMSwgMCwge1xyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMCwge1xyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZSgwLCBzcGxpdEluZGV4KSxcclxuICAgICAgICAgICAgbGVmdFBlZXI6IHRoaXMubGVmdFBlZXIsXHJcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByaWdodE5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2Uoc3BsaXRJbmRleCwgdGhpcy5kYXRhLmxlbmd0aCksXHJcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXHJcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xyXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRMZWZ0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoICYmIGVsZW1lbnQua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudC52YWx1ZV0uY29uY2F0KHRoaXMubWVyZ2UobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcclxuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGxlZnRTdXJwbHVzID0gMDtcclxuICAgICAgICB2YXIgbGVmdERhdGE7XHJcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XHJcbiAgICAgICAgdmFyIHJpZ2h0RGF0YTtcclxuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xyXG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIHJpZ2h0U3VycGx1cyA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnRTdXJwbHVzRGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXRSaWdodFN1cnBsdXNEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5jb25jYXQodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgIHJldHZhbFsxXSA9IGxlZnRNZXJnZU9wdGlvbjtcclxuICAgICAgICAgICAgcmV0dmFsWzJdID0gdGhpcy5kYXRhWzBdLmtleTtcclxuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcclxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0U3VycGx1cyA+IGxlZnRTdXJwbHVzKSB7XHJcbiAgICAgICAgICAgIHZhciByaWdodFN1cnBsdXNEYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXRMZWZ0U3VycGx1c0RhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChyaWdodFN1cnBsdXNEYXRhKTtcclxuICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcclxuICAgICAgICAgICAgcmV0dmFsWzFdID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICByZXR2YWxbM10gPSByaWdodE1lcmdlT3B0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtZXJnZWRMZWFmTm9kZTtcclxuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdERhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChyaWdodERhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikgJiYgaXNEZWZpbmVkKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNEZWZpbmVkKHJpZ2h0RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQodGhpcy5kYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRMZWFmTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHREYXRhLmxlbmd0aCA8IGxlZnREYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQocmlnaHREYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGVmdERhdGEuY29uY2F0KHRoaXMuZGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGF0YS5sZW5ndGggJiYgZWxlbWVudC5rZXkgPT09IGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIHZhciByYW5nZSA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChpc0RlZmluZWQobm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBub2RlLmZpbmRJbmRleChzdGFydCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG5vZGUuZmluZEluZGV4KGVuZCk7XHJcbiAgICAgICAgICAgIHZhciBub2RlRGF0YSA9IG5vZGUuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IG5vZGVEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaChub2RlRGF0YVtpXS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZEluZGV4ID09IG5vZGVEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UmlnaHRQZWVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcclxuICAgICAgICByZXR1cm4gaW5kZW50ICsgXCJbXCIgKyB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5rZXk7XHJcbiAgICAgICAgICAgIH0pLnRvU3RyaW5nKCkgKyBcIl1cIjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFRyZWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMub3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8IDEwMDtcclxuICAgICAgICB0aGlzLm1lcmdlVGhyZXNob2xkID0gb3B0aW9ucy5tZXJnZVRocmVzaG9sZCB8fCA0MDtcclxuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgIGRhdGE6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QudG9TdHJpbmcoXCJcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XHJcbiAgICAgICAgdmFyIG5ld05vZGVzID0gdGhpcy5yb290Lmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcclxuICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2Rlc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHJldHZhbCA9IHRoaXMucm9vdC5yZW1vdmUoa2V5KTtcclxuICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJldHZhbFsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbFswXTtcclxuICAgIH07XHJcblxyXG4gICAgVHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmZpbmQoa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgVHJlZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmFuZ2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4cG9zZSBhbGwgdHlwZXMgb24gdG9wXHJcbiAgICBUcmVlLk5vZGUgPSBOb2RlO1xyXG4gICAgVHJlZS5JbnRlcm5hbE5vZGUgPSBJbnRlcm5hbE5vZGU7XHJcbiAgICBUcmVlLkxlYWZOb2RlID0gTGVhZk5vZGU7XHJcblxyXG4gICAgLy8gRW5hYmxlIG1vZHVsZSBsb2FkaW5nIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSkgeyAvLyBDb21tb25KU1xyXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBUcmVlO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9ICd1bmRlZmluZWQnICYmIGRlZmluZVtcImFtZFwiXSkgeyAvLyBBTURcclxuICAgICAgICBkZWZpbmUoXCJCUGx1c1RyZWVcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJlZTsgfSk7XHJcbiAgICB9IGVsc2UgeyAvLyBTaGltXHJcbiAgICAgICAgaWYgKCFnbG9iYWxbXCJkY29kZUlPXCJdKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJQbHVzVHJlZVwiXSA9IFRyZWU7XHJcbiAgICB9XHJcblxyXG59KSh0aGlzKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0JQbHVzVHJlZS5qc1xuICoqLyIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBidHJlZS5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vZGNvZGVJTy9idHJlZS5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uIChtb2R1bGUsIGNvbnNvbGUpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyBtdWx0aXBsZSBhcnJheXMgaW50byBhIG5ldyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gey4uLltBcnJheV19IHZhcl9hcmdzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb25jYXQodmFyX2FyZ3MpIHtcclxuICAgICAgICAvLyBBcnJheSNjb25jYXQgYmVoYXZlcyBzdHJhbmdlbHkgZm9yIGVtcHR5IGFycmF5cywgc28uLi5cclxuICAgICAgICB2YXIgYSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGEsIGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoZXMgYW4gYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0geyp9IHZcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9yIC0xIGlmIG5vdCBmb3VuZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNlYXJjaChhLCB2KSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBmYXN0ZXIgdGhhbiBBcnJheSNpbmRleE9mIGJlY2F1c2UgaXQncyByYXcuIEhvd2V2ZXIsIHdlXHJcbiAgICAgICAgLy8gY2Fubm90IHVzZSBiaW5hcnkgc2VhcmNoIGJlY2F1c2Ugbm9kZXMgZG8gbm90IGhhdmUgYSBjb21wYXJhYmxlXHJcbiAgICAgICAgLy8ga2V5LiBJZiB0aGUgY29tcGlsZXIgaXMgc21hcnQsIGl0IHdpbGwgaW5saW5lIHRoaXMuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldID09PSB2KSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC1pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYnRyZWUgbmFtZXNwYWNlLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICovXHJcbiAgICB2YXIgYnRyZWUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmljdGx5IGNvbXBhcmVzIHR3byBzdHJpbmdzLCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyLiBObyBsb2NhbGVzLCBubyBudW1iZXIgZXh0ZW5zaW9uLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgYnRyZWUuc3RyY21wID0gZnVuY3Rpb24gc3RyY21wKGEsIGIpIHtcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB2YXIgYWM7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdmFyIGJjO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChhYyA9IGEuY2hhckNvZGVBdChpKSkgPCAoYmMgPSBiLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWMgPiBiYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgc2FtZSwgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoID8gMCA6IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHR3byBudW1iZXJzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgYnRyZWUubnVtY21wID0gZnVuY3Rpb24gaW50Y21wKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IChhID4gYiA/IDEgOiAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQlRyZWUgY2xhc3MgdXNpbmcgdGhlIGdpdmVuIG9yZGVyLlxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgYSBjbGFzcywgbm90IGFuIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcmRlciBEZWZhdWx0cyB0byAyXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8sID8pOm51bWJlcj19IGNvbXBhcmUgQ29tcGFyZSBpbXBsZW1lbnRhdGlvbiB0byB1c2Ugb24ga2V5c1xyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBidHJlZS5jcmVhdGUgPSBmdW5jdGlvbiAob3JkZXIsIGNvbXBhcmUpIHtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgb3JkZXJcclxuICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIG9yZGVyID0gNTI7IC8vIEJlbmNobWFya3MgcHJvb2ZlZCB0aGF0IHRoaXMgaXMgY2xvc2UgdG8gdGhlIG9wdGltdW1cclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBvcmRlciA9IE1hdGguZmxvb3Iob3JkZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9yZGVyID0gcGFyc2VJbnQob3JkZXIsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yZGVyIDwgMSkgb3JkZXIgPSAxO1xyXG4gICAgICAgIHZhciBtaW5PcmRlciA9IG9yZGVyID4gMSA/IE1hdGguZmxvb3Iob3JkZXIgLyAyKSA6IDE7XHJcblxyXG4gICAgICAgIC8vIFVzZSBudW1jbXAgYnkgZGVmYXVsdFxyXG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZSAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbXBhcmUgPSBidHJlZS5udW1jbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWYWxpZGF0ZXMgYSBub2RlIGFuZCBwcmludHMgZGVidWdnaW5nIGluZm8gaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV8IVRyZWV9IG5vZGVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUpIHsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHN0cmlwcGVkIGJ5IHRoZSBjb21waWxlclxyXG4gICAgICAgICAgICBpZiAoKG5vZGUgaW5zdGFuY2VvZiBUcmVlKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWF2ZXMubGVuZ3RoICsgMSAhPSBub2RlLm5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogSWxsZWdhbCBsZWFmL25vZGUgY291bnQgaW4gXCIgKyBub2RlICsgXCI6IFwiICsgbm9kZS5sZWF2ZXMubGVuZ3RoICsgXCIvXCIgKyBub2RlLm5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlYXZlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbGVhZiBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogXCIgKyBub2RlLmxlYXZlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5ub2Rlc1tpXSA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbm9kZSBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRyZWVOb2RlLlxyXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWVOb2RlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IShUcmVlTm9kZXxUcmVlKX0gcGFyZW50IFBhcmVudCBub2RlXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48IUxlYWY+PX0gbGVhdmVzIExlYWYgbm9kZXNcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxUcmVlTm9kZT49fSBub2RlcyBDaGlsZCBub2Rlc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmVlTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGxlYXZlcywgbm9kZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgbm9kZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFUcmVlTm9kZXwhVHJlZX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExlYWYgbm9kZXMgKG1heC4gb3JkZXIpLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhTGVhZj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmxlYXZlcyA9IGxlYXZlcyB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAobGVhZikge1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGlsZCBub2RlcyAobWF4LiBvcmRlcisxKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48VHJlZU5vZGU+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzIHx8IFtudWxsXTtcclxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkgbm9kZS5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZWFyY2hlcyBmb3IgdGhlIG5vZGUgdGhhdCB3b3VsZCBjb250YWluIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt7bGVhZjogIUxlYWYsIGluZGV4OiBudW1iZXJ9fHtub2RlOiAhVHJlZU5vZGUsIGluZGV4OiBudW1iZXJ9fSBMZWFmIGlmIHRoZSBrZXkgZXhpc3RzLCBlbHNlIHRoZSBpbnNlcnRpb24gbm9kZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMubGVhdmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYS5rZXksIGtleSkgPT0gMCkgcmV0dXJuIHtsZWFmOiBhLCBpbmRleDogMH07XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIGEua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5zZWFyY2goa2V5KTsgLy8gTGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge25vZGU6IHRoaXMsIGluZGV4OiAwfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5sZWF2ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYi5rZXksIGtleSkgPT0gMCkgcmV0dXJuIHtsZWFmOiBiLCBpbmRleDogaX07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBiLmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tpXS5zZWFyY2goa2V5KTsgLy8gSW5uZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge25vZGU6IHRoaXMsIGluZGV4OiBpfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBSaWdodFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogaX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogMH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgdW5kZWZpbmVkIGlzIHJldHVybmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoKGtleSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikgcmV0dXJuIHJlc3VsdC5sZWFmLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYSBrZXkvdmFsdWUgcGFpciBpbnRvIHRoaXMgbm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gb3ZlcndyaXRlIFdoZXRoZXIgdG8gb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlcywgZGVmYXVsdHMgdG8gYHRydWVgXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3VjY2Vzc2Z1bGx5IHNldCwgZmFsc2UgaWYgYWxyZWFkeSBwcmVzZW50IGFuZCBvdmVyd3JpdGUgaXMgYGZhbHNlYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcndyaXRlICE9PSAndW5kZWZpbmVkJyAmJiAhb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmxlYWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IC8vIEtleSBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHJlc3VsdC5ub2RlLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXg7XHJcbiAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMCwgbmV3IExlYWYobm9kZSwga2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICBub2RlLm5vZGVzLnNwbGljZShpbmRleCArIDEsIDAsIG51bGwpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWF2ZXMubGVuZ3RoID4gb3JkZXIpIHsgLy8gUmViYWxhbmNlXHJcbiAgICAgICAgICAgICAgICBub2RlLnNwbGl0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoaXMgbm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5IGhhcyBiZWVuIGRlbGV0ZWQsIGZhbHNlIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2goa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQubGVhZikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgbGVhZiA9IHJlc3VsdC5sZWFmLFxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGxlYWYucGFyZW50LFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbm9kZS5ub2Rlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlYXZlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5ub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5iYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gbGVmdC5sZWF2ZXNbbGVmdC5sZWF2ZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBsZWZ0LmRlbChtYXgua2V5KTtcclxuICAgICAgICAgICAgICAgIG1heC5wYXJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxLCBtYXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhbGFuY2VzIHRoaXMgbm9kZSB0byBmdWxmaWxsIGFsbCBjb25kaXRpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IFJvb3QgaGFzIGp1c3QgYSBzaW5nbGUgY2hpbGQgYW5kIG5vIGxlYXZlc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA9PSAwICYmIHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yb290ID0gdGhpcy5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yb290LnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPj0gbWluT3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBhc2VhcmNoKHRoaXMucGFyZW50Lm5vZGVzLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBpbmRleCA+IDAgPyB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCAtIDFdIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJlbnQubm9kZXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggKyAxXSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBzZXAsIGxlYWYsIHJlc3Q7XHJcbiAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCAmJiByaWdodC5sZWF2ZXMubGVuZ3RoID4gbWluT3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc2VwZXJhdG9yIGZyb20gcGFyZW50IHRvIHRoaXNcclxuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBzZXAucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnB1c2goc2VwKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGJsYW5rIHdpdGggdGhlIGZpcnN0IHJpZ2h0IGxlYWZcclxuICAgICAgICAgICAgICAgIGxlYWYgPSByaWdodC5sZWF2ZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmlnaHQgcmVzdCB0byB0aGlzXHJcbiAgICAgICAgICAgICAgICByZXN0ID0gcmlnaHQubm9kZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gbnVsbCAmJiBsZWZ0LmxlYXZlcy5sZW5ndGggPiBtaW5PcmRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgc2VwZXJhdG9yIGZyb20gcGFyZW50IHRvIHRoaXNcclxuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgc2VwLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy51bnNoaWZ0KHNlcCk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBibGFuayB3aXRoIHRoZSBsYXN0IGxlZnQgbGVhZlxyXG4gICAgICAgICAgICAgICAgbGVhZiA9IGxlZnQubGVhdmVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgdGhlIGxlZnQgcmVzdCB0byB0aGlzXHJcbiAgICAgICAgICAgICAgICByZXN0ID0gbGVmdC5ub2Rlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnVuc2hpZnQocmVzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoaXMgKyBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50ICsgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0ID0gbmV3IFRyZWVOb2RlKHRoaXMucGFyZW50LCBjb25jYXQodGhpcy5sZWF2ZXMsIFtzZXBdLCByaWdodC5sZWF2ZXMpLCBjb25jYXQodGhpcy5ub2RlcywgcmlnaHQubm9kZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVwbGFjZSB0aGUgbm9kZXMgaXQgc2VwZXJhdGVkIHdpdGggc3Vic3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXgsIDIsIHN1YnN0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgbGVmdCArIHNlcGVyYXRvciBmcm9tIHBhcmVudCArIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdCA9IG5ldyBUcmVlTm9kZSh0aGlzLnBhcmVudCwgY29uY2F0KGxlZnQubGVhdmVzLCBbc2VwXSwgdGhpcy5sZWF2ZXMpLCBjb25jYXQobGVmdC5ub2RlcywgdGhpcy5ub2RlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VwZXJhdG9yIGZyb20gdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlcy5zcGxpY2UoaW5kZXggLSAxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVwbGFjZSB0aGUgbm9kZXMgaXQgc2VwZXJhdGVkIHdpdGggc3Vic3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXggLSAxLCAyLCBzdWJzdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBcIiArIHRoaXMudG9TdHJpbmcodHJ1ZSkgKyBcIiBoYXMgbmVpdGhlciBhIGxlZnQgbm9yIGEgcmlnaHQgc2libGluZ1wiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5iYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdmFsaWRhdGUodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlKHRoaXMucGFyZW50KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnNwbGl0cyBhIGNoaWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IUxlYWZ9IGxlYWZcclxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZX0gcmVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS51bnNwbGl0ID0gZnVuY3Rpb24gKGxlYWYsIHJlc3QpIHtcclxuICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXN0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5sZWF2ZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGxlYWYua2V5LCBhLmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy51bnNoaWZ0KGxlYWYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zcGxpY2UoMSwgMCwgcmVzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmxlYXZlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShsZWFmLmtleSwgYi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5zcGxpY2UoaSwgMCwgbGVhZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuc3BsaWNlKGkgKyAxLCAwLCByZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5sZWF2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMucHVzaChsZWFmKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA+IG9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpdHMgdGhpcyBub2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmxlYXZlcy5sZW5ndGggLyAyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoMCwgaW5kZXgpLCB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUcmVlTm9kZSh0aGlzLCB0aGlzLmxlYXZlcy5zbGljZShpbmRleCArIDEpLCB0aGlzLm5vZGVzLnNsaWNlKGluZGV4ICsgMSkpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBbdGhpcy5sZWF2ZXNbaW5kZXhdXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZWFmID0gdGhpcy5sZWF2ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIHRoaXMubGVhdmVzLnNsaWNlKGluZGV4ICsgMSksIHRoaXMubm9kZXMuc2xpY2UoaW5kZXggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcyA9IHRoaXMubGVhdmVzLnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC51bnNwbGl0KGxlYWYsIHJlc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZU5vZGVzIFdoZXRoZXIgdG8gaW5jbHVkZSBzdWItbm9kZXMgb3Igbm90XHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5jbHVkZU5vZGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsLnB1c2godGhpcy5sZWF2ZXNbaV0ua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcyA9IFwiW1wiICsgdmFsLnRvU3RyaW5nKCkgKyBcIl1cIiArICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUgPyBcIjoqXCIgOiBcIjpcIiArIHRoaXMucGFyZW50KTtcclxuICAgICAgICAgICAgaWYgKGluY2x1ZGVOb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IFwiIC0+IFwiICsgdGhpcy5ub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcmludHMgb3V0IHRoZSBub2RlcyBsZWF2ZXMgYW5kIG5vZGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAoaW5kZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZW50OyBpKyspIHNwYWNlICs9IFwiIFwiO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLmxlYXZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaSArIDFdICE9PSBudWxsKSB0aGlzLm5vZGVzW2kgKyAxXS5wcmludChpbmRlbnQgKyAyKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwYWNlICsgdGhpcy5sZWF2ZXNbaV0ua2V5ICsgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSA/IFwiKlwiIDogXCJcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzWzBdICE9PSBudWxsKSB0aGlzLm5vZGVzWzBdLnByaW50KGluZGVudCArIDIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTGVhZiBjb250YWluaW5nIGEgdmFsdWUuXHJcbiAgICAgICAgICogQGNsYXNzIEEgTGVhZi5cclxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZX0gcGFyZW50XHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBMZWFmID0gZnVuY3Rpb24gKHBhcmVudCwga2V5LCB2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcmVudCBub2RlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVRyZWVOb2RlfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2V5LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7ISp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBWYWx1ZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGVhZi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5rZXk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlLlxyXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWUuXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVHJlZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IFRyZWVOb2RlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0cyBhIGtleS92YWx1ZSBwYWlyIGludG8gdGhlIHRyZWUuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHNldCwgZmFsc2UgaWYgYWxyZWFkeSBwcmVzZW50IGFuZCBvdmVyd3JpdGUgaXMgYGZhbHNlYFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUga2V5IGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB0aHJvdyhuZXcgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIiArIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QucHV0KGtleSwgdmFsdWUsIG92ZXJ3cml0ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgdW5kZWZpbmVkIGlzIHJldHVybmVkXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0KGtleSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoZSB0cmVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXkgaGFzIGJlZW4gZGVsZXRlZCwgZmFsc2UgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpICB0aHJvdyhuZXcgRXJyb3IoXCJJbGxlZ2FsIGtleTogXCIgKyBrZXkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5kZWwoa2V5KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCBrZXlzIFttaW5LZXksIC4uLiwgbWF4S2V5XSBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCl9IG1pbktleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nXHJcbiAgICAgICAgICogQHBhcmFtIHsoKnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpKT19IG1heEtleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHdhbGtzIHRpbGwgdGhlIGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcclxuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0FzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5sZWF2ZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1pbktleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1pbktleTtcclxuICAgICAgICAgICAgICAgIG1pbktleSA9IG1heEtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1heEtleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1heEtleTtcclxuICAgICAgICAgICAgICAgIG1heEtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWluS2V5ID0gdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGw7XHJcbiAgICAgICAgICAgIG1heEtleSA9IHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgcHRyLCBpbmRleDtcclxuICAgICAgICAgICAgaWYgKG1pbktleSA9PT0gbnVsbCkgeyAvLyBJZiB0aGVyZSBpcyBubyBtaW5pbXVtIGxpbWl0XHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJvb3Q7IC8vIHNldCBwdHIgdG8gdGhlIG91dGVyIGxlZnQgbm9kZVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1swXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMDsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBmaXJzdCBsZWFmXHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIEVsc2UgbG9va3VwXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtaW5LZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7IC8vIElmIHRoZSBtaW5pbXVtIGtleSBpdHNlbGYgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0LmxlYWYucGFyZW50OyAvLyBzZXQgcHRyIHRvIHRoZSBjb250YWluaW5nIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0Lm5vZGU7IC8vIHNldCBwdHIgdG8gdGhlIGluc2VydGlvbiBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXg7IC8vIGFuZCBzdGFydCBhdCB0aGUgaW5zZXJ0aW9uIGluZGV4IChrZXkgPiBtaW5LZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHB0ci5sZWF2ZXMubGVuZ3RoKSB7IC8vIG9uIG92ZXJydW4sIGJlZ2luIGF0IHRoZSBzZXBhcmF0b3IgaW4gdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHB0ci5wYXJlbnQubGVhdmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB0ci9pbmRleCBub3cgcG9pbnRzIGF0IG91ciBmaXJzdCByZXN1bHRcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhLZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1heEtleSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGtleXMgbGVzcyB0aGFuIG1heEtleVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgcHRyLmxlYXZlc1tpbmRleF0udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgYnJlYWtzIHRoZSBsb29wIGJ5IHJldHVybmluZyB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHRyLm5vZGVzW2luZGV4ICsgMV0gIT09IG51bGwpIHsgLy8gRGVzY2VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1tpbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzWzBdICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHB0ci5sZWF2ZXMubGVuZ3RoID4gaW5kZXggKyAxKSB7IC8vIE5leHRcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXNjZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHB0ci5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4ID49IHB0ci5sZWF2ZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsaWFzIG9mIHtAbGluayBUcmVlI3dhbGtBc2N9LlxyXG4gICAgICAgICAqIEBwYXJhbSB7KnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpfSBtaW5LZXkgSWYgb21pdHRlZCBvciBOVUxMLCBzdGFydHMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7KCp8KGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCkpKT19IG1heEtleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHdhbGtzIHRpbGwgdGhlIGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcclxuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2FsayA9IFRyZWUucHJvdG90eXBlLndhbGtBc2M7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdhbGtzIHRocm91Z2ggYWxsIGtleXMgW21pbktleSwgLi4uLCBtYXhLZXldIGluIGRlc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCl9IG1pbktleSBJZiBvbWl0dGVkIG9yIG51bGwsIHdhbGtzIHRpbGwgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBudWxsLCBzdGFydHMgYXQgdGhlIGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcclxuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0Rlc2MgPSBmdW5jdGlvbiAobWluS2V5LCBtYXhLZXksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWluS2V5ID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWluS2V5O1xyXG4gICAgICAgICAgICAgICAgbWluS2V5ID0gbWF4S2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4S2V5ID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWF4S2V5O1xyXG4gICAgICAgICAgICAgICAgbWF4S2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaW5LZXkgPSB0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbDtcclxuICAgICAgICAgICAgbWF4S2V5ID0gdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBwdHIsIGluZGV4O1xyXG4gICAgICAgICAgICBpZiAobWF4S2V5ID09PSBudWxsKSB7IC8vIElmIHRoZXJlIGlzIG5vIG1heGltdW0gbGltaXRcclxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucm9vdDsgLy8gc2V0IHB0ciB0byB0aGUgb3V0ZXIgcmlnaHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBwdHIubGVhdmVzLmxlbmd0aCAtIDE7IC8vIGFuZCBzdGFydCBhdCBpdHMgbGFzdCBsZWFmXHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIEVsc2UgbG9va3VwXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtYXhLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7IC8vIElmIHRoZSBtYXhpbXVtIGtleSBpdHNlbGYgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0LmxlYWYucGFyZW50OyAvLyBzZXQgcHRyIHRvIHRoZSBjb250YWluaW5nIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0Lm5vZGU7IC8vIHNldCBwdHIgdG8gdGhlIGluc2VydGlvbiBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXggLSAxOyAvLyBhbmQgc3RhcnQgYXQgdGhlIGluc2VydGlvbiBpbmRleC0xIChrZXkgPCBtYXhLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgMCkgeyAvLyBvbiB1bmRlcnJ1biwgYmVnaW4gYXQgdGhlIHNlcGFyYXRvciBpbiB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB0ci9pbmRleCBub3cgcG9pbnRzIGF0IG91ciBmaXJzdCByZXN1bHRcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW5LZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1pbktleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGtleXMgYmlnZ2VyIHRoYW4gbWluS2V5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socHRyLmxlYXZlc1tpbmRleF0ua2V5LCBwdHIubGVhdmVzW2luZGV4XS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBicmVha3MgdGhlIGxvb3AgYnkgcmV0dXJuaW5nIHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwdHIubm9kZXNbaW5kZXhdICE9PSBudWxsKSB7IC8vIERlc2NlbmRcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcHRyLmxlYXZlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHsgLy8gTmV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBBc2NlbmRcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5wYXJlbnQubm9kZXMsIHB0cikgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4IDwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBrZXlzIGJldHdlZW4gbWluS2V5IGFuZCBtYXhLZXkgKGJvdGggaW5jbHVzaXZlKS5cclxuICAgICAgICAgKiBAcGFyYW0geyo9fSBtaW5LZXkgSWYgb21pdHRlZCwgY291bnRzIGZyb20gdGhlIHN0YXJ0XHJcbiAgICAgICAgICogQHBhcmFtIHsqPX0gbWF4S2V5IElmIG9taXR0ZWQsIGNvdW50cyB0aWxsIHRoZSBlbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMud2FsayhcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtaW5LZXkgIT0gJ3VuZGVmaW5lZCcgPyBtaW5LZXkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyBuKys7IH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpbnRzIG91dCBhbGwgbm9kZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QucHJpbnQoMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlRyZWUoXCIgKyBvcmRlciArIFwiKSBcIiArIHRoaXMucm9vdC50b1N0cmluZygpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBUcmVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJ0cmVlO1xyXG5cclxufSkobW9kdWxlLCBjb25zb2xlKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0JUcmVlLmpzXG4gKiovIiwiLypcclxuIOaKmOWNiuafpeaJvihCaW5hcnkgU2VhcmNoKVxyXG5cclxuIOaKmOWNiuafpeaJvuWPiOensOS4uuS6jOWIhuafpeaJvu+8jOaYr+S4gOenjeaViOeOh+i+g+mrmOeahOafpeaJvuaWueazleOAglxyXG4g5YmN5o+Q5p2h5Lu277ya5p+l5om+6KGo5Lit55qE5omA5pyJ6K6w5b2V5piv5oyJ5YWz6ZSu5a2X5pyJ5bqPKOWNh+W6j+aIlumZjeW6jykg44CCXHJcbiDmn6Xmib7ov4fnqIvkuK3vvIzlhYjnoa7lrprlvoXmn6Xmib7orrDlvZXlnKjooajkuK3nmoTojIPlm7TvvIznhLblkI7pgJDmraXnvKnlsI/ojIPlm7Qo5q+P5qyh5bCG5b6F5p+l6K6w5b2V5omA5Zyo5Yy66Ze057yp5bCP5LiA5Y2KKe+8jOebtOWIsOaJvuWIsOaIluaJvuS4jeWIsOiusOW9leS4uuatouOAglxyXG5cclxuIDEgIOafpeaJvuaAneaDs1xyXG4g55SoTG9344CBSGlnaOWSjE1pZOihqOekuuW+heafpeaJvuWMuumXtOeahOS4i+eVjOOAgeS4iueVjOWSjOS4remXtOS9jee9ruaMh+mSiO+8jOWIneWAvOS4ukxvdz0w77yMSGlnaD1uIC0gMeOAglxyXG4g4pG0ICDlj5bkuK3pl7TkvY3nva5NaWTvvJpNaWQ9TWF0aC5mbG9vcigoTG93K0hpZ2gpLzIp77ybXHJcbiDikbUgIOavlOi+g+S4remXtOS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcclxuIOKRoCAg55u4562J77yaIOafpeaJvuaIkOWKn++8m1xyXG4g4pGhICDlpKfkuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTliY3ljYrmrrXvvIzkv67mlLnkuIrnlYzmjIfpkojvvJogSGlnaD1NaWQtMe+8jOi9rOKRtCDvvJtcclxuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q6177yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m1xyXG4g55u05Yiw6LaK55WMKExvdz5IaWdoKe+8jOafpeaJvuWksei0peOAglxyXG5cclxuIDIgIOeul+azleWIhuaekFxyXG4g4pGgICDmn6Xmib7ml7bmr4/nu4/ov4fkuIDmrKHmr5TovoPvvIzmn6Xmib7ojIPlm7TlsLHnvKnlsI/kuIDljYrvvIzor6Xov4fnqIvlj6/nlKjkuIDmo7Xkuozlj4nmoJHooajnpLrvvJpcclxuIOKXhiDmoLnnu5PngrnlsLHmmK/nrKzkuIDmrKHov5vooYzmr5TovoPnmoTkuK3pl7TkvY3nva7nmoTorrDlvZXvvJtcclxuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7liY3pnaLnmoTkvZzkuLrlt6blrZDmoJHnmoTnu5PngrnvvJtcclxuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7lkI7pnaLnmoTkvZzkuLrlj7PlrZDmoJHnmoTnu5PngrnvvJtcclxuIOWvueWQhOWtkOagkeadpeivtOmDveaYr+ebuOWQjOeahOOAgui/meagt+aJgOW+l+WIsOeahOS6jOWPieagkeensOS4uuWIpOWumuagkShEZWNpc2lvbiBUcmVlKeOAglxyXG4g4pGhICDlsIbkuozlj4nliKTlrprmoJHnmoTnrKxNYXRoLmZsb29yKE1hdGgubG9nKDIsIG4pKSsx5bGC5LiK55qE57uT54K56KGl6b2Q5bCx5oiQ5Li65LiA5qO15ruh5LqM5Y+J5qCR77yM5rex5bqm5LiN5Y+Y77yMaD0gTWF0aC5mbG9vcihNYXRoLmxvZygyLCBuICsgMSkpIOOAglxyXG4g4pGiICDnlLHmu6Hkuozlj4nmoJHmgKfotKjnn6XvvIznrKxpIOWxguS4iueahOe7k+eCueaVsOS4uk1hdGgucG93KDIsIGktMSkoaTw9aCkg77yM6K6+6KGo5Lit5q+P5Liq6K6w5b2V55qE5p+l5om+5qaC546H55u4562J77yM5Y2zUGk9MS9u77yM5p+l5om+5oiQ5Yqf5pe255qE5bmz5Z2H5p+l5om+6ZW/5bqmQVNM77yaXHJcbiAobisxKS9uKk1hdGgubG9nKDIsbisxKS0xXHJcbiDlvZNu5b6I5aSnIChuPjUwKeaXtu+8jCBBU0ziiYggTWF0aC5sb2coMixuKzEpLTHjgIJcclxuXHJcblxyXG4g5pe26Ze05aSN5p2C5bqmTyhsb2duKVxyXG4gKi9cclxuXHJcbi8vIOmdnumAkuW9kuW8j1xyXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHNUYWJsZSwga2V5KSB7XHJcbiAgICBsZXQgbG93ID0gMDtcclxuICAgIGxldCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgd2hpbGUobG93IDw9IGhpZ2gpe1xyXG4gICAgICAgIGxldCAgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XHJcbiAgICAgICAgbGV0IGVsZW0gPSBzVGFibGVbbWlkXTtcclxuXHJcbiAgICAgICAgaWYoZWxlbSA9PT0ga2V5KSByZXR1cm4gbWlkO1xyXG4gICAgICAgIGVsc2UgaWYoZWxlbSA8IGtleSkgbG93ID0gbWlkICsgMTtcclxuICAgICAgICBlbHNlIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5cclxuY29uc29sZS5sb2coJ2JpbmFyeVNlYXJjaDogJyk7XHJcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDEpKTsgIC8vIDBcclxuXHJcbi8vIOmAkuW9kuW8j1xyXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoUmVjdXJzaXZlKHNUYWJsZSwga2V5LCBsb3cgPSAwLCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDEpIHtcclxuICAgIGlmKGxvdyA+IGhpZ2gpIHJldHVybiAtMTtcclxuXHJcbiAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XHJcbiAgICBsZXQgZWxlbSA9IHNUYWJsZVttaWRdO1xyXG5cclxuICAgIGlmKGVsZW0gPT09IGtleSkgcmV0dXJuIG1pZDtcclxuICAgIGVsc2UgaWYoZWxlbSA8IGtleSkgcmV0dXJuIGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShzVGFibGUsIGtleSwgbWlkICsgMSwgaGlnaCk7XHJcbiAgICBlbHNlIHJldHVybiBiaW5hcnlTZWFyY2hSZWN1cnNpdmUoc1RhYmxlLCBrZXksIGxvdywgbWlkIC0gMSk7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCdiaW5hcnlTZWFyY2hSZWN1cnNpdmU6ICcpO1xyXG5jb25zb2xlLmxvZyhiaW5hcnlTZWFyY2hSZWN1cnNpdmUoWzEsIDIsIDMsIDQsIDVdLCAxKSk7IC8vIDBcclxuY29uc29sZS5sb2coYmluYXJ5U2VhcmNoUmVjdXJzaXZlKFsxLCAyLCAzLCA0LCA1XSwgNikpOyAvLyAtMVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TZWFyY2gvQmluYXJ5U2VhcmNoLmpzXG4gKiovIiwiLypcclxuIEJsb29tIEZpbHRlcuaYr+S4gOenjeepuumXtOaViOeOh+W+iOmrmOeahOmaj+acuuaVsOaNrue7k+aehO+8jOWug+WIqeeUqOS9jeaVsOe7hOW+iOeugOa0geWcsOihqOekuuS4gOS4qumbhuWQiO+8jOW5tuiDveWIpOaWreS4gOS4quWFg+e0oOaYr+WQpuWxnuS6jui/meS4qumbhuWQiOOAgkJsb29tIEZpbHRlcueahOi/meenjemrmOaViOaYr+acieS4gOWumuS7o+S7t+eahO+8muWcqOWIpOaWreS4gOS4quWFg+e0oOaYr+WQpuWxnuS6juafkOS4qumbhuWQiOaXtu+8jOacieWPr+iDveS8muaKiuS4jeWxnuS6jui/meS4qumbhuWQiOeahOWFg+e0oOivr+iupOS4uuWxnuS6jui/meS4qumbhuWQiO+8iGZhbHNlIHBvc2l0aXZl77yJ44CC5Zug5q2k77yMQmxvb20gRmlsdGVy5LiN6YCC5ZCI6YKj5Lqb4oCc6Zu26ZSZ6K+v4oCd55qE5bqU55So5Zy65ZCI44CC6ICM5Zyo6IO95a655b+N5L2O6ZSZ6K+v546H55qE5bqU55So5Zy65ZCI5LiL77yMQmxvb20gRmlsdGVy6YCa6L+H5p6B5bCR55qE6ZSZ6K+v5o2i5Y+W5LqG5a2Y5YKo56m66Ze055qE5p6B5aSn6IqC55yB44CCXHJcblxyXG4g5Li65LqG6ZmN5L2O5Yay56qB55qE5qaC5b+177yMQmxvb20gRmlsdGVy5L2/55So5LqG5aSa5Liq5ZOI5biM5Ye95pWw77yM6ICM5LiN5piv5LiA5Liq44CCXHJcblxyXG4gQmxvb20gRmlsdGVy566X5rOV5aaC5LiL77yaXHJcbiDliJvlu7rkuIDkuKpt5L2NQml0U2V077yM5YWI5bCG5omA5pyJ5L2N5Yid5aeL5YyW5Li6MO+8jOeEtuWQjumAieaLqWvkuKrkuI3lkIznmoTlk4jluIzlh73mlbDjgILnrKxp5Liq5ZOI5biM5Ye95pWw5a+55a2X56ym5Liyc3Ry5ZOI5biM55qE57uT5p6c6K6w5Li6aO+8iGnvvIxzdHLvvInvvIzkuJRo77yIae+8jHN0cu+8ieeahOiMg+WbtOaYrzDliLBtLTEg44CCXHJcblxyXG4gKDEpIOWKoOWFpeWtl+espuS4sui/h+eoi1xyXG4g5LiL6Z2i5piv5q+P5Liq5a2X56ym5Liy5aSE55CG55qE6L+H56iL77yM6aaW5YWI5piv5bCG5a2X56ym5Liyc3Ry4oCc6K6w5b2V4oCd5YiwQml0U2V05Lit55qE6L+H56iL77yaXHJcbiDlr7nkuo7lrZfnrKbkuLJzdHLvvIzliIbliKvorqHnrpdo77yIMe+8jHN0cu+8ie+8jGjvvIgy77yMc3Ry77yJ4oCm4oCmIGjvvIhr77yMc3Ry77yJ44CC54S25ZCO5bCGQml0U2V055qE56ysaO+8iDHvvIxzdHLvvInjgIFo77yIMu+8jHN0cu+8ieKApuKApiBo77yIa++8jHN0cu+8ieS9jeiuvuS4ujHjgIJcclxuXHJcbiAoMikg5qOA5p+l5a2X56ym5Liy5piv5ZCm5a2Y5Zyo55qE6L+H56iLXHJcbiDkuIvpnaLmmK/mo4Dmn6XlrZfnrKbkuLJzdHLmmK/lkKbooqtCaXRTZXTorrDlvZXov4fnmoTov4fnqIvvvJpcclxuIOWvueS6juWtl+espuS4snN0cu+8jOWIhuWIq+iuoeeul2jvvIgx77yMc3Ry77yJ77yMaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInjgILnhLblkI7mo4Dmn6VCaXRTZXTnmoTnrKxo77yIMe+8jHN0cu+8ieOAgWjvvIgy77yMc3Ry77yJ4oCm4oCmIGjvvIhr77yMc3Ry77yJ5L2N5piv5ZCm5Li6Me+8jOiLpeWFtuS4reS7u+S9leS4gOS9jeS4jeS4ujHliJnlj6/ku6XliKTlrppzdHLkuIDlrprmsqHmnInooqvorrDlvZXov4fjgILoi6Xlhajpg6jkvY3pg73mmK8x77yM5YiZ4oCc6K6k5Li64oCd5a2X56ym5Liyc3Ry5a2Y5Zyo44CCXHJcbiDoi6XkuIDkuKrlrZfnrKbkuLLlr7nlupTnmoRCaXTkuI3lhajkuLox77yM5YiZ5Y+v5Lul6IKv5a6a6K+l5a2X56ym5Liy5LiA5a6a5rKh5pyJ6KKrQmxvb20gRmlsdGVy6K6w5b2V6L+H44CC77yI6L+Z5piv5pi+54S255qE77yM5Zug5Li65a2X56ym5Liy6KKr6K6w5b2V6L+H77yM5YW25a+55bqU55qE5LqM6L+b5Yi25L2N6IKv5a6a5YWo6YOo6KKr6K6+5Li6MeS6hu+8iVxyXG4g44CA5L2G5piv6Iul5LiA5Liq5a2X56ym5Liy5a+55bqU55qEQml05YWo5Li6Me+8jOWunumZheS4iuaYr+S4jeiDvTEwMCXnmoTogq/lrpror6XlrZfnrKbkuLLooqtCbG9vbSBGaWx0ZXLorrDlvZXov4fnmoTjgILvvIjlm6DkuLrmnInlj6/og73or6XlrZfnrKbkuLLnmoTmiYDmnInkvY3pg73liJrlpb3mmK/ooqvlhbbku5blrZfnrKbkuLLmiYDlr7nlupTvvInov5nnp43lsIbor6XlrZfnrKbkuLLliJLliIbplJnnmoTmg4XlhrXvvIznp7DkuLpmYWxzZSBwb3NpdGl2ZeOAglxyXG5cclxuICgzKSDliKDpmaTlrZfnrKbkuLLov4fnqItcclxuIOWtl+espuS4suWKoOWFpeS6huWwseiiq+S4jeiDveWIoOmZpOS6hu+8jOWboOS4uuWIoOmZpOS8muW9seWTjeWIsOWFtuS7luWtl+espuS4suOAguWunuWcqOmcgOimgeWIoOmZpOWtl+espuS4sueahOWPr+S7peS9v+eUqENvdW50aW5nIGJsb29tZmlsdGVyKENCRinvvIzov5nmmK/kuIDnp43ln7rmnKxCbG9vbSBGaWx0ZXLnmoTlj5jkvZPvvIxDQkblsIbln7rmnKxCbG9vbSBGaWx0ZXLmr4/kuIDkuKpCaXTmlLnkuLrkuIDkuKrorqHmlbDlmajvvIzov5nmoLflsLHlj6/ku6Xlrp7njrDliKDpmaTlrZfnrKbkuLLnmoTlip/og73kuobjgIJcclxuXHJcbiBCbG9vbSBGaWx0ZXLot5/ljZXlk4jluIzlh73mlbBCaXQtTWFw5LiN5ZCM5LmL5aSE5Zyo5LqO77yaQmxvb20gRmlsdGVy5L2/55So5LqGa+S4quWTiOW4jOWHveaVsO+8jOavj+S4quWtl+espuS4sui3n2vkuKpiaXTlr7nlupTjgILku47ogIzpmY3kvY7kuoblhrLnqoHnmoTmpoLnjofjgIJcclxuXHJcbiBCbG9vbSBGaWx0ZXLlj4LmlbDpgInmi6lcclxuICgxKeWTiOW4jOWHveaVsOmAieaLqVxyXG4g44CA44CA5ZOI5biM5Ye95pWw55qE6YCJ5oup5a+55oCn6IO955qE5b2x5ZON5bqU6K+l5piv5b6I5aSn55qE77yM5LiA5Liq5aW955qE5ZOI5biM5Ye95pWw6KaB6IO96L+R5Ly8562J5qaC546H55qE5bCG5a2X56ym5Liy5pig5bCE5Yiw5ZCE5LiqQml044CC6YCJ5oupa+S4quS4jeWQjOeahOWTiOW4jOWHveaVsOavlOi+g+m6u+eDpu+8jOS4gOenjeeugOWNleeahOaWueazleaYr+mAieaLqeS4gOS4quWTiOW4jOWHveaVsO+8jOeEtuWQjumAgeWFpWvkuKrkuI3lkIznmoTlj4LmlbDjgIJcclxuXHJcbiAoMikgbSxuLGvlgLzvvIzmiJHku6zlpoLkvZXlj5blgLxcclxuIOaIkeS7rOWumuS5ie+8mlxyXG4g5Y+v6IO95oqK5LiN5bGe5LqO6L+Z5Liq6ZuG5ZCI55qE5YWD57Sg6K+v6K6k5Li65bGe5LqO6L+Z5Liq6ZuG5ZCI77yIRmFsc2UgUG9zaXRpdmXvvIlcclxuIOS4jeS8muaKiuWxnuS6jui/meS4qumbhuWQiOeahOWFg+e0oOivr+iupOS4uuS4jeWxnuS6jui/meS4qumbhuWQiO+8iEZhbHNlIE5lZ2F0aXZl77yJ44CCXHJcblxyXG4g5ZOI5biM5Ye95pWw55qE5Liq5pWwa+OAgeS9jeaVsOe7hOWkp+Wwj23jgIHliqDlhaXnmoTlrZfnrKbkuLLmlbDph49u55qE5YWz57O744CC5ZOI5biM5Ye95pWw5Liq5pWwa+WPljEw77yM5L2N5pWw57uE5aSn5bCPbeiuvuS4uuWtl+espuS4suS4quaVsG7nmoQyMOWAjeaXtu+8jGZhbHNlIHBvc2l0aXZl5Y+R55Sf55qE5qaC546H5pivMC4wMDAwODg5IO+8jOWNszEw5LiH5qyh55qE5Yik5pat5Lit77yM5Lya5a2Y5ZyoOeasoeivr+WIpO+8jOWvueS6juS4gOWkqTHkur/mrKHnmoTmn6Xor6LvvIzor6/liKTnmoTmrKHmlbDkuLo5MDAw5qyh44CCXHJcblxyXG4gQmxvb21maWx0ZXIg55qE5bqU55So5Zy65pmvXHJcbiAxLum7keWQjeWNlVxyXG4g5pyA5YW45Z6L55qE5LiA5Liq5bqU55So5bCx5piv6buR5ZCN5Y2V5Yqf6IO977yM5a+555So5oi35ZCN56ew5oiW6ICFSVDmiJbogIVFbWFpbOi/m+ihjOi/h+a7pO+8jOavj+asoeajgOafpeaXtueUqGtleei/m+ihjGhhc2jlkI7vvIzlpoLmnpzkuI3lnKjpu5HlkI3ljZXlhoXnmoTvvIzogq/lrprlj6/ku6XpgJrooYzvvIzlpoLmnpzlnKjnmoTliJnkuI3lhYHorrjpgJrov4fvvIzor6/liKTmg4XlhrXlop7liqDkuIDkuKrmjpLpmaTlkI3ljZXmnaXov5vooYzmjpLpmaTjgIJcclxuIOivr+WIpOaDheWGte+8muWwhuato+W4uOeUqOaIt+WIpOWumuS4uum7keWQjeWNleeUqOaIt1xyXG5cclxuIDIu54is6Jmr6YeN5aSNVVJM5qOA5rWLXHJcbiDlnKjniKzlj5bnvZHnq5lVUkzml7bvvIzopoHmo4DmtYvov5nmnaFVUkzmmK/lkKblt7Lnu4/orr/pl67ov4fjgIJcclxuIOivr+WIpOaDheWGte+8muayoeacieiuv+mXrui/h+eahOivr+WIpOS4uuiuv+mXrui/h1xyXG5cclxuIDMu5a2X5YW457qg6ZSZXHJcbiDmo4Dmn6XljZXor43mi7zlhpnmmK/lkKbmraPnoa5cclxuIOivr+WIpOaDheWGte+8mumUmeivr+eahOWNleivjeivr+WIpOS4uuato+ehruOAglxyXG5cclxuIDQu56OB55uY5paH5Lu25qOA5rWLXHJcbiDlsIbno4Hnm5jkuK3miJbogIXmlbDmja7lupPkuK3mlbDmja5rZXnlrZjlhaXor6Xnu5PmnoTkuK3vvIzmo4DmtYvopoHorr/pl67nmoTmlbDmja7mmK/lkKblnKjno4Hnm5jmiJbmlbDmja7lupPkuK3vvIznhLblkI7lho3lj5Hotbforr/pl67vvIzpgb/lhY3nqbrmn6Xor6LpgKDmiJDno4Hnm5jmiJbmlbDmja7lupPljovlipvjgIJcclxuIOivr+WIpOaDheWGte+8muS4jeWtmOWcqOivpeaVsOaNruWNtOivr+WIpOS4uuacieivpeaVsOaNruOAglxyXG5cclxuIDUuQ0RO77yIc3F1aWTvvInku6PnkIbnvJPlrZjmioDmnK9cclxuIOWFiOafpeaJvuacrOWcsOacieaXoGNhY2hl77yM5aaC5p6c5rKh5pyJ5YiZ5Yiw5YW25LuW5YWE5byfIGNhY2hl5pyN5Yqh5Zmo5LiK5Y675p+l5om+44CC5Li65LqG6YG/5YWN5peg6LCT55qE5p+l6K+i77yM5Zyo5q+P5LiqY2FjaGXmnI3liqHlmajkuIrkv53lrZjlhbblhYTlvJ/mnI3liqHlmajnmoTnvJPlrZjlhbPplK7lrZfvvIzku6VibG9vbWZpbHRlcuaWueW8j+WtmOWCqO+8jOWGjeWOu+WFtuS7lmNhY2hl5pyN5Yqh5Zmo5p+l5om+5LmL5YmN77yM5YWI5qOA5p+l6K+l57uT5p6E5piv5ZCm5pyJdXJs77yM5aaC5p6c5pyJ5a2Y5ZyodXJs77yM5YaN5Y675a+55bqU5pyN5Yqh5Zmo5p+l5om+44CCXHJcbiDor6/liKTmg4XlhrXvvJog5a+55bqU5pyN5Yqh5Zmo5LiN5a2Y5Zyo6K+lVVJM55qE57yT5a2Y44CCXHJcblxyXG4gVGhhbmtzIHRvOlxyXG4gaHR0cDovL2FsbGVua2ltNjcuZ2l0aHViLmlvLzIwMTYvMDUvMTcvbm9kZWpzLWJ1ZmZlci10dXRvcmlhbC5odG1sXHJcbiBodHRwczovL2dpdGh1Yi5jb20vY2VlamJvdC94eC1ibG9vbVxyXG4gaHR0cHM6Ly9naXRodWIuY29tL3BpZXJyZWMvanMteHhoYXNoXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgaDMyIGFzIHh4aGFzaCB9IGZyb20gJ3h4aGFzaGpzJztcclxuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSAgZnJvbSAnY3J5cHRvJztcclxuXHJcbmNvbnN0IExOMl9TUVVBUkVEID0gTWF0aC5MTjIgKiBNYXRoLkxOMjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9vbUZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xyXG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KG9wdGlvbnMpe1xyXG4gICAgICAgIGlmKG9wdGlvbnMuc2VlZHMpe1xyXG4gICAgICAgICAgICB0aGlzLnNlZWRzID0gb3B0aW9ucy5zZWVkcztcclxuICAgICAgICAgICAgdGhpcy5oYXNoZXMgPSBvcHRpb25zLnNlZWRzLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNlZWRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0aW9ucy5oYXNoZXMgfHwgMDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlU2VlZHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYml0cyA9IG9wdGlvbnMuYml0cyB8fCAxMDI0O1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKE1hdGguY2VpbCh0aGlzLmJpdHMgLyA4KSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgb3B0aW1pemUoaXRlbUNvdW50LCBlcnJvclJhdGUgPSAwLjAwNSl7XHJcbiAgICAgICAgbGV0IGJpdHMgPSBNYXRoLnJvdW5kKC0xICogaXRlbUNvdW50ICogTWF0aC5sb2coZXJyb3JSYXRlKSAvIExOMl9TUVVBUkVEKTtcclxuICAgICAgICBsZXQgaGFzaGVzID0gTWF0aC5yb3VuZCgoYml0cyAvIGl0ZW1Db3VudCkgKiBNYXRoLkxOMik7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJpdHMsXHJcbiAgICAgICAgICAgIGhhc2hlc1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNyZWF0ZU9wdGltYWwoaXRlbUNvdW50LCBlcnJvclJhdGUpe1xyXG4gICAgICAgIGxldCBvcHRzID0gdGhpcy5vcHRpbWl6ZShpdGVtQ291bnQsIGVycm9yUmF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpe1xyXG4gICAgICAgIC8vICBidWYuZmlsbCgwKSB0byBpbml0aWFsaXplIGEgQnVmZmVyIHRvIHplcm9lc1xyXG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2dlbmVyYXRlU2VlZHMoKXtcclxuICAgICAgICBpZighdGhpcy5zZWVkcykgdGhpcy5zZWVkcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoZXM7ICsraSl7XHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgcHNldWRvLXJhbmRvbSBkYXRhLiBHZW5lcmF0ZSA0IGJ5dGVzLlxyXG4gICAgICAgICAgICBsZXQgYnVmID0gcmFuZG9tQnl0ZXMoNCk7XHJcbiAgICAgICAgICAgIC8vIFJlYWRzIGFuIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGZyb20gdGhlIEJ1ZmZlciBmcm9tIGluZGV4IDBcclxuICAgICAgICAgICAgdGhpcy5zZWVkc1tpXSA9IGJ1Zi5yZWFkVUludDMyTEUoMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgZW5kIHVwIHdpdGggdHdvIGlkZW50aWNhbCBzZWVkcyxcclxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgdW5saWtlbHkgYnV0IHBvc3NpYmxlLlxyXG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgaTsgKytqKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2VlZHNbaV0gPT09IHRoaXMuc2VlZHNbal0pe1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGQoYnVmKSB7XHJcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShidWYpKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGJ1Zil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1Zik7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoZXM7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzaCA9IHh4aGFzaChidWYsIHRoaXMuc2VlZHNbaV0pLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYml0ID0gaGFzaCAlIHRoaXMuYml0cztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEJpdChiaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhcyhpdGVtKXtcclxuICAgICAgICBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hlczsgKytpKXtcclxuICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goaXRlbSwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbGV0IGJpdCA9IGhhc2ggJSB0aGlzLmJpdHM7XHJcblxyXG4gICAgICAgICAgICBsZXQgaXNJblNldCA9IHRoaXMuX2dldEJpdChiaXQpO1xyXG4gICAgICAgICAgICBpZighaXNJblNldCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEJpdChiaXQpe1xyXG4gICAgICAgIGxldCBwb3MgPSBNYXRoLmZsb29yKGJpdCAvIDgpO1xyXG4gICAgICAgIGxldCBzaGlmdCA9IGJpdCAlIDg7XHJcblxyXG4gICAgICAgIGxldCBiaXRGaWVsZCA9IHRoaXMuYnVmZmVyW3Bvc107XHJcbiAgICAgICAgYml0RmllbGQgfD0gKDB4MSA8PCBzaGlmdCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJbcG9zXSA9IGJpdEZpZWxkO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRCaXQoYml0KXtcclxuICAgICAgICBsZXQgcG9zID0gTWF0aC5mbG9vcihiaXQgLyA4KTtcclxuICAgICAgICBsZXQgc2hpZnQgPSBiaXQgJSA4O1xyXG5cclxuICAgICAgICBsZXQgYml0RmllbGQgPSB0aGlzLmJ1ZmZlcltwb3NdO1xyXG5cclxuICAgICAgICByZXR1cm4gKGJpdEZpZWxkICYgKDB4MSA8PCBzaGlmdCkpICE9PSAwO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgZmlsdGVyID0gbmV3IEJsb29tRmlsdGVyKHsgaGFzaGVzOiA4LCBiaXRzOiAxMDI0IH0pO1xyXG5maWx0ZXIuYWRkKFsnY2F0JywgJ2RvZycsICdjb2F0aScsICdyZWQgcGFuZGEnXSk7XHJcbmNvbnNvbGUubG9nKGZpbHRlci5oYXMoJ2NhdCcpKTtcclxuY29uc29sZS5sb2coZmlsdGVyLmhhcygnY29hdCcpKTtcclxuY29uc29sZS5sb2coZmlsdGVyLmhhcygnbnVsbCcpKTtcclxuXHJcblxyXG5jbGFzcyBDb3VudGluZ0Jsb29tRmlsdGVyIGV4dGVuZHMgQmxvb21GaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KXtcclxuICAgICAgICBzdXBlcihvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KG9wdHMpe1xyXG4gICAgICAgIGlmIChvcHRzLnNlZWRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VlZHMgPSBvcHRzLnNlZWRzO1xyXG4gICAgICAgICAgICB0aGlzLmhhc2hlcyA9IG9wdHMuc2VlZHMubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0cy5oYXNoZXMgfHwgODtcclxuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVTZWVkcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaXRzID0gb3B0cy5iaXRzIHx8IDEwMjQ7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5iaXRzKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBjcmVhdGVPcHRpbWFsKGl0ZW1Db3VudCwgZXJyb3JSYXRlKXtcclxuICAgICAgICBsZXQgb3B0cyA9IEJsb29tRmlsdGVyLm9wdGltaXplKGl0ZW1Db3VudCwgZXJyb3JSYXRlKTtcclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMob3B0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKXtcclxuICAgICAgICBzdXBlci5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLm92ZXJmbG93ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0Qml0KGJpdCl7XHJcbiAgICAgICAgLy8gbm8tb3AgYXQgb3ZlcmZsb3dcclxuICAgICAgICBpZih0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUpe1xyXG4gICAgICAgICAgICArK3RoaXMub3ZlcmZsb3c7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICsrdGhpcy5idWZmZXJbYml0XTtcclxuICAgIH1cclxuXHJcbiAgICBfdW5TZXRCaXQoYml0KXtcclxuICAgICAgICBpZih0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUgfHwgdGhpcy5idWZmZXJbYml0XSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAtLXRoaXMuYnVmZmVyW2JpdF07XHJcbiAgICB9XHJcblxyXG4gICAgX2dldEJpdChiaXQpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltiaXRdICE9PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBoYXNPdmVyZmxvd2VkKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmZsb3cgPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZShpdGVtKXtcclxuICAgICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnNlZWRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goaXRlbSwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbGV0IGJpdCA9IGhhc2ggJSB0aGlzLmJpdHM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl91blNldEJpdChiaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zb2xlLmxvZygnQ291bnRpbmdCbG9vbUZpbHRlcicpXHJcbnZhciBmaWx0ZXIgPSBuZXcgQ291bnRpbmdCbG9vbUZpbHRlcih7IGhhc2hlczogOCwgYml0czogMTAyNCB9KTtcclxuZmlsdGVyLmFkZChbJ2NhdCcsICdkb2cnLCAnY29hdGknLCAncmVkIHBhbmRhJ10pO1xyXG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XHJcbmZpbHRlci5yZW1vdmUoJ2NhdCcpO1xyXG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XHJcbmNvbnNvbGUubG9nKGZpbHRlci5oYXMoJ2NvYXQnKSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0Jsb29tRmlsdGVyLmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzEvMTEuXHJcbiAqL1xyXG5cclxuLypcclxuXHJcbiDlpoLmnpzkuIDkuKrlhbPplK7lrZflj6/ku6XooajnpLrmiJDlrZfnrKbnmoTluo/lj7fvvIzljbPlrZfnrKbkuLLvvIzpgqPkuYjlj6/ku6XnlKjplK7moJHvvIhrZXl3b3JkIHRyZWXvvInvvIzlj4jnp7DmlbDlrZfmkJzntKLmoJHvvIhkaWdpdGFsIHNlYXJjaCB0cmVl77yJ5oiW5a2X56ym5qCR77yM5Lmf5Y+r5a2X5YW45qCR77yM5p2l6KGo56S66L+Z5qC355qE5a2X56ym5Liy55qE6ZuG5ZCI44CCXHJcblxyXG4g5qaC5b+1XHJcblxyXG4g5aaC5p6c5LiA5Liq5YWz6ZSu5a2X5Y+v5Lul6KGo56S65oiQ5a2X56ym55qE5bqP5Y+377yM5Y2z5a2X56ym5Liy77yM6YKj5LmI5Y+v5Lul55So6ZSu5qCR77yIa2V5d29yZCB0cmVl77yJ77yM5Y+I56ew5pWw5a2X5pCc57Si5qCR77yIZGlnaXRhbCBzZWFyY2ggdHJlZe+8ieaIluWtl+espuagke+8jOadpeihqOekuui/meagt+eahOWtl+espuS4sueahOmbhuWQiOOAgumUruagkeWPiOensOS4uuaVsOWtl+afpeaJvuagke+8iERpZ2l0YWwgU2VhcmNoIFRyZWUp5oiWVHJpZeagkSh0cmll5Li6cmV0cmlldmXkuK3pl7Q05Liq5a2X56ymKe+8jOWFtue7k+aehOWPl+WQr+WPkeS6juS4gOmDqOWkp+Wei+Wtl+WFuOeahOKAnOS5pui+ueagh+ebruKAneOAguWtl+WFuOS4reagh+WHuummluWtl+avjeaYryBBLEIsQywuLi4uWueahOWNleivjeaJgOWcqOmhtSzlho3lr7nlkITpg6jliIbmoIflh7rnrKzkuozlrZfmr43kuLpBLEIsQywuLi5a55qE5Y2V6K+N5omA5Zyo55qE6aG1LCAuLi4u562J562J44CCXHJcblxyXG4g6ZSu5qCR5piv5LiA56eN54m55q6K55qE5p+l5om+5qCR77yM5a6D55qE5p+Q5Liq6IqC54K55LiN5piv5YyF5ZCr5LiA5Liq5oiW5aSa5Liq5YWz6ZSu5a2X77yM6ICM5piv5Y+q5YyF5ZCr57uE5oiQ5YWz6ZSu5a2X55qE5LiA6YOo5YiG77yI5a2X56ym5oiW5pWw5a2X77yJ77yM5q+U5aaC77ya5aaC5p6c5YWz6ZSu5a2X5piv5pWw5YC877yM5YiZ6IqC54K55Lit5Y+q5YyF5ZCr5LiA5Liq5pWw5L2N77yb5aaC5p6c5YWz6ZSu5a2X5piv5Y2V6K+N77yM5YiZ6IqC54K55Lit5Y+q5YyF5ZCr5LiA5Liq5a2X5q+N5a2X56ym44CCXHJcblxyXG4g5qC557uT54K55LiN5Luj6KGo5Lu75L2V5a2X56ym77yM5qC55Lul5LiL56ys5LiA5bGC55qE57uT54K55a+55bqU5LqO5a2X56ym5Liy55qE56ys5LiA5Liq5a2X56ym77yM56ys5LqM5bGC55qE57uT54K55a+55bqU5LqO5a2X56ym5Liy55qE56ys5LqM5Liq5a2X56ym4oCm4oCm5q+P5Liq5a2X56ym5Liy5Y+v55Sx5LiA5Liq54m55q6K55qE5a2X56ym5aaC4oCcJOKAneetieS9nOS4uuWtl+espuS4sueahOe7k+adn+espu+8jOeUqOS4gOS4quWPtuWtkOe7k+eCueadpeihqOekuuivpeeJueauiuWtl+espuOAguaKiuS7juagueWIsOWPtuWtkOeahOi3r+W+hOS4iu+8jOaJgOaciee7k+eCue+8iOmZpOagueS7peWklu+8ieWvueW6lOeahOWtl+espui/nuaOpei1t+adpe+8jOWwseW+l+WIsOS4gOS4quWtl+espuS4suOAguWboOatpO+8jOavj+S4quWPtuWtkOe7k+eCueWvueW6lOS4gOS4quWFs+mUruWtl+OAguWcqOWPtuWtkOe7k+eCuei/mOWPr+S7peWMheWQq+S4gOS4quaMh+mSiO+8jOaMh+WQkeivpeWFs+mUruWtl+aJgOWvueW6lOeahOWFg+e0oOOAguaVtOS4quWtl+espuS4sumbhuWQiOS4reeahOWtl+espuS4sueahOaVsOebruetieS6juWPtuWtkOe7k+eCueeahOaVsOebruOAguWmguaenOS4gOS4qumbhuWQiOS4reeahOWFs+mUruWtl+mDveWFt+aciei/meagt+eahOWtl+espuS4sueJueaAp++8jOmCo+S5iO+8jOivpeWFs+mUruWtl+mbhuWQiOWwseWPr+mHh+eUqOi/meagt+S4gOajtemUruagkeadpeihqOekuuOAguS6i+WunuS4iu+8jOi/mOWPr+S7pei1i+S6iOKAnOWtl+espuS4suKAneabtOW5v+azm+eahOWQq+S5ie+8jOWug+WPr+S7peaYr+S7u+S9leexu+Wei+eahOWvueixoee7hOaIkOeahOS4suOAglxyXG5cclxuXHJcbiDplK7moJHnmoTlrZjlgqhcclxuIDHvvInlj4zpk77moJHooajnpLpcclxuIDIpIOWkmumHjemTvuihqOihqOekulxyXG5cclxuXHJcbiDplK7moJHnmoTlupTnlKjlnLrmma9cclxuXHJcbiBUcmll5piv5LiA56eN6Z2e5bi4566A5Y2V6auY5pWI55qE5pWw5o2u57uT5p6E77yM5L2G5pyJ5aSn6YeP55qE5bqU55So5a6e5L6L44CCXHJcbiDvvIgx77yJIOWtl+espuS4suajgOe0olxyXG4g5LqL5YWI5bCG5bey55+l55qE5LiA5Lqb5a2X56ym5Liy77yI5a2X5YW477yJ55qE5pyJ5YWz5L+h5oGv5L+d5a2Y5YiwdHJpZeagkemHjO+8jOafpeaJvuWPpuWkluS4gOS6m+acquefpeWtl+espuS4suaYr+WQpuWHuueOsOi/h+aIluiAheWHuueOsOmikeeOh+OAglxyXG4g5Li+5L6L77yaXHJcbiBAICDnu5nlh7pOIOS4quWNleivjee7hOaIkOeahOeGn+ivjeihqO+8jOS7peWPiuS4gOevh+WFqOeUqOWwj+WGmeiLseaWh+S5puWGmeeahOaWh+eroO+8jOivt+S9oOaMieacgOaXqeWHuueOsOeahOmhuuW6j+WGmeWHuuaJgOacieS4jeWcqOeGn+ivjeihqOS4reeahOeUn+ivjeOAglxyXG4gQCAg57uZ5Ye65LiA5Liq6K+N5YW477yM5YW25Lit55qE5Y2V6K+N5Li65LiN6Imv5Y2V6K+N44CC5Y2V6K+N5Z2H5Li65bCP5YaZ5a2X5q+N44CC5YaN57uZ5Ye65LiA5q615paH5pys77yM5paH5pys55qE5q+P5LiA6KGM5Lmf55Sx5bCP5YaZ5a2X5q+N5p6E5oiQ44CC5Yik5pat5paH5pys5Lit5piv5ZCm5ZCr5pyJ5Lu75L2V5LiN6Imv5Y2V6K+N44CC5L6L5aaC77yM6Iulcm9i5piv5LiN6Imv5Y2V6K+N77yM6YKj5LmI5paH5pyscHJvYmxlbeWQq+acieS4jeiJr+WNleivjeOAglxyXG5cclxuIO+8iDLvvInlrZfnrKbkuLLmnIDplb/lhazlhbHliY3nvIBcclxuIFRyaWXmoJHliKnnlKjlpJrkuKrlrZfnrKbkuLLnmoTlhazlhbHliY3nvIDmnaXoioLnnIHlrZjlgqjnqbrpl7TvvIzlj43kuYvvvIzlvZPmiJHku6zmiorlpKfph4/lrZfnrKbkuLLlrZjlgqjliLDkuIDmo7V0cmll5qCR5LiK5pe277yM5oiR5Lus5Y+v5Lul5b+r6YCf5b6X5Yiw5p+Q5Lqb5a2X56ym5Liy55qE5YWs5YWx5YmN57yA44CCXHJcbiDkuL7kvovvvJpcclxuIEAg57uZ5Ye6TiDkuKrlsI/lhpnoi7HmloflrZfmr43kuLLvvIzku6Xlj4pRIOS4quivoumXru+8jOWNs+ivoumXruafkOS4pOS4quS4sueahOacgOmVv+WFrOWFseWJjee8gOeahOmVv+W6puaYr+WkmuWwke+8n1xyXG4g6Kej5Yaz5pa55qGI77ya6aaW5YWI5a+55omA5pyJ55qE5Liy5bu656uL5YW25a+55bqU55qE5a2X5q+N5qCR44CC5q2k5pe25Y+R546w77yM5a+55LqO5Lik5Liq5Liy55qE5pyA6ZW/5YWs5YWx5YmN57yA55qE6ZW/5bqm5Y2z5a6D5Lus5omA5Zyo57uT54K555qE5YWs5YWx56WW5YWI5Liq5pWw77yM5LqO5piv77yM6Zeu6aKY5bCx6L2s5YyW5Li65LqG56a757q/77yIT2ZmbGluZe+8ieeahOacgOi/keWFrOWFseelluWFiO+8iExlYXN0IENvbW1vbiBBbmNlc3Rvcu+8jOeugOensExDQe+8iemXrumimOOAglxyXG4g6ICM5pyA6L+R5YWs5YWx56WW5YWI6Zeu6aKY5ZCM5qC35piv5LiA5Liq57uP5YW46Zeu6aKY77yM5Y+v5Lul55So5LiL6Z2i5Yeg56eN5pa55rOV77yaXHJcbiAxLiDliKnnlKjlubbmn6Xpm4bvvIhEaXNqb2ludCBTZXTvvInvvIzlj6/ku6Xph4fnlKjph4fnlKjnu4/lhbjnmoRUYXJqYW4g566X5rOV77ybXHJcbiAyLiDmsYLlh7rlrZfmr43moJHnmoTmrKfmi4nluo/liJfvvIhFdWxlciBTZXF1ZW5jZSDvvInlkI7vvIzlsLHlj6/ku6XovazkuLrnu4/lhbjnmoTmnIDlsI/lgLzmn6Xor6LvvIhSYW5nZSBNaW5pbXVtIFF1ZXJ577yM566A56ewUk1R77yJ6Zeu6aKY5LqG77ybXHJcbiDvvIjlhbPkuo7lubbmn6Xpm4bvvIxUYXJqYW7nrpfms5XvvIxSTVHpl67popjvvIznvZHkuIrmnInlvojlpJrotYTmlpnjgILvvIlcclxuXHJcbiDvvIgz77yJ5o6S5bqPXHJcbiBUcmll5qCR5piv5LiA5qO15aSa5Y+J5qCR77yM5Y+q6KaB5YWI5bqP6YGN5Y6G5pW05qO15qCR77yM6L6T5Ye655u45bqU55qE5a2X56ym5Liy5L6/5piv5oyJ5a2X5YW45bqP5o6S5bqP55qE57uT5p6c44CCXHJcbiDkuL7kvovvvJpcclxuIEAg57uZ5L2gTiDkuKrkupLkuI3nm7jlkIznmoTku4XnlLHkuIDkuKrljZXor43mnoTmiJDnmoToi7HmloflkI3vvIzorqnkvaDlsIblroPku6zmjInlrZflhbjluo/ku47lsI/liLDlpKfmjpLluo/ovpPlh7rjgIJcclxuXHJcbiDvvIg077yJIOS9nOS4uuWFtuS7luaVsOaNrue7k+aehOWSjOeul+azleeahOi+heWKqee7k+aehFxyXG4g5aaC5ZCO57yA5qCR77yMQUPoh6rliqjmnLrnrYlcclxuICovXHJcblxyXG5cclxuLypcclxuIOWPjOmTvuagkeihqOekulxyXG5cclxuIOS7peagkeeahOWtqeWtkOWFhOW8n+mTvuihqOadpeihqOekuumUruagke+8jOWImeavj+S4quWIhuaUr+e7k+eCueWMheaLrOS4ieS4quWfn++8mlxyXG4gc3ltYm9s5Z+f77ya5a2Y5YKo5YWz6ZSu5a2X55qE5LiA5Liq5a2X56ym77ybXHJcbiBmaXJzdOWfn++8muWtmOWCqOaMh+WQkeesrOS4gOajteWtkOagkeagueeahOaMh+mSiO+8m1xyXG4gbmV4dOWfn++8muWtmOWCqOaMh+WQkeWPs+WFhOW8n+eahOaMh+mSiOOAglxyXG5cclxuIOWQjOaXtu+8jOWPtuWtkOe7k+eCueS4jeWQq2ZpcnN05Z+f77yM5a6D55qEaW5mb3B0cuWfn+WtmOWCqOaMh+WQkeivpeWFs+mUruWtl+iusOW9leeahOaMh+mSiOOAglxyXG4g5q2k5pe255qE6ZSu5qCR5Y+I56ew5Y+M6ZO+5qCR44CCXHJcbiDlnKjlj4zpk77moJHkuK3mj5LlhaXmiJbliKDpmaTkuIDkuKrlhbPplK7lrZfvvIznm7jlvZPkuo7lnKjmoJHkuK3mn5DkuKrnu5PngrnkuIrmj5LlhaXmiJbliKDpmaTkuIDmo7XlrZDmoJHjgIJcclxuIOe7k+eCueeahOe7k+aehOS4reWPr+S7peiuvue9ruS4gOS4quaemuS4vuWPmOmHj+ihqOekuue7k+eCueeahOexu+Wei++8jOWPtuWtkOe7k+eCueWSjOWIhuaUr+e7k+eCueOAglxyXG4g5Y+25a2Q57uT54K55ZKM5YiG5pSv57uT54K56YO95pyJc3ltYm9s5Z+f5ZKMbmV4dOWfn+OAguS4jeWQjOeahOS4gOS4quWfn+WPr+S7peeUqOiBlOWQiOihqOekuu+8jOWPtuWtkOe7k+eCueWMheWQq2luZm9wdHLmjIflkJHorrDlvZXvvIzogIzliIbmlK/nu5PngrnmmK9maXJzdOWfn+aMh+WQkeWFtuesrOS4gOajteWtkOagkeOAglxyXG5cclxuXHJcbiDlj4zpk77moJHnmoTmn6Xmib5cclxuXHJcbiDlgYforr7nu5nlrprlgLzkuLpLLmNoKDAuLm51bS0xKSwg5YW25LitSy5jaFswXeiHsyBLLmNoW251bS0yXeihqOekuuW+heafpeWFs+mUruWtl+S4rW51bS0x5Liq5a2X56ym77yMIEsuY2hbbnVtLTFd5Li657uT5p2f56ymJOOAglxyXG4g5LuO5Y+M6ZO+5qCR55qE5qC55oyH6ZKI5Ye65Y+R77yM6aG6Zmlyc3TmjIfpkojmib7liLDnrKzkuIDmo7XlrZDmoJHnmoTmoLnnu5PngrnvvIzku6VLLmNoWzBd5ZKM5q2k57uT54K555qEc3ltYm9s5Z+f5q+U6L6D77yM6Iul55u4562J77yM5YiZ6aG6Zmlyc3Tln5/lho3mr5TovoPkuIvkuIDlrZfnrKbvvIzlkKbliJnmsr9uZXh05Z+f6aG65bqP5p+l5om+44CCXHJcbiDoi6Xnm7Toh7Pnqbrku43mr5TovoPkuI3nrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcclxuXHJcbiAvLyDnm7jlhbPotYTmlplcclxuIGh0dHA6Ly93d3cuY25ibG9ncy5jb20vcm9sbGVuaG9sdC9hcmNoaXZlLzIwMTIvMDQvMjQvMjQ2ODkzMi5odG1sXHJcbiBodHRwOi8vYmxvZy5jc2RuLm5ldC92X2p1bHlfdi9hcnRpY2xlL2RldGFpbHMvNjg5NzA5N1xyXG4gaHR0cDovL3d3dy5yYXljaGFzZS5uZXQvMTc4M1xyXG4gKi9cclxuXHJcbmNvbnN0IExFQUYgPSAnbGVhZic7XHJcbmNvbnN0IEJSQU5DSCA9ICdicmFuY2gnO1xyXG5jb25zdCBURVJNSU5BTCA9IG5ldyBTdHJpbmcoJyQnKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEb3VibGVMaW5rZWRUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCA9ICdyb290Jywga2luZCA9IEJSQU5DSCwgaW5mbyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcclxuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcclxuICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzeW5vU2VhcmNoIChrZXkpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuZmlyc3Q7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBwICYmIGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHAgJiYgcC5raW5kID09PSBMRUFGKSBicmVhaztcclxuICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5zeW1ib2wgPCBrZXlbaV0pIHAgPSBwLm5leHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocCAmJiBwLnN5bWJvbCA9PT0ga2V5W2ldKVxyXG4gICAgICAgICAgICAgICAgcCA9IHAuZmlyc3Q7XHJcbiAgICAgICAgICAgIGVsc2UgcCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHNlYXJjaCAoa2V5KSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmZpcnN0O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgcCAmJiBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChwICYmIHAuc3ltYm9sIDwga2V5W2ldKSBwID0gcC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSlcclxuICAgICAgICAgICAgICAgIHAgPSBwLmZpcnN0O1xyXG4gICAgICAgICAgICBlbHNlIHAgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHAgJiYgcC5raW5kID09PSBMRUFGID8gcC5pbmZvIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGtleSArPSAnJztcclxuICAgICAgICBsZXQgY3VyID0gdGhpcztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IGMgPSBrZXlbaV07XHJcbiAgICAgICAgICAgIGxldCBwID0gY3VyO1xyXG4gICAgICAgICAgICBjdXIgPSBjdXIuZmlyc3Q7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gbmV3IERvdWJsZUxpbmtlZFRyZWUoYywgQlJBTkNIKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOWmguaenOayoeacieWtkOe7k+eCueWImeWwhuaWsOe7k+eCueS9nOS4uuWtkOe7k+eCuVxyXG4gICAgICAgICAgICBpZiAoIWN1cikge1xyXG4gICAgICAgICAgICAgICAgcC5maXJzdCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHA7XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g5Zyo5YWE5byf57uT54K55Lit5om+5Yiw5a+55bqU57uT54K5XHJcbiAgICAgICAgICAgICAgICBpZihjIDwgY3VyLnN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gY3VyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuZmlyc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYyA+IGN1ci5zeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYjtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOebuOetie+8jOmAgOWHuuivpeW+queOr+afpeaJvuS4i+S4gOWtl+esplxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gY3VyLnN5bWJvbCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOWwj+S6juW9k+WJjeWtl+espu+8jOWImeaPkuWFpeWIsOW9k+WJjee7k+eCueWJjemdolxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGMgPCBjdXIuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGN1cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInlhYTlvJ/nu5PngrnliJnmj5LlhaXliLDlhYTlvJ/nu5PngrlcclxuICAgICAgICAgICAgICAgICAgICBpZighY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gYi5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDnlJ/miJDlj7blrZDnu5PngrlcclxuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChjdXIua2luZCA9PT0gQlJBTkNIKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGN1ci5maXJzdDtcclxuXHJcbiAgICAgICAgICAgIC8vIOWmguaenOS4jeWtmOWcqOWFs+mUruWtl+WImeivtOaYjuaPkuWFpeaIkOWKn++8jOWQpuWImeaPkuWFpeWksei0pVxyXG4gICAgICAgICAgICBpZighKGNoaWxkICYmIGNoaWxkLnN5bWJvbCA9PT0gVEVSTUlOQUwpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIuZmlyc3QgPSBuZXcgRG91YmxlTGlua2VkVHJlZShURVJNSU5BTCwgTEVBRiwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDoga2V5KTtcclxuICAgICAgICAgICAgICAgIGN1ci5maXJzdC5wYXJlbnQgPSBjdXI7XHJcbiAgICAgICAgICAgICAgICBjdXIuZmlyc3QubmV4dCA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZSAoa2V5KSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmZpcnN0O1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHAgJiYgaSA8IGtleS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5zeW1ib2wgPCBrZXlbaV0pIHAgPSBwLm5leHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocCAmJiBwLnN5bWJvbCA9PT0ga2V5W2ldKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcclxuICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgfSBlbHNlIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkYXRhID0gcC5pbmZvO1xyXG4gICAgICAgIHdoaWxlICghcC5uZXh0ICYmIHAucGFyZW50KSBwID0gcC5wYXJlbnQ7XHJcbiAgICAgICAgbGV0IHRvcCA9IHA7XHJcblxyXG4gICAgICAgIGlmICh0b3AgPT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwID0gdG9wLnBhcmVudDtcclxuICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICBwID0gcC5maXJzdDtcclxuICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgIGxldCBwcmU7XHJcbiAgICAgICAgICAgICAgICBpZiAocCA9PSB0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDliKDpmaTlnKhmaXJzdOWfn+S4iueahOWtkOagkee7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJlKSB0b3AucGFyZW50LmZpcnN0ID0gdG9wLnBhcmVudC5maXJzdC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWIoOmZpOWcqG5leHTln5/nmoTlhYTlvJ/nu5PngrlcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHByZS5uZXh0ID0gcHJlLm5leHQubmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZSA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgdGVzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKCk7XHJcbnRlc3QuaW5zZXJ0KCdDQUknKTtcclxudGVzdC5pbnNlcnQoJ0xBTicpO1xyXG50ZXN0Lmluc2VydCgnQ0FPJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEEnKTtcclxudGVzdC5pbnNlcnQoJ0NIQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEFPJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEVOJyk7XHJcbnRlc3QuaW5zZXJ0KCdMSScpO1xyXG50ZXN0Lmluc2VydCgnTElVJyk7XHJcbnRlc3QuaW5zZXJ0KCdaSEFPJyk7XHJcbnRlc3QuaW5zZXJ0KCdaSEFPJyk7XHJcblxyXG5jb25zb2xlLmxvZygnXFxuc2VhcmNoOiAnKTtcclxuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NBSScpKTtcclxuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcclxuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQU5HJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnWkhBT3gnKSk7XHJcblxyXG5jb25zb2xlLmxvZygnXFxucmVtb3ZlOicpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0FJJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0FJJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnTEFOJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0FPJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hBJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hBTkcnKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDSEFPJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hFTicpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0xJJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnTElVJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnWkhBTycpKTtcclxuXHJcblxyXG4vKlxyXG4g5aSa6YeN6ZO+6KGo6KGo56S6XHJcblxyXG4g6Iul5Lul5qCR55qE5aSa6YeN6ZO+6KGo6KGo56S66ZSu5qCR77yM5YiZ5qCR55qE5q+P5Liq57uT54K55Lit5bqU5ZCr5pyJZOS4quaMh+mSiOWfn++8jOatpOaXtueahOmUruagkeWPiOensFRyaWXmoJHjgIJcclxuIO+8iFRyaWXmmK/ku47mo4DntKJyZXRyaWV2ZeS4reWPluS4remXtOWbm+S4quWtl+espueahO+8jOivu+mfs+WQjHRyee+8ieOAglxyXG4g6Iul5LuO6ZSu5qCR5Lit5p+Q5Liq57uT54K55Yiw5Y+25a2Q57uT54K555qE6Lev5b6E5LiK5q+P5Liq57uT54K56YO95Y+q5pyJ5LiA5Liq5a2p5a2Q77yM5YiZ5Y+v5bCG6K+l6Lev5b6E5LiK5omA5pyJ57uT54K55Y6L57yp5oiQ5LiA5Liq4oCc5Y+25a2Q57uT54K54oCd77yM5LiU5Zyo6K+l5Y+25a2Q57uT54K55Lit5a2Y5YKo5YWz6ZSu5a2X5Y+K5oyH5ZCR6K6w5b2V55qE5oyH6ZKI562J5L+h5oGv44CCXHJcbiDlnKhUcmll5qCR5Lit5pyJ5Lik56eN57uT54K577yaXHJcbiDliIbmlK/nu5PngrnvvJrlkKvmnIlk5Liq5oyH6ZKI5Z+f5ZKM5LiA5Liq5oyH56S66K+l57uT54K55Lit6Z2e56m65oyH6ZKI5Z+f55qE5Liq5pWw55qE5pW05pWw5Z+f44CC5Zyo5YiG5pSv57uT54K55Lit5LiN6K6+5pWw5o2u5Z+f77yM5q+P5Liq5YiG5pSv57uT54K55omA6KGo56S655qE5a2X56ym5Z2H5pyJ5YW254i257uT54K55Lit5oyH5ZCR6K+l57uT54K555qE5oyH6ZKI5omA5Zyo5L2N572u5Yaz5a6a44CCXHJcbiDlj7blrZDnu5PngrnvvJrlkKvmnInlhbPplK7lrZfln5/lkozmjIflkJHorrDlvZXnmoTmjIfpkojln5/jgIJcclxuXHJcblxyXG4g5ZyoVHJpZeagkeS4iui/m+ihjOafpeaJvlxyXG5cclxuIOS7juaguee7k+eCueWHuuWPke+8jOayv+WSjOe7meWumuWAvOebuOW6lOeahOaMh+mSiOmAkOWxguWQkeS4i++8jOebtOiHs+WPtuWtkOe7k+eCue+8jOiLpeWPtuWtkOe7k+eCueS4reeahOWFs+mUruWtl+WSjOe7meWumuWAvOebuOetie+8jOWImeafpeaJvuaIkOWKn++8jOiLpeWIhuaUr+e7k+eCueS4reWSjOe7meWumuWAvOebuOW6lOeahOaMh+mSiOS4uuepuu+8jOaIluWPtuWtkOe7k+eCueS4reeahOWFs+mUruWtl+WSjOe7meWumuWAvOS4jeebuOetie+8jOWImeafpeaJvuS4jeaIkOWKn+OAglxyXG5cclxuXHJcbiDkvJjljJZUcmll5qCR55qE5rex5bqmXHJcblxyXG4g5oiR5Lus5Y+v5a+55YWz6ZSu5a2X6ZuG6YCJ5oup5LiA56eN5ZCI6YCC55qE5YiG5Ymy44CC5YWI5oyJ6aaW5a2X56ym5LiN6YCa5YiG5oiQ5aSa5Liq5a2Q6ZuG5LmL5ZCO77yM54S25ZCO5oyJ5pyA5ZCO5LiA5Liq5a2X56ym5LiN5ZCM5YiG5Ymy5q+P5Liq5a2Q6ZuG77yM5YaN5oyJ56ys5LqM5Liq5a2X56ym44CC44CC44CC5YmN5ZCO5Lqk5Y+J5YiG5Ymy44CC5LiA57yp5YePVHJpZeagkeeahOa3seW6plxyXG4gKi9cclxuLy8g5rGC5a2X56ym5Zyo5a2X5q+N6KGo5Lit55qE5bqP5Y+3XHJcbmZ1bmN0aW9uIG9yZGVyKGMpIHtcclxuICAgIHJldHVybiBjID8gYy50b0xvd2VyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgLSAnYScuY2hhckNvZGVBdCgwKSArIDEgOiAwO1xyXG59XHJcblxyXG4vLyDpgJrov4flm57muq/ms5XmuIXnkIZUcmll5qCR55qE5Ye95pWwXHJcbmZ1bmN0aW9uIHJlbW92ZU5vZGUodHJpZU5vZGUsIG9yZGVyLCBjbGVhcikge1xyXG4gICAgdHJpZU5vZGUuYnJhbmNoLm5vZGVzW29yZGVyXSA9IG51bGw7XHJcbiAgICAtLXRyaWVOb2RlLmJyYW5jaC5udW07XHJcblxyXG4gICAgaWYgKCFjbGVhcikgcmV0dXJuO1xyXG5cclxuICAgIGxldCBub2RlcyA9IHRyaWVOb2RlLmJyYW5jaC5ub2RlcztcclxuICAgIGxldCBwYXJlbnQgPSB0cmllTm9kZS5wYXJlbnQ7XHJcbiAgICBsZXQgcHJlID0gdHJpZU5vZGU7XHJcblxyXG4gICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgaW4gbm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGkpICYmIG5vZGVzW2ldKSByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaW5kZXg7XHJcbiAgICAgICAgbGV0IHBhcmVudE5vZGVzID0gcGFyZW50LmJyYW5jaC5ub2RlcztcclxuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmVudE5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2Rlcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBwYXJlbnROb2Rlc1tpXSAmJiBwYXJlbnROb2Rlc1tpXSA9PSBwcmUpXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudC5icmFuY2gubm9kZXNbaW5kZXhdID0gbnVsbDtcclxuICAgICAgICAtLXBhcmVudC5icmFuY2gubnVtO1xyXG5cclxuICAgICAgICBwcmUgPSBwYXJlbnQ7XHJcbiAgICAgICAgbm9kZXMgPSBwYXJlbnQuYnJhbmNoLm5vZGVzO1xyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUcmllVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihraW5kID0gQlJBTkNIKSB7XHJcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChraW5kID09PSBMRUFGKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVhZiA9IHtcclxuICAgICAgICAgICAgICAgIGtleTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGluZm86IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJyYW5jaCA9IHtcclxuICAgICAgICAgICAgICAgIC8vIOKAnCTigJ3kuLrnrKzkuIDkuKrlrZfnrKbvvIzlkI7nu63kuLoyNuS4quWtl+avjVxyXG4gICAgICAgICAgICAgICAgbm9kZXM6IG5ldyBBcnJheSgyNyksXHJcbiAgICAgICAgICAgICAgICBudW06IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VhcmNoIChrZXkpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMsIGkgPSAwO1xyXG4gICAgICAgIGZvciAoO1xyXG4gICAgICAgICAgICAgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aDtcclxuICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKTtcclxuXHJcbiAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgaWYgKHAua2luZCA9PT0gTEVBRiAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBwLmxlYWYuaW5mbztcclxuICAgICAgICAgICAgLy8g5ZCM5LmJ6K+NXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5icmFuY2gubm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAocCAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBwLmxlYWYuaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0IChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgLy8g5bu65Y+25a2Q57uT54K5XHJcbiAgICAgICAgbGV0IHEgPSBuZXcgVHJpZVRyZWUoTEVBRik7XHJcbiAgICAgICAgcS5sZWFmLmtleSA9IGtleTtcclxuICAgICAgICBxLmxlYWYuaW5mbyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAvLyDoh6rkuIrogIzkuIvmn6Xmib5cclxuICAgICAgICBsZXQgbGFzdDtcclxuICAgICAgICBsZXQgcCA9IHRoaXMsIGkgPSAwO1xyXG4gICAgICAgIGZvciAoO1xyXG4gICAgICAgICAgICAgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aCAmJiBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXTtcclxuICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKSBsYXN0ID0gcDtcclxuXHJcbiAgICAgICAgLy8g5aaC5p6c5pyA5ZCO6JC95Yiw5YiG5pSv57uT54K577yI5peg5ZCM5LmJ6K+N77yJXHJcbiAgICAgICAgLy8g55u05o6l6L+e5LiK5Y+25a2QXHJcbiAgICAgICAgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XHJcbiAgICAgICAgICAgIHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldID0gcTtcclxuICAgICAgICAgICAgcS5wYXJlbnQgPSBwO1xyXG4gICAgICAgICAgICArK3AuYnJhbmNoLm51bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5aaC5p6c5pyA5ZCO6JC95Yiw5Y+25a2Q57uT54K577yI5pyJ5ZCM5LmJ6K+N77yJXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwLmxlYWYua2V5ID09PSBrZXkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIOW7uueri+aWsOeahOWIhuaUr+e7k+eCuVxyXG4gICAgICAgICAgICBsZXQgciA9IG5ldyBUcmllVHJlZShCUkFOQ0gpO1xyXG4gICAgICAgICAgICAvLyDnlKjmlrDnmoTliIbmlK/nu5Pngrnlj5bku6PogIHlj7blrZDnu5PngrnlkozkuIrkuIDlsYLnmoTogZTns7tcclxuICAgICAgICAgICAgbGFzdC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2kgLSAxXSldID0gcjtcclxuICAgICAgICAgICAgci5wYXJlbnQgPSBsYXN0O1xyXG4gICAgICAgICAgICByLmJyYW5jaC5udW0gPSAyO1xyXG4gICAgICAgICAgICByLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSA9IHE7XHJcbiAgICAgICAgICAgIHEucGFyZW50ID0gcjtcclxuICAgICAgICAgICAgLy8g5paw5YiG5pSv57uT54K55LiO5paw6ICB5Lik5Liq5Y+25a2Q57uT54K555u46L+eXHJcbiAgICAgICAgICAgIHIuYnJhbmNoLm5vZGVzW29yZGVyKHAubGVhZi5rZXlbaV0pXSA9IHA7XHJcbiAgICAgICAgICAgIHAucGFyZW50ID0gcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXIg5piv5ZCm6ZyA6KaB5riF55CG57uT54K5XHJcbiAgICAgKiBAcmV0dXJucyB7Kn0g5aaC5p6c5Yig6Zmk5oiQ5Yqf6L+U5ZueaW5mb+aVsOaNruWQpuWImei/lOWbnmZhbHNlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSAoa2V5LCBjbGVhcikge1xyXG4gICAgICAgIGxldCBsYXN0O1xyXG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XHJcbiAgICAgICAgLy8g5p+l5om+5b6F5Yig6Zmk5YWD57SgXHJcbiAgICAgICAgZm9yICg7XHJcbiAgICAgICAgICAgICBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpIGxhc3QgPSBwO1xyXG5cclxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgY2xlYXIgPSB0eXBlb2YgY2xlYXIgIT09ICd1bmRlZmluZWQnID8gY2xlYXIgOiB0cnVlO1xyXG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHAua2luZCA9PT0gTEVBRiAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHAubGVhZi5pbmZvO1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKGxhc3QsIG9yZGVyKGtleVtpIC0gMV0pLCBjbGVhcik7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcclxuICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAocCAmJiBwLmxlYWYua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBwLmxlYWYuaW5mbztcclxuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUocC5wYXJlbnQsIDAsIGNsZWFyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB0ZXN0ID0gbmV3IFRyaWVUcmVlKCk7XHJcblxyXG50ZXN0Lmluc2VydCgnQ0hBJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEEnKTtcclxudGVzdC5pbnNlcnQoJ0NIQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdDQUknKTtcclxudGVzdC5pbnNlcnQoJ0NIRU4nKTtcclxudGVzdC5pbnNlcnQoJ0NBTycpO1xyXG50ZXN0Lmluc2VydCgnQ0hBTycpO1xyXG50ZXN0Lmluc2VydCgnTE9ORycpO1xyXG50ZXN0Lmluc2VydCgnTEknKTtcclxudGVzdC5pbnNlcnQoJ0xBTicpO1xyXG50ZXN0Lmluc2VydCgnTElVJyk7XHJcbnRlc3QuaW5zZXJ0KCdXQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdXRU4nKTtcclxudGVzdC5pbnNlcnQoJ1dVJyk7XHJcbnRlc3QuaW5zZXJ0KCdZQU5HJyk7XHJcbnRlc3QuaW5zZXJ0KCdZVU4nKTtcclxudGVzdC5pbnNlcnQoJ1pIQU8nKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5zZWFyY2g6ICcpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnWVVOJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnWkhBTycpKTtcclxuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcclxuXHJcbnRlc3QucmVtb3ZlKCdMQU4nKTtcclxudGVzdC5yZW1vdmUoJ0xJVScpO1xyXG50ZXN0LnJlbW92ZSgnV0FORycpO1xyXG50ZXN0LnJlbW92ZSgnV0VOJyk7XHJcbnRlc3QucmVtb3ZlKCdXVScpO1xyXG50ZXN0LnJlbW92ZSgnWUFORycpO1xyXG50ZXN0LnJlbW92ZSgnWVVOJyk7XHJcbnRlc3QucmVtb3ZlKCdaSEFPJyk7XHJcbnRlc3QucmVtb3ZlKCdDSEEnKTtcclxudGVzdC5yZW1vdmUoJ0NIQU5HJyk7XHJcbnRlc3QucmVtb3ZlKCdDQUknKTtcclxudGVzdC5yZW1vdmUoJ0NIRU4nKTtcclxudGVzdC5yZW1vdmUoJ0NBTycpO1xyXG50ZXN0LnJlbW92ZSgnQ0hBTycpO1xyXG50ZXN0LnJlbW92ZSgnTE9ORycpO1xyXG50ZXN0LnJlbW92ZSgnTEknKTtcclxuXHJcbnRlc3QuaW5zZXJ0KCdMSScpO1xyXG50ZXN0Lmluc2VydCgnTEFOJyk7XHJcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0RpZ2l0YWxTZWFyY2hUcmVlLmpzXG4gKiovIiwiLyoqXHJcbiAqIEhhc2hUYWJsZVxyXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNC8xMi8zMC5cclxuICovXHJcblxyXG4vKipcclxu5ZOI5biMKOaVo+WIlynmn6Xmib5cclxuXHJcbuWfuuacrOaAneaDs++8muWcqOiusOW9leeahOWtmOWCqOWcsOWdgOWSjOWug+eahOWFs+mUruWtl+S5i+mXtOW7uueri+S4gOS4quehruWumueahOWvueW6lOWFs+ezu++8m+i/meagt++8jOS4jee7j+i/h+avlOi+g++8jOS4gOasoeWtmOWPluWwseiDveW+l+WIsOaJgOafpeWFg+e0oOeahOafpeaJvuaWueazleOAglxyXG5cclxu5Z+65pys5qaC5b+1XHJcblxyXG7lk4jluIzlh73mlbDvvJrlnKjorrDlvZXnmoTlhbPplK7lrZfkuI7orrDlvZXnmoTlrZjlgqjlnLDlnYDkuYvpl7Tlu7rnq4vnmoTkuIDnp43lr7nlupTlhbPns7vlj6vlk4jluIzlh73mlbDjgIJcclxu5ZOI5biM5Ye95pWw5piv5LiA56eN5pig6LGh77yM5piv5LuO5YWz6ZSu5a2X56m66Ze05Yiw5a2Y5YKo5Zyw5Z2A56m66Ze055qE5LiA56eN5pig6LGh44CC5Y+v5YaZ5oiQ77yaYWRkcihhaSk9SChraSkg77yM5YW25LitaeaYr+ihqOS4reS4gOS4quWFg+e0oO+8jGFkZHIoYWkp5pivYWnnmoTlnLDlnYDvvIwga2nmmK9haeeahOWFs+mUruWtl+OAglxyXG5cclxu5ZOI5biM6KGo77ya5bqU55So5ZOI5biM5Ye95pWw77yM55Sx6K6w5b2V55qE5YWz6ZSu5a2X56Gu5a6a6K6w5b2V5Zyo6KGo5Lit55qE5Zyw5Z2A77yM5bm25bCG6K6w5b2V5pS+5YWl5q2k5Zyw5Z2A77yM6L+Z5qC35p6E5oiQ55qE6KGo5Y+r5ZOI5biM6KGo44CCXHJcblxyXG7lk4jluIzmn6Xmib4o5Y+I5Y+r5pWj5YiX5p+l5om+Ke+8muWIqeeUqOWTiOW4jOWHveaVsOi/m+ihjOafpeaJvueahOi/h+eoi+WPq+WTiOW4jOafpeaJvuOAglxyXG5cclxu5Yay56qB77ya5a+55LqO5LiN5ZCM55qE5YWz6ZSu5a2Xa2njgIFrau+8jOiLpWtp74K5a2rvvIzkvYZIKGtpKT1IKGtqKeeahOeOsOixoeWPq+WGsueqgShjb2xsaXNpb24pIOOAglxyXG5cclxu5ZCM5LmJ6K+N77ya5YW35pyJ55u45ZCM5Ye95pWw5YC855qE5Lik5Liq5LiN5ZCM55qE5YWz6ZSu5a2X77yM56ew5Li66K+l5ZOI5biM5Ye95pWw55qE5ZCM5LmJ6K+N44CCXHJcbuWTiOW4jOWHveaVsOmAmuW4uOaYr+S4gOenjeWOi+e8qeaYoOixoe+8jOaJgOS7peWGsueqgeS4jeWPr+mBv+WFje+8jOWPquiDveWwvemHj+WHj+Wwke+8m+W9k+WGsueqgeWPkeeUn+aXtu+8jOW6lOivpeacieWkhOeQhuWGsueqgeeahOaWueazleOAguiuvuiuoeS4gOS4quaVo+WIl+ihqOW6lOWMheaLrO+8mlxyXG7ikaAgIOaVo+WIl+ihqOeahOepuumXtOiMg+WbtO+8jOWNs+ehruWumuaVo+WIl+WHveaVsOeahOWAvOWfn++8m1xyXG7ikaEgIOaehOmAoOWQiOmAgueahOaVo+WIl+WHveaVsO+8jOS9v+W+l+WvueS6juaJgOacieWPr+iDveeahOWFg+e0oCjorrDlvZXnmoTlhbPplK7lrZcp77yM5Ye95pWw5YC85Z2H5Zyo5pWj5YiX6KGo55qE5Zyw5Z2A56m66Ze06IyD5Zu05YaF77yM5LiU5Ye6546w5Yay56qB55qE5Y+v6IO95bC96YeP5bCP77ybXHJcbuKRoiAg5aSE55CG5Yay56qB55qE5pa55rOV44CC5Y2z5b2T5Yay56qB5Ye6546w5pe25aaC5L2V6Kej5Yaz44CCXHJcblxyXG5cclxu5ZOI5biM5Ye95pWw55qE5p6E6YCgXHJcblxyXG7lk4jluIzlh73mlbDmmK/kuIDnp43mmKDosaHvvIzlhbborr7lrprlvojngbXmtLvvvIzlj6ropoHkvb/ku7vkvZXlhbPplK7lrZfnmoTlk4jluIzlh73mlbDlgLzpg73okL3lnKjooajplb/lhYHorrjnmoTojIPlm7TkuYvlhoXljbPlj6/jgILlk4jluIzlh73mlbDigJzlpb3lnY/igJ3nmoTkuLvopoHor4Tku7flm6DntKDmnInvvJpcclxu4peGIOaVo+WIl+WHveaVsOeahOaehOmAoOeugOWNle+8m1xyXG7il4Yg6IO94oCc5Z2H5YyA4oCd5Zyw5bCG5pWj5YiX6KGo5Lit55qE5YWz6ZSu5a2X5pig5bCE5Yiw5Zyw5Z2A56m66Ze044CC5omA6LCT4oCc5Z2H5YyA4oCdKHVuaWZvcm0p5piv5oyH5Y+R55Sf5Yay56qB55qE5Y+v6IO95oCn5bC95Y+v6IO95pyA5bCR44CCXHJcblxyXG4xICDnm7TmjqXlrprlnYDms5Vcclxu5Y+W5YWz6ZSu5a2X5oiW5YWz6ZSu5a2X55qE5p+Q5Liq57q/5oCn5Ye95pWw5L2c5ZOI5biM5Zyw5Z2A77yM5Y2zSChrZXkpPWtleSAgICDmiJYgICBIKGtleSk9YcK3a2V5K2IoYSxi5Li65bi45pWwKVxyXG7nibnngrnvvJrnm7TmjqXlrprlnYDms5XmiYDlvpflnLDlnYDpm4blkIjkuI7lhbPplK7lrZfpm4blkIjlpKflsI/nm7jnrYnvvIzkuI3kvJrlj5HnlJ/lhrLnqoHvvIzkvYblrp7pmYXkuK3lvojlsJHkvb/nlKjjgIJcclxuXHJcbjIgIOaVsOWtl+WIhuaekOazlVxyXG7lr7nlhbPplK7lrZfov5vooYzliIbmnpDvvIzlj5blhbPplK7lrZfnmoToi6XlubLkvY3miJbnu4TlkIjkvZzkuLrlk4jluIzlnLDlnYDjgIJcclxu6YCC55So5LqO5YWz6ZSu5a2X5L2N5pWw5q+U5ZOI5biM5Zyw5Z2A5L2N5pWw5aSn77yM5LiU5Y+v6IO95Ye6546w55qE5YWz6ZSu5a2X5LqL5YWI55+l6YGT55qE5oOF5Ya144CCXHJcbuS+i++8miDorr7mnIk4MOS4quiusOW9le+8jOWFs+mUruWtl+S4ujjkvY3ljYHov5vliLbmlbDvvIzlk4jluIzlnLDlnYDkuLoy5L2N5Y2B6L+b5Yi25pWw44CCXHJcbu+CgSAg74KCIO+CgyAg74KEIO+ChSAg74KGIO+ChyAg74KIXHJcbjggIDEgIDMgIDQgIDYgIDUgIDMgIDJcclxuOCAgMSAgMyAgNyAgMiAgMiAgNCAgMlxyXG44ICAxICAzICA4ICA3ICA0ICAyICAyXHJcbjggIDEgIDMgIDAgIDEgIDMgIDYgIDdcclxuOCAgMSAgMyAgMiAgMiAgOCAgMSAgN1xyXG44ICAxICAzICAzICA4ICA5ICA2ICA3XHJcbjggIDEgIDMgIDYgIDggIDUgIDMgIDdcclxuOCAgMSAgNCAgMSAgOSAgMyAgNSAgNVxyXG7liIbmnpDvvJog74KBIOWPquWPljhcclxuICAgICAg74KCIOWPquWPljFcclxuICAgICAg74KDIOWPquWPljPjgIE0XHJcbiAgICAgIO+CiCDlj6rlj5Yy44CBN+OAgTVcclxuICAgICAg74KE74KF74KG74KH5pWw5a2X5YiG5biD6L+R5LmO6ZqP5py6XHJcbuaJgOS7pe+8muWPlu+ChO+Che+Chu+Ch+S7u+aEj+S4pOS9jeaIluS4pOS9jeS4juWPpuS4pOS9jeeahOWPoOWKoOS9nOWTiOW4jOWcsOWdgFxyXG5cclxuMyAg5bmz5pa55Y+W5Lit5rOVXHJcbuWwhuWFs+mUruWtl+W5s+aWueWQjuWPluS4remXtOWHoOS9jeS9nOS4uuWTiOW4jOWcsOWdgOOAglxyXG7kuIDkuKrmlbDlubPmlrnlkI7kuK3pl7Tlh6DkvY3lkozmlbDnmoTmr4/kuIDkvY3pg73mnInlhbPvvIzliJnnlLHpmo/mnLrliIbluIPnmoTlhbPplK7lrZflvpfliLDnmoTmlaPliJflnLDlnYDkuZ/mmK/pmo/mnLrnmoTjgILmlaPliJflh73mlbDmiYDlj5bnmoTkvY3mlbDnlLHmlaPliJfooajnmoTplb/luqblhrPlrprjgILov5nnp43mlrnms5XpgILkuo7kuI3nn6XpgZPlhajpg6jlhbPplK7lrZfmg4XlhrXvvIzmmK/kuIDnp43ovoPkuLrluLjnlKjnmoTmlrnms5XjgIJcclxuXHJcbjQgIOaKmOWPoOazlVxyXG7lsIblhbPplK7lrZfliIblibLmiJDkvY3mlbDnm7jlkIznmoTlh6Dpg6jliIYo5pyA5ZCO5LiA6YOo5YiG5Y+v5Lul5LiN5ZCMKe+8jOeEtuWQjuWPlui/meWHoOmDqOWIhueahOWPoOWKoOWSjOS9nOS4uuWTiOW4jOWcsOWdgOOAglxyXG7mlbDkvY3lj6DliqDmnInnp7vkvY3lj6DliqDlkozpl7TnlYzlj6DliqDkuKTnp43jgIJcclxu4peGIOenu+S9jeWPoOWKoO+8muWwhuWIhuWJsuWQjueahOWHoOmDqOWIhuS9juS9jeWvuem9kOebuOWKoOOAglxyXG7il4Yg6Ze055WM5Y+g5Yqg77ya5LuO5LiA56uv5Yiw5Y+m5LiA56uv5rK/5YiG5Ymy55WM5p2l5Zue5oqY6L+t77yM54S25ZCO5a+56b2Q55u45Yqg44CCXHJcbumAguS6juWFs+mUruWtl+S9jeaVsOW+iOWkmu+8jOS4lOavj+S4gOS9jeS4iuaVsOWtl+WIhuW4g+Wkp+iHtOWdh+WMgOaDheWGteOAglxyXG7kvovvvJog6K6+5YWz6ZSu5a2X5Li6MDQ0MjIwNTg2NO+8jOWTiOW4jOWcsOWdgOS9jeaVsOS4ujQg44CC5Lik56eN5LiN5ZCM55qE5Zyw5Z2A6K6h566X5pa55rOV5aaC5LiL77yaXHJcbiAgICA1ODY0ICAgICAgICAgICAgICAgICAgICAgICAgNTg2NFxyXG4gICAgNDIyMCAgICAgICAgICAgICAgICAgICAgICAgIDAyMjRcclxuICAgICAgMDQgICAgICAg56e75L2N5Y+g5YqgICAgICAgICAgICAgMDQgICAgICAgICAgIOmXtOeVjOWPoOWKoFxyXG4gLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLVxyXG4gICAxMDA4OCAgICAgICAgICAgICAgICAgICAgICAgIDYwOTFcclxuXHJcbjUgIOmZpOeVmeS9meaVsOazlVxyXG7lj5blhbPplK7lrZfooqvmn5DkuKrkuI3lpKfkuo7lk4jluIzooajooajplb9t55qE5pWwcOmZpOWQjuaJgOW+l+S9meaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgTU9EIHAgICAgIChwPD1tKVxyXG7mmK/kuIDnp43nroDljZXjgIHluLjnlKjnmoTlk4jluIzlh73mlbDmnoTpgKDmlrnms5XjgIJcclxu5Yip55So6L+Z56eN5pa55rOV55qE5YWz6ZSu5pivcOeahOmAieWPlu+8jHDpgInnmoTkuI3lpb3vvIzlrrnmmJPkuqfnlJ/lkIzkuYnor43jgIJw55qE6YCJ5Y+W55qE5YiG5p6Q77yaXHJcbuKXhiAg6YCJ5Y+WcD0yaShwPD1tKe+8mui/kOeul+S+v+S6jueUqOenu+S9jeadpeWunueOsO+8jOS9huetieS6juWwhuWFs+mUruWtl+eahOmrmOS9jeW/veeVpeiAjOS7heeVmeS4i+S9juS9jeS6jOi/m+WItuaVsOOAgumrmOS9jeS4jeWQjOiAjOS9juS9jeebuOWQjOeahOWFs+mUruWtl+aYr+WQjOS5ieivjeOAglxyXG7il4Yg6YCJ5Y+WcD1xKmYoceOAgWbpg73mmK/otKjlm6DmlbDvvIxwPD1tKe+8muWImeaJgOacieWQq+aciXHmiJZm5Zug5a2Q55qE5YWz6ZSu5a2X55qE5pWj5YiX5Zyw5Z2A5Z2H5pivceaIlmbnmoTlgI3mlbDjgIJcclxu4peGIOmAieWPlnDkuLrntKDmlbDmiJZwPXEqZihx44CBZuaYr+i0qOaVsOS4lOWdh+Wkp+S6jjIw77yMcDw9bSnvvJrluLjnlKjnmoTpgInlj5bmlrnms5XvvIzog73lh4/lsJHlhrLnqoHlh7rnjrDnmoTlj6/og73mgKfjgIJcclxuXHJcbjYgIOmaj+acuuaVsOazlVxyXG7lj5blhbPplK7lrZfnmoTpmo/mnLrlh73mlbDlgLzkvZzlk4jluIzlnLDlnYDvvIzljbNIKGtleSk9cmFuZG9tKGtleSlcclxu5b2T5pWj5YiX6KGo5Lit5YWz6ZSu5a2X6ZW/5bqm5LiN562J5pe277yM6K+l5pa55rOV5q+U6L6D5ZCI6YCC44CCXHJcblxyXG5cclxuXHJcbumAieWPluWTiOW4jOWHveaVsO+8jOiAg+iZkeS7peS4i+WboOe0oFxyXG7il4Yg6K6h566X5ZOI5biM5Ye95pWw5omA6ZyA5pe26Ze077ybXHJcbuKXhiDlhbPplK7lrZfnmoTplb/luqbvvJtcclxu4peGIOWTiOW4jOihqOmVv+W6pu+8iOWTiOW4jOWcsOWdgOiMg+WbtO+8ie+8m1xyXG7il4Yg5YWz6ZSu5a2X5YiG5biD5oOF5Ya177ybXHJcbuKXhiDorrDlvZXnmoTmn6Xmib7popHnjofjgIJcclxuXHJcblxyXG5cclxu5Yay56qB5aSE55CG55qE5pa55rOVXHJcbuWGsueqgeWkhOeQhu+8muW9k+WHuueOsOWGsueqgeaXtu+8jOS4uuWGsueqgeWFg+e0oOaJvuWIsOWPpuS4gOS4quWtmOWCqOS9jee9ruOAglxyXG5cclxuMSAg5byA5pS+5a6a5Z2A5rOVXHJcbuWfuuacrOaWueazle+8muW9k+WGsueqgeWPkeeUn+aXtu+8jOW9ouaIkOafkOS4quaOoua1i+W6j+WIl++8m+aMieatpOW6j+WIl+mAkOS4quaOoua1i+aVo+WIl+ihqOS4reeahOWFtuS7luWcsOWdgO+8jOebtOWIsOaJvuWIsOe7meWumueahOWFs+mUruWtl+aIluS4gOS4quepuuWcsOWdgCjlvIDmlL7nmoTlnLDlnYAp5Li65q2i77yM5bCG5Y+R55Sf5Yay56qB55qE6K6w5b2V5pS+5Yiw6K+l5Zyw5Z2A5Lit44CC5pWj5YiX5Zyw5Z2A55qE6K6h566X5YWs5byP5piv77yaXHJcbkhpKGtleSk9KEgoa2V5KStkaSkgIE1PRCBt77yMaT0xLCAyLCDigKYsIGsoazw9bS0xKVxyXG5cclxu5YW25Lit77yaSChrZXkp77ya5ZOI5biM5Ye95pWw77ybbe+8muaVo+WIl+ihqOmVv+W6pu+8m1xyXG5kae+8muesrGnmrKHmjqLmtYvml7bnmoTlop7ph4/luo/liJfvvJtcclxuSGkoa2V5KSDvvJrnu4/nrKxp5qyh5o6i5rWL5ZCO5b6X5Yiw55qE5pWj5YiX5Zyw5Z2A44CCXHJcblxyXG7ikbQgIOe6v+aAp+aOoua1i+azlVxyXG7lsIbmlaPliJfooahUWzAg4oCmbS0xXeeci+aIkOW+queOr+WQkemHj+OAguW9k+WPkeeUn+WGsueqgeaXtu+8jOS7juWIneasoeWPkeeUn+WGsueqgeeahOS9jee9ruS+neasoeWQkeWQjuaOoua1i+WFtuS7lueahOWcsOWdgOOAglxyXG7lop7ph4/luo/liJfkuLrvvJpkaT0xLCAyLCAzLCDigKYsIG0tMVxyXG7orr7liJ3mrKHlj5HnlJ/lhrLnqoHnmoTlnLDlnYDmmK9o77yM5YiZ5L6d5qyh5o6i5rWLVFtoKzFd77yMVFtoKzJd4oCm77yM55u05YiwVFttLTFd5pe25Y+I5b6q546v5Yiw6KGo5aS077yM5YaN5qyh5o6i5rWLVFswXe+8jFRbMV3igKbvvIznm7TliLBUW2gtMV3jgILmjqLmtYvov4fnqIvnu4jmraLnmoTmg4XlhrXmmK/vvJpcclxu4peGIOaOoua1i+WIsOeahOWcsOWdgOS4uuepuu+8muihqOS4reayoeacieiusOW9leOAguiLpeaYr+afpeaJvuWImeWksei0pe+8m+iLpeaYr+aPkuWFpeWImeWwhuiusOW9leWGmeWFpeWIsOivpeWcsOWdgO+8m1xyXG7il4Yg5o6i5rWL5Yiw55qE5Zyw5Z2A5pyJ57uZ5a6a55qE5YWz6ZSu5a2X77ya6Iul5piv5p+l5om+5YiZ5oiQ5Yqf77yb6Iul5piv5o+S5YWl5YiZ5aSx6LSl77ybXHJcbuKXhiDnm7TliLBUW2hd77ya5LuN5pyq5o6i5rWL5Yiw56m65Zyw5Z2A5oiW57uZ5a6a55qE5YWz6ZSu5a2X77yM5pWj5YiX6KGo5ruh44CCXHJcblxyXG7kvosxIO+8muiuvuaVo+WIl+ihqOmVv+S4ujfvvIzorrDlvZXlhbPplK7lrZfnu4TkuLrvvJoxNSwgMTQsIDI4LCAyNiwgNTYsIDIz77yM5pWj5YiX5Ye95pWw77yaSChrZXkpPWtleSAgIE1PRCAgN++8jOWGsueqgeWkhOeQhumHh+eUqOe6v+aAp+aOoua1i+azleOAglxyXG5IKDE1KT0xNSAgTU9EIDc9MVxyXG5IKDE0KT0xNCAgTU9EIDc9MFxyXG5IKDI4KT0yOCAgTU9EIDc9MCAg5Yay56qBICAgSDEoMjgpPTEgIOWPiOWGsueqgVxyXG5IMigyOCk9MiAgICAgICAgICAgSCgyNik9MjYgIE1PRCA3PTVcclxuSCg1Nik9NTYgIE1PRCA3PTAgICAgIOWGsueqgSAgICAgIEgxKDU2KT0xICAgICDlj4jlhrLnqoFcclxuSDIoNTYpPTIgICDlj4jlhrLnqoEgICAgSDMoNTYpPTNcclxuSCgyMyk9MjMgIE1PRCA3PTIgICAgIOWGsueqgSAgICAgIEgxKDIzKT0zICAgICDlj4jlhrLnqoFcclxuSDMoMjMpPTRcclxuXHJcbjAgICAgIDEgICAgICAyICAgICAgMyAgICAgIDQgICAgICAgNSAgICAgNlxyXG4xNCAgICAxNSAgICAgMjggICAgIDU2ICAgICAyMyAgICAgIDI2XHJcblxyXG7nur/mgKfmjqLmtYvms5XnmoTnibnngrlcclxu4peGIOS8mOeCue+8muWPquimgeaVo+WIl+ihqOacqua7oe+8jOaAu+iDveaJvuWIsOS4gOS4quS4jeWGsueqgeeahOaVo+WIl+WcsOWdgO+8m1xyXG7il4Yg57y654K577ya5q+P5Liq5Lqn55Sf5Yay56qB55qE6K6w5b2V6KKr5pWj5YiX5Yiw56a75Yay56qB5pyA6L+R55qE56m65Zyw5Z2A5LiK77yM5LuO6ICM5Y+I5aKe5Yqg5LqG5pu05aSa55qE5Yay56qB5py65LyaKOi/meenjeeOsOixoeensOS4uuWGsueqgeeahOKAnOiBmumbhuKAnSnjgIJcclxuXHJcbuKRtSAg5LqM5qyh5o6i5rWL5rOVXHJcbuWinumHj+W6j+WIl+S4uu+8mmRpPTHCsiwtMcKyLDLCsiwtMsKyLDPCsizigKbigKbCsWvCsiAgKGs8PeKMim0vMuKMiylcclxuXHJcbuS4iui/sOS+i+mimOiLpemHh+eUqOS6jOasoeaOoua1i+azlei/m+ihjOWGsueqgeWkhOeQhu+8jOWIme+8mlxyXG5IKDE1KT0xNSAgTU9EIDc9MSAgICAgICAgIEgoMTQpPTE0ICBNT0QgNz0wXHJcbkgoMjgpPTI4ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSgyOCk9MSAgICAg5Y+I5Yay56qBXHJcbkgyKDI4KT00XHJcbkgoMjYpPTI2ICBNT0QgNz01XHJcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXHJcbkgyKDU2KT0wICAg5Y+I5Yay56qBICAgIEgzKDU2KT00ICAgIOWPiOWGsueqgVxyXG5INCg1Nik9MlxyXG5IKDIzKT0yMyAgTU9EIDc9MiAgICAgIOWGsueqgVxyXG5IMSgyMyk9M1xyXG5cclxu5LqM5qyh5o6i5rWL5rOV55qE54m554K5XHJcbuKXhiDkvJjngrnvvJrmjqLmtYvluo/liJfot7Pot4PlvI/lnLDmlaPliJfliLDmlbTkuKrooajkuK3vvIzkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3njrDosaHvvJtcclxu4peGIOe8uueCue+8muS4jeiDveS/neivgeaOoua1i+WIsOaVo+WIl+ihqOeahOaJgOacieWcsOWdgOOAglxyXG5cclxu4pG2ICAg5Lyq6ZqP5py65o6i5rWL5rOVXHJcbuWinumHj+W6j+WIl+S9v+eUqOS4gOS4quS8qumaj+acuuWHveaVsOadpeS6p+eUn+S4gOS4quiQveWcqOmXreWMuumXtFsx77yMbS0xXeeahOmaj+acuuW6j+WIl+OAglxyXG5cclxu5L6LMiDvvJog6KGo6ZW/5Li6MTHnmoTlk4jluIzooajkuK3lt7LloavmnInlhbPplK7lrZfkuLoxN++8jDYw77yMMjnnmoTorrDlvZXvvIzmlaPliJflh73mlbDkuLpIKGtleSk9a2V5ICBNT0QgIDExIOOAgiDnjrDmnInnrKw05Liq6K6w5b2V77yM5YW25YWz6ZSu5a2X5Li6MzjvvIzmjInkuInnp43lpITnkIblhrLnqoHnmoTmlrnms5XvvIzlsIblroPloavlhaXooajkuK3jgIJcclxuXHJcbigxKSAgSCgzOCk9MzggTU9EIDExPTUgICAg5Yay56qBXHJcbiAgICAgSDE9KDUrMSkgTU9EIDExPTYgICAg5Yay56qBXHJcbiAgICAgSDI9KDUrMikgTU9EIDExPTcgICAg5Yay56qBXHJcbiAgICAgSDM9KDUrMykgTU9EIDExPTggICAg5LiN5Yay56qBXHJcbigyKSAgSCgzOCk9MzggTU9EIDExPTUgICAgICDlhrLnqoFcclxuICAgICBIMT0oNSsxwrIpIE1PRCAxMT02ICAgIOWGsueqgVxyXG4gICAgIEgyPSg1LTHCsikgTU9EIDExPTQgICAgIOS4jeWGsueqgVxyXG4oMykgIEgoMzgpPTM4IE1PRCAxMT01ICAgIOWGsueqgVxyXG4gICAgIOiuvuS8qumaj+acuuaVsOW6j+WIl+S4ujnvvIzliJlIMT0oNSs5KSBNT0QgMTE9MyDkuI3lhrLnqoFcclxuXHJcblxyXG4yICDlho3lk4jluIzms5Vcclxu5p6E6YCg6Iul5bmy5Liq5ZOI5biM5Ye95pWw77yM5b2T5Y+R55Sf5Yay56qB5pe277yM5Yip55So5LiN5ZCM55qE5ZOI5biM5Ye95pWw5YaN6K6h566X5LiL5LiA5Liq5paw5ZOI5biM5Zyw5Z2A77yM55u05Yiw5LiN5Y+R55Sf5Yay56qB5Li65q2i44CC5Y2z77yaSGk9UkhpKGtleSkgICAgIGk9MSwgMiwg4oCmLCBrXHJcblJIaSDvvJrkuIDnu4TkuI3lkIznmoTlk4jluIzlh73mlbDjgILnrKzkuIDmrKHlj5HnlJ/lhrLnqoHml7bvvIznlKhSSDHorqHnrpfvvIznrKzkuozmrKHlj5HnlJ/lhrLnqoHml7bvvIznlKhSSDLorqHnrpfigKbkvp3mraTnsbvmjqjnn6XpgZPlvpfliLDmn5DkuKpIaeS4jeWGjeWGsueqgeS4uuatouOAglxyXG7il4YgIOS8mOeCue+8muS4jeaYk+S6p+eUn+WGsueqgeeahOKAnOiBmumbhuKAneeOsOixoe+8m1xyXG7il4YgIOe8uueCue+8muiuoeeul+aXtumXtOWinuWKoOOAglxyXG5cclxuXHJcbjMgIOmTvuWcsOWdgOazlVxyXG7mlrnms5XvvJrlsIbmiYDmnInlhbPplK7lrZfkuLrlkIzkuYnor40o5pWj5YiX5Zyw5Z2A55u45ZCMKeeahOiusOW9leWtmOWCqOWcqOS4gOS4quWNlemTvuihqOS4re+8jOW5tueUqOS4gOe7tOaVsOe7hOWtmOaUvumTvuihqOeahOWktOaMh+mSiOOAglxyXG7orr7mlaPliJfooajplb/kuLpt77yM5a6a5LmJ5LiA5Liq5LiA57u05oyH6ZKI5pWw57uE77yaXHJcblJlY05vZGUgKmxpbmtoYXNoW21d77yM5YW25LitUmVjTm9kZeaYr+e7k+eCueexu+Wei++8jOavj+S4quWIhumHj+eahOWIneWAvOS4uuepuuOAguWHoeaVo+WIl+WcsOWdgOS4umvnmoTorrDlvZXpg73mj5LlhaXliLDku6VsaW5raGFzaFtrXeS4uuWktOaMh+mSiOeahOmTvuihqOS4re+8jOaPkuWFpeS9jee9ruWPr+S7peWcqOihqOWktOaIluihqOWwvuaIluaMieWFs+mUruWtl+aOkuW6j+aPkuWFpeOAglxyXG5cclxu5L6L77yaIOW3suefpeS4gOe7hOWFs+mUruWtlygxOSwgMTQsIDIzLCAxLCA2OCwgMjAsIDg0LCAyNywgNTUsIDExLCAxMCwgNzkpIO+8jOWTiOW4jOWHveaVsOS4uu+8mkgoa2V5KT1rZXkgTU9EIDEz77yM55So6ZO+5Zyw5Z2A5rOV5aSE55CG5Yay56qBOlxyXG5cclxuIDBcclxuIDEgIC0tPiAxNCAtPiAxIC0+IDI3IC0+IDc5XHJcbiAyXHJcbiAzICAtLT4gNjggLT4gNTVcclxuIDRcclxuIDVcclxuIDYgIC0tPiAxOSAtPiA4NFxyXG4gNyAgLS0+IDIwXHJcbiA4XHJcbiA5XHJcbiAxMCAtLT4gMjMgLT4gMTBcclxuIDExIC0tPiAxMVxyXG4gMTJcclxuXHJcbiDkvJjngrnvvJrkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3vvJvliKDpmaTorrDlvZXkuZ/lvojnroDljZXjgIJcclxuXHJcblxyXG4gNCAg5bu656uL5YWs5YWx5rqi5Ye65Yy6XHJcbiDmlrnms5XvvJrlnKjln7rmnKzmlaPliJfooajkuYvlpJbvvIzlj6blpJborr7nq4vkuIDkuKrmuqLlh7rooajkv53lrZjkuI7ln7rmnKzooajkuK3orrDlvZXlhrLnqoHnmoTmiYDmnInorrDlvZXjgIJcclxuIOiuvuaVo+WIl+ihqOmVv+S4um3vvIzorr7nq4vln7rmnKzmlaPliJfooahoYXNodGFibGVbbV3vvIzmr4/kuKrliIbph4/kv53lrZjkuIDkuKrorrDlvZXvvJvmuqLlh7rooahvdmVydGFibGVbbV3vvIzkuIDml6bmn5DkuKrorrDlvZXnmoTmlaPliJflnLDlnYDlj5HnlJ/lhrLnqoHvvIzpg73loavlhaXmuqLlh7rooajkuK3jgIJcclxuXHJcbiDkvovvvJog5bey55+l5LiA57uE5YWz6ZSu5a2XKDE1LCA0LCAxOCwgNywgMzcsIDQ3KSDvvIzmlaPliJfooajplb/luqbkuLo3IO+8jOWTiOW4jOWHveaVsOS4uu+8mkgoa2V5KT1rZXkgTU9EIDfvvIznlKjlu7rnq4vlhazlhbHmuqLlh7rljLrms5XlpITnkIblhrLnqoHjgILlvpfliLDnmoTln7rmnKzooajlkozmuqLlh7rooajlpoLkuIvvvJpcclxuICAgICAgICAgICAgICAgICAgICDmlaPliJflnLDlnYAgICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNSAgICAgNlxyXG4gSGFzaHRhYmxl6KGo77yaXHJcbiAgICAgICAgICAgICAgICAgICAg5YWz6ZSu5a2XICAgICA3ICAgICAxNSAgICAzNyAgICAgICAgICA0ICAgICA0N1xyXG5cclxuICAgICAgICAgICAgICAgICAgICDmuqLlh7rlnLDlnYAgICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNSAgICAgNlxyXG4gb3ZlcnRhYmxl6KGo77yaXHJcbiAgICAgICAgICAgICAgICAgICAgIOWFs+mUruWtlyAgICAxOFxyXG5cclxuXHJcblxyXG5cclxuIOWTiOW4jOafpeaJvui/h+eoi+WPiuWIhuaekFxyXG5cclxuIDEgICDlk4jluIzmn6Xmib7ov4fnqItcclxuIOWTiOW4jOihqOeahOS4u+imgeebrueahOaYr+eUqOS6juW/q+mAn+afpeaJvu+8jOS4lOaPkuWFpeWSjOWIoOmZpOaTjeS9nOmDveimgeeUqOWIsOafpeaJvuOAgueUseS6juaVo+WIl+ihqOeahOeJueauiue7hOe7h+W9ouW8j++8jOWFtuafpeaJvuacieeJueauiueahOaWueazleOAglxyXG5cclxuIOe7meWumkvlgLzvvIzmoLnmja7pgKDooajml7borr7lrprnmoTlk4jluIzlh73mlbDmsYLlvpflk4jluIzlnLDlnYDvvIzoi6XooajkuK3mraTkvY3nva7kuIrmsqHmnInorrDlvZXvvIzliJnmn6Xmib7kuI3miJDlip/vvJvlkKbliJnmr5TovoPlhbPplK7lrZfvvIzoi6Xlkoznu5nlrprlhbPplK7lrZfnm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvJvlkKbliJnmoLnmja7pgKDooajml7borr7lrprnmoTlpITnkIblhrLnqoHnmoTmlrnms5Xmib7igJzkuIvkuIDlnLDlnYDigJ3vvIznm7TliLDlk4jluIzooajkuK3mn5DkuKrkvY3nva7kuLrnqbrmiJbogIXooajkuK3miYDloavorrDlvZXnmoTlhbPplK7lrZfnrYnkuo7nu5nlrprlgLzml7bkuLrmraLjgIJcclxuXHJcblxyXG5cclxuIOWTiOW4jOafpeaJvuWIhuaekFxyXG5cclxuIOS7juWTiOW4jOafpeaJvui/h+eoi+WPr+inge+8muWwveeuoeaVo+WIl+ihqOWcqOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+S6huebtOaOpeaYoOixoe+8jOS9hueUseS6juKAnOWGsueqgeKAne+8jOafpeaJvui/h+eoi+S7jeaYr+S4gOS4que7meWumuWAvOS4juWFs+mUruWtl+i/m+ihjOavlOi+g+eahOi/h+eoi++8jOivhOS7t+WTiOW4jOafpeaJvuaViOeOh+S7jeimgeeUqEFTTOOAglxyXG4g5ZOI5biM5p+l5om+5pe25YWz6ZSu5a2X5LiO57uZ5a6a5YC85q+U6L6D55qE5qyh5pWw5Y+W5Yaz5LqO77yaXHJcbiDil4Yg5ZOI5biM5Ye95pWw77ybXHJcbiDil4Yg5aSE55CG5Yay56qB55qE5pa55rOV77ybXHJcbiDil4Yg5ZOI5biM6KGo55qE5aGr5ruh5Zug5a2QzrEg44CC5aGr5ruh5Zug5a2QzrHnmoTlrprkuYnmmK/vvJpcclxuXHJcbiDOsSA9IOihqOS4reWhq+WFpeeahOiusOW9leaVsCAvIOWTiOW4jOihqOmVv+W6plxyXG5cclxuXHJcbiDlkITnp43mlaPliJflh73mlbDmiYDmnoTpgKDnmoTmlaPliJfooajnmoRBU0zlpoLkuIvvvJpcclxuXHJcbiDikbQgICDnur/mgKfmjqLmtYvms5XnmoTlubPlnYfmn6Xmib7plb/luqbmmK/vvJpcclxuIFPmiJDlip8g57qm562J5LqOIDEgLyAyICogKDEgKyAxIC8gKDEgLSDOsSkpXHJcbiBT5aSx6LSlIOe6puetieS6jiAxIC8gMiAqICgxICsgMSAvICgxIC0gzrEpICogKDEgLSDOsSkpXHJcblxyXG4g4pG1ICAg5LqM5qyh5o6i5rWL44CB5Lyq6ZqP5py65o6i5rWL44CB5YaN5ZOI5biM5rOV55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXHJcbiBT5oiQ5YqfIOe6puetieS6jiAtMSAvIM6xICogbG4oMSAtIM6xKVxyXG4gU+Wksei0pSDnuqbnrYnkuo4gMSAvICgxIC0gzrEpXHJcblxyXG4g4pG2ICAg55So6ZO+5Zyw5Z2A5rOV6Kej5Yaz5Yay56qB55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXHJcbiBT5oiQ5YqfIOe6puetieS6jiAxICsgzrEgLyAyXHJcbiBT5aSx6LSlIOe6puetieS6jiDOsSArIGXnmoQtzrHmrKHluYJcclxuXHJcblxyXG4gKi9cclxuXHJcbmltcG9ydCBMaW5rZWRMaXN0IGZyb20gJy4uL0xpc3QvTGlua2VkTGlzdCc7XHJcblxyXG5cclxubGV0IGhhc2hTaXplID0gYnVpbGRIYXNoU2l6ZSg5NzcsIDIwKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBIYXNoVGFibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gW107XHJcbiAgICAgICAgLy8g5b2T5YmN5pWw5o2u5YWD57Sg5Liq5pWwO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIC8vIOW9k+WJjeWuuemHj1xyXG4gICAgICAgIHRoaXMuc2l6ZUluZGV4ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyDkvb/nlKjnur/mgKfmjqLmtYvms5Xop6PlhrPlhrLnqoFcclxuICAgIHNlYXJjaChrZXkpIHtcclxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xyXG4gICAgICAgIGxldCBwID0gaGFzaChrZXksIG1heCk7XHJcbiAgICAgICAgbGV0IGMgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAocCA8IG1heCAmJiB0aGlzLmRhdGFbcF0gIT0gbnVsbCAmJiBrZXkgIT09IHRoaXMuZGF0YVtwXSkge1xyXG4gICAgICAgICAgICBwID0gY29sbGlzaW9uKGtleSwgKytjLCBtYXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VjY2Vzczoga2V5ID09PSB0aGlzLmRhdGFbcF0sXHJcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbWVzOiBjLFxyXG4gICAgICAgICAgICBpbmRleDogcFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0KGtleSkge1xyXG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPj0gbWF4KSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3Jtc2c6ICd0YWJsZSBvdmVyZmxvd2VkJyB9O1xyXG5cclxuICAgICAgICBsZXQgcmV0ID0gdGhpcy5zZWFyY2goa2V5KTtcclxuICAgICAgICBsZXQgcCA9IHJldC5pbmRleDtcclxuICAgICAgICBsZXQgYyA9IHJldC5jb2xsaXNpb25UaW1lcztcclxuXHJcbiAgICAgICAgaWYgKHJldC5zdWNjZXNzKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhW3BdID0ga2V5O1xyXG4gICAgICAgICAgICArK3RoaXMuY291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjcmVhdGVIYXNoVGFibGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvdW50KSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XHJcbiAgICAgICAgbGV0IHAgPSBoYXNoKGtleSwgbWF4KTtcclxuICAgICAgICBsZXQgYyA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChrZXkgIT09IHRoaXMuZGF0YVtwXSlcclxuICAgICAgICAgICAgcCA9IGNvbGxpc2lvbihrZXksICsrYywgbWF4KTtcclxuXHJcblxyXG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMuZGF0YVtwXSkge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YVtwXTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShwLCAxKTtcclxuICAgICAgICAgICAgLS10aGlzLmNvdW50O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjcmVhdGVIYXNoVGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICsrdGhpcy5zaXplSW5kZXggPCBoYXNoU2l6ZS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gRUxGaGFzaOWtl+espuS4suaVo+WIl+WHveaVsFxyXG5mdW5jdGlvbiBoYXNoKHN0ciwgbWF4KSB7XHJcbiAgICBsZXQgaGFzaCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSArIGhhc2ggKyBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxyXG4gICAgICAgIGhhc2ggPSBNYXRoLmFicyhoYXNoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNoICUgbWF4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsaXNpb24oa2V5LCB0aW1lcywgbWF4KSB7XHJcbiAgICAvLyDnur/mgKfmjqLmtYvms5VcclxuICAgIHJldHVybiAoaGFzaChrZXksIG1heCkgKyB0aW1lcykgJSBtYXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUHJpbWUobikge1xyXG4gICAgaWYgKG4gPD0gMykgcmV0dXJuIG4gPiAxO1xyXG4gICAgaWYgKG4gJSAyID09PSAwIHx8IG4gJSAzID09PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gNTsgaSAqIGkgPD0gbjsgaSArPSA2KSB7XHJcbiAgICAgICAgaWYgKG4gJSBpID09PSAwIHx8IG4gJSAoaSArIDIpID09PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkSGFzaFNpemUoYmVnaW4sIGxlbmd0aCkge1xyXG4gICAgbGV0IGhhc2hTaXplID0gW107XHJcblxyXG4gICAgd2hpbGUgKDEpIHtcclxuICAgICAgICBpZiAoaGFzaFNpemUubGVuZ3RoID49IGxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgaWYgKGlzUHJpbWUoYmVnaW4pKSBoYXNoU2l6ZS5wdXNoKGJlZ2luKTtcclxuICAgICAgICArK2JlZ2luO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoYXNoU2l6ZTtcclxufVxyXG5cclxuLy8g5byA5pS+5a6a5Z2A5rOVXHJcbi8vaGFzaFNpemUgPSBbNSwgN107IC8vIGZvciB0ZXN0LiB3aWxsIGJlIGRlbGV0ZWRcclxubGV0IHRlc3QgPSBuZXcgSGFzaFRhYmxlKCk7XHJcbnRlc3QuaW5zZXJ0KCcxNycpO1xyXG50ZXN0Lmluc2VydCgnNjAnKTtcclxudGVzdC5pbnNlcnQoJzI5Jyk7XHJcbnRlc3QuaW5zZXJ0KCczOCcpO1xyXG50ZXN0Lmluc2VydCgnMzknKTtcclxudGVzdC5pbnNlcnQoJzQwJyk7XHJcblxyXG50ZXN0LnJlbW92ZSgnMTcnKTtcclxudGVzdC5yZW1vdmUoJzYwJyk7XHJcbnRlc3QucmVtb3ZlKCcyOScpO1xyXG50ZXN0LnJlbW92ZSgnMzgnKTtcclxudGVzdC5yZW1vdmUoJzM5Jyk7XHJcbnRlc3QucmVtb3ZlKCc0MCcpO1xyXG5cclxuXHJcbi8vIOS9v+eUqOmTvuWcsOWdgOazleino+WGs+WGsueqgeeahOWTiOW4jOihqFxyXG5cclxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3RIYXNoVGFibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8g5b2T5YmN5pWw5o2u5YWD57Sg5Liq5pWwO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIC8vIOW9k+WJjeWuuemHj1xyXG4gICAgICAgIHRoaXMuc2l6ZUluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmhOb2RlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHNlYXJjaChrZXkpIHtcclxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xyXG4gICAgICAgIGxldCBpID0gaGFzaChrZXksIG1heCk7XHJcbiAgICAgICAgbGV0IHQgPSB0aGlzLmhOb2RlcztcclxuXHJcbiAgICAgICAgaWYgKHRbaV0gPT0gbnVsbCkgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGluZGV4OiBpIH07XHJcblxyXG4gICAgICAgIGxldCBwID0gdFtpXTtcclxuICAgICAgICBsZXQgZGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgIHAuZWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBkYXRhID09PSBrZXksIGluZGV4OiBpIH07XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0KGtleSkge1xyXG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPj0gbWF4KSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3Jtc2c6ICd0YWJsZSBvdmVyZmxvd2VkJyB9O1xyXG5cclxuICAgICAgICBsZXQgcmV0ID0gdGhpcy5zZWFyY2goa2V5KTtcclxuICAgICAgICBsZXQgaW5kZXggPSByZXQuaW5kZXg7XHJcblxyXG4gICAgICAgIGlmIChyZXQuc3VjY2VzcykgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaE5vZGVzW2luZGV4XSkgdGhpcy5oTm9kZXNbaW5kZXhdID0gbmV3IExpbmtlZExpc3QoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaE5vZGVzW2luZGV4XS5zaXplKCkgPCBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF0gLyAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XS5vcmRlckluc2VydChrZXkpO1xyXG4gICAgICAgICAgICArK3RoaXMuY291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjcmVhdGVIYXNoVGFibGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvdW50KSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xyXG5cclxuICAgICAgICBpZiAocmV0LnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gcmV0LmluZGV4O1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHJldC5kYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmhOb2Rlc1tpbmRleF1bJ3JlbW92ZSddKGtleSk7XHJcbiAgICAgICAgICAgIC0tdGhpcy5jb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjcmVhdGVIYXNoVGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICsrdGhpcy5zaXplSW5kZXggPCBoYXNoU2l6ZS5sZW5ndGg7XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgdGVzdDIgPSBuZXcgTGlua2VkTGlzdEhhc2hUYWJsZSgpO1xyXG50ZXN0Mi5pbnNlcnQoJzE3Jyk7XHJcbnRlc3QyLmluc2VydCgnNjAnKTtcclxudGVzdDIuaW5zZXJ0KCcyOScpO1xyXG50ZXN0Mi5pbnNlcnQoJzM4Jyk7XHJcbnRlc3QyLmluc2VydCgnMzknKTtcclxudGVzdDIuaW5zZXJ0KCc0MCcpO1xyXG5cclxudGVzdDIucmVtb3ZlKCcxNycpO1xyXG50ZXN0Mi5yZW1vdmUoJzYwJyk7XHJcbnRlc3QyLnJlbW92ZSgnMjknKTtcclxudGVzdDIucmVtb3ZlKCczOCcpO1xyXG50ZXN0Mi5yZW1vdmUoJzM5Jyk7XHJcbnRlc3QyLnJlbW92ZSgnNDAnKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0hhc2hUYWJsZS5qc1xuICoqLyIsIi8qKlxyXG4gKiBSZWQgQmxhY2sgVHJlZVxyXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNC8xMi8zMC5cclxuICovXHJcbi8qXHJcbiBodHRwOi8vYmxvZy5jc2RuLm5ldC92X2p1bHlfdi9hcnRpY2xlL2RldGFpbHMvNjEwNTYzMFxyXG5cclxuIOe6oum7keagke+8jOS4gOenjeS6jOWPieafpeaJvuagke+8jOS9huWcqOavj+S4que7k+eCueS4iuWinuWKoOS4gOS4quWtmOWCqOS9jeihqOekuue7k+eCueeahOminOiJsu+8jOWPr+S7peaYr1JlZOaIlkJsYWNr44CCXHJcbiDpgJrov4flr7nku7vkvZXkuIDmnaHku47moLnliLDlj7blrZDnmoTot6/lvoTkuIrlkITkuKrnu5PngrnnnYDoibLmlrnlvI/nmoTpmZDliLbvvIznuqLpu5HmoJHnoa7kv53msqHmnInkuIDmnaHot6/lvoTkvJrmr5Tlhbbku5bot6/lvoTplb/lh7rkv6nlgI3vvIzlm6DogIzmmK/mjqXov5HlubPooaHnmoTjgIJcclxuXHJcbiDnuqLpu5HmoJHomb3nhLbmnKzotKjkuIrmmK/kuIDmo7Xkuozlj4nmn6Xmib7moJHvvIzkvYblroPlnKjkuozlj4nmn6Xmib7moJHnmoTln7rnoYDkuIrlop7liqDkuobnnYDoibLlkoznm7jlhbPnmoTmgKfotKjkvb/lvpfnuqLpu5HmoJHnm7jlr7nlubPooaHvvIzku47ogIzkv53or4HkuobnuqLpu5HmoJHnmoTmn6Xmib7jgIHmj5LlhaXjgIHliKDpmaTnmoTml7bpl7TlpI3mnYLluqbmnIDlnY/kuLpPKGxvZyBuKeOAglxyXG5cclxuIOe6oum7keagkeeahDXkuKrmgKfotKjvvJpcclxuIDEu5q+P5Liq57uT54K56KaB5LmI5piv57qi55qE6KaB5LmI5piv6buR55qE44CCXHJcbiAyLuaguee7k+eCueaYr+m7keeahOOAglxyXG4gMy7mr4/kuKrlj7bnu5PngrnvvIjlj7bnu5PngrnljbPmjIfmoJHlsL7nq69OSUzmjIfpkojmiJZOVUxM57uT54K577yJ6YO95piv6buR55qE44CCXHJcbiA0LuWmguaenOS4gOS4que7k+eCueaYr+e6oueahO+8jOmCo+S5iOWug+eahOS4pOS4quWEv+WtkOmDveaYr+m7keeahOOAglxyXG4gNS7lr7nkuo7ku7vmhI/nu5PngrnogIzoqIDvvIzlhbbliLDlj7bnu5PngrnmoJHlsL7nq69OSUzmjIfpkojnmoTmr4/mnaHot6/lvoTpg73ljIXlkKvnm7jlkIzmlbDnm67nmoTpu5Hnu5PngrnjgIJcclxuXHJcbiDmraPmmK/nuqLpu5HmoJHnmoTov5k15p2h5oCn6LSo77yM5L2/5LiA5qO1buS4que7k+eCueeahOe6oum7keagkeWni+e7iOS/neaMgeS6hmxvZ27nmoTpq5jluqbvvIzku47ogIzkuZ/lsLHop6Pph4rkuobkuIrpnaLmiYDor7TnmoTigJznuqLpu5HmoJHnmoTmn6Xmib7jgIHmj5LlhaXjgIHliKDpmaTnmoTml7bpl7TlpI3mnYLluqbmnIDlnY/kuLpPKGxvZyBuKeKAnei/meS4gOe7k+iuuuaIkOeri+eahOWOn+WboOOAglxyXG5cclxuXHJcbiDmoJHnmoTml4vovaxcclxuXHJcbuW9k+WcqOWvuee6oum7keagkei/m+ihjOaPkuWFpeWSjOWIoOmZpOetieaTjeS9nOaXtu+8jOWvueagkeWBmuS6huS/ruaUueWPr+iDveS8muegtOWdj+e6oum7keagkeeahOaAp+i0qOOAguS4uuS6hue7p+e7reS/neaMgee6oum7keagkeeahOaAp+i0qO+8jOWPr+S7pemAmui/h+Wvuee7k+eCuei/m+ihjOmHjeaWsOedgOiJsu+8jOS7peWPiuWvueagkei/m+ihjOebuOWFs+eahOaXi+i9rOaTjeS9nO+8jOWNs+mAmui/h+S/ruaUueagkeS4reafkOS6m+e7k+eCueeahOminOiJsuWPiuaMh+mSiOe7k+aehO+8jOadpei+vuWIsOWvuee6oum7keagkei/m+ihjOaPkuWFpeaIluWIoOmZpOe7k+eCueetieaTjeS9nOWQjue7p+e7reS/neaMgeWug+eahOaAp+i0qOaIluW5s+ihoeeahOebrueahOOAglxyXG5cclxu5qCR55qE5peL6L2s5YiG5Li65bem5peL5ZKM5Y+z5peLXHJcblxyXG7moJHlnKjnu4/ov4flt6bml4vlj7Pml4vkuYvlkI7vvIzmoJHnmoTmkJzntKLmgKfotKjkv53mjIHkuI3lj5jvvIzkvYbmoJHnmoTnuqLpu5HmgKfotKjliJnooqvnoLTlnY/kuobvvIzmiYDku6XvvIznuqLpu5HmoJHmj5LlhaXlkozliKDpmaTmlbDmja7lkI7vvIzpnIDopoHliKnnlKjml4vovazkuI7popzoibLph43mtoLmnaXph43mlrDmgaLlpI3moJHnmoTnuqLpu5HmgKfotKjjgIJcclxuXHJcblxyXG7nuqLpu5HmoJHnmoTmj5LlhaVcclxuXHJcbuWmguaenOaPkuWFpeeahOaYr+aguee7k+eCue+8jOeUseS6juWOn+agkeaYr+epuuagke+8jOatpOaDheWGteWPquS8mui/neWPjeaAp+i0qDLvvIzlm6DmraTnm7TmjqXmiormraTnu5PngrnmtoLkuLrpu5HoibLvvJvlpoLmnpzmj5LlhaXnmoTnu5PngrnnmoTniLbnu5PngrnmmK/pu5HoibLvvIznlLHkuo7mraTkuI3kvJrov53lj43mgKfotKgy5ZKM5oCn6LSoNO+8jOe6oum7keagkeayoeacieiiq+egtOWdj++8jOaJgOS7peatpOaXtuS7gOS5iOS5n+S4jeWBmuOAglxyXG7kvYblvZPpgYfliLDkuIvov7Az56eN5oOF5Ya15pe25Y+I6K+l5aaC5L2V6LCD5pW05ZGi77yfXHJcbuKXjyDmj5LlhaXkv67lpI3mg4XlhrUx77ya5aaC5p6c5b2T5YmN57uT54K555qE54i257uT54K55piv57qi6Imy5LiU56WW54i257uT54K555qE5Y+m5LiA5Liq5a2Q57uT54K577yI5Y+U57uT54K577yJ5piv57qi6ImyXHJcbuatpOaXtueItue7k+eCueeahOeItue7k+eCueS4gOWumuWtmOWcqO+8jOWQpuWImeaPkuWFpeWJjeWwseW3suS4jeaYr+e6oum7keagkeOAguS4juatpOWQjOaXtu+8jOWPiOWIhuS4uueItue7k+eCueaYr+ellueItue7k+eCueeahOW3puWtqeWtkOi/mOaYr+WPs+WtqeWtkO+8jOagueaNruWvueensOaAp++8jOaIkeS7rOWPquimgeino+W8gOS4gOS4quaWueWQkeWwseWPr+S7peS6huOAgui/memHjOWPquiAg+iZkeeItue7k+eCueS4uuellueItuW3puWtqeWtkOeahOaDheWGtVxyXG7lr7nmraTvvIzmiJHku6znmoTop6PlhrPnrZbnlaXmmK/vvJrlsIblvZPliY3oioLngrnnmoTniLboioLngrnlkozlj5Tlj5ToioLngrnmtoLpu5HvvIznpZbniLbnu5PngrnmtoLnuqLvvIzmiorlvZPliY3nu5PngrnmjIflkJHnpZbniLboioLngrnvvIzku47mlrDnmoTlvZPliY3oioLngrnph43mlrDlvIDlp4vnrpfms5XjgIJcclxu5LqO5piv77yM5o+S5YWl5L+u5aSN5oOF5Ya1Mei9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTJcclxuXHJcbuKXjyDmj5LlhaXkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOWPs+WtkFxyXG7mraTml7bvvIzop6PlhrPlr7nnrZbmmK/vvJrlvZPliY3oioLngrnnmoTniLboioLngrnlgZrkuLrmlrDnmoTlvZPliY3oioLngrnvvIzku6XmlrDlvZPliY3oioLngrnkuLrmlK/ngrnlt6bml4vjgIJcclxu5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcclxuXHJcbuKXjyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxyXG7op6PlhrPlr7nnrZbmmK/vvJrniLboioLngrnlj5jkuLrpu5HoibLvvIznpZbniLboioLngrnlj5jkuLrnuqLoibLvvIzlnKjnpZbniLboioLngrnkuLrmlK/ngrnlj7Pml4vvvIxcclxu5pyA5ZCO77yM5oqK5qC557uT54K55raC5Li66buR6Imy77yM5pW05qO157qi6buR5qCR5L6/6YeN5paw5oGi5aSN5LqG5bmz6KGh44CCXHJcblxyXG7nu4/ov4fkuIrpnaLmg4XlhrUz44CB5oOF5Ya1NOOAgeaDheWGtTXnrYkz56eN5o+S5YWl5L+u5aSN5oOF5Ya155qE5pON5L2c56S65oSP5Zu+77yM6K+76ICF6Ieq5Lya5Y+R546w77yM5ZCO6Z2i55qE5oOF5Ya1NOOAgeaDheWGtTXpg73mmK/pkojlr7nmg4XlhrUz5o+S5YWl6IqC54K5NOS7peWQju+8jOi/m+ihjOeahOS4gOezu+WIl+aPkuWFpeS/ruWkjeaDheWGteaTjeS9nO+8jOS4jei/h++8jOaMh+WQkeW9k+WJjeiKgueCuU7mjIfpkojkuIDnm7TlnKjlj5jljJbjgILmiYDku6XvvIzkvaDlj6/ku6Xmg7PlvZPnhLbnmoTorqTkuLrvvJrmlbTkuKrkuIvmnaXvvIzmg4XlhrUz44CBNOOAgTXlsLHmmK/kuIDkuKrlrozmlbTnmoTmj5LlhaXkv67lpI3mg4XlhrXnmoTmk43kvZzmtYHnqItcclxuXHJcblxyXG7nuqLpu5HmoJHnmoTliKDpmaRcclxuXHJcbuWcqOWIoOmZpOiKgueCueWQju+8jOWOn+e6oum7keagkeeahOaAp+i0qOWPr+iDveiiq+aUueWPmO+8jOWmguaenOWIoOmZpOeahOaYr+e6ouiJsuiKgueCue+8jOmCo+S5iOWOn+e6oum7keagkeeahOaAp+i0qOS+neaXp+S/neaMge+8jOatpOaXtuS4jeeUqOWBmuS/ruato+aTjeS9nO+8jOWmguaenOWIoOmZpOeahOiKgueCueaYr+m7keiJsuiKgueCue+8jOWOn+e6oum7keagkeeahOaAp+i0qOWPr+iDveS8muiiq+aUueWPmO+8jOaIkeS7rOimgeWvueWFtuWBmuS/ruato+aTjeS9nOOAgumCo+S5iOWTquS6m+agkeeahOaAp+i0qOS8muWPkeeUn+WPmOWMluWRou+8jOWmguaenOWIoOmZpOiKgueCueS4jeaYr+agkeWUr+S4gOiKgueCue+8jOmCo+S5iOWIoOmZpOiKgueCueeahOmCo+S4gOS4quaUr+eahOWIsOWQhOWPtuiKgueCueeahOm7keiJsuiKgueCueaVsOS8muWPkeeUn+WPmOWMlu+8jOatpOaXtuaAp+i0qDXooqvnoLTlnY/jgILlpoLmnpzooqvliKDoioLngrnnmoTllK/kuIDpnZ7nqbrlrZDoioLngrnmmK/nuqLoibLvvIzogIzooqvliKDoioLngrnnmoTniLboioLngrnkuZ/mmK/nuqLoibLvvIzpgqPkuYjmgKfotKg06KKr56C05Z2P44CC5aaC5p6c6KKr5Yig6IqC54K55piv5qC56IqC54K577yM6ICM5a6D55qE5ZSv5LiA6Z2e56m65a2Q6IqC54K55piv57qi6Imy77yM5YiZ5Yig6Zmk5ZCO5paw5qC56IqC54K55bCG5Y+Y5oiQ57qi6Imy77yM6L+d6IOM5oCn6LSoMuOAglxyXG5cclxu5LiK6Z2i55qE5L+u5aSN5oOF5Ya155yL6LW35p2l5pyJ5Lqb5aSN5p2C77yM5LiL6Z2i5oiR5Lus55So5LiA5Liq5YiG5p6Q5oqA5ben77ya5oiR5Lus5LuO6KKr5Yig6IqC54K55ZCO5p2l6aG25pu/5a6D55qE6YKj5Liq6IqC54K55byA5aeL6LCD5pW077yM5bm26K6k5Li65a6D5pyJ6aKd5aSW55qE5LiA6YeN6buR6Imy44CC6L+Z6YeM6aKd5aSW5LiA6YeN6buR6Imy5piv5LuA5LmI5oSP5oCd5ZGi77yM5oiR5Lus5LiN5piv5oqK57qi6buR5qCR55qE6IqC54K55Yqg5LiK6Zmk57qi5LiO6buR55qE5Y+m5LiA56eN6aKc6Imy77yM6L+Z6YeM5Y+q5piv5LiA56eN5YGH6K6+77yM5oiR5Lus6K6k5Li65oiR5Lus5b2T5YmN5oyH5ZCR5a6D77yM5Zug5q2k56m65pyJ6aKd5aSW5LiA56eN6buR6Imy77yM5Y+v5Lul6K6k5Li65a6D55qE6buR6Imy5piv5LuO5a6D55qE54i26IqC54K56KKr5Yig6Zmk5ZCO57un5om/57uZ5a6D55qE77yM5a6D546w5Zyo5Y+v5Lul5a6557qz5Lik56eN6aKc6Imy77yM5aaC5p6c5a6D5Y6f5p2l5piv57qi6Imy77yM6YKj5LmI546w5Zyo5piv57qiK+m7ke+8jOWmguaenOWOn+adpeaYr+m7keiJsu+8jOmCo+S5iOWug+eOsOWcqOeahOminOiJsuaYr+m7kSvpu5HjgILmnInkuobov5nph43pop3lpJbnmoTpu5HoibLvvIzljp/nuqLpu5HmoJHmgKfotKg15bCx6IO95L+d5oyB5LiN5Y+Y44CC546w5Zyo5Y+q6KaB5oGi5aSN5YW25a6D5oCn6LSo5bCx5Y+v5Lul5LqG77yM5YGa5rOV6L+Y5piv5bC96YeP5ZCR5qC556e75Yqo5ZKM56m35Li+5omA5pyJ5Y+v6IO95oCn44CCXHJcblxyXG4g5aaC5p6c5piv5Lul5LiL5oOF5Ya177yM5oGi5aSN5q+U6L6D566A5Y2V77yaXHJcbiBhKeW9k+WJjeiKgueCueaYr+e6oivpu5HoibJcclxuIOino+azle+8jOebtOaOpeaKiuW9k+WJjeiKgueCueafk+aIkOm7keiJsu+8jOe7k+adn+atpOaXtue6oum7keagkeaAp+i0qOWFqOmDqOaBouWkjeOAglxyXG4gYinlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5piv5qC56IqC54K577yMIOino+azle+8muS7gOS5iOmDveS4jeWBmu+8jOe7k+adn+OAglxyXG5cclxuIOS9huWmguaenOaYr+S7peS4i+aDheWGteWRou+8n++8mlxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKVxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJslxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueminOiJsuaYr+m7kSvpu5HvvIzlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzlhYTlvJ/nmoTlt6blrZDmmK/nuqLoibLvvIzlj7PlrZDmmK/pu5HoibJcclxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSPXHJcbiDmraTml7bvvIzmiJHku6zpnIDopoHosIPnlKhSQi1ERUxFVEUtRklYVVAoVCwgeCnvvIzmnaXmgaLlpI3kuI7kv53mjIHnuqLpu5HmgKfotKjnmoTlt6XkvZzjgIJcclxuXHJcbiDkuIvpnaLvvIzlkrHku6zkvr/mnaXliIbliKvlpITnkIbov5k056eN5Yig6Zmk5L+u5aSN5oOF5Ya144CCXHJcblxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKeOAglxyXG4g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV77yI5oiR5Lus5Y+q6K6o6K665b2T5YmN6IqC54K55piv5YW254i26IqC54K55bem5a2p5a2Q5pe255qE5oOF5Ya177yJ44CC5q2k5Y+Y5o2i5ZCO5Y6f57qi6buR5qCR5oCn6LSoNeS4jeWPmO+8jOiAjOaKiumXrumimOi9rOWMluS4uuWFhOW8n+iKgueCueS4uum7keiJsueahOaDheWGtSjms6jvvJrlj5jljJbliY3vvIzljp/mnKzlsLHmnKrov53lj43mgKfotKg177yM5Y+q5piv5Li65LqG5oqK6Zeu6aKY6L2s5YyW5Li65YWE5byf6IqC54K55Li66buR6Imy55qE5oOF5Ya1KeOAglxyXG5cclxuIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibLjgIJcclxuIOino+azle+8muaKiuW9k+WJjeiKgueCueWSjOWFhOW8n+iKgueCueS4reaKveWPluS4gOmHjem7keiJsui/veWKoOWIsOeItuiKgueCueS4iu+8jOaKiueItuiKgueCueW9k+aIkOaWsOeahOW9k+WJjeiKgueCue+8jOmHjeaWsOi/m+WFpeeul+azleOAgu+8iOatpOWPmOaNouWQjuaAp+i0qDXkuI3lj5jvvIlcclxuXHJcbiDliKDpmaTkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRK+m7ke+8jOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOWFhOW8n+eahOW3puWtkOaYr+e6ouiJsu+8jOWPs+WtkOaYr+m7keiJsuOAglxyXG4g6Kej5rOV77ya5oqK5YWE5byf57uT54K55p+T57qi77yM5YWE5byf5bem5a2Q6IqC54K55p+T6buR77yM5LmL5ZCO5YaN5Zyo5YWE5byf6IqC54K55Li65pSv54K56Kej5Y+z5peL77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV44CC5q2k5piv5oqK5b2T5YmN55qE5oOF5Ya16L2s5YyW5Li65oOF5Ya1NO+8jOiAjOaAp+i0qDXlvpfku6Xkv53mjIFcclxuXHJcbiDliKDpmaTkv67lpI3mg4XlhrU077ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRLem7keiJsu+8jOWug+eahOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOS9huaYr+WFhOW8n+iKgueCueeahOWPs+WtkOaYr+e6ouiJsu+8jOWFhOW8n+iKgueCueW3puWtkOeahOminOiJsuS7u+aEj+OAglxyXG4g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXHJcblxyXG5cclxuIOacgOWQjuWAvOW+l+S4gOaPkOeahOaYr+S4iui/sOWIoOmZpOS/ruWkjeeahOaDheWGtTF+NOmDveWPquaYr+agkeeahOWxgOmDqO+8jOW5tumdnuagkeeahOaVtOS9k+WFqOmDqO+8jOS4lOWIoOmZpOS/ruWkjeaDheWGtTPjgIE05Zyo57uP6L+H5LiK6Z2i55qE6LCD5pW05ZCO77yM6LCD5pW06L+Y5rKh57uT5p2fLOi/mOW+l+e7p+e7reiwg+aVtOebtOiHs+mHjeaWsOaBouWkjeW5s+ihoVxyXG4qL1xyXG5pbXBvcnQgQlNUTm9kZSBmcm9tICcuL0JpbmFyeVNvcnRlZFRyZWUnO1xyXG5cclxuY29uc3QgUkVEID0gJ3JlZCc7XHJcbmNvbnN0IEJMQUNLID0gJ2JsYWNrJztcclxuXHJcbmNsYXNzIFJlZEJsYWNrTm9kZSBleHRlbmRzIEJTVE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIC4uLnJlc3Qpe1xyXG4gICAgICAgIHN1cGVyKGRhdGEsIC4uLnJlc3QpO1xyXG5cclxuICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodENoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgUmVkQmxhY2tMZWFmIHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gdGhpcztcclxuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWRCbGFja1RyZWUge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICAvLyDlk6jlhbVcclxuICAgICAgICB0aGlzLm5pbCA9IG5ldyBSZWRCbGFja0xlYWYoKTtcclxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm5pbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOmAkuW9kuafpeaJvueul+azlVxyXG4gICAgICogQHBhcmFtIGRhdGFcclxuICAgICAqL1xyXG4gICAgZmluZChkYXRhKXtcclxuICAgICAgICBsZXQgeiA9IHRoaXMucm9vdDtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIGZpbmQoeiwgZGF0YSl7XHJcbiAgICAgICAgICAgIGlmKHogPT0gbWUubmlsIHx8IGRhdGEgPT09IHouZGF0YSkgcmV0dXJuIHo7XHJcblxyXG4gICAgICAgICAgICBpZihkYXRhIDwgei5kYXRhKSByZXR1cm4gZmluZCh6LmxlZnRDaGlsZCwgZGF0YSk7XHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZpbmQoei5yaWdodENoaWxkLCBkYXRhKTtcclxuICAgICAgICB9KSh6LCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOaPkuWFpVxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGFkZChkYXRhKXtcclxuICAgICAgICBsZXQgeiA9IG5ldyBSZWRCbGFja05vZGUoZGF0YSk7XHJcbiAgICAgICAgei5sZWZ0Q2hpbGQgPSB0aGlzLm5pbDtcclxuICAgICAgICB6LnJpZ2h0Q2hpbGQgPSB0aGlzLm5pbDtcclxuICAgICAgICBsZXQgeSA9IHRoaXMubmlsO1xyXG4gICAgICAgIGxldCB4ID0gdGhpcy5yb290O1xyXG5cclxuICAgICAgICAvLyDmib7liLDopoHmj5LlhaXkvY3nva7nmoTnu5Pngrl5XHJcbiAgICAgICAgd2hpbGUoeCAhPSB0aGlzLm5pbCl7XHJcbiAgICAgICAgICAgIHkgPSB4O1xyXG5cclxuICAgICAgICAgICAgaWYoei5kYXRhIDwgeC5kYXRhKSB4ID0geC5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIGVsc2UgeCA9IHgucmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHoucGFyZW50ID0geTtcclxuXHJcbiAgICAgICAgLy8g5aaC5p6ceeS4jeaYr+aguee7k+eCue+8jOagueaNruWkp+Wwj+aPkuWFpeWIsOW3puaIluWPs+WtkOagkVxyXG4gICAgICAgIGlmKHkgIT0gdGhpcy5uaWwpIHtcclxuICAgICAgICAgICAgaWYoei5kYXRhIDwgeS5kYXRhKSB5LmxlZnRDaGlsZCA9IHo7XHJcbiAgICAgICAgICAgIGVsc2UgeS5yaWdodENoaWxkID0gejtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5ZCm5YiZ5o+S5YWl5Yiw5qC557uT54K5XHJcbiAgICAgICAgZWxzZSB0aGlzLnJvb3QgPSB6ID09IHRoaXMubmlsID8gbnVsbCA6IHo7XHJcblxyXG4gICAgICAgIC8vIOaPkuWFpeS/ruWkjeaTjeS9nFxyXG4gICAgICAgIHRoaXMuX2FkZEZpeHVwKHopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5o+S5YWl566X5rOV5L+u5aSNXHJcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0geiDlvoXmj5LlhaXnmoTnu5PngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9hZGRGaXh1cCh6KXtcclxuXHJcbiAgICAgICAgd2hpbGUoeiAhPSB0aGlzLnJvb3QgJiYgei5wYXJlbnQuY29sb3IgPT09IFJFRCl7XHJcbiAgICAgICAgICAgIGlmKHoucGFyZW50ID09IHoucGFyZW50LnBhcmVudC5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICBsZWZ0QWRkRml4dXAodGhpcywgeik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJpZ2h0QWRkRml4dXAodGhpcywgeik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmnIDlkI7vvIzmiormoLnnu5PngrnmtoLkuLrpu5HoibLvvIzmlbTmo7XnuqLpu5HmoJHkvr/ph43mlrDmgaLlpI3kuoblubPooaFcclxuICAgICAgICB0aGlzLnJvb3QuY29sb3IgPSBCTEFDSztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe6oum7keagkeeahOWIoOmZpOeul+azlVxyXG4gICAgICogQHBhcmFtIHtSZWRCbGFja05vZGV9IHog5b6F5Yig6Zmk57uT54K5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU5vZGUoeil7XHJcbiAgICAgICAgbGV0IHgsIHk7XHJcblxyXG4gICAgICAgIC8vIOaJvuWIsOW+heWIoOmZpOe7k+eCueeahOeItue7k+eCueaIluebuOmCu+W+heabv+aNoue7k+eCuVxyXG4gICAgICAgIGlmKHoubGVmdENoaWxkID09IHRoaXMubmlsIHx8IHoucmlnaHRDaGlsZCA9PSB0aGlzLm5pbClcclxuICAgICAgICAgICAgeSA9IHo7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB5ID0gdGhpcy5zdWNjZXNzb3Ioeik7XHJcblxyXG4gICAgICAgIGlmKHkubGVmdENoaWxkICE9IHRoaXMubmlsKSB4ID0geS5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgZWxzZSB4ID0geS5yaWdodENoaWxkO1xyXG5cclxuICAgICAgICB4LnBhcmVudCA9IHkucGFyZW50O1xyXG5cclxuICAgICAgICAvLyDliKDpmaTmk43kvZxcclxuICAgICAgICBpZih5LnBhcmVudCA9PSB0aGlzLm5pbCkgdGhpcy5yb290ID0geDtcclxuICAgICAgICBlbHNlIGlmKHkgPT0geS5wYXJlbnQubGVmdENoaWxkKSB5LnBhcmVudC5sZWZ0Q2hpbGQgPSB4O1xyXG4gICAgICAgIGVsc2UgeS5wYXJlbnQucmlnaHRDaGlsZCA9IHg7XHJcblxyXG4gICAgICAgIGlmKHkgIT0geikgei5kYXRhID0geS5kYXRhO1xyXG5cclxuICAgICAgICAvLyDliKDpmaTkv67lpI1cclxuICAgICAgICBpZih5LmNvbG9yID09PSBCTEFDSykgdGhpcy5fcmVtb3ZlRml4dXAoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g566X5rOV5a+86K665LiK55qE5Yig6Zmk57uT54K5XHJcbiAgICByZW1vdmVOb2RlMih6KXtcclxuICAgICAgICBsZXQgeSA9IHo7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsWUNvbG9yID0geS5jb2xvcjtcclxuICAgICAgICBsZXQgeDtcclxuXHJcbiAgICAgICAgaWYoei5sZWZ0Q2hpbGQgPT0gdGhpcy5uaWwpIHtcclxuICAgICAgICAgICAgeCA9IHoucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNwbGFudCh6LCB6LnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH0gZWxzZSBpZih6LnJpZ2h0Q2hpbGQgPT0gdGhpcy5uaWwpIHtcclxuICAgICAgICAgICAgeCA9IHoubGVmdENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHoubGVmdENoaWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5ID0gdGhpcy5taW4oei5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxZQ29sb3IgPSB5LmNvbG9yO1xyXG4gICAgICAgICAgICB4ID0geS5yaWdodENoaWxkO1xyXG5cclxuICAgICAgICAgICAgaWYoeS5wYXJlbnQgPT0geikgeC5wYXJlbnQgPSB5O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeSwgeS5yaWdodENoaWxkKTtcclxuICAgICAgICAgICAgICAgIHkucmlnaHRDaGlsZCA9IHoucmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgICAgIHkucmlnaHRDaGlsZC5wYXJlbnQgPSB5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHkpO1xyXG4gICAgICAgICAgICB5LmxlZnRDaGlsZCA9IHoubGVmdENoaWxkO1xyXG4gICAgICAgICAgICB5LmxlZnRDaGlsZC5wYXJlbnQgPSB5O1xyXG4gICAgICAgICAgICB5LmNvbG9yID0gei5jb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG9yaWdpbmFsWUNvbG9yID09PSBCTEFDSykgdGhpcy5fcmVtb3ZlRml4dXAoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3RyYW5zcGxhbnQodSwgdil7XHJcbiAgICAgICAgaWYodS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHY7XHJcbiAgICAgICAgZWxzZSBpZih1ID09IHUucGFyZW50LmxlZnRDaGlsZCkgdS5wYXJlbnQubGVmdENoaWxkID0gdjtcclxuICAgICAgICBlbHNlIHUucGFyZW50LnJpZ2h0Q2hpbGQgPSB2O1xyXG5cclxuICAgICAgICB2LnBhcmVudCA9IHUucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5L+u5aSNXHJcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0gelxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZUZpeHVwKHope1xyXG4gICAgICAgIHdoaWxlKHogIT09IHRoaXMucm9vdCAmJiB6LmNvbG9yID09PSBCTEFDSyl7XHJcbiAgICAgICAgICAgIGlmKHogPT0gei5wYXJlbnQubGVmdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgbGVmdFJlbW92ZUZpeHVwKHRoaXMsIHopO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByaWdodFJlbW92ZUZpeHVwKHRoaXMsIHopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgei5jb2xvciA9IEJMQUNLO1xyXG4gICAgfVxyXG5cclxuICAgIHN1Y2Nlc3Nvcih6KXtcclxuICAgICAgICBpZih6LnJpZ2h0Q2hpbGQgIT0gdGhpcy5uaWwpIHJldHVybiB0aGlzLm1pbih6LnJpZ2h0Q2hpbGQpO1xyXG5cclxuICAgICAgICBsZXQgeSA9IHoucGFyZW50O1xyXG5cclxuICAgICAgICB3aGlsZSh5ICE9IHRoaXMubmlsICYmIHogPT0geS5yaWdodENoaWxkKXtcclxuICAgICAgICAgICAgeiA9IHk7XHJcbiAgICAgICAgICAgIHkgPSB5LnBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIG1pbih6KXtcclxuICAgICAgICB3aGlsZSh6LmxlZnRDaGlsZCAhPSB0aGlzLm5pbCl7XHJcbiAgICAgICAgICAgIHogPSB6LmxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB6O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2ua2V55YC85Yig6Zmk57uT54K5XHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXkpe1xyXG4gICAgICAgIGxldCB6ID0gdGhpcy5maW5kKGtleSk7XHJcblxyXG4gICAgICAgIGlmKHogPT0gdGhpcy5uaWwpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTm9kZSh6KTtcclxuICAgIH1cclxufVxyXG5cclxuUmVkQmxhY2tUcmVlLnByb3RvdHlwZS5fcm90YXRlTGVmdCA9IHJvdGF0ZSgnbGVmdCcpO1xyXG5SZWRCbGFja1RyZWUucHJvdG90eXBlLl9yb3RhdGVSaWdodCA9IHJvdGF0ZSgncmlnaHQnKTtcclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZShkaXIpe1xyXG4gICAgbGV0IGMxLCBjMjtcclxuICAgIGlmKCBkaXIgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ2xlZnRDaGlsZCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAncmlnaHRDaGlsZCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIGxldCB5ID0geFtjMV07XHJcbiAgICAgICAgeFtjMV0gPSB5W2MyXTtcclxuXHJcbiAgICAgICAgaWYoeVtjMl0gIT0gdGhpcy5uaWwpIHlbYzJdLnBhcmVudCA9IHg7XHJcbiAgICAgICAgeS5wYXJlbnQgPSB4LnBhcmVudDtcclxuXHJcbiAgICAgICAgaWYoeC5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHk7XHJcbiAgICAgICAgZWxzZSBpZih4ID09IHgucGFyZW50W2MyXSkgeC5wYXJlbnRbYzJdID0geTtcclxuICAgICAgICBlbHNlIHgucGFyZW50W2MxXSA9IHk7XHJcblxyXG4gICAgICAgIHlbYzJdID0geDtcclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRGaXh1cChkaXIpe1xyXG4gICAgbGV0IGMxLCBjMiwgcm90YXRlMSwgcm90YXRlMjtcclxuICAgIGlmKCBkaXIgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ2xlZnRDaGlsZCc7XHJcbiAgICAgICAgcm90YXRlMSA9ICdfcm90YXRlTGVmdCc7XHJcbiAgICAgICAgcm90YXRlMiA9ICdfcm90YXRlUmlnaHQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjMSA9ICdsZWZ0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIHJvdGF0ZTEgPSAnX3JvdGF0ZVJpZ2h0JztcclxuICAgICAgICByb3RhdGUyID0gJ19yb3RhdGVMZWZ0JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24odHJlZSwgeil7XHJcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XHJcblxyXG4gICAgICAgIC8vIOWPlOe7k+eCuVxyXG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQucGFyZW50W2MxXTtcclxuXHJcbiAgICAgICAgLy8g5o+S5YWl5L+u5aSN5oOF5Ya1Me+8muWmguaenOW9k+WJjee7k+eCueeahOeItue7k+eCueaYr+e6ouiJsuS4lOellueItue7k+eCueeahOWPpuS4gOS4quWtkOe7k+eCue+8iOWPlOe7k+eCue+8ieaYr+e6ouiJslxyXG4gICAgICAgIC8vIOWwhuW9k+WJjeiKgueCueeahOeItuiKgueCueWSjOWPlOWPlOiKgueCuea2gum7ke+8jOellueItue7k+eCuea2gue6ou+8jOaKiuW9k+WJjee7k+eCueaMh+WQkeellueItuiKgueCue+8jOS7juaWsOeahOW9k+WJjeiKgueCuemHjeaWsOW8gOWni+eul+azleOAglxyXG4gICAgICAgIGlmKHkuY29sb3IgPT09IFJFRCkge1xyXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICB5LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHoucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgeiA9IHoucGFyZW50LnBhcmVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOWPs+WtkFxyXG4gICAgICAgICAgICAvLyDop6PlhrPlr7nnrZbmmK/vvJrlvZPliY3oioLngrnnmoTniLboioLngrnlgZrkuLrmlrDnmoTlvZPliY3oioLngrnvvIzku6XmlrDlvZPliY3oioLngrnkuLrmlK/ngrnlt6bml4vjgIJcclxuICAgICAgICAgICAgLy8g5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcclxuICAgICAgICAgICAgaWYoeiA9PT0gei5wYXJlbnRbYzFdKSB7XHJcbiAgICAgICAgICAgICAgICB6ID0gei5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0cmVlW3JvdGF0ZTFdKHopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxyXG4gICAgICAgICAgICAvLyDop6PlhrPlr7nnrZbmmK/vvJrniLboioLngrnlj5jkuLrpu5HoibLvvIznpZbniLboioLngrnlj5jkuLrnuqLoibLvvIzlnKjnpZbniLboioLngrnkuLrmlK/ngrnlj7Pml4vvvIxcclxuICAgICAgICAgICAgei5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgei5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICB0cmVlW3JvdGF0ZTJdKHoucGFyZW50LnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxubGV0IGxlZnRBZGRGaXh1cCA9IGFkZEZpeHVwKCdsZWZ0Jyk7XHJcbmxldCByaWdodEFkZEZpeHVwID0gYWRkRml4dXAoJ3JpZ2h0Jyk7XHJcbmxldCBsZWZ0UmVtb3ZlRml4dXAgPSByZW1vdmVGaXh1cCgnbGVmdCcpO1xyXG5sZXQgcmlnaHRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdyaWdodCcpO1xyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRml4dXAoZGlyKXtcclxuICAgIGxldCBjMSwgYzIsIHIxLCByMjtcclxuICAgIGlmKGRpciA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgYzEgPSAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcclxuICAgICAgICByMSA9ICdfcm90YXRlTGVmdCc7XHJcbiAgICAgICAgcjIgPSAnX3JvdGF0ZVJpZ2h0JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYzEgPSAnbGVmdENoaWxkJztcclxuICAgICAgICBjMiA9ICdyaWdodENoaWxkJztcclxuICAgICAgICByMSA9ICdfcm90YXRlUmlnaHQnO1xyXG4gICAgICAgIHIyID0gJ19yb3RhdGVMZWZ0JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24odHJlZSwgeil7XHJcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XHJcblxyXG4gICAgICAgIC8vIOWPlOe7k+eCuVxyXG4gICAgICAgIGxldCB3ID0gei5wYXJlbnRbYzFdO1xyXG5cclxuICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrUx77ya5b2T5YmN6IqC54K55piv6buRK+m7keS4lOWFhOW8n+iKgueCueS4uue6ouiJsijmraTml7bniLboioLngrnlkozlhYTlvJ/oioLngrnnmoTlrZDoioLngrnliIbkuLrpu5Ep44CCXHJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOVXHJcbiAgICAgICAgaWYody5jb2xvciA9PT0gUkVEKXtcclxuICAgICAgICAgICAgdy5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgdHJlZVtyMV0oei5wYXJlbnQpO1xyXG4gICAgICAgICAgICB3ID0gei5wYXJlbnRbYzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJsuOAglxyXG4gICAgICAgIC8vIOino+azle+8muaKiuW9k+WJjeiKgueCueWSjOWFhOW8n+iKgueCueS4reaKveWPluS4gOmHjem7keiJsui/veWKoOWIsOeItuiKgueCueS4iu+8jOaKiueItuiKgueCueW9k+aIkOaWsOeahOW9k+WJjeiKgueCue+8jOmHjeaWsOi/m+WFpeeul+azleOAglxyXG4gICAgICAgIGlmKHdbYzJdLmNvbG9yID09PSBCTEFDSyAmJiB3W2MxXS5jb2xvciA9PT0gQkxBQ0spe1xyXG4gICAgICAgICAgICB3LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICB6ID0gei5wYXJlbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueminOiJsuaYr+m7kSvpu5HvvIzlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzlhYTlvJ/nmoTlt6blrZDmmK/nuqLoibLvvIzlj7PlrZDmmK/pu5HoibLjgIJcclxuICAgICAgICAgICAgLy8g6Kej5rOV77ya5oqK5YWE5byf57uT54K55p+T57qi77yM5YWE5byf5bem5a2Q6IqC54K55p+T6buR77yM5LmL5ZCO5YaN5Zyo5YWE5byf6IqC54K55Li65pSv54K56Kej5Y+z5peL77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV44CCXHJcbiAgICAgICAgICAgIGlmKHdbYzFdLmNvbG9yID09PSBCTEFDSykge1xyXG4gICAgICAgICAgICAgICAgd1tjMl0uY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgIHcuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICB0cmVlW3IyXSh3KTtcclxuICAgICAgICAgICAgICAgIHcgPSB6LnBhcmVudFtjMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSP44CCXHJcbiAgICAgICAgICAgIC8vIOino+azle+8muaKiuWFhOW8n+iKgueCueafk+aIkOW9k+WJjeiKgueCueeItuiKgueCueeahOminOiJsu+8jOaKiuW9k+WJjeiKgueCueeItuiKgueCueafk+aIkOm7keiJsu+8jOWFhOW8n+iKgueCueWPs+WtkOafk+aIkOm7keiJsu+8jOS5i+WQjuS7peW9k+WJjeiKgueCueeahOeItuiKgueCueS4uuaUr+eCuei/m+ihjOW3puaXi++8jOatpOaXtueul+azlee7k+adn++8jOe6oum7keagkeaJgOacieaAp+i0qOiwg+aVtOato+ehrlxyXG4gICAgICAgICAgICB3LmNvbG9yID0gei5wYXJlbnQuY29sb3I7XHJcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHdbYzFdLmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHRyZWVbcjFdKHoucGFyZW50KTtcclxuICAgICAgICAgICAgeiA9IHRyZWUucm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxubGV0IHRlc3QgPSBuZXcgUmVkQmxhY2tUcmVlKCk7XHJcbnRlc3QuYWRkKDEzKTtcclxudGVzdC5hZGQoOCk7XHJcbnRlc3QuYWRkKDE3KTtcclxudGVzdC5hZGQoMSk7XHJcbnRlc3QuYWRkKDYpO1xyXG50ZXN0LmFkZCgxMSk7XHJcbnRlc3QuYWRkKDE1KTtcclxudGVzdC5hZGQoMjIpO1xyXG50ZXN0LmFkZCgyNSk7XHJcbnRlc3QuYWRkKDI3KTtcclxuXHJcbnRlc3QucmVtb3ZlKDEzKTtcclxudGVzdC5yZW1vdmUoOCk7XHJcbnRlc3QucmVtb3ZlKDE3KTtcclxudGVzdC5yZW1vdmUoMSk7XHJcbnRlc3QucmVtb3ZlKDYpO1xyXG50ZXN0LnJlbW92ZSgxMSk7XHJcbnRlc3QucmVtb3ZlKDE1KTtcclxudGVzdC5yZW1vdmUoMjIpO1xyXG50ZXN0LnJlbW92ZSgyNSk7XHJcbnRlc3QucmVtb3ZlKDI3KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL1JlZEJsYWNrVHJlZS5qc1xuICoqLyIsIi8qXHJcbiDpnZnmgIHmrKHkvJjmn6Xmib7moJFcclxuXHJcbiDpgILlkIjlkITorrDlvZXnmoTmn6Xmib7mpoLnjofkuI3nrYnnmoTmg4XlhrVcclxuXHJcbiDmn6Xmib7mlYjnjofmnIDpq5jljbPlubPlnYfmn6Xmib7plb/luqbmnIDlsI/vvIzmiJHku6zlj6/ku6Xnu5nlh7rmnInluo/ooajlnKjpnZ7nrYnmpoLnjofmg4XlhrXkuIvlupTpgbXlvqrnmoTkuKTkuKrljp/liJnvvJpcclxuIDHjgIHmnIDlhYjorr/pl67nmoTnu5PngrnlupTmmK/orr/pl67mpoLnjofmnIDlpKfnmoTnu5PngrnvvJtcclxuIDLjgIHmr4/mrKHorr/pl67lupTkvb/nu5PngrnkuKTovrnlsJrmnKrorr/pl67nmoTnu5PngrnnmoTooqvorr/mpoLnjofkuYvlkozlsL3lj6/og73nm7jnrYnjgIJcclxuXHJcblxyXG4g6L+Z5Lik5Liq5Y6f5YiZ5Y+v55So5LiA5Y+l6K+d5p2l6KGo56S677yM5Y2z5Yik5a6a5qCR5Li65bim5p2D5YaF6Lev5b6E6ZW/5bqm5LmL5ZKM5pyA5bCP55qE5LqM5Y+J5qCR77yM5Lqm5Y2z77yaUEggPSDiiJF3aWhpICDmnIDlsI/vvIzlhbbkuK0gbiDkuLrmnInluo/ooajplb/luqbvvIxoaSDkuLrnrKwgaSDkuKrnu5PngrnlnKjliKTlrprmoJHkuIrnmoTlsYLmrKHmlbDvvIx3aSA9IGNwae+8jGMg5Li65p+Q5Liq5bi45pWw77yMcGkg5Li656ysIGkg5Liq57uT54K555qE5p+l5om+5qaC546H44CCXHJcblxyXG5cclxuIOi/meagt+eahOagkeensOS4uumdmeaAgeacgOS8mOafpeaJvuagke+8iHN0YXRpYyBvcHRpbWFsIHNlYXJjaCB0cmVl77yJ77yM5p6E6YCg6L+Z5qC35LiA5qO15qCR55qE5pe26Ze05Luj5Lu35aSq5aSn77yM5Lqm5Y2z5pe26Ze05aSN5p2C5bqm5b6I5aSn77yM5Zug5q2k5oiR5Lus6YCa5bi45piv5p6E6YCg5qyh5LyY5p+l5om+5qCR77yIbmVhcmx5IG9wdGltYWwgc2VhcmNoIHRyZWXvvInvvIzmnoTpgKDlroPnmoTml7bpl7Tku6Pku7fov5zov5zkvY7kuo7mnoTpgKDmnIDkvJjmn6Xmib7moJHvvIzkvYbmn6Xmib7mgKfog73lj6rmr5TmnIDkvJjmn6Xmib7moJHlt64xJX4yJe+8jOW+iOWwkeW3rjMl5Lul5LiK44CCXHJcblxyXG4g5qyh5LyY5p+l5om+5qCR55qE5p6E6YCg77yaXHJcblxyXG4g6K6+5pyJ5bqP6KGo5q+P5Liq6K6w5b2V55qE5p2D5YC85Li6IHdsLHdsKzEs4oCmLHdo77yM56ys5LiA5Liq5bqU6K6/6Zeu55qE57uT54K55Y+35Li6IGkg77yM5YiZ5pyJ77yaXHJcbiDOlHBpID0gICDiiJF3aiAtIOKIkXdqICAg5pyA5bCP77yM5Y2zIM6UcGkgPSBNaW4ge86UcGogfVxyXG4g5YaN5YiG5Yir5a+5IHtybCxybCsxLOKApixyaS0xfSDlkowge3JpKzEscmkrMizigKYscmh9IOWIhuWIq+aehOmAoOasoeS8mOafpeaJvuagkVxyXG4gKi9cclxuaW1wb3J0IHsgQmluYXJ5VHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XHJcblxyXG4vKipcclxuICog55Sx5pyJ5bqP6KGoc1RhYmxlW2xvdy4uaGlnaF3lj4rlhbbntK/orqHmnYPlgLzooah3ZWlnaHRz6YCS5b2S5p6E6YCg5qyh5LyY5p+l5om+5qCRXHJcbiAqIEBwYXJhbSB7QmluYXJ5VHJlZX0gdHJlZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzVGFibGVcclxuICogQHBhcmFtIHtBcnJheX0gc1dlaWdodHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xyXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZE9wdGltYWwodHJlZSwgc1RhYmxlLCBzV2VpZ2h0cywgbG93LCBoaWdoKSB7XHJcbiAgICBsZXQgaSA9IGxvdztcclxuICAgIGxldCBtaW4gPSBNYXRoLmFicyhzV2VpZ2h0c1toaWdoXSAtIHNXZWlnaHRzW2xvd10pO1xyXG4gICAgbGV0IGR3ID0gc1dlaWdodHNbaGlnaF0gKyAoc1dlaWdodHNbbG93IC0gMV0gfHwgMCk7XHJcblxyXG4gICAgLy8g6YCJ5oup5pyA5bCP55qE4pazUGnlgLxcclxuICAgIGZvciAobGV0IGogPSBsb3cgKyAxOyBqIDw9IGhpZ2g7ICsraikge1xyXG4gICAgICAgIGxldCB0ID0gTWF0aC5hYnMoZHcgLSBzV2VpZ2h0c1tqXSAtIHNXZWlnaHRzW2ogLSAxXSk7XHJcbiAgICAgICAgaWYgKHQgPCBtaW4pIHtcclxuICAgICAgICAgICAgaSA9IGo7XHJcbiAgICAgICAgICAgIG1pbiA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOiwg+aVtOagkeagueadg++8jOmAieaLqemCu+i/keadg+WAvOi+g+Wkp+eahOWFs+mUruWtl1xyXG4gICAgbGV0IGEgPSAwLCBiLCBjID0gMDtcclxuICAgIGlmIChpIC0gMSA+PSBsb3cpICBiID0gc1dlaWdodHNbaV0gLSBzV2VpZ2h0c1tpIC0gMV07XHJcbiAgICBpZiAoaSAtIDIgPj0gbG93KSBhID0gc1dlaWdodHNbaSAtIDFdIC0gc1dlaWdodHNbaSAtIDJdO1xyXG4gICAgaWYgKGkgKyAxIDwgaGlnaCkgYyA9IHNXZWlnaHRzW2kgKyAxXSAtIHNXZWlnaHRzW2ldO1xyXG4gICAgaWYgKHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmIChhID4gYyAmJiBhID4gYikgLS1pO1xyXG4gICAgICAgIGVsc2UgaWYgKGEgPCBjICYmIGMgPiBiKSAgKytpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyZWUuZGF0YSA9IHNUYWJsZVtpXTtcclxuICAgIC8v5bem5a2Q5qCRXHJcbiAgICBpZiAoaSA9PT0gbG93KSB0cmVlLmxlZnRDaGlsZCA9IG51bGw7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cmVlLmxlZnRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XHJcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLmxlZnRDaGlsZCwgc1RhYmxlLCBzV2VpZ2h0cywgbG93LCBpIC0gMSk7XHJcbiAgICB9XHJcbiAgICAvLyDlj7PlrZDmoJFcclxuICAgIGlmIChpID09PSBoaWdoKSB0cmVlLnJpZ2h0Q2hpbGQgPSBudWxsO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJlZS5yaWdodENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcclxuICAgICAgICBzZWNvbmRPcHRpbWFsKHRyZWUucmlnaHRDaGlsZCwgc1RhYmxlLCBzV2VpZ2h0cywgaSArIDEsIGhpZ2gpO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgdHJlZSA9IG5ldyBCaW5hcnlUcmVlKCk7XHJcbnNlY29uZE9wdGltYWwodHJlZSwgWydBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSSddLCBbMSwgMiwgNCwgOSwgMTIsIDE2LCAyMCwgMjMsIDI4XSwgMCwgOCk7XHJcbmNvbnNvbGUubG9nKHRyZWUpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiDnlLHmnInluo/ooajmnoTpgKDkuIDmo7XmrKHkvJjmn6Xmib7moJFcclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiDmnInluo/ooajvvIzmlbDmja7lhYPntKDlkKvmnInmnYPln593ZWlnaHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTT1NUcmVlKG9iaikge1xyXG4gICAgbGV0IHRyZWU7XHJcbiAgICBpZiAob2JqLmVsZW1zLmxlbmd0aCA9PT0gMCkgdHJlZSA9IG51bGw7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyDmsYLntK/orqHmnYPlgLzooahcclxuICAgICAgICBsZXQgc3cgPSBmaW5kU1cob2JqLndlaWdodHMpO1xyXG4gICAgICAgIHRyZWUgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgIHNlY29uZE9wdGltYWwodHJlZSwgb2JqLmVsZW1zLCBzdywgMCwgb2JqLmVsZW1zLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kU1coc1RhYmxlKSB7XHJcbiAgICBsZXQgc3cgPSBbc1RhYmxlWzBdXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNUYWJsZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHN3W2ldID0gc3dbaSAtIDFdICsgc1RhYmxlW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdztcclxufVxyXG5cclxubGV0IHNvc1RyZWUgPSBjcmVhdGVTT1NUcmVlKHtcclxuICAgIGVsZW1zOiBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRSddLFxyXG4gICAgd2VpZ2h0czogWzEsIDMwLCAyLCAyOSwgM11cclxufSk7XHJcbnNvc1RyZWUuaW5PcmRlclJlY3Vyc2l2ZShmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGNvbnNvbGUubG9nKCdpbk9yZGVyOiAnICsgdmFsdWUpO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL1NPU1RyZWUuanNcbiAqKi8iLCIvKlxyXG4gRmlib25hY2Np5p+l5om+XHJcblxyXG4gRmlib25hY2Np5p+l5om+5pa55rOV5piv5qC55o2uRmlib25hY2Np5pWw5YiX55qE54m554K55a+55p+l5om+6KGo6L+b6KGM5YiG5Ymy44CCRmlib25hY2Np5pWw5YiX55qE5a6a5LmJ5piv77yaXHJcbiBGKDApPTDvvIxGKDEpPTHvvIxGKGopPUYoai0xKStGKGotMikg44CCXHJcblxyXG4gMSAg5p+l5om+5oCd5oOzXHJcbiDorr7mn6Xmib7ooajkuK3nmoTorrDlvZXmlbDmr5Tmn5DkuKpGaWJvbmFjY2nmlbDlsI8x77yM5Y2z6K6+bj1GKGopLTHjgILnlKhMb3fjgIFIaWdo5ZKMTWlk6KGo56S65b6F5p+l5om+5Yy66Ze055qE5LiL55WM44CB5LiK55WM5ZKM5YiG5Ymy5L2N572u77yM5Yid5YC85Li6TG93PTDvvIxIaWdoPW4gLSAx44CCXHJcbiDikbQgICDlj5bliIblibLkvY3nva5NaWTvvJpNaWQ9RihqLTEpIO+8m1xyXG4g4pG1ICAg5q+U6L6D5YiG5Ymy5L2N572u6K6w5b2V55qE5YWz6ZSu5a2X5LiO57uZ5a6a55qES+WAvO+8mlxyXG4g4pGgIOebuOetie+8miDmn6Xmib7miJDlip/vvJtcclxuIOKRoSAg5aSn5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5YmN5Y2K5q61KOWMuumXtOmVv+W6puS4ukYoai0xKS0xKe+8jOS/ruaUueS4iueVjOaMh+mSiO+8miBIaWdoPU1pZC0x77yM6L2s4pG0IO+8m1xyXG4g4pGiICDlsI/kuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTlkI7ljYrmrrUo5Yy66Ze06ZW/5bqm5Li6RihqLTIpLTEp77yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m+ebtOWIsOi2iueVjChMb3c+SGlnaCnvvIzmn6Xmib7lpLHotKXjgIJcclxuXHJcbiAyICDnrpfms5Xlrp7njrBcclxuIOWcqOeul+azleWunueOsOaXtu+8jOS4uuS6humBv+WFjemikee5geiuoeeul0ZpYm9uYWNjaeaVsO+8jOWPr+eUqOS4pOS4quWPmOmHj2Yx5ZKMZjLkv53lrZjlvZPliY3nm7jpgrvnmoTkuKTkuKpGaWJvbmFjY2nmlbDvvIzov5nmoLflnKjku6XlkI7nmoTorqHnrpfkuK3lj6/ku6Xkvp3mrKHpgJLmjqjorqHnrpflh7rjgIJcclxuXHJcbiAzICDnrpfms5XliIbmnpBcclxuIOeUseeul+azleefpe+8jEZpYm9uYWNjaeafpeaJvuWcqOacgOWdj+aDheWGteS4i+aAp+iDveavlOaKmOWNiuafpeaJvuW3ru+8jOS9huW5s+Wdh+aQnOe0ouasoeaVsOWwkeS6juaKmOWNiuafpeaJvu+8jOiAjOS4lOaKmOWNiuafpeaJvuimgeaxguiusOW9leaMieWFs+mUruWtl+acieW6j++8m0ZpYm9uYWNjaeafpeaJvueahOS8mOeCueaYr+WIhuWJsuaXtuWPqumcgOi/m+ihjOWKoOOAgeWHj+i/kOeul+OAglxyXG5cclxuICovXHJcblxyXG5mdW5jdGlvbiBmaWIobikge1xyXG4gICAgaWYgKG4gPT09IDApIHJldHVybiAwO1xyXG4gICAgaWYgKG4gPT09IDEpIHJldHVybiAxO1xyXG4gICAgbGV0IGY7XHJcbiAgICBsZXQgZjAgPSAwO1xyXG4gICAgbGV0IGYxID0gMTtcclxuICAgIGZvciAobGV0IGkgPSAyOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgIGYgPSBmMCArIGYxO1xyXG4gICAgICAgIGYwID0gZjE7XHJcbiAgICAgICAgZjEgPSBmO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGY7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlnKjmnInluo/ooahTVOS4reeUqEZpYm9uYWNjaeaWueazleafpeaJvuWFs+mUruWtl+S4umtleeeahOiusOW9lVxyXG4gKiBAcGFyYW0gc1RhYmxlXHJcbiAqIEBwYXJhbSBrZXlcclxuICogQHBhcmFtIG5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpYm9uYWNjaVNlYXJjaChzVGFibGUsIGtleSwgbiA9IHNUYWJsZS5sZW5ndGgpIHtcclxuICAgIGxldCBsb3cgPSAwO1xyXG4gICAgbGV0IGhpZ2ggPSBuIC0gMTtcclxuICAgIGxldCBmMSA9IGZpYihuKTtcclxuICAgIGxldCBmMiA9IGZpYihuIC0gMSk7XHJcblxyXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcbiAgICAgICAgbGV0IG1pZCA9IGxvdyArIGYxIC0gMTtcclxuICAgICAgICBpZiAoc1RhYmxlW21pZF0gPT09IGtleSkgcmV0dXJuIG1pZDtcclxuICAgICAgICBlbHNlIGlmIChrZXkgPCBzVGFibGVbbWlkXSkge1xyXG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcclxuICAgICAgICAgICAgZjIgPSBmMSAtIGYyO1xyXG4gICAgICAgICAgICBmMSA9IGYxIC0gZjI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgICAgICAgZjEgPSBmMSAtIGYyO1xyXG4gICAgICAgICAgICBmMiA9IGYyIC0gZjE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygnZmlib25hY2NpU2VhcmNoOiAnKTtcclxuY29uc29sZS5sb2coZmlib25hY2NpU2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgNSkpOyAvLyA0XHJcbmNvbnNvbGUubG9nKGZpYm9uYWNjaVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaC5qc1xuICoqLyIsIi8qXHJcbiDpnZnmgIHmn6Xmib5cclxuXHJcbiDnur/mgKfooajmmK/mn6Xmib7ooajmnIDnroDljZXnmoTkuIDnp43nu4Tnu4fmlrnlvI9cclxuXHJcbiDpobrluo/mn6Xmib4oU2VxdWVudGlhbCBTZWFyY2gpXHJcbiAxICDmn6Xmib7mgJ3mg7NcclxuIOS7juihqOeahOS4gOerr+W8gOWni+mAkOS4quWwhuiusOW9leeahOWFs+mUruWtl+WSjOe7meWumkvlgLzov5vooYzmr5TovoPvvIzoi6Xmn5DkuKrorrDlvZXnmoTlhbPplK7lrZflkoznu5nlrppL5YC855u4562J77yM5p+l5om+5oiQ5Yqf77yb5ZCm5YiZ77yM6Iul5omr5o+P5a6M5pW05Liq6KGo77yM5LuN54S25rKh5pyJ5om+5Yiw55u45bqU55qE6K6w5b2V77yM5YiZ5p+l5om+5aSx6LSl44CCXHJcblxyXG4gMiAg566X5rOV5YiG5p6QXHJcbiDkuI3lpLHkuIDoiKzmgKfvvIzorr7mn6Xmib7mr4/kuKrorrDlvZXmiJDlip/nmoTmpoLnjofnm7jnrYnvvIzljbNQaT0xL27vvJvmn6Xmib7nrKxp5Liq5YWD57Sg5oiQ5Yqf55qE5q+U6L6D5qyh5pWwQ2k9bi1p77ybXHJcbiDil4Yg5p+l5om+5oiQ5Yqf5pe255qE5bmz5Z2H5p+l5om+6ZW/5bqmQVNM77yaKG4rMSkvMlxyXG4g4peGIOWMheWQq+afpeaJvuS4jeaIkOWKn+aXtu+8muafpeaJvuWksei0peeahOavlOi+g+asoeaVsOS4um7vvIzoi6XmiJDlip/kuI7kuI3miJDlip/nmoTmpoLnjofnm7jnrYnvvIzlr7nmr4/kuKrorrDlvZXnmoTmn6Xmib7mpoLnjofkuLpQaT0xLygybinvvIzliJnlubPlnYfmn6Xmib7plb/luqZBU0zvvJoz77yIbisx77yJLzRcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXF1ZW50aWFsU2VhcmNoKHNUYWJsZSwga2V5KSB7XHJcbiAgICBmb3IgKHZhciBpID0gc1RhYmxlLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiBzVGFibGVbaV0gIT09IGtleTsgLS1pKTtcclxuICAgIHJldHVybiBpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhzZXF1ZW50aWFsU2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgNikpOyAgLy8gLTFcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL3NlcXVlbnRpYWxTZWFyY2guanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS8yLzE4LlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IHF1aWNrU29ydCB9IGZyb20gJy4uL2V4Y2hhbmdlL2luZGV4JztcclxuXHJcbi8qXHJcbiDorqHmlbDmjpLluo9cclxuXHJcbiDorqHmlbDmjpLluo/vvIhDb3VudGluZyBzb3J077yJ5piv5LiA56eN56iz5a6a55qE57q/5oCn5pe26Ze05o6S5bqP566X5rOV44CC6K6h5pWw5o6S5bqP5L2/55So5LiA5Liq6aKd5aSW55qE5pWw57uEQ++8jOWFtuS4reesrGnkuKrlhYPntKDmmK/lvoXmjpLluo/mlbDnu4RB5Lit5YC8562J5LqOaeeahOWFg+e0oOeahOS4quaVsOOAgueEtuWQjuagueaNruaVsOe7hEPmnaXlsIZB5Lit55qE5YWD57Sg5o6S5Yiw5q2j56Gu55qE5L2N572u44CCXHJcblxyXG4g6K6h5pWw5o6S5bqP55qE54m55b6BXHJcblxyXG4g5b2T6L6T5YWl55qE5YWD57Sg5pivbuS4qjDliLBr5LmL6Ze055qE5pW05pWw5pe277yM5a6D55qE6L+Q6KGM5pe26Ze05pivzpgobiArIGsp44CC6K6h5pWw5o6S5bqP5LiN5piv5q+U6L6D5o6S5bqP77yM5o6S5bqP55qE6YCf5bqm5b+r5LqO5Lu75L2V5q+U6L6D5o6S5bqP566X5rOV44CCXHJcbiDnlLHkuo7nlKjmnaXorqHmlbDnmoTmlbDnu4RD55qE6ZW/5bqm5Y+W5Yaz5LqO5b6F5o6S5bqP5pWw57uE5Lit5pWw5o2u55qE6IyD5Zu077yI562J5LqO5b6F5o6S5bqP5pWw57uE55qE5pyA5aSn5YC85LiO5pyA5bCP5YC855qE5beu5Yqg5LiKMe+8ie+8jOi/meS9v+W+l+iuoeaVsOaOkuW6j+WvueS6juaVsOaNruiMg+WbtOW+iOWkp+eahOaVsOe7hO+8jOmcgOimgeWkp+mHj+aXtumXtOWSjOWGheWtmOOAguS+i+Wmgu+8muiuoeaVsOaOkuW6j+aYr+eUqOadpeaOkuW6jzDliLAxMDDkuYvpl7TnmoTmlbDlrZfnmoTmnIDlpb3nmoTnrpfms5XvvIzkvYbmmK/lroPkuI3pgILlkIjmjInlrZfmr43pobrluo/mjpLluo/kurrlkI3jgILkvYbmmK/vvIzorqHmlbDmjpLluo/lj6/ku6XnlKjlnKjln7rmlbDmjpLluo/kuK3nmoTnrpfms5XmnaXmjpLluo/mlbDmja7ojIPlm7TlvojlpKfnmoTmlbDnu4TjgIJcclxuIOmAmuS/l+WcsOeQhuino++8jOS+i+WmguaciTEw5Liq5bm06b6E5LiN5ZCM55qE5Lq677yM57uf6K6h5Ye65pyJOOS4quS6uueahOW5tOm+hOavlEHlsI/vvIzpgqNB55qE5bm06b6E5bCx5o6S5Zyo56ysOeS9je+8jOeUqOi/meS4quaWueazleWPr+S7peW+l+WIsOWFtuS7luavj+S4quS6uueahOS9jee9ru+8jOS5n+WwseaOkuWlveS6huW6j+OAguW9k+eEtu+8jOW5tOm+hOaciemHjeWkjeaXtumcgOimgeeJueauiuWkhOeQhu+8iOS/neivgeeos+WumuaAp++8ie+8jOi/meWwseaYr+S4uuS7gOS5iOacgOWQjuimgeWPjeWQkeWhq+WFheebruagh+aVsOe7hO+8jOS7peWPiuWwhuavj+S4quaVsOWtl+eahOe7n+iuoeWHj+WOuzHnmoTljp/lm6DjgILnrpfms5XnmoTmraXpqqTlpoLkuIvvvJpcclxuIDEu5om+5Ye65b6F5o6S5bqP55qE5pWw57uE5Lit5pyA5aSn5ZKM5pyA5bCP55qE5YWD57SgXHJcbiAyLue7n+iuoeaVsOe7hOS4reavj+S4quWAvOS4umnnmoTlhYPntKDlh7rnjrDnmoTmrKHmlbDvvIzlrZjlhaXmlbDnu4RD55qE56ysaemhuVxyXG4gMy7lr7nmiYDmnInnmoTorqHmlbDntK/liqDvvIjku45D5Lit55qE56ys5LiA5Liq5YWD57Sg5byA5aeL77yM5q+P5LiA6aG55ZKM5YmN5LiA6aG555u45Yqg77yJXHJcbiA0LuWPjeWQkeWhq+WFheebruagh+aVsOe7hO+8muWwhuavj+S4quWFg+e0oGnmlL7lnKjmlrDmlbDnu4TnmoTnrKxDKGkp6aG577yM5q+P5pS+5LiA5Liq5YWD57Sg5bCx5bCGQyhpKeWHj+WOuzFcclxuIFxyXG4g566A6KaB5YiG5p6Q77yaXHJcbiAxLuiuoeaVsOaOkuW6j+S7hemAguWQiOS6juWwj+iMg+WbtOeahOaVsOaNrui/m+ihjOaOkuW6j1xyXG4gMi7kuI3og73lr7nmta7ngrnmlbDov5vooYzmjpLluo9cclxuIDMu5pe26Ze05aSN5p2C5bqm5Li6IE8obilcclxuIDQu6K6h5pWw5o6S5bqP5piv56iz5a6a55qE77yI5o6S5bqP5ZCO5YC855u45ZCM55qE5YWD57Sg55u45a+55LqO5Y6f5YWI55qE5L2N572u5piv5LiN5Lya5Y+R55Sf5Y+Y5YyW55qE77yJXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWF4RWxlbShhcnIpe1xyXG4gICAgbGV0IG1heCA9IGFyclswXTtcclxuXHJcbiAgICBmb3IobGV0IGkgPSAxLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpXHJcbiAgICAgICAgaWYobWF4IDwgYXJyW2ldKSBtYXggPSBhcnJbaV07XHJcblxyXG4gICAgcmV0dXJuIG1heDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNxTGlzdCDopoHmjpLluo/nmoTmlbDnu4RcclxuICogQHBhcmFtIHtOdW1iZXJ9IGsg5pWw57uE5Lit5pyA5aSn55qE5YWD57Sg5YC8XHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudFNvcnQoc3FMaXN0ID0gW10sIGsgPSBtYXhFbGVtKHNxTGlzdCkpe1xyXG4gICAgbGV0IGxlbiA9IHNxTGlzdC5sZW5ndGg7XHJcbiAgICBsZXQgYyA9IFtdO1xyXG4gICAgbGV0IGIgPSBbXTtcclxuXHJcbiAgICAvLyDliJ3lp4vljJbovoXliqnmlbDnu4RcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPD0gazsgKytpKSBjW2ldID0gMDtcclxuICAgIC8vIOiuoeaVsOaVsOe7hEHkuK3lgLznrYnkuo5D5pWw57uE5LiL5qCH55qE5Liq5pWwXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIGNbc3FMaXN0W2ldXSsrO1xyXG4gICAgLy8g6K6h5pWw5pWw57uEQeS4reWAvOWwj+S6juetieS6jkPmlbDnu4TkuIvmoIfnmoTkuKrmlbBcclxuICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gazsgKytpKSBjW2ldICs9IGNbaSAtIDFdO1xyXG4gICAgZm9yKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBiW2Nbc3FMaXN0W2ldXSAtIDFdID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIC0tY1tzcUxpc3RbaV1dO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkgc3FMaXN0W2ldID0gYltpXTtcclxufVxyXG5cclxudmFyIGFyciA9IFsxMDAsIDkzLCA5NywgOTIsIDk2LCA5OSwgOTIsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIsIDk1XTtcclxuY291bnRTb3J0KGFyciwgMTAwKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbiDln7rmlbDmjpLluo9cclxuXHJcbiDln7rmlbDmjpLluo/vvIjoi7Hor63vvJpSYWRpeCBzb3J077yJ5piv5LiA56eN6Z2e5q+U6L6D5Z6L5pW05pWw5o6S5bqP566X5rOV77yM5YW25Y6f55CG5piv5bCG5pW05pWw5oyJ5L2N5pWw5YiH5Ymy5oiQ5LiN5ZCM55qE5pWw5a2X77yM54S25ZCO5oyJ5q+P5Liq5L2N5pWw5YiG5Yir5q+U6L6D44CC55Sx5LqO5pW05pWw5Lmf5Y+v5Lul6KGo6L6+5a2X56ym5Liy77yI5q+U5aaC5ZCN5a2X5oiW5pel5pyf77yJ5ZKM54m55a6a5qC85byP55qE5rWu54K55pWw77yM5omA5Lul5Z+65pWw5o6S5bqP5Lmf5LiN5piv5Y+q6IO95L2/55So5LqO5pW05pWw44CC5Z+65pWw5o6S5bqP55qE5Y+R5piO5Y+v5Lul6L+95rqv5YiwMTg4N+W5tOi1q+WwlOabvMK35L2V5LmQ56S85Zyo5omT5a2U5Y2h54mH5Yi26KGo5py677yIVGFidWxhdGlvbiBNYWNoaW5l77yJ5LiK55qE6LSh54yu44CCXHJcbiDlroPmmK/ov5nmoLflrp7njrDnmoTvvJrlsIbmiYDmnInlvoXmr5TovoPmlbDlgLzvvIjmraPmlbTmlbDvvInnu5/kuIDkuLrlkIzmoLfnmoTmlbDkvY3plb/luqbvvIzmlbDkvY3ovoPnn63nmoTmlbDliY3pnaLooaXpm7bjgILnhLblkI7vvIzku47mnIDkvY7kvY3lvIDlp4vvvIzkvp3mrKHov5vooYzkuIDmrKHmjpLluo/jgILov5nmoLfku47mnIDkvY7kvY3mjpLluo/kuIDnm7TliLDmnIDpq5jkvY3mjpLluo/lrozmiJDku6XlkI7vvIzmlbDliJflsLHlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcclxuIOWfuuaVsOaOkuW6j+eahOaWueW8j+WPr+S7pemHh+eUqExTRO+8iExlYXN0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInmiJZNU0TvvIhNb3N0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInvvIxMU0TnmoTmjpLluo/mlrnlvI/nlLHplK7lgLznmoTmnIDlj7PovrnlvIDlp4vvvIzogIxNU0TliJnnm7jlj43vvIznlLHplK7lgLznmoTmnIDlt6bovrnlvIDlp4vjgIJcclxuXHJcbiDmlYjnjodcclxuXHJcbiDln7rmlbDmjpLluo/nmoTml7bpl7TlpI3mnYLluqbmmK9PKGvCt24p77yM5YW25LitbuaYr+aOkuW6j+WFg+e0oOS4quaVsO+8jGvmmK/mlbDlrZfkvY3mlbDjgILms6jmhI/ov5nkuI3mmK/or7Tov5nkuKrml7bpl7TlpI3mnYLluqbkuIDlrprkvJjkuo5PKG7Ct2xvZyhuKSnvvIxr55qE5aSn5bCP5Y+W5Yaz5LqO5pWw5a2X5L2N55qE6YCJ5oup77yI5q+U5aaC5q+U54m55L2N5pWw77yJ77yM5ZKM5b6F5o6S5bqP5pWw5o2u5omA5bGe5pWw5o2u57G75Z6L55qE5YWo6ZuG55qE5aSn5bCP77yba+WGs+WumuS6hui/m+ihjOWkmuWwkei9ruWkhOeQhu+8jOiAjG7mmK/mr4/ova7lpITnkIbnmoTmk43kvZzmlbDnm67jgIJcclxuIOS7peaOkuW6j27kuKrkuI3lkIzmlbTmlbDmnaXkuL7kvovvvIzlgYflrprov5nkupvmlbTmlbDku6VC5Li65bqV77yM6L+Z5qC35q+P5L2N5pWw6YO95pyJQuS4quS4jeWQjOeahOaVsOWtl++8jGsgPSBsb2dCKE4p77yMTuaYr+W+heaOkuW6j+aVsOaNruexu+Wei+WFqOmbhueahOWKv+OAguiZveeEtuaciULkuKrkuI3lkIznmoTmlbDlrZfvvIzpnIDopoFC5Liq5LiN5ZCM55qE5qG277yM5L2G5Zyo5q+P5LiA6L2u5aSE55CG5Lit77yM5Yik5pat5q+P5Liq5b6F5o6S5bqP5pWw5o2u6aG55Y+q6ZyA6KaB5LiA5qyh6K6h566X56Gu5a6a5a+55bqU5pWw5L2N55qE5YC877yM5Zug5q2k5Zyo5q+P5LiA6L2u5aSE55CG55qE5pe25YCZ6YO96ZyA6KaB5bmz5Z2HbuasoeaTjeS9nOadpeaKiuaVtOaVsOaUvuWIsOWQiOmAgueahOahtuS4reWOu++8jOaJgOS7peWwseacie+8mlxyXG4ga+e6puetieS6jmxvZ0IoTilcclxuIOaJgOS7pe+8jOWfuuaVsOaOkuW6j+eahOW5s+Wdh+aXtumXtFTlsLHmmK/vvJpcclxuIFTvvZ49IGxvZ0IoTinCt25cclxuIOWFtuS4reWJjeS4gOmhueaYr+S4gOS4quS4jui+k+WFpeaVsOaNruaXoOWFs+eahOW4uOaVsO+8jOW9k+eEtuivpemhueS4jeS4gOWumuWwj+S6jmxvZ25cclxuIOWmguaenOiAg+iZkeWSjOavlOi+g+aOkuW6j+i/m+ihjOWvueeFp++8jOWfuuaVsOaOkuW6j+eahOW9ouW8j+WkjeadguW6puiZveeEtuS4jeS4gOWumuabtOWwj++8jOS9hueUseS6juS4jei/m+ihjOavlOi+g++8jOWboOatpOWFtuWfuuacrOaTjeS9nOeahOS7o+S7t+i+g+Wwj++8jOiAjOS4lOWcqOmAguW9k+mAieaLqeeahELkuYvkuIvvvIxr5LiA6Iis5LiN5aSn5LqObG9nbu+8jOaJgOS7peWfuuaVsOaOkuW6j+S4gOiIrOimgeW/q+i/h+WfuuS6juavlOi+g+eahOaOkuW6j++8jOavlOWmguW/q+mAn+aOkuW6j+OAglxyXG5cclxuIOWBh+iuvuaIkeS7rOacieS4gOS6m+S6jOWFg+e7hChhLGIp77yM6KaB5a+55a6D5Lus6L+b6KGM5LulYeS4uummluimgeWFs+mUruWtl++8jGLnmoTmrKHopoHlhbPplK7lrZfnmoTmjpLluo/jgILmiJHku6zlj6/ku6XlhYjmiorlroPku6zlhYjmjInnhafpppbopoHlhbPplK7lrZfmjpLluo/vvIzliIbmiJDpppbopoHlhbPplK7lrZfnm7jlkIznmoToi6XlubLloIbjgILnhLblkI7vvIzlnKjmjInnhafmrKHopoHlhbPplK7lgLzliIbliKvlr7nmr4/kuIDloIbov5vooYzljZXni6zmjpLluo/jgILmnIDlkI7lho3miorov5nkupvloIbkuLLov57liLDkuIDotbfvvIzkvb/pppbopoHlhbPplK7lrZfovoPlsI/nmoTkuIDloIbmjpLlnKjkuIrpnaLjgILmjInov5nnp43mlrnlvI/nmoTln7rmlbDmjpLluo/np7DkuLpNU0QoTW9zdCBTaWduaWZpY2FudCBEaWdodCnmjpLluo/jgILnrKzkuoznp43mlrnlvI/mmK/ku47mnIDkvY7mnInmlYjlhbPplK7lrZflvIDlp4vmjpLluo/vvIznp7DkuLpMU0QoTGVhc3QgU2lnbmlmaWNhbnQgRGlnaHQp5o6S5bqP44CC6aaW5YWI5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn5qyh6KaB5YWz6ZSu5a2X5o6S5bqP77yM54S25ZCO5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn6aaW6KaB5YWz6ZSu5a2X5o6S5bqP44CC6KaB5rOo5oSP55qE5piv77yM5L2/55So55qE5o6S5bqP566X5rOV5b+F6aG75piv56iz5a6a55qE77yM5ZCm5YiZ5bCx5Lya5Y+W5raI5YmN5LiA5qyh5o6S5bqP55qE57uT5p6c44CC55Sx5LqO5LiN6ZyA6KaB5YiG5aCG5a+55q+P5aCG5Y2V54us5o6S5bqP77yMTFNE5pa55rOV5b6A5b6A5q+UTVNE566A5Y2V6ICM5byA6ZSA5bCP44CC5LiL5paH5LuL57uN55qE5pa55rOV5YWo6YOo5piv5Z+65LqOTFNE55qE44CCXHJcblxyXG4g5Z+65pWw5o6S5bqP55qE566A5Y2V5o+P6L+w5bCx5piv5bCG5pWw5a2X5ouG5YiG5Li65Liq5L2N5Y2B5L2N55m+5L2N77yM5q+P5Liq5L2N5L6d5qyh5o6S5bqP44CC5Zug5Li66L+Z5a+5566X5rOV56iz5a6a6KaB5rGC6auY77yM5omA5Lul5oiR5Lus5a+55pWw5L2N5o6S5bqP55So5Yiw5LiK5LiA5Liq5o6S5bqP5pa55rOV6K6h5pWw5o6S5bqP44CC5Zug5Li65Z+65pWw5o6S5bqP6KaB57uP6L+HZCAo5pWw5o2u6ZW/5bqmKeasoeaOkuW6j++8jCDmr4/mrKHkvb/nlKjorqHmlbDmjpLluo/vvIwg6K6h5pWw5o6S5bqP55qE5aSN5p2C5bqm5Li6IE9uKSwgIGQg55u45b2T5LqO5bi46YeP5ZKMTuaXoOWFs++8jOaJgOS7peWfuuaVsOaOkuW6j+S5n+aYryBPKG4p44CC5Z+65pWw5o6S5bqP6Jm954S25piv57q/5oCn5aSN5p2C5bqm77yMIOWNs+WvuW7kuKrmlbDlrZflpITnkIbkuoZu5qyh77yM5L2G5piv5q+P5LiA5qyh5Luj5Lu36YO95q+U6L6D6auY77yMIOiAjOS4lOS9v+eUqOiuoeaVsOaOkuW6j+eahOWfuuaVsOaOkuW6j+S4jeiDvei/m+ihjOWOn+WcsOaOkuW6j++8jOmcgOimgeabtOWkmueahOWGheWtmO+8jCDlubbkuJTlv6vpgJ/mjpLluo/lj6/og73mm7Tlpb3lnLDliKnnlKjnoazku7bnmoTnvJPlrZjvvIwg5omA5Lul5q+U6L6D6LW35p2l77yM5YOP5b+r6YCf5o6S5bqP6L+Z5Lqb5Y6f5Zyw5o6S5bqP566X5rOV5pu05Y+v5Y+W44CC5a+55LqO5LiA5Liq5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw77yM5oiR5Lus5Y+v5Lul5oqK5a6D55yL5L2c5LiA5Liq5aSa5YWD57uE77yM5LuO6auY5L2N5Yiw5L2O5L2N5YWz6ZSu5a2X6YeN6KaB56iL5bqm5L6d5qyh6YCS5YeP44CC5Y+v5Lul5L2/55So5Z+65pWw5o6S5bqP5a+55LiA5Lqb5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw5o6S5bqP44CCXHJcbiAqL1xyXG5cclxuLy8g5rGC5pWw5o2u55qE5pyA5aSn5L2N5pWwXHJcbmZ1bmN0aW9uIG1heEJpdChhcnIpe1xyXG4gICAgbGV0IGQgPSAxO1xyXG4gICAgbGV0IHAgPSAxMDtcclxuXHJcbiAgICBmb3IobGV0IGkgPSAwLCBuID0gYXJyLmxlbmd0aDsgaSA8IG47ICsraSl7XHJcbiAgICAgICAgd2hpbGUoYXJyW2ldID49IHApe1xyXG4gICAgICAgICAgICBwICo9IDEwO1xyXG4gICAgICAgICAgICArK2Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmFkaXhTb3J0KGFyciA9IFtdLCBkID0gbWF4Qml0KGFycikpe1xyXG4gICAgbGV0IG4gPSBhcnIubGVuZ3RoO1xyXG4gICAgbGV0IHRlbXAgPSBbXTtcclxuICAgIC8vIOiuoeaVsOWZqFxyXG4gICAgbGV0IGNvdW50ID0gW107XHJcbiAgICBsZXQgcmFkaXggPSAxO1xyXG5cclxuICAgIC8vIOi/m+ihjGTmrKHmjpLluo9cclxuICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gZDsgKytpKXtcclxuICAgICAgICAvLyDmr4/mrKHliIbphY3liY3muIXnqbrorqHmlbDlmahcclxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgMTA7ICsrailcclxuICAgICAgICAgICAgY291bnRbal0gPSAwO1xyXG4gICAgICAgIC8vIOe7n+iuoeavj+S4quahtuS4reeahOiusOW9leaVsFxyXG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBuOyArK2ope1xyXG4gICAgICAgICAgICBsZXQgayA9IE1hdGguZmxvb3IoYXJyW2pdIC8gcmFkaXgpICUgMTA7XHJcbiAgICAgICAgICAgICsrY291bnRba107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaiA9IDE7IGogPCAxMDsgKytqKVxyXG4gICAgICAgICAgICBjb3VudFtqXSArPSBjb3VudFtqIC0gMV07XHJcbiAgICAgICAgLy8g5bCG5omA5pyJ5qG25Lit6K6w5b2V5L6d5qyh5pS26ZuG5YiwdG1w5LitXHJcbiAgICAgICAgZm9yKGxldCBqID0gbiAtIDE7IGogPj0gMDsgLS1qKXtcclxuICAgICAgICAgICAgbGV0IGsgPSBNYXRoLmZsb29yKGFycltqXSAvIHJhZGl4KSAlIDEwO1xyXG4gICAgICAgICAgICB0ZW1wWy0tY291bnRba11dID0gYXJyW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WwhuS4tOaXtuaVsOe7hOeahOWGheWuueWkjeWItuWIsGFycuS4rVxyXG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBuOyArK2opXHJcbiAgICAgICAgICAgIGFycltqXSA9IHRlbXBbal07XHJcblxyXG4gICAgICAgIHJhZGl4ICo9IDEwO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYXJyID0gWzEwMCwgOTMsIDk3LCA5MiwgOTYsIDk5LCA5MiwgODksIDkzLCA5NywgOTAsIDk0LCA5MiwgOTVdO1xyXG5yYWRpeFNvcnQoYXJyLCAxMDApO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDmobbmjpLluo9cclxuXHJcbiDmobbmjpLluo/vvIhCdWNrZXQgc29ydO+8ieaIluaJgOiwk+eahOeuseaOkuW6j++8jOaYr+S4gOS4quaOkuW6j+eul+azle+8jOW3peS9nOeahOWOn+eQhuaYr+WwhuaVsOe7hOWIhuWIsOaciemZkOaVsOmHj+eahOahtuWtkOmHjOOAguavj+S4quahtuWtkOWGjeS4quWIq+aOkuW6j++8iOacieWPr+iDveWGjeS9v+eUqOWIq+eahOaOkuW6j+eul+azleaIluaYr+S7pemAkuW9kuaWueW8j+e7p+e7reS9v+eUqOahtuaOkuW6j+i/m+ihjOaOkuW6j++8ieOAguahtuaOkuW6j+aYr+m4veW3ouaOkuW6j+eahOS4gOenjeW9kue6s+e7k+aenOOAguW9k+imgeiiq+aOkuW6j+eahOaVsOe7hOWGheeahOaVsOWAvOaYr+Wdh+WMgOWIhumFjeeahOaXtuWAme+8jOahtuaOkuW6j+S9v+eUqOe6v+aAp+aXtumXtO+8iM6YKG4p77yJ44CC5L2G5qG25o6S5bqP5bm25LiN5piv5q+U6L6D5o6S5bqP77yM5LuW5LiN5Y+X5YiwTyhuIGxvZyBuKeS4i+mZkOeahOW9seWTjeOAglxyXG5cclxuIOWfuuacrOaAneaDs1xyXG5cclxuIOWBh+iuvuacieS4gOe7hOmVv+W6puS4uk7nmoTlvoXmjpLlhbPplK7lrZfluo/liJdLWzEuLi4ubl3jgILpppblhYjlsIbov5nkuKrluo/liJfliJLliIbmiJBN5Liq55qE5a2Q5Yy66Ze0KOahtikg44CC54S25ZCO5Z+65LqO5p+Q56eN5pig5bCE5Ye95pWwIO+8jOWwhuW+heaOkuW6j+WIl+eahOWFs+mUruWtl2vmmKDlsITliLDnrKxp5Liq5qG25LitKOWNs+ahtuaVsOe7hELnmoTkuIvmoIcgaSkg77yM6YKj5LmI6K+l5YWz6ZSu5a2Xa+WwseS9nOS4ukJbaV3kuK3nmoTlhYPntKAo5q+P5Liq5qG2QltpXemDveaYr+S4gOe7hOWkp+Wwj+S4uk4vTeeahOW6j+WIlynjgILmjqXnnYDlr7nmr4/kuKrmobZCW2ld5Lit55qE5omA5pyJ5YWD57Sg6L+b6KGM5q+U6L6D5o6S5bqPKOWPr+S7peS9v+eUqOW/q+aOkinjgILnhLblkI7kvp3mrKHmnprkuL7ovpPlh7pCWzBdLi4uLkJbTV3kuK3nmoTlhajpg6jlhoXlrrnljbPmmK/kuIDkuKrmnInluo/luo/liJfjgIJcclxuIOWBh+WmguW+heaOkuW6j+WIl0s9IHs0OeOAgSAzOCDjgIEgMzXjgIEgOTcg44CBIDc244CBIDczIOOAgSAyN+OAgSA0OSB944CC6L+Z5Lqb5pWw5o2u5YWo6YOo5ZyoMeKAlDEwMOS5i+mXtOOAguWboOatpOaIkeS7rOWumuWItjEw5Liq5qG277yM54S25ZCO56Gu5a6a5pig5bCE5Ye95pWwZihrKT1rLzEw44CC5YiZ56ys5LiA5Liq5YWz6ZSu5a2XNDnlsIblrprkvY3liLDnrKw05Liq5qG25LitKDQ5LzEwPTQp44CC5L6d5qyh5bCG5omA5pyJ5YWz6ZSu5a2X5YWo6YOo5aCG5YWl5qG25Lit77yM5bm25Zyo5q+P5Liq6Z2e56m655qE5qG25Lit6L+b6KGM5b+r6YCf5o6S5bqP44CCXHJcblxyXG4g5YiG5p6QXHJcblxyXG4g5qG25o6S5bqP5Yip55So5Ye95pWw55qE5pig5bCE5YWz57O777yM5YeP5bCR5LqG5Yeg5LmO5omA5pyJ55qE5q+U6L6D5bel5L2c44CC5a6e6ZmF5LiK77yM5qG25o6S5bqP55qEZihrKeWAvOeahOiuoeeul++8jOWFtuS9nOeUqOWwseebuOW9k+S6juW/q+aOkuS4reWIkuWIhu+8jOW3sue7j+aKiuWkp+mHj+aVsOaNruWIhuWJsuaIkOS6huWfuuacrOacieW6j+eahOaVsOaNruWdlyjmobYp44CC54S25ZCO5Y+q6ZyA6KaB5a+55qG25Lit55qE5bCR6YeP5pWw5o2u5YGa5YWI6L+b55qE5q+U6L6D5o6S5bqP5Y2z5Y+v44CCXHJcbiDlr7lO5Liq5YWz6ZSu5a2X6L+b6KGM5qG25o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5YiG5Li65Lik5Liq6YOo5YiG77yaXHJcbiAgICAgKDEpIOW+queOr+iuoeeul+avj+S4quWFs+mUruWtl+eahOahtuaYoOWwhOWHveaVsO+8jOi/meS4quaXtumXtOWkjeadguW6puaYr08oTinjgIJcclxuICAgICAoMikg5Yip55So5YWI6L+b55qE5q+U6L6D5o6S5bqP566X5rOV5a+55q+P5Liq5qG25YaF55qE5omA5pyJ5pWw5o2u6L+b6KGM5o6S5bqP77yM5YW25pe26Ze05aSN5p2C5bqm5Li6IOKIkSBPKE5pKmxvZ05pKSDjgILlhbbkuK1OaSDkuLrnrKxp5Liq5qG255qE5pWw5o2u6YeP44CCXHJcbiDlvojmmL7nhLbvvIznrKwoMinpg6jliIbmmK/mobbmjpLluo/mgKfog73lpb3lnY/nmoTlhrPlrprlm6DntKDjgILlsL3ph4/lh4/lsJHmobblhoXmlbDmja7nmoTmlbDph4/mmK/mj5Dpq5jmlYjnjofnmoTllK/kuIDlip7ms5Uo5Zug5Li65Z+65LqO5q+U6L6D5o6S5bqP55qE5pyA5aW95bmz5Z2H5pe26Ze05aSN5p2C5bqm5Y+q6IO96L6+5YiwTyhOKmxvZ04p5LqGKeOAguWboOatpO+8jOaIkeS7rOmcgOimgeWwvemHj+WBmuWIsOS4i+mdouS4pOeCue+8mlxyXG4gICAgICgxKSDmmKDlsITlh73mlbBmKGsp6IO95aSf5bCGTuS4quaVsOaNruW5s+Wdh+eahOWIhumFjeWIsE3kuKrmobbkuK3vvIzov5nmoLfmr4/kuKrmobblsLHmnIlbTi9NXeS4quaVsOaNrumHj+OAglxyXG4gICAgICgyKSDlsL3ph4/nmoTlop7lpKfmobbnmoTmlbDph4/jgILmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rog73lvpfliLDkuIDkuKrmlbDmja7vvIzov5nmoLflsLHlrozlhajpgb/lvIDkuobmobblhoXmlbDmja7nmoTigJzmr5TovoPigJ3mjpLluo/mk43kvZzjgIIg5b2T54S277yM5YGa5Yiw6L+Z5LiA54K55b6I5LiN5a655piT77yM5pWw5o2u6YeP5beo5aSn55qE5oOF5Ya15LiL77yMZihrKeWHveaVsOS8muS9v+W+l+ahtumbhuWQiOeahOaVsOmHj+W3qOWkp++8jOepuumXtOa1qui0ueS4pemHjeOAgui/meWwseaYr+S4gOS4quaXtumXtOS7o+S7t+WSjOepuumXtOS7o+S7t+eahOadg+ihoemXrumimOS6huOAglxyXG5cclxuIOWvueS6jk7kuKrlvoXmjpLmlbDmja7vvIxN5Liq5qG277yM5bmz5Z2H5q+P5Liq5qG2W04vTV3kuKrmlbDmja7nmoTmobbmjpLluo/lubPlnYfml7bpl7TlpI3mnYLluqbkuLrvvJpcclxuIE8oTikrTyhNKihOL00pKmxvZyhOL00pKT1PKE4rTioobG9nTi1sb2dNKSk9TyhOK04qbG9nTi1OKmxvZ00pXHJcbiDlvZNOPU3ml7bvvIzljbPmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rmnInkuIDkuKrmlbDmja7ml7bjgILmobbmjpLluo/nmoTmnIDlpb3mlYjnjofog73lpJ/ovr7liLBPKE4p44CCXHJcblxyXG4g5oC757uT77yaIOahtuaOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puS4uue6v+aAp+eahE8oTitDKe+8jOWFtuS4rUM9TioobG9nTi1sb2dNKeOAguWmguaenOebuOWvueS6juWQjOagt+eahE7vvIzmobbmlbDph49N6LaK5aSn77yM5YW25pWI546H6LaK6auY77yM5pyA5aW955qE5pe26Ze05aSN5p2C5bqm6L6+5YiwTyhOKeOAgiDlvZPnhLbmobbmjpLluo/nmoTnqbrpl7TlpI3mnYLluqYg5Li6TyhOK00p77yM5aaC5p6c6L6T5YWl5pWw5o2u6Z2e5bi45bqe5aSn77yM6ICM5qG255qE5pWw6YeP5Lmf6Z2e5bi45aSa77yM5YiZ56m66Ze05Luj5Lu35peg55aR5piv5piC6LS155qE44CC5q2k5aSW77yM5qG25o6S5bqP5piv56iz5a6a55qE44CCXHJcbiAqL1xyXG5cclxuY29uc3QgQlVDS0VUU05VTSA9IDEwO1xyXG5cclxuZnVuY3Rpb24gYnVja2V0U29ydChzcUxpc3Qpe1xyXG4gICAgbGV0ICBuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIGxldCBidWNrZXRBID0gW107XHJcbiAgICBsZXQgYiA9IFtdO1xyXG5cclxuICAgIC8vIOWIneWni+WMluahtlxyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSl7XHJcbiAgICAgICAgYltpXSA9IFtdO1xyXG4gICAgICAgIGJ1Y2tldEFbaV0gPSAwO1xyXG5cclxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbjsgKytqKVxyXG4gICAgICAgICAgICBiW2ldW2pdID0gSW5maW5pdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g57uZ5qG25aGr6KOF5pWw5o2uXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgKytpKXtcclxuICAgICAgICBsZXQgZGF0YSA9IHNxTGlzdFtpXTtcclxuICAgICAgICAvLyBub3RvOiDov5nph4znmoTmmKDlsITlh73mlbDmmK/pkojlr7kxLTEwMOS5i+mXtOeahOWunuaVsFxyXG4gICAgICAgIGxldCBidWNrZXQgPSBNYXRoLmZsb29yKGRhdGEgLyBCVUNLRVRTTlVNKTtcclxuICAgICAgICBiW2J1Y2tldF1bYnVja2V0QVtidWNrZXRdXSA9IGRhdGE7XHJcbiAgICAgICAgKytidWNrZXRBW2J1Y2tldF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6ZKI5a+55q+P5Liq5qG26L+b6KGM5b+r6YCf5o6S5bqPXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgQlVDS0VUU05VTTsgKytpKXtcclxuICAgICAgICBpZihidWNrZXRBW2ldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHF1aWNrU29ydChiW2ldLCAwLCBidWNrZXRBW2ldIC0gMSk7XHJcbiAgICAgICAgICAgIC8vZm9yKGxldCBqID0gMTsgaiA8IGJ1Y2tldEFbaV07ICsrail7XHJcbiAgICAgICAgICAgIC8vICAgIGxldCBwID0gYltpXVtqXTtcclxuICAgICAgICAgICAgLy8gICAgbGV0IGs7XHJcbiAgICAgICAgICAgIC8vICAgIGZvcihrID0gaiAtIDE7IGsgPj0gMCAmJiBwIDwgYltpXVtrXTsgLS1rKXtcclxuICAgICAgICAgICAgLy8gICAgICAgIGJbaV1bayArIDFdID0gYltpXVtrXTtcclxuICAgICAgICAgICAgLy8gICAgfVxyXG4gICAgICAgICAgICAvLyAgICBiW2ldW2sgKyAxXSA9IHA7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKGIpO1xyXG4gICAgLy9jb25zb2xlLmxvZyhidWNrZXRBKTtcclxuXHJcbiAgICAvLyDlpI3liLblm57ljrtcclxuICAgIGxldCBudW0gPSAwO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSl7XHJcbiAgICAgICAgaWYoYnVja2V0QVtpXSAhPT0gMCkge1xyXG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgYnVja2V0QVtpXTsgKytqKXtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtudW0rK10gPSBiW2ldW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYnVja2V0U29ydCA9IGJ1Y2tldFNvcnQ7XHJcblxyXG52YXIgYXJyID0gWzUxLjIsIDkzLCAxLCA5Mi4yLCA4LCA5OS41LCA5Mi4wLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLjEsIDk1XTtcclxuYnVja2V0U29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG52YXIgYXJyID0gWzUxLjIsIDkzLCAxLCA5Mi4yLCA4LCA5OS41LCA5Mi4wLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLjEsIDk1LCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcclxucXVpY2tTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vKlxyXG4g5oCn6IO95YiG5p6QXHJcbiDlvojmmI7mmL7vvIzln7rmlbDmjpLluo/nmoTmgKfog73mr5TmobbmjpLluo/opoHnlaXlt67jgILmr4/kuIDmrKHlhbPplK7lrZfnmoTmobbliIbphY3pg73pnIDopoFPKE4p55qE5pe26Ze05aSN5p2C5bqm77yM6ICM5LiU5YiG6YWN5LmL5ZCO5b6X5Yiw5paw55qE5YWz6ZSu5a2X5bqP5YiX5Y+I6ZyA6KaBTyhOKeeahOaXtumXtOWkjeadguW6puOAguWBh+WmguW+heaOkuaVsOaNruWPr+S7peWIhuS4umTkuKrlhbPplK7lrZfvvIzliJnln7rmlbDmjpLluo/nmoTml7bpl7TlpI3mnYLluqblsIbmmK9PKGQqMk4pIO+8jOW9k+eEtmTopoHov5zov5zlsI/kuo5O77yM5Zug5q2k5Z+65pys5LiK6L+Y5piv57q/5oCn57qn5Yir55qE44CC5Z+65pWw5o6S5bqP55qE56m66Ze05aSN5p2C5bqm5Li6TyhOK00p77yM5YW25LitTeS4uuahtueahOaVsOmHj+OAguS4gOiIrOadpeivtE4+Pk3vvIzlm6DmraTpop3lpJbnqbrpl7TpnIDopoHlpKfmpoJO5Liq5bem5Y+z44CCXHJcbiDkvYbmmK/vvIzlr7nmr5TmobbmjpLluo/vvIzln7rmlbDmjpLluo/mr4/mrKHpnIDopoHnmoTmobbnmoTmlbDph4/lubbkuI3lpJrjgILogIzkuJTln7rmlbDmjpLluo/lh6DkuY7kuI3pnIDopoHku7vkvZXigJzmr5TovoPigJ3mk43kvZzvvIzogIzmobbmjpLluo/lnKjmobbnm7jlr7novoPlsJHnmoTmg4XlhrXkuIvvvIzmobblhoXlpJrkuKrmlbDmja7lv4Xpobvov5vooYzln7rkuo7mr5TovoPmk43kvZznmoTmjpLluo/jgILlm6DmraTvvIzlnKjlrp7pmYXlupTnlKjkuK3vvIzln7rmlbDmjpLluo/nmoTlupTnlKjojIPlm7Tmm7TliqDlub/ms5vjgIJcclxuICovXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU29ydC9kaXN0cmlidXRpb24vaW5kZXguanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTUvMi8yLlxyXG4gKi9cclxuXHJcbmltcG9ydCBTdGF0aWNMaW5rZWRMaXN0IGZyb20gJy4uLy4uL0xpc3QvU3RhdGljTGlua2VkTGlzdCc7XHJcbmltcG9ydCBkZWZhdWx0Q29tcGFyZSBmcm9tICcuLi9kZWZhdWx0Q29tcGFyaXNpb24nO1xyXG5cclxuLypcclxuIOaPkuWFpeaOkuW6j1xyXG5cclxuIOmHh+eUqOeahOaYr+S7pSDigJznjqnmoaXniYzogIXigJ3nmoTmlrnms5XkuLrln7rnoYDnmoTjgILljbPlnKjogIPlr5/orrDlvZVSaeS5i+WJje+8jOiuvuS7peWJjeeahOaJgOacieiusOW9lVIxLCBSMiAs4oCmLiwgUmktMeW3suaOkuWlveW6j++8jOeEtuWQjuWwhlJp5o+S5YWl5Yiw5bey5o6S5aW95bqP55qE6K+46K6w5b2V55qE6YCC5b2T5L2N572uXHJcblxyXG4g5pyA5Z+65pys55qE5o+S5YWl5o6S5bqP5piv55u05o6l5o+S5YWl5o6S5bqPKFN0cmFpZ2h0IEluc2VydGlvbiBTb3J0KSDjgIJcclxuXHJcblxyXG4g55u05o6l5o+S5YWl5o6S5bqPXHJcblxyXG4gMSAg5o6S5bqP5oCd5oOzXHJcbiDlsIblvoXmjpLluo/nmoTorrDlvZVSae+8jOaPkuWFpeWIsOW3suaOkuWlveW6j+eahOiusOW9leihqFIxLCBSMiAs4oCmLiwgUmktMeS4re+8jOW+l+WIsOS4gOS4quaWsOeahOOAgeiusOW9leaVsOWinuWKoDHnmoTmnInluo/ooajjgIIg55u05Yiw5omA5pyJ55qE6K6w5b2V6YO95o+S5YWl5a6M5Li65q2i44CCXHJcbiDorr7lvoXmjpLluo/nmoTorrDlvZXpobrluo/lrZjmlL7lnKjmlbDnu4RSWzHigKZuXeS4re+8jOWcqOaOkuW6j+eahOafkOS4gOaXtuWIu++8jOWwhuiusOW9leW6j+WIl+WIhuaIkOS4pOmDqOWIhu+8mlxyXG4g4peGIFJbMeKApmktMV3vvJrlt7LmjpLlpb3luo/nmoTmnInluo/pg6jliIbvvJtcclxuIOKXhiBSW2nigKZuXe+8muacquaOkuWlveW6j+eahOaXoOW6j+mDqOWIhuOAglxyXG4g5pi+54S277yM5Zyo5Yia5byA5aeL5o6S5bqP5pe277yMUlsxXeaYr+W3sue7j+aOkuWlveW6j+eahOOAglxyXG5cclxuIDIu566X5rOV5a6e546wXHJcblxyXG4gMy7nrpfms5XliIbmnpBcclxuIOKRtCDmnIDlpb3mg4XlhrXvvJroi6XlvoXmjpLluo/orrDlvZXmjInlhbPplK7lrZfku47lsI/liLDlpKfmjpLliJco5q2j5bqPKe+8jOeul+azleS4reeahOWGheW+queOr+aXoOmhu+aJp+ihjO+8jOWImeS4gOi2n+aOkuW6j+aXtu+8muWFs+mUruWtl+avlOi+g+asoeaVsDHmrKHvvIzorrDlvZXnp7vliqjmrKHmlbAy5qyhKFJbaV3ihpJSWzBdLCBSWzBd4oaSUltqKzFdKeOAglxyXG4g5YiZ5pW05Liq5o6S5bqP55qE5YWz6ZSu5a2X5q+U6L6D5qyh5pWw5ZKM6K6w5b2V56e75Yqo5qyh5pWw5YiG5Yir5piv77yaXHJcbiDmr5TovoPmrKHmlbDvvJpuIC0gMSAgICAgICAgICDnp7vliqjmrKHmlbDvvJogMiAqIChuIC0gMSlcclxuXHJcbiDikbUg5pyA5Z2P5oOF5Ya177ya6Iul5b6F5o6S5bqP6K6w5b2V5oyJ5YWz6ZSu5a2X5LuO5aSn5Yiw5bCP5o6S5YiXKOmAhuW6jynvvIzliJnkuIDotp/mjpLluo/ml7bvvJrnrpfms5XkuK3nmoTlhoXlvqrnjq/kvZPmiafooYxpLTHvvIzlhbPplK7lrZfmr5TovoPmrKHmlbBp5qyh77yM6K6w5b2V56e75Yqo5qyh5pWwaSsx44CCXHJcbiDliJnlsLHmlbTkuKrmjpLluo/ogIzoqIDvvJpcclxuIOavlOi+g+asoeaVsO+8miAobiAtIDEpICogKG4gKyAxKSAvIDIgICAgIOenu+WKqOasoeaVsDogKG4gLSAxKSAqIChuICsgNCkgLyAyXHJcblxyXG4g5LiA6Iis5Zyw77yM6K6k5Li65b6F5o6S5bqP55qE6K6w5b2V5Y+v6IO95Ye6546w55qE5ZCE56eN5o6S5YiX55qE5qaC546H55u45ZCM77yM5YiZ5Y+W5Lul5LiK5Lik56eN5oOF5Ya155qE5bmz5Z2H5YC877yM5L2c5Li65o6S5bqP55qE5YWz6ZSu5a2X5q+U6L6D5qyh5pWw5ZKM6K6w5b2V56e75Yqo5qyh5pWw77yM57qm5Li6bjIvNO+8jOWImeWkjeadguW6puS4uk8objIpIOOAglxyXG5cclxuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmFpZ2h0SW5zZXJ0U29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIC8vIOiuvue9ruWTqOWFtSwg5b2T6K6+572uc3FMaXN0Wy0xXSA9IHNxTGlzdFtpXeaXtu+8jOe7j+a1i+ivleaViOeOh+abtOaFolxyXG4gICAgICAgIC8vIOWboOS4umpz6YeM6Z2i55qE5Y+Y6YeP5L2c55So5Z+f5Zyo5Ye95pWw5YaF55qEXHJcbiAgICAgICAgbGV0IHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgLy8g5p+l5om+5o+S5YWl5L2N572u77yM5bm25bCG6K6w5b2V5ZCO56e7XHJcbiAgICAgICAgbGV0IGogPSBpIC0gMTtcclxuICAgICAgICBmb3IoOyBqID49IDAgJiYgY29tcCh0ZW1wLCBzcUxpc3Rbal0pIDwgMDsgLS1qKVxyXG4gICAgICAgICAgICBzcUxpc3RbaiArIDFdID0gc3FMaXN0W2pdO1xyXG5cclxuICAgICAgICAvLyDmj5LlhaXliLDmraPnoa7kvY3nva5cclxuICAgICAgICBzcUxpc3RbaiArIDFdID0gdGVtcDtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGEgPSBbNywgNCwgLTIsIDE5LCAxMywgNl07XHJcbnN0cmFpZ2h0SW5zZXJ0U29ydChhKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuXHJcblxyXG4vKlxyXG4g5YW25a6D5o+S5YWl5o6S5bqPXHJcblxyXG4gMSAg5oqY5Y2K5o+S5YWl5o6S5bqPXHJcbiDlvZPlsIblvoXmjpLluo/nmoTorrDlvZVSW2ldIOaPkuWFpeWIsOW3suaOkuWlveW6j+eahOiusOW9leWtkOihqFJbMeKApmktMV3kuK3ml7bvvIznlLHkuo5SMSwgUjIgLOKApiwgUmktMeW3suaOkuWlveW6j++8jOWImeafpeaJvuaPkuWFpeS9jee9ruWPr+S7peeUqOKAnOaKmOWNiuafpeaJvuKAneWunueOsO+8jOWImeebtOaOpeaPkuWFpeaOkuW6j+WwseWPmOaIkOS4uuaKmOWNiuaPkuWFpeaOkuW6j+OAglxyXG5cclxuIOS7juaXtumXtOS4iuavlOi+g++8jOaKmOWNiuaPkuWFpeaOkuW6j+S7heS7heWHj+WwkeS6huWFs+mUruWtl+eahOavlOi+g+asoeaVsO+8jOWNtOayoeacieWHj+WwkeiusOW9leeahOenu+WKqOasoeaVsO+8jOaVheaXtumXtOWkjeadguW6puS7jeeEtuS4uk8objIpIOOAglxyXG5cclxuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeUluc2VydFNvcnQoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcclxuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICBsZXQgbG93ID0gMDtcclxuICAgICAgICBsZXQgaGlnaCA9IGkgLSAxO1xyXG5cclxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcclxuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbXAodGVtcCwgc3FMaXN0W21pZF0pIDwgMCkgaGlnaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgICAgIGVsc2UgbG93ID0gbWlkICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSBpIC0gMTsgaiA+PSBoaWdoICsgMTsgLS1qKSB7XHJcbiAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSBzcUxpc3Rbal07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcUxpc3RbaGlnaCArIDFdID0gdGVtcDtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGIgPSBbMzAsIDEzLCA3MCwgODUsIDM5LCA0MiwgNiwgMjBdO1xyXG5iaW5hcnlJbnNlcnRTb3J0KGIpO1xyXG5jb25zb2xlLmxvZyhiICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbiAyLei3r+aPkuWFpeaOkuW6j1xyXG5cclxuIOaYr+WvueaKmOWNiuaPkuWFpeaOkuW6j+eahOaUuei/m++8jOS7peWHj+WwkeaOkuW6j+i/h+eoi+S4reenu+WKqOiusOW9leeahOasoeaVsOOAgumZhOWKoG7kuKrorrDlvZXnmoTovoXliqnnqbrpl7TvvIzmlrnms5XmmK/vvJpcclxuIOKRoCAg5Y+m6K6+5LiA5Liq5pWw57uEZO+8jExbMV3otYvnu5lkWzFd77yM5bCGZFsxXeeci+aIkOaYr+aOkuWlveW6j+eahOW6j+WIl+S4reS4remXtOS9jee9rueahOiusOW9le+8m1xyXG4g4pGhICDliIbliKvlsIZMWyBd5Lit55qE56ysaeS4quiusOW9leS+neasoeaPkuWFpeWIsGRbMV3kuYvliY3miJbkuYvlkI7nmoTmnInluo/luo/liJfkuK3vvIzlhbfkvZPmlrnms5XvvJpcclxuIOKXhiAgTFtpXS5rZXk8ZFsxXS5rZXnvvJogTFtpXeaPkuWFpeWIsGRbMV3kuYvliY3nmoTmnInluo/ooajkuK3vvJtcclxuIOKXhiBMW2ldLmtleeKJpWRbMV0ua2V577yaIExbaV3mj5LlhaXliLBkWzFd5LmL5ZCO55qE5pyJ5bqP6KGo5Lit77ybXHJcbiDlhbPplK7ngrnvvJrlrp7njrDml7blsIblkJHph49k55yL5oiQ5piv5b6q546v5ZCR6YeP77yM5bm26K6+5Lik5Liq5oyH6ZKIZmlyc3TlkoxmaW5hbOWIhuWIq+aMh+ekuuaOkuW6j+i/h+eoi+S4reW+l+WIsOeahOacieW6j+W6j+WIl+S4reeahOesrOS4gOS4quWSjOacgOWQjuS4gOS4quiusOW9leOAglxyXG5cclxuIOWcqDIt6Lev5o+S5YWl5o6S5bqP5Lit77yM56e75Yqo6K6w5b2V55qE5qyh5pWw57qm5Li6bjIvOCDjgILkvYblvZNMWzFd5piv5b6F5o6S5bqP6K6w5b2V5Lit5YWz6ZSu5a2X5pyA5aSn5oiW5pyA5bCP55qE6K6w5b2V5pe277yMMi3ot6/mj5LlhaXmjpLluo/lsLHlrozlhajlpLHljrvkuobkvJjotormgKfjgIJcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGF0aDJJbnNlcnRTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XHJcbiAgICBsZXQgZCA9IFtzcUxpc3RbMF1dO1xyXG4gICAgLy8gZmlyc3TjgIFmaW5hbOWIhuWIq+aMh+ekumTkuK3mjpLlpb3luo/nmoTorrDlvZXnmoTnrKwx5Liq5ZKM5pyA5ZCOMeS4quiusOW9leeahOS9jee9ruOAglxyXG4gICAgbGV0IGZpcnN0ID0gMDtcclxuICAgIGxldCBmaW5hbCA9IDA7XHJcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBzcUxpc3RbaV07XHJcblxyXG4gICAgICAgIC8vIOW+heaPkuWFpeiusOW9leWwj+S6jmTkuK3mnIDlsI/lgLzvvIzmj5LlhaXliLBkW2ZpcnN0XeS5i+WJje+8iOS4jemcgOenu+WKqGTmlbDnu4TnmoTlhYPntKDvvInjgIJcclxuICAgICAgICBpZiAoY29tcChpdGVtLCBkW2ZpcnN0XSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGZpcnN0ID0gKGZpcnN0IC0gMSkgJSBsZW47XHJcbiAgICAgICAgICAgIGRbZmlyc3RdID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5b6F5o+S5YWl6K6w5b2V5aSn5LqOZOS4reacgOWwj+WAvO+8jOaPkuWFpeWIsGRbZmluYWxd5LmL5ZCO77yI5LiN6ZyA56e75YqoZOaVsOe7hOeahOWFg+e0oO+8ieOAglxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXAoaXRlbSwgZFtmaW5hbF0pID4gMCkge1xyXG4gICAgICAgICAgICBkWysrZmluYWxdID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5b6F5o+S5YWl6K6w5b2V5aSn5LqOZOS4reacgOWwj+WAvO+8jOWwj+S6jmTkuK3mnIDlpKflgLzvvIzmj5LlhaXliLBk55qE5Lit6Ze077yI6ZyA6KaB56e75YqoZOaVsOe7hOeahOWFg+e0oO+8ieOAglxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDnp7vliqhk5bC+6YOo5YWD57Sg5Lul5L6/5oyJ5bqP5o+S5YWl6K6w5b2V44CCXHJcbiAgICAgICAgICAgIGxldCBqID0gZmluYWwrKztcclxuICAgICAgICAgICAgd2hpbGUgKGNvbXAoaXRlbSwgZFtqXSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkWyhqICsgMSkgJSBsZW5dID0gZFtqXTtcclxuICAgICAgICAgICAgICAgIGogPSAoaiAtIDEpICUgbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRbKGogKyAxKSAlIGxlbl0gPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDlvqrnjq/miopk6LWL57uZc3FMaXN0XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgc3FMaXN0W2ldID0gZFsoaSArIGZpcnN0KSAlIGxlbl07XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBjID0gWzQ5LCAzOCwgNjUsIDEzLCA5NywgMjcsIDc2LCA1LCAxMDAsIDc4LCAxNSwgMTUsIDIwXTtcclxucGF0aDJJbnNlcnRTb3J0KGMpO1xyXG5jb25zb2xlLmxvZyhjICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbuihqOaPkuWFpeaOkuW6j1xyXG5cclxu5YmN6Z2i55qE5o+S5YWl5o6S5bqP5LiN5Y+v6YG/5YWN5Zyw6KaB56e75Yqo6K6w5b2V77yM6Iul5LiN56e75Yqo6K6w5b2V5bCx6ZyA6KaB5pS55Y+Y5pWw5o2u57uT5p6E44CCXHJcbuWIneWni+WMlu+8muS4i+agh+WAvOS4ujDnmoTliIbph4/kvZzkuLrooajlpLTnu5PngrnvvIzlhbPplK7lrZflj5bkuLrmnIDlpKflgLzvvIzlkITliIbph4/nmoTmjIfpkojlgLzkuLrnqbrvvJtcclxu4pGgICDlsIbpnZnmgIHpk77ooajkuK3mlbDnu4TkuIvmoIflgLzkuLox55qE5YiG6YePKOe7k+eCuSnkuI7ooajlpLTnu5PngrnmnoTmiJDkuIDkuKrlvqrnjq/pk77ooajvvJtcclxu4pGhIGk9MiDvvIzlsIbliIbph49SW2ld5oyJ5YWz6ZSu5a2X6YCS5YeP5o+S5YWl5Yiw5b6q546v6ZO+6KGo77ybXHJcbuKRoiAg5aKe5YqgaSDvvIzph43lpI3ikaHvvIznm7TliLDlhajpg6jliIbph4/mj5LlhaXliLDlvqrnjq/pk77ooajjgIJcclxuXHJcbuWSjOebtOaOpeaPkuWFpeaOkuW6j+ebuOavlO+8jOS4jeWQjOeahOaYr+S/ruaUuTJu5qyh5oyH6ZKI5YC85Lul5Luj5pu/56e75Yqo6K6w5b2V77yM6ICM5YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw55u45ZCM77yM5pWF5pe26Ze05aSN5p2C5bqm5Li6TyhuMinjgIJcclxuXHJcbuihqOaPkuWFpeaOkuW6j+W+l+WIsOS4gOS4quacieW6j+mTvuihqO+8jOWvueWFtuWPr+S7peaWueS+v+WcsOi/m+ihjOmhuuW6j+afpeaJvu+8jOS9huS4jeiDveWunueOsOmaj+acuuafpeaJvuOAguS4uuS6huiDveWunueOsOacieW6j+ihqOeahOaKmOWNiuafpeaJvuagueaNrumcgOimge+8jOWPr+S7peWvueiusOW9lei/m+ihjOmHjeaOki5cclxuXHJcbumHjeaOkuiusOW9leeahOWBmuazleaYr++8mumhuuW6j+aJq+aPj+acieW6j+mTvuihqO+8jOWwhumTvuihqOS4reesrGnkuKrnu5Pngrnnp7vliqjoh7PmlbDnu4TnmoTnrKxp5Liq5YiG6YeP5Lit44CCXHJcblxyXG7kvovlrZDkuK3vvIzpk77ooajkuK3nrKzkuIDkuKrnu5PngrnvvIzljbPlhbPplK7lrZfmnIDlsI/nmoTnu5PngrnmmK/mlbDnu4TkuK3kuIvmoIfkuLo255qE5YiG6YeP77yM5YW25Lit6K6w5b2V5bqU56e76Iez5pWw57uE55qE56ys5LiA5Liq5YiG6YeP77yM5YiZ5bCGbGlzdFsxXeWSjGxpc3RbNl3kupLmjaLvvIzlubbkuLrkuobkuI3kuK3mlq3pnZnmgIHpk77ooajkuK3nmoTpk77vvIzljbPlnKjnu6fnu63pobrpk77ooajmiavmj4/ml7bku43og73mib7liLDkupLmjaLkuYvliY3lnKhsaXN0WzFd5Lit55qE57uT54K577yM5Luk5LqS5o2i5LmL5ZCO55qEbGlzdFsxXeS4reeahOa4uOagh+aUueS4ujZcclxuXHJcbuaOqOW5v+iHs+S4gOiIrOaDheWGte+8jOiLpeesrGnkuKrmnIDlsI/lhbPplK7lrZfnmoTnu5PngrnmmK/mlbDnu4TkuK3kuIvmoIfkuLpw5LiUcCA+IGnnmoTliIbph4/vvIzliJnkupLmjaJsaXN0W2ld5ZKMbGlzdFtwXe+8jOS4lOS7pGxpc3RbaV3kuK3nmoTmuLjmoIfmlLnkuLpw77ybXHJcbueUseS6juatpOaXtuaVsOe7hOS4reaJgOacieWwj+S6jmnnmoTliIbph4/kuK3lt7LmmK/liLDkvY3orrDlvZXvvIzliJnlvZNwPGnml7bvvIzlupTpobrpk77nu6fnu63mn6Xmib7nm7TliLBwPj1p5Li65q2i44CCXHJcbiAqL1xyXG5cclxuXHJcbi8vIOihqOaPkuWFpeaOkuW6j1xyXG5leHBvcnQgZnVuY3Rpb24gc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQoc2xsaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcclxuICAgIC8vIOaehOaIkOW+queOr+mTvuihqFxyXG4gICAgc2xsaXN0WzBdLmN1ciA9IDE7XHJcbiAgICBzbGxpc3RbMV0uY3VyID0gMDtcclxuXHJcbiAgICBsZXQgcCwgcTtcclxuICAgIGZvciAobGV0IGkgPSAyLCBsZW4gPSBzbGxpc3QubGVuZ3RoOyBpIDw9IGxlbjsgKytpKSB7XHJcbiAgICAgICAgcCA9IDA7XHJcbiAgICAgICAgbGV0IHggPSBzbGxpc3RbaV0uZGF0YTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHNsbGlzdFtwXS5jdXIgJiYgY29tcChzbGxpc3Rbc2xsaXN0W3BdLmN1cl0uZGF0YSwgeCkgPCAwKVxyXG4gICAgICAgICAgICBwID0gc2xsaXN0W3BdLmN1cjtcclxuXHJcbiAgICAgICAgLy8g5b2T6YGH5Yiw5aSn5LqO5b2T5YmN5YWz6ZSu5a2X55qE5LiL5qCH5pe277yM5o+S5YWl5Yiw5YW25YmN6amx5ZKM5ZCO57un55qE5Lit6Ze0XHJcbiAgICAgICAgcSA9IHNsbGlzdFtwXS5jdXI7XHJcbiAgICAgICAgc2xsaXN0W3BdLmN1ciA9IGk7XHJcbiAgICAgICAgc2xsaXN0W2ldLmN1ciA9IHE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydCA9IHN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0O1xyXG5cclxuLy8g6YeN5o6S6Z2Z5oCB6ZO+6KGo77yM6Z2Z5oCB6ZO+6KGo5LiL5qCH5bey5o6S5aW95bqPXHJcbmZ1bmN0aW9uIGFycmFuZ2Uoc2xsaXN0KSB7XHJcbiAgICBsZXQgcCA9IHNsbGlzdFswXS5jdXI7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNsbGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIC8vIOesrGnkuKrorrDlvZXlnKhsaXN05Lit55qE5b2T5YmN5L2N572u5bqU5LiN5bCP5LqOaVxyXG4gICAgICAgIC8vIOaJvuWIsOesrGnkuKrorrDlvZXvvIzlubbnlKhw5oyH56S65YW25ZyobGlzdOS4reW9k+WJjeS9jee9rlxyXG4gICAgICAgIHdoaWxlIChwIDwgaSkgcCA9IHNsbGlzdFtwXS5jdXI7XHJcbiAgICAgICAgLy8gceaMh+WQkeWwmuacquiwg+aVtOeahOihqOWwvlxyXG4gICAgICAgIGxldCBxID0gc2xsaXN0W3BdLmN1cjtcclxuXHJcbiAgICAgICAgaWYgKHAgIT09IGkpIHtcclxuICAgICAgICAgICAgLy8g5Lqk5o2i6K6w5b2V77yM5L2/56ysaeS4quiusOW9leWIsOS9jVxyXG4gICAgICAgICAgICBsZXQgdGVtcCA9IHNsbGlzdFtwXTtcclxuICAgICAgICAgICAgc2xsaXN0W3BdID0gc2xsaXN0W2ldO1xyXG4gICAgICAgICAgICBzbGxpc3RbaV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAvLyDmjIflkJHooqvnp7votbDnmoTorrDlvZXvvIzkvb/lvpfku6XlkI7lj6/mnIl3aGlsZeW+queOr+aJvuWIsFxyXG4gICAgICAgICAgICBzbGxpc3RbaV0uY3VyID0gcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHDmjIflkJHlsJrmnKrosIPmlbTnmoTooajlsL5cclxuICAgICAgICBwID0gcTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDUyXTtcclxudmFyIGQgPSBuZXcgU3RhdGljTGlua2VkTGlzdCgpO1xyXG5kLmNyZWF0ZShhcnIpO1xyXG5zdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydChkKTtcclxuY29uc29sZS5sb2coZCk7XHJcbmFycmFuZ2UoZCk7XHJcbmNvbnNvbGUubG9nKGQpO1xyXG5cclxuXHJcbi8qXHJcbuW4jOWwlOaOkuW6j1xyXG5cclxu5biM5bCU5o6S5bqPKFNoZWxsIFNvcnTvvIzlj4jnp7DnvKnlsI/lop7ph4/ms5Up5piv5LiA56eN5YiG57uE5o+S5YWl5o6S5bqP5pa55rOV44CCXHJcblxyXG4xICDmjpLluo/mgJ3mg7Ncclxu4pGgICAg5YWI5Y+W5LiA5Liq5q2j5pW05pWwZDEoZDE8binkvZzkuLrnrKzkuIDkuKrlop7ph4/vvIzlsIblhajpg6hu5Liq6K6w5b2V5YiG5oiQZDHnu4TvvIzmiormiYDmnInnm7jpmpRkMeeahOiusOW9leaUvuWcqOS4gOe7hOS4re+8jOWNs+WvueS6juavj+S4qmsoaz0xLCAyLCAg4oCmIGQxKe+8jFJba10sIFJbZDEra10sIFJbMmQxK2tdICwg4oCm5YiG5Zyo5ZCM5LiA57uE5Lit77yM5Zyo5ZCE57uE5YaF6L+b6KGM55u05o6l5o+S5YWl5o6S5bqP44CC6L+Z5qC35LiA5qyh5YiG57uE5ZKM5o6S5bqP6L+H56iL56ew5Li65LiA6Laf5biM5bCU5o6S5bqP77ybXHJcbuKRoSAgIOWPluaWsOeahOWinumHj2QyPGQx77yM6YeN5aSN4pGg55qE5YiG57uE5ZKM5o6S5bqP5pON5L2c77yb55u06Iez5omA5Y+W55qE5aKe6YePZGk9MeS4uuatou+8jOWNs+aJgOacieiusOW9leaUvui/m+S4gOS4que7hOS4reaOkuW6j+S4uuatouOAglxyXG5cclxuMiAg5o6S5bqP56S65L6LXHJcbuiuvuaciTEw5Liq5b6F5o6S5bqP55qE6K6w5b2V77yM5YWz6ZSu5a2X5YiG5Yir5Li6OSwgMTMsIDgsIDIsIDUsIDEzLCA3LCAxLCAxNSwgMTHvvIzlop7ph4/luo/liJfmmK81LCAzLCAx77yM5biM5bCU5o6S5bqP55qE6L+H56iLOlxyXG7liJ3lp4vlhbPplK7lrZfluo/liJc6ICAgIDkgICAgIDEzICAgICA4ICAgICAgMiAgICAgIDUgICAgICAxMyAgICAgIDcgICAgICAxICAgICAgMTUgICAgICAxMVxyXG7nrKzkuIDotp/mjpLluo/lkI46ICAgICAgOSAgICAgNyAgICAgIDEgICAgICAyICAgICAgNSAgICAgIDEzICAgICAgMTMgICAgIDggICAgICAxNSAgICAgIDExXHJcbuesrOS6jOi2n+aOkuW6j+WQjjogICAgICAyICAgICA1ICAgICAgMSAgICAgIDkgICAgICA3ICAgICAgMTMgICAgICAxMSAgICAgOCAgICAgIDE1ICAgICAgMTNcclxu56ys5LiJ6Laf5o6S5bqP5ZCOOiAgICAgIDEgICAgIDIgICAgICA1ICAgICAgNyAgICAgIDggICAgICA5ICAgICAgMTEgICAgIDEzICAgICAgMTMgICAgICAxNVxyXG5cclxuXHJcbuW4jOWwlOaOkuW6j+eahOWIhuaekOavlOi+g+Wkjeadgu+8jOa2ieWPiuS4gOS6m+aVsOWtpuS4iueahOmXrumimO+8jOWFtuaXtumXtOaYr+aJgOWPlueahOKAnOWinumHj+KAneW6j+WIl+eahOWHveaVsOOAglxyXG5cclxu5biM5bCU5o6S5bqP54m554K5XHJcbuWtkOW6j+WIl+eahOaehOaIkOS4jeaYr+eugOWNleeahOKAnOmAkOauteWIhuWJsuKAne+8jOiAjOaYr+WwhuebuOmalOafkOS4quWinumHj+eahOiusOW9lee7hOaIkOS4gOS4quWtkOW6j+WIl+OAglxyXG7luIzlsJTmjpLluo/lj6/mj5Dpq5jmjpLluo/pgJ/luqbvvIzljp/lm6DmmK/vvJpcclxu4peGIOWIhue7hOWQjm7lgLzlh4/lsI/vvIxuwrLmm7TlsI/vvIzogIxUKG4pPU8obsKyKSzmiYDku6VUKG4p5LuO5oC75L2T5LiK55yL5piv5YeP5bCP5LqG77ybXHJcbuKXhiDlhbPplK7lrZfovoPlsI/nmoTorrDlvZXot7Pot4PlvI/liY3np7vvvIzlnKjov5vooYzmnIDlkI7kuIDotp/lop7ph4/kuLox55qE5o+S5YWl5o6S5bqP5pe277yM5bqP5YiX5bey5Z+65pys5pyJ5bqP44CCXHJcblxyXG7lop7ph4/luo/liJflj5bms5Vcclxu4peGIOaXoOmZpDHku6XlpJbnmoTlhazlm6DlrZDvvJtcclxu4peGIOacgOWQjuS4gOS4quWinumHj+WAvOW/hemhu+S4ujHjgIJcclxuXHJcbuebuOWFs+i1hOaWme+8miBodHRwOi8vd2Vua3UuYmFpZHUuY29tL2xpbms/dXJsPXE3a3pPeFhxYzBCTGFHVVZEWTQzRlFPaDJhWDFVcUJIa2tZZDNWTXdKaEpvNnJ2NFNpVTY4NlJXM2tRQ1NxR0VLeXRsMTJTOGZCT3B3aHEtcnVuaFhfcGJaY2c2QmVELW1pWU1QZ0RoWHhLXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2hlbGxJbnNlcnQoc3FMaXN0LCBkaywgY29tcCkge1xyXG4gICAgZm9yIChsZXQgaSA9IGRrLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICBpZiAoY29tcCh0ZW1wLCBzcUxpc3RbaSAtIGRrXSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gaSAtIGRrO1xyXG4gICAgICAgICAgICBmb3IgKDsgaiA+PSAwICYmIGNvbXAodGVtcCwgc3FMaXN0W2pdKSA8IDA7IGogLT0gZGspXHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIGRrXSA9IHNxTGlzdFtqXTtcclxuXHJcbiAgICAgICAgICAgIHNxTGlzdFtqICsgZGtdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaGVsbFNvcnQoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcclxuICAgIGxldCBkZWx0YSA9IGNyZWF0ZURlbHRhKHNxTGlzdC5sZW5ndGgpO1xyXG4gICAgLy9jb25zb2xlLmxvZyhkZWx0YSk7XHJcbiAgICBmb3IgKGxldCBrID0gMCwgdCA9IGRlbHRhLmxlbmd0aDsgayA8IHQ7ICsraykge1xyXG4gICAgICAgIHNoZWxsSW5zZXJ0KHNxTGlzdCwgZGVsdGFba10sIGNvbXApO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEZWx0YShuKSB7XHJcbiAgICBsZXQgYXJyID0gW107XHJcbiAgICBsZXQgdCA9IChNYXRoLmxvZyhuIC0gMSkgLyBNYXRoLmxvZygyKSkgfCAwOyAgLy8gTWF0aC5sb2cobiAtIDEpIC8gTWF0aC5sb2coMiksIE1hdGgubG9nKG4gKyAxKSAvIE1hdGgubG9nKDIpXHJcbiAgICBmb3IobGV0IGsgPSAwOyBrIDw9IHQ7ICsraylcclxuICAgICAgICBhcnJba10gPSBNYXRoLnBvdygyLCB0IC0gaykgKyAxOyAgICAvLyBNYXRoLnBvdygyLCB0IC0gaSArIDEpIC0gMSwgTWF0aC5wb3coMiwgdCAtIGkpICsgMVxyXG5cclxuICAgIGFyclthcnIubGVuZ3RoXSA9IDE7XHJcblxyXG4gICAgcmV0dXJuIGFycjtcclxufVxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdcXG5cXG5TaGVsbCBTb3J0OicpO1xyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG5zaGVsbFNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvaW5zZXJ0aW9uL2luZGV4LmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMi83LlxyXG4gKi9cclxuaW1wb3J0IExpbmtlZExpc3QgZnJvbSAnLi4vLi4vTGlzdC9MaW5rZWRMaXN0JztcclxuaW1wb3J0IFF1ZXVlIGZyb20gJy4uLy4uL1F1ZXVlL1F1ZXVlJztcclxuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XHJcblxyXG4vKlxyXG4g5b2S5bm25o6S5bqPXHJcblxyXG4g5b2S5bm2KE1lcmdpbmcpIO+8muaYr+aMh+WwhuS4pOS4quaIluS4pOS4quS7peS4iueahOacieW6j+W6j+WIl+WQiOW5tuaIkOS4gOS4quacieW6j+W6j+WIl+OAguiLpemHh+eUqOe6v+aAp+ihqCjml6DorrrmmK/pgqPnp43lrZjlgqjnu5PmnoQp5piT5LqO5a6e546w77yM5YW25pe26Ze05aSN5p2C5bqm5Li6TyhtK24pIOOAglxyXG4g5b2S5bm25oCd5oOz5a6e5L6L77ya5Lik5aCG5omR5YWL54mM77yM6YO95bey5LuO5bCP5Yiw5aSn5o6S5aW95bqP77yM6KaB5bCG5Lik5aCG5ZCI5bm25Li65LiA5aCG5LiU6KaB5rGC5LuO5bCP5Yiw5aSn5o6S5bqP44CCXHJcbiDil4YgIOWwhuS4pOWghuacgOS4iumdoueahOaKveWHuijorr7kuLpDMe+8jEMyKeavlOi+g+Wkp+Wwj++8jOWwhuWwj+iAhee9ruS6juS4gOi+ueS9nOS4uuaWsOeahOS4gOWghijkuI3lpqjorr5DMTxDMinvvJvlho3ku47nrKzkuIDloIbkuK3mir3lh7rkuIDlvKDnu6fnu63kuI5DMui/m+ihjOavlOi+g++8jOWwhui+g+Wwj+eahOaUvue9ruWcqOaWsOWghueahOacgOS4i+mdou+8m1xyXG4g4peGIOmHjeWkjeS4iui/sOi/h+eoi++8jOebtOWIsOafkOS4gOWghuW3suaKveWujO+8jOeEtuWQjuWwhuWJqeS4i+S4gOWghuS4reeahOaJgOacieeJjOi9rOenu+WIsOaWsOWghuS4reOAglxyXG5cclxuIDEgICDmjpLluo/mgJ3mg7NcclxuIOKRoCAg5Yid5aeL5pe277yM5bCG5q+P5Liq6K6w5b2V55yL5oiQ5LiA5Liq5Y2V54us55qE5pyJ5bqP5bqP5YiX77yM5YiZbuS4quW+heaOkuW6j+iusOW9leWwseaYr27kuKrplb/luqbkuLox55qE5pyJ5bqP5a2Q5bqP5YiX77ybXHJcbiDikaEgIOWvueaJgOacieacieW6j+WtkOW6j+WIl+i/m+ihjOS4pOS4pOW9kuW5tu+8jOW+l+WIsO+DqW4vMu+DueS4qumVv+W6puS4ujLmiJYx55qE5pyJ5bqP5a2Q5bqP5YiX4oCU4oCU5LiA6Laf5b2S5bm277ybXHJcbiDikaIgIOmHjeWkjeKRoSDvvIznm7TliLDlvpfliLDplb/luqbkuLpu55qE5pyJ5bqP5bqP5YiX5Li65q2i44CCXHJcblxyXG4g5LiK6L+w5o6S5bqP6L+H56iL5Lit77yM5a2Q5bqP5YiX5oC75piv5Lik5Lik5b2S5bm277yM56ew5Li6Mi3ot6/lvZLlubbmjpLluo/jgILlhbbmoLjlv4PmmK/lpoLkvZXlsIbnm7jpgrvnmoTkuKTkuKrlrZDluo/liJflvZLlubbmiJDkuIDkuKrlrZDluo/liJfjgILorr7nm7jpgrvnmoTkuKTkuKrlrZDluo/liJfliIbliKvkuLrvvJpcclxuIHtSW2tdLCBSW2srMV0sIOKApiwgUlttXX3lkox7UlttKzFdLCBSW20rMl0s4oCmLCBSW2hdfe+8jOWwhuWug+S7rOW9kuW5tuS4uuS4gOS4quacieW6j+eahOWtkOW6j+WIl++8mlxyXG4ge0RSW2xdLCBEUltsKzFdLCDigKYsIERSW21dLCBEUlttKzFdLCDigKYsIERSW2hdIH1cclxuXHJcbiDkvovvvJrorr7mnIk55Liq5b6F5o6S5bqP55qE6K6w5b2V77yM5YWz6ZSu5a2X5YiG5Yir5Li6MjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0Me+8jOW9kuW5tuaOkuW6j+eahOi/h+eoi+OAglxyXG4g5Yid5aeL5YWz6ZSu5a2XOiBbMjNdICAgWzM4XSAgIFsyMl0gICBbNDVdICAgWzIzXSAgIFs2N10gICBbMzFdICAgWzE1XSAgIFs0MV1cclxuICAgICAgICAgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfFxyXG4gICAgICAgICAgICAgIC0tLS0tLS0tICAgICAgLS0tLS0tLS0gICAgICAtLS0tLS0tLSAgICAgIC0tLS0tLS0tXHJcbiDkuIDotp/lvZLlubblkI46IFsyMyAgICAzOF0gICAgWzIyICAgICA0NV0gICAgWzIzICAgICA2N10gICAgWzE1ICAgICAzMV0gICBbNDFdXHJcbiAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tXHJcbiDkuozotp/lvZLlubblkI46IFsyMiAgICAgMjMgICAgICAzOCAgICAgNDVdICAgIFsxNSAgICAgMjMgICAgIDMxICAgICA2N10gICAgWzQxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4g5LiJ6Laf5b2S5bm25ZCOOiBbMTUgICAgIDIyICAgICAgMjMgICAgIDIzICAgICAzMSAgICAgMzggICAgIDQ1ICAgICA2N10gICAgWzQxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuIOWbm+i2n+W9kuW5tuWQjjogWzE1ICAgICAyMiAgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgIDY3XHJcblxyXG5cclxuIDIgIOS4gOi2n+W9kuW5tuaOkuW6j1xyXG4g5LiA6Laf5b2S5bm25o6S5bqP6YO95piv5LuO5YmN5Yiw5ZCO77yM5L6d5qyh5bCG55u46YK755qE5Lik5Liq5pyJ5bqP5a2Q5bqP5YiX5b2S5bm25Li65LiA5Liq77yM5LiU6Zmk5pyA5ZCO5LiA5Liq5a2Q5bqP5YiX5aSW77yM5YW25L2Z5q+P5Liq5a2Q5bqP5YiX55qE6ZW/5bqm6YO955u45ZCM44CC6K6+6L+Z5Lqb5a2Q5bqP5YiX55qE6ZW/5bqm5Li6ZO+8jOWImeS4gOi2n+W9kuW5tuaOkuW6j+eahOi/h+eoi+aYr++8mlxyXG4g5LuOaj0w5byA5aeL77yM5L6d5qyh5bCG55u46YK755qE5Lik5Liq5pyJ5bqP5a2Q5bqP5YiXXHJcbiBSW2rigKZqK2QtMV3lkoxSW2orZOKApmorMmQtMV3ov5vooYzlvZLlubbvvJvmr4/mrKHlvZLlubbkuKTkuKrlrZDluo/liJflkI7vvIxq5ZCO56e75YqoMmTkuKrkvY3nva7vvIzljbNcclxuIGo9aisyZO+8m+iLpeWJqeS4i+eahOWFg+e0oOS4jei2s+S4pOS4quWtkOW6j+WIl+aXtu+8jOWIhuS7peS4i+S4pOenjeaDheWGteWkhOeQhu+8mlxyXG4g4pGgICDliankuIvnmoTlhYPntKDkuKrmlbA+ZO+8muWGjeiwg+eUqOS4gOasoeS4iui/sOi/h+eoi++8jOWwhuS4gOS4qumVv+W6puS4umTnmoTlrZDluo/liJflkozkuI3otrNk55qE5a2Q5bqP5YiX6L+b6KGM5b2S5bm277ybXHJcbiDikaEgIOWJqeS4i+eahOWFg+e0oOS4quaVsOKJpGTvvJrlsIbliankuIvnmoTlhYPntKDkvp3mrKHlpI3liLbliLDlvZLlubblkI7nmoTluo/liJfkuK3jgIJcclxuXHJcblxyXG4gMy7nrpfms5XliIbmnpBcclxu5YW35pyJbuS4quW+heaOkuW6j+iusOW9leeahOW9kuW5tuasoeaVsOaYr+OPkjJu77yM6ICM5LiA6Laf5b2S5bm255qE5pe26Ze05aSN5p2C5bqm5Li6TyhuKe+8jOWImeaVtOS4quW9kuW5tuaOkuW6j+eahOaXtumXtOWkjeadguW6puaXoOiuuuaYr+acgOWlvei/mOaYr+acgOWdj+aDheWGteWdh+S4uk8obuOPkjJuKeOAguWcqOaOkuW6j+i/h+eoi+S4re+8jOS9v+eUqOS6hui+heWKqeWQkemHj0RS77yM5aSn5bCP5LiO5b6F5o6S5bqP6K6w5b2V56m66Ze055u45ZCM77yM5YiZ56m66Ze05aSN5p2C5bqm5Li6TyhuKeOAguW9kuW5tuaOkuW6j+aYr+eos+WumueahOOAglxyXG5cclxuICovXHJcblxyXG5sZXQgbkNvdW50ID0gMDtcclxubGV0IG5vblJlY3Vyc2l2ZUNvdW50ID0gMDtcclxubGV0IHJlY3Vyc2l2ZUNvdW50ID0gMDtcclxuXHJcbi8qKlxyXG4gKiDlsIbmnInluo/nmoRzcltzMS4uZTFd5ZKMc3JbczIuLmUyXeW9kuW5tuS4uuacieW6j+eahHRyW3MxLi5lMl1cclxuICogQHBhcmFtIHNyXHJcbiAqIEBwYXJhbSBzMVxyXG4gKiBAcGFyYW0gZTFcclxuICogQHBhcmFtIGUyXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZShzciwgczEsIGUxLCBlMiwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcclxuICAgIGxldCB0ZW1wID0gW107XHJcbiAgICBsZXQgaSA9IHMxO1xyXG4gICAgbGV0IGogPSBlMSArIDE7XHJcbiAgICBsZXQgayA9IDA7XHJcblxyXG4gICAgd2hpbGUoaSA8PSBlMSAmJiBqIDw9IGUyKXtcclxuICAgICAgICBpZihjb21wKHNyW2ldLCBzcltqXSkgPCAwKSB0ZW1wW2srK10gPSBzcltpKytdO1xyXG4gICAgICAgIGVsc2UgdGVtcFtrKytdID0gc3JbaisrXTtcclxuICAgIH1cclxuICAgIHdoaWxlKGkgPD0gZTEpIHRlbXBbaysrXSA9IHNyW2krK107XHJcbiAgICB3aGlsZShqIDw9IGUyKSB0ZW1wW2srK10gPSBzcltqKytdO1xyXG5cclxuICAgIC8vIOWkjeWItuWbnuWOu1xyXG4gICAgZm9yKGkgPSBzMSwgayA9IDA7IGkgPD0gZTI7ICsraSwgKytrKSBzcltpXSA9IHRlbXBba107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAyLei3r+W9kuW5tuaOkuW6j+mAkuW9kueul+azlVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydFJlY3Vyc2l2ZShzciwgcyA9IDAsIHQgPSBzci5sZW5ndGggLSAxLCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xyXG4gICAgaWYocyA+PSB0KSByZXR1cm47XHJcblxyXG4gICAgLy8g5bCGc3Jbcy4udF3lubPliIbkuLpzcltzLi5tXeWSjHNyW20rMS4udF1cclxuICAgIGxldCBtID0gKHMgKyB0KSA+PiAxO1xyXG4gICAgLy8g6YCS5b2S5Zyw5bCGc3Jbcy4ubV3lvZLlubbkuLrmnInluo/nmoRzcltzLi5tXVxyXG4gICAgbWVyZ2VTb3J0UmVjdXJzaXZlKHNyLCBzLCBtLCBjb21wKTtcclxuICAgIC8vIOmAkuW9kuWcsOWwhnNyW20rMS4udF3lvZLlubbkuLrmnInluo/nmoRzclttKzEuLnRdXHJcbiAgICBtZXJnZVNvcnRSZWN1cnNpdmUoc3IsIG0gKyAxLCB0LCBjb21wKTtcclxuICAgIC8vIOWwhnNyW3MuLm1d5ZKMc3JbbSsxLi50XeW9kuW5tuWIsHNyW3MuLnRdO1xyXG4gICAgbWVyZ2Uoc3IsIHMsIG0sIHQsIGNvbXApO1xyXG59XHJcblxyXG5cclxuY29uc29sZS5sb2coJ1xcblxcbm1lcmdlU29ydFJlY3Vyc2l2ZTonKTtcclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxubWVyZ2VTb3J0UmVjdXJzaXZlKGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydE5vblJlY3Vyc2l2ZShzciwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcclxuICAgIGxldCBqLCBrO1xyXG4gICAgZm9yKGxldCBkID0gMSwgbiA9IHNyLmxlbmd0aCAtIDE7IGQgPCBuOyBkICo9IDIpIHtcclxuICAgICAgICAvLyDkuIDotp/lvZLlubbmjpLluo/nrpfms5VcclxuICAgICAgICBqID0gMDtcclxuXHJcbiAgICAgICAgLy8g5a2Q5bqP5YiX5Lik5Lik5b2S5bm2XHJcbiAgICAgICAgd2hpbGUoKGsgPSAoaiArIDIgKiBkIC0gMSkpIDwgbil7XHJcbiAgICAgICAgICAgIG1lcmdlKHNyLCBqLCAgaiArIGQgLSAxLCBrLCBjb21wKTtcclxuICAgICAgICAgICAgaiA9IGsgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Ymp5L2Z5YWD57Sg5Liq5pWw6LaF6L+H5LiA5Liq5a2Q5bqP5YiX6ZW/5bqmXHJcbiAgICAgICAgaWYoaiArIGQgLSAxIDwgbikgbWVyZ2Uoc3IsIGosIGogKyBkIC0gMSwgbiwgY29tcCk7XHJcbiAgICAgICAgLy8g5Ymp5L2Z5a2Q5bqP5YiX5aSN5Yi2XHJcbiAgICAgICAgZWxzZSBtZXJnZShzciwgaiwgbiwgbiwgY29tcCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCdcXG5tZXJnZVNvcnROb25SZWN1cnNpdmU6Jyk7XHJcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XHJcbm1lcmdlU29ydE5vblJlY3Vyc2l2ZShhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG5cclxuLy8g6Ieq54S25ZCI5bm25o6S5bqPXHJcbi8vIGh0dHA6Ly93d3cuY25ibG9ncy5jb20vbGl1c2hhbmcwNDE5L2FyY2hpdmUvMjAxMS8wOS8xOS8yMTgxNDc2Lmh0bWxcclxuLy8gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9sYW5rZS9hcmNoaXZlLzIwMTMvMDEvMTUvMjg2MDQ4Ny5odG1sXHJcbi8qXHJcbuiHqueEtuW9kuW5tuaYr+W9kuW5tuaOkuW6j+eahOS4gOS4quWPmOW9ou+8jOaViOeOh+abtOmrmOS4gOS6m++8jOWPr+S7peWcqOW9kuW5tuaOkuW6j+mdnumAkuW9kuWunueOsOeahOWfuuehgOS4iui/m+ihjOS/ruaUuS7lr7nkuo7lt7Lnu4/kuIDkuKrlt7Lnu4/nu5nlrprmlbDnu4RhLOmAmuW4uOWtmOWcqOWkmuS4qumVv+W6puWkp+S6jjHnmoTlt7Lnu4/oh6rnhLbmjpLlpb3nmoTlrZDmlbDnu4TmrrUs5Zug5q2k55So5LiA5qyh5a+55pWw57uEYeeahOe6v+aAp+aJq+aPj+WwseWPr+S7peaJvuWHuuaJgOaciei/meS6m+aOkuWlveW6j+eahOWtkOaVsOe7hOautSznhLblkI7lho3lr7nov5nkupvlrZDmlbDnu4TmrrXkv6nkv6nlkIjlubYuXHJcbiAqL1xyXG5cclxuXHJcbi8vIOaJq+aPj+W+l+WIsOWtkOS4sueahOWHveaVsFxyXG5mdW5jdGlvbiBwYXNzKHNxTGlzdCwgcmVjLCBjb21wKXtcclxuICAgIGxldCBudW0gPSAwO1xyXG4gICAgcmVjW251bSsrXSA9IDA7XHJcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHJlY1tudW0rK10gPSBpICsgMTtcclxuICAgIH1cclxuICAgIHJlY1tudW0rK10gPSBsZW47XHJcblxyXG4gICAgcmV0dXJuIG51bTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5hdHVyZU1lcmdlU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSl7XHJcbiAgICBsZXQgcmVjID0gW107XHJcblxyXG4gICAgLy9udW09MuivtOaYjuW3sue7j+aOkuWlveW6j+S6hlxyXG4gICAgLy/mr4/lvqrnjq/kuIDmrKHvvIzov5vooYzkuIDmrKFwYXNzKCnmk43kvZxcclxuICAgIGZvcihsZXQgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCk7IG51bSAhPT0gMjsgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCkpe1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgKyAyIDwgbnVtOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgbWVyZ2Uoc3FMaXN0LCByZWNbaV0sIHJlY1tpICsgMV0gLSAxLCByZWNbaSArIDJdIC0gMSwgY29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zb2xlLmxvZygnXFxubmF0dXJlTWVyZ2VTb3J0OicpO1xyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG5uYXR1cmVNZXJnZVNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xyXG5cclxuXHJcbmNvbnNvbGUubG9nKHJlY3Vyc2l2ZUNvdW50KTtcclxuY29uc29sZS5sb2cobm9uUmVjdXJzaXZlQ291bnQpO1xyXG5jb25zb2xlLmxvZyhuQ291bnQpO1xyXG5cclxuLy8g5Y+M5ZCR6Ieq54S25ZCI5bm25o6S5bqP566X5rOVXHJcbi8qXHJcbuWPjOWQkeiHqueEtuWQiOW5tuaOkuW6j+aYr+agueaNruassuaOkuW6j+aVsOaNruWxgOmDqOS4jeaYr+WNh+W6j+WwseaYr+mZjeW6j+eahOiHqueEtuacieW6j+eJueeCuSzlhYjnur/mgKfmiavmj4/lh7roh6rnhLbmnInluo/nmoTlrZDmlbDnu4TmrrUs5YaN6L+b6KGM5ZCI5bm25o6S5bqPLuaJq+aPj+aXtueahOacieW6j+aVsOautemVv+W6pui2iumVvyzmrrXmlbDotorlsJEs5a+55bqU5ZCI5bm25qCR55qE5bGC5pWw5bCx5Lya6LaK5bCRLOeul+azleeahOaViOeOh+i2iumrmC5cclxuICovXHJcbmV4cG9ydCBsZXQgbmF0dXJhbE1lcmdlU29ydCA9IChmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG5hdHVyYWxNZXJnZVNvcnQ7XHJcblxyXG4gICAgZnVuY3Rpb24gbmF0dXJhbE1lcmdlU29ydChhLCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xyXG4gICAgICAgIGxldCBiID0gW107XHJcbiAgICAgICAgbGV0IG4gPSBhLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSghbWVyZ2VSdW5zKGEsIGIsIG4sIGNvbXApKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVJ1bnMoYSwgYiwgbiwgY29tcCl7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGxldCBrID0gMDtcclxuICAgICAgICBsZXQgYXNjID0gdHJ1ZTtcclxuICAgICAgICBsZXQgeDtcclxuXHJcbiAgICAgICAgd2hpbGUoaSA8IG4pe1xyXG4gICAgICAgICAgICBrID0gaTtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5pyA5ZCO5LiA5Liq6YCS5aKe5bqP5YiX5YWD57SgXHJcbiAgICAgICAgICAgIGRvIHggPSBhW2krK107IHdoaWxlKGkgPCBuICYmIGNvbXAoeCwgYVtpXSkgPD0gMCk7XHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOacgOWQjuS4gOS4qumAkuWHj+W6j+WIl+WFg+e0oFxyXG4gICAgICAgICAgICB3aGlsZShpIDwgbiAmJiBjb21wKHgsIGFbaV0pID49IDApIHggPSBhW2krK107XHJcbiAgICAgICAgICAgIC8vIOW9kuW5tumAkuWinuW6j+WIl+WSjOmAkuWHj+W6j+WIl++8jOe7k+aenOWPr+iDvemAkuWinuaIlumAkuWHj1xyXG4gICAgICAgICAgICBtZXJnZShhLCBiLCBrLCBpIC0gMSwgYXNjLCBjb21wKTtcclxuICAgICAgICAgICAgYXNjID0gIWFzYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOW9k2vnrYnkuo4w5pe25Luj6KGoYeW3sue7j+aOkuWlveW6j+S6hlxyXG4gICAgICAgIHJldHVybiBrID09PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIsIGxvdywgaGlnaCwgYXNjLCBjb21wKXtcclxuICAgICAgICBsZXQgayA9IGFzYyA/IGxvdyA6IGhpZ2g7XHJcbiAgICAgICAgbGV0IGMgPSBhc2MgPyAxIDogLTE7XHJcbiAgICAgICAgbGV0IGkgPSBsb3c7XHJcbiAgICAgICAgbGV0IGogPSBoaWdoO1xyXG5cclxuICAgICAgICB3aGlsZShpIDw9IGope1xyXG4gICAgICAgICAgICBpZihjb21wKGFbaV0sIGFbal0pIDw9IDApIGJba10gPSBhW2krK107XHJcbiAgICAgICAgICAgIGVsc2UgYltrXSA9IGFbai0tXTtcclxuICAgICAgICAgICAgayArPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IoaSA9IGsgPSBsb3csIGogPSBoaWdoOyBpIDw9IGo7ICsraSwgKytrKSBhW2ldID0gYltrXTtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5uYXR1cmFsTWVyZ2VTb3J0OicpO1xyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG5uYXR1cmFsTWVyZ2VTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vLyDpk77ooajlrZjlgqjnu5PmnoTnmoToh6rnhLblkIjlubbmjpLluo9cclxuZXhwb3J0IGxldCBsaW5rZWRMaXN0TmF0dXJhbE1lcmdlU29ydCA9IChmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG1lcmdlU29ydDtcclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQobGlua2VkbGlzdCwgbmVlZFJlcGxhY2UgPSB0cnVlLCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xyXG4gICAgICAgIGlmKCFsaW5rZWRsaXN0KSByZXR1cm4gbGlua2VkbGlzdDtcclxuXHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgbGV0IGxpc3QgPSBsaW5rZWRsaXN0LmhlYWQ7XHJcblxyXG4gICAgICAgIGlmKCFsaXN0IHx8ICFsaXN0Lm5leHQpIHJldHVybiBsaW5rZWRsaXN0O1xyXG5cclxuICAgICAgICBsZXQgdSA9IGxpc3Q7XHJcbiAgICAgICAgbGV0IHQgPSBsaXN0O1xyXG4gICAgICAgIGxldCB2O1xyXG4gICAgICAgIC8vIOWwhumAkuWinueahOe7k+eCueaUvuWFpeWIsOmYn+WIl+S4re+8iOS8muiiq+WIh+aWre+8iVxyXG4gICAgICAgIGZvcig7IHQ7IHQgPSB1KXtcclxuICAgICAgICAgICAgd2hpbGUodSAmJiB1Lm5leHQgJiYgY29tcCh1LmRhdGEsIHUubmV4dC5kYXRhKSA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdSA9IHUubmV4dDtcclxuICAgICAgICAgICAgdiA9IHU7XHJcbiAgICAgICAgICAgIHUgPSB1Lm5leHQ7XHJcbiAgICAgICAgICAgIHYubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgIC8vIOWQiOW5tue7k+eCuVxyXG4gICAgICAgIHdoaWxlKHF1ZXVlLnNpemUpe1xyXG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHQpO1xyXG4gICAgICAgICAgICBsZXQgYSA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAgICAgbGV0IGIgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHQgPSBtZXJnZShhLCBiLCBjb21wKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG5lZWRSZXBsYWNlKSBsaW5rZWRsaXN0LmhlYWQgPSB0O1xyXG5cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiLCBjb21wKXtcclxuICAgICAgICBsZXQgYyA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbiAgICAgICAgbGV0IGhlYWQgPSB7ZGF0YTogbnVsbCwgbmV4dDogbnVsbH07XHJcbiAgICAgICAgYy5oZWFkID0gaGVhZDtcclxuICAgICAgICBjID0gYy5oZWFkO1xyXG5cclxuICAgICAgICB3aGlsZShhICYmIGIpe1xyXG4gICAgICAgICAgICBpZihjb21wKGEuZGF0YSwgYi5kYXRhKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGMubmV4dCA9IGE7XHJcbiAgICAgICAgICAgICAgICBjID0gYTtcclxuICAgICAgICAgICAgICAgIGEgPSBhLm5leHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjLm5leHQgPSBiO1xyXG4gICAgICAgICAgICAgICAgYyA9IGI7XHJcbiAgICAgICAgICAgICAgICBiID0gYi5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLm5leHQgPSBhID8gYSA6IGI7XHJcblxyXG4gICAgICAgIHJldHVybiBoZWFkLm5leHQ7XHJcbiAgICB9XHJcbn0pKCk7XHJcblxyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG52YXIgbGlua2VkTGlzdCA9IG5ldyBMaW5rZWRMaXN0KGFycik7XHJcbmxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0KGxpbmtlZExpc3QpO1xyXG5jb25zb2xlLmxvZyhsaW5rZWRMaXN0ICsgJycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvbWVyZ2luZy9pbmRleC5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGx1a2Ugb24gMjAxNS8yLzIuXHJcbiAqL1xyXG5cclxuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XHJcblxyXG4vKlxyXG7pgInmi6nmjpLluo9cclxuXHJcbumAieaLqeaOkuW6jyhTZWxlY3Rpb24gU29ydCnnmoTln7rmnKzmgJ3mg7PmmK/vvJrmr4/mrKHku47lvZPliY3lvoXmjpLluo/nmoTorrDlvZXkuK3pgInlj5blhbPplK7lrZfmnIDlsI/nmoTorrDlvZXooajvvIznhLblkI7kuI7lvoXmjpLluo/nmoTorrDlvZXluo/liJfkuK3nmoTnrKzkuIDkuKrorrDlvZXov5vooYzkuqTmjaLvvIznm7TliLDmlbTkuKrorrDlvZXluo/liJfmnInluo/kuLrmraLjgIJcclxuXHJcblxyXG7nroDljZXpgInmi6nmjpLluo9cclxuXHJcbueugOWNlemAieaLqeaOkuW6jyhTaW1wbGUgU2VsZWN0aW9uIFNvcnQg77yM5Y+I56ew5Li655u05o6l6YCJ5oup5o6S5bqPKeeahOWfuuacrOaTjeS9nOaYr++8mumAmui/h24taeasoeWFs+mUruWtl+mXtOeahOavlOi+g++8jOS7jm4taSsx5Liq6K6w5b2V5Lit6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V77yM54S25ZCO5ZKM56ysaeS4quiusOW9lei/m+ihjOS6pOaNou+8jGk9MSwgMiwg4oCmIG4tMSDjgIJcclxuMSAg5o6S5bqP56S65L6LXHJcbuS+i++8muiuvuacieWFs+mUruWtl+W6j+WIl+S4uu+8mjcsIDQsIC0yLCAxOSwgMTMsIDbvvIznm7TmjqXpgInmi6nmjpLluo/nmoTov4fnqIvvvJpcclxu5Yid5aeL6K6w5b2V55qE5YWz6ZSu5a2X77yaICA3ICAgICA0ICAgIC0yICAgICAxOSAgICAxMyAgICA2XHJcbiAgICDnrKzkuIDotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA3ICAgICAxOSAgICAxMyAgICA2XHJcbiAgICDnrKzkuozotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA3ICAgICAxOSAgICAxMyAgICA2XHJcbiAgICDnrKzkuInotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICAxOSAgICAxMyAgICA3XHJcbiAgICDnrKzlm5votp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICA3ICAgICAxMyAgICAxOVxyXG4gICAg56ys5LqU6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgNyAgICAgMTMgICAgMTlcclxuICAgIOesrOWFrei2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDcgICAgIDEzICAgIDE5XHJcblxyXG4yLueul+azleWIhuaekFxyXG7mlbTkuKrnrpfms5XmmK/kuozph43lvqrnjq/vvJrlpJblvqrnjq/mjqfliLbmjpLluo/nmoTotp/mlbDvvIzlr7lu5Liq6K6w5b2V6L+b6KGM5o6S5bqP55qE6Laf5pWw5Li6bi0x6Laf77yb5YaF5b6q546v5o6n5Yi25q+P5LiA6Laf55qE5o6S5bqP44CCXHJcbui/m+ihjOesrGnotp/mjpLluo/ml7bvvIzlhbPplK7lrZfnmoTmr5TovoPmrKHmlbDkuLpuLWnvvIzliJnvvJpcclxu5q+U6L6D5qyh5pWw77yaIG4qKG4gLSAxKSAvIDJcclxu5pe26Ze05aSN5p2C5bqm5piv77yaVChuKT1PKG4yKVxyXG7nqbrpl7TlpI3mnYLluqbmmK/vvJpTKG4pPU8oMSlcclxu5LuO5o6S5bqP55qE56iz5a6a5oCn5p2l55yL77yM55u05o6l6YCJ5oup5o6S5bqP5piv5LiN56iz5a6a55qE44CCXHJcblxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxlU2VsZWN0aW9uU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIGxldCBrID0gaTtcclxuICAgICAgICBmb3IgKGxldCBqID0gayArIDE7IGogPCBsZW47ICsrailcclxuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2pdLCBzcUxpc3Rba10pIDwgMCkgayA9IGo7XHJcblxyXG4gICAgICAgIGlmIChrICE9PSBpKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2tdO1xyXG4gICAgICAgICAgICBzcUxpc3Rba10gPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgIHNxTGlzdFtpXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYXJyID0gWzcsIDQsIC0yLCAxOSwgMTMsIDZdO1xyXG5zaW1wbGVTZWxlY3Rpb25Tb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vKlxyXG7moJHlvaLpgInmi6nmjpLluo9cclxuXHJcbummluWFiOWvuW7kuKrorrDlvZXnmoTlhbPplK7lrZfkuKTkuKTov5vooYzmr5TovoPvvIzpgInlj5bvg6luLzLvg7nkuKrovoPlsI/ogIXvvJvnhLblkI7ov5nvg6luLzLvg7nkuKrovoPlsI/ogIXkuKTkuKTov5vooYzmr5TovoPvvIzpgInlj5bvg6luLzTvg7nkuKrovoPlsI/ogIXigKYg5aaC5q2k6YeN5aSN77yM55u05Yiw5Y+q5YmpMeS4quWFs+mUruWtl+S4uuatouOAglxyXG7or6Xov4fnqIvlj6/nlKjkuIDmo7XmnIlu5Liq5Y+25a2Q57uT54K555qE5a6M5YWo5LqM5Y+J5qCR6KGo56S677yM5q+P5Liq5p6d57uT54K555qE5YWz6ZSu5a2X6YO9562J5LqO5YW25bem44CB5Y+z5a2p5a2Q57uT54K55Lit6L6D5bCP55qE5YWz6ZSu5a2X77yM5qC557uT54K555qE5YWz6ZSu5a2X5bCx5piv5pyA5bCP55qE5YWz6ZSu5a2X44CCXHJcbui+k+WHuuacgOWwj+WFs+mUruWtl+WQju+8jOagueaNruWFs+ezu+eahOWPr+S8oOmAkuaAp++8jOassumAieWPluasoeWwj+WFs+mUruWtl++8jOWPqumcgOWwhuWPtuWtkOe7k+eCueS4reeahOacgOWwj+WFs+mUruWtl+aUueS4uuKAnOacgOWkp+WAvOKAnSDvvIznhLblkI7ph43lpI3kuIrov7DmraXpqqTljbPlj6/jgIJcclxu5ZCr5pyJbuS4quWPtuWtkOe7k+eCueeahOWujOWFqOS6jOWPieagkeeahOa3seW6puS4uu+DqeOPkjJu74O5KzHvvIzliJnmgLvnmoTml7bpl7TlpI3mnYLluqbkuLpPKG7jj5Iybikg44CCXHJcblxyXG7kvYbov5nnp43mjpLluo/mlrnms5XlsJrmnInovoXliqnlrZjlgqjnqbrpl7TovoPlpJos5ZKM5pyA5aSn5YC86L+b6KGM5aSa5L2Z5q+U6L6D562J57y654K544CC5Li65LqG5byl6KGl6L+Z5Lqb57y66Zm377yM5Ye6546w5LqG5Y+m5LiA56eN6YCJ5oup5o6S5bqPLS0t5aCG5o6S5bqPXHJcbiAqL1xyXG5cclxuXHJcblxyXG4vKlxyXG7loIbmjpLluo9cclxuXHJcbjEgIOWghueahOWumuS5iVxyXG7mmK9u5Liq5YWD57Sg55qE5bqP5YiXSD17azEsIGsyICwg4oCmIGtufSDvvIzmu6HotrPvvJpcclxuICAgIGtp4omkazJpICAgICAgIOW9kzJp4omkbuaXtlxyXG4gICAga2niiaRrMmkrMSAgIOW9kzJpKzHiiaRu5pe2XHJcblxyXG7nlLHloIbnmoTlrprkuYnnn6XvvIzloIbmmK/kuIDmo7Xku6VrMeS4uuagueeahOWujOWFqOS6jOWPieagkeOAguiLpeWvueivpeS6jOWPieagkeeahOe7k+eCuei/m+ihjOe8luWPtyjku47kuIrliLDkuIvvvIzku47lt6bliLDlj7Mp77yM5b6X5Yiw55qE5bqP5YiX5bCx5piv5bCG5LqM5Y+J5qCR55qE57uT54K55Lul6aG65bqP57uT5p6E5a2Y5pS+77yM5aCG55qE57uT5p6E5q2j5aW95ZKM6K+l5bqP5YiX57uT5p6E5a6M5YWo5LiA6Ie044CCXHJcblxyXG4yICDloIbnmoTmgKfotKhcclxuICAgIDEpICDloIbmmK/kuIDmo7Xph4fnlKjpobrluo/lrZjlgqjnu5PmnoTnmoTlrozlhajkuozlj4nmoJHvvIwgazHmmK/moLnnu5PngrnvvJtcclxuICAgIDIpICDloIbnmoTmoLnnu5PngrnmmK/lhbPplK7lrZfluo/liJfkuK3nmoTmnIDlsI8o5oiW5pyA5aSnKeWAvO+8jOWIhuWIq+ensOS4uuWwjyjmiJblpKcp5qC55aCG77ybXHJcbiAgICAzKSAg5LuO5qC557uT54K55Yiw5q+P5LiA5Y+25a2Q57uT54K56Lev5b6E5LiK55qE5YWD57Sg57uE5oiQ55qE5bqP5YiX6YO95piv5oyJ5YWD57Sg5YC8KOaIluWFs+mUruWtl+WAvCnpnZ7pgJLlh48o5oiW6Z2e6YCS5aKeKeeahO+8m1xyXG4gICAgNCkgIOWghuS4reeahOS7u+S4gOWtkOagkeS5n+aYr+WghuOAglxyXG5cclxu5Yip55So5aCG6aG26K6w5b2V55qE5YWz6ZSu5a2X5YC85pyA5bCPKOaIluacgOWkpynnmoTmgKfotKjvvIzku47lvZPliY3lvoXmjpLluo/nmoTorrDlvZXkuK3kvp3mrKHpgInlj5blhbPplK7lrZfmnIDlsI8o5oiW5pyA5aSnKeeahOiusOW9le+8jOWwseWPr+S7peWunueOsOWvueaVsOaNruiusOW9leeahOaOkuW6j++8jOi/meenjeaOkuW6j+aWueazleensOS4uuWghuaOkuW6j+OAglxyXG5cclxuMyAg5aCG5o6S5bqP5oCd5oOzXHJcblxyXG7ikaAgIOWvueS4gOe7hOW+heaOkuW6j+eahOiusOW9le+8jOaMieWghueahOWumuS5ieW7uueri+Wghu+8m1xyXG7ikaEgIOWwhuWghumhtuiusOW9leWSjOacgOWQjuS4gOS4quiusOW9leS6pOaNouS9jee9ru+8jOWImeWJjW4tMeS4quiusOW9leaYr+aXoOW6j+eahO+8jOiAjOacgOWQjuS4gOS4quiusOW9leaYr+acieW6j+eahO+8m1xyXG7ikaIgIOWghumhtuiusOW9leiiq+S6pOaNouWQju+8jOWJjW4tMeS4quiusOW9leS4jeWGjeaYr+Wghu+8jOmcgOWwhuWJjW4tMeS4quW+heaOkuW6j+iusOW9lemHjeaWsOe7hOe7h+aIkOS4uuS4gOS4quWghu+8jOeEtuWQjuWwhuWghumhtuiusOW9leWSjOWAkuaVsOesrOS6jOS4quiusOW9leS6pOaNouS9jee9ru+8jOWNs+WwhuaVtOS4quW6j+WIl+S4reasoeWwj+WFs+mUruWtl+WAvOeahOiusOW9leiwg+aVtCjmjpLpmaQp5Ye65peg5bqP5Yy677ybXHJcbuKRoyAg6YeN5aSN5LiK6L+w5q2l6aqk77yM55u05Yiw5YWo6YOo6K6w5b2V5o6S5aW95bqP5Li65q2i44CCXHJcblxyXG7nu5PorrrvvJrmjpLluo/ov4fnqIvkuK3vvIzoi6Xph4fnlKjlsI/moLnloIbvvIzmjpLluo/lkI7lvpfliLDnmoTmmK/pnZ7pgJLlh4/luo/liJfvvJvoi6Xph4fnlKjlpKfmoLnloIbvvIzmjpLluo/lkI7lvpfliLDnmoTmmK/pnZ7pgJLlop7luo/liJfjgIJcclxuXHJcbuWghuaOkuW6j+eahOWFs+mUrlxyXG7ikaAgIOWmguS9leeUseS4gOS4quaXoOW6j+W6j+WIl+W7uuaIkOS4gOS4quWghu+8n1xyXG7ikaEgIOWmguS9leWcqOi+k+WHuuWghumhtuWFg+e0oOS5i+WQju+8jOiwg+aVtOWJqeS9meWFg+e0oO+8jOS9v+S5i+aIkOS4uuS4gOS4quaWsOeahOWghu+8n1xyXG5cclxuNCAg5aCG55qE6LCD5pW04oCU4oCU562b6YCJXHJcbuKRtCDloIbnmoTosIPmlbTmgJ3mg7Ncclxu6L6T5Ye65aCG6aG25YWD57Sg5LmL5ZCO77yM5Lul5aCG5Lit5pyA5ZCO5LiA5Liq5YWD57Sg5pu/5Luj5LmL77yb54S25ZCO5bCG5qC557uT54K55YC85LiO5bem44CB5Y+z5a2Q5qCR55qE5qC557uT54K55YC86L+b6KGM5q+U6L6D77yM5bm25LiO5YW25Lit5bCP6ICF6L+b6KGM5Lqk5o2i77yb6YeN5aSN5LiK6L+w5pON5L2c77yM55u05Yiw5piv5Y+25a2Q57uT54K55oiW5YW25YWz6ZSu5a2X5YC85bCP5LqO562J5LqO5bem44CB5Y+z5a2Q5qCR55qE5YWz6ZSu5a2X55qE5YC877yM5bCG5b6X5Yiw5paw55qE5aCG44CC56ew6L+Z5Liq5LuO5aCG6aG26Iez5Y+25a2Q55qE6LCD5pW06L+H56iL5Li64oCc562b6YCJ4oCd44CCXHJcblxyXG7ms6jmhI/vvJrnrZvpgInov4fnqIvkuK3vvIzmoLnnu5PngrnnmoTlt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzlm6DmraTvvIznrZvpgInmmK/ku47moLnnu5PngrnliLDmn5DkuKrlj7blrZDnu5PngrnnmoTkuIDmrKHosIPmlbTov4fnqIvjgIJcclxuXHJcbjUgIOWghueahOW7uueri1xyXG7liKnnlKjnrZvpgInnrpfms5XvvIzlj6/ku6XlsIbku7vmhI/ml6Dluo/nmoTorrDlvZXluo/liJflu7rmiJDkuIDkuKrloIbvvIzorr5SWzFdLFJbMl0sIOKApixSW25d5piv5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX44CCXHJcbuWwhuS6jOWPieagkeeahOavj+ajteWtkOagkemDveetm+mAieaIkOS4uuWghuOAguWPquacieaguee7k+eCueeahOagkeaYr+WghuOAguesrOKMim4vMuKMi+S4que7k+eCueS5i+WQjueahOaJgOaciee7k+eCuemDveayoeacieWtkOagke+8jOWNs+S7peesrOKMim4vMuKMi+S4que7k+eCueS5i+WQjueahOe7k+eCueS4uuagueeahOWtkOagkemDveaYr+WghuOAguWboOatpO+8jOS7pei/meS6m+e7k+eCueS4uuW3puOAgeWPs+WtqeWtkOeahOe7k+eCue+8jOWFtuW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWImei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuOAguWQjOeQhu+8jOWPquimgeWwhui/meS6m+e7k+eCueeahOebtOaOpeeItue7k+eCuei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuKApuOAglxyXG7lj6rpnIDku47nrKzijIpuLzLijIvkuKrorrDlvZXliLDnrKwx5Liq6K6w5b2V5L6d5qyh6L+b6KGM562b6YCJ5bCx5Y+v5Lul5bu656uL5aCG44CCXHJcblxyXG42ICAg5aCG5o6S5bqP566X5rOV5a6e546wXHJcbuWghueahOaguee7k+eCueaYr+WFs+mUruWtl+acgOWwj+eahOiusOW9le+8jOi+k+WHuuaguee7k+eCueWQju+8jOaYr+S7peW6j+WIl+eahOacgOWQjuS4gOS4quiusOW9leS9nOS4uuaguee7k+eCue+8jOiAjOWOn+adpeWghueahOW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWImei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuOAglxyXG5cclxuNyAg566X5rOV5YiG5p6QXHJcbuS4u+imgei/h+eoi++8muWIneWni+W7uuWghuWSjOmHjeaWsOiwg+aVtOaIkOWghuOAguiuvuiusOW9leaVsOS4um7vvIzmiYDlr7nlupTnmoTlrozlhajkuozlj4nmoJHmt7HluqbkuLpoIOOAglxyXG7il4YgIOWIneWni+W7uuWghu+8muavj+S4qumdnuWPtuWtkOe7k+eCuemDveimgeS7juS4iuWIsOS4i+WBmuKAnOetm+mAieKAnSDjgILnrKxp5bGC57uT54K55pWw4omkMmktMe+8jOe7k+eCueS4i+enu+eahOacgOWkp+a3seW6puaYr2gtae+8jOiAjOavj+S4i+enu+S4gOWxguimgeavlOi+gzLmrKHvvIzliJnmr5TovoPmrKHmlbBDMShuKeS4uu+8mlxyXG5DMShuKeKJpDQobi3jj5Iybi0xKVxyXG7il4YgIOetm+mAieiwg+aVtO+8muavj+asoeetm+mAieimgeWwhuaguee7k+eCueKAnOS4i+ayieKAneWIsOS4gOS4quWQiOmAguS9jee9ruOAguesrGnmrKHnrZvpgInml7bvvJrloIbkuK3lhYPntKDkuKrmlbDkuLpuLWkrMe+8m+WghueahOa3seW6puaYr++Dq+OPkjIobi1pKzEp74O7KzHvvIzliJnov5vooYxuLTHmrKHigJznrZvpgInigJ3nmoTmr5TovoPmrKHmlbBDMihuKeS4uu+8mlxyXG5DMihuKTwybuOPkjJuXHJcbuWghuaOkuW6j+eahOavlOi+g+asoeaVsOeahOaVsOmHj+e6p+S4uu+8miBUKG4pPU8obuOPkjJuKe+8m+iAjOmZhOWKoOepuumXtOWwseaYr+S6pOaNouaXtuaJgOeUqOeahOS4tOaXtuepuumXtO+8jOaVheepuumXtOWkjeadguW6puS4uu+8miBTKG4pPU8oMSkg44CCXHJcblxyXG7loIbmjpLluo/pgILlkIjorrDlvZXmlbDovoPlpKfnmoTmg4XlhrVcclxuXHJcblxyXG5odHRwOi8vYmxvZy5jc2RuLm5ldC96ejE5ODgwOC9hcnRpY2xlL2RldGFpbHMvNzY3ODA1NVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDlt7Lnn6VzcUxpc3Rbcy4ubV3kuK3orrDlvZXnmoTlhbPplK7lrZfpmaRzcUxpc3Rbc13kuYvlpJblnYfmu6HotrPloIbnmoTlrprkuYnvvIxcclxuICog5pys5Ye95pWw6LCD5pW0c3FMaXN0W3Nd55qE5YWz6ZSu5a2X77yM5L2/c3FMaXN0W3MuLm1d5oiQ5Li65LiA5Liq5aSn5aCG6aG277yI5a+55YW25Lit5YWz6ZSu5a2X6ICM6KiA77yJXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNxTGlzdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbVxyXG4gKi9cclxuZnVuY3Rpb24gaGVhcEFkanVzdChzcUxpc3QsIHMsIG0sIGNvbXApIHtcclxuICAgIGxldCByYyA9IHNxTGlzdFtzXTtcclxuXHJcbiAgICAvLyDmsr/lhbPplK7lrZfovoPlpKfnmoTlranlrZDnu5PngrnlkJHkuIvnrZvpgIlcclxuICAgIGZvciAobGV0IGogPSAyICogcyArIDE7IGogPD0gbTsgaiA9IGogKiAyICsgMSkge1xyXG4gICAgICAgIC8vIGrkuLrlhbPplK7lrZfovoPlpKfnmoTorrDlvZXkuIvmoIdcclxuICAgICAgICBpZiAoaiA8IG0gJiYgY29tcChzcUxpc3Rbal0sIHNxTGlzdFtqICsgMV0pIDwgMCkgKytqO1xyXG4gICAgICAgIC8vIHJj5bqU5o+S5YWl5Zyo5L2N572uc+S4ilxyXG4gICAgICAgIGlmIChjb21wKHJjLCBzcUxpc3Rbal0pID49IDApIGJyZWFrO1xyXG4gICAgICAgIHNxTGlzdFtzXSA9IHNxTGlzdFtqXTtcclxuICAgICAgICBzID0gajtcclxuICAgIH1cclxuXHJcbiAgICBzcUxpc3Rbc10gPSByYztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhlYXBTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XHJcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIC8vIOW7uueri+Wkp+WghumhtlxyXG4gICAgZm9yIChsZXQgaSA9IChsZW4gPj4gMSkgLSAxOyBpID49IDA7IC0taSlcclxuICAgICAgICBoZWFwQWRqdXN0KHNxTGlzdCwgaSwgbGVuIC0gMSwgY29tcCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPiAwOyAtLWkpIHtcclxuICAgICAgICAvLyDlsIbloIbpobborrDlvZXlkozlvZPliY3mnKrnu4/mjpLluo/lrZDluo/liJdzcUxpc3RbMC4uaV3kuK1cclxuICAgICAgICAvLyDmnIDlkI7kuIDkuKrorrDlvZXnm7jkupLkuqTmjaJcclxuICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbMF07XHJcbiAgICAgICAgc3FMaXN0WzBdID0gdGVtcDtcclxuXHJcbiAgICAgICAgLy8g5bCGc3FMaXN0WzAuLmkgLSAxXemHjeaWsOiwg+aVtOS4uuWkp+WghumhtlxyXG4gICAgICAgIGhlYXBBZGp1c3Qoc3FMaXN0LCAwLCBpIC0gMSwgY29tcCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhcnIgPSBbMSwgMywgNCwgNSwgNywgMiwgNiwgOCwgMF07XHJcbmhlYXBTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU29ydC9zZWxlY3Rpb24vaW5kZXguanNcbiAqKi8iLCIvKipcclxuICog5aCG5YiG6YWN5a2Y5YKo6KGo56S6XHJcbiAqXHJcbiAqIOi/meenjeWtmOWCqOihqOekuueahOeJueeCueaYr++8jOS7jeS7peS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+WtmOaUvuS4suWAvOWtl+espuW6j+WIl++8jOS9huWug+S7rOeahOWtmOWCqOepuumXtOaYr+WcqOeoi+W6j+aJp+ihjOi/h+eoi+S4reWKqOaAgeWIhumFjeiAjOW+l+OAguWcqGPor63oqIDkuK3vvIzlrZjlnKjkuIDkuKrnp7DkuYvkuLrigJzloIbigJ3nmoToh6rnlLHlrZjlgqjljLrvvIzlubbnlLFj6K+t6KiA55qE5Yqo5oCB5YiG6YWN5Ye95pWwbWFsbG9jKCnlkoxmcmVlKCnmnaXnrqHnkIbjgILliKnnlKjlh73mlbBtYWxsb2MoKeS4uuavj+S4quaWsOS6p+eUn+eahOS4suWIhumFjeS4gOWdl+WunumZheS4sumVv+aJgOmcgOeahOWtmOWCqOepuumXtOOAglxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmNoID0ge307XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDEgPD0gcG9zaXRpb24gPD0gdGhpcy5sZW5ndGgu5Zyo5Liy55qE56yscG9zaXRpb27kuKrlrZfnrKbkuYvliY3mj5LlhaXkuLJ0SFN0cmluZ1xyXG4gICAgc3RySW5zZXJ0IChwb3NpdGlvbiwgdEhTdHJpbmcpIHtcclxuICAgICAgICBpZiAocG9zaXRpb24gPCAxIHx8IHBvc2l0aW9uID4gdGhpcy5sZW5ndGggKyAxKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcG9zaXRpb24nKTtcclxuXHJcbiAgICAgICAgaWYgKHRIU3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyDkuLrmj5LlhaV06ICM6IW+5Ye65L2N572uXHJcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZW4gPSBwb3NpdGlvbiAtIDE7IGkgPj0gbGVuOyAtLWkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoW2kgKyB0SFN0cmluZy5sZW5ndGhdID0gdGhpcy5jaFtpXTtcclxuXHJcbiAgICAgICAgICAgIHN0cmluZ0NvcHkodGhpcy5jaCwgdEhTdHJpbmcuY2gsIHBvc2l0aW9uIC0gMSwgdEhTdHJpbmcubGVuZ3RoIC0gMSwgMCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0SFN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RyQXNzaWduIChjaGFycykge1xyXG4gICAgICAgIHN0cmluZ0NvcHkodGhpcy5jaCwgY2hhcnMsIDAsIGNoYXJzLmxlbmd0aCAtIDEsIDApO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgc3RyTGVuZ3RoICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBzdHJDb21wYXJlICh0SFN0cmluZykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbiAmJiBpIDwgdEhTdHJpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoW2ldICE9PSB0SFN0cmluZy5jaFtpXSkgcmV0dXJuIHRoaXMuY2hbaV0gLSB0SFN0cmluZy5jaFtpXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdEhTdHJpbmcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY2xlYXJTdHJpbmcgKCkge1xyXG4gICAgICAgIHRoaXMuY2ggPSB7fTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBjb25jYXQgKHMpIHtcclxuICAgICAgICBsZXQgdCA9IG5ldyBIU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIC8vIHQuY2hbMC4udGhpcy5sZW5ndGggLSAxXSA9IHRoaXMuY2hbMC4udGhpcy5sZW5ndGggLSAxXVxyXG4gICAgICAgIHN0cmluZ0NvcHkodC5jaCwgdGhpcy5jaCwgMCwgdGhpcy5sZW5ndGggLSAxLCAwKTtcclxuICAgICAgICB0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgcy5sZW5ndGg7XHJcbiAgICAgICAgLy8gdC5jaFt0aGlzLmxlbmd0aC4udC5sZW5ndGggLSAxXSA9IHMuY2hbMC4ucy5sZW5ndGggLSAxXVxyXG4gICAgICAgIHN0cmluZ0NvcHkodC5jaCwgcy5jaCwgdGhpcy5sZW5ndGgsIHMubGVuZ3RoIC0gMSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgc3Vic3RyaW5nIChwb3NpdGlvbiwgbGVuKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSB+fnBvc2l0aW9uIHx8IDA7XHJcbiAgICAgICAgbGVuID0gfn5sZW4gfHwgdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMubGVuZ3RoIC0gMSB8fCBsZW4gPCAwIHx8IGxlbiA+IHRoaXMubGVuZ3RoIC0gcG9zaXRpb24pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwYXJhbWV0ZXInKTtcclxuXHJcbiAgICAgICAgbGV0IHN1YiA9IG5ldyBIU3RyaW5nKCk7XHJcbiAgICAgICAgc3RyaW5nQ29weShzdWIuY2gsIHRoaXMuY2gsIDAsIGxlbiAtIDEsIHBvc2l0aW9uKTtcclxuICAgICAgICBzdWIubGVuZ3RoID0gbGVuO1xyXG5cclxuICAgICAgICByZXR1cm4gc3ViO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGxldCBzID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgcyArPSB0aGlzLmNoW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5nQ29weShkZXN0aW5hdGlvbiwgdGFyZ2V0LCBkZXN0U3RhcnQsIGxlbmd0aCwgdGFyZ2V0U3RhcnQpIHtcclxuICAgIGRlc3RTdGFydCA9IGRlc3RTdGFydCB8fCAwO1xyXG4gICAgbGVuZ3RoID0gbGVuZ3RoIHx8IHRhcmdldC5sZW5ndGg7XHJcbiAgICB0YXJnZXRTdGFydCA9IHRhcmdldFN0YXJ0IHx8IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkZXN0aW5hdGlvbltkZXN0U3RhcnQgKyBpXSA9IHRhcmdldFt0YXJnZXRTdGFydCArIGldO1xyXG4gICAgfVxyXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU3RyaW5nL0hTdHJpbmcuanNcbiAqKi8iLCIvKipcclxuICog5Liy55qE5Z2X6ZO+5a2Y5YKo6KGo56S6XHJcbiAqXHJcbiAqIOWSjOe6v+aAp+ihqOeahOmTvuW8j+WtmOWCqOe7k+aehOebuOexu+S8vO+8jOS5n+WPr+mHh+eUqOmTvuW8j+aWueW8j+WtmOWCqOS4suWAvOOAgueUseS6juS4sue7k+aehOeahOeJueauiuaApy0t57uT5p6E5Lit55qE5q+P5Liq5pWw5o2u5YWD57Sg5piv5LiA5Liq5a2X56ym77yM5YiZ55So6ZO+6KGo5a2Y5YKo5Liy5YC85pe277yM5a2Y5Zyo5LiA5Liq4oCc57uT54K55aSn5bCP4oCd55qE6Zeu6aKY77yM5Y2z5q+P5Liq57uT54K55Y+v5Lul5a2Y5pS+5LiA5Liq5a2X56ym77yM5Lmf5Y+v5Lul5a2Y5pS+5aSa5Liq5a2X56ym44CCXHJcbiAqIOS4i+mdouaYr+e7k+eCueWkp+Wwj+S4ujTvvIjljbPmr4/kuKrnu5PngrnlrZjmlL405Liq5a2X56ym77yJ55qE6ZO+6KGoXHJcbiAqIGhlYWQgLS0+IChhLGIsYyxkKSAtLT4gKGUsZixnLGgpIC0tPiAoaSMjIylcclxuICog5LiL6Z2i5piv57uT54K55aSn5bCP5Li6MeeahOmTvuihqFxyXG4gKiBoZWFkIC0tPiAoYSkgLS0+IChiKSAtLT4gKGMpIC0tPiAuLi4gLS0+IChpKVxyXG4gKlxyXG4gKiDlvZPnu5PngrnlpKflsI/lpKfkuo4x5pe277yM55Sx5LqO5Liy6ZW/5LiN5LiA5a6a5piv57uT54K55aSn5bCP55qE5pW05YCN5pWw77yM5YiZ6ZO+6KGo5Lit55qE5pyA5ZCO5LiA5Liq57uT54K55LiN5LiA5a6a5YWo6KKr5Liy5YC85Y2g5ruh77yM5q2k5pe26YCa5bi46KGl5LiK4oCcI+KAneaIluWFtuWug+mdnuS4suWAvOWtl+espuOAglxyXG4gKiDkuLrkuobkvr/kuo7ov5vooYzkuLLnmoTmk43kvZzvvIzlvZPku6Xpk77ooajlrZjlgqjkuLLlgLzml7bvvIzpmaTlpLTmjIfpkojlpJbov5jlj6/pmYTorr7kuIDkuKrlsL7mjIfpkojmjIfnpLrpk77ooajkuK3nmoTmnIDlkI7kuIDkuKrnu5PngrnvvIzlubbnu5nlh7rlvZPliY3kuLLnmoTplb/luqbvvIznp7DlpoLmraTlrprkuYnnmoTkuLLlrZjlgqjnu5PmnoTkuLrlnZfpk77nu5PmnoTjgIJcclxuICpcclxuICog55Sx5LqO5LiA6Iis5oOF5Ya15LiL77yM5a+55Liy6L+b6KGM5pON5L2c5pe277yM5Y+q6ZyA6KaB5LuO5aS05ZCR5bC+6aG65bqP5omr5o+P5Y2z5Y+v77yM5YiZ5a+55Liy5YC85LiN5b+F5bu656uL5Y+M5ZCR6ZO+6KGo44CC6K6+5bC+5oyH6ZKI55qE55uu55qE5piv5Li65LqG5L6/5LqO6L+b6KGM6L+e5o6l5pON5L2c77yM5L2G5bqU5rOo5oSP6L+e5o6l5pe26ZyA5aSE55CG56ys5LiA5Liq5Liy5bC+55qE5peg5pWI5a2X56ym44CCXHJcbiAqIOWcqOmTvuW8j+WtmOWCqOaWueW8j+S4re+8jOe7k+eCueWkp+Wwj+eahOmAieaLqeWSjOmhuuW6j+WtmOWCqOaWueW8j+eahOagvOW8j+mAieaLqeS4gOagt+mDveW+iOmHjeimge+8jOWug+ebtOaOpeW9seWTjeWIsOS4suWkhOeQhueahOaViOeOh+OAguWmguaenOS4suW+iOmVv++8jOi/meimgeaxguaIkeS7rOiAg+iZkeS4suWAvOeahOWtmOWCqOWvhuW6pu+8mlxyXG4gKiDlrZjlgqjlr4bluqYgPSDkuLLlgLzmiYDljaDnmoTlrZjlgqjkvY0gLyDlrp7pmYXliIbphY3nmoTlrZjlgqjkvY1cclxuICpcclxuICog5Liy5YC855qE6ZO+5byP5a2Y5YKo57uT5p6E5a+55p+Q5Lqb5Liy5pON5L2c77yM5aaC6L+e5o6l5pON5L2c562J5pyJ5LiA5a6a5pa55L6/5LmL5aSE77yM5L2G5oC755qE5p2l6K+05LiN5aaC5Y+m5aSW5Lik56eN5a2Y5YKo57uT5p6E54G15rS777yM5a6D5Y2g55So5a2Y5YKo6YeP5aSn5LiU5pON5L2c5aSN5p2C44CCXHJcbiAqL1xyXG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vU3RhY2svaW5kZXgnO1xyXG5cclxuY2xhc3MgQ2h1bmsge1xyXG4gICAgY29uc3RydWN0b3IoY2h1bmtTaXplID0gNCkge1xyXG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xyXG4gICAgICAgIHRoaXMuY2ggPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaFtpXSA9ICcjJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHlwZTogQ2h1bmtcclxuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMU3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKGNodW5rU2l6ZSA9IDQpIHtcclxuICAgICAgICAvLyB0eXBlIENodW5rXHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICAvLyB0eXBlOiBjaHVua1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgLy8g5Liy55qE5b2T5YmN6ZW/5bqmXHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWwhuWtl+espuS4sui9rOaNouaIkExTdHJpbmfnsbvlnotcclxuICAgIHN0ckFzc2lnbiAoY2hhcnMpIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hhcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudC5jaFtpICUgdGhpcy5jaHVua1NpemVdID0gY2hhcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbiAmJiAoaSArIDEpICUgdGhpcy5jaHVua1NpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IG5ldyBDaHVuaygpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50YWlsID0gY3VycmVudDtcclxuICAgIH1cclxuICAgIC8vIOWtl+espuS4suWvueavlFxyXG4gICAgLy8gVE9ETyDmmK/lkKbljrvmjoljaHVua1NpemXnmoTlr7nmr5RcclxuICAgIHN0ckNvbXBhcmUgKHRMU3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGN1clQgPSB0TFN0cmluZy5oZWFkO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IHRMU3RyaW5nLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmNoW2ldICE9PSBjdXJULmNoW2ldKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIGN1clQgPSBjdXJULm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNsZWFyU3RyaW5nICgpIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGNvbmNhdCAodExTdGluZykge1xyXG4gICAgICAgIGlmICghdExTdGluZy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHJldCA9IG5ldyBMU3RyaW5nKHRoaXMuY2h1bmtTaXplKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdExTdGluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0LmhlYWQgPSByZXQudGFpbCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XHJcbiAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHJldC50YWlsLmNoLmluZGV4T2YoJyMnKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcsIHJldC50YWlsLCB0TFN0aW5nLmhlYWQsIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIHN1YnN0cmluZyAocG9zLCBsZW4pIHtcclxuICAgICAgICBwb3MgPSB+fnBvcyB8fCAwO1xyXG4gICAgICAgIGxlbiA9IH5+bGVuIHx8IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoIC0gMSB8fCBsZW4gPCAwIHx8IGxlbiA+IHRoaXMubGVuZ3RoIC0gcG9zKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XHJcblxyXG4gICAgICAgIGxldCBzdWIgPSBuZXcgTFN0cmluZyh0aGlzLmNodW5rU2l6ZSk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBmaW5kUG9zQ2h1bmsodGhpcywgcG9zKTtcclxuICAgICAgICBsZXQgY3VyUyA9IHN1Yi5oZWFkID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgc3ViLmxlbmd0aCA9IGxlbjtcclxuXHJcbiAgICAgICAgb3V0ZXJsb29wOiB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc2l6ZSA9IHRoaXMuY2h1bmtTaXplOyBqIDwgc2l6ZTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXJsb29wO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJTLmNoW2pdID0gY3VycmVudC5jaFsoaSArIHBvcykgJSB0aGlzLmNodW5rU2l6ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaSArIHBvcykgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAlIHRoaXMuY2h1bmtTaXplID09PSAwICYmIChjdXJyZW50LmNoW2ldIHx8IGN1cnJlbnQubmV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyUy5uZXh0ID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyUyA9IGN1clMubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdWI7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSByZXR1cm4gJyc7XHJcblxyXG4gICAgICAgIGxldCBzdHIgPSAnJztcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5jaHVua1NpemU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoID0gY3VycmVudC5jaFtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IGN1cnJlbnQuY2hbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRQb3NDaHVuayhsU3RyaW5nLCBwb3MpIHtcclxuICAgIGxldCBjdXJyZW50ID0gbFN0cmluZy5oZWFkO1xyXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbFN0cmluZy5jaHVua1NpemU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocG9zLS0gPT09IDApIHJldHVybiBjdXJyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb3B5U3RyaW5nKGRlc3RpbmF0aW9uLCB0YXJnZXQsIGN1ckQsIGN1cnJULCBvZmZzZXQpIHtcclxuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xyXG4gICAgY3VyclQgPSBjdXJyVCB8fCB0YXJnZXQuaGVhZDtcclxuICAgIGN1ckQgPSBjdXJEIHx8IGRlc3RpbmF0aW9uLmhlYWQ7XHJcbiAgICBsZXQgayA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGN1cnJUKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRhcmdldC5jaHVua1NpemU7IGkgPCBsZW47IGkrKywgaysrKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gayAlIGN1ckQuY2h1bmtTaXplICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICBjdXJELmNoW2ogJSBjdXJELmNodW5rU2l6ZV0gPSBjdXJyVC5jaFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoaiArIDEpICUgY3VyRC5jaHVua1NpemUgPT09IDAgJiYgKGN1cnJULmNoW2kgKyAxXSB8fCBjdXJyVC5uZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY3VyRC5uZXh0ID0gbmV3IENodW5rKGRlc3RpbmF0aW9uLmNodW5rU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBjdXJEID0gY3VyRC5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyVCA9IGN1cnJULm5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdGluYXRpb24udGFpbCA9IGN1ckQ7XHJcbiAgICBkZXN0aW5hdGlvbi5sZW5ndGggKz0gdGFyZ2V0Lmxlbmd0aDtcclxufVxyXG5cclxubGV0IGEgPSBuZXcgTFN0cmluZygpO1xyXG5sZXQgYiA9IG5ldyBMU3RyaW5nKCk7XHJcbmxldCBjID0gbmV3IExTdHJpbmcoKTtcclxuXHJcbmEuc3RyQXNzaWduKCdhYmNkZWZnJyk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcbmIuc3RyQXNzaWduKCdoaWprbG1ubycpO1xyXG5jb25zb2xlLmxvZyhiICsgJycpO1xyXG5jLnN0ckFzc2lnbignYWJjZGVmZycpO1xyXG5jb25zb2xlLmxvZyhhLnN0ckNvbXBhcmUoYikpO1xyXG5jb25zb2xlLmxvZyhhLnN0ckNvbXBhcmUoYykpO1xyXG5sZXQgdCA9IGEuY29uY2F0KGIpO1xyXG5jb25zb2xlLmxvZyh0ICsgJycpO1xyXG50ID0gdC5zdWJzdHJpbmcoMiwgNSk7XHJcbmNvbnNvbGUubG9nKHQgKyAnJyk7XHJcblxyXG5cclxuLy8g5Yik5pat5piv5ZCm5Li65Zue5paH5a2X56ym5LiyXHJcbmZ1bmN0aW9uIHBhbGluZHJvbWUobFN0cikge1xyXG4gICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICBsZXQgcCA9IGxTdHIuaGVhZDtcclxuICAgIGxldCBpID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBrID0gMTsgayA8PSBsU3RyLmxlbmd0aDsgKytrKSB7XHJcbiAgICAgICAgaWYgKGsgPD0gbFN0ci5sZW5ndGggLyAyKSBzdGFjay5wdXNoKHAuY2hbaV0pO1xyXG4gICAgICAgIGVsc2UgaWYgKGsgPiAobFN0ci5sZW5ndGggKyAxKSAvIDIpIHtcclxuICAgICAgICAgICAgbGV0IGMgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgaWYgKHAuY2hbaV0gIT09IGMpIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgrK2kgPT09IGxTdHIuY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1N0cmluZy9MU3RyaW5nLmpzXG4gKiovIiwiLyoqXHJcbiAqIOS4su+8iHN0cmluZ++8ie+8iOaIluWtl+espuS4su+8ieaYr+eUsembtuS4quaIluWkmuS4quWtl+espue7hOaIkOeahOaciemZkOW6j+WIl+OAguS4suS4reWtl+espueahOaVsOebruensOS4uuS4sueahOmVv+W6puOAgumbtuS4quWtl+espueahOS4suensOS4uuepuuS4su+8iG51bGwgc3RyaW5n77yJ77yM5a6D55qE6ZW/5bqm5Li66Zu244CCXHJcbiAqIOS4suS4reS7u+aEj+S4qui/nue7reeahOWtl+espue7hOaIkOeahOWtkOW6j+WIl+ensOS4uuivpeS4sueahOWtkOS4suOAguWMheWQq+WtkOS4sueahOS4suebuOW6lOWcsOensOS4uuS4u+S4suOAgumAmuW4uOensOWtl+espuWcqOW6j+WIl+S4reeahOW6j+WPt+S4uuivpeWtl+espuWcqOS4suS4reeahOS9jee9ruOAguWtkOS4suWcqOS4u+S4suS4reeahOS9jee9ruWImeS7peWtkOS4sueahOesrOS4gOS4quWtl+espuWcqOS4u+S4suS4reeahOS9jee9ruadpeihqOekuuOAglxyXG4gKiDlj6rmnInlvZPkuKTkuKrkuLLnmoTplb/luqbnm7jnrYnvvIzlubbkuJTlkITkuKrlr7nlupTkvY3nva7nmoTlrZfnrKbpg73nm7jnrYnml7bmiY3nm7jnrYnjgIJcclxuICpcclxuICog5Liy5pyJM+enjeacuuWGheihqOekuuaWueazle+8mlxyXG4gKiAxLuWumumVv+mhuuW6j+WtmOWCqOihqOekulxyXG4gKiAyLuWghuWIhumFjeWtmOWCqOihqOekulxyXG4gKiAzLuS4sueahOWdl+mTvuWtmOWCqOihqOekulxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDlrprplb/pobrluo/lrZjlgqjooajnpLpcclxuICog57G75Ly85LqO57q/5oCn6KGo55qE6aG65bqP5a2Y5YKo57uT5p6E77yM55So5LiA57uE5Zyw5Z2A6L+e57ut55qE5a2Y5YKo5Y2V5YWD5a2Y5YKo5Liy5YC85b6X5a2X56ym5bqP5YiX44CC5Zyo5Liy55qE5a6a6ZW/6aG65bqP5a2Y5YKo57uT5p6E5Lit77yM5oyJ54Wn6aKE5a6a5LmJ55qE5aSn5bCP77yM5Li65q+P5Liq5a6a5LmJ55qE5Liy5Y+Y6YeP5YiG6YWN5LiA5Liq5Zu65a6a6ZW/5bqm55qE5a2Y5YKo5Yy677yM5YiZ5Y+v55So5a6a6ZW/5pWw57uE5p2l5o+P6L+w44CCXHJcbiAqIOS7peS4i+agh+S4ujDnmoTmlbDnu4TliIbph4/lrZjmlL7kuLLnmoTlrp7pmYXplb/luqbjgIJcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTU3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0cil7XHJcbiAgICAgICAgdGhpcy5NQVhTVFJMRU4gPSAxMDtcclxuICAgICAgICBpZiAoc3RyKSB7XHJcbiAgICAgICAgICAgIHRoaXNbMF0gPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBzdHJbaSAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOi/lOWbnueUsXMx5ZKMczLov57mjqXogIzmiJDnmoTmlrDkuLJcclxuICAgIGNvbmNhdCAoczIpIHtcclxuICAgICAgICBsZXQgdCA9IG5ldyBTU3RyaW5nKCk7XHJcbiAgICAgICAgLy8g5pyq5oiq5patXHJcbiAgICAgICAgaWYgKHRoaXNbMF0gKyBzMlswXSA8PSB0aGlzLk1BWFNUUkxFTikge1xyXG4gICAgICAgICAgICBjb3B5U3RyMlQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvcHlTdHIyVChzMiwgdGhpc1swXSk7XHJcbiAgICAgICAgICAgIHRbMF0gPSB0aGlzWzBdICsgczJbMF07XHJcblxyXG4gICAgICAgICAgICAvLyDmiKrmlq1cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbMF0gPCB0aGlzLk1BWFNUUkxFTikge1xyXG4gICAgICAgICAgICBjb3B5U3RyMlQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvcHlTdHIyVChzMiwgdGhpc1swXSwgdGhpcy5NQVhTVFJMRU4gLSB0aGlzWzBdKTtcclxuICAgICAgICAgICAgdFswXSA9IHRoaXMuTUFYU1RSTEVOO1xyXG5cclxuICAgICAgICAgICAgLy8g5oiq5pat77yI5LuF5Y+WczHvvIlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb3B5U3RyMlQodGhpcywgMCwgdGhpcy5NQVhTVFJMRU4pO1xyXG4gICAgICAgICAgICB0WzBdID0gdGhpc1swXSA9IHRoaXMuTUFYU1RSTEVOO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNvcHlTdHIyVChzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyWzBdKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBlbmQgfHwgc3RyWzBdOyBpIDw9IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0W3N0YXJ0ICsgaV0gPSBzdHJbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdWJzdHJpbmcgKHBvc2l0aW9uID0gMCwgbGVuID0gdGhpc1swXSkge1xyXG4gICAgICAgIHBvc2l0aW9uID0gfn5wb3NpdGlvbjtcclxuICAgICAgICBsZW4gPSB+fmxlbjtcclxuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpc1swXSAtIDEgfHwgbGVuIDwgMCB8fCBsZW4gPiB0aGlzWzBdIC0gcG9zaXRpb24pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwYXJhbWV0ZXInKTtcclxuXHJcbiAgICAgICAgbGV0IHN1YiA9IG5ldyBTU3RyaW5nKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgc3ViW2ldID0gdGhpc1twb3NpdGlvbiArIGkgLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3ViWzBdID0gbGVuO1xyXG5cclxuICAgICAgICByZXR1cm4gc3ViO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bCG5Liyc+S4reeahOWtkOS4snTmm7/mjaLkuLp277yM6L+U5Zue5pu/5o2i5qyh5pWwXHJcbiAgICAgKiB0b2RvIHRvIGJlIHRlc3RlZFxyXG4gICAgICogQHBhcmFtIHtTU3RyaW5nfSB0XHJcbiAgICAgKiBAcGFyYW0ge1NTdHJpbmd9IHZcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOabv+aNouasoeaVsFxyXG4gICAgICovXHJcbiAgICByZXBsYWNlICh0LCB2KSB7XHJcbiAgICAgICAgZm9yIChsZXQgbiA9IDAsIGkgPSAxOyBpIDw9IHRoaXNbMF0gLSB0WzBdICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpLCBrID0gMTsgdFtrXSAmJiB0aGlzW2pdID09PSB0W2tdOyArK2osICsrayk7XHJcblxyXG4gICAgICAgICAgICAvLyDmib7liLDkuobkuI505Yy56YWN55qE5a2X5Liy77ya5YiG5LiJ56eN5oOF5Ya15aSE55CGXHJcbiAgICAgICAgICAgIGlmIChrID4gdFswXSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGw7XHJcbiAgICAgICAgICAgICAgICAvLyDmlrDlrZfkuLLnmoTplb/luqbkuI7ljp/lrZDkuLLnm7jlkIzml7bvvIznm7TmjqXmm7/mjaJcclxuICAgICAgICAgICAgICAgIGlmICh0WzBdID09PSB2WzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMTsgbCA8PSB0WzBdOyArK2wpIHRoaXNbaSArIGwgLSAxXSA9IHZbbF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDmlrDlrZDkuLLplb/luqblpKfkuo7ljp/lrZDkuLLml7bvvIzlhYjlsIblkI7pg6jlj7Pnp7tcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRbMF0gPCB2WzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gdGhpc1swXTsgbCA+PSBpICsgdFswXTsgLS1sKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2wgKyB2WzBdIC0gdFswXV0gPSB0aGlzW2xdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAxOyBsIDw9IHZbMF07ICsrbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpICsgbCAtIDFdID0gdltsXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDmlrDlrZDkuLLplb/luqblsI/kuo7ljp/lrZDkuLLml7bvvIzlhYjlsIblkI7pg6jlt6bnp7tcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IGkgKyB2WzBdOyBsIDw9IHRoaXNbMF0gKyB2WzBdIC0gdFswXTsgKytsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2xdID0gdGhpc1tsIC0gdlswXSArIHRbMF1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAxOyBsIDw9IHZbMF07ICsrbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpICsgbCAtIDFdID0gdltsXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpc1swXSA9IHRoaXNbMF0gLSB0WzBdICsgdlswXTtcclxuICAgICAgICAgICAgICAgIGkgKz0gdlswXTtcclxuICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGxldCBzdHIgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgdGhpc1tpXTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0ciArPSB0aGlzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgLy8g6L+U5Zue5a2Q5Liyc3N0cmluZ+WcqOS4u+S4suS4reeahOesrHBvc2l0aW9u5Liq5a2X56ym5LmL5ZCO55qE5L2N572uXHJcbiAgICBpbmRleCAoc3N0cmluZywgcG9zaXRpb24pIHtcclxuICAgICAgICBsZXQgaSA9IHBvc2l0aW9uIHx8IDE7XHJcbiAgICAgICAgbGV0IGogPSAxO1xyXG5cclxuICAgICAgICB3aGlsZSAoaSA8PSB0aGlzWzBdICYmIGogPD0gc3N0cmluZ1swXSkge1xyXG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gc3N0cmluZ1tqXSkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaSA9IGkgLSBqICsgMjtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaiA+IHNzdHJpbmdbMF0gPyBpIC0gc3N0cmluZ1swXSA6IC0xO1xyXG4gICAgfVxyXG4gICAga21wSW5kZXggKHNzdHJpbmcsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgbGV0IGkgPSBwb3NpdGlvbiB8fCAxO1xyXG4gICAgICAgIGxldCBqID0gMTtcclxuICAgICAgICBsZXQgbmV4dCA9IGdldE5leHQoc3N0cmluZyk7XHJcblxyXG4gICAgICAgIHdoaWxlIChpIDw9IHRoaXNbMF0gJiYgaiA8PSBzc3RyaW5nWzBdKSB7XHJcbiAgICAgICAgICAgIGlmIChqID09PSAwIHx8IHRoaXNbaV0gPT09IHNzdHJpbmdbal0pIHtcclxuICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgICsrajtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGogPSBuZXh0W2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaiA+IHNzdHJpbmdbMF0gPyBpIC0gc3N0cmluZ1swXSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguWMheWQq+WcqOWtl+espuS4suS4reiAjHN0cuayoeacieeahOWtl+espuS4slxyXG4gICAgc3VidHJhY3QgKHN0cikge1xyXG4gICAgICAgIGxldCByID0gbmV3IFNTdHJpbmcoKTtcclxuICAgICAgICByWzBdID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpc1swXTsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBjID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgLy8g5Yik5pat5b2T5YmN5a2X56ymY+aYr+WQpuesrOS4gOasoeWHuueOsFxyXG4gICAgICAgICAgICBsZXQgaiA9IDE7XHJcbiAgICAgICAgICAgIGZvciAoOyBqIDwgaSAmJiB0aGlzW2pdICE9PSBjOyArK2opO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xyXG4gICAgICAgICAgICAgICAgLy8g5Yik5pat5b2T5YmN5a2X56ym5piv5ZCm5YyF5ZCr5Zyoc3Ry5LitXHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IDFcclxuICAgICAgICAgICAgICAgIGZvciAoOyBrIDw9IHN0clswXSAmJiBzdHJba10gIT09IGM7ICsrayk7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA+IHN0clswXSkgclsrK3JbMF1dID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdG9kbyBidWcgZXhpc3RzXHJcbiAgICBkZWxldGVfc3Vic3RyaW5nIChzdHIpIHtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpc1swXSAtIHN0clswXSArIDE7ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgaiA9IDE7XHJcbiAgICAgICAgICAgIGZvciAoOyBqIDw9IHN0clswXSAmJiB0aGlzW2kgKyBqIC0gMV0gPT09IHN0cltqXTsgKytqKTtcclxuICAgICAgICAgICAgaWYgKGogPiBzdHJbMF0gLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gaTsgayA8PSB0aGlzWzBdIC0gc3RyWzBdOyArK2spIHRoaXNba10gPSB0aGlzW2sgKyBzdHJbMF1dO1xyXG4gICAgICAgICAgICAgICAgdGhpc1swXSAtPSBzdHJbMF07XHJcbiAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXROZXh0KHNzdHJpbmcpIHtcclxuICAgIGxldCBpID0gMTtcclxuICAgIGxldCBuZXh0ID0gezE6IDB9O1xyXG4gICAgbGV0IGogPSAwO1xyXG5cclxuICAgIHdoaWxlIChpIDwgc3N0cmluZ1swXSkge1xyXG4gICAgICAgIGlmIChqID09PSAwIHx8IHNzdHJpbmdbaV0gPT09IHNzdHJpbmdbal0pIHtcclxuICAgICAgICAgICAgaWYgKHNzdHJpbmdbKytpXSAhPT0gc3N0cmluZ1srK2pdKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0W2ldID0gajtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5leHRbaV0gPSBuZXh0W2pdO1xyXG4gICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgIG5leHRbKytpXSA9ICsrajtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBqID0gbmV4dFtqXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5leHQ7XHJcbn1cclxuXHJcbmxldCBhID0gbmV3IFNTdHJpbmcoKTtcclxubGV0IGIgPSBuZXcgU1N0cmluZygpO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgYVtpICsgMV0gPSBpICsgJyc7XHJcbiAgICBiW2kgKyAxXSA9IGkgKyAnJztcclxufVxyXG5hWzBdID0gYlswXSA9IDQ7XHJcbmxldCB0ID0gYS5jb25jYXQoYik7XHJcbmNvbnNvbGUubG9nKHQgKyAnJyk7ICAgICAgIC8vIDAxMjMwMTIzXHJcblxyXG5sZXQgZCA9IG5ldyBTU3RyaW5nKCdhY2FiYWFiYWFiY2FjYWFiYycpO1xyXG5sZXQgYyA9IG5ldyBTU3RyaW5nKCdhYmFhYmMnKTtcclxuXHJcbmNvbnNvbGUubG9nKCdpbmRleDogJyArIGQuaW5kZXgoYykpO1xyXG5jb25zb2xlLmxvZygna21wSW5kZXg6ICcgKyBkLmttcEluZGV4KGMpKTtcclxuXHJcbmEgPSBuZXcgU1N0cmluZygnYWJjZGVmZycpO1xyXG5iID0gbmV3IFNTdHJpbmcoJ2FzZGZnJyk7XHJcbmNvbnNvbGUubG9nKGEuc3VidHJhY3QoYikgKyAnJyk7XHJcblxyXG5hID0gbmV3IFNTdHJpbmcoJ2FiY2RlZmdoJyk7XHJcbmIgPSBuZXcgU1N0cmluZygnY2RlZicpO1xyXG5jb25zb2xlLmxvZyhhLmRlbGV0ZV9zdWJzdHJpbmcoYikgKyAnJyk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcblxyXG4vKlxyXG4g5Zyo6aG65bqP5a2Y5YKo57uT5p6E5Lit77yM5a6e546w5Liy5pON5L2c55qE5Y6f5pON5L2c5Li64oCc5a2X56ym5Liy5bqP5YiX55qE5aSN5Yi24oCd77yM5pON5L2c5pe26Ze05aSN5p2C5bqm5Z+65LqO5aSN5Yi255qE5a2X56ym5Liy5bqP5YiX55qE6ZW/5bqm44CCXHJcbiDlj6bkuIDmk43kvZznibnngrnmmK/vvIzlpoLmnpzlnKjmk43kvZzkuK3lh7rnjrDkuLLlgLzluo/liJfnmoTplb/luqbotoXov4dNQVhTVFJMRU7ml7bvvIznuqblrprnlKjmiKrlsL7ms5XlpITnkIbvvIzov5nnp43mg4XlhrXkuI3ku4XlnKjmsYLov57mjqXkuLLml7blj6/og73lj5HnlJ/vvIzlnKjkuLLnmoTlhbbku5bmk43kvZzkuK3vvIzlpoLmj5LlhaXvvIznva7mjaLnrYnkuZ/lj6/og73lj5HnlJ/vvIzlhYvmnI3ov5nkuKrlvIrnl4XllK/mnInkuI3pmZDlrprkuLLplb/nmoTmnIDlpKfplb/luqbvvIzljbPliqjmgIHliIbphY3kuLLlgLznmoTlrZjlgqjnqbrpl7TjgIJcclxuICovXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU3RyaW5nL1NTdHJpbmcuanNcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2llZWU3NTQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNyeXB0bykge1xuICBmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGlnZXN0KSB7XG4gICAgICBjYWxsYmFjayA9IGRpZ2VzdFxuICAgICAgZGlnZXN0ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXN1bHQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSB7XG4gICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgaXRlcmF0aW9ucylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcblxuICAgIGlmIChpdGVyYXRpb25zIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcblxuICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIGtleWxlbilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcblxuICAgIGlmIChrZXlsZW4gPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuXG4gICAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQpXG5cbiAgICB2YXIgaExlbiwgbCA9IDEsIHIsIFRcbiAgICB2YXIgREsgPSBuZXcgQnVmZmVyKGtleWxlbilcbiAgICB2YXIgYmxvY2sxID0gbmV3IEJ1ZmZlcihzYWx0Lmxlbmd0aCArIDQpXG4gICAgc2FsdC5jb3B5KGJsb2NrMSwgMCwgMCwgc2FsdC5sZW5ndGgpXG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcbiAgICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuXG4gICAgICB2YXIgVSA9IGNyeXB0by5jcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpXG5cbiAgICAgIGlmICghaExlbikge1xuICAgICAgICBoTGVuID0gVS5sZW5ndGhcbiAgICAgICAgVCA9IG5ldyBCdWZmZXIoaExlbilcbiAgICAgICAgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKVxuICAgICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW5cblxuICAgICAgICBpZiAoa2V5bGVuID4gKE1hdGgucG93KDIsIDMyKSAtIDEpICogaExlbilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXlsZW4gZXhjZWVkcyBtYXhpbXVtIGxlbmd0aCcpXG4gICAgICB9XG5cbiAgICAgIFUuY29weShULCAwLCAwLCBoTGVuKVxuXG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICBVID0gY3J5cHRvLmNyZWF0ZUhtYWMoZGlnZXN0LCBwYXNzd29yZCkudXBkYXRlKFUpLmRpZ2VzdCgpXG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspIHtcbiAgICAgICAgICBUW2tdIF49IFVba11cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuXG4gICAgICB2YXIgbGVuID0gKGkgPT0gbCA/IHIgOiBoTGVuKVxuICAgICAgVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIERLXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBia2RmMjogcGJrZGYyLFxuICAgIHBia2RmMlN5bmM6IHBia2RmMlN5bmNcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcGJrZGYyLWNvbXBhdC9wYmtkZjIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9XG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpcztcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gcmlwZW1kMTYwXG5cblxuXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKiBAcHJlc2VydmVcbihjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLy8gQ29uc3RhbnRzIHRhYmxlXG52YXIgemwgPSBbXG4gICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICA3LCAgNCwgMTMsICAxLCAxMCwgIDYsIDE1LCAgMywgMTIsICAwLCAgOSwgIDUsICAyLCAxNCwgMTEsICA4LFxuICAgIDMsIDEwLCAxNCwgIDQsICA5LCAxNSwgIDgsICAxLCAgMiwgIDcsICAwLCAgNiwgMTMsIDExLCAgNSwgMTIsXG4gICAgMSwgIDksIDExLCAxMCwgIDAsICA4LCAxMiwgIDQsIDEzLCAgMywgIDcsIDE1LCAxNCwgIDUsICA2LCAgMixcbiAgICA0LCAgMCwgIDUsICA5LCAgNywgMTIsICAyLCAxMCwgMTQsICAxLCAgMywgIDgsIDExLCAgNiwgMTUsIDEzXTtcbnZhciB6ciA9IFtcbiAgICA1LCAxNCwgIDcsICAwLCAgOSwgIDIsIDExLCAgNCwgMTMsICA2LCAxNSwgIDgsICAxLCAxMCwgIDMsIDEyLFxuICAgIDYsIDExLCAgMywgIDcsICAwLCAxMywgIDUsIDEwLCAxNCwgMTUsICA4LCAxMiwgIDQsICA5LCAgMSwgIDIsXG4gICAgMTUsICA1LCAgMSwgIDMsICA3LCAxNCwgIDYsICA5LCAxMSwgIDgsIDEyLCAgMiwgMTAsICAwLCAgNCwgMTMsXG4gICAgOCwgIDYsICA0LCAgMSwgIDMsIDExLCAxNSwgIDAsICA1LCAxMiwgIDIsIDEzLCAgOSwgIDcsIDEwLCAxNCxcbiAgICAxMiwgMTUsIDEwLCAgNCwgIDEsICA1LCAgOCwgIDcsICA2LCAgMiwgMTMsIDE0LCAgMCwgIDMsICA5LCAxMV07XG52YXIgc2wgPSBbXG4gICAgIDExLCAxNCwgMTUsIDEyLCAgNSwgIDgsICA3LCAgOSwgMTEsIDEzLCAxNCwgMTUsICA2LCAgNywgIDksICA4LFxuICAgIDcsIDYsICAgOCwgMTMsIDExLCAgOSwgIDcsIDE1LCAgNywgMTIsIDE1LCAgOSwgMTEsICA3LCAxMywgMTIsXG4gICAgMTEsIDEzLCAgNiwgIDcsIDE0LCAgOSwgMTMsIDE1LCAxNCwgIDgsIDEzLCAgNiwgIDUsIDEyLCAgNywgIDUsXG4gICAgICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCAgOSwgIDgsICA5LCAxNCwgIDUsICA2LCAgOCwgIDYsICA1LCAxMixcbiAgICA5LCAxNSwgIDUsIDExLCAgNiwgIDgsIDEzLCAxMiwgIDUsIDEyLCAxMywgMTQsIDExLCAgOCwgIDUsICA2IF07XG52YXIgc3IgPSBbXG4gICAgOCwgIDksICA5LCAxMSwgMTMsIDE1LCAxNSwgIDUsICA3LCAgNywgIDgsIDExLCAxNCwgMTQsIDEyLCAgNixcbiAgICA5LCAxMywgMTUsICA3LCAxMiwgIDgsICA5LCAxMSwgIDcsICA3LCAxMiwgIDcsICA2LCAxNSwgMTMsIDExLFxuICAgIDksICA3LCAxNSwgMTEsICA4LCAgNiwgIDYsIDE0LCAxMiwgMTMsICA1LCAxNCwgMTMsIDEzLCAgNywgIDUsXG4gICAgMTUsICA1LCAgOCwgMTEsIDE0LCAxNCwgIDYsIDE0LCAgNiwgIDksIDEyLCAgOSwgMTIsICA1LCAxNSwgIDgsXG4gICAgOCwgIDUsIDEyLCAgOSwgMTIsICA1LCAxNCwgIDYsICA4LCAxMywgIDYsICA1LCAxNSwgMTMsIDExLCAxMSBdO1xuXG52YXIgaGwgPSAgWyAweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXTtcbnZhciBociA9ICBbIDB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdO1xuXG52YXIgYnl0ZXNUb1dvcmRzID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHZhciB3b3JkcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgYiA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKywgYiArPSA4KSB7XG4gICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgfVxuICByZXR1cm4gd29yZHM7XG59O1xuXG52YXIgd29yZHNUb0J5dGVzID0gZnVuY3Rpb24gKHdvcmRzKSB7XG4gIHZhciBieXRlcyA9IFtdO1xuICBmb3IgKHZhciBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpIHtcbiAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG52YXIgcHJvY2Vzc0Jsb2NrID0gZnVuY3Rpb24gKEgsIE0sIG9mZnNldCkge1xuXG4gIC8vIFN3YXAgZW5kaWFuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG4gICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuICAgIC8vIFN3YXBcbiAgICBNW29mZnNldF9pXSA9IChcbiAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG4gICAgKTtcbiAgfVxuXG4gIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gIHZhciBhbCwgYmwsIGNsLCBkbCwgZWw7XG4gIHZhciBhciwgYnIsIGNyLCBkciwgZXI7XG5cbiAgYXIgPSBhbCA9IEhbMF07XG4gIGJyID0gYmwgPSBIWzFdO1xuICBjciA9IGNsID0gSFsyXTtcbiAgZHIgPSBkbCA9IEhbM107XG4gIGVyID0gZWwgPSBIWzRdO1xuICAvLyBDb21wdXRhdGlvblxuICB2YXIgdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdCA9IChhbCArICBNW29mZnNldCt6bFtpXV0pfDA7XG4gICAgaWYgKGk8MTYpe1xuICAgICAgICB0ICs9ICBmMShibCxjbCxkbCkgKyBobFswXTtcbiAgICB9IGVsc2UgaWYgKGk8MzIpIHtcbiAgICAgICAgdCArPSAgZjIoYmwsY2wsZGwpICsgaGxbMV07XG4gICAgfSBlbHNlIGlmIChpPDQ4KSB7XG4gICAgICAgIHQgKz0gIGYzKGJsLGNsLGRsKSArIGhsWzJdO1xuICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuICAgICAgICB0ICs9ICBmNChibCxjbCxkbCkgKyBobFszXTtcbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICAgIHQgKz0gIGY1KGJsLGNsLGRsKSArIGhsWzRdO1xuICAgIH1cbiAgICB0ID0gdHwwO1xuICAgIHQgPSAgcm90bCh0LHNsW2ldKTtcbiAgICB0ID0gKHQrZWwpfDA7XG4gICAgYWwgPSBlbDtcbiAgICBlbCA9IGRsO1xuICAgIGRsID0gcm90bChjbCwgMTApO1xuICAgIGNsID0gYmw7XG4gICAgYmwgPSB0O1xuXG4gICAgdCA9IChhciArIE1bb2Zmc2V0K3pyW2ldXSl8MDtcbiAgICBpZiAoaTwxNil7XG4gICAgICAgIHQgKz0gIGY1KGJyLGNyLGRyKSArIGhyWzBdO1xuICAgIH0gZWxzZSBpZiAoaTwzMikge1xuICAgICAgICB0ICs9ICBmNChicixjcixkcikgKyBoclsxXTtcbiAgICB9IGVsc2UgaWYgKGk8NDgpIHtcbiAgICAgICAgdCArPSAgZjMoYnIsY3IsZHIpICsgaHJbMl07XG4gICAgfSBlbHNlIGlmIChpPDY0KSB7XG4gICAgICAgIHQgKz0gIGYyKGJyLGNyLGRyKSArIGhyWzNdO1xuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgICAgdCArPSAgZjEoYnIsY3IsZHIpICsgaHJbNF07XG4gICAgfVxuICAgIHQgPSB0fDA7XG4gICAgdCA9ICByb3RsKHQsc3JbaV0pIDtcbiAgICB0ID0gKHQrZXIpfDA7XG4gICAgYXIgPSBlcjtcbiAgICBlciA9IGRyO1xuICAgIGRyID0gcm90bChjciwgMTApO1xuICAgIGNyID0gYnI7XG4gICAgYnIgPSB0O1xuICB9XG4gIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG4gIHQgICAgPSAoSFsxXSArIGNsICsgZHIpfDA7XG4gIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpfDA7XG4gIEhbMl0gPSAoSFszXSArIGVsICsgYXIpfDA7XG4gIEhbM10gPSAoSFs0XSArIGFsICsgYnIpfDA7XG4gIEhbNF0gPSAoSFswXSArIGJsICsgY3IpfDA7XG4gIEhbMF0gPSAgdDtcbn07XG5cbmZ1bmN0aW9uIGYxKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoeSkgXiAoeikpO1xufVxuXG5mdW5jdGlvbiBmMih4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSYoeSkpIHwgKCh+eCkmKHopKSk7XG59XG5cbmZ1bmN0aW9uIGYzKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSk7XG59XG5cbmZ1bmN0aW9uIGY0KHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkmKH4oeikpKSk7XG59XG5cbmZ1bmN0aW9uIGY1KHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoKHkpIHwofih6KSkpKTtcbn1cblxuZnVuY3Rpb24gcm90bCh4LG4pIHtcbiAgcmV0dXJuICh4PDxuKSB8ICh4Pj4+KDMyLW4pKTtcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwKG1lc3NhZ2UpIHtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3NiwgMHhDM0QyRTFGMF07XG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09ICdzdHJpbmcnKVxuICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICd1dGY4Jyk7XG5cbiAgdmFyIG0gPSBieXRlc1RvV29yZHMobWVzc2FnZSk7XG5cbiAgdmFyIG5CaXRzTGVmdCA9IG1lc3NhZ2UubGVuZ3RoICogODtcbiAgdmFyIG5CaXRzVG90YWwgPSBtZXNzYWdlLmxlbmd0aCAqIDg7XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgbVtuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuICBtWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG4gICAgICAoKChuQml0c1RvdGFsIDw8IDgpICB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgobkJpdHNUb3RhbCA8PCAyNCkgfCAobkJpdHNUb3RhbCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG4gICk7XG5cbiAgZm9yICh2YXIgaT0wIDsgaTxtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIHByb2Nlc3NCbG9jayhILCBtLCBpKTtcbiAgfVxuXG4gIC8vIFN3YXAgZW5kaWFuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgIHZhciBIX2kgPSBIW2ldO1xuXG4gICAgLy8gU3dhcFxuICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuICB9XG5cbiAgdmFyIGRpZ2VzdGJ5dGVzID0gd29yZHNUb0J5dGVzKEgpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihkaWdlc3RieXRlcyk7XG59XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJ1ZmZlcikge1xuXG4gIC8vcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpIC8vbmV3IFVpbnQzMkFycmF5KGJsb2NrU2l6ZS80KVxuICAgIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICAgIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICAgIHRoaXMuX2xlbiA9IDBcbiAgICB0aGlzLl9zID0gMFxuICB9XG5cbiAgSGFzaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zID0gMFxuICAgIHRoaXMuX2xlbiA9IDBcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGVuYyA9IGVuYyB8fCBcInV0ZjhcIlxuICAgICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICAgIH1cblxuICAgIHZhciBsID0gdGhpcy5fbGVuICs9IGRhdGEubGVuZ3RoXG4gICAgdmFyIHMgPSB0aGlzLl9zID0gKHRoaXMuX3MgfHwgMClcbiAgICB2YXIgZiA9IDBcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYmxvY2tcblxuICAgIHdoaWxlIChzIDwgbCkge1xuICAgICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICAgIHZhciBjaCA9ICh0IC0gZilcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgICB9XG5cbiAgICAgIHMgKz0gY2hcbiAgICAgIGYgKz0gY2hcblxuICAgICAgaWYgKChzICUgdGhpcy5fYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoYnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zID0gc1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICAgIHZhciBsID0gdGhpcy5fbGVuICogOFxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXQgMSB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlXG4gICAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAgIC8vIGFuZCB0aGVuIGsgemVybyBiaXRzLCB3aGVyZSBrIGlzIHRoZSBzbWFsbGVzdCBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsICsgMSArIGspID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplICsgMSlcblxuICAgIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgICB9XG5cbiAgICAvLyB0byB0aGlzIGFwcGVuZCB0aGUgYmxvY2sgd2hpY2ggaXMgZXF1YWwgdG8gdGhlIG51bWJlciBsIHdyaXR0ZW4gaW4gYmluYXJ5XG4gICAgLy8gVE9ETzogaGFuZGxlIGNhc2Ugd2hlcmUgbCBpcyA+IE1hdGgucG93KDIsIDI5KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gICAgdmFyIGhhc2ggPSB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spIHx8IHRoaXMuX2hhc2goKVxuXG4gICAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxuICB9XG5cbiAgcmV0dXJuIEhhc2hcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NoYS5qcy9oYXNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFsZykge1xuICB2YXIgQWxnID0gZXhwb3J0c1thbGddXG4gIGlmKCFBbGcpIHRocm93IG5ldyBFcnJvcihhbGcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG4gIHJldHVybiBuZXcgQWxnKClcbn1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIEhhc2ggICA9IHJlcXVpcmUoJy4vaGFzaCcpKEJ1ZmZlcilcblxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJykoQnVmZmVyLCBIYXNoKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpKEJ1ZmZlciwgSGFzaClcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKShCdWZmZXIsIEhhc2gpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaGEuanMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCdWZmZXIsIEhhc2gpIHtcblxuICB2YXIgQSA9IDB8MFxuICB2YXIgQiA9IDR8MFxuICB2YXIgQyA9IDh8MFxuICB2YXIgRCA9IDEyfDBcbiAgdmFyIEUgPSAxNnwwXG5cbiAgdmFyIFcgPSBuZXcgKHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogSW50MzJBcnJheSkoODApXG5cbiAgdmFyIFBPT0wgPSBbXVxuXG4gIGZ1bmN0aW9uIFNoYTEgKCkge1xuICAgIGlmKFBPT0wubGVuZ3RoKVxuICAgICAgcmV0dXJuIFBPT0wucG9wKCkuaW5pdCgpXG5cbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBTaGExKSkgcmV0dXJuIG5ldyBTaGExKClcbiAgICB0aGlzLl93ID0gV1xuICAgIEhhc2guY2FsbCh0aGlzLCAxNio0LCAxNCo0KVxuXG4gICAgdGhpcy5faCA9IG51bGxcbiAgICB0aGlzLmluaXQoKVxuICB9XG5cbiAgaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuICBTaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gICAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICAgIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gICAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICAgIEhhc2gucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBTaGExLnByb3RvdHlwZS5fUE9PTCA9IFBPT0xcbiAgU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChYKSB7XG5cbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgX2EsIF9iLCBfYywgX2QsIF9lXG5cbiAgICBhID0gX2EgPSB0aGlzLl9hXG4gICAgYiA9IF9iID0gdGhpcy5fYlxuICAgIGMgPSBfYyA9IHRoaXMuX2NcbiAgICBkID0gX2QgPSB0aGlzLl9kXG4gICAgZSA9IF9lID0gdGhpcy5fZVxuXG4gICAgdmFyIHcgPSB0aGlzLl93XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgICAgdmFyIFcgPSB3W2pdID0gaiA8IDE2ID8gWC5yZWFkSW50MzJCRShqKjQpXG4gICAgICAgIDogcm9sKHdbaiAtIDNdIF4gd1tqIC0gIDhdIF4gd1tqIC0gMTRdIF4gd1tqIC0gMTZdLCAxKVxuXG4gICAgICB2YXIgdCA9IGFkZChcbiAgICAgICAgYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgIGFkZChhZGQoZSwgVyksIHNoYTFfa3QoaikpXG4gICAgICApXG5cbiAgICAgIGUgPSBkXG4gICAgICBkID0gY1xuICAgICAgYyA9IHJvbChiLCAzMClcbiAgICAgIGIgPSBhXG4gICAgICBhID0gdFxuICAgIH1cblxuICAgIHRoaXMuX2EgPSBhZGQoYSwgX2EpXG4gICAgdGhpcy5fYiA9IGFkZChiLCBfYilcbiAgICB0aGlzLl9jID0gYWRkKGMsIF9jKVxuICAgIHRoaXMuX2QgPSBhZGQoZCwgX2QpXG4gICAgdGhpcy5fZSA9IGFkZChlLCBfZSlcbiAgfVxuXG4gIFNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKFBPT0wubGVuZ3RoIDwgMTAwKSBQT09MLnB1c2godGhpcylcbiAgICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG4gICAgLy9jb25zb2xlLmxvZyh0aGlzLl9hfDAsIHRoaXMuX2J8MCwgdGhpcy5fY3wwLCB0aGlzLl9kfDAsIHRoaXMuX2V8MClcbiAgICBILndyaXRlSW50MzJCRSh0aGlzLl9hfDAsIEEpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYnwwLCBCKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2N8MCwgQylcbiAgICBILndyaXRlSW50MzJCRSh0aGlzLl9kfDAsIEQpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZXwwLCBFKVxuICAgIHJldHVybiBIXG4gIH1cblxuICAvKlxuICAgKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICAgKiBpdGVyYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZCkge1xuICAgIGlmKHQgPCAyMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpO1xuICAgIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gICAgcmV0dXJuIGIgXiBjIF4gZDtcbiAgfVxuXG4gIC8qXG4gICAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgYWRkaXRpdmUgY29uc3RhbnQgZm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gc2hhMV9rdCh0KSB7XG4gICAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG4gIH1cblxuICAvKlxuICAgKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gICAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gICAqIC8vZG9taW5pY3RhcnI6IHRoaXMgaXMgMTAgeWVhcnMgb2xkLCBzbyBtYXliZSB0aGlzIGNhbiBiZSBkcm9wcGVkPylcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGFkZCh4LCB5KSB7XG4gICAgcmV0dXJuICh4ICsgeSApIHwgMFxuICAvL2xldHMgc2VlIGhvdyB0aGlzIGdvZXMgb24gdGVzdGxpbmcuXG4gIC8vICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICAvLyAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICAvLyAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG4gIH1cblxuICAvKlxuICAgKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gICAqL1xuICBmdW5jdGlvbiByb2wobnVtLCBjbnQpIHtcbiAgICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG4gIH1cblxuICByZXR1cm4gU2hhMVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2hhLmpzL3NoYTEuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCdWZmZXIsIEhhc2gpIHtcblxuICB2YXIgSyA9IFtcbiAgICAgIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gICAgICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAgICAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgICAgIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gICAgICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAgICAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgICAgIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gICAgICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAgICAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgICAgIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gICAgICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAgICAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgICAgIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gICAgICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAgICAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgICAgIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbiAgICBdXG5cbiAgdmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbiAgZnVuY3Rpb24gU2hhMjU2KCkge1xuICAgIHRoaXMuaW5pdCgpXG5cbiAgICB0aGlzLl93ID0gVyAvL25ldyBBcnJheSg2NClcblxuICAgIEhhc2guY2FsbCh0aGlzLCAxNio0LCAxNCo0KVxuICB9XG5cbiAgaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2EgPSAweDZhMDllNjY3fDBcbiAgICB0aGlzLl9iID0gMHhiYjY3YWU4NXwwXG4gICAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJ8MFxuICAgIHRoaXMuX2QgPSAweGE1NGZmNTNhfDBcbiAgICB0aGlzLl9lID0gMHg1MTBlNTI3ZnwwXG4gICAgdGhpcy5fZiA9IDB4OWIwNTY4OGN8MFxuICAgIHRoaXMuX2cgPSAweDFmODNkOWFifDBcbiAgICB0aGlzLl9oID0gMHg1YmUwY2QxOXwwXG5cbiAgICB0aGlzLl9sZW4gPSB0aGlzLl9zID0gMFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZ1bmN0aW9uIFMgKFgsIG4pIHtcbiAgICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpO1xuICB9XG5cbiAgZnVuY3Rpb24gUiAoWCwgbikge1xuICAgIHJldHVybiAoWCA+Pj4gbik7XG4gIH1cblxuICBmdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xuICB9XG5cbiAgZnVuY3Rpb24gTWFqICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xuICB9XG5cbiAgZnVuY3Rpb24gU2lnbWEwMjU2ICh4KSB7XG4gICAgcmV0dXJuIChTKHgsIDIpIF4gUyh4LCAxMykgXiBTKHgsIDIyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBTaWdtYTEyNTYgKHgpIHtcbiAgICByZXR1cm4gKFMoeCwgNikgXiBTKHgsIDExKSBeIFMoeCwgMjUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdhbW1hMDI1NiAoeCkge1xuICAgIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBHYW1tYTEyNTYgKHgpIHtcbiAgICByZXR1cm4gKFMoeCwgMTcpIF4gUyh4LCAxOSkgXiBSKHgsIDEwKSk7XG4gIH1cblxuICBTaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihNKSB7XG5cbiAgICB2YXIgVyA9IHRoaXMuX3dcbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaFxuICAgIHZhciBUMSwgVDJcblxuICAgIGEgPSB0aGlzLl9hIHwgMFxuICAgIGIgPSB0aGlzLl9iIHwgMFxuICAgIGMgPSB0aGlzLl9jIHwgMFxuICAgIGQgPSB0aGlzLl9kIHwgMFxuICAgIGUgPSB0aGlzLl9lIHwgMFxuICAgIGYgPSB0aGlzLl9mIHwgMFxuICAgIGcgPSB0aGlzLl9nIHwgMFxuICAgIGggPSB0aGlzLl9oIHwgMFxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICB2YXIgdyA9IFdbal0gPSBqIDwgMTZcbiAgICAgICAgPyBNLnJlYWRJbnQzMkJFKGogKiA0KVxuICAgICAgICA6IEdhbW1hMTI1NihXW2ogLSAyXSkgKyBXW2ogLSA3XSArIEdhbW1hMDI1NihXW2ogLSAxNV0pICsgV1tqIC0gMTZdXG5cbiAgICAgIFQxID0gaCArIFNpZ21hMTI1NihlKSArIENoKGUsIGYsIGcpICsgS1tqXSArIHdcblxuICAgICAgVDIgPSBTaWdtYTAyNTYoYSkgKyBNYWooYSwgYiwgYyk7XG4gICAgICBoID0gZzsgZyA9IGY7IGYgPSBlOyBlID0gZCArIFQxOyBkID0gYzsgYyA9IGI7IGIgPSBhOyBhID0gVDEgKyBUMjtcbiAgICB9XG5cbiAgICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcblxuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEggPSBuZXcgQnVmZmVyKDMyKVxuXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgIDApXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgIDQpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYywgIDgpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgICByZXR1cm4gSFxuICB9XG5cbiAgcmV0dXJuIFNoYTI1NlxuXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaGEuanMvc2hhMjU2LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQnVmZmVyLCBIYXNoKSB7XG4gIHZhciBLID0gW1xuICAgIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gICAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAgIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gICAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAgIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gICAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAgIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gICAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAgIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gICAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAgIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gICAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAgIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gICAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAgIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gICAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAgIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gICAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAgIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gICAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAgIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gICAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAgIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gICAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAgIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gICAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAgIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbiAgXVxuXG4gIHZhciBXID0gbmV3IEFycmF5KDE2MClcblxuICBmdW5jdGlvbiBTaGE1MTIoKSB7XG4gICAgdGhpcy5pbml0KClcbiAgICB0aGlzLl93ID0gV1xuXG4gICAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxuICB9XG5cbiAgaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG4gIFNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2EgPSAweDZhMDllNjY3fDBcbiAgICB0aGlzLl9iID0gMHhiYjY3YWU4NXwwXG4gICAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJ8MFxuICAgIHRoaXMuX2QgPSAweGE1NGZmNTNhfDBcbiAgICB0aGlzLl9lID0gMHg1MTBlNTI3ZnwwXG4gICAgdGhpcy5fZiA9IDB4OWIwNTY4OGN8MFxuICAgIHRoaXMuX2cgPSAweDFmODNkOWFifDBcbiAgICB0aGlzLl9oID0gMHg1YmUwY2QxOXwwXG5cbiAgICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDh8MFxuICAgIHRoaXMuX2JsID0gMHg4NGNhYTczYnwwXG4gICAgdGhpcy5fY2wgPSAweGZlOTRmODJifDBcbiAgICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjF8MFxuICAgIHRoaXMuX2VsID0gMHhhZGU2ODJkMXwwXG4gICAgdGhpcy5fZmwgPSAweDJiM2U2YzFmfDBcbiAgICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmJ8MFxuICAgIHRoaXMuX2hsID0gMHgxMzdlMjE3OXwwXG5cbiAgICB0aGlzLl9sZW4gPSB0aGlzLl9zID0gMFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZ1bmN0aW9uIFMgKFgsIFhsLCBuKSB7XG4gICAgcmV0dXJuIChYID4+PiBuKSB8IChYbCA8PCAoMzIgLSBuKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuICgoeCAmIHkpIF4gKCh+eCkgJiB6KSk7XG4gIH1cblxuICBmdW5jdGlvbiBNYWogKHgsIHksIHopIHtcbiAgICByZXR1cm4gKCh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KSk7XG4gIH1cblxuICBTaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihNKSB7XG5cbiAgICB2YXIgVyA9IHRoaXMuX3dcbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaFxuICAgIHZhciBhbCwgYmwsIGNsLCBkbCwgZWwsIGZsLCBnbCwgaGxcblxuICAgIGEgPSB0aGlzLl9hIHwgMFxuICAgIGIgPSB0aGlzLl9iIHwgMFxuICAgIGMgPSB0aGlzLl9jIHwgMFxuICAgIGQgPSB0aGlzLl9kIHwgMFxuICAgIGUgPSB0aGlzLl9lIHwgMFxuICAgIGYgPSB0aGlzLl9mIHwgMFxuICAgIGcgPSB0aGlzLl9nIHwgMFxuICAgIGggPSB0aGlzLl9oIHwgMFxuXG4gICAgYWwgPSB0aGlzLl9hbCB8IDBcbiAgICBibCA9IHRoaXMuX2JsIHwgMFxuICAgIGNsID0gdGhpcy5fY2wgfCAwXG4gICAgZGwgPSB0aGlzLl9kbCB8IDBcbiAgICBlbCA9IHRoaXMuX2VsIHwgMFxuICAgIGZsID0gdGhpcy5fZmwgfCAwXG4gICAgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgICBobCA9IHRoaXMuX2hsIHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICB2YXIgaiA9IGkgKiAyXG5cbiAgICAgIHZhciBXaSwgV2lsXG5cbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgV2kgPSBXW2pdID0gTS5yZWFkSW50MzJCRShqICogNClcbiAgICAgICAgV2lsID0gV1tqICsgMV0gPSBNLnJlYWRJbnQzMkJFKGogKiA0ICsgNClcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggID0gV1tqIC0gMTUqMl1cbiAgICAgICAgdmFyIHhsID0gV1tqIC0gMTUqMiArIDFdXG4gICAgICAgIHZhciBnYW1tYTAgID0gUyh4LCB4bCwgMSkgXiBTKHgsIHhsLCA4KSBeICh4ID4+PiA3KVxuICAgICAgICB2YXIgZ2FtbWEwbCA9IFMoeGwsIHgsIDEpIF4gUyh4bCwgeCwgOCkgXiBTKHhsLCB4LCA3KVxuXG4gICAgICAgIHggID0gV1tqIC0gMioyXVxuICAgICAgICB4bCA9IFdbaiAtIDIqMiArIDFdXG4gICAgICAgIHZhciBnYW1tYTEgID0gUyh4LCB4bCwgMTkpIF4gUyh4bCwgeCwgMjkpIF4gKHggPj4+IDYpXG4gICAgICAgIHZhciBnYW1tYTFsID0gUyh4bCwgeCwgMTkpIF4gUyh4LCB4bCwgMjkpIF4gUyh4bCwgeCwgNilcblxuICAgICAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICAgICAgdmFyIFdpNyAgPSBXW2ogLSA3KjJdXG4gICAgICAgIHZhciBXaTdsID0gV1tqIC0gNyoyICsgMV1cblxuICAgICAgICB2YXIgV2kxNiAgPSBXW2ogLSAxNioyXVxuICAgICAgICB2YXIgV2kxNmwgPSBXW2ogLSAxNioyICsgMV1cblxuICAgICAgICBXaWwgPSBnYW1tYTBsICsgV2k3bFxuICAgICAgICBXaSAgPSBnYW1tYTAgICsgV2k3ICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMGwgPj4+IDApID8gMSA6IDApXG4gICAgICAgIFdpbCA9IFdpbCArIGdhbW1hMWxcbiAgICAgICAgV2kgID0gV2kgICsgZ2FtbWExICArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKVxuICAgICAgICBXaWwgPSBXaWwgKyBXaTE2bFxuICAgICAgICBXaSAgPSBXaSAgKyBXaTE2ICsgKChXaWwgPj4+IDApIDwgKFdpMTZsID4+PiAwKSA/IDEgOiAwKVxuXG4gICAgICAgIFdbal0gPSBXaVxuICAgICAgICBXW2ogKyAxXSA9IFdpbFxuICAgICAgfVxuXG4gICAgICB2YXIgbWFqID0gTWFqKGEsIGIsIGMpXG4gICAgICB2YXIgbWFqbCA9IE1haihhbCwgYmwsIGNsKVxuXG4gICAgICB2YXIgc2lnbWEwaCA9IFMoYSwgYWwsIDI4KSBeIFMoYWwsIGEsIDIpIF4gUyhhbCwgYSwgNylcbiAgICAgIHZhciBzaWdtYTBsID0gUyhhbCwgYSwgMjgpIF4gUyhhLCBhbCwgMikgXiBTKGEsIGFsLCA3KVxuICAgICAgdmFyIHNpZ21hMWggPSBTKGUsIGVsLCAxNCkgXiBTKGUsIGVsLCAxOCkgXiBTKGVsLCBlLCA5KVxuICAgICAgdmFyIHNpZ21hMWwgPSBTKGVsLCBlLCAxNCkgXiBTKGVsLCBlLCAxOCkgXiBTKGUsIGVsLCA5KVxuXG4gICAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG4gICAgICB2YXIgS2kgPSBLW2pdXG4gICAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgICAgdmFyIGNoID0gQ2goZSwgZiwgZylcbiAgICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgICB2YXIgdDFsID0gaGwgKyBzaWdtYTFsXG4gICAgICB2YXIgdDEgPSBoICsgc2lnbWExaCArICgodDFsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMClcbiAgICAgIHQxbCA9IHQxbCArIGNobFxuICAgICAgdDEgPSB0MSArIGNoICsgKCh0MWwgPj4+IDApIDwgKGNobCA+Pj4gMCkgPyAxIDogMClcbiAgICAgIHQxbCA9IHQxbCArIEtpbFxuICAgICAgdDEgPSB0MSArIEtpICsgKCh0MWwgPj4+IDApIDwgKEtpbCA+Pj4gMCkgPyAxIDogMClcbiAgICAgIHQxbCA9IHQxbCArIFdpbFxuICAgICAgdDEgPSB0MSArIFdpICsgKCh0MWwgPj4+IDApIDwgKFdpbCA+Pj4gMCkgPyAxIDogMClcblxuICAgICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICAgIHZhciB0MmwgPSBzaWdtYTBsICsgbWFqbFxuICAgICAgdmFyIHQyID0gc2lnbWEwaCArIG1haiArICgodDJsID4+PiAwKSA8IChzaWdtYTBsID4+PiAwKSA/IDEgOiAwKVxuXG4gICAgICBoICA9IGdcbiAgICAgIGhsID0gZ2xcbiAgICAgIGcgID0gZlxuICAgICAgZ2wgPSBmbFxuICAgICAgZiAgPSBlXG4gICAgICBmbCA9IGVsXG4gICAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgICBlICA9IChkICsgdDEgKyAoKGVsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgICAgZCAgPSBjXG4gICAgICBkbCA9IGNsXG4gICAgICBjICA9IGJcbiAgICAgIGNsID0gYmxcbiAgICAgIGIgID0gYVxuICAgICAgYmwgPSBhbFxuICAgICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICAgIGEgID0gKHQxICsgdDIgKyAoKGFsID4+PiAwKSA8ICh0MWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB9XG5cbiAgICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcbiAgICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcbiAgICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcbiAgICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICAgIHRoaXMuX2EgPSAodGhpcy5fYSArIGEgKyAoKHRoaXMuX2FsID4+PiAwKSA8IChhbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2IgPSAodGhpcy5fYiArIGIgKyAoKHRoaXMuX2JsID4+PiAwKSA8IChibCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2MgPSAodGhpcy5fYyArIGMgKyAoKHRoaXMuX2NsID4+PiAwKSA8IChjbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2QgPSAodGhpcy5fZCArIGQgKyAoKHRoaXMuX2RsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2UgPSAodGhpcy5fZSArIGUgKyAoKHRoaXMuX2VsID4+PiAwKSA8IChlbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2YgPSAodGhpcy5fZiArIGYgKyAoKHRoaXMuX2ZsID4+PiAwKSA8IChmbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2cgPSAodGhpcy5fZyArIGcgKyAoKHRoaXMuX2dsID4+PiAwKSA8IChnbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIHRoaXMuX2ggPSAodGhpcy5faCArIGggKyAoKHRoaXMuX2hsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB9XG5cbiAgU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSCA9IG5ldyBCdWZmZXIoNjQpXG5cbiAgICBmdW5jdGlvbiB3cml0ZUludDY0QkUoaCwgbCwgb2Zmc2V0KSB7XG4gICAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICAgIH1cblxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9hLCB0aGlzLl9hbCwgMClcbiAgICB3cml0ZUludDY0QkUodGhpcy5fYiwgdGhpcy5fYmwsIDgpXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2MsIHRoaXMuX2NsLCAxNilcbiAgICB3cml0ZUludDY0QkUodGhpcy5fZCwgdGhpcy5fZGwsIDI0KVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9lLCB0aGlzLl9lbCwgMzIpXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2YsIHRoaXMuX2ZsLCA0MClcbiAgICB3cml0ZUludDY0QkUodGhpcy5fZywgdGhpcy5fZ2wsIDQ4KVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9oLCB0aGlzLl9obCwgNTYpXG5cbiAgICByZXR1cm4gSFxuICB9XG5cbiAgcmV0dXJuIFNoYTUxMlxuXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaGEuanMvc2hhNTEyLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRoMzI6IHJlcXVpcmUoXCIuL3h4aGFzaFwiKVxuLFx0aDY0OiByZXF1aXJlKFwiLi94eGhhc2g2NFwiKVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34veHhoYXNoanMvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbnh4SGFzaCBpbXBsZW1lbnRhdGlvbiBpbiBwdXJlIEphdmFzY3JpcHRcblxuQ29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFVJTlQzMiA9IHJlcXVpcmUoJ2N1aW50JykuVUlOVDMyXG5cbi8qXG5cdE1lcmdlZCB0aGlzIHNlcXVlbmNlIG9mIG1ldGhvZCBjYWxscyBhcyBpdCBzcGVlZHMgdXBcblx0dGhlIGNhbGN1bGF0aW9ucyBieSBhIGZhY3RvciBvZiAyXG4gKi9cbi8vIHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTMyXzIpICkucm90bCgxMykubXVsdGlwbHkoUFJJTUUzMl8xKTtcblVJTlQzMi5wcm90b3R5cGUueHhoX3VwZGF0ZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcblx0dmFyIGIwMCA9IFBSSU1FMzJfMi5fbG93XG5cdHZhciBiMTYgPSBQUklNRTMyXzIuX2hpZ2hcblxuXHR2YXIgYzE2LCBjMDBcblx0YzAwID0gbG93ICogYjAwXG5cdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRjMTYgKz0gaGlnaCAqIGIwMFxuXHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0YzE2ICs9IGxvdyAqIGIxNlxuXG5cdHZhciBhMDAgPSB0aGlzLl9sb3cgKyAoYzAwICYgMHhGRkZGKVxuXHR2YXIgYTE2ID0gYTAwID4+PiAxNlxuXG5cdGExNiArPSB0aGlzLl9oaWdoICsgKGMxNiAmIDB4RkZGRilcblxuXHR2YXIgdiA9IChhMTYgPDwgMTYpIHwgKGEwMCAmIDB4RkZGRilcblx0diA9ICh2IDw8IDEzKSB8ICh2ID4+PiAxOSlcblxuXHRhMDAgPSB2ICYgMHhGRkZGXG5cdGExNiA9IHYgPj4+IDE2XG5cblx0YjAwID0gUFJJTUUzMl8xLl9sb3dcblx0YjE2ID0gUFJJTUUzMl8xLl9oaWdoXG5cblx0YzAwID0gYTAwICogYjAwXG5cdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRjMTYgKz0gYTE2ICogYjAwXG5cdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRjMTYgKz0gYTAwICogYjE2XG5cblx0dGhpcy5fbG93ID0gYzAwICYgMHhGRkZGXG5cdHRoaXMuX2hpZ2ggPSBjMTYgJiAweEZGRkZcbn1cblxuLypcbiAqIENvbnN0YW50c1xuICovXG52YXIgUFJJTUUzMl8xID0gVUlOVDMyKCAnMjY1NDQzNTc2MScgKVxudmFyIFBSSU1FMzJfMiA9IFVJTlQzMiggJzIyNDY4MjI1MTknIClcbnZhciBQUklNRTMyXzMgPSBVSU5UMzIoICczMjY2NDg5OTE3JyApXG52YXIgUFJJTUUzMl80ID0gVUlOVDMyKCAgJzY2ODI2NTI2MycgKVxudmFyIFBSSU1FMzJfNSA9IFVJTlQzMiggICczNzQ3NjEzOTMnIClcblxuLyoqXG4qIENvbnZlcnQgc3RyaW5nIHRvIHByb3BlciBVVEYtOCBhcnJheVxuKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZ1xuKiBAcmV0dXJucyB7VWludDhBcnJheX0gVVRGOCBhcnJheSBpcyByZXR1cm5lZCBhcyB1aW50OCBhcnJheVxuKi9cbmZ1bmN0aW9uIHRvVVRGOEFycmF5IChzdHIpIHtcblx0dmFyIHV0ZjggPSBbXVxuXHRmb3IgKHZhciBpPTAsIG49c3RyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpXG5cdFx0aWYgKGNoYXJjb2RlIDwgMHg4MCkgdXRmOC5wdXNoKGNoYXJjb2RlKVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcblx0XHRcdHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ZDgwMCB8fCBjaGFyY29kZSA+PSAweGUwMDApIHtcblx0XHRcdHV0ZjgucHVzaCgweGUwIHwgKGNoYXJjb2RlID4+IDEyKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdGVsc2Uge1xuXHRcdFx0aSsrO1xuXHRcdFx0Ly8gVVRGLTE2IGVuY29kZXMgMHgxMDAwMC0weDEwRkZGRiBieVxuXHRcdFx0Ly8gc3VidHJhY3RpbmcgMHgxMDAwMCBhbmQgc3BsaXR0aW5nIHRoZVxuXHRcdFx0Ly8gMjAgYml0cyBvZiAweDAtMHhGRkZGRiBpbnRvIHR3byBoYWx2ZXNcblx0XHRcdGNoYXJjb2RlID0gMHgxMDAwMCArICgoKGNoYXJjb2RlICYgMHgzZmYpPDwxMClcblx0XHRcdHwgKHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmYpKVxuXHRcdFx0dXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4xOCksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+MTIpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodXRmOClcbn1cblxuLyoqXG4gKiBYWEggb2JqZWN0IHVzZWQgYXMgYSBjb25zdHJ1Y3RvciBvciBhIGZ1bmN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIG9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfFVJTlQzMn0gc2VlZFxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICogb3JcbiAqIEByZXR1cm4ge1VJTlQzMn0geHhIYXNoXG4gKi9cbmZ1bmN0aW9uIFhYSCAoKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG5cdFx0cmV0dXJuIG5ldyBYWEgoIGFyZ3VtZW50c1sxXSApLnVwZGF0ZSggYXJndW1lbnRzWzBdICkuZGlnZXN0KClcblxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgWFhIKSlcblx0XHRyZXR1cm4gbmV3IFhYSCggYXJndW1lbnRzWzBdIClcblxuXHRpbml0LmNhbGwodGhpcywgYXJndW1lbnRzWzBdKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFhYSCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBzZWVkXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gc2VlZCBhcyBhIG51bWJlciBvciBhbiB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuIGZ1bmN0aW9uIGluaXQgKHNlZWQpIHtcblx0dGhpcy5zZWVkID0gc2VlZCBpbnN0YW5jZW9mIFVJTlQzMiA/IHNlZWQuY2xvbmUoKSA6IFVJTlQzMihzZWVkKVxuXHR0aGlzLnYxID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FMzJfMSkuYWRkKFBSSU1FMzJfMilcblx0dGhpcy52MiA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTMyXzIpXG5cdHRoaXMudjMgPSB0aGlzLnNlZWQuY2xvbmUoKVxuXHR0aGlzLnY0ID0gdGhpcy5zZWVkLmNsb25lKCkuc3VidHJhY3QoUFJJTUUzMl8xKVxuXHR0aGlzLnRvdGFsX2xlbiA9IDBcblx0dGhpcy5tZW1zaXplID0gMFxuXHR0aGlzLm1lbW9yeSA9IG51bGxcblxuXHRyZXR1cm4gdGhpc1xufVxuWFhILnByb3RvdHlwZS5pbml0ID0gaW5pdFxuXG4vKipcbiAqIEFkZCBkYXRhIHRvIGJlIGNvbXB1dGVkIGZvciB0aGUgWFhIIGhhc2hcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ9IGlucHV0IGFzIGEgc3RyaW5nIG9yIG5vZGVqcyBCdWZmZXIgb3IgQXJyYXlCdWZmZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuWFhILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09ICdzdHJpbmcnXG5cdHZhciBpc0FycmF5QnVmZmVyXG5cblx0Ly8gQ29udmVydCBhbGwgc3RyaW5ncyB0byB1dGYtOCBmaXJzdCAoaXNzdWUgIzUpXG5cdGlmIChpc1N0cmluZykge1xuXHRcdGlucHV0ID0gdG9VVEY4QXJyYXkoaW5wdXQpXG5cdFx0aXNTdHJpbmcgPSBmYWxzZVxuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdH1cblxuXHRpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG5cdHtcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHRcdGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuXHR9XG5cblx0dmFyIHAgPSAwXG5cdHZhciBsZW4gPSBpbnB1dC5sZW5ndGhcblx0dmFyIGJFbmQgPSBwICsgbGVuXG5cblx0aWYgKGxlbiA9PSAwKSByZXR1cm4gdGhpc1xuXG5cdHRoaXMudG90YWxfbGVuICs9IGxlblxuXG5cdGlmICh0aGlzLm1lbXNpemUgPT0gMClcblx0e1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgPSAnJ1xuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkgPSBuZXcgVWludDhBcnJheSgxNilcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tZW1vcnkgPSBuZXcgQnVmZmVyKDE2KVxuXHRcdH1cblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgKyBsZW4gPCAxNikgICAvLyBmaWxsIGluIHRtcCBidWZmZXJcblx0e1xuXHRcdC8vIFhYSF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCBsZW4pXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dFxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCBsZW4pLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCBsZW4gKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSArPSBsZW5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSA+IDApICAgLy8gc29tZSBkYXRhIGxlZnQgZnJvbSBwcmV2aW91cyB1cGRhdGVcblx0e1xuXHRcdC8vIFhYSF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCAxNi10aGlzLm1lbXNpemUpO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UoMCwgMTYgLSB0aGlzLm1lbXNpemUpXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIDE2IC0gdGhpcy5tZW1zaXplKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgMTYgLSB0aGlzLm1lbXNpemUgKVxuXHRcdH1cblxuXHRcdHZhciBwMzIgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMilcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdH1cblxuXHRcdHAgKz0gMTYgLSB0aGlzLm1lbXNpemVcblx0XHR0aGlzLm1lbXNpemUgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB0aGlzLm1lbW9yeSA9ICcnXG5cdH1cblxuXHRpZiAocCA8PSBiRW5kIC0gMTYpXG5cdHtcblx0XHR2YXIgbGltaXQgPSBiRW5kIC0gMTZcblxuXHRcdGRvXG5cdFx0e1xuXHRcdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0XHRwICs9IDRcblx0XHR9IHdoaWxlIChwIDw9IGxpbWl0KVxuXHR9XG5cblx0aWYgKHAgPCBiRW5kKVxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSwgcCwgYkVuZC1wKTtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0LnNsaWNlKHApXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KHAsIGJFbmQpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCBwLCBiRW5kIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgPSBiRW5kIC0gcFxuXHR9XG5cblx0cmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBGaW5hbGl6ZSB0aGUgWFhIIGNvbXB1dGF0aW9uLiBUaGUgWFhIIGluc3RhbmNlIGlzIHJlYWR5IGZvciByZXVzZSBmb3IgdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgZGlnZXN0XG4gKiBAcmV0dXJuIHtVSU5UMzJ9IHh4SGFzaFxuICovXG5YWEgucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGlucHV0ID0gdGhpcy5tZW1vcnlcblx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09ICdzdHJpbmcnXG5cdHZhciBwID0gMFxuXHR2YXIgYkVuZCA9IHRoaXMubWVtc2l6ZVxuXHR2YXIgaDMyLCBoXG5cdHZhciB1ID0gbmV3IFVJTlQzMlxuXG5cdGlmICh0aGlzLnRvdGFsX2xlbiA+PSAxNilcblx0e1xuXHRcdGgzMiA9IHRoaXMudjEucm90bCgxKS5hZGQoIHRoaXMudjIucm90bCg3KS5hZGQoIHRoaXMudjMucm90bCgxMikuYWRkKCB0aGlzLnY0LnJvdGwoMTgpICkgKSApXG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0aDMyICA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZCggUFJJTUUzMl81IClcblx0fVxuXG5cdGgzMi5hZGQoIHUuZnJvbU51bWJlcih0aGlzLnRvdGFsX2xlbikgKVxuXG5cdHdoaWxlIChwIDw9IGJFbmQgLSA0KVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdClcblx0XHR9XG5cdFx0aDMyXG5cdFx0XHQuYWRkKCB1Lm11bHRpcGx5KFBSSU1FMzJfMykgKVxuXHRcdFx0LnJvdGwoMTcpXG5cdFx0XHQubXVsdGlwbHkoIFBSSU1FMzJfNCApXG5cdFx0cCArPSA0XG5cdH1cblxuXHR3aGlsZSAocCA8IGJFbmQpXG5cdHtcblx0XHR1LmZyb21CaXRzKCBpc1N0cmluZyA/IGlucHV0LmNoYXJDb2RlQXQocCsrKSA6IGlucHV0W3ArK10sIDAgKVxuXHRcdGgzMlxuXHRcdFx0LmFkZCggdS5tdWx0aXBseShQUklNRTMyXzUpIClcblx0XHRcdC5yb3RsKDExKVxuXHRcdFx0Lm11bHRpcGx5KFBSSU1FMzJfMSlcblx0fVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDE1KVxuXHRoMzIueG9yKGgpLm11bHRpcGx5KFBSSU1FMzJfMilcblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxMylcblx0aDMyLnhvcihoKS5tdWx0aXBseShQUklNRTMyXzMpXG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTYpXG5cdGgzMi54b3IoaClcblxuXHQvLyBSZXNldCB0aGUgc3RhdGVcblx0dGhpcy5pbml0KCB0aGlzLnNlZWQgKVxuXG5cdHJldHVybiBoMzJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBYWEhcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3h4aGFzaGpzL2xpYi94eGhhc2guanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxueHhIYXNoNjQgaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoQykgMjAxNiwgUGllcnJlIEN1cnRvXG5NSVQgbGljZW5zZVxuKi9cbnZhciBVSU5UNjQgPSByZXF1aXJlKCdjdWludCcpLlVJTlQ2NFxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTY0XzEgPSBVSU5UNjQoICcxMTQwMDcxNDc4NTA3NDY5NDc5MScgKVxudmFyIFBSSU1FNjRfMiA9IFVJTlQ2NCggJzE0MDI5NDY3MzY2ODk3MDE5NzI3JyApXG52YXIgUFJJTUU2NF8zID0gVUlOVDY0KCAgJzE2MDk1ODc5MjkzOTI4MzkxNjEnIClcbnZhciBQUklNRTY0XzQgPSBVSU5UNjQoICAnOTY1MDAyOTI0MjI4NzgyODU3OScgKVxudmFyIFBSSU1FNjRfNSA9IFVJTlQ2NCggICcyODcwMTc3NDUwMDEyNjAwMjYxJyApXG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBwcm9wZXIgVVRGLTggYXJyYXlcbiogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVURjggYXJyYXkgaXMgcmV0dXJuZWQgYXMgdWludDggYXJyYXlcbiovXG5mdW5jdGlvbiB0b1VURjhBcnJheSAoc3RyKSB7XG5cdHZhciB1dGY4ID0gW11cblx0Zm9yICh2YXIgaT0wLCBuPXN0ci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKVxuXHRcdGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSlcblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRlbHNlIHtcblx0XHRcdGkrKztcblx0XHRcdC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcblx0XHRcdC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcblx0XHRcdC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG5cdFx0XHRjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG5cdFx0XHR8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSlcblx0XHRcdHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHV0ZjgpXG59XG5cbi8qKlxuICogWFhINjQgb2JqZWN0IHVzZWQgYXMgYSBjb25zdHJ1Y3RvciBvciBhIGZ1bmN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIG9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfFVJTlQ2NH0gc2VlZFxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICogb3JcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cbmZ1bmN0aW9uIFhYSDY0ICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMV0gKS51cGRhdGUoIGFyZ3VtZW50c1swXSApLmRpZ2VzdCgpXG5cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFhYSDY0KSlcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhINjQgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHNlZWQgYXMgYSBudW1iZXIgb3IgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cbiBmdW5jdGlvbiBpbml0IChzZWVkKSB7XG5cdHRoaXMuc2VlZCA9IHNlZWQgaW5zdGFuY2VvZiBVSU5UNjQgPyBzZWVkLmNsb25lKCkgOiBVSU5UNjQoc2VlZClcblx0dGhpcy52MSA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTY0XzEpLmFkZChQUklNRTY0XzIpXG5cdHRoaXMudjIgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYzID0gdGhpcy5zZWVkLmNsb25lKClcblx0dGhpcy52NCA9IHRoaXMuc2VlZC5jbG9uZSgpLnN1YnRyYWN0KFBSSU1FNjRfMSlcblx0dGhpcy50b3RhbF9sZW4gPSAwXG5cdHRoaXMubWVtc2l6ZSA9IDBcblx0dGhpcy5tZW1vcnkgPSBudWxsXG5cblx0cmV0dXJuIHRoaXNcbn1cblhYSDY0LnByb3RvdHlwZS5pbml0ID0gaW5pdFxuXG4vKipcbiAqIEFkZCBkYXRhIHRvIGJlIGNvbXB1dGVkIGZvciB0aGUgWFhINjQgaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEg2NC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgaXNBcnJheUJ1ZmZlclxuXG5cdC8vIENvbnZlcnQgYWxsIHN0cmluZ3MgdG8gdXRmLTggZmlyc3QgKGlzc3VlICM1KVxuXHRpZiAoaXNTdHJpbmcpIHtcblx0XHRpbnB1dCA9IHRvVVRGOEFycmF5KGlucHV0KVxuXHRcdGlzU3RyaW5nID0gZmFsc2Vcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHR9XG5cblx0aWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHR7XG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0XHRpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcblx0fVxuXG5cdHZhciBwID0gMFxuXHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoXG5cdHZhciBiRW5kID0gcCArIGxlblxuXG5cdGlmIChsZW4gPT0gMCkgcmV0dXJuIHRoaXNcblxuXHR0aGlzLnRvdGFsX2xlbiArPSBsZW5cblxuXHRpZiAodGhpcy5tZW1zaXplID09IDApXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gJydcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IEJ1ZmZlcigzMilcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplICsgbGVuIDwgMzIpICAgLy8gZmlsbCBpbiB0bXAgYnVmZmVyXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCBsZW4pXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dFxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCBsZW4pLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCBsZW4gKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSArPSBsZW5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSA+IDApICAgLy8gc29tZSBkYXRhIGxlZnQgZnJvbSBwcmV2aW91cyB1cGRhdGVcblx0e1xuXHRcdC8vIFhYSDY0X21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAzMiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMzIgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAzMiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHA2NCA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG90aGVyXG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fVxuXG5cdFx0cCArPSAzMiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAzMilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAzMlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dmFyIG90aGVyXG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH1cblx0XHRcdHAgKz0gOFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnksIHAsIGJFbmQtcCk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZShwKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheShwLCBiRW5kKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgcCwgYkVuZCApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplID0gYkVuZCAtIHBcblx0fVxuXG5cdHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogRmluYWxpemUgdGhlIFhYSDY0IGNvbXB1dGF0aW9uLiBUaGUgWFhINjQgaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cblhYSDY0LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpbnB1dCA9IHRoaXMubWVtb3J5XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgcCA9IDBcblx0dmFyIGJFbmQgPSB0aGlzLm1lbXNpemVcblx0dmFyIGg2NCwgaFxuXHR2YXIgdSA9IG5ldyBVSU5UNjRcblxuXHRpZiAodGhpcy50b3RhbF9sZW4gPj0gMzIpXG5cdHtcblx0XHRoNjQgPSB0aGlzLnYxLmNsb25lKCkucm90bCgxKVxuXHRcdGg2NC5hZGQoIHRoaXMudjIuY2xvbmUoKS5yb3RsKDcpIClcblx0XHRoNjQuYWRkKCB0aGlzLnYzLmNsb25lKCkucm90bCgxMikgKVxuXHRcdGg2NC5hZGQoIHRoaXMudjQuY2xvbmUoKS5yb3RsKDE4KSApXG5cblx0XHRoNjQueG9yKCB0aGlzLnYxLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjIubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52My5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnY0Lm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoNjQgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTY0XzUgKVxuXHR9XG5cblx0aDY0LmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDgpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzUpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzQpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdClcblx0XHR9XG5cdFx0dS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSlcblx0XHRoNjRcblx0XHRcdC54b3IodSlcblx0XHRcdC5yb3RsKDI3KVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzEgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF80IClcblx0XHRwICs9IDhcblx0fVxuXG5cdGlmIChwICsgNCA8PSBiRW5kKSB7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0MFxuXHRcdFx0LFx0MFxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9XG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdFx0LnJvdGwoMjMpXG5cdFx0XHQubXVsdGlwbHkoIFBSSU1FNjRfMiApXG5cdFx0XHQuYWRkKCBQUklNRTY0XzMgKVxuXHRcdHAgKz0gNFxuXHR9XG5cblx0d2hpbGUgKHAgPCBiRW5kKVxuXHR7XG5cdFx0dS5mcm9tQml0cyggaXNTdHJpbmcgPyBpbnB1dC5jaGFyQ29kZUF0KHArKykgOiBpbnB1dFtwKytdLCAwLCAwLCAwIClcblx0XHRoNjRcblx0XHRcdC54b3IoIHUubXVsdGlwbHkoUFJJTUU2NF81KSApXG5cdFx0XHQucm90bCgxMSlcblx0XHRcdC5tdWx0aXBseShQUklNRTY0XzEpXG5cdH1cblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMylcblx0aDY0LnhvcihoKS5tdWx0aXBseShQUklNRTY0XzIpXG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMjkpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8zKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDMyKVxuXHRoNjQueG9yKGgpXG5cblx0Ly8gUmVzZXQgdGhlIHN0YXRlXG5cdHRoaXMuaW5pdCggdGhpcy5zZWVkIClcblxuXHRyZXR1cm4gaDY0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWFhINjRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3h4aGFzaGpzL2xpYi94eGhhc2g2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBjcnlwdG8gKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9