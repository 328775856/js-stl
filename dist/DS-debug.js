(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DS"] = factory();
	else
		root["DS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 156);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(162)
var ieee754 = __webpack_require__(240)
var isArray = __webpack_require__(106)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(0).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(117)(module)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(233).version;
elliptic.utils = __webpack_require__(232);
elliptic.rand = __webpack_require__(82);
elliptic.curve = __webpack_require__(43);
elliptic.curves = __webpack_require__(224);

// Protocols
elliptic.ec = __webpack_require__(225);
elliptic.eddsa = __webpack_require__(228);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(158);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 6 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(39)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(29)
  , IE8_DOM_DEFINE = __webpack_require__(96)
  , toPrimitive    = __webpack_require__(62)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(183)
  , defined = __webpack_require__(52);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(238);
hash.common = __webpack_require__(234);
hash.sha = __webpack_require__(237);
hash.ripemd = __webpack_require__(236);
hash.hmac = __webpack_require__(235);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = __webpack_require__(67);
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

var Readable = __webpack_require__(114);
var Writable = __webpack_require__(69);

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),
/* 15 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 队列Queue
 *
 * 队列是一种先进先出（first in first out, FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。
 * 允许插入的一端叫队尾（rear），允许删除的一端叫队头（front）。
 */

// 链队列
var Queue = function () {
    function Queue() {
        (0, _classCallCheck3.default)(this, Queue);

        this.rear = this.front = null;
        this.size = 0;
    }

    Queue.prototype.isEmpty = function isEmpty() {
        return this.rear === null;
    };

    Queue.prototype.clear = function clear() {
        this.rear = this.front = null;
        this.size = 0;
    };

    Queue.prototype.getHead = function getHead() {
        return this.front ? this.front.data : null;
    };

    Queue.prototype.enQueue = function enQueue(elem) {
        if (this.front === null) {
            this.rear = this.front = { data: elem, next: null };
        } else {
            var p = { data: elem, next: null };
            this.rear.next = p;
            this.rear = p;
        }
        this.size++;
    };

    Queue.prototype.deQueue = function deQueue() {
        if (this.front) {
            var elem = this.front.data;
            this.front = this.front.next;
            if (this.front === null) {
                this.rear = null;
            }
            this.size--;
            return elem;
        } else {
            return null;
        }
    };

    Queue.prototype.forEach = function forEach(iterator) {
        if (typeof iterator !== 'function') throw new Error('iterator should be function');

        var current = this.front;
        while (current) {
            if (iterator(current.data)) break;
            current = current.next;
        }
    };

    Queue.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var current;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        current = this.front;

                    case 1:
                        if (!current) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 4;
                        return current.data;

                    case 4:
                        current = current.next;
                        _context.next = 1;
                        break;

                    case 7:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    Queue.prototype.peekAt = function peekAt() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (index < this.size) {
            var current = this.front;
            for (var i = 0; i < index; i++) {
                current = current.next;
            }
            return current.data;
        }

        return -1;
    };

    Queue.prototype.toString = function toString() {
        if (this.front === null) {
            return null;
        }

        var arr = [];
        var current = this.front;

        for (var i = 0, len = this.size; i < len; i++) {
            arr[i] = current.data;
            current = current.next;
        }

        return arr;
    };

    return Queue;
}();

exports.default = Queue;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var Transform = __webpack_require__(23).Transform
var inherits = __webpack_require__(1)
var StringDecoder = __webpack_require__(70).StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 18 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(10)
  , createDesc = __webpack_require__(41);
module.exports = __webpack_require__(8) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(60)('wks')
  , uid        = __webpack_require__(42)
  , Symbol     = __webpack_require__(6).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var inherits = __webpack_require__(1)
var md5 = __webpack_require__(103)
var rmd160 = __webpack_require__(258)
var sha = __webpack_require__(260)

var Base = __webpack_require__(17)

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(44).EventEmitter;
var inherits = __webpack_require__(1);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(253);
Stream.Writable = __webpack_require__(255);
Stream.Duplex = __webpack_require__(250);
Stream.Transform = __webpack_require__(254);
Stream.PassThrough = __webpack_require__(252);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChildSiblingTree = exports.ChildTree = exports.ParentTree = exports.BinaryTree = undefined;

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 链式存储结构
/**
 * 树的一些概念
 *
 * 树（Tree）是n（n>=0）个结点的有限集。在任意一棵非空树中：
 * （1）有且仅有一个特定的称为根（Root）的结点；
 * （2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,T3,...Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。
 *
 * 例如，（a）是只有一个根结点的树；
 * （b）是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。
 *
 * 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。例如，（b）中A的度为3，C的度为1，F的度为0.度为0的结点称为叶子（Leaf）或者终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。（b）的树的度为3.结点的子树的根称为该结点的孩子（Child）。相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。
 * 结点的层次（Level）从根开始定义起，根为第一层，跟的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。例如，结点G与E，F,H,I,J互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。（b）的树的深度为4。
 *
 * 如果将树中结点的各子树看成从左至右是有次序的（即不能交换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
 * 森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
 *
 *
 */

/**
 * 二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）
 *
 * 二叉树的性质
 * 1.在二叉树的第i层上至多有2的i-1次方个结点(i>=1)。
 * 2.深度为k的二叉树至多有2的k次方-1个结点，(k>=1)。
 * 3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1;
 *      一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树。
 *      深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。
 * 下面是完全二叉树的两个特性
 * 4.具有n个结点的完全二叉树的深度为Math.floor(log 2 n) + 1
 * 5.如果对一棵有n个结点的完全二叉树（其深度为Math.floor(log 2 n) + 1）的结点按层序编号（从第1层到第Math.floor(2 n) + 1，每层从左到右），则对任一结点（1<=i<=n）有：
 *     (1)如果i=1，则结点i、是二叉树的根，无双亲；如果i>1，则其双亲parent(i)是结点Math.floor(i/2)。
 *     (2)如果2i > n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LChild(i)是结点2i.
 *     (3)如果2i + 1 > n，则结点i无右孩子；否则其右孩子RChild(i)是结点2i + 1;
 */

/*
 二叉树的存储结构

 1.顺序存储结构
 用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，即将二叉树上编号为i的结点元素存储在加上定义的一维数组中下标为i-1的分量中。“0”表示不存在此结点。这种顺序存储结构仅适用于完全二叉树。
 因为，在最坏情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为2的n次方-1的一维数组。

 2.链式存储结构
 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左右指针域。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结构所得的二叉树的存储结构分别称之为二叉链表和三叉链表。
 在含有n个结点的二叉链表中有n+1个空链域，我们可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构---线索链表。

 先（根）序遍历：根左右
 中（根）序遍历：左根右
 后（根）序遍历：左右根

 */

var BinaryTree = exports.BinaryTree = function () {
    function BinaryTree() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var leftChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var rightChild = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        (0, _classCallCheck3.default)(this, BinaryTree);

        this.data = data;
        // 左右孩子结点
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }

    // 判断两棵树是否相似


    BinaryTree.prototype.isSimilar = function isSimilar(tree) {
        return !!(tree && (this.leftChild && this.leftChild.isSimilar(tree.leftChild) || !this.leftChild && !tree.leftChild) && (this.rightChild && this.rightChild.isSimilar(tree.rightChild) || !this.rightChild && !tree.rightChild));
    };

    BinaryTree.prototype.createBinaryTree = function createBinaryTree(tree) {
        void function preOrderRecursive(node, x, visit) {
            visit(node, tree[x]);

            var p = void 0;
            if (tree[2 * x + 1]) {
                p = node.leftChild = new BinaryTree();
                preOrderRecursive(p, 2 * x + 1, visit);
            }
            if (tree[2 * x + 2]) {
                p = node.rightChild = new BinaryTree();
                preOrderRecursive(p, 2 * x + 2, visit);
            }

            if (p) p.parentNode = node;
        }(this, 0, function (node, value) {
            node.data = value;
        });
    };

    /**
     * 
     * 根据type类型使用不同顺序迭代，默认前序遍历
     * 1: 前序 2: 中序 3: 后序
     * @param {Number} iteratorType
     * 
     * @memberOf BinaryTree
     */


    BinaryTree.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var iteratorType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.t0 = iteratorType;
                        _context.next = _context.t0 === 1 ? 3 : _context.t0 === 2 ? 10 : _context.t0 === 3 ? 17 : 24;
                        break;

                    case 3:
                        _context.next = 5;
                        return this.data;

                    case 5:
                        if (!this.leftChild) {
                            _context.next = 7;
                            break;
                        }

                        return _context.delegateYield(this.leftChild, 't1', 7);

                    case 7:
                        if (!this.rightChild) {
                            _context.next = 9;
                            break;
                        }

                        return _context.delegateYield(this.rightChild, 't2', 9);

                    case 9:
                        return _context.abrupt('break', 24);

                    case 10:
                        if (!this.leftChild) {
                            _context.next = 12;
                            break;
                        }

                        return _context.delegateYield(this.leftChild, 't3', 12);

                    case 12:
                        _context.next = 14;
                        return this.data;

                    case 14:
                        if (!this.rightChild) {
                            _context.next = 16;
                            break;
                        }

                        return _context.delegateYield(this.rightChild, 't4', 16);

                    case 16:
                        return _context.abrupt('break', 24);

                    case 17:
                        if (!this.leftChild) {
                            _context.next = 19;
                            break;
                        }

                        return _context.delegateYield(this.leftChild, 't5', 19);

                    case 19:
                        if (!this.rightChild) {
                            _context.next = 21;
                            break;
                        }

                        return _context.delegateYield(this.rightChild, 't6', 21);

                    case 21:
                        _context.next = 23;
                        return this.data;

                    case 23:
                        return _context.abrupt('break', 24);

                    case 24:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    // 先序遍历二叉树的非递归算法

    BinaryTree.prototype.preOrderNonRecursive = function preOrderNonRecursive(visit) {
        var stack = new _index2.default();
        var p = this;

        while (p || stack.length) {
            // 向左走到尽头
            if (p) {
                stack.push(p);
                p.data && visit(p.data);
                p = p.leftChild;
            } else {
                p = stack.pop();
                p = p.rightChild;
            }
        }
    };

    // 中序非递归遍历


    BinaryTree.prototype.inOrderNonRecursive = function inOrderNonRecursive(visit) {
        var stack = new _index2.default();
        var p = this;

        while (p || stack.length) {
            if (p) {
                stack.push(p);
                p = p.leftChild;
            } else {
                p = stack.pop();
                p.data && visit(p.data);
                p = p.rightChild;
            }
        }
    };

    // 为了区分两次过栈的不同处理方式，在堆栈中增加一个mark域，
    // mark=0表示刚刚访问此结点，mark=1表示左子树处理结束返回，
    // mark=2表示右子树处理结束返回。每次根据栈顶的mark域决定做何动作


    BinaryTree.prototype.postOrderNonRecursive = function postOrderNonRecursive(visit) {
        var stack = new _index2.default();
        stack.push([this, 0]);

        while (stack.length) {
            var a = stack.pop();
            var node = a[0];

            switch (a[1]) {
                case 0:
                    stack.push([node, 1]); // 修改mark域
                    if (node.leftChild) stack.push([node.leftChild, 0]); // 访问左子树
                    break;
                case 1:
                    stack.push([node, 2]);
                    if (node.rightChild) stack.push([node.rightChild, 0]);
                    break;
                case 2:
                    node.data && visit(node.data);
                    break;
                default:
                    break;
            }
        }
    };

    BinaryTree.prototype.preOrderRecursive = function preOrderRecursive(visit) {
        visit(this.data);
        if (this.leftChild) this.leftChild.preOrderRecursive(visit);
        if (this.rightChild) this.rightChild.preOrderRecursive(visit);
    };

    BinaryTree.prototype.inOrderRecursive = function inOrderRecursive(visit) {
        if (this.leftChild) this.leftChild.inOrderRecursive(visit);
        visit(this.data);
        if (this.rightChild) this.rightChild.inOrderRecursive(visit);
    };

    BinaryTree.prototype.postOrderRecursive = function postOrderRecursive(visit) {
        if (this.leftChild) this.leftChild.postOrderRecursive(visit);
        if (this.rightChild) this.rightChild.postOrderRecursive(visit);
        visit(this.data);
    };

    BinaryTree.prototype.levelOrderTraverse = function levelOrderTraverse(visit) {
        var queue = new _Queue2.default();
        queue.enQueue(this);

        while (queue.rear) {
            var p = queue.deQueue();
            p.data && visit(p.data);
            p.leftChild && queue.enQueue(p.leftChild);
            p.rightChild && queue.enQueue(p.rightChild);
        }
    };

    // 求先序序列为k的结点的值


    BinaryTree.prototype.getPreSequence = function getPreSequence(k) {
        var count = 0;
        var data = null;

        void function recurse(node) {
            if (node) {
                if (++count === k) data = node.data;else {
                    recurse(node.leftChild);
                    recurse(node.rightChild);
                }
            }
        }(this);

        return data;
    };

    // 求二叉树中叶子结点的数目


    BinaryTree.prototype.countLeaves = function countLeaves() {
        return function recurse(node) {
            if (!node) return 0;else if (!node.leftChild && !node.rightChild) return 1;else return recurse(node.leftChild) + recurse(node.rightChild);
        }(this);
    };

    // 交换所有结点的左右子树


    BinaryTree.prototype.revoluteBinaryTree = function revoluteBinaryTree() {
        var _ref = [this.rightChild, this.leftChild];
        this.leftChild = _ref[0];
        this.rightChild = _ref[1];


        if (this.leftChild) this.leftChild.revoluteBinaryTree();
        if (this.rightChild) this.rightChild.revoluteBinaryTree();
    };

    BinaryTree.prototype.revoluteNonRecursive = function revoluteNonRecursive() {
        var stack = [];
        stack.push(this);

        while (stack.length) {
            var node = stack.pop();
            var _ref2 = [node.rightChild, node.leftChild];
            node.leftChild = _ref2[0];
            node.rightChild = _ref2[1];


            if (node.leftChild) stack.push(node.leftChild);
            if (node.rightChild) stack.push(node.rightChild);
        }
    };

    // 求二叉树中以值为x的结点为根的子树深度


    BinaryTree.prototype.getSubDepth = function getSubDepth(x) {
        var count = 0;
        var stack = new _index2.default();
        stack.push(this);

        while (stack.length) {
            var node = stack.pop();

            if (node.data === x) {
                count = node.getDepth();
                break;
            } else {
                if (node.leftChild) stack.push(node.leftChild);
                if (node.rightChild) stack.push(node.rightChild);
            }
        }

        return count;
    };

    BinaryTree.prototype.getDepth = function getDepth() {
        var m = this.leftChild && this.leftChild.getDepth() || 0;
        var n = this.rightChild && this.rightChild.getDepth() || 0;
        return (m > n ? m : n) + 1;
    };

    // 删除所有以元素x为根的子树


    BinaryTree.prototype.delSubX = function delSubX(x) {
        if (this.data === x) {
            this.leftChild = null;
            this.rightChild = null;
        } else {
            if (this.leftChild) this.leftChild.delSubX(x);
            if (this.rightChild) this.rightChild.delSubX(x);
        }
    };

    /**
     * 非递归复制二叉树
     * @param {Function} cb 拷贝过程中会执行的回调，可以用来拷贝其它自定义属性
     * @returns {Cstr} 返回新的实例
     */


    BinaryTree.prototype.copy = function copy() {
        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

        // 用来存放本体结点的栈
        var stack1 = new _index2.default();
        // 用来存放新二叉树结点的栈
        var stack2 = new _index2.default();
        stack1.push(this);
        var Cstr = this.constructor;
        var newTree = new Cstr();
        var q = newTree;
        stack2.push(newTree);
        var p = void 0;

        while (stack1.length) {
            // 向左走到尽头
            while (p = stack1.peek()) {
                if (p.leftChild) q.leftChild = new Cstr();
                q = q.leftChild;
                stack1.push(p.leftChild);
                stack2.push(q);
            }

            p = stack1.pop();
            q = stack2.pop();

            if (stack1.length) {
                p = stack1.pop();
                q = stack2.pop();
                if (p.rightChild) q.rightChild = new Cstr();
                q.data = p.data;
                cb(q, p);
                q = q.rightChild;
                stack1.push(p.rightChild); // 向右一步
                stack2.push(q);
            }
        }

        return newTree;
    };

    // 求二叉树中结点p和q的最近祖先


    BinaryTree.prototype.findNearAncient = function findNearAncient(pNode, qNode) {
        var pathP = findPath(this, pNode, 0);
        var pathQ = findPath(this, qNode, 0);

        for (var i = 0; pathP[i] == pathQ[i] && pathP[i]; i++) {}
        return pathP[--i];
    };

    // todo


    BinaryTree.prototype.toString = function toString() {};

    // 求一棵二叉树的繁茂度


    BinaryTree.prototype.lushDegree = function lushDegree() {
        var countArr = [];
        var queue = new _Queue2.default();
        queue.enQueue({
            node: this,
            layer: 0
        });
        // 利用层序遍历来统计各层的结点数
        var r = void 0;
        while (queue.rear) {
            r = queue.deQueue();
            countArr[r.layer] = (countArr[r.layer] || 0) + 1;

            if (r.node.leftChild) queue.enQueue({
                node: r.node.leftChild,
                layer: r.layer + 1
            });
            if (r.node.rightChild) queue.enQueue({
                node: r.node.rightChild,
                layer: r.layer + 1
            });
        }

        // 最后一个队列元素所在层就是树的高度
        var height = r.layer;
        var max = countArr[0];
        for (var i = 1; countArr[i]; i++) {
            // 求层最大结点数
            if (countArr[i] > max) max = countArr[i];
        }return height * max;
    };

    // 求树结点的子孙总数填入descNum字段中，并返回


    BinaryTree.prototype.descNum = function descNum() {
        return function recurse(node) {
            var d = void 0;
            if (!node) return -1;else d = recurse(node.leftChild) + recurse(node.rightChild) + 2;

            node.descNum = d;

            return d;
        }(this);
    };

    // 判断二叉树是否完全二叉树


    BinaryTree.isFullBinaryTree = function isFullBinaryTree(tree) {
        var queue = new _Queue2.default();
        var flag = 0;
        queue.enQueue(tree);

        while (queue.rear) {
            var p = queue.deQueue();

            if (!p) flag = 1;else if (flag) return false;else {
                queue.enQueue(p.leftChild);
                queue.enQueue(p.rightChild);
            }
        }

        return true;
    };

    return BinaryTree;
}();

// 求从tree到node结点路径的递归算法


function findPath(tree, node) {
    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var path = [];
    var found = false;

    void function recurse(tree, i) {
        if (tree == node) {
            found = true;
            return;
        }

        path[i] = tree;
        if (tree.leftChild) recurse(tree.leftChild, i + 1);
        if (tree.rightChild && !found) recurse(tree.rightChild, i + 1);
        if (!found) path[i] = null;
    }(tree, i);

    return path;
}

var global = Function('return this;')();

// 求深度等于树的高度减一的最靠左的结点
function printPath_maxDepthS1(tree) {
    var maxh = tree.getDepth();
    var path = [];

    if (maxh < 2) return false;
    find_h(tree, 1);

    function find_h(tree, h) {
        path[h] = tree;

        if (h == maxh - 1) {
            var s = ' ';
            for (var i = 1; path[i]; i++) {
                s += path[i].data + (path[i + 1] ? ' -> ' : '');
            }console.log(s);
            return;
        } else {
            if (tree.leftChild) find_h(tree.leftChild, h + 1);
            if (tree.rightChild) find_h(tree.rightChild, h + 1);
        }

        path[h] = null;
    }
}

var tree = [1, 2, 3, 4, 5,, 6,,, 7];
var test = new BinaryTree();
test.createBinaryTree(tree);

console.log('iterator: ');
for (var _iterator = test, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref3;

    if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref3 = _iterator[_i++];
    } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref3 = _i.value;
    }

    var x = _ref3;

    console.log(x);
}

/**
 * 树的3种常用链表结构
 */

// 1.双亲表示法
// 优点：parent(tree, x)操作可以在常量时间内实现
// 缺点：求结点的孩子时需要遍历整个结构

var ParentTree = exports.ParentTree = function () {
    function ParentTree() {
        (0, _classCallCheck3.default)(this, ParentTree);

        this.nodes = [];
    }

    ParentTree.prototype.getDepth = function getDepth() {
        var maxDepth = 0;

        for (var i = 0; i < this.nodes.length; i++) {
            var dep = 0;
            for (var j = i; j >= 0; j = this.nodes[i].parent) {
                dep++;
            }if (dep > maxDepth) maxDepth = dep;
        }

        return maxDepth;
    };

    return ParentTree;
}();

var ParentTreeNode = function ParentTreeNode() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck3.default)(this, ParentTreeNode);

    // type: ParentTree
    this.data = data;
    // 双亲位置域 {Number}
    this.parent = parent;
};

var pt = new ParentTree();
pt.nodes.push(new ParentTreeNode('R', -1));
pt.nodes.push(new ParentTreeNode('A', 0));
pt.nodes.push(new ParentTreeNode('B', 0));
pt.nodes.push(new ParentTreeNode('C', 0));
pt.nodes.push(new ParentTreeNode('D', 1));
pt.nodes.push(new ParentTreeNode('E', 1));
pt.nodes.push(new ParentTreeNode('F', 3));
pt.nodes.push(new ParentTreeNode('G', 6));
pt.nodes.push(new ParentTreeNode('H', 6));
pt.nodes.push(new ParentTreeNode('I', 6));

// 孩子表示法

var ChildTree = exports.ChildTree = function () {
    function ChildTree() {
        (0, _classCallCheck3.default)(this, ChildTree);

        this.nodes = [];
    }

    ChildTree.prototype.getDepth = function getDepth() {
        var self = this;
        return function subDepth(rootIndex) {
            if (!self.nodes[rootIndex]) return 1;

            var sd = 1;
            for (var p = self.nodes[rootIndex]; p; p = p.next) {
                var d = subDepth(p.child);
                if (d > sd) sd = d;
            }

            return sd + 1;
        }(this.data[0]);
    };

    return ChildTree;
}();
/**
 *
 * @param {*} data
 * @param {ChildTreeNode} firstChild 孩子链表头指针
 * @constructor
 */


var ChildTreeBox = function ChildTreeBox() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var firstChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, ChildTreeBox);

    this.data = data;
    this.firstChild = firstChild;
};

/**
 * 孩子结点
 *
 * @param {Number} child
 * @param {ChildTreeNode} next
 * @constructor
 */


var ChildTreeNode = function ChildTreeNode() {
    var child = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, ChildTreeNode);

    this.child = child;
    this.next = next;
};

/*
 孩子表示法便于涉及孩子的操作的实现，但不适用于parent操作。
 我们可以把双亲表示法和孩子表示法结合起来。
 */

// 孩子兄弟表示法(二叉树表示法)
// 可增设一个parent域实现parent操作


var ChildSiblingTree = exports.ChildSiblingTree = function () {
    function ChildSiblingTree() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var firstChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        (0, _classCallCheck3.default)(this, ChildSiblingTree);

        this.data = data;
        this.firstChild = firstChild;
        this.nextSibling = nextSibling;
    }

    // 输出孩子兄弟链表表示的树的各边


    ChildSiblingTree.prototype.print = function print() {
        for (var child = this.firstChild; child; child = child.nextSibling) {
            console.log('%c %c', this.data, child.data);
            child.print();
        }
    };

    // 求孩子兄弟链表表示的树的叶子数目


    ChildSiblingTree.prototype.leafCount = function leafCount() {
        if (!this.firstChild) return 1;else {
            var count = 0;
            for (var child = this.firstChild; child; child = child.nextSibling) {
                count += child.leafCount();
            }
            return count;
        }
    };

    // 求树的度


    ChildSiblingTree.prototype.getDegree = function getDegree() {
        if (!this.firstChild) return 0;else {
            var degree = 0;
            for (var p = this.firstChild; p; p = p.nextSibling) {
                degree++;
            }for (var _p = this.firstChild; _p; _p = _p.nextSibling) {
                var d = _p.getDegree();
                if (d > degree) degree = d;
            }

            return degree;
        }
    };

    ChildSiblingTree.prototype.getDepth = function getDepth() {
        if (this === global) return 0;else {
            var maxd = 0;
            for (var p = this.firstChild; p; p = p.nextSibling) {
                var d = p.getDepth();
                if (d > maxd) maxd = d;
            }

            return maxd + 1;
        }
    };

    return ChildSiblingTree;
}();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 栈
 *
 * 是限定仅在表尾进行插入或删除操作的线性表。表尾为栈顶（top），表头为栈底（bottom），不含元素的空表为空栈。
 * 栈又称为后进先出（last in first out）的线性表。
 */

/**
 * 顺序栈
 * 栈的顺序存储结构是利用一组地址连续的存储单元依次存放至栈底到栈顶的元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
 *
 */

// 栈的链式表示
var Stack = function () {
    function Stack() {
        (0, _classCallCheck3.default)(this, Stack);

        this.top = null;
        this.length = 0;
    }

    Stack.prototype.isEmpty = function isEmpty() {
        return this.length === 0;
    };

    Stack.prototype.push = function push(data) {
        var node = {
            data: data,
            next: null
        };

        node.next = this.top;
        this.top = node;
        this.length++;
    };

    Stack.prototype.peek = function peek() {
        return this.top === null ? null : this.top.data;
    };

    Stack.prototype.pop = function pop() {
        if (this.top === null) return null;

        var out = this.top;
        this.top = this.top.next;

        if (this.length > 0) this.length--;

        return out.data;
    };

    Stack.prototype.clear = function clear() {
        this.top = null;
        this.length = 0;
    };

    Stack.prototype.toString = function toString() {
        if (this.top === null) return null;

        var arr = [];
        var current = this.top;

        for (var i = 0, len = this.size; i < len; i++) {
            arr[i] = current.data;
            current = current.next;
        }

        return arr;
    };

    (0, _createClass3.default)(Stack, [{
        key: "size",
        get: function get() {
            return this.length;
        }
    }]);
    return Stack;
}();

exports.default = Stack;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(3);

asn1.define = __webpack_require__(148).define;
asn1.base = __webpack_require__(27);
asn1.constants = __webpack_require__(77);
asn1.decoders = __webpack_require__(152);
asn1.encoders = __webpack_require__(154);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(150).Reporter;
base.DecoderBuffer = __webpack_require__(76).DecoderBuffer;
base.EncoderBuffer = __webpack_require__(76).EncoderBuffer;
base.Node = __webpack_require__(149);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(31);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(6)
  , core      = __webpack_require__(18)
  , ctx       = __webpack_require__(94)
  , hide      = __webpack_require__(19)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}

var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > 65536) throw new Error('requested too many random bytes')
  // in case browserify  isn't using the Uint8Array version
  var rawBytes = new global.Uint8Array(size)

  // This will not work in older browsers.
  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
  if (size > 0) {  // getRandomValues fails on IE if size == 0
    crypto.getRandomValues(rawBytes)
  }
  // phantomjs doesn't like a buffer being passed here
  var bytes = new Buffer(rawBytes.buffer)

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(0).Buffer, __webpack_require__(7)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultCompare;
/**
 * Created by ldp on 2015/4/12.
 */

function defaultCompare(a, b) {
  return a - b;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(256);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 37 */
/***/ (function(module, exports) {

exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes128'] = exports['aes-128-cbc']
exports['aes192'] = exports['aes-192-cbc']
exports['aes256'] = exports['aes-256-cbc']
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(28)

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(101)
  , enumBugKeys = __webpack_require__(53);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(220);
curve.short = __webpack_require__(223);
curve.mont = __webpack_require__(222);
curve.edwards = __webpack_require__(221);


/***/ }),
/* 44 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var md5 = __webpack_require__(103)
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var asn1 = __webpack_require__(243)
var aesid = __webpack_require__(242)
var fixProc = __webpack_require__(245)
var ciphers = __webpack_require__(49)
var compat = __webpack_require__(109)
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(159);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(157);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(81);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(81);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(164)
exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
var deciphers = __webpack_require__(163)
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
var modes = __webpack_require__(37)
function getCiphers () {
  return Object.keys(modes)
}
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(3);
var randomBytes = __webpack_require__(33);
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var buffer = __webpack_require__(0);
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 52 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 53 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(29)
  , dPs         = __webpack_require__(189)
  , enumBugKeys = __webpack_require__(53)
  , IE_PROTO    = __webpack_require__(59)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(95)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(182).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 57 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(10).f
  , has = __webpack_require__(9)
  , TAG = __webpack_require__(20)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(60)('keys')
  , uid    = __webpack_require__(42);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(6)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 61 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(31);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(6)
  , core           = __webpack_require__(18)
  , LIBRARY        = __webpack_require__(55)
  , wksExt         = __webpack_require__(64)
  , defineProperty = __webpack_require__(10).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(20);

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var createHash = __webpack_require__(21);
var inherits = __webpack_require__(1)

var Transform = __webpack_require__(23).Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(216);
exports.Cipher = __webpack_require__(213);
exports.DES = __webpack_require__(214);
exports.CBC = __webpack_require__(212);
exports.EDE = __webpack_require__(215);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(14);

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/*<replacement>*/
var processNextTick = __webpack_require__(67);
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(266)
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = __webpack_require__(23);
  } catch (_) {} finally {
    if (!Stream) Stream = __webpack_require__(44).EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = __webpack_require__(0).Buffer;
/*<replacement>*/
var bufferShim = __webpack_require__(51);
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(14);

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(14);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(265).setImmediate))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = __webpack_require__(0).Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 堆
 * 
 * @export
 * @class Heap
 */
var Heap = function () {
    function Heap() {
        var compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCompre;
        (0, _classCallCheck3.default)(this, Heap);

        this.arr = [];
        this.compare = compare;
    }

    Heap.prototype.add = function add(elem) {
        this.arr.push(elem);

        if (this.arr.length === 1) return;

        this._upHeapAdjust((this.arr.length >> 1) - 1);
    };

    Heap.prototype.remove = function remove() {
        if (!this.arr.length) return;

        var heap = this.arr;
        // 出队列操作，弹出数据头元素
        var data = heap[0];
        // 用尾元素填充头元素
        heap[0] = heap[heap.length - 1];
        // 删除尾节点
        heap.pop();

        //然后从根节点下滤堆
        if (heap.length > 1) this._downHeapAdjust(0);

        return data;
    };

    Heap.prototype.clear = function clear() {
        this.arr.length = 0;
    };

    // 对堆进行上滤操作，使得满足堆性质


    Heap.prototype._upHeapAdjust = function _upHeapAdjust(parent) {
        var heap = this.arr;
        var len = heap.length;

        while (parent >= 0) {
            var leftChild = 2 * parent + 1;
            var rightChild = leftChild + 1;
            var max = leftChild;

            if (rightChild < len) {
                max = this.compare(heap[leftChild], heap[rightChild]) < 0 ? rightChild : leftChild;
            }

            // 如果parent节点小于它的某个子节点的话，此时筛选操作
            if (this.compare(heap[parent], heap[max]) < 0) {
                var temp = heap[parent];
                heap[parent] = heap[max];
                heap[max] = temp;

                // 继续进行更上一层的过滤
                parent = Math.ceil(parent / 2) - 1;
            } else break;
        }
    };

    // 对堆进行下滤操作，使得满足堆性质


    Heap.prototype._downHeapAdjust = function _downHeapAdjust(parent) {
        var heap = this.arr;
        var len = heap.length;

        while (2 * parent + 1 < len) {
            var leftChild = 2 * parent + 1;
            var rightChild = leftChild + 1;
            var max = leftChild;

            if (rightChild < len) {
                max = this.compare(heap[leftChild], heap[rightChild]) < 0 ? rightChild : leftChild;
            }

            if (this.compare(heap[parent], heap[max]) < 0) {
                var temp = heap[parent];
                heap[parent] = heap[max];
                heap[max] = temp;

                parent = max;
            } else break;
        }
    };

    return Heap;
}();

exports.default = Heap;
;

function defaultCompre(a, b) {
    return a - b;
}

// var arr = [1, 0, 5, 4, 3];
// var heap = new Heap();
// for (let ele of arr) {
//     heap.add(ele);
// }
// console.log(`heap: ${heap.arr.join(',')}`);
// for (let ele of arr) {
//     heap.remove();
//     console.log(`heap: ${heap.arr.join(',')}`);
// }

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 双向链表
 *
 * 双向链表是为了克服单链表这种单向性的缺点。
 * 双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋。
 *
 * 双向链表也可以有循环表。
 */

var Node = function Node(data) {
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck3.default)(this, Node);

    this.data = data;
    this.prev = prev;
    this.next = next;
};

function defaultCompare(a, b) {
    return a === b;
}

var DoubleLinkedList = function () {
    function DoubleLinkedList() {
        var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCompare;
        (0, _classCallCheck3.default)(this, DoubleLinkedList);

        this.head = null;
        this.tail = null;
        this.size = 0;
        this.compare = compare;

        if (sqList && sqList.length) {
            for (var _iterator = sqList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var item = _ref;

                this.push(item);
            }
        }
    }

    DoubleLinkedList.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var current;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        current = this.head;

                    case 1:
                        if (!current) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 4;
                        return current.data;

                    case 4:

                        current = current.next;
                        _context.next = 1;
                        break;

                    case 7:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    DoubleLinkedList.prototype.clear = function clear() {
        this.head = null;
        this.tail = null;
        this.size = 0;

        return true;
    };

    DoubleLinkedList.prototype.push = function push(data) {
        if (typeof data === 'undefined') throw new Error('param data required');

        ++this.size;

        if (!this.head) {
            this.head = this.tail = new Node(data);
        } else {
            var node = new Node(data, this.tail, null);
            this.tail.next = node;
            this.tail = node;
        }

        return data;
    };

    DoubleLinkedList.prototype.unshift = function unshift(data) {
        if (typeof data === 'undefined') throw new Error('param data required');

        ++this.size;

        if (!this.head) {
            this.head = this.tail = new Node(data);
        } else {
            var node = new Node(data, null, this.head);
            this.head.prev = node;
            this.head = node;
        }

        return data;
    };

    DoubleLinkedList.prototype.pop = function pop() {
        if (!this.tail) {
            this.head = this.tail = null;
            return;
        }

        --this.size;

        var data = this.tail.data;

        this.tail.prev.next = null;
        this.tail = this.tail.prev;

        return data;
    };

    DoubleLinkedList.prototype.shift = function shift() {
        if (!this.head) {
            this.head = this.tail = null;
            return;
        }

        --this.size;

        var data = this.head.data;

        this.head.next.prev = null;
        this.head = this.head.next;

        return data;
    };

    /**
     * update the value of existing node by index
     * @param {Number} index 
     * @param {*} data 
     */


    DoubleLinkedList.prototype.update = function update(index, data) {
        var node = this.findByIndex(index, true);

        if (node) node.data = data;

        return !!node;
    };

    /**
     * Remove the first matched data
     * @param {*} data 
     */


    DoubleLinkedList.prototype.remove = function remove(data) {
        if (typeof data === 'function') throw new Error('Param data required');

        var current = this.head;

        while (current) {
            if (this.compare(data, current.data)) {
                --this.size;

                if (current === this.head) {
                    this.head = this.head.next;

                    if (this.head) {
                        this.head.prev = null;
                    } else {
                        this.head = this.tail = null;
                    }
                } else if (current === this.tail) {
                    this.tail = this.tail.prev;

                    if (this.tail) {
                        this.tail.next = null;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    current.prev.next = current.next;
                    current.next.prev = current.prev;
                }

                return current.data;
            }

            current = current.next;
        }

        return null;
    };

    DoubleLinkedList.prototype.indexOf = function indexOf(data) {
        var current = this.head;
        var index = -1;

        while (current) {
            ++index;
            if (this.compare(data, current.data)) return index;

            current = current.next;
        }

        return -1;
    };

    /**
     * find node or data by index
     * @param {Number} index 
     * @param {Boolean} returnNode true: return the node object; otherwise return data;
     */


    DoubleLinkedList.prototype.findByIndex = function findByIndex() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var returnNode = arguments[1];

        var current = this.head;
        var j = 0;

        while (current) {
            if (j++ === index) break;

            current = current.next;
        }

        return returnNode ? current : current ? current.data : null;
    };

    DoubleLinkedList.prototype.forEach = function forEach() {
        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (typeof cb !== 'function') throw new Error('argument should be a function');

        var current = this.head;
        var index = 0;

        while (current) {
            cb(current.data, index++);

            current = current.next;
        }
    };

    DoubleLinkedList.prototype.toJSON = function toJSON() {
        var list = [];
        var current = this.head;

        while (current) {
            list.push(current.data);

            current = current.next;
        }

        return list;
    };

    DoubleLinkedList.prototype.toString = function toString() {
        return this.toJSON() + '';
    };

    (0, _createClass3.default)(DoubleLinkedList, [{
        key: 'length',
        get: function get() {
            return this.size;
        }
    }]);
    return DoubleLinkedList;
}();

// let a = new DoubleLinkedList([2, 3]);
// a.unshift(1);
// a.push(4);
// console.log(a.indexOf(4));
// console.log(a.findByIndex(2));

// for(let item of a){
//     console.log(item);
// }

// a.pop();
// a.shift();
// a.remove(2);
// a.remove(32);
// a.remove(3);


exports.default = DoubleLinkedList;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 静态单链表
/*
 有时可借用一维数组来描述线性链表，这就是线性表的静态单链表存储结构。
 在静态链表中，数组的一个分量表示一个结点，同时用游标（cur）代替指针指示结点在数组中的相对位置。
 数组的第0分量可看成头结点，其指针域指示链表的第一个结点。
 这种存储结构需要预先分配一个较大的空间，但在线性表的插入和删除操作时不需移动元素，
 仅需要修改指针，故仍具有链式存储结构的主要优点
 */

var StaticLinkedList = function () {
    function StaticLinkedList(MAXSIZE) {
        (0, _classCallCheck3.default)(this, StaticLinkedList);

        this[-1] = { cur: 0 };
        this.length = 0;
        this.MAXSIZE = MAXSIZE + 1 || 1000;
    }

    /**
     * 在静态单链线性表L中查找第1个值为e的元素，
     * 若找到，则返回它在L中的位序
     * @param data
     */


    StaticLinkedList.prototype.find = function find(data) {
        var i = this[0].cur;
        while (i && this[i].data !== data) {
            i = this[i].cur;
        }
        return i;
    };
    /**
     * 将一维数组中各分量链成一个备用链表
     * this[0].cur为头指针
     */


    StaticLinkedList.prototype.init = function init(len) {
        len = len ? len + 1 : this.MAXSIZE;
        for (var i = 0; i < len - 1; ++i) {
            this[i] = this[i] || { data: null, cur: null };
            this[i].cur = i + 1;
        }

        this[len - 1] = this[len - 1] || {};
        this[len - 1].cur = 0;
    };
    /**
     * 若备用链表非空，则返回分配的结点下标，反则返回0
     * @returns {*}
     */


    StaticLinkedList.prototype.malloc = function malloc() {
        var i = this[-1].cur;
        if (typeof this[-1].cur !== 'undefined') this[-1].cur = this[i].cur;
        return i;
    };
    /**
     * 将下标为k的空闲结点回收到备用链表
     * @param k
     */


    StaticLinkedList.prototype.free = function free(k) {
        this[k].cur = this[0].cur;
        this[0].cur = k;
    };

    StaticLinkedList.prototype.create = function create(sqList) {
        // 初始化备用空间
        this.init(sqList.length);
        // 生成s的头结点
        var s = this.malloc();
        // r指向s的当前最后结点
        var r = s;
        var m = sqList.length;

        // 建立集合A的链表
        for (var j = 0; j < m; ++j) {
            //分配结点
            var i = this.malloc();
            // 输入A元素的值
            this[i].data = sqList[j];
            // 插入到表尾
            this[r].cur = i;
            ++this.length;
            r = i;
        }
        // 尾结点的指针为空
        this[r].cur = 0;
    };

    // todo


    StaticLinkedList.prototype.add = function add(index, elem) {};

    StaticLinkedList.prototype.remove = function remove(index) {};

    return StaticLinkedList;
}();

/**
 * 在一维数组中建立表示集合(A-B)U(B-A)
 * 的静态链表，s为其头指针。
 * @returns {*}
 */


exports.default = StaticLinkedList;
function difference(sllist, arr1, arr2) {
    // 初始化备用空间
    sllist.init();
    // 生成s的头结点
    var s = sllist.malloc();
    // r指向s的当前最后结点
    var r = s;
    // 删除A和B的元素个数
    var m = arr1.length;
    var n = arr2.length;

    // 建立集合A的链表
    for (var j = 0; j < m; ++j) {
        //分配结点
        var i = sllist.malloc();
        // 输入A元素的值
        sllist[i].data = arr1[j];
        // 插入到表尾
        sllist[r].cur = i;
        r = i;
    }
    // 尾结点的指针为空
    sllist[r].cur = 0;

    // 依次输入B的元素，若不在当前表中，则插入，
    // 否则删除
    for (var _j = 0; _j < n; ++_j) {
        var b = arr2[_j];
        var p = s;
        // k指向集合中的第一个结点
        var k = sllist[s].cur;
        // 在当前表中查找
        while (k !== sllist[r].cur && sllist[k].data !== b) {
            p = k;
            k = sllist[k].cur;
        }
        // 当前表中不存在该元素，插入在r所指结点之后，且r的位置不变
        if (k === sllist[r].cur) {
            var _i = sllist.malloc();
            sllist[_i].data = b;
            sllist[_i].cur = sllist[r].cur;
            sllist[r].cur = _i;

            // 该元素已在表中，删除之
        } else {
            sllist[p].cur = sllist[k].cur;
            sllist.free(k);
            // 若删除的是r所指结点，则需修改尾指针
            if (r === k) r = p;
        }
    }
}

var sl = new StaticLinkedList(10);
var ret = difference(sl, [1, 2, 3], [3, 4, 5]);
console.log(sl);

var test = new StaticLinkedList(10);
test.create([49, 38, 65, 97, 76, 13, 27, 49]);
console.log(test);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(48);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(47);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BinaryTree2 = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BSTNode = function (_BinaryTree) {
    (0, _inherits3.default)(BSTNode, _BinaryTree);

    function BSTNode() {
        (0, _classCallCheck3.default)(this, BSTNode);

        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
            arg[_key] = arguments[_key];
        }

        return (0, _possibleConstructorReturn3.default)(this, _BinaryTree.call.apply(_BinaryTree, [this].concat(arg)));
    }

    /**
     * BST树的查找（递归）
     * @param {*} key
     * @returns {*}
     */


    BSTNode.prototype.search = function search(key) {
        if (this.data != null) {
            if (this.data === key) return this;else if (key < this.data) {
                if (this.leftChild) return this.leftChild.search(key);
            } else {
                if (this.rightChild) return this.rightChild.search(key);
            }
        }

        return null;
    };

    /**
     * BST树的查找（非递归）
     * @param {*} key
     * @returns {*}
     */


    BSTNode.prototype.searchNonRecursive = function searchNonRecursive(key) {
        if (this.data == null) return null;

        var p = this;
        while (p && p.data !== key) {
            if (key < p.data) p = p.leftChild;else p = p.rightChild;
        }

        if (!p || key !== p.data) return null;else return p;
    };

    /**
     * BST树的插入（递归）
     * @param {*} key
     */


    BSTNode.prototype.insert = function insert(key) {
        if (this.data == null) {
            this.data = key;
            return;
        }
        if (key === this.data) return;

        var node = new BSTNode(key);
        if (key < this.data) {
            if (!this.leftChild) this.leftChild = node;
            this.leftChild.insert(key);
        } else {
            if (!this.rightChild) this.rightChild = node;
            this.rightChild.insert(key);
        }
    };

    /**
     * BST树的插入（非递归）
     * @param {*} key
     */


    BSTNode.prototype.insertNonRecursive = function insertNonRecursive(key) {
        if (this.data == null) {
            this.data = key;
            return;
        }

        var p = this;
        var q = void 0;
        while (p) {
            if (p.data === key) return;
            // q作为p的父节点
            q = p;
            if (key < p.data) p = p.leftChild;else p = p.rightChild;
        }

        var node = new BSTNode(key);
        if (key < q.data) q.leftChild = node;else q.rightChild = node;
    };

    /**
     * 利用BST树的插入操作建立一棵BST树
     * @param {Array} arr
     * @param {Boolean|undefined} useNonRecursive 是否使用非递归
     */


    BSTNode.prototype.createBST = function createBST(arr, useNonRecursive) {
        var i = void 0;
        if (useNonRecursive) {
            for (i = 0; i < arr.length; ++i) {
                this.insertNonRecursive(arr[i]);
            }
        } else {
            for (i = 0; i < arr.length; ++i) {
                this.insert(arr[i]);
            }
        }

        return this;
    };

    /**
     * 使用递归的方法删除与关键字符合的结点
     * @param {*} key 需要查找的关键字
     * @param {BSTNode} parent 父节点，内部调用需要用到
     * @returns {Boolean}
     */


    BSTNode.prototype.remove = function remove(key, parent) {
        // 空结点的情况
        if (this.data == null) return false;

        // 找到关键字
        if (this.data === key) return deleteNode(this, parent);
        // 查找左子树，如果有的话
        else if (key < this.data) {
                if (this.leftChild) return this.leftChild.remove(key, this);
            }
            // 查找右子树，如果有的话
            else {
                    if (this.rightChild) return this.rightChild.remove(key, this);
                }

        // 未找到
        return false;
    };

    /**
     * 非递归删除与关键字符合的结点
     * @param {*} key 需要查找的关键字
     * @returns {boolean}
     */


    BSTNode.prototype.removeNonRecursive = function removeNonRecursive(key) {
        var p = this;
        var f = void 0;

        while (p && p.data !== key) {
            f = p;
            if (key < p.data) p = p.leftChild;else p = p.rightChild;
        }

        // 没有要删除的结点
        if (!p) return false;

        // 找到了要删除的结点p
        var s = p;
        var q = void 0;
        // 如果有左右子树
        if (p.leftChild && p.rightChild) {
            f = p;
            s = p.leftChild;

            // 找到左子树的最大右子树，即仅小于左子树的值的结点
            while (s.rightChild) {
                f = s;
                s = s.rightChild;
            }

            p.data = s.data;
        }

        // 若s有左子树，右子树为空
        if (s.leftChild) q = s.leftChild;else q = s.rightChild;

        // 只有一个根结点的情况
        if (!f) this.data = null;else if (f.leftChild == s) f.leftChild = q;else f.rightChild = q;

        return true;
    };

    /**
     * 找到小于x的最大元素和大于x的最小元素
     * @param {String|Number} x
     * @returns {Array} [min, max]
     */


    BSTNode.prototype.findNeighborElem = function findNeighborElem(x) {
        var last = typeof this.data === 'number' ? -Infinity : 'a';
        var ret = [];

        void function recurse(tree, x) {
            if (tree.leftChild) recurse(tree.leftChild, x);
            if (last < x && tree.data >= x) ret[0] = last;
            if (last <= x && tree.data > x) ret[1] = tree.data;
            last = tree.data;
            if (tree.rightChild) recurse(tree.rightChild, x);
        }(this, x);

        return ret;
    };

    /**
     * 把二叉排序树bst合并到该树中
     * @param {BSTNode} bst
     */


    BSTNode.prototype.merge = function merge(bst) {
        if (bst.leftChild) this.merge(bst.leftChild);
        if (bst.rightChild) this.merge(bst.rightChild);
        this.insert(bst.data);
    };

    /**
     * 把结点插入到合适位置
     * @param {BSTNode} node 待插入的结点
     */


    BSTNode.prototype.insertNode = function insertNode(node) {
        if (this.data == null) {
            this.data = node.data;
        } else {
            if (node.data > this.data) {
                if (!this.rightChild) this.rightChild = node;else this.rightChild.insertNode(node);
            } else if (node.data < this.data) {
                if (!this.leftChild) this.leftChild = node;else this.leftChild.insertNode(node);
            }
        }

        node.leftChild = node.rightChild = null;
    };

    /**
     * 分裂为两棵二叉排序树
     * @param {*} x
     * @returns {BSTNode[a, b]} a的元素全部小于等于x，b的元素全部大于x
     */


    BSTNode.prototype.split = function split(x) {
        var a = new BSTNode();
        var b = new BSTNode();

        void function split(tree, x) {
            if (tree.leftChild) split(tree.leftChild, x);
            if (tree.rightChild) split(tree.rightChild, x);
            if (tree.data <= x) a.insertNode(tree);else b.insertNode(tree);
        }(this, x);

        return [a, b];
    };

    /**
     * 判断tree是否是二叉排序树
     * @param tree
     */


    BSTNode.isBSTTree = function isBSTTree(tree) {
        var last = typeof tree.data === 'number' ? -Infinity : 'a';
        var flag = true;

        void function isBSTTree(tree) {
            if (tree.leftChild && flag) isBSTTree(tree.leftChild);
            if (tree.data < last) flag = false;
            last = tree.data;
            if (tree.rightChild && flag) isBSTTree(tree.rightChild);
        }(tree);

        return flag;
    };

    return BSTNode;
}(_BinaryTree2.BinaryTree);

/**
 * 删除结点
 * @param {BSTNode} p 要删除的结点
 * @param {BSTNode} parent 要删除的结点的父节点
 * @returns {boolean} 返回删除成功
 */
/*
 动态查找

 当查找表以线性表的形式组织时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。
 利用树的形式组织查找表，可以对查找表进行动态高效的查找。


 二叉排序树(BST)的定义

 二叉排序树(Binary Sort Tree或Binary Search Tree) 的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。
 (1) ：若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；
 (2) ：若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；
 (3) ：左、右子树都分别是二叉排序树。
 结论：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。


 BST树的查找
 1  查找思想
 首先将给定的K值与二叉排序树的根结点的关键字进行比较：若相等： 则查找成功；
 ① 给定的K值小于BST的根结点的关键字：继续在该结点的左子树上进行查找；
 ② 给定的K值大于BST的根结点的关键字：继续在该结点的右子树上进行查找。

 在随机情况下，二叉排序树的平均查找长度ASL和㏒(n)(树的深度)是等数量级的。


 BST树的插入

 在BST树中插入一个新结点，要保证插入后仍满足BST的性质。

 1 插入思想
 在BST树中插入一个新结点x时，若BST树为空，则令新结点x为插入后BST树的根结点；否则，将结点x的关键字与根结点T的关键字进行比较：
 ① 若相等： 不需要插入；
 ②  若x.key<T->key：结点x插入到T的左子树中；
 ③  若x.key>T->key：结点x插入到T的右子树中。

 由结论知，对于一个无序序列可以通过构造一棵BST树而变成一个有序序列。
 由算法知，每次插入的新结点都是BST树的叶子结点，即在插入时不必移动其它结点，仅需修改某个结点的指针。


 BST树的删除

 1  删除操作过程分析
 从BST树上删除一个结点，仍然要保证删除后满足BST的性质。设被删除结点为p，其父结点为f ，删除情况如下：
 ①  若p是叶子结点： 直接删除p。
 ②  若p只有一棵子树(左子树或右子树)：直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树。
 ③ 若p既有左子树又有右子树 ：处理方法有以下两种，可以任选其中一种。
 ◆  用p的直接前驱结点代替p。即从p的左子树中选择值最大的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的左子树中的最右边的结点且没有右子树，对s的删除同②。
 ◆ 用p的直接后继结点代替p。即从p的右子树中选择值最小的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的右子树中的最左边的结点且没有左子树，对s的删除同②。

 */

exports.default = BSTNode;
function deleteNode(p, parent) {
    // 叶子结点或只有一个结点
    if (!p.leftChild && !p.rightChild) {
        // 当前结点是其父结点的左子树还是右子树
        var pos = parent && parent.leftChild == p ? 'leftChild' : 'rightChild';
        if (parent) parent[pos] = null;
        // 只有一个结点的情况
        else p.data = null;
    }
    // 只有左子树
    else if (!p.rightChild) {
            p.data = p.leftChild.data;
            p.leftChild = p.leftChild.leftChild;
        }
        // 只有右子树
        else if (!p.leftChild) {
                p.data = p.rightChild.data;
                p.rightChild = p.rightChild.rightChild;
            }
            // 左右子树都有
            else {
                    var s = p.leftChild;
                    // q为父结点
                    var q = p;
                    // 找到左子树的最大右子树，即仅小于左子树的值的结点
                    while (s.rightChild) {
                        q = s;
                        s = s.rightChild;
                    }

                    p.data = s.data;
                    if (q != p) q.rightChild = s.leftChild;else q.leftChild = s.leftChild;
                }

    return true;
}

var bst = new BSTNode();
bst.createBST([45, 24, 53, 12, 24, 90]);
console.log(bst.search(12));
console.log(bst.search(13));

var bst2 = new BSTNode();
bst2.createBST([45, 24, 53, 12, 24, 90], true);
console.log(bst2.searchNonRecursive(12));
console.log(bst2.searchNonRecursive(13));

console.log('\nfindSiblingElem: ');
console.log(bst.findNeighborElem(12) + '');
console.log(bst.findNeighborElem(90) + '');
console.log(bst.findNeighborElem(45) + '');

console.log(bst.remove(45));
console.log(bst.remove(1));
console.log(bst.remove(53));
console.log(bst.remove(12));
console.log(bst.remove(90));
console.log(bst.remove(24));
console.log(bst.remove(2));

//console.log(bst2.removeNonRecursive(45));
//console.log(bst2.removeNonRecursive(1));
//console.log(bst2.removeNonRecursive(53));
//console.log(bst2.removeNonRecursive(12));
//console.log(bst2.removeNonRecursive(90));
//console.log(bst2.removeNonRecursive(24));
//console.log(bst2.removeNonRecursive(2));

console.log('\nisBSTTree: ');
console.log(BSTNode.isBSTTree(bst));
//console.log(BSTNode.isBSTTree(sosTree));


/**
 * 从大到小输出二叉排序树中所有不小于x的元素
 * @param bst
 * @param x
 */
function printNotLessThan(bst, x) {
    if (bst.rightChild) printNotLessThan(bst.rightChild, x);
    if (bst.data < x) return;
    console.log(bst.data);
    if (bst.leftChild) printNotLessThan(bst.leftChild, x);
}

console.log('\nprintNotLessThan: ');
printNotLessThan(bst2, 90);
console.log('\n');
printNotLessThan(bst2, 12);

bst.merge(bst2);

var a1 = new BSTNode(5);
var a2 = new BSTNode(91);
bst2.insertNode(a1);
bst2.insertNode(a2);

bst2.split(45);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bubbleSort = bubbleSort;
exports.bubbleSort2 = bubbleSort2;
exports.cockTailSort = cockTailSort;
exports.cockTailSort2 = cockTailSort2;
exports.quickSortRecursive = quickSortRecursive;
exports.quickSortRecursive2 = quickSortRecursive2;
exports.quickSortNonRecursive = quickSortNonRecursive;
exports.quickSort = quickSort;
exports.oddEvenSort = oddEvenSort;

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 交换排序

 是一类基于交换的排序，系统地交换反序的记录的偶对，直到不再有这样的偶对为止。其中最基本的是冒泡排序(Bubble Sort)。

 冒泡排序
 1  排序思想
 依次比较相邻的两个记录的关键字，若两个记录是反序的(即前一个记录的关键字大于后前一个记录的关键字)，则进行交换，直到没有反序的记录为止。
     ① 首先将L->R[1]与L->R[2]的关键字进行比较，若为反序(L->R[1]的关键字大于L->R[2]的关键字)，则交换两个记录；然后比较L->R[2]与L->R[3]的关键字，依此类推，直到L->R[n-1]与L->R[n]的关键字比较后为止，称为一趟冒泡排序，L->R[n]为关键字最大的记录。
     ②  然后进行第二趟冒泡排序，对前n-1个记录进行同样的操作。
 一般地，第i趟冒泡排序是对L->R[1 … n-i+1]中的记录进行的，因此，若待排序的记录有n个，则要经过n-1趟冒泡排序才能使所有的记录有序。

 2  排序示例
 设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41

 初始关键字序列:  23    38     22     45     23     67     31     15    41
 第一趟排序后:    23    22     38     23     45     31     15     41    67
 第二趟排序后:    22    23     23     38     31     15     41     45    67
 第三趟排序后:    22    23     23     31     15     38     41     45    67
 第四趟排序后:    22    23     23     15     31     38     41     45    67
 第五趟排序后:    22    23     15     23     31     38     41     45    67
 第六趟排序后:    22    15     23     23     31     38     41     45    67
 第七趟排序后:    15    22     23     23     31     38     41     45    67

3.算法分析
 时间复杂度
 ◆  最好情况(正序)：比较次数：n-1；移动次数：0；
 ◆  最坏情况(逆序)：
 比较次数： n * (n - 1) / 2
 移动次数： 3*n*(n - 1) / 2

 故时间复杂度：T(n)=O(n²)
 空间复杂度：S(n)=O(1)

 */

function bubbleSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 1, len = sqList.length; i < len; ++i) {
        var change = 0;

        for (var j = 0; j <= len - i; ++j) {
            if (comp(sqList[j + 1], sqList[j]) < 0) {
                change = 1;
                var temp = sqList[j];
                sqList[j] = sqList[j + 1];
                sqList[j + 1] = temp;
            }
        }

        if (!change) break;
    }
} /**
   * Created by Luke on 2015/2/2.
   */

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
bubbleSort(arr);
console.log('bubbleSort:\n' + arr + '');

// 冒泡改进1
function bubbleSort2(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var len = sqList.length;
    var change = len - 1;

    while (change) {
        var c = 0;
        for (var i = 0; i < change; ++i) {
            if (comp(sqList[i], sqList[i + 1]) > 0) {
                var temp = sqList[i];
                sqList[i] = sqList[i + 1];
                sqList[i + 1] = temp;
                // c指示这一趟冒泡中发生交换的元素
                c = i + 1;
            }
        }

        change = c;
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
bubbleSort2(arr);
console.log('bubbleSort2:\n' + arr + '');

// 相邻两趟反方向起泡的冒泡排序算法
function cockTailSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var len = sqList.length;
    // 冒泡上下界
    var low = 0,
        high = len - 1;
    var change = 1;
    var temp = void 0;

    while (low < high && change) {
        change = 0;

        // 从上向下起泡
        for (var i = low; i < high; ++i) {
            if (comp(sqList[i], sqList[i + 1]) > 0) {
                temp = sqList[i];
                sqList[i] = sqList[i + 1];
                sqList[i + 1] = temp;
                change = 1;
            }
        }
        // 修改上界
        --high;

        // 从下向上起泡
        for (var _i = high; _i > low; --_i) {
            if (comp(sqList[_i], sqList[_i - 1]) < 0) {
                temp = sqList[_i];
                sqList[_i] = sqList[_i - 1];
                sqList[_i - 1] = temp;
                change = 1;
            }
        }
        // 修改下界
        ++low;
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
cockTailSort(arr);
console.log('cockTailSort:\n' + arr + '');

// 改进3
function cockTailSort2(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var b = {};
    var len = sqList.length;
    // d为冒泡方向标识， 1为向上，-1为向下
    var d = 1;
    // b[0]为冒泡上界，b[2]为冒泡上界，b[1]无用
    b[0] = 0;
    b[2] = len - 1;
    var change = 1;

    while (b[0] < b[2] && change) {
        change = 0;

        // 统一的冒泡算法
        for (var i = b[1 - d]; i !== b[1 + d]; i += d) {
            // 注意这个交换条件
            if (comp(sqList[i], sqList[i + d]) * d > 0) {
                var temp = sqList[i];
                sqList[i] = sqList[i + d];
                sqList[i + d] = temp;
                change = 1;
            }
        }

        // 修改边界
        b[1 + d] -= d;
        // 换个方向
        d *= -1;
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
cockTailSort2(arr);
console.log('cockTailSort2:\n' + arr + '');

/*
 快速排序

 1  排序思想
 通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录进行下一趟排序，以达到整个序列有序。

 2  排序过程
 设待排序的记录序列是R[s…t] ，在记录序列中任取一个记录(一般取R[s])作为参照(又称为基准或枢轴)，以R[s].key为基准重新排列其余的所有记录，方法是：
     ◆ 所有关键字比基准小的放R[s]之前；
     ◆ 所有关键字比基准大的放R[s]之后。
 以R[s].key最后所在位置i作为分界，将序列R[s…t]分割成两个子序列，称为一趟快速排序。

 3  一趟快速排序方法
 从序列的两端交替扫描各个记录，将关键字小于基准关键字的记录依次放置到序列的前边；而将关键字大于基准关键字的记录从序列的最后端起，依次放置到序列的后边，直到扫描完所有的记录。

 设置指针low，high，初值为第1个和最后一个记录的位置。
 设两个变量i，j，初始时令i=low，j=high，以R[low].key作为基准(将R[low]保存在temp中) 。
 ① 从j所指位置向前搜索：将temp与R[j].key进行比较：
    ◆ 若temp≤R[j].key ：令j=j-1，然后继续进行比较， 直到i=j或temp>R[j].key为止；
    ◆ 若temp>R[j].key ：R[j]R[i]，腾空R[j]的位置， 且令i=i+1；
 ② 从i所指位置起向后搜索：将temp与R[i].key进行比较：
    ◆ 若temp≥R[i].key ：令i=i+1，然后继续进行比较， 直到i=j或temp<R[i].key为止；
    ◆ 若temp<R[i].key ：R[i]R[j]，腾空R[i]的位置， 且令j=j-1；
 ③ 重复①、②，直至i=j为止，i就是temp(基准)所应放置的位置。

 算法分析
 快速排序的主要时间是花费在划分上，对长度为k的记录序列进行划分时关键字的比较次数是k-1 。设长度为n的记录序列进行排序的比较次数为C(n)，则C(n)=n-1+C(k)+C(n-k-1) 。
 ◆  最好情况：每次划分得到的子序列大致相等，则
 C(n)<=h×n+2h×C(n/2h) ，当n/2h=1时排序结束。
 即C(n)≤O(n×㏒2n) ；
 ◆  最坏情况：每次划分得到的子序列中有一个为空，另一个子序列的长度为n-1。即每次划分所选择的基准是当前待排序序列中的最小(或最大)关键字。
 比较次数：:  即C(n)=O(n2)
 ◆  一般情况： 对n个记录进行快速排序所需的时间T(n)组成是：
     ① 对n个记录进行一趟划分所需的时间是：n×C ，C是常数；
     ② 对所得到的两个子序列进行快速排序的时间：
        Tavg(n)=C(n)+Tavg(k-1)+Tavg(n-k)          ……

 快速排序的平均时间复杂度是：T(n)=O(n㏒2n)
 从所需要的附加空间来看，快速排序算法是递归调用，系统内用堆栈保存递归参数，当每次划分比较均匀时，栈的最大深度为[㏒2n]+1 。

 快速排序的空间复杂度是：S(n)=O(㏒2n)
 从排序的稳定性来看，快速排序是不稳定的。

 */

function partition1(sqList, low, high) {
    var temp = sqList[low];

    while (low < high) {
        while (low < high && sqList[high] >= temp) {
            --high;
        }sqList[low] = sqList[high];
        while (low < high && sqList[low] <= temp) {
            ++low;
        }sqList[high] = sqList[low];
    }

    sqList[low] = temp;

    return low;
}

// 优化一趟快速排序方法： 随机化partition
// 最坏情况效率大幅提升，时间复杂度T(n)=O(n㏒2n)
function partition2(sqList, low, high) {
    var temp = void 0;
    var n = high - low + 1;
    var rand = Math.floor(Math.random() * n) + low;

    //let rand = (low + high) >> 1;
    temp = sqList[high];
    sqList[high] = sqList[rand];
    sqList[rand] = temp;

    var i = low - 1;
    var pivot = sqList[high];

    for (var j = low; j < high; ++j) {
        if (sqList[j] <= pivot) {
            ++i;
            temp = sqList[i];
            sqList[i] = sqList[j];
            sqList[j] = temp;
        }
    }

    ++i;
    sqList[high] = sqList[i];
    sqList[i] = pivot;

    return i;
}

function partition(sqList, low, high, comp) {
    var temp = void 0;
    var i = low;
    var j = high + 1;
    var rand = Math.floor(Math.random() * (high - low)) + low + 1;
    //let rand = (low + high) >> 1;

    temp = sqList[low];
    sqList[low] = sqList[rand];
    sqList[rand] = temp;

    var x = sqList[low];

    while (1) {
        while (comp(sqList[++i], x) < 0 && i < high) {}
        while (comp(sqList[--j], x) > 0) {}
        if (i >= j) break;
        temp = sqList[i];
        sqList[i] = sqList[j];
        sqList[j] = temp;
    }

    sqList[low] = sqList[j];
    sqList[j] = x;

    return j;
}

function quickSortRecursive() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    if (low >= high) return;

    var k = partition(sqList, low, high, comp);
    quickSortRecursive(sqList, low, k - 1, comp);
    quickSortRecursive(sqList, k + 1, high, comp);
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSortRecursive(arr);
console.log('quickSortRecursive:\n' + arr + '');

/*
快排递归算法优化，在最坏情况下堆栈深度为O(logn)
 */
function quickSortRecursive2() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    while (low < high) {
        var k = partition(sqList, low, high, comp);

        // 对两个子数组中较小的一个子数组进行递归调用。
        // 较小子数组的大小最多为原数组大小一半，
        // 由于每次递归调用的数组大小至少减少一半，所以递归调用的次数
        // 最多为O(logn)
        if (k - low + 1 < high - k) {
            quickSortRecursive2(sqList, low, k - 1, comp);
            low = k + 1;
        } else {
            quickSortRecursive2(sqList, k + 1, high, comp);
            high = k - 1;
        }
    }
}
var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSortRecursive2(arr);
console.log('quickSortRecursive2:\n' + arr + '');

function quickSortNonRecursive() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    var stack = [];
    var k = void 0;

    do {
        while (low < high) {
            k = partition(sqList, low, high, comp);
            // 第二个子序列的上,下界分别入栈
            stack.push(high, k + 1);
            //stack.push(k + 1);
            high = k - 1;
        }

        if (!stack.length) return;

        low = stack.pop();
        high = stack.pop();
    } while (1);
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSortNonRecursive(arr);
console.log('quickSortNonRecursive:\n' + arr + '');

// 优化版本
function quickSort() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    var stack = [];
    var pivot = void 0;

    do {
        // 如果当前子序列长度大于3且尚未排好序
        if (high - low > 2) {
            // 进行一趟划分
            pivot = partition(sqList, low, high, comp);

            // 吧长的子序列边界入栈，
            // 短的子序列留待下次排序
            if (high - pivot > pivot - low) {
                stack.push(high, pivot + 1);
                //stack.push();
                high = pivot - 1;
            } else {
                stack.push(pivot - 1, low);
                //stack.push();
                low = pivot + 1;
            }
        }
        // 如果当前子序列长度小于3，且尚未排好序，
        // 直接进行比较排序买当前子序列标志为已排好序
        else if (low < high && high - low < 3) {
                easySort(sqList, low, high, comp);
                low = high;
            }
            // 如果当前子序列已排好序但栈中还有未排序的子序列
            // 从栈中取出一个子序列
            else {
                    if (!stack.length) return;

                    low = stack.pop();
                    high = stack.pop();
                }
    } while (1);
}

function easySort(sqList, low, high, comp) {
    var temp = void 0;

    if (high - low === 1) {
        if (comp(sqList[low], sqList[high]) > 0) {
            temp = sqList[low];
            sqList[low] = sqList[high];
            sqList[high] = temp;
        }
    } else {
        if (comp(sqList[low], sqList[low + 1]) > 0) {
            temp = sqList[low];
            sqList[low] = sqList[low + 1];
            sqList[low + 1] = temp;
        }
        if (comp(sqList[low + 1], sqList[high]) > 0) {
            temp = sqList[low + 1];
            sqList[low + 1] = sqList[high];
            sqList[high] = temp;
        }
        if (comp(sqList[low], sqList[low + 1]) > 0) {
            temp = sqList[low];
            sqList[low] = sqList[low + 1];
            sqList[low + 1] = temp;
        }
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSort(arr);
console.log('quickSort:\n' + arr + '');

// 奇偶交换排序
function oddEvenSort() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var change = 1;
    var temp = void 0;
    var len = sqList.length;

    while (change) {
        change = 0;
        // 对所有奇数进行一趟比较
        for (var i = 1; i < len - 1; i += 2) {
            if (comp(sqList[i], sqList[i + 1]) > 0) {
                temp = sqList[i];
                sqList[i] = sqList[i + 1];
                sqList[i + 1] = temp;

                change = 1;
            }
        }

        // 对所有偶数进行一趟比较
        for (var _i2 = 0; _i2 < len - 1; _i2 += 2) {
            if (comp(sqList[_i2], sqList[_i2 + 1]) > 0) {
                temp = sqList[_i2];
                sqList[_i2] = sqList[_i2 + 1];
                sqList[_i2 + 1] = temp;

                change = 1;
            }
        }
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
oddEvenSort(arr);
console.log('oddEvenSort:\n' + arr + '');

/*
把由三种颜色组成的序列重排为按照红白蓝的顺序排列，
思路：
设立三个指针，其中j表示当前元素；i以前的元素全部为红色；k以后的颜色全为蓝色。这样就可以根据j的颜色把其交换到序列的前面或者后面。
 */
var RED = 0;
var WHITE = 1;
var BLUE = 2;

function flagArrange(colors) {
    var i = 0;
    var j = 0;
    var k = colors.length - 1;
    var temp = void 0;

    while (j <= k) {
        switch (colors[j]) {
            case RED:
                temp = colors[i];
                colors[i] = colors[j];
                colors[j] = temp;
                ++i;
                ++j;
                break;
            case WHITE:
                ++j;
                break;
            case BLUE:
                temp = colors[j];
                colors[j] = colors[k];
                colors[k] = temp;
                --k;
                break;
            default:
                break;
        }
    }
}

var arr = [2, 1, 0, 2, 1, 1, 0, 2, 0, 2, 1];
flagArrange(arr);
console.log(arr + '');

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);
var Reporter = __webpack_require__(27).Reporter;
var Buffer = __webpack_require__(0).Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(151);


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);

var asn1 = __webpack_require__(26);
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);
var Buffer = __webpack_require__(0).Buffer;

var asn1 = __webpack_require__(26);
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 由于链表在空间的合理利用上和插入，删除时不需要移动等的有点，因此在很多场合下，它是线性表的首选存储结构。然而，它也存在着实现某些基本操作，如求线性表长度时不如顺序存储结构的缺点；另一方面，由于在链表中，结点之间的关系使用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际出发重新定义线性链表及其基本操作
 */

var Node = function Node() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, Node);

    this.data = data;
    this.next = next;
};

var LinkedList = function () {
    function LinkedList() {
        var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        (0, _classCallCheck3.default)(this, LinkedList);

        this.head = null;
        this.tail = null;

        if (sqList) {
            for (var i = 0, len = sqList.length; i < len; ++i) {
                this.push(sqList[i]);
            }
        }
    }

    /**
     * merge list, note: this operation will delete a and b nodes.
     * @param {LinkedList} a 
     * @param {LinkedList} b
     * @param {*} compare 
     */


    LinkedList.mergeList = function mergeList(a, b) {
        var compare = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : compFn;

        var ha = a.head;
        var hb = b.head;
        var pa = ha;
        var pb = hb;
        var c = new LinkedList();
        var q = void 0;

        while (pa && pb) {
            var data1 = pa.data;
            var data2 = pb.data;

            if (!compare(data1, data2)) {
                // delete head node
                q = a.shift();
                // append the node to c linkedList
                c.append(q);
                pa = a.head;
            } else {
                q = b.shift();
                c.append(q);
                pb = b.head;
            }
        }

        if (pa) {
            c.append(pa);
            c.tail = a.tail;
        } else {
            c.append(pb);
            c.tail = b.tail;
        }

        return c;
    };

    /**
     * remove the first element and return it
     */


    LinkedList.prototype.shift = function shift() {
        var head = this.head;
        this.head = this.head.next;
        head.next = null;

        if (this.head === null) this.tail = null;
        return head;
    };

    /**
     * remove the last element and return it
     */


    LinkedList.prototype.pop = function pop() {
        var current = this.head;
        var previous = this.head;
        var elem = void 0;

        while (current !== null) {
            if (this.tail === current) {
                if (current === this.head) {
                    elem = this.tail.data;
                    this.head = null;
                    break;
                }

                this.tail = previous;

                previous.next = current.next;
                elem = current.data;
                break;
            }

            previous = current;
            current = current.next;
        }

        if (this.head === null) this.tail = null;

        return elem ? elem : false;
    };

    /**
     * append node
     * @param {Node} node 
     */


    LinkedList.prototype.append = function append(node) {
        if (this.head !== null) {
            this.tail.next = node;
            this.tail = this.tail.next;
        } else {
            this.head = node;
            this.tail = node;
        }
    };

    /**
     * add data
     * @param {*} data 
     */


    LinkedList.prototype.push = function push(data) {
        if (this.head === null) {
            this.head = new Node(data);
            this.tail = this.head;
        } else {
            this.tail.next = new Node(data);
            this.tail = this.tail.next;
        }

        this.tail.data = data;
    };

    /**
     * remove data
     * @param {*} data 
     */


    LinkedList.prototype.remove = function remove(data) {
        var current = this.head;
        var previous = this.head;
        var elem = void 0;

        while (current !== null) {
            if (data === current.data) {
                if (current === this.head) {
                    this.head = current.next;
                    elem = current.data;
                    break;
                }

                if (current === this.tail) this.tail = previous;

                previous.next = current.next;
                elem = current.data;
                break;
            }

            previous = current;
            current = current.next;
        }

        if (this.head === null) this.tail = null;

        return elem ? elem : false;
    };

    /**
     * find the index of matched data 
     * @param {*} data 
     */


    LinkedList.prototype.indexOf = function indexOf(data) {
        var current = this.head;
        var index = -1;
        while (current !== null) {
            ++index;
            if (current.data === data) {
                return index;
            }

            current = current.next;
        }

        return index;
    };

    /**
     * add data to the front
     * @param {*} data 
     */


    LinkedList.prototype.unshift = function unshift(data) {
        var temp = new Node(data);
        temp.next = this.head;
        this.head = temp;
    };

    /**
     * 
     * @param {*} target 
     * @param {*} data 
     */


    LinkedList.prototype.insertAfter = function insertAfter(target, data) {
        var current = this.head;
        while (current !== null) {
            if (current.data === target) {
                var temp = new Node(data);
                temp.next = current.next;

                if (current === this.tail) this.tail = temp;

                current.next = temp;
                return;
            }

            current = current.next;
        }
    };

    LinkedList.prototype.item = function item(index) {
        var current = this.head;

        while (current !== null) {
            if (--index === 0) return current;

            current = current.next;
        }

        return null;
    };

    LinkedList.prototype.forEach = function forEach(callback) {
        if (typeof callback !== 'function') return;

        for (var current = this.head, index = 0; current; current = current.next) {
            if (callback(current.data, index++)) break;
        }
    };

    LinkedList.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var current;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        current = this.head;

                    case 1:
                        if (!current) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 4;
                        return current.data;

                    case 4:
                        current = current.next;
                        _context.next = 1;
                        break;

                    case 7:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    LinkedList.prototype.toString = function toString() {
        var str = '';

        this.forEach(function (node) {
            str += node.data + (node.next ? ',' : '');
        });

        return str;
    };

    /**
     * insert element by order
     * @param {*} data 
     * @param {Function} cmp 
     */


    LinkedList.prototype.orderInsert = function orderInsert(data, cmp) {
        cmp = typeof cmp === 'function' ? cmp : function (a, b) {
            if (a > b) return 1;else if (a === b) return 0;else return -1;
        };
        var previous = this.head;
        var current = this.head;

        if (current === null) {
            this.head = this.tail = new Node(data);
            return;
        }

        var me = this;
        while (current) {
            var ret = cmp(data, current.data);
            // 如果插入元素大于当前元素，准备下次遍历
            if (ret > 0) {
                previous = current;
                current = current.next;

                // 如果等于，直接插入到后面
            } else if (ret === 0) {
                return insertBetween(data, previous, current);

                // 如果小于则插入到前节点和当前节点中
                // 因为已经是排序了，所以不需要多余判断了
            } else {
                if (this.head === previous && previous === current) return this.unshift(data);else return insertBetween(data, previous, current);
            }
        }

        // 插入到最后一个结点
        previous.next = new Node(data);
        this.tail = previous.next;

        function insertBetween(data, a, b) {
            if (a == b) {
                if (a == me.head) return me.unshift(data);
            } else {
                var temp = new Node(data);
                temp.next = b;
                a.next = temp;
                return true;
            }
        }
    };

    // 删除元素递增排列的链表中值大于min，且小于max的所有元素


    LinkedList.prototype.deleteBetween = function deleteBetween(min, max) {
        var p = this.head;

        // p是最后一个不大于min的元素
        while (p.next && p.next.data <= min) {
            p = p.next;
        } // 如果还有比min更大的元素
        var q = void 0;
        if (p.next) {
            q = p.next;
            // q是第一个不小于max的元素
            while (q && q.data < max) {
                q = q.next;
            }p.next = q;
        }

        var last = q || p;
        while (last.next) {
            last = last.next;
        }this.tail = last;
    };

    // 删除元素递增排列的链表的重复元素


    LinkedList.prototype.deleteEqual = function deleteEqual() {
        var p = this.head;
        var q = p.next;

        while (p.next) {
            // 当相邻两元素不相等时，p,q都向后移
            if (p.data !== q.data) {
                p = p.next;
                q = p.next;
            } else {
                while (q.data === p.data) {
                    q = q.next;
                } // 删除
                p.next = q;
                p = q;
                q = p.next;
            }
        }
    };

    LinkedList.prototype.reverse = function reverse() {
        var p = this.head;
        var q = p.next;
        var s = q.next;
        this.tail = p;
        p.next = null;

        while (s.next) {
            q.next = p;
            p = q;
            q = s;
            s = s.next;
        }

        q.next = p;
        s.next = q;
        this.head = s;
    };

    (0, _createClass3.default)(LinkedList, [{
        key: 'size',
        get: function get() {
            var current = this.head;
            var size = 0;

            while (current !== null) {
                ++size;
                current = current.next;
            }

            return size;
        }
    }]);
    return LinkedList;
}();

exports.default = LinkedList;


function compFn(a, b) {
    return a - b;
}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(161);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(160);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(271);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)
var GHASH = __webpack_require__(165)
var xor = __webpack_require__(28)
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(28)

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(28)

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 88 */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(28)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = {
	"sha224WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha224",
		"id": "302d300d06096086480165030402040500041c"
	},
	"RSA-SHA224": {
		"sign": "ecdsa/rsa",
		"hash": "sha224",
		"id": "302d300d06096086480165030402040500041c"
	},
	"sha256WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha256",
		"id": "3031300d060960864801650304020105000420"
	},
	"RSA-SHA256": {
		"sign": "ecdsa/rsa",
		"hash": "sha256",
		"id": "3031300d060960864801650304020105000420"
	},
	"sha384WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha384",
		"id": "3041300d060960864801650304020205000430"
	},
	"RSA-SHA384": {
		"sign": "ecdsa/rsa",
		"hash": "sha384",
		"id": "3041300d060960864801650304020205000430"
	},
	"sha512WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha512",
		"id": "3051300d060960864801650304020305000440"
	},
	"RSA-SHA512": {
		"sign": "ecdsa/rsa",
		"hash": "sha512",
		"id": "3051300d060960864801650304020305000440"
	},
	"RSA-SHA1": {
		"sign": "rsa",
		"hash": "sha1",
		"id": "3021300906052b0e03021a05000414"
	},
	"ecdsa-with-SHA1": {
		"sign": "ecdsa",
		"hash": "sha1",
		"id": ""
	},
	"sha256": {
		"sign": "ecdsa",
		"hash": "sha256",
		"id": ""
	},
	"sha224": {
		"sign": "ecdsa",
		"hash": "sha224",
		"id": ""
	},
	"sha384": {
		"sign": "ecdsa",
		"hash": "sha384",
		"id": ""
	},
	"sha512": {
		"sign": "ecdsa",
		"hash": "sha512",
		"id": ""
	},
	"DSA-SHA": {
		"sign": "dsa",
		"hash": "sha1",
		"id": ""
	},
	"DSA-SHA1": {
		"sign": "dsa",
		"hash": "sha1",
		"id": ""
	},
	"DSA": {
		"sign": "dsa",
		"hash": "sha1",
		"id": ""
	},
	"DSA-WITH-SHA224": {
		"sign": "dsa",
		"hash": "sha224",
		"id": ""
	},
	"DSA-SHA224": {
		"sign": "dsa",
		"hash": "sha224",
		"id": ""
	},
	"DSA-WITH-SHA256": {
		"sign": "dsa",
		"hash": "sha256",
		"id": ""
	},
	"DSA-SHA256": {
		"sign": "dsa",
		"hash": "sha256",
		"id": ""
	},
	"DSA-WITH-SHA384": {
		"sign": "dsa",
		"hash": "sha384",
		"id": ""
	},
	"DSA-SHA384": {
		"sign": "dsa",
		"hash": "sha384",
		"id": ""
	},
	"DSA-WITH-SHA512": {
		"sign": "dsa",
		"hash": "sha512",
		"id": ""
	},
	"DSA-SHA512": {
		"sign": "dsa",
		"hash": "sha512",
		"id": ""
	},
	"DSA-RIPEMD160": {
		"sign": "dsa",
		"hash": "rmd160",
		"id": ""
	},
	"ripemd160WithRSA": {
		"sign": "rsa",
		"hash": "rmd160",
		"id": "3021300906052b2403020105000414"
	},
	"RSA-RIPEMD160": {
		"sign": "rsa",
		"hash": "rmd160",
		"id": "3021300906052b2403020105000414"
	},
	"md5WithRSAEncryption": {
		"sign": "rsa",
		"hash": "md5",
		"id": "3020300c06082a864886f70d020505000410"
	},
	"RSA-MD5": {
		"sign": "rsa",
		"hash": "md5",
		"id": "3020300c06082a864886f70d020505000410"
	}
};

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = {
	"1.3.132.0.10": "secp256k1",
	"1.3.132.0.33": "p224",
	"1.2.840.10045.3.1.1": "p192",
	"1.2.840.10045.3.1.7": "p256",
	"1.3.132.0.34": "p384",
	"1.3.132.0.35": "p521"
};

/***/ }),
/* 93 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(178);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(31)
  , document = __webpack_require__(6).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(39)(function(){
  return Object.defineProperty(__webpack_require__(95)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(55)
  , $export        = __webpack_require__(30)
  , redefine       = __webpack_require__(102)
  , hide           = __webpack_require__(19)
  , has            = __webpack_require__(9)
  , Iterators      = __webpack_require__(54)
  , $iterCreate    = __webpack_require__(185)
  , setToStringTag = __webpack_require__(58)
  , getPrototypeOf = __webpack_require__(191)
  , ITERATOR       = __webpack_require__(20)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(57)
  , createDesc     = __webpack_require__(41)
  , toIObject      = __webpack_require__(11)
  , toPrimitive    = __webpack_require__(62)
  , has            = __webpack_require__(9)
  , IE8_DOM_DEFINE = __webpack_require__(96)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(101)
  , hiddenKeys = __webpack_require__(53).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 100 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(9)
  , toIObject    = __webpack_require__(11)
  , arrayIndexOf = __webpack_require__(180)(false)
  , IE_PROTO     = __webpack_require__(59)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(19);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = __webpack_require__(208);

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

exports.UINT32 = __webpack_require__(210)
exports.UINT64 = __webpack_require__(211)

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(33);
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(3);
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(107);
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),
/* 106 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(3);
var brorand = __webpack_require__(82);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var createHmac = __webpack_require__(65)
var checkParameters = __webpack_require__(246)

exports.pbkdf2 = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  checkParameters(iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  setTimeout(function () {
    callback(null, exports.pbkdf2Sync(password, salt, iterations, keylen, digest))
  })
}

var defaultEncoding
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}

exports.pbkdf2Sync = function (password, salt, iterations, keylen, digest) {
  if (!Buffer.isBuffer(password)) password = new Buffer(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, defaultEncoding)

  checkParameters(iterations, keylen)

  digest = digest || 'sha1'

  var hLen
  var l = 1
  var DK = new Buffer(keylen)
  var block1 = new Buffer(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var r
  var T

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)
    var U = createHmac(digest, password).update(block1).digest()

    if (!hLen) {
      hLen = U.length
      T = new Buffer(hLen)
      l = Math.ceil(keylen / hLen)
      r = keylen - (l - 1) * hLen
    }

    U.copy(T, 0, 0, hLen)

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    var destPos = (i - 1) * hLen
    var len = (i === l ? r : hLen)
    T.copy(DK, destPos, 0, len)
  }

  return DK
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(0).Buffer))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(21);
module.exports = function (seed, len) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(3);
function withPublic(paddedMsg, key) {
  return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
}

module.exports = withPublic;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(68);

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = Readable;

/*<replacement>*/
var processNextTick = __webpack_require__(67);
/*</replacement>*/

/*<replacement>*/
var isArray = __webpack_require__(106);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(44).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = __webpack_require__(23);
  } catch (_) {} finally {
    if (!Stream) Stream = __webpack_require__(44).EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = __webpack_require__(0).Buffer;
/*<replacement>*/
var bufferShim = __webpack_require__(51);
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(272);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(251);
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(14);

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(70).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(14);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(70).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.preOrderRecursive = preOrderRecursive;
exports.inOrderRecursive = inOrderRecursive;
exports.postOrderRecursive = postOrderRecursive;
/**
 * 二叉树的顺序存储结构
 */

// 顺序存储结构的遍历
function preOrderRecursive(tree, x, visit) {
    visit(tree[x]);
    if (tree[2 * x + 1]) preOrderRecursive(tree, 2 * x + 1, visit);
    if (tree[2 * x + 2]) preOrderRecursive(tree, 2 * x + 2, visit);
};

function inOrderRecursive(tree, x, visit) {
    if (tree[2 * x + 1]) inOrderRecursive(tree, 2 * x + 1, visit);
    visit(tree[x]);
    if (tree[2 * x + 2]) inOrderRecursive(tree, 2 * x + 2, visit);
}

function postOrderRecursive(tree, x, visit) {
    if (tree[2 * x + 1]) postOrderRecursive(tree, 2 * x + 1, visit);
    if (tree[2 * x + 2]) postOrderRecursive(tree, 2 * x + 2, visit);
    visit(tree[x]);
}

var tree = [1, 2, 3, 4, 5,, 6,,, 7];

console.log('preOrder:');
preOrderRecursive(tree, 0, function (value) {
    console.log(value);
});

console.log('inOrder:');
inOrderRecursive(tree, 0, function (value) {
    console.log(value);
});

console.log('postOrder:');
postOrderRecursive(tree, 0, function (value) {
    console.log(value);
});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = huffManCoding;
/**
 * 赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树，有着广泛应用。
 *
 * 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
 * 树的路径长度是从树根到每一个结点的路径之和。
 * 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。
 *
 * 构造赫夫曼树的步骤：
 * （1）根据给定的n个权值{w1,w2,...wn}构成n棵二叉树的集合F = {T1,T2,...Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
 * （2）在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
 * （3）在F中删除这两棵树，同时将新得到的二叉树加入F中。
 * （4）重复（2）和（3），直到F只含一棵树为止。这棵树便是赫夫曼树。
 */
/*
赫夫曼编码
http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81

假设电报需传送的电文为“A B A C C D A”，它只有4种字符只需两个字符串便可分辨。假设A,B,C,D的编码分别为00,01,10和11，则上述7个字符的电文便为“00010010101100”，对方接收时，可按二位一分进行译码。
在传送电文时，希望总长尽可能地短。如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便可减少。
如果涉及A,B,C,D的编码分别为0,00,1和01，则上述7个字符的电文可转换成总长为9的字符串“000011010”。但是，这样的电文无法翻译，因为可有多种译法。
因此，若要设计长短不等的编码，则必须是任意个字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码。
可利用二叉树来设计二进制的前缀编码。假设有一棵二叉树，其4个叶子结点分别表示A,B,C,D这4个字符，且约定左分支表示字符“0”，右分支表示字符“1”，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。所得二进制前缀编码分别为0,10,110,111.
设计电文总长最短的二进制前缀编码即以n种字符出现的频率作权。
 */

// 赫夫曼树和赫夫曼编码的存储结构
function HuffmanNode(weight, parent, leftChild, rightChild) {
    this.weight = weight || 0;
    this.parent = parent || 0;
    this.leftChild = leftChild || 0;
    this.rightChild = rightChild || 0;
}
function huffManCoding(weights) {
    var n = weights.length;
    if (n < 1) return;

    var huffmanTree = buildHuffmanTree(weights, n);

    // 从叶子到根逆向求每个字符的赫夫曼编码
    var hc = calcHuffmanCode(huffmanTree, n);

    return [huffmanTree, hc];
}

function calcHuffmanCode(huffmanTree, n) {
    // 从叶子到根逆向求每个字符的赫夫曼编码
    var hc = [];
    var cd = [];
    for (var i = 0; i < n; i++) {
        var start = n - 1;
        for (var c = i, f = huffmanTree[i].parent; f != 0; c = f, f = huffmanTree[f].parent) {
            if (huffmanTree[f].leftChild == c) cd[--start] = '0';else cd[--start] = '1';
        }

        hc[i] = strCopy(cd, start);
    }

    return hc;
}

// 创建一棵叶子结点数为n的Huffman树
function buildHuffmanTree(weights, n) {
    n = n || weights.length;
    var m = 2 * n - 1;
    var huffmanTree = [];

    // 初始化
    var i = void 0;
    for (i = 0; i < n; i++) {
        huffmanTree[i] = new HuffmanNode(weights[i], 0, 0, 0);
    }for (; i < m; i++) {
        huffmanTree[i] = new HuffmanNode(0, 0, 0, 0);
    }for (var _i = n; _i < m; _i++) {
        // 在HT[1..i-1]选择parent为0且weight最小的两个结点，返回其序号为[s1, s2]
        var ret = select(huffmanTree, _i);
        var s1 = ret[0];
        var s2 = ret[1];
        huffmanTree[s1].parent = _i;
        huffmanTree[s2].parent = _i;
        huffmanTree[_i].leftChild = s1;
        huffmanTree[_i].rightChild = s2;
        huffmanTree[_i].weight = huffmanTree[s1].weight + huffmanTree[s2].weight;
    }

    return huffmanTree;
}

function strCopy(str, start) {
    var s = '';
    for (; str[start]; start++) {
        s += str[start];
    }
    return s;
}

function select(huffmanTree, len) {
    var ret = [];
    for (var i = 0; i < len; i++) {
        var node = huffmanTree[i];
        if (node.parent !== 0) continue;

        if (ret.length < 2) {
            ret.push(i);
        } else {
            var index = huffmanTree[ret[0]].weight > huffmanTree[ret[1]].weight ? 0 : 1;

            if (node.weight < huffmanTree[ret[index]].weight) ret[index] = i;
        }
    }

    if (ret[0] > ret[1]) {
        var temp = ret[0];
        ret[0] = ret[1];
        ret[1] = temp;
    }

    return ret;
}

console.log('-------huffman coding 1:------');
console.log(huffManCoding([5, 29, 7, 8, 14, 23, 3, 11]));

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 广义表
 *
 * 广义表是线性表的推广。广泛用于人工智能的表处理语言Lisp，把广义表作为基本的数据结构。
 * 广义表一般记作：
 *      LS = (a1, a2, ..., an)
 * LS是广义表的名称，n是它的长度，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头，称其余元素组成的表(a2, a3, ..., an)是LS的表尾。
 *
 * 下面列举一些广义表的例子：
 * 1.A = () ---- A是一个空表，它的长度为0。
 * 2.B = (e) ---- 列表B只有一个原子e，B的长度为1。
 * 3.C = (a, (b, c, d)) ---- 列表C的长度为2，两个元素分别为原子a和子表(b, c, d)。
 * 4.D = (A, B, C) ---- 列表D的长度为3,3个元素都是列表。显示，将子表的值代入后，则有D = ((), (e), (a, (b, c, d)))。
 * 5.E = (a, E) ---- 这是一个递归的表，它的长度为2.E相当于一个无限的列表E = (a, (a, (a, ...)))。
 *
 * 1）列表的元素可以是子表，而子表的元素还可以是子表。由此，列表是一个多层次的结构，可以用图形象地表示。
 * 2)列表可为其它列表所共享。列表A，B和C为D的子表，则在D中可以不必列出子表的值。
 * 3）列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如列表E。
 *
 * 任何一个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。
 *
 */

/*
 广义表的递归算法

 递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。

 由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，应注意：
 （1）首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的字问题，只要接口一致，便可进行递归调用。
 （2）对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。
 */

/*
 求广义表的深度

 广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。
 设非空广义表为:
 LS = (a1, a2, ..., an)

 其中ai(i = 1, 2, ..., n)或为原子或为LS的子表，则求LS的深度可分解为n个子问题，每个子问题为求ai的深度，若ai是原子，则由定义其深度为零，若ai是广义表，则递归处理，而LS的深度为各ai(i = 1, 2, ..., n)的深度最大值加1.空表也是广义表，且深度为1.

 广义表的深度DEPTH(LS)的递归定义为：
 基本项：    DEPTH(LS) = 1   当LS为空表时
 DEPTH(LS) = 0   当LS为原子时
 归纳项：    DEPTH(LS) = 1 + MAX{DEPTH(ai)}  1 <= i <= n
 */

var ATOM = Symbol();
var LIST = Symbol();

var global = Function('return this')();
// 使用链队列

// 广义表的头尾链表存储表示
var GLNode = function () {
    function GLNode() {
        (0, _classCallCheck3.default)(this, GLNode);

        // 公共部分，用于区分原子结点和表结点
        this.tag = undefined;

        // atom是原子结点的值域
        this.atom = null;
        // ptr是表结点的指针域
        this.ptr = {
            // ptr.hp和ptr.tp分别指向表头和表尾
            hp: null,
            tp: null
        };
    }

    // 采用头尾链表存储结构，求广义表的深度


    GLNode.prototype.depth = function depth() {
        return getDepth(this);
    };

    // 复制广义表


    GLNode.prototype.copyList = function copyList(gList) {
        gList.tag = this.tag;

        if (this.tag === ATOM) {
            gList.atom = this.atom;
        } else {
            if (this.ptr.hp) {
                gList.ptr.hp = new GLNode();
                this.ptr.hp.copyList(gList.ptr.hp);
            }
            if (this.ptr.tp) {
                gList.ptr.tp = new GLNode();
                this.ptr.tp.copyList(gList.ptr.tp);
            }
        }
    };

    // 采用头尾链表存储结构，由广义表的书写形式串创建广义表


    GLNode.prototype.createGList = function createGList(string) {
        string = string.trim();

        // 创建单原子广义表
        var q = void 0;
        if (isWord(string)) {
            this.tag = ATOM;
            this.atom = string;
        } else {
            this.tag = LIST;
            var p = this;

            // 脱外层括号
            var sub = string.substr(1, string.length - 2);

            do {
                var hsub = void 0;
                var n = sub.length;
                var i = 0;
                var k = 0;
                var ch = void 0;

                do {
                    ch = sub[i++];
                    if (ch == '(') ++k;else if (ch == ')') --k;
                } while (i < n && (ch != ',' || k != 0));

                // i为第一个逗号分隔索引
                if (i < n) {
                    hsub = sub.substr(0, i - 1);
                    sub = sub.substr(i, n - i);

                    // 最后一组
                } else {
                    hsub = sub;
                    sub = '';
                }

                if (hsub === '()') p.ptr.hp = null;
                // 创建表头结点
                else {
                        p.ptr.hp = new GLNode();
                        p.ptr.hp.createGList(hsub);
                    }

                q = p;

                // 创建表尾结点
                if (sub) {
                    p = new GLNode();
                    p.tag = LIST;
                    q.ptr.tp = p;
                }
            } while (sub);

            q.ptr.tp = null;
        }
    };

    GLNode.equal = function equal(gList1, gList2) {
        // 空表时相等的
        if (!gList1 && !gList2) return true;
        if (gList1.tag === ATOM && gList2.tag === ATOM && gList1.atom === gList2.atom) return true;

        if (gList1.tag === LIST && gList2.tag === LIST) {
            // 表头表尾都相等
            if (this.equal(gList1.ptr.hp, gList2.ptr.hp) && this.equal(gList1.ptr.tp, gList2.ptr.tp)) return true;
        }

        return false;
    };

    // 递归逆转广义表


    GLNode.prototype.reverse = function reverse() {
        var ptr = [];
        // 当A不为原子且表尾非空时才需逆转
        if (this.tag === LIST && this.ptr.tp) {
            var i = 0;
            for (var p = this; p; p = p.ptr.tp, i++) {
                // 逆转各子表
                if (p.ptr.hp) p.ptr.hp.reverse();

                ptr[i] = p.ptr.hp;
            }

            // 重新按逆序排列各子表的顺序
            for (var _p = this; _p; _p = _p.ptr.tp) {
                _p.ptr.hp = ptr[--i];
            }
        }
    };

    GLNode.prototype.toString = function toString() {
        var str = '';
        if (this == global || this == null) str = '()';else if (this.tag === ATOM) str = this.atom; // 原子
        else {
                str += '(';

                for (var p = this; p; p = p.ptr.tp) {
                    str += this.toString.call(p.ptr.hp);
                    if (p.ptr.tp) str += ', ';
                }
                str += ')';
            }

        return str;
    };

    // 按层序输出广义表
    // 层序遍历的问题，一般都是借助队列来完成的，每次从队头
    // 取出一个元素的同时把它下一层的孩子插入队尾，这是层序遍历的基本思想


    GLNode.prototype.orderPrint = function orderPrint() {
        var queue = new _Queue2.default();

        for (var p = this; p; p = p.ptr.tp) {
            queue.enQueue(p);
        }while (queue.size) {
            var r = queue.deQueue();
            if (r.tag === ATOM) console.log(r.atom);else {
                for (r = r.ptr.hp; r; r = r.ptr.tp) {
                    queue.enQueue(r);
                }
            }
        }
    };

    return GLNode;
}();

// 广义表的扩展线性链表存储表示


exports.default = GLNode;

var GLNode2 = function GLNode2() {
    (0, _classCallCheck3.default)(this, GLNode2);

    // 公共部分，用于区分原子结点和表结点
    this.tag = undefined;

    // 原子结点的值域
    this.atom = null;
    // 表结点的表头指针
    this.hp = null;

    // 相当于线性链表的next，指向下一个元素结点
    this.tp = null;
};

function getDepth(gList) {
    if (!gList) return 1;else if (gList.tag === ATOM) return 0;

    var m = getDepth(gList.ptr.hp) + 1;
    var n = getDepth(gList.ptr.tp);

    return m > n ? m : n;
}

function isWord(str) {
    return (/^[\w-]+$/.test(str)
    );
}

/*
 m元多项式表示

 如果用线性表来表示,则每个数据元素需要m+1个数据项，以存储一个系数和m个指数值，这将产生两个问题。
 一是无论多项式中各项的变元数是多是少，若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便。二是对m值不同的多项式，线性表中的结点大小也不同，这同样引起存储管理的不便。
 故不适于用线性表表示。

 例如三元多项式：
 P(x, y, z) = x(10)y(3)z(2) + 2x(6)y(3)z(2) + 3x(5)y(2)z(2) + x(4)y(4)z + 2yz + 15

 如若改写为：
 P(x, y, z) = ((x(10) + 2x(6))y(3) + 3x(5)y(2))z(2) + ((x(4) + 6x(3))y(4) + 2y)z + 15

 用广义表表示：
 P = z((A, 2), (B, 1), (15, 0))
 A = y((C, 3), (D, 2))
 B = y((E, 4), (F, 1))
 C = x((1, 10), (2, 6))
 D = x((3, 5))
 E = x((1, 4), (6, 3))
 F = x((2, 0))


 */

function MPNode() {
    // 区分原子结点和表结点
    this.tag = undefined;
    // 指数域
    this.exp = 0;

    // 系数域
    this.coef = 0;
    // 表结点的表头指针
    this.hp = null;

    // 相当于线性表的next，指向下一个元素结点
    this.tp = null;
}

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 邻接多重表

 邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。

 邻接表是无向图的一种有效的存储结构，在无向图的邻接表中，一条边(v,w)的两个表结点分别初选在以v和w为头结点的链表中，很容易求得顶点和边的信息，但在涉及到边的操作会带来不便。

 邻接多重表的结构和十字链表类似，每条边用一个结点表示；邻接多重表中的顶点结点结构与邻接表中的完全相同，而表结点包括六个域。

 ◆  Data域：存储和顶点相关的信息；
 ◆ 指针域firstedge：指向依附于该顶点的第一条边所对应的表结点；
 ◆ 标志域mark：用以标识该条边是否被访问过；
 ◆ ivex和jvex域：分别保存该边所依附的两个顶点在图中的位置；
 ◆ info域：保存该边的相关信息；
 ◆ 指针域ilink：指向下一条依附于顶点ivex的边；
 ◆ 指针域jlink：指向下一条依附于顶点jvex的边；

 邻接多重表与邻接表的区别：
 后者的同一条边用两个表结点表示，而前者只用一个表结点表示；除标志域外，邻接多重表与邻接表表达的信息是相同的，因此，操作的实现也基本相似。

 */

var UNVISITED = 0;
var VISITED = 1;

var EBox =
/**
 * 边的结点表示
 * @param {Number} mark 访问标记 0 -- 未访问  1 == 已访问
 * @param {Number} ivex 该边依附的两个顶点的位置
 * @param {Number} jvex 该边依附的两个顶点的位置
 * @param {EBox} ilink 分别指向依附这两个顶点的下一条边
 * @param {EBox} jlink 分别指向依附这两个顶点的下一条边
 * @param {*} info 该边信息
 * @constructor
 */
function EBox(mark, ivex, jvex, ilink, jlink, info) {
    (0, _classCallCheck3.default)(this, EBox);

    this.mark = mark || UNVISITED;
    this.ivex = ivex || 0;
    this.jvex = jvex || 0;
    this.ilink = ilink || null;
    this.jlink = jlink || null;
    this.info = info || null;
};

var AMLVexBox =
/**
 * 顶点的结点表示
 * @param {*} data
 * @param {EBox} firstEdge 指向第一条依附该顶点的边
 * @constructor
 */
function AMLVexBox(data, firstEdge) {
    (0, _classCallCheck3.default)(this, AMLVexBox);

    this.data = data || null;
    this.firstEdge = firstEdge || null;
};

var AMLGraph = function () {
    /**
     *
     * @param {Array | AMLVexBox} adjMulist
     * @param {Number} vexnum
     * @param {Number} edgenum
     * @constructor
     */
    function AMLGraph(adjMulist, vexnum, edgenum) {
        (0, _classCallCheck3.default)(this, AMLGraph);

        this.adjMulist = adjMulist || [];
        this.vexnum = vexnum || 0;
        this.edgenum = edgenum || 0;
    }

    AMLGraph.prototype.locateVex = function locateVex(v) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.adjMulist[i].data === v) return i;
        }
        return -1;
    };

    AMLGraph.prototype.deleteArc = function deleteArc(v, w) {
        var i = this.locateVex(v);
        var j = this.locateVex(w);

        if (i < 0 || j < 0) throw new Error('Vertex not found!');

        var p;
        // 在i链表中删除该边
        if (this.adjMulist[i].firstEdge.jvex === j) {
            this.adjMulist[i].firstEdge = this.adjMulist[i].firstEdge.ilink;
        } else {
            for (p = this.adjMulist[i].firstEdge; p && p.ilink.jvex !== j; p = p.ilink) {}
            if (!p) throw new Error('edge not found!');
            p.ilink = p.ilink.ilink;
        }

        // 在j链表中删除该边
        if (this.adjMulist[j].firstEdge.ivex === i) {
            this.adjMulist[j].firstEdge = this.adjMulist[j].firstEdge.jlink;
        } else {
            for (p = this.adjMulist[j].firstEdge; p && p.jlink.ivex !== i; p = p.jlink) {}
            if (!p) throw new Error('edge not found!');
            p.jlink = p.jlink.jlink;
        }

        this.edgenum--;
        return true;
    };

    AMLGraph.prototype.createGraph = function createGraph() {
        var vexnum = +prompt('vexnum: ');
        this.vexnum = vexnum;
        var edgenum = +prompt('edgenum: ');
        this.edgenum = edgenum;

        for (var m = 0; m < vexnum; ++m) {
            this.adjMulist[m] = new AMLVexBox(prompt('data: '), null);
        }

        for (m = 0; m < edgenum; ++m) {
            var t = prompt('tailVex: ');
            var h = prompt('headVex: ');
            var i = this.locateVex(t);
            var j = this.locateVex(h);

            if (i < 0 || j < 0) {
                console.error('vertex not found! Try again:');
                m--;
                continue;
            }

            var p = new EBox(0, i, j, null, null);
            var q, r;

            // 插入i链表尾部
            if (!this.adjMulist[i].firstEdge) {
                this.adjMulist[i].firstEdge = p;
            } else {
                q = this.adjMulist[i].firstEdge;
                while (q) {
                    r = q;
                    if (q.ivex === i) q = q.ilink;else q = q.jlink;
                }
                if (r.ivex === i) r.ilink = p;else r.jlink = p;
            }

            // 插入j链表尾部
            if (!this.adjMulist[j].firstEdge) {
                this.adjMulist[j].firstEdge = p;
            } else {
                q = this.adjMulist[j].firstEdge;
                while (q) {
                    r = q;
                    if (q.jvex === j) q = q.jlink;else q = q.ilink;
                }
                if (r.jvex === j) r.jlink = p;else r.ilink = p;
            }
        }
    };

    return AMLGraph;
}();

//var g = new AMLGraph();
//g.createGraph();
//console.log(g);


exports.default = AMLGraph;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

var _BinaryTree = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 图的数组（邻接矩阵）存储表示
var DG = 1; // 有向图
/* Create By Luke */

var DN = 2; // 有向网
var UDG = 3; // 无向图
var UDN = 4; // 无向网


/*
 邻接链表法

 基本思想：对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。

 第i个单链表表示依附于顶点Vi的边(对有向图是以顶点Vi为头或尾的弧)。

 1  结点结构与邻接链表示例

 链表中的结点称为表结点，每个结点由三个域组成。其中邻接点域(adjvex)指示与顶点Vi邻接的顶点在图中的位置(顶点编号)，链域(nextarc)指向下一个与顶点Vi邻接的表结点，数据域(info)存储和边或弧相关的信息，如权值等。对于无权图，如果没有与边相关的其他信息，可省略此域。

 每个链表设一个表头结点(称为顶点结点)，由两个域组成。链域(firstarc)指向链表中的第一个结点，数据域(data) 存储顶点名或其他信息。

 在图的邻接链表表示中，所有顶点结点用一个向量 以顺序结构形式存储，可以随机访问任意顶点的链表，该向量称为表头向量，向量的下标指示顶点的序号。

 用邻接链表存储图时，对无向图，其邻接链表是唯一的；对有向图，其邻接链表有两种形式。


 2  邻接表法的特点

 ◆ 表头向量中每个分量就是一个单链表的头结点，分量个数就是图中的顶点数目；
 ◆ 在边或弧稀疏的条件下，用邻接表表示比用邻接矩阵表示节省存储空间；
 ◆ 在无向图，顶点Vi的度是第i个链表的结点数；
 ◆ 对有向图可以建立正邻接表或逆邻接表。正邻接表是以顶点Vi为出度(即为弧的起点)而建立的邻接表；逆邻接表是以顶点Vi为入度(即为弧的终点)而建立的邻接表；
 ◆ 在有向图中，第i个链表中的结点数是顶点Vi的出 (或入)度；求入 (或出)度，须遍历整个邻接表；
 ◆ 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点；

 */

var ArcNode =
/**
 *
 * @param {Number} adjVex
 * @param {ArcNode} nextArc
 * @param {*} info
 * @constructor
 */
function ArcNode() {
    var adjVex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var nextArc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck3.default)(this, ArcNode);

    // 该弧所指向的顶点的位置
    this.adjVex = adjVex;
    // 指向下一条弧的指针
    this.nextArc = nextArc;
    // 该弧相关信息的指针
    this.info = info;
};

var VexNode =
/**
 *
 * @param {*} data
 * @param {ArcNode} firstArc
 * @param {Number} indegree
 * @constructor
 */
function VexNode(data) {
    var firstArc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var indegree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    (0, _classCallCheck3.default)(this, VexNode);

    // 顶点信息
    this.data = data;
    // 指向第一条依附该顶点的弧的指针
    this.firstArc = firstArc;
    //  顶点的度, 有向图是入度或出度或没有
    this.indegree = indegree;
};

var AdjacencyListGraph = function () {
    /**
     *
     * @param {Array | VexNode} vertices
     * @param {Number} vexnum
     * @param {Number} arcnum
     * @param {Number} kind
     * @constructor
     */
    function AdjacencyListGraph() {
        var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var vexnum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var arcnum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var kind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DG;
        (0, _classCallCheck3.default)(this, AdjacencyListGraph);

        this.vertices = vertices;
        // 图的当前顶点数和弧数
        this.vexnum = vexnum;
        this.arcnum = arcnum;
        // 图的种类标志
        this.kind = kind;
    }

    // 查找顶点位置


    AdjacencyListGraph.prototype.locateVex = function locateVex(vp) {
        for (var _i = 0; _i < this.vexnum; ++_i) {
            if (this.vertices[_i].data === vp) return _i;
        }

        return -1;
    };

    // 添加顶点


    AdjacencyListGraph.prototype.addVertex = function addVertex(vp) {
        if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');

        this.vertices[this.vexnum++] = new VexNode(vp, null, 0);
        return this.vexnum;
    };

    /**
     * 添加弧
     * 如果是无向图或者无向网,arc1和arc2无顺序要求
     * 如果是有向图或者有向网，只会添加arc1，因此正邻接表和逆邻接表的顺序需要注意
     * @param {String} arc1
     * @param {String} arc2
     * @param {*} info
     * @returns {boolean}
     */


    AdjacencyListGraph.prototype.addArc = function addArc(arc1, arc2, info) {
        var k = this.locateVex(arc1);
        var j = this.locateVex(arc2);

        if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');

        // 边的起始表结点赋值
        var p = new ArcNode(k, null, info);
        // 边的末尾表结点赋值
        var q = new ArcNode(j, null, info);

        // 是无向图，用头插入法插入到两个单链表
        if (this.kind === UDG || this.kind === UDN) {
            q.nextArc = this.vertices[k].firstArc;
            this.vertices[k].firstArc = q;
            p.nextArc = this.vertices[j].firstArc;
            this.vertices[j].firstArc = p;
        }
        // 建立有向图的邻接链表，用头插入法
        else {
                p.nextArc = this.vertices[j].firstArc;
                this.vertices[j].firstArc = p;
            }

        ++this.arcnum;

        return true;
    };

    // TODO 其他图类型的创建暂时没弄


    AdjacencyListGraph.prototype.createGraph = function createGraph() {
        this.vexnum = +prompt('vexnum: ');
        this.arcnum = +prompt('arcnum: ');
        // incInfo为0则各弧不含其他信息
        var incInfo = +prompt('incInfo: ');

        for (var _m = 0; _m < this.vexnum; ++_m) {
            this.vertices[_m] = new VexNode();
            this.vertices[_m].data = prompt('vertex: ');
        }

        for (m = 0; m < this.arcnum; ++m) {
            var h = prompt('弧头: ');
            var t = prompt('弧尾: ');
            var _i2 = this.locateVex(t);
            var j = this.locateVex(h);

            if (_i2 < 0 || j < 0) {
                alert('顶点为找到，请重新输入！');
                m--;
                continue;
            }

            var p = new ArcNode(j, null, incInfo && prompt('info: '));

            if (!this.vertices[_i2].firstArc) this.vertices[_i2].firstArc = p;else {
                for (var _q = this.vertices[_i2].firstArc; _q.nextArc; _q = _q.nextArc) {}
                q.nextArc = p;
            }
        }
    };

    // 判断一个邻接表存储的有向图是否可传递


    AdjacencyListGraph.prototype.isPass = function isPass() {
        if (this.kind !== DG) throw new Error('graph kind should be DG');

        for (var x = 0; x < this.vexnum; ++x) {
            for (var p = this.vertices[x].firstArc; p; p = p.nextArc) {
                var y = p.adjVex;
                for (var _q2 = this.vertices[y].firstArc; _q2; _q2 = _q2.nextArc) {
                    var z = _q2.adjVex;
                    if (z !== x && this.isAdj(x, z)) return false;
                }
            }
        }

        return true;
    };

    // 判断有向图是否存在边(m,n)


    AdjacencyListGraph.prototype.isAdj = function isAdj(m, n) {
        for (var p = this.vertices[m].firstArc; p; p = p.nextArc) {
            if (p.adjVex === n) return true;
        }
        return false;
    };

    /**
     * 深度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
     * @param {String} i
     * @param {String} j
     */


    AdjacencyListGraph.prototype.existPathDFS = function existPathDFS(i, j) {
        var visited = [];
        i = this.locateVex(i);
        j = this.locateVex(j);

        if (i < 0 || j < 0) throw new Error('vertex not found!');

        return exist_path(this, i, j);

        function exist_path(graph, i, j) {
            if (i === j) return true;

            visited[i] = true;
            for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (!visited[k] && exist_path(graph, k, j)) return true;
            }

            return false;
        }
    };

    /**
     * 广度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
     * @param {String} i
     * @param {String} j
     */


    AdjacencyListGraph.prototype.existPathBFS = function existPathBFS(i, j) {
        i = this.locateVex(i);
        j = this.locateVex(j);
        var visited = [];
        var queue = new _Queue2.default();
        queue.enQueue(i);

        while (queue.rear) {
            var u = queue.deQueue();
            visited[u] = 1;

            for (var p = this.vertices[i].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (k === j) return true;
                if (!visited[k]) queue.enQueue(k);
            }
        }

        return false;
    };

    /**
     * 判断邻接表方式存储的有向图的顶点i到j是否存在长度为k的简单路径
     * @param {String} i
     * @param {String} j
     * @param {Number} k
     */


    AdjacencyListGraph.prototype.existPathLen = function existPathLen(i, j, k) {
        i = this.locateVex(i);
        j = this.locateVex(j);
        var visited = [];

        return function recurse(graph, i, j, k) {
            // 找到了一条路径，且长度符合
            if (i === j && k === 0) return true;else if (k > 0) {
                visited[i] = 1;
                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                    var l = p.adjVex;
                    if (!visited[l]) {
                        // 剩余路径长度减一
                        if (recurse(graph, l, j, k - 1)) return true;
                    }
                }
                // 允许曾经被访问过的结点出现在另一条路径上
                visited[i] = 0;
            }

            return false;
        }(this, i, j, k);
    };

    /**
     * 求有向图中顶点u到v之间的所有简单路径，k为当前路径长度
     * @param {String} u
     * @param {String} v
     * @param {Number} k
     *
     * @example
     *  graph.findAllPaths('v1', 'v2', 0);
     */


    AdjacencyListGraph.prototype.findAllPaths = function findAllPaths(u, v, k) {
        u = this.locateVex(u);
        v = this.locateVex(v);
        var path = [];
        var visited = [];

        findPath(this, u, v, k);

        function findPath(graph, u, v, k) {
            // 加入当前路径中
            path[k] = u;
            visited[u] = 1;

            // 找到一条简单路径
            if (u === v) {
                console.log('Found one path!');
                for (var _i3 = 0; path[_i3]; ++_i3) {
                    console.log(path[_i3]);
                }
            } else {
                for (var p = graph.vertices[u].firstArc; p; p = p.nextArc) {
                    var l = p.adjVex;
                    // 继续寻找
                    if (!visited[l]) findPath(graph, l, v, k + 1);
                }
            }

            visited[u] = 0;
            // 回溯
            path[k] = 0;
        }
    };

    /**
     * 求有向图的顶点之间长度为len的简单路径条数
     * @param {String} i
     * @param {String} j
     * @param {Number} len
     */


    AdjacencyListGraph.prototype.getPathNum_len = function getPathNum_len(i, j, len) {
        var visited = [];

        return function recurse(graph, i, j, len) {
            if (i === j && len === 0) return 1;else if (len > 0) {
                var sum = 0;
                visited[i] = 1;
                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                    var l = p.adjVex;
                    if (!visited[l]) sum += recurse(l, j, len - 1);
                }
                visited[i] = 0;
                return sum;
            }
        }(this, i, j, len);
    };

    /**
     * 求有向无环图的根
     */


    AdjacencyListGraph.prototype.getRoot = function getRoot() {
        var visited = [];

        for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
            // 每次都要将访问数组清零
            for (var _w = 0; _w < this.vexnum; ++_w) {
                visited[_w] = false;
            } // 从顶点i出发进行深度优先遍历
            dfs(this, _i4);

            var flag = true;
            for (w = 0; w < this.vexnum; ++w) {
                // 如果i是根，则深度优先遍历可以访问到所有结点
                if (!visited[w]) flag = false;
            }

            if (flag) console.log('Found a root vertex: %d', _i4);
        }

        function dfs(graph, v) {
            visited[v] = true;

            for (var p = graph.vertices[v].firstArc; p; p = p.nextArc) {
                var _w2 = p.adjVex;
                if (!visited[_w2]) dfs(graph, _w2);
            }
        }
    };

    /**
     * 求一个有向无环图中最长的路径
     */


    AdjacencyListGraph.prototype.getLongestPath = function getLongestPath() {
        var mlp = [];
        var path = [];
        var visited = [];
        var maxLen = 0;

        this.countIndegree();

        for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
            for (var j = 0; j < this.vexnum; ++j) {
                visited[j] = false;
            } // 从每一个零入度结点开始深度优先遍历
            if (this.vertices[_i5].indegree === 0) dfs(this, _i5, 0);
        }

        console.log('Longest Path:');
        // 输出最长路径
        for (i = 0; mlp[i]; ++i) {
            console.log(mlp.join(','));
        }function dfs(graph, i, len) {
            visited[i] = true;
            path[len] = i;

            // 新的最长路径
            if (len > maxLen && !graph.vertices[i].firstArc) {
                // 保存下来
                for (var _j = 0; _j <= len; ++_j) {
                    mlp[_j] = path[_j];
                }maxLen = len;
            } else {
                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                    var _w3 = p.adjVex;
                    if (!visited[_w3]) dfs(graph, _w3, len + 1);
                }
            }

            path[i] = 0;
            visited[i] = false;
        }
    };

    // 邻接表的递归式深度优先遍历


    AdjacencyListGraph.prototype.DFSTraverse = function DFSTraverse(visitFn) {
        var visited = [];
        for (var _i6 = 0; _i6 < this.vexnum; ++_i6) {
            visited[_i6] = false;
        }for (var _i7 = 0; _i7 < this.vexnum; ++_i7) {
            if (!visited[_i7]) dfs(this, _i7);
        }

        function dfs(graph, v) {
            visited[v] = true;
            visitFn.call(graph, v);

            var p = graph.vertices[v].firstArc;
            while (p) {
                if (!visited[p.adjVex]) dfs(graph, p.adjVex);

                p = p.nextArc;
            }
        }
    };

    // 邻接表的非递归深度优先搜索


    AdjacencyListGraph.prototype.DFSTraverse_NonRecurse = function DFSTraverse_NonRecurse(visitFn) {
        var visited = [];
        var stack = new _index2.default();
        for (var _i8 = 0; _i8 < this.vexnum; ++_i8) {
            visited[_i8] = false;
        }for (var _i9 = 0; _i9 < this.vexnum; ++_i9) {
            if (!visited[_i9]) {
                stack.push(_i9);
                visited[_i9] = true;
                visitFn.call(this, _i9);

                var v = void 0;
                while ((v = stack.peek()) != null) {
                    var p = this.vertices[v].firstArc;
                    while (p) {
                        if (!visited[p.adjVex]) {
                            visited[p.adjVex] = true;
                            visitFn.call(this, p.adjVex);
                            stack.push(p.adjVex);
                        } else stack.pop();

                        p = p.nextArc;
                    }
                }
            }
        }
    };

    // 邻接表的广度优先搜索


    AdjacencyListGraph.prototype.BFSTraverse = function BFSTraverse(visitFn) {
        var queue = new _Queue2.default();
        var visited = [];
        for (var _i10 = 0; _i10 < this.vexnum; ++_i10) {
            visited[_i10] = false;
        }for (var _i11 = 0; _i11 < this.vexnum; ++_i11) {
            if (!visited[_i11]) {
                queue.enQueue(_i11);
                visited[_i11] = true;
                visitFn.call(this, _i11);

                while (queue.rear) {
                    var _w4 = queue.deQueue();
                    var p = this.vertices[_w4].firstArc;
                    while (p) {
                        if (!visited[p.adjVex]) {
                            visited[p.adjVex] = true;
                            visitFn.call(this, p.adjVex);
                            queue.enQueue(p.adjVex);
                        }

                        p = p.nextArc;
                    }
                }
            }
        }
    };

    // 建立无向图的深度优先生成森林的孩子兄弟链表树


    AdjacencyListGraph.prototype.createDFSForest = function createDFSForest() {
        var tree = null;
        var visited = [];
        for (var _i12 = 0; _i12 < this.vexnum; ++_i12) {
            visited[_i12] = false;
        }var q = void 0;
        for (var _i13 = 0; _i13 < this.vexnum; ++_i13) {
            if (!visited[_i13]) {
                // 新的生成树的根结点
                var p = new _BinaryTree.ChildSiblingTree(this.vertices[_i13].data);

                // 第一棵生成树的根
                if (!tree) tree = p;
                // 其它生成树的根
                else q.nextSibling = p;

                // q为当前生成树的根
                q = p;
                // 建立以p为根的生成树
                DFSTree(this, _i13, p);
            }
        }

        return tree;

        // 以第v个顶点触发深度优先遍历图，建立以tree为根的生成树
        function DFSTree(graph, v, tree) {
            visited[v] = true;
            var first = true;
            var w = graph.vertices[v].firstArc;
            var q = void 0;

            while (w) {
                if (!visited[w.adjVex]) {
                    visited[w.adjVex] = true;
                    var _p = new _BinaryTree.ChildSiblingTree(graph.vertices[w.adjVex].data);

                    // w是v的第一个未被访问的邻接结点
                    if (first) {
                        tree.firstChild = _p;
                        first = false;
                    }
                    // w是v的其它未被访问的邻接顶点
                    else q.nextSibling = _p;

                    q = _p;

                    DFSTree(graph, w.adjVex, q);
                }

                w = w.nextArc;
            }
        }
    };

    AdjacencyListGraph.prototype.createBFSForest = function createBFSForest() {
        var tree = null;
        var visited = [];
        var queue = new _Queue2.default();
        for (var _i14 = 0; _i14 < this.vexnum; ++_i14) {
            visited[_i14] = false;
        }var q = void 0;
        for (var _i15 = 0; _i15 < this.vexnum; ++_i15) {
            if (!visited[_i15]) {
                visited[_i15] = true;
                queue.enQueue(_i15);

                var node = new _BinaryTree.ChildSiblingTree(this.vertices[_i15].data);
                if (!tree) tree = node;else q.nextSibling = node;

                q = node;

                while (queue.rear) {
                    var _w5 = queue.deQueue();
                    var p = this.vertices[_w5].firstArc;
                    var first = true;
                    var pre = void 0;

                    while (p) {
                        if (!visited[p.adjVex]) {
                            visited[p.adjVex] = true;
                            queue.enQueue(p.adjVex);

                            var node2 = new _BinaryTree.ChildSiblingTree(this.vertices[p.adjVex].data);

                            if (first) {
                                node.firstChild = node2;
                                first = false;
                            } else pre.nextSibling = node2;

                            pre = node2;
                        }
                        p = p.nextArc;
                    }
                }
            }
        }

        return tree;
    };

    AdjacencyListGraph.prototype.findArticul = function findArticul() {
        var visited = [];
        var count = 1;
        var low = [];
        low[0] = count;
        visited[0] = 1;
        for (var _i16 = 1; _i16 < this.vexnum; ++_i16) {
            visited[_i16] = 0;
        }var p = this.vertices[0].firstArc;
        var v = p.adjVex;

        DFSArticul(this, v);
        if (count < this.vexnum) {
            console.log(0 + '  ' + this.vertices[0].data);
            while (p.nextArc) {
                p = p.nextArc;
                v = p.adjVex;
                if (visited[v] === 0) DFSArticul(this, v);
            }
        }

        function DFSArticul(graph, v0) {
            var min = visited[v0] = ++count;
            for (var _p2 = graph.vertices[v0].firstArc; _p2; _p2 = _p2.nextArc) {
                var _w6 = _p2.adjVex;
                if (visited[_w6] === 0) {
                    DFSArticul(graph, _w6);
                    if (low[_w6] < min) min = low[_w6];
                    if (low[_w6] >= visited[v0]) console.log(v0 + '  ' + graph.vertices[v0].data);
                } else if (visited[_w6] < min) min = visited[_w6];
            }
            low[v0] = min;
        }
    };

    // 统计各顶点入度的函数


    AdjacencyListGraph.prototype.countIndegree = function countIndegree() {
        for (var k = 0; k < this.vexnum; ++k) {
            this.vertices[k].indegree = 0;
        }for (var _k = 0; _k < this.vexnum; ++_k) {
            for (var p = this.vertices[_k].firstArc; p; p = p.nextArc) {
                ++this.vertices[p.adjVex].indegree;
            }
        }
    };

    // 拓扑排序算法


    AdjacencyListGraph.prototype.topologicSort = function topologicSort() {
        var stack = new _index2.default();
        this.topologicalOrder = [];
        this.countIndegree();

        for (var _i17 = 0; _i17 < this.vexnum; ++_i17) {
            if (this.vertices[_i17].indegree === 0) stack.push(_i17);
        }

        var count = 0;
        while (stack.length) {
            var _i18 = stack.pop();
            this.topologicalOrder.push(_i18);
            console.log(this.vertices[_i18].data);
            ++count;
            for (var p = this.vertices[_i18].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (--this.vertices[k].indegree === 0) stack.push(k);
            }
        }

        return count >= this.vexnum;
    };

    // 输出有向图的各项关键活动


    AdjacencyListGraph.prototype.criticalPath = function criticalPath() {
        if (!this.topologicSort()) throw new Error('AOE网中存在回路！');

        var ve = [];
        // 事件最早发生时间初始化
        for (var j = 0; j < this.vexnum; ++j) {
            ve[j] = 0;
        } // 计算每个事件的最早发生时间ve值
        for (var _m2 = 0; _m2 < this.vexnum; ++_m2) {
            var _j2 = this.topologicalOrder[_m2];
            for (var p = this.vertices[_j2].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (ve[_j2] + p.info > ve[k]) ve[k] = ve[_j2] + p.info;
            }
        }
        var vl = [];
        // 事件最晚发生时间初始化
        for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
            vl[_j3] = ve[this.vexnum - 1];
        } // 计算每个事件的最晚发生时间vl的值
        for (var _m3 = this.vexnum - 1; _m3 >= 0; --_m3) {
            var _j4 = this.topologicalOrder[_m3];
            for (var _p3 = this.vertices[_j4].firstArc; _p3; _p3 = _p3.nextArc) {
                var _k2 = _p3.adjVex;
                if (vl[_k2] - _p3.info < vl[_j4]) vl[_j4] = vl[_k2] - _p3.info;
            }
        }
        // 输出所有关键活动
        for (var _m4 = 0; _m4 < this.vexnum; ++_m4) {
            for (var _p4 = this.vertices[_m4].firstArc; _p4; _p4 = _p4.nextArc) {
                var _k3 = _p4.adjVex;
                if (ve[_m4] + _p4.info === vl[_k3]) console.log('<%d, %d>', _m4, _k3);
            }
        }
    };

    AdjacencyListGraph.prototype.shortestPath_Dijkstra = function shortestPath_Dijkstra(v0) {
        var dist = [];
        var pre = [];
        var final = [];
        var w = void 0;

        for (var _v = 0; _v < this.vexnum; ++_v) {
            dist[_v] = Infinity;
        }for (var p = this.vertices[v0].firstArc; p; p = p.nextArc) {
            dist[p.adjVex] = p.info;
        }var v = void 0;
        for (v = 0; v < this.vexnum; ++v) {
            final[v] = false;
            pre[v] = pre[v] || [];
            for (w = 0; w < this.vexnum; ++w) {
                pre[v][w] = false;
            }if (dist[v] < Infinity) {
                pre[v][v0] = true;
                pre[v][v] = true;
            }
        }

        dist[v0] = 0;
        final[v0] = true;

        for (var _i19 = 1; _i19 < this.vexnum; ++_i19) {
            var min = Infinity;
            for (w = 0; w < this.vexnum; ++w) {
                if (!final[w] && dist[w] < min) {
                    v = w;
                    min = dist[w];
                }
            }

            final[v] = true;

            for (var _p5 = this.vertices[v].firstArc; _p5; _p5 = _p5.nextArc) {
                w = _p5.adjVex;
                if (!final[w] && min + _p5.info < dist[w]) {
                    dist[w] = min + _p5.info;
                    pre[w] = pre[v];
                    pre[w][w] = true;
                }
            }
        }

        console.log(final);
        console.log(pre);
        console.log(dist);

        return {
            final: final,
            pre: pre,
            dist: dist
        };
    };

    return AdjacencyListGraph;
}();

// 无向图的邻接表


exports.default = AdjacencyListGraph;
var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
adjListGraph.addVertex('v1');
adjListGraph.addVertex('v2');
adjListGraph.addVertex('v3');
adjListGraph.addVertex('v4');
adjListGraph.addVertex('v5');

adjListGraph.addArc('v1', 'v2');
adjListGraph.addArc('v1', 'v3');
adjListGraph.addArc('v1', 'v4');
adjListGraph.addArc('v2', 'v3');
adjListGraph.addArc('v3', 'v4');
adjListGraph.addArc('v3', 'v5');
adjListGraph.addArc('v4', 'v5');

console.log(adjListGraph);

// 有向图的逆邻接表
var g = new AdjacencyListGraph([], 0, 0, DG);
g.addVertex('v1');
g.addVertex('v2');
g.addVertex('v3');
g.addVertex('v4');
g.addVertex('v5');

g.addArc('v1', 'v2');
g.addArc('v1', 'v4');
g.addArc('v3', 'v2');
g.addArc('v3', 'v1');
g.addArc('v4', 'v3');
g.addArc('v3', 'v5');
g.addArc('v5', 'v4');

console.log(g);

// 有向图的正邻接表
var g = new AdjacencyListGraph([], 0, 0, DG);
g.addVertex('v1');
g.addVertex('v2');
g.addVertex('v3');
g.addVertex('v4');
g.addVertex('v5');

g.addArc('v2', 'v1');
g.addArc('v4', 'v1');
g.addArc('v2', 'v3');
g.addArc('v1', 'v3');
g.addArc('v3', 'v4');
g.addArc('v5', 'v3');
g.addArc('v4', 'v5');

console.log(g);

console.log('adjListGraph DFSTraverse: ');
var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
adjListGraph.addVertex('v1');
adjListGraph.addVertex('v2');
adjListGraph.addVertex('v3');
adjListGraph.addVertex('v4');
adjListGraph.addVertex('v5');

adjListGraph.addArc('v5', 'v4');
adjListGraph.addArc('v3', 'v2');
adjListGraph.addArc('v2', 'v1');
adjListGraph.addArc('v3', 'v1');

adjListGraph.DFSTraverse(function (v) {
    console.log(this.vertices[v].data);
});

console.log('adjListGraph DFSTraverse_NonRecurse: ');
adjListGraph.DFSTraverse_NonRecurse(function (v) {
    console.log(this.vertices[v].data);
});

console.log('adjListGraph BFSTraverse: ');
var g2 = new AdjacencyListGraph([], 0, 0, DG);
g2.addVertex('v1');
g2.addVertex('v2');
g2.addVertex('v3');
g2.addVertex('v4');
g2.addVertex('v5');

g2.addArc('v4', 'v1');
g2.addArc('v2', 'v1');
g2.addArc('v5', 'v3');
g2.addArc('v2', 'v3');
g2.addArc('v1', 'v3');
g2.addArc('v3', 'v4');
g2.addArc('v4', 'v5');

g2.BFSTraverse(function (v) {
    console.log(this.vertices[v].data);
});

console.log('DFS: expect false: ' + adjListGraph.existPathDFS('v1', 'v4'));
console.log('DFS: expect true: ' + adjListGraph.existPathDFS('v1', 'v2'));

console.log('BFS : expect false: ' + adjListGraph.existPathBFS('v1', 'v4'));
console.log('BFS :expect true: ' + adjListGraph.existPathBFS('v1', 'v2'));

/*
 图的连通性问题

 无向图的连通分量与生成树

 1 无向图的连通分量和生成树
 对于无向图，对其进行遍历时：
 ◆ 若是连通图：仅需从图中任一顶点出发，就能访问图中的所有顶点；
 ◆ 若是非连通图：需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集；

 ⑴ 若G=(V,E)是无向连通图， 顶点集和边集分别是V(G) ，E(G) 。若从G中任意点出发遍历时， E(G)被分成两个互不相交的集合：
 T(G) ：遍历过程中所经过的边的集合；
 B(G) ：遍历过程中未经过的边的集合；
 显然： E(G)=T(G)∪B(G) ，T(G)∩B(G)=Ø
 显然，图G’=(V, T(G))是G的极小连通子图，且G’是一棵树。G’称为图G的一棵生成树。
 从任意点出发按DFS算法得到生成树G’称为深度优先生成树；按BFS算法得到的G’称为广度优先生成树。

 ⑵  若G=(V,E)是无向非连通图，对图进行遍历时得到若干个连通分量的顶点集：V1(G) ,V2(G) ,…,Vn(G)和相应所经过的边集：T1(G) ,T2(G) , …,Tn(G) 。
 则对应的顶点集和边集的二元组：Gi=(Vi(G),Ti(G))
 (1≦i≦n)是对应分量的生成树，所有这些生成树构成了原来非连通图的生成森林。

 说明：当给定无向图要求画出其对应的生成树或生成森林时，必须先给出相应的邻接表，然后才能根据邻接表画出其对应的生成树或生成森林。


 2  图的生成树和生成森林算法

 对图的深度优先搜索遍历DFS(或BFS)算法稍作修改，就可得到构造图的DFS生成树算法。
 在算法中，树的存储结构采用孩子—兄弟表示法。首先建立从某个顶点V出发，建立一个树结点，然后再分别以V的邻接点为起始点，建立相应的子生成树，并将其作为V 结点的子树链接到V结点上。显然，算法是一个递归算法。

 */

console.log(adjListGraph.createDFSForest());

console.log(adjListGraph.createBFSForest());

/*
 在某图中，若删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。一个没有关节点的连通图称为重连通图。
 在重连通图中，任意一对顶点之间至少存在两条路径，则再删去某个顶点即相关各边后也不破坏图的连通性。若在图的连通图上删去k个节点才能破坏图的连通性，则称K为此图的连通度。
 他们常常在通信网络的图或航空网中应用，K越大，系统越稳定，反之，战争中若要摧毁敌方的运输线，只须破坏其运输网中的关节点即可。
 */

var articulTest = new AdjacencyListGraph([], 0, 0, UDG);
articulTest.addVertex('A');
articulTest.addVertex('B');
articulTest.addVertex('C');
articulTest.addVertex('D');
articulTest.addVertex('E');
articulTest.addVertex('F');
articulTest.addVertex('G');
articulTest.addVertex('H');
articulTest.addVertex('I');
articulTest.addVertex('J');
articulTest.addVertex('K');
articulTest.addVertex('L');
articulTest.addVertex('M');

articulTest.addArc('A', 'B');
articulTest.addArc('A', 'C');
articulTest.addArc('A', 'F');
articulTest.addArc('A', 'L');
articulTest.addArc('C', 'B');
articulTest.addArc('D', 'B');
articulTest.addArc('G', 'B');
articulTest.addArc('H', 'B');
articulTest.addArc('M', 'B');
articulTest.addArc('D', 'E');
articulTest.addArc('G', 'H');
articulTest.addArc('G', 'I');
articulTest.addArc('G', 'K');
articulTest.addArc('H', 'K');
articulTest.addArc('J', 'L');
articulTest.addArc('J', 'M');
articulTest.addArc('L', 'M');

articulTest.findArticul();

/*
 有向无环图及其应用

 有向无环图(Directed Acycling Graph)：是图中没有回路(环)的有向图。是一类具有代表性的图，主要用于研究工程项目的工序问题、工程时间进度问题等。

 一个工程(project)都可分为若干个称为活动(active)的子工程(或工序)，各个子工程受到一定的条件约束：某个子工程必须开始于另一个子工程完成之后；整个工程有一个开始点(起点)和一个终点。人们关心：
 ◆ 工程能否顺利完成?影响工程的关键活动是什么?
 ◆ 估算整个工程完成所必须的最短时间是多少?

 对工程的活动加以抽象：图中顶点表示活动，有向边表示活动之间的优先关系，这样的有向图称为顶点表示活动的网(Activity On Vertex Network ，AOV网) 。


 拓扑排序

 1 定义
 拓扑排序(Topological Sort) ：由某个集合上的一个偏序得到该集合上的一个全序的操作。

 ◆ 集合上的关系：集合A上的关系是从A到A的关系(AA) 。
 ◆ 关系的自反性：若a∈A有(a，a)∈R，称集合A上的关系R是自反的。
 ◆ 关系的对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。
 ◆ 关系的对称性与反对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。如果对于a，b∈A ，仅当a=b时有(a，b)∈R和(b，a)∈R ，称集合A上的关系R是反对称的。
 ◆ 关系的传递性：若a，b，c∈A，若(a，b)∈R，并且(b，c)∈R ，则(a，c)∈R ，称集合A上的关系R是传递的。
 ◆ 偏序：若集合A上的关系R是自反的，反对称的和传递的，则称R是集合A上的偏序关系。
 ◆ 全序：设R是集合A上的偏序关系，a，b∈A，必有aRb或bRa， 则称R是集合A上的全序关系。

 即偏序是指集合中仅有部分元素之间可以比较，而全序是指集合中任意两个元素之间都可以比较。
 在AOV网中，若有有向边<i, j>，则i是j的直接前驱，j是i的直接后继；推而广之，若从顶点i到顶点j有有向路径，则i是j的前驱，j是i的后继。
 在AOV网中，不能有环，否则，某项活动能否进行是以自身的完成作为前提条件。
 检查方法：对有向图的顶点进行拓扑排序，若所有顶点都在其拓扑有序序列中，则无环。
 有向图的拓扑排序：构造AOV网中顶点的一个拓扑线性序列(v’1,v’2, ⋯,v’n)，使得该线性序列不仅保持原来有向图中顶点之间的优先关系，而且对原图中没有优先关系的顶点之间也建立一种(人为的)优先关系。

 2 拓扑排序算法
 算法思想

 ① 在AOV网中选择一个没有前驱的顶点且输出；
 ② 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧)所有有向弧(边) ；
 ③ 重复①、②，直到图中全部顶点都已输出(图中无环)或图中不存在无前驱的顶点(图中必有环)。

 3  算法实现说明
 ◆ 采用正邻接链作为AOV网的存储结构；
 ◆ 设立堆栈，用来暂存入度为0的顶点；
 ◆ 删除顶点以它为尾的弧：弧头顶点的入度减1。

 整个算法的时间复杂度是O(n+e) 。

 */

var topologicTest = new AdjacencyListGraph([], 0, 0, DG);
topologicTest.addVertex('v1');
topologicTest.addVertex('v2');
topologicTest.addVertex('v3');
topologicTest.addVertex('v4');
topologicTest.addVertex('v5');
topologicTest.addVertex('v6');

topologicTest.addArc('v2', 'v1');
topologicTest.addArc('v4', 'v1');
topologicTest.addArc('v3', 'v1');
topologicTest.addArc('v2', 'v3');
topologicTest.addArc('v5', 'v3');
topologicTest.addArc('v4', 'v6');
topologicTest.addArc('v5', 'v4');
topologicTest.addArc('v5', 'v6');

console.log('topologicSort: ');
console.log(topologicTest.topologicSort());

/*
 关键路径(Critical Path)

 与AOV网相对应的是AOE(Activity On Edge) ，是边表示活动的有向无环图，如图7-24所示。图中顶点表示事件(Event)，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的时间或费用。

 1 与AOE有关的研究问题
 ◆ 完成整个工程至少需要多少时间?
 ◆ 哪些活动是影响工程进度(费用)的关键?
 工程完成最短时间：从起点到终点的最长路径长度(路径上各活动持续时间之和) 。长度最长的路径称为关键路径，关键路径上的活动称为关键活动。关键活动是影响整个工程的关键。
 设v0是起点，从v0到vi的最长路径长度称为事件vi的最早发生时间，即是以vi为尾的所有活动的最早发生时间。
 若活动ai是弧<j, k>，持续时间是dut(<j, k>)，设：
 ◆ e(i)：表示活动ai的最早开始时间；
 ◆ l(i)：在不影响进度的前提下，表示活动ai的最晚开始时间； 则l(i)-e(i)表示活动ai的时间余量，若l(i)-e(i)=0，表示活动ai是关键活动。
 ◆ ve(i)：表示事件vi的最早发生时间，即从起点到顶点vi的最长路径长度；
 ◆ vl(i)：表示事件vi的最晚发生时间。则有以下关系：
 e(i)=ve(j)
 l(i)= vl(k)-dut(<j, k>)
 0    j=0，表示vj是起点
 ve(j)=
 Max{ve(i)+dut(<i, j>)|<vi, vj>是网中的弧}

 含义是：源点事件的最早发生时间设为0；除源点外，只有进入顶点vj的所有弧所代表的活动全部结束后，事件vj才能发生。即只有vj的所有前驱事件vi的最早发生时间ve(i)计算出来后，才能计算ve(j) 。
 方法是：对所有事件进行拓扑排序，然后依次按拓扑顺序计算每个事件的最早发生时间。
 ve(n-1)    j=n-1，表示vj是终点
 vl(j)=
 Min{vl(k)-dut(<j, k>)|<vj, vk>是网中的弧}
 含义是：只有vj的所有后继事件vk的最晚发生时间vl(k)计算出来后，才能计算vl(j) 。
 方法是：按拓扑排序的逆顺序，依次计算每个事件的最晚发生时间。


 2 求AOE中关键路径和关键活动
 ⑴ 算法思想
 ① 利用拓扑排序求出AOE网的一个拓扑序列；
 ②  从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个事件的最早发生时间ve(i) ；
 ③  从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；

 设AOE网有n个事件，e个活动，则算法的主要执行是：
 ◆ 进行拓扑排序：时间复杂度是O(n+e) ；
 ◆ 求每个事件的ve值和vl值：时间复杂度是O(n+e) ；
 ◆ 根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；
 因此，整个算法的时间复杂度是O(n+e) 。

 */

var criticalPathTest = new AdjacencyListGraph([], 0, 0, DG);
criticalPathTest.addVertex('v0');
criticalPathTest.addVertex('v1');
criticalPathTest.addVertex('v2');
criticalPathTest.addVertex('v3');
criticalPathTest.addVertex('v4');
criticalPathTest.addVertex('v5');
criticalPathTest.addVertex('v6');
criticalPathTest.addVertex('v7');
criticalPathTest.addVertex('v8');

criticalPathTest.addArc('v1', 'v0', 3);
criticalPathTest.addArc('v2', 'v0', 10);
criticalPathTest.addArc('v4', 'v1', 13);
criticalPathTest.addArc('v4', 'v2', 12);
criticalPathTest.addArc('v3', 'v1', 9);
criticalPathTest.addArc('v5', 'v2', 7);
criticalPathTest.addArc('v7', 'v4', 6);
criticalPathTest.addArc('v7', 'v3', 4);
criticalPathTest.addArc('v7', 'v5', 11);
criticalPathTest.addArc('v6', 'v3', 8);
criticalPathTest.addArc('v8', 'v7', 5);
criticalPathTest.addArc('v8', 'v6', 2);

criticalPathTest.criticalPath();

var dijTest = new AdjacencyListGraph([], [], 0, 0, DN);

dijTest.addVertex('0');
dijTest.addVertex('1');
dijTest.addVertex('2');
dijTest.addVertex('3');
dijTest.addVertex('4');
dijTest.addVertex('5');

dijTest.addArc('1', '0', 20);
dijTest.addArc('4', '0', 10);
dijTest.addArc('2', '0', 60);
dijTest.addArc('5', '0', 65);
dijTest.addArc('2', '1', 30);
dijTest.addArc('3', '2', 40);
dijTest.addArc('2', '5', 15);
dijTest.addArc('5', '4', 20);
dijTest.addArc('4', '3', 35);
dijTest.addArc('3', '1', 70);

dijTest.shortestPath_Dijkstra(0);

(function () {
    /**
     * 输出有向无环图形式表示的逆波兰式
     */
    function niBoLan_DAG(graph) {
        graph.countIndegree();
        for (var _i20 = 0; _i20 < graph.vexnum; ++_i20) {
            // 找到有向无环图的根
            if (graph.vertices[_i20].indegree === 0) {
                printNiBoLan(graph, _i20);
                break;
            }
        }

        return false;
    }

    function printNiBoLan(graph, i) {
        var c = graph.vertices[i].data;
        var p = graph.vertices[i].firstArc;

        // 子表达式
        if (p) {
            printNiBoLan(graph, p.adjVex);
            printNiBoLan(graph, p.nextArc.adjVex);
        }

        console.log(c + '');
    }

    /**
     * 给有向无环图表示的表达式求值
     */
    function evaluate_DAG(graph) {
        graph.countIndegree();
        for (var _i21 = 0; _i21 < graph.vexnum; ++_i21) {
            if (!graph.vertices[_i21].indegree) return evaluate_imp(graph, _i21);
        }
    }

    function evaluate_imp(g, i) {
        if (/^\d+$/.test(g.vertices[i].data)) return g.vertices[i].data;else {
            var p = g.vertices[i].firstArc;
            var v1 = evaluate_imp(g, p.adjVex);
            var v2 = evaluate_imp(g, p.nextArc.adjVex);
            return calculate(v1, g.vertices[i].data, v2);
        }
    }

    function calculate(a, operation, b) {
        // 偷一下懒..
        return eval(a + operation + b);
    }

    // ((1 + 2) * (2 * (3 + 4)) + (3 + 4) * 5) * ((3 + 4) * 5)
    var dag = new AdjacencyListGraph([], 0, 0, DG);

    var a1 = new String('*');
    var a2 = new String('+');
    var a3 = new String('*');
    var a4 = new String('*');
    var a5 = new String('+');
    var a6 = new String('*');
    var a7 = new String('+');

    // 12
    dag.addVertex(a1);
    dag.addVertex(a2);
    dag.addVertex(a3);
    dag.addVertex(a4);
    dag.addVertex(a5);
    dag.addVertex(a6);
    dag.addVertex(a7);
    dag.addVertex(1);
    dag.addVertex(2);
    dag.addVertex(3);
    dag.addVertex(4);
    dag.addVertex(5);

    // 14
    dag.addArc(a2, a1);
    dag.addArc(a4, a1);
    dag.addArc(a3, a2);
    dag.addArc(a4, a2);
    dag.addArc(a5, a3);
    dag.addArc(a6, a3);
    dag.addArc(a7, a6);
    dag.addArc(a7, a4);
    dag.addArc(5, a4);
    dag.addArc(1, a5);
    dag.addArc(2, a5);
    dag.addArc(2, a6);
    dag.addArc(3, a7);
    dag.addArc(4, a7);

    console.log('niBoLan_DAG: ');
    niBoLan_DAG(dag);
    console.log('evaluate_DAG: ' + evaluate_DAG(dag)); // 2695
})();

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

var _BinaryTree = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 图的数组（邻接矩阵）存储表示
var DG = 1; // 有向图
/* create by Luke */
/**
 * 图(Graph)
 *
 * 图(Graph)是一种比线性表和树更为复杂的数据结构。
 *
 * 线性结构：是研究数据元素之间的一对一关系。在这种结构中，除第一个和最后一个元素外，任何一个元素都有唯一的一个直接前驱和直接后继。
 *
 * 树结构：是研究数据元素之间的一对多的关系。在这种结构中，每个元素对下(层)可以有0个或多个元素相联系，对上(层)只有唯一的一个元素相关，数据元素之间有明显的层次关系。
 *
 * 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。
 *
 * 图的应用极为广泛，已渗入到诸如语言学、逻辑学、物理、化学、电讯、计算机科学以及数学的其它分支。
 *
 * 图的基本概念
 *
 * 一个图(G)定义为一个偶对(V,E) ，记为G=(V,E) 。其中： V是顶点(Vertex)的非空有限集合，记为V(G)；E是无序集V&V的一个子集，记为E(G) ，其元素是图的弧(Arc)。
 * 将顶点集合为空的图称为空图。其形式化定义为：
 G=(V ，E)
 V={v|v∈data object}
 E={<v,w>| v,w∈V∧p(v,w)}
 P(v,w)表示从顶点v到顶点w有一条直接通路。
 *
 * 弧(Arc) ：表示两个顶点v和w之间存在一个关系，用顶点偶对<v,w>表示。通常根据图的顶点偶对将图分为有向图和无向图。
 * 有向图(Digraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是有序的，称图G是有向图。
 *   在有向图中，若 <v,w>∈E(G) ，表示从顶点v到顶点w有一条弧。 其中：v称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) 。
 * 无向图(Undigraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是无序的，称图G是无向图。
 *   在无向图中，若<v,w>∈E(G) ，有<w,v>∈E(G) ，即E(G)是对称，则用无序对(v,w) 表示v和w之间的一条边(Edge)，因此(v,w) 和(w,v)代表的是同一条边。
 *
 * 例1：设有有向图G1和无向图G2，形式化定义分别是：
 G1=(V1 ，E1)
 V1={a,b,c,d,e}
 E1={<a,b>,<a,c>, <a,e>,<c,d>,<c,e> ,<d,a>,<d,b>,<e,d>}
 G2=(V2 ，E2)
 V2={a,b,c,d}
 E2={(a,b), (a,c), (a,d), (b,d), (b,c), (c,d)}
 *
 * 完全无向图：对于无向图，若图中顶点数为n ，用e表示边的数目，则e ∈[0，n(n-1)/2] 。具有n(n-1)/2条边的无向图称为完全无向图。
 完全无向图另外的定义是：
 * 对于无向图G=(V，E)，若vi，vj ∈V ，当vi≠vj时，有(vi ,vj)∈E，即图中任意两个不同的顶点间都有一条无向边，这样的无向图称为完全无向图。
 *
 * 完全有向图：对于有向图，若图中顶点数为n ，用e表示弧的数目，则e∈[0，n(n-1)] 。具有n(n-1)条边的有向图称为完全有向图。
 完全有向图另外的定义是：
 * 对于有向图G=(V，E)，若vi，vj∈V ，当vi ≠vj时，有<vi ,vj>∈E∧<vj , vi >∈E ，即图中任意两个不同的顶点间都有一条弧，这样的有向图称为完全有向图。
 *
 * 有很少边或弧的图（e<n㏒n）的图称为稀疏图，反之称为稠密图。
 * 权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。
 *
 * 子图和生成子图：设有图G=(V，E)和G’=(V’，E’)，若V’∈V且E’∈E ，则称图G’是G的子图；若V’=V且E’∈E，则称图G’是G的一个生成子图。
 * 顶点的邻接(Adjacent)：对于无向图G=(V，E)，若边(v,w)∈E，则称顶点v和w 互为邻接点，即v和w相邻接。边(v,w)依附(incident)与顶点v和w 。
 * 对于有向图G=(V ，E)，若有向弧<v,w>∈E，则称顶点v “邻接到”顶点w，顶点w “邻接自”顶点v ，弧<v,w> 与顶点v和w “相关联” 。
 *
 * 顶点的度、入度、出度：对于无向图G=(V，E)， vi∈V，图G中依附于vi的边的数目称为顶点vi的度(degree)，记为TD(vi)。
 显然，在无向图中，所有顶点度的和是图中边的2倍。 即   ∑TD(vi)=2e      i=1, 2, …, n ，e为图的边数。
 对有向图G=(V，E)，若vi ∈V ，图G中以vi作为起点的有向边(弧)的数目称为顶点vi的出度(Outdegree)，记为OD(vi) ；以vi作为终点的有向边(弧)的数目称为顶点vi的入度(Indegree)，记为ID(vi) 。顶点vi的出度与入度之和称为vi的度，记为TD(vi) 。即
 TD(vi)=OD(vi)+ID(vi)
 *
 * 路径(Path)、路径长度、回路(Cycle) ：对无向图G=(V，E)，若从顶点vi经过若干条边能到达vj，称顶点vi和vj是连通的，又称顶点vi到vj有路径。
 对有向图G=(V，E)，从顶点vi到vj有有向路径，指的是从顶点vi经过若干条有向边(弧)能到达vj。
 或路径是图G中连接两顶点之间所经过的顶点序列。即
 Path=vi0vi1…vim ，vij∈V且(vij-1, vij)∈E   j=1,2, …,m
 或
 Path=vi0vi1 …vim ，vij∈V且<vij-1, vij>∈E  j=1,2, …,m
 路径上边或有向边(弧)的数目称为该路径的长度。
 在一条路径中，若没有重复相同的顶点，该路径称为简单路径；第一个顶点和最后一个顶点相同的路径称为回路(环)；在一个回路中，若除第一个与最后一个顶点外，其余顶点不重复出现的回路称为简单回路(简单环)。
 *
 * 连通图、图的连通分量：对无向图G=(V，E)，若vi ，vj ∈V，vi和vj都是连通的，则称图G是连通图，否则称为非连通图。若G是非连通图，则极大的连通子图称为G的连通分量。
 对有向图G=(V，E)，若vi ，vj ∈V，都有以vi为起点， vj 为终点以及以vj为起点，vi为终点的有向路径，称图G是强连通图，否则称为非强连通图。若G是非强连通图，则极大的强连通子图称为G的强连通分量。
 “极大”的含义：指的是对子图再增加图G中的其它顶点，子图就不再连通。
 生成树、生成森林：一个连通图(无向图)的生成树是一个极小连通子图，它含有图中全部n个顶点和只有足以构成一棵树的n-1条边，称为图的生成树。
 关于无向图的生成树的几个结论：
 ◆ 一棵有n个顶点的生成树有且仅有n-1条边；
 ◆ 如果一个图有n个顶点和小于n-1条边，则是非连通图；
 ◆ 如果多于n-1条边，则一定有环；
 ◆ 有n-1条边的图不一定是生成树。

 有向图的生成森林是这样一个子图，由若干棵有向树组成，含有图中全部顶点。
 有向树是只有一个顶点的入度为0 ，其余顶点的入度均为1的有向图。

 *
 * 网：每个边(或弧)都附加一个权值的图，称为带权图。带权的连通图(包括弱连通的有向图)称为网或网络。网络是工程上常用的一个概念，用来表示一个工程或某种流程
 */

/**
 * 图的存储结构
 *
 图的存储结构比较复杂，其复杂性主要表现在：
 ◆ 任意顶点之间可能存在联系，无法以数据元素在存储区中的物理位置来表示元素之间的关系。
 ◆ 图中顶点的度不一样，有的可能相差很大，若按度数最大的顶点设计结构，则会浪费很多存储单元，反之按每个顶点自己的度设计不同的结构，又会影响操作。
 图的常用的存储结构有：邻接矩阵、邻接链表、十字链表、邻接多重表和边表。
 */

/*
 邻接矩阵(数组)表示法

 基本思想：对于有n个顶点的图，用一维数组vexs[n]存储顶点信息，用二维数组A[n][n]存储顶点之间关系的信息。该二维数组称为邻接矩阵。在邻接矩阵中，以顶点在vexs数组中的下标代表顶点，邻接矩阵中的元素A[i][j]存放的是顶点i到顶点j之间关系的信息。

 1  无向图的数组表示

 (1)  无权图的邻接矩阵
 无向无权图G=(V，E)有n(n≧1)个顶点，其邻接矩阵是n阶对称方阵。其元素的定义如下：
            -- 1   若(vi , vj)∈E，即vi , vj邻接
 A[i][j]=
             -- 0   若(vi , vj)∉E，即vi , vj不邻接

 (2)  带权图的邻接矩阵
 无向带权图G=(V，E) 的邻接矩阵。其元素的定义如下：
            -- Wij    若(vi , vj)∈E，即vi , vj邻接，权值为wij
 A[i][j]=

            -- ∞   若(vi , vj)∉E，即vi , vj不邻接时

 (3)  无向图邻接矩阵的特性
 ◆ 邻接矩阵是对称方阵
 ◆ 对于顶点vi，其度数是第i行的非0元素的个数；
 ◆ 无向图的边数是上(或下)三角形矩阵中非0元素个数。

 2  有向图的数组表示

 (1)  无权图的邻接矩阵
 若有向无权图G=(V，E)有n(n≧1)个顶点，则其邻接矩阵是n阶对称方阵。元素定义如下：
            -- 1   若<vi, vj>∈E，从vi到vj有弧
 A[i][j]=
            -- 0   若<vi , vj>∉E  从vi到vj 没有弧

 (2)  带权图的邻接矩阵
 有向带权图G=(V，E)的邻接矩阵。其元素的定义如下：
            -- wij    若<vi,vj>∈E，即vi , vj邻接，权值为wij
 A[i][j]=
            ∞   若<vi,vj>∉E，即vi , vj不邻接时

 ⑶ 有向图邻接矩阵的特性
 ◆ 对于顶点vi，第i行的非0元素的个数是其出度OD(vi)；第i列的非0元素的个数是其入度ID(vi) 。
 ◆ 邻接矩阵中非0元素的个数就是图的弧的数目。

 3  图的邻接矩阵的操作

 图的邻接矩阵的实现比较容易，定义两个数组分别存储顶点信息(数据元素)和边或弧的信息(数据元素之间的关系) 。

 */

var DN = 2; // 有向网
var UDG = 3; // 无向图
var UDN = 4; // 无向网


var ArcCell =
/**
 *
 * @param {Number} adj
 * @param {*} info
 * @constructor
 */
function ArcCell(adj) {
    var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, ArcCell);

    // 顶点类型。对于无权图，用1或0表示相邻否；对带权图，则为权值类型
    this.adj = typeof adj === 'number' ? adj : Infinity;
    // 该弧相关信息
    this.info = info;
};

var AdjacencyMatrixGraph = function () {
    /**
     *
     * @param {Array} vexs 顶点向量
     * @param {Array | ArcCell} arcs 邻接矩阵
     * @param {Number} vexnum
     * @param {Number} arcnum
     * @param {Number} kind
     * @constructor
     */
    function AdjacencyMatrixGraph() {
        var vexs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var arcs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var vexnum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var arcnum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var kind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DG;
        (0, _classCallCheck3.default)(this, AdjacencyMatrixGraph);

        // 顶点向量
        this.vexs = vexs;
        // 邻接矩阵
        this.arcs = arcs;
        // 图的当前顶点数
        this.vexnum = vexnum;
        // 图的当前弧数
        this.arcnum = arcnum;
        // 图的种类标志
        this.kind = kind;
    }

    AdjacencyMatrixGraph.prototype.createGraph = function createGraph() {
        switch (this.kind) {
            case DG:
                return createDG(this); // 构造有向图
            case DN:
                return createDN(this); // 构造有向网
            case UDG:
                return createUDG(this); // 构造无向图
            case UDN:
                return createUDN(this); // 构造无向网
            default:
                throw new Error('非有效的图类型');
        }
    };

    /**
     * 查找顶点
     * @param {*} vp 顶点向量
     * @returns {number}
     */


    AdjacencyMatrixGraph.prototype.locateVex = function locateVex(vp) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.vexs[i] === vp) return i;
        }

        return -1;
    };

    /**
     * 向图中增加顶点
     * @param {*} vp 顶点向量
     */


    AdjacencyMatrixGraph.prototype.addVertex = function addVertex(vp) {
        if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');

        var k = this.vexnum;
        this.vexs[this.vexnum++] = vp;

        var value = this.kind === DG || this.kind === UDG ? 0 : Infinity;
        for (var j = 0; j < this.vexnum; ++j) {
            this.arcs[j] = this.arcs[j] || [];
            this.arcs[k] = this.arcs[k] || [];
            this.arcs[j][k] = this.arcs[j][k] || new ArcCell();
            this.arcs[k][j] = this.arcs[k][j] || new ArcCell();
            this.arcs[j][k].adj = this.arcs[k][j].adj = value;
        }
    };

    /**
     * 向图中增加一条弧
     * @param {*} vex1 顶点1向量
     * @param {*} vex2 顶点2向量
     * @param {ArcCell} arc
     * @returns {boolean}
     */


    AdjacencyMatrixGraph.prototype.addArc = function addArc(vex1, vex2, arc) {
        arc = arc || new ArcCell(this.kind === DG || this.kind === UDG ? 1 : 'weight');
        var k = this.locateVex(vex1);
        var j = this.locateVex(vex2);

        if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');

        this.arcs[k][j].adj = arc.adj;
        this.arcs[k][j].info = arc.info;
        // 无向图或无向网
        if (this.kind === UDG || this.kind === UDN) {
            this.arcs[j][k].adj = arc.adj;
            this.arcs[j][k].info = arc.info;
        }

        ++this.arcnum;

        return true;
    };

    /**
     * 删除顶点
     * @param {String} vex 要删除的顶点
     */


    AdjacencyMatrixGraph.prototype.deleteVex = function deleteVex(vex) {
        var n = this.vexnum - 1;
        var m = this.locateVex(vex);

        if (m < 0) return false;

        // 将待删除顶点交换到最后一个顶点
        var temp = this.vexs[m];
        this.vexs[m] = this.vexs[n];
        this.vexs[n] = temp;

        // 将边的关系随之交换
        for (var i = 0; i <= n; ++i) {
            this.arcs[i][m] = this.arcs[i][n];
            this.arcs[m][i] = this.arcs[n][i];
        }

        this.arcs[m][m].adj = 0;
        this.vexs.length = --this.vexnum;
        return true;
    };

    /**
     * 删除边(v, w)
     * @param {String} v
     * @param {String} w
     * @returns {boolean}
     */


    AdjacencyMatrixGraph.prototype.deleteArc = function deleteArc(v, w) {
        var i = this.locateVex(v);
        var j = this.locateVex(w);

        if (i < 0 || j < 0) return false;

        if (this.arcs[i][j].adj) {
            this.arcs[i][j].adj = 0;
            this.arcnum--;
        }

        return true;
    };

    // 判断一个邻接矩阵存储的有向图是否可传递


    AdjacencyMatrixGraph.prototype.isPass = function isPass() {
        if (this.kind !== DG) throw new Error('graph kind should be DG');

        for (var x = 0; x < this.vexnum; ++x) {
            for (var y = 0; y < this.vexnum; ++y) {
                if (this.arcs[x][y]) {
                    for (var z = 0; z < this.vexnum; ++z) {
                        if (z !== x && this.arcs[y][z] && !this.arcs[x][z]) return false;
                    }
                }
            }
        }

        return true;
    };

    AdjacencyMatrixGraph.prototype.firstAdjVex = function firstAdjVex(v) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
        }

        return -1;
    };

    AdjacencyMatrixGraph.prototype.nextAdjVex = function nextAdjVex(v, w) {
        for (var i = w + 1; i < this.vexnum; ++i) {
            if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
        }

        return -1;
    };

    // 对邻接矩阵图作递归式深度优先遍历


    AdjacencyMatrixGraph.prototype.DFSTraverse = function DFSTraverse(visitFn) {
        var visited = [];
        // 访问标志数组初始化
        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        }for (var _i = 0; _i < this.vexnum; ++_i) {
            if (!visited[_i]) dfs(this, _i);
        }

        function dfs(graph, vertex) {
            visited[vertex] = true;
            visitFn.call(graph, vertex);

            for (var j = 0; j < graph.vexnum; ++j) {
                if (graph.arcs[vertex][j].adj !== 0 && graph.arcs[vertex][j].adj !== Infinity && !visited[j]) dfs(graph, j);
            }
        }
    };

    // 非递归


    AdjacencyMatrixGraph.prototype.DFSTraverse_NonRecurse = function DFSTraverse_NonRecurse(visitFn) {
        var visited = [];
        var stack = new _index2.default();
        var me = this;
        // 访问标志数组初始化
        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        }for (var _i2 = 0; _i2 < this.vexnum; ++_i2) {
            if (!visited[_i2]) {
                stack.push(_i2);
                visited[_i2] = true;
                visitFn.call(me, _i2);

                var vertex = void 0;
                while ((vertex = stack.peek()) != null) {
                    for (var j = 0; j < this.vexnum; ++j) {
                        if (this.arcs[vertex][j].adj !== 0 && this.arcs[vertex][j].adj !== Infinity && !visited[j]) {
                            visitFn.call(me, j);
                            visited[j] = true;
                            stack.push(j);
                        } else stack.pop();
                    }
                }
            }
        }
    };

    // 对邻接矩阵图作广度优先遍历


    AdjacencyMatrixGraph.prototype.BFSTraverse = function BFSTraverse(visitFn) {
        var visited = [];
        var queue = new _Queue2.default();

        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        }for (var _i3 = 0; _i3 < this.vexnum; ++_i3) {
            if (!visited[_i3]) {
                visited[_i3] = true;
                visitFn.call(this, _i3);
                queue.enQueue(_i3);

                while (queue.rear) {
                    var u = queue.deQueue();

                    for (var j = 0; j < this.vexnum; ++j) {
                        if (this.arcs[u][j].adj !== 0 && this.arcs[u][j].adj !== Infinity && !visited[j]) {
                            visited[j] = true;
                            visitFn.call(this, j);
                            queue.enQueue(j);
                        }
                    }
                }
            }
        }
    };

    AdjacencyMatrixGraph.prototype.minSpanTree_PRIM = function minSpanTree_PRIM(u) {
        var closedge = [];

        // 初始化
        for (var j = 0; j < this.vexnum; ++j) {
            closedge[j] = { adjvex: u, lowcost: +this.arcs[j][u].adj };
        }
        closedge[u].lowcost = 0;

        var te = [];
        // 选择其余this.vexnum - 1个顶点
        for (var _j = 0; _j < this.vexnum - 1; ++_j) {
            var min = Infinity;
            var k = void 0;
            for (var v = 0; v < this.vexnum; ++v) {
                if (closedge[v].lowcost !== 0 && closedge[v].lowcost < min) {
                    min = closedge[v].lowcost;
                    k = v;
                }
            }

            te[_j] = {
                vex1: closedge[k].adjvex,
                vex2: k,
                weight: closedge[k].lowcost
            };
            closedge[k].lowcost = 0;
            for (var _v = 0; _v < this.vexnum; ++_v) {
                if (this.arcs[_v][k].adj < closedge[_v].lowcost) {
                    closedge[_v].lowcost = this.arcs[_v][k].adj;
                    closedge[_v].adjvex = k;
                }
            }
        }

        return te;
    };

    AdjacencyMatrixGraph.prototype.minSpanTree_Kruskal = function minSpanTree_Kruskal() {
        var set = [];
        var te = [];

        for (var i = 0; i < this.vexnum; ++i) {
            set[i] = i;
        }var k = 0;
        var min = Infinity;
        var a = 0;
        var b = 0;
        while (k < this.vexnum - 1) {
            for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
                for (var j = _i4 + 1; j < this.vexnum; ++j) {
                    if (this.arcs[_i4][j].adj < min) {
                        min = this.arcs[_i4][j].adj;
                        a = _i4;
                        b = j;
                    }
                }
            }

            if (set[a] !== set[b]) {
                te[k++] = {
                    vex1: a,
                    vex2: b,
                    weight: this.arcs[a][b].adj
                };

                for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
                    if (set[_i5] === set[b] && _i5 !== b) set[_i5] = set[a];
                }
                set[b] = set[a];
            }

            min = this.arcs[a][b].adj = Infinity;
        }

        return te;
    };

    /**
     * 用Dijkstra算法求有向网的v0顶点到其余顶点v的最短路径pre[v]及其带权长度dist[v]。
     * 若pre[v][w]为true，则w是从v0到v当前求得最短路径上的顶点。
     * final[v]为true当且仅当v∈S，即已经求得v0到v的最短路径
     * @param v0
     */


    AdjacencyMatrixGraph.prototype.shortestPath_Dijkstra = function shortestPath_Dijkstra(v0) {
        var pre = [];
        var dist = [];
        var final = [];
        var w = void 0,
            v = void 0;

        for (var _v2 = 0; _v2 < this.vexnum; ++_v2) {
            final[_v2] = false;
            dist[_v2] = this.arcs[v0][_v2].adj;
            pre[_v2] = pre[_v2] || [];
            // 设空路径
            for (w = 0; w < this.vexnum; ++w) {
                pre[_v2][w] = false;
            }if (dist[_v2] < Infinity) {
                pre[_v2][v0] = true;
                pre[_v2][_v2] = true;
            }
        }

        // 初始化，v0顶点属于S集
        dist[v0] = 0;
        final[v0] = true;

        // 开始主循环，每次求得v0到某个v顶点的最短路径，并加v到S集

        // 其余的顶点
        for (var i = 1; i < this.vexnum; ++i) {
            var min = Infinity;
            // 当前所指离v0顶点的最近距离
            for (w = 0; w < this.vexnum; ++w) {
                // w顶点在V - S中
                // 且w顶点离v0顶点更近
                if (!final[w] && dist[w] < min) {
                    v = w;
                    min = dist[w];
                }
            }

            // 离v0顶点最近的v加入S集
            final[v] = true;
            // 更新当前最短路径及距离
            for (w = 0; w < this.vexnum; ++w) {
                if (!final[w] && min + this.arcs[v][w].adj < dist[w]) {
                    dist[w] = min + this.arcs[v][w].adj;
                    pre[w] = pre[v];
                    pre[w][w] = true;
                }
            }
        }

        console.log(final);
        console.log(pre);
        console.log(dist);

        return {
            final: final,
            pre: pre,
            dist: dist
        };
    };

    AdjacencyMatrixGraph.prototype.shortestPath_FLOYD = function shortestPath_FLOYD() {
        var a = [];
        var path = [];

        for (var j = 0; j < this.vexnum; ++j) {
            a[j] = a[j] || [];
            path[j] = path[j] || [];
            for (var k = 0; k < this.vexnum; ++k) {
                if (j === k) a[j][k] = 0;else a[j][k] = this.arcs[j][k].adj;
                path[j][k] = -1;
            }
        }

        for (var m = 0; m < this.vexnum; ++m) {
            for (var _j2 = 0; _j2 < this.vexnum; ++_j2) {
                for (var _k = 0; _k < this.vexnum; ++_k) {
                    if (a[_j2][m] + a[m][_k] < a[_j2][_k]) {
                        a[_j2][_k] = a[_j2][m] + a[m][_k];
                        path[_j2][_k] = m;
                    }
                }
            }
        }

        for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
            for (var _k2 = 0; _k2 < this.vexnum; ++_k2) {
                if (_j3 !== _k2) {
                    console.log('%d到%d的最短路径为：', _j3, _k2);
                    console.log('%d ', _j3);prn_pass(_j3, _k2);
                    console.log('%d ', _k2);
                    console.log('最短路径长度为： %d', a[_j3][_k2]);
                }
            }
        }

        function prn_pass(j, k) {
            if (path[j][k] !== -1) {
                prn_pass(j, path[j][k]);
                console.log(', %d', path[j][k]);
                prn_pass(path[j][k], k);
            }
        }
    };

    return AdjacencyMatrixGraph;
}();

exports.default = AdjacencyMatrixGraph;


var createDG = createGraph(DG);
var createDN = createGraph(DN);
var createUDG = createGraph(UDG);
var createUDN = createGraph(UDN);

function createGraph(kind) {
    var adj = void 0;
    var setMatrixValue = void 0;

    if (kind === 2 || kind === 4) {
        adj = Infinity;
        setMatrixValue = function setMatrixValue() {
            return prompt('weight: ');
        };
    } else {
        adj = 0;
        setMatrixValue = function setMatrixValue() {
            return 1;
        };
    }

    return function (AdjacencyMatrixGraph) {
        AdjacencyMatrixGraph.vexnum = parseInt(prompt('vexnum: '), 10);
        AdjacencyMatrixGraph.arcnum = parseInt(prompt('arcnum: '), 10);
        // incInfo为0则各弧不含其他信息
        var incInfo = parseInt(prompt('incInfo: '), 10);

        // 构造顶点向量
        var i = void 0,
            j = void 0;
        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
            AdjacencyMatrixGraph.vexs[i] = prompt('顶点向量vex: ');
        } // 初始化邻接矩阵
        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
            for (j = 0; j < AdjacencyMatrixGraph.vexnum; ++j) {
                AdjacencyMatrixGraph.arcs[i] = AdjacencyMatrixGraph.arcs[i] || [];
                AdjacencyMatrixGraph.arcs[i][j] = new ArcCell(adj, null);
            }
        }

        // 构造邻接矩阵
        for (var k = 0; k < AdjacencyMatrixGraph.arcnum; ++k) {
            // 输入一条边依附的顶点及权值
            var v1 = prompt('v1: ');
            var v2 = prompt('v2: ');

            // 确定v1，v2在G中的位置
            i = AdjacencyMatrixGraph.locateVex(v1);
            j = AdjacencyMatrixGraph.locateVex(v2);

            var w = setMatrixValue();
            // 弧<v1, v2>的权值
            AdjacencyMatrixGraph.arcs[i][j].adj = w;
            if (incInfo) AdjacencyMatrixGraph.arcs[i][j].info = prompt('info: ');
            if (kind === 3 || kind === 4) AdjacencyMatrixGraph.arcs[j][i] = AdjacencyMatrixGraph.arcs[i][j];
        }
    };
}

// 第一种创建图方法
var vexs = ['a', 'b', 'c', 'd', 'e'];
var arcs = [[{ "adj": Infinity, "info": null }, { "adj": "6", "info": null }, { "adj": "2", "info": null }, { "adj": Infinity, "info": null }, { "adj": Infinity, "info": null }], [{ "adj": "6", "info": null }, { "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": "4", "info": null }, { "adj": "3", "info": null }], [{ "adj": "2", "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "4", "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }, { "adj": Infinity, "info": null }]];
var udn = new AdjacencyMatrixGraph(vexs, arcs, 5, 7, 4);

// 第二种创建图方法
var dn = new AdjacencyMatrixGraph([], [], 0, 0, 2);
dn.addVertex('a');
dn.addVertex('b');
dn.addVertex('c');
dn.addVertex('d');
dn.addVertex('e');

dn.addArc('a', 'b', {
    adj: 6
});
dn.addArc('a', 'c', {
    adj: 2
});
dn.addArc('c', 'b', {
    adj: 3
});
dn.addArc('c', 'd', {
    adj: 1
});
dn.addArc('d', 'b', {
    adj: 4
});
dn.addArc('b', 'e', {
    adj: 3
});
dn.addArc('d', 'e', {
    adj: 5
});

console.log(dn);

/*

 // 第三种创建图方法
 let g = new AdjacencyMatrixGraph();
 g.kind = DN;
 g.createGraph();
 console.log(g);

 */

/*
 图的遍历

 图的遍历(Travering Graph)：从图的某一顶点出发，访遍图中的其余顶点，且每个顶点仅被访问一次。图的遍历算法是各种图的操作的基础。

 ◆ 复杂性：图的任意顶点可能和其余的顶点相邻接，可能在访问了某个顶点后，沿某条路径搜索后又回到原顶点。
 ◆ 解决办法：在遍历过程中记下已被访问过的顶点。设置一个辅助向量Visited[1…n](n为顶点数)，其初值为0，一旦访问了顶点vi后，使Visited[i]为1或为访问的次序号。
 图的遍历算法有深度优先搜索算法和广度优先搜索算法。

 深度优先搜索(Depth First Search--DFS)遍历类似树的先序遍历，是树的先序遍历的推广。

 算法思想
 设初始状态时图中的所有顶点未被访问，则：
 ⑴ ：从图中某个顶点vi出发，访问vi；然后找到vi的一个邻接顶点vi1 ；
 ⑵：从vi1出发，深度优先搜索访问和vi1相邻接且未被访问的所有顶点；
 ⑶：转⑴ ，直到和vi相邻接的所有顶点都被访问为止
 ⑷ ：继续选取图中未被访问顶点vj作为起始顶点，转(1)，直到图中所有顶点都被访问为止。


 广度优先搜索(Breadth First Search--BFS)遍历类似树的按层次遍历的过程。

 算法思想
 设初始状态时图中的所有顶点未被访问，则：
 ⑴ ：从图中某个顶点vi出发，访问vi；
 ⑵：访问vi的所有相邻接且未被访问的所有顶点vi1，vi2，…，vim；
 ⑶：以vi1，vi2， …，vim的次序，以vij(1≦j≦m)依此作为vi ，转⑴；
 ⑷ ：继续选取图中未被访问顶点vk作为起始顶点，转⑴，直到图中所有顶点都被访问为止。

 用广度优先搜索算法遍历图与深度优先搜索算法遍历图的唯一区别是邻接点搜索次序不同.
 */

console.log('DFSTraverse: udn');

var g1 = new AdjacencyMatrixGraph([], [], 0, 0, UDG);
g1.addVertex('v1');
g1.addVertex('v3');
g1.addVertex('v2');
g1.addVertex('v4');
g1.addVertex('v5');

g1.addArc('v5', 'v4');
g1.addArc('v3', 'v1');
g1.addArc('v2', 'v1');
g1.addArc('v3', 'v2');

g1.DFSTraverse(function (v) {
    console.log(this.vexs[v]);
});

console.log('DFSTraverse_NonRecurse: udn');
g1.DFSTraverse_NonRecurse(function (v) {
    console.log(this.vexs[v]);
});

console.log('BFSTraverse: ');
var bsfG = new AdjacencyMatrixGraph([], [], 0, 0, DG);
bsfG.addVertex('v1');
bsfG.addVertex('v2');
bsfG.addVertex('v3');
bsfG.addVertex('v4');
bsfG.addVertex('v5');

bsfG.addArc('v1', 'v4');
bsfG.addArc('v1', 'v2');
bsfG.addArc('v3', 'v5');
bsfG.addArc('v3', 'v2');
bsfG.addArc('v3', 'v1');
bsfG.addArc('v4', 'v3');
bsfG.addArc('v5', 'v4');

bsfG.BFSTraverse(function (v) {
    console.log(this.vexs[v]);
});

/*
 最小生成树

 如果连通图是一个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。

 最小生成树(Minimum Spanning Tree) ：带权连通图中代价最小的生成树称为最小生成树。

 最小生成树在实际中具有重要用途，如设计通信网。设图的顶点表示城市，边表示两个城市之间的通信线路，边的权值表示建造通信线路的费用。n个城市之间最多可以建n(n-1)/2条线路，如何选择其中的n-1条，使总的建造费用最低?

 构造最小生成树的算法有许多，基本原则是：
 ◆ 尽可能选取权值最小的边，但不能构成回路；
 ◆ 选择n-1条边构成最小生成树。
 以上的基本原则是基于MST的如下性质：
 设G=(V，E)是一个带权连通图，U是顶点集V的一个非空子集。若u∈U ，v∈V-U，且(u, v)是U中顶点到V-U中顶点之间权值最小的边，则必存在一棵包含边(u, v)的最小生成树。

 证明： 用反证法证明。
 设图G的任何一棵最小生成树都不包含边(u,v)。设T是G的一棵生成树，则T是连通的，从u到v必有一条路径(u,…,v)，当将边(u,v)加入到T中时就构成了回路。则路径(u, …,v)中必有一条边(u’,v’) ，满足u’∈U ，v’∈V-U 。删去边(u’,v’) 便可消除回路，同时得到另一棵生成树T’。
 由于(u,v)是U中顶点到V-U中顶点之间权值最小的边，故(u,v)的权值不会高于(u’,v’)的权值，T’的代价也不会高于T， T’是包含(u,v) 的一棵最小生成树，与假设矛盾。

 */

/*
 普里姆(Prim)算法

 适合边稠密的网

 从连通网N=(U，E)中找最小生成树T=(U，TE) 。

 1 算法思想
 ⑴  若从顶点v0出发构造，U={v0}，TE={}；
 ⑵ 先找权值最小的边(u，v)，其中u∈U且v∈V-U，并且子图不构成环，则U= U∪{v}，TE=TE∪{(u，v)} ；
 ⑶ 重复⑵ ，直到U=V为止。则TE中必有n-1条边， T=(U，TE)就是最小生成树。

 2.算法实现说明
 为便于算法实现，设置一个一维数组closedge[n]，用来保存V- U中各顶点到U中顶点具有权值最小的边。
 closedge[j].adjvex=k，表明边(vj, vk)是V-U中顶点vj到U中权值最小的边，而顶点vk是该边所依附的U中的顶点。 closedge[j].lowcost存放该边的权值。
 假设从顶点vs开始构造最小生成树。初始时令：
 Closedge[s].lowcost=0 ：表明顶点vs首先加入到U中；
 Closedge[k].adjvex=s ，Closedge[k].lowcost=cost(k, s)
 表示V-U中的各顶点到U中权值最小的边(k≠s) ，cost(k, s)表示边(vk, vs) 权值。

 3.算法步骤
 ⑴  从closedge中选择一条权值(不为0)最小的边(vk, vj) ，然后做：
 ① 置closedge[k].lowcost为0 ，表示vk已加入到U中。
 ②  根据新加入vk的更新closedge中每个元素：
 vi∈V-U ，若cost(i, k)≦colsedge[i].lowcost，表明在U中新加入顶点vk后， (vi, vk)成为vi到U中权值最小的边，置：
 Closedge[i].lowcost=cost(i, k)
 Closedge[i].adjvex=k
 ⑵  重复⑴n-1次就得到最小生成树。

 算法分析：
 设带权连通图有n个顶点，则算法的主要执行是二重循环： 求closedge中权值最小的边，频度为n-1； 修改closedge数组，频度为n 。因此，整个算法的时间复杂度是O(n2)，与边的数目无关。

 */

udn = new AdjacencyMatrixGraph([], [], 0, 0, 4);
udn.addVertex('v1');
udn.addVertex('v2');
udn.addVertex('v3');
udn.addVertex('v4');
udn.addVertex('v5');
udn.addVertex('v6');

udn.addArc('v1', 'v2', { adj: 6 });
udn.addArc('v1', 'v3', { adj: 1 });
udn.addArc('v1', 'v4', { adj: 5 });
udn.addArc('v2', 'v3', { adj: 5 });
udn.addArc('v2', 'v5', { adj: 3 });
udn.addArc('v3', 'v4', { adj: 5 });
udn.addArc('v3', 'v5', { adj: 6 });
udn.addArc('v3', 'v6', { adj: 4 });
udn.addArc('v4', 'v6', { adj: 2 });
udn.addArc('v5', 'v6', { adj: 6 });

console.log('minSpanTree_PRIM: ');
console.log(udn.minSpanTree_PRIM(0));

/*
 克鲁斯卡尔(Kruskal)算法

 适合边稀疏的网

 1 算法思想
 设G=(V, E)是具有n个顶点的连通网，T=(U, TE)是其最小生成树。初值：U=V，TE={} 。
 对G中的边按权值大小从小到大依次选取。
 ⑴   选取权值最小的边(vi，vj)，若边(vi，vj)加入到TE后形成回路，则舍弃该边(边(vi，vj) ；否则，将该边并入到TE中，即TE=TE∪{(vi，vj)} 。
 ⑵ 重复⑴ ，直到TE中包含有n-1条边为止。
 如图7-22所提示。

 2 算法实现说明
 Kruskal算法实现的关键是：当一条边加入到TE的集合后，如何判断是否构成回路?
 简单的解决方法是：定义一个一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。
 ◆ 初值：Vset[i]=i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。
 ◆ 当往T中增加一条边(vi，vj) 时，先检查Vset[i]和Vset[j]值：
 ☆ 若Vset[i]=Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路；
 ☆ 若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。
 ◆ 加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号。

 */

console.log('minSpanTree_Kruskal: ');
console.log(udn.minSpanTree_Kruskal());

/*
 最短路径

 若用带权图表示交通网，图中顶点表示地点，边代表两地之间有直接道路，边上的权值表示路程(或所花费用或时间) 。从一个地方到另一个地方的路径长度表示该路径上各边的权值之和。问题：
 ◆ 两地之间是否有通路?
 ◆ 在有多条通路的情况下，哪条最短?
 考虑到交通网的有向性，直接讨论的是带权有向图的最短路径问题，但解决问题的算法也适用于无向图。
 将一个路径的起始顶点称为源点，最后一个顶点称为终点。


 单源点最短路径

 对于给定的有向图G=(V，E)及单个源点Vs，求Vs到G的其余各顶点的最短路径。
 针对单源点的最短路径问题，Dijkstra提出了一种按路径长度递增次序产生最短路径的算法，即迪杰斯特拉(Dijkstra)算法。

 1 基本思想
 从图的给定源点到其它各个顶点之间客观上应存在一条最短路径，在这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。
 即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，依此类推，直到求出长度最长的最短路径。

 2 算法思想说明
 设给定源点为Vs，S为已求得最短路径的终点集，开始时令S={Vs} 。当求得第一条最短路径(Vs ，Vi)后，S为{Vs，Vi} 。根据以下结论可求下一条最短路径。
 设下一条最短路径终点为Vj ，则Vj只有：
 ◆  源点到终点有直接的弧<Vs，Vj>；
 ◆ 从Vs 出发到Vj 的这条最短路径所经过的所有中间顶点必定在S中。即只有这条最短路径的最后一条弧才是从S内某个顶点连接到S外的顶点Vj 。
 若定义一个数组dist[n]，其每个dist[i]分量保存从Vs 出发中间只经过集合S中的顶点而到达Vi的所有路径中长度最小的路径长度值，则下一条最短路径的终点Vj必定是不在S中且值最小的顶点，即：
 dist[i]=Min{ dist[k]| Vk∈V-S }
 利用上述公式就可以依次找出下一条最短路径。

 3  算法步骤
 ① 令S={Vs} ，用带权的邻接矩阵表示有向图，对图中每个顶点Vi按以下原则置初值：
 0    i =s
 dist[i] =   Wsi     i≠s且<vs,vi>∈E， wsi为弧上的权值
 ∞   i≠s且<vs,vi>不属于E
 ② 选择一个顶点Vj ，使得：
 dist[j]=Min{ dist[k]| Vk∈V-S }
 Vj就是求得的下一条最短路径终点，将Vj 并入到S中，即S=S∪{Vj} 。
 ③ 对V-S中的每个顶点Vk ，修改dist[k]，方法是：
 若dist[j]+Wjk<dist[k]，则修改为：
 dist[k]=dist[j]+Wjk (Vk∈V-S )
 ④ 重复②，③，直到S=V为止。

 4 算法实现
 用带权的邻接矩阵表示有向图， 对Prim算法略加改动就成了Dijkstra算法，将Prim算法中求每个顶点Vk的lowcost值用dist[k]代替即可。
 ◆  设数组pre[n]保存从Vs到其它顶点的最短路径。若pre[i]=k，表示从Vs 到Vi的最短路径中，Vi的前一个顶点是Vk，即最短路径序列是(Vs , …, Vk  , Vi) 。
 ◆ 设数组final[n]，标识一个顶点是否已加入S中。

 5  算法分析
 Dijkstra算法的主要执行是：
 ◆ 数组变量的初始化：时间复杂度是O(n) ；
 ◆ 求最短路径的二重循环：时间复杂度是O(n2) ；
 因此，整个算法的时间复杂度是O(n2) 。

 */

var dijTest = new AdjacencyMatrixGraph([], [], 0, 0, DN);

dijTest.addVertex('0');
dijTest.addVertex('1');
dijTest.addVertex('2');
dijTest.addVertex('3');
dijTest.addVertex('4');
dijTest.addVertex('5');

dijTest.addArc('0', '1', { adj: 20 });
dijTest.addArc('0', '4', { adj: 10 });
dijTest.addArc('0', '2', { adj: 60 });
dijTest.addArc('0', '5', { adj: 65 });
dijTest.addArc('1', '2', { adj: 30 });
dijTest.addArc('2', '3', { adj: 40 });
dijTest.addArc('5', '2', { adj: 15 });
dijTest.addArc('4', '5', { adj: 20 });
dijTest.addArc('3', '4', { adj: 35 });
dijTest.addArc('1', '3', { adj: 70 });

dijTest.shortestPath_Dijkstra(0);

/*
 每一对顶点间的最短路径

 用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。方法是：每次以一个不同的顶点为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，时间复杂度是O(n3) 。

 弗罗伊德(Floyd)提出了另一个算法，其时间复杂度仍是O(n3) ， 但算法形式更为简明。

 1 算法思想

 设顶点集S(初值为空)，用数组A的每个元素A[i][j]保存从Vi只经过S中的顶点到达Vj的最短路径长度，其思想是：
 ① 初始时令S={ } ， A[i][j]的赋初值方式是：
 0    i =j时
 A[i][j]=    Wij     i≠j且<vi,vj>∈E， wij为弧上的权值
 ∞   i≠j且<vi,vj>不属于E
 ② 将图中一个顶点Vk 加入到S中，修改A[i][j]的值，修改方法是：
 A[i][j]=Min{A[i][j] , (A[i][k]+A[k][j]) }
 原因： 从Vj只经过S中的顶点(Vk)到达Vj的路径长度可能比原来不经过Vk的路径更短。
 ③ 重复②，直到G的所有顶点都加入到S中为止。

 2 算法实现

 ◆  定义二维数组Path[n][n](n为图的顶点数) ，元素Path[i][j]保存从Vi到Vj的最短路径所经过的顶点。
 ◆ 若Path[i][j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径子序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i][k]和Path[k][j]的值再找到该路径上所经过的其它顶点，…依此类推。
 ◆ 初始化为Path[i][j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i][j]变小时，令Path[i][j]=k。


 */

var floyd = new AdjacencyMatrixGraph([], [], 0, 0, DN);
floyd.addVertex('v0');
floyd.addVertex('v1');
floyd.addVertex('v2');
floyd.addArc('v0', 'v2', { adj: 8 });
floyd.addArc('v0', 'v1', { adj: 2 });
floyd.addArc('v1', 'v2', { adj: 4 });
floyd.addArc('v2', 'v0', { adj: 5 });

floyd.shortestPath_FLOYD();

// http://blog.csdn.net/hguisu/article/details/7719428
// 添加《图的应用详解-数据结构》

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = OLGraph;
/*
 十字链表法

 十字链表(Orthogonal List)是有向图的另一种链式存储结构，是将有向图的正邻接表和逆邻接表结合起来得到的一种链表。

 在这种结构中，每条弧的弧头结点和弧尾结点都存放在链表中，并将弧结点分别组织到以弧尾结点为头(顶点)结点和以弧头结点为头(顶点)结点的链表中。

 ◆  data域：存储和顶点相关的信息；
 ◆ 指针域firstin：指向以该顶点为弧头的第一条弧所对应的弧结点；
 ◆ 指针域firstout：指向以该顶点为弧尾的第一条弧所对应的弧结点；
 ◆ 尾域tailvex：指示弧尾顶点在图中的位置；
 ◆ 头域headvex：指示弧头顶点在图中的位置；
 ◆ 指针域hlink：指向弧头相同的下一条弧；
 ◆ 指针域tlink：指向弧尾相同的下一条弧；
 ◆ Info域：指向该弧的相关信息；

 从这种存储结构图可以看出，从一个顶点结点的firstout出发，沿表结点的tlink指针构成了正邻接表的链表结构，而从一个顶点结点的firstin出发，沿表结点的hlink指针构成了逆邻接表的链表结构。

 */

/**
 *
 * @param {Number} headVex 弧的头顶点的位置
 * @param {Number} tailVex 弧的尾顶点位置
 * @param {ArcBox} hLink 弧头相同的弧的链域
 * @param {ArcBox} tLink 弧尾相同的弧的链域
 * @param {*} info
 * @constructor
 */
function ArcBox(tailVex, headVex, hLink, tLink, info) {
    this.headVex = headVex || 0;
    this.tailVex = tailVex || 0;
    this.hLink = hLink || null;
    this.tLink = tLink || null;
    this.info = info || null;
}

/**
 *
 * @param {*} data
 * @param {ArcBox} firstIn 该顶点第一条入弧
 * @param {ArcBox} firstOut 该顶点第一条出弧
 * @constructor
 */
function OLVexNode(data, firstIn, firstOut) {
    this.data = data || null;
    this.firstIn = firstIn || null;
    this.firstOut = firstOut || null;
}

/**
 *
 * @param {Array | OLVexNode} xList 表头向量
 * @param {Number} vexnum 有向图的当前顶点数
 * @param {Number} arcnum 有向图的当前弧数
 * @constructor
 */
function OLGraph(xList, vexnum, arcnum) {
    this.xList = xList || [];
    this.vexnum = vexnum || 0;
    this.arcnum = arcnum || 0;
}
OLGraph.prototype = {
    constructor: OLGraph,

    locateVex: function locateVex(vp) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.xList[i].data === vp) return i;
        }

        return -1;
    },

    // 删除顶点
    deleteVertex: function deleteVertex(v) {
        var m = this.locateVex(v);

        if (m < 0) throw new Error('vertex not found!');

        var n = this.vexnum;
        var q, i, p;
        // 删除所有以v为头的边
        for (i = 0; i < n; ++i) {
            // 如果待删除的边是头链上的第一个结点
            if (this.xList[i].firstIn.tailVex === m) {
                q = this.xList[i].firstIn;
                this.xList[i].firstIn = q.hLink;
                this.arcnum--;
            } else {
                for (p = this.xList[i].firstIn; p && p.hLink.tailVex !== m; p = p.hLink) {}
                if (p) {
                    q = p.hLink;
                    p.hLink = q.hLink;
                    this.arcnum--;
                }
            }
        }

        // 删除所有以v为尾的边
        for (i = 0; i < n; ++i) {
            // 如果待删除的边是尾链上的第一个结点
            if (this.xList[i].firstOut.headVex === m) {
                q = this.xList[i].firstOut;
                this.xList[i].firstOut = q.tLink;
                this.arcnum--;
            } else {
                for (p = this.xList[i].firstOut; p && p.tLink.headVex !== m; p = p.tLink) {}
                if (p) {
                    q = p.tLink;
                    p.tLink = q.tLink;
                    this.arcnum--;
                }
            }
        }

        // 顺次用结点m之后的顶点取代前一个顶点
        for (i = m; i < n; ++i) {
            // 修改表头向量
            this.xList[i] = this.xList[i + 1];
            for (p = this.xList[i].firstIn; p; p = p.hLink) {
                p.headVex--;
            }for (p = this.xList[i].firstOut; p; p = p.tLink) {
                p.tailVex--;
            }
        }

        this.vexnum--;
        return true;
    },

    createDG: function createDG() {
        this.vexnum = prompt('Vexnum: ');
        this.arcnum = prompt('Arcnum: ');
        // IncInfo为0则各弧不含其他信息
        var incInfo = +prompt('IncInfo: ');

        // 输入顶点值
        for (var i = 0; i < this.vexnum; ++i) {
            this.xList[i] = new OLVexNode(prompt('data: '), null, null);
        }

        for (var k = 0; k < this.arcnum; ++k) {
            var v1 = prompt('v1: ');
            var v2 = prompt('v2: ');

            i = this.locateVex(v1);
            var j = this.locateVex(v2);

            if (i === -1 || j === -1) {
                alert('无此顶点，请重新输入!');
                k--;
                continue;
            }

            var p = new ArcBox(i, j, this.xList[j].firstIn, this.xList[i].firstOut, incInfo && prompt('info: '));
            this.xList[j].firstIn = this.xList[i].firstOut = p;
        }
    },

    /**
     * 求有向图的强连通分量
     */
    getSGraph: function getSGraph() {
        var visited = [];
        var finished = [];
        var count = 0;

        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        } // 第一次深度优先遍历建立finished数组
        for (i = 0; i < this.vexnum; ++i) {
            if (!visited[i]) dfs1(this, i);
        }
        // 清空visited数组
        for (i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        } // 第二次逆向的深度优先遍历
        for (var len = this.vexnum - 1; len >= 0; --len) {
            i = finished[i];
            if (!visited[i]) dfs2(this, i);
        }

        function dfs1(graph, v) {
            visited[v] = true;
            for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
                var w = p.headVex;
                if (!visited[w]) dfs1(graph, w);
            }
            finished[++count] = v;
        }

        function dfs2(graph, v) {
            visited[v] = true;
            console.log('%d', v);
            for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
                var w = p.tailVex;
                if (!visited[w]) dfs2(graph, w);
            }
        }
    }
};

//var g = new OLGraph();
//g.createDG();
//console.log(g);


/*
 有向图的强连通分量

 对于有向图，在其每一个强连通分量中，任何两个顶点都是可达的。 V∈G，与V可相互到达的所有顶点就是包含V的强连通分量的所有顶点。

 设从V可到达 (以V为起点的所有有向路径的终点)的顶点集合为T1(G)，而到达V (以V为终点的所有有向路径的起点)的顶点集合为T2(G)，则包含V的强连通分量的顶点集合是： T1(G)∩T2(G) 。

 求有向图G的强连通分量的基本步骤是：
 ⑴ 对G进行深度优先遍历，生成G的深度优先生成森林T。
 ⑵  对森林T的顶点按中序遍历顺序进行编号。
 ⑶  改变G中每一条弧的方向，构成一个新的有向图G’。
 ⑷  按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。
 ⑸  重复步骤⑷ ，直到G’中的所有顶点都被访问。

 在算法实现时，建立一个数组in_order[n]存放深度优先生成森林的中序遍历序列。对每个顶点v，在调用DFS函数结束时，将顶点依次存放在数组in_order[n]中。图采用十字链表作为存储结构最合适。

 */

// todo to be tested
OLGraph.prototype.connected_DG = function () {
    var visited = [];
    var in_order = [];
    var count = 0;

    for (var i = 0; i < this.vexnum; ++i) {
        visited[i] = false;
    } // 对图正向遍历
    for (i = 0; i < this.vexnum; ++i) {
        if (!visited[i]) {
            dfs(this, i, in_order);
        }
    }

    for (i = 0; i < this.vexnum; ++i) {
        visited[i] = false;
    } // 对图逆向遍历
    var k = 1;
    for (var j = this.vexnum - 1; j >= 0; --j) {
        var v = in_order[j];
        if (!visited[v]) {
            console.log('第' + k++ + '个连通分量顶点');
            rev_dfs(this, v);
        }
    }

    function dfs(graph, v) {
        visited[v] = true;

        for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
            if (!visited[p.headVex]) {
                dfs(graph, p.headVex);
            }
        }

        in_order[count++] = v;
    }

    function rev_dfs(graph, v) {
        visited[v] = true;
        console.log('顶点：' + v);

        for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
            if (!visited[p.tailVex]) {
                rev_dfs(graph, p.tailVex);
            }
        }
    }
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _DoubleLinkedList = __webpack_require__(72);

var _DoubleLinkedList2 = _interopRequireDefault(_DoubleLinkedList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LIMIT = 20; /**
                 * LRU( Least recently used )
                 */

var LRUCache = function () {
    function LRUCache(sqList) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LIMIT;
        (0, _classCallCheck3.default)(this, LRUCache);

        this.limit = limit;
        sqList = sqList && sqList.length ? sqList && sqList.slice(0, this.limit) : [];
        this.__cache = new _DoubleLinkedList2.default(sqList, function (a, b) {
            return a.key === b.key;
        });
    }

    LRUCache.prototype[Symbol.iterator] = function () {
        return this.__cache[Symbol.iterator]();
    };

    LRUCache.prototype.remove = function remove(key) {
        return this.__cache.remove({ key: key });
    };

    LRUCache.prototype.clear = function clear() {
        return this.___cache.clear();
    };

    LRUCache.prototype.get = function get(key) {
        var index = this.__cache.indexOf({ key: key });

        if (index >= 0) {
            var data = this.__cache.findByIndex(index);
            this.__cache.remove(data);
            this.__cache.unshift(data);

            return data;
        }

        return false;
    };

    LRUCache.prototype.add = function add(key, value) {
        var data = this.get(key);
        if (data) {
            data.value = value;
        } else {
            if (this.size === this.limit) {
                this.__cache.pop();
            }

            this.__cache.unshift({
                key: key,
                value: value
            });
        }
    };

    LRUCache.prototype.toString = function toString() {
        var arr = [];
        this.__cache.forEach(function (data) {
            arr.push(data.key + ':' + data.value);
        });

        return arr.join(' > ');
    };

    LRUCache.prototype.toJSON = function toJSON() {
        return this.__cache.toJSON();
    };

    (0, _createClass3.default)(LRUCache, [{
        key: 'size',
        get: function get() {
            return this.__cache.size;
        }
    }]);
    return LRUCache;
}();

exports.default = LRUCache;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.union = union;
exports.mergeList = mergeList;
exports.insert = insert;
exports.del = del;
exports.listComp = listComp;
exports.reverse = reverse;
exports.intersect = intersect;
exports.intersect_true = intersect_true;
exports.intersect_delete = intersect_delete;
/**
 * 线性表
 */

// 线性表的类型定义
// 将所有在数组b中但不在数组a的数据元素插入到a中

var a = [1, 2, 3, 4, 5];
var b = [1, 3, 5, 7, 9];

function union(a, b) {
    var elem, equal;

    for (var i = 0, bLen = b.length; i < bLen; i++) {
        elem = b[i];
        equal = false;

        for (var j = 0, aLen = a.length; j < aLen; j++) {
            if (elem === a[j]) {
                equal = true;
                break;
            }
        }

        if (!equal) a.push(elem);
    }
}

union(a, b);
console.log(a);
// [1, 2, 3, 4, 5, 7, 9]

// 时间复杂度：O(aLen * bLen)

// 已知数组a和数组b中的数据元素按值非递减排列
// 归并a和b得到新的数组c，c的数据元素也按值非递减排列
var a = [3, 5, 8, 11];
var b = [2, 6, 8, 9, 11, 15, 20];

function mergeList(a, b) {
    var c = [],
        aElem,
        bElem;
    var i = 0,
        j = 0,
        k = 0;
    var aLen = a.length;
    var bLen = b.length;

    while (i < aLen && j < bLen) {
        aElem = a[i];
        bElem = b[j];

        if (aElem < bElem) {
            c[k++] = aElem;
            i++;
        } else {
            c[k++] = bElem;
            j++;
        }
    }

    while (i < aLen) {
        c[k++] = a[i++];
    }

    while (j < bLen) {
        c[k++] = b[j++];
    }

    return c;
}

var c = mergeList(a, b);
console.log(c);
// [2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20]

// 时间复杂度： O(aLen + bLen)

// 线性表的顺序表示和实现
// 使用伪数组模拟线性表插入操作的前后数据元素在存储空间中的位置变化
var a = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 };
a.length = 6;

function insert(a, i, elem) {
    if (!elem) return;

    var len = a.length;
    if (i >= len) {
        while (len < i) {
            a[len++] = undefined;
            a.length++;
        }
        a[i] = elem;
    } else {
        while (len > i) {
            a[len--] = a[len];
        }
        a[i] = elem;
    }
    a.length++;
}

insert(a, 3, 8);
insert(a, 10, 10);
console.log(a);

// 使用伪数组模拟线性表删除操作的前后数据元素在存储空间中的位置变化

function del(a, i) {
    var temp = a[i];
    var j = i + 1;
    var len = a.length;

    while (j < len) {
        a[j - 1] = a[j++];
    }
    a.length--;
    delete a[len - 1];

    return temp;
}

del(a, 3);
console.log(a);
del(a, 10);
console.log(a);

// 时间复杂度： O(a.length)

// 比较字符表A和B，并用返回值表示结果，值为1，表示A>B，值为-1，表示A<B，值为0，表示A=B
function listComp(aList, bList) {
    for (var i = 0; i < aList.length && i < bList.length; i++) {
        if (aList[i] !== bList[i]) return aList[i] > bList[i] ? 1 : -1;
    }

    if (aList.length == bList.length) return 0;

    return aList.length > bList.length ? 1 : -1;
}

function reverse(list) {
    for (var i = 0, j = list.length - 1; i <= j; i++, j--) {
        var temp = list[i];
        list[i] = list[j];
        list[j] = temp;
    }
}

// 求元素递增排列的线性表A和B的元素的交集并存入C
function intersect(aList, bList) {
    var cList = [];
    var i = 0,
        j = 0,
        k = 0;

    while (aList[i] && bList[j]) {
        if (aList[i] < bList[j]) i++;else if (aList[i] > bList[j]) j++;else {
            cList[k++] = aList[i];
            i++;
            j++;
        }
    }

    return cList;
}

console.log(intersect([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

// 求元素递增排列的线性表A和B的元素的交集并存入回a
function intersect_true(a, b) {
    var i = 0,
        j = 0,
        k = 0;

    while (a[i] && b[j]) {
        if (a[i] < b[j]) i++;else if (a[i] > b[j]) j++;else {
            a[k++] = a[i];
            i++;
            j++;
        }
    }

    while (a[k]) {
        a.splice(k, 1);
    }return a;
}

console.log(intersect_true([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

// a，b，c的元素均是非递减排列
// 求a数组中非b数组和c数组的交集的元素。
function intersect_delete(a, b, c) {
    var i = 0,
        j = 0,
        k = 0,
        m = 0;

    while (i < a.length && j < b.length && k < c.length) {
        if (b[j] < c[k]) j++;else if (b[j] > c[k]) k++;else {
            // 找到了相同元素same
            var same = b[j];

            // j，k后移到新的元素
            while (b[j] === same) {
                j++;
            }while (c[k] === same) {
                k++;
            } // 需保留的元素移动到新位置
            while (i < a.length && a[i] < same) {
                a[m++] = a[i++];
            } // 跳过相同的元素
            while (i < a.length && a[i] === same) {
                i++;
            }
        }
    }

    // a的剩余元素重新存储
    while (i < a.length) {
        a[m++] = a[i++];
    }a.length = m;

    return a;
}

console.log(intersect_delete([1, 2, 3, 4, 5, 6, 9], [1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Created by ldp on 2015/1/19.
 */

/**
 * 循环队列
 * 
 * 用处：约瑟夫环
 * 优点：为充分利用向量空间，克服"假溢出"现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。
 * 
 * @export
 * @class CycleQueue
 */
var CycleQueue = function () {
    function CycleQueue() {
        var maxsize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
        (0, _classCallCheck3.default)(this, CycleQueue);

        this.base = {};
        this.front = this.rear = 0;
        this.MAXQSIZE = maxsize;
    }

    CycleQueue.prototype.enQueue = function enQueue(data) {
        if ((this.rear + 1) % this.MAXQSIZE === 0) throw new Error('cycleQueue is already full!');

        this.base[this.rear] = data;
        this.rear = (this.rear + 1) % this.MAXQSIZE;
    };

    CycleQueue.prototype.deQueue = function deQueue() {
        if (this.front === this.rear) throw new Error('cycleQueue is already empty');

        var elem = this.base[this.front];
        this.front = (this.front + 1) % this.MAXQSIZE;

        return elem;
    };

    CycleQueue.prototype.clear = function clear() {
        this.base = {};
        this.front = this.rear = 0;
    };

    CycleQueue.prototype.peekAt = function peekAt() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        index = (index + this.MAXQSIZE) % this.MAXQSIZE;

        return this.base[index + this.front] || null;
    };

    CycleQueue.prototype.getHead = function getHead() {
        var elem = this.base[this.front];
        return elem ? elem : null;
    };

    CycleQueue.prototype.queueTraverse = function queueTraverse(iterator) {
        for (var i = this.front, len = this.rear = this.front; i < len; i++) {
            if (iterator(this.base[i], i)) break;
        }
    };

    CycleQueue.prototype.toString = function toString() {
        var base = [].slice.call(this.base);

        return base.slice(this.front, this.rear - this.front);
    };

    (0, _createClass3.default)(CycleQueue, [{
        key: 'size',
        get: function get() {
            return (this.rear - this.front + this.MAXQSIZE) % this.MAXQSIZE;
        }
    }]);
    return CycleQueue;
}();

exports.default = CycleQueue;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _Heap = __webpack_require__(71);

var _Heap2 = _interopRequireDefault(_Heap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 用堆实现优先队列
 * 
 * @export
 * @class PriorityQueue
 */
var PriorityQueue = function () {
    function PriorityQueue() {
        (0, _classCallCheck3.default)(this, PriorityQueue);

        this.heap = new _Heap2.default(function (a, b) {
            return a.priority - b.priority;
        });
    }

    PriorityQueue.prototype.enQueue = function enQueue(value) {
        var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (typeof value === 'undefined') throw new Error('argument required');

        // 将当前节点追加到堆尾
        this.heap.add({
            value: value,
            priority: priority
        });
    };

    PriorityQueue.prototype.deQueue = function deQueue() {
        return this.heap.remove();
    };

    PriorityQueue.prototype.clear = function clear() {
        this.heap.clear();
    };

    (0, _createClass3.default)(PriorityQueue, [{
        key: 'size',
        get: function get() {
            return this.heap.arr.length;
        }
    }]);
    return PriorityQueue;
}(); /**
      * Created by Luke on 2015/2/26.
      */

/*
优先队列(priority queue)

普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。

优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.


入队操作
①：完全二叉树的构建操作是“从上到下，从左到右”的形式，所以入队的节点是放在数组的最后，也就是树中叶子层的有序最右边空位。
②：当节点插入到最后时，有可能破坏了堆的性质，此时我们要进行“上滤操作”，当然时间复杂度为O(lgN)。

出队操作
出队操作时，我们采取的方案是：弹出堆顶元素，然后将叶子层中的最右子节点赋给堆顶，同样这时也会可能存在破坏堆的性质，最后我们要被迫进行下滤操作。
 */

exports.default = PriorityQueue;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * AVL TREE Class
 *
 * @author Brice Chevalier
 *
 *
 * @desc
 *
 *    Method                Time Complexity
 *    ___________________________________
 *
 *    add                    O(log2(n))
 *    remove                O(log2(n))
 *    getFirst            O(1)
 *    getLast                O(1)
 *    getCount            O(1)
 *    apply                O(n)
 *    clear                O(n)
 *
 *    Memory Complexity in O(n)
 */

function Node(obj) {
    this.object = obj;
    this.height = 1;
    this.left = null;
    this.right = null;
    this.previous = null;
    this.next = null;
    this.parent = null;
}

function AvlTree() {
    this.count = 0;
    this.root = null;
    this.first = null;
    this.last = null;
}
AvlTree.cmp = function (a, b) {
    if (a > b) return 1;else if (a < b) return -1;else return 0;
};

AvlTree.prototype._addLeft = function (node, parent) {
    node.previous = parent.previous;
    node.next = parent;
    node.parent = parent;

    parent.left = node;
    parent.previous = node;

    if (node.previous) {
        node.previous.next = node;
    }

    if (parent === this.first) {
        this.first = node;
    }
};

AvlTree.prototype._addRight = function (node, parent) {
    node.previous = parent;
    node.next = parent.next;
    node.parent = parent;

    parent.right = node;
    parent.next = node;

    if (node.next) {
        node.next.previous = node;
    }

    if (parent === this.last) {
        this.last = node;
    }
};

AvlTree.prototype.add = function (obj) {
    this.count += 1;
    var newNode = new Node(obj);

    if (this.root === null) {
        this.root = newNode;
        this.first = this.root;
        this.last = this.root;
        return newNode;
    }

    var current = this.root;

    while (true) {

        var cmp = AvlTree.cmp(obj, current.object);
        if (cmp < 0) {
            // Adding to the left
            if (current.left === null) {
                this._addLeft(newNode, current);
                break;
            } else {
                current = current.left;
            }
        } else if (cmp > 0) {
            // Adding to the right
            if (current.right === null) {
                this._addRight(newNode, current);
                break;
            } else {
                current = current.right;
            }
        } else {
            if (current.left === null) {
                this._addLeft(newNode, current);
                break;
            } else if (current.right === null) {
                this._addRight(newNode, current);
                break;
            } else {
                if (current.right.height < current.left.height) {
                    current = current.right;
                } else {
                    current = current.left;
                }
            }
        }
    }

    this._balance(newNode.parent);

    return newNode;
};

AvlTree.prototype._balanceLeftRight = function (node) {
    var left = node.left;
    var a = left.left;
    var b = left.right.left;

    left.right.left = left;
    node.left = left.right;
    left = node.left;
    left.parent = node;

    var leftLeft = left.left;
    leftLeft.parent = left;
    leftLeft.left = a;
    leftLeft.right = b;
    if (a !== null) {
        a.parent = leftLeft;
    }
    if (b !== null) {
        b.parent = leftLeft;
    }

    left.height = leftLeft.height + 1;
};

AvlTree.prototype._balanceLeftLeft = function (node) {
    var left = node.left;
    var c = left.right;

    if (node === this.root) {
        this.root = left;
    } else {
        if (node.parent.right === node) {
            node.parent.right = left;
        } else {
            node.parent.left = left;
        }
    }

    left.right = node;
    left.parent = node.parent;
    node.parent = left;
    node.left = c;
    if (c !== null) {
        c.parent = node;
    }

    node.height = node.height - 1;
};

AvlTree.prototype._balanceRightLeft = function (node) {
    var right = node.right;
    var a = right.right;
    var b = right.left.right;

    right.left.right = right;
    node.right = right.left;
    right = node.right;
    right.parent = node;

    var rightRight = right.right;
    rightRight.parent = right;
    rightRight.right = a;
    rightRight.left = b;
    if (a !== null) {
        a.parent = rightRight;
    }
    if (b !== null) {
        b.parent = rightRight;
    }

    node.right.height = rightRight.height + 1;
};

AvlTree.prototype._balanceRightRight = function (node) {
    var right = node.right;
    var c = right.left;

    if (node === this.root) {
        this.root = right;
    } else {
        if (node.parent.left === node) {
            node.parent.left = right;
        } else {
            node.parent.right = right;
        }
    }

    right.left = node;
    right.parent = node.parent;
    node.parent = right;
    node.right = c;
    if (c !== null) {
        c.parent = node;
    }

    node.height = node.height - 1;
};

AvlTree.prototype._balance = function (node) {
    // Balancing the tree
    var current = node;
    while (current !== null) {
        var leftHeight = current.left === null ? 0 : current.left.height;
        var rightHeight = current.right === null ? 0 : current.right.height;
        var newHeight = 1 + Math.max(leftHeight, rightHeight);

        if (newHeight > current.height) {
            current.height = newHeight;
            if (leftHeight - rightHeight > 1) {

                // Left case
                if (current.left.right !== null && (current.left.left === null || current.left.left.height < current.left.right.height)) {
                    // Left Right Case
                    this._balanceLeftRight(current);
                }

                // Left Left Case
                this._balanceLeftLeft(current);

                // The tree has been balanced
                break;
            } else if (rightHeight - leftHeight > 1) {

                // Right case
                if (current.right.left !== null && (current.right.right === null || current.right.right.height < current.right.left.height)) {
                    // Right Left Case
                    this._balanceRightLeft(current);
                }

                // Right Right Case
                this._balanceRightRight(current);

                // The tree has been balanced
                break;
            } else {
                // Node is balanced
                current = current.parent;
            }
        } else {
            break;
        }
    }
};

AvlTree.prototype.remove = function (obj) {
    this._remove(obj, this.root);
};

AvlTree.prototype._remove = function (obj, node) {
    var current = node;

    while (current !== null) {
        var cmp = AvlTree.cmp(obj, current.object);
        if (cmp < 0) {
            current = current.left;
        } else if (cmp > 0) {
            current = current.right;
        } else {
            if (obj === current.object) {

                // Node removal
                this.count -= 1;

                if (current.previous === null) {
                    this.first = current.next;
                } else {
                    current.previous.next = current.next;
                }
                if (current.next === null) {
                    this.last = current.previous;
                } else {
                    current.next.previous = current.previous;
                }

                // Replacing the node by the smallest element greater than it
                var parent = current.parent;
                var left = current.left;
                var right = current.right;

                if (current.right === null) {
                    if (parent === null) {
                        this.root = left;
                    } else {
                        if (parent.right === current) {
                            parent.right = left;
                        } else {
                            parent.left = left;
                        }
                    }

                    if (left !== null) {
                        left.parent = parent;
                    }

                    this._balance(parent);
                    return 1;
                }

                var replacement = current.right;
                var balanceFrom;

                if (replacement.left === null) {
                    balanceFrom = replacement;

                    if (left !== null) {
                        left.parent = replacement;
                    }
                    replacement.left = left;

                    if (parent === null) {
                        this.root = replacement;
                    } else {
                        if (parent.right === current) {
                            parent.right = replacement;
                        } else {
                            parent.left = replacement;
                        }
                    }
                    replacement.parent = parent;

                    this._balance(balanceFrom);

                    return 1;
                }

                replacement = replacement.left;
                while (replacement.left !== null) {
                    replacement = replacement.left;
                }

                if (replacement.right !== null) {
                    replacement.right.parent = replacement.parent;
                }
                replacement.parent.left = replacement.right;

                if (right !== null) {
                    right.parent = replacement;
                }
                replacement.right = right;

                balanceFrom = replacement.parent;

                if (left !== null) {
                    left.parent = replacement;
                }
                replacement.left = left;

                if (parent === null) {
                    this.root = replacement;
                } else {
                    if (parent.right === current) {
                        parent.right = replacement;
                    } else {
                        parent.left = replacement;
                    }
                }
                replacement.parent = parent;

                this._balance(balanceFrom);

                return 1;
            } else {
                if (!this._remove(obj, current.left)) {
                    this._remove(obj, current.right);
                }
            }
        }
    }

    return 0;
};

AvlTree.prototype.removeByRef = function (node) {
    // Node removal
    this.count -= 1;

    if (node.previous === null) {
        this.first = node.next;
    } else {
        node.previous.next = node.next;
    }
    if (node.next === null) {
        this.last = node.previous;
    } else {
        node.next.previous = node.previous;
    }

    // Replacing the node by the smallest element greater than it
    var parent = node.parent;
    var left = node.left;
    var right = node.right;

    if (node.right === null) {
        if (parent === null) {
            this.root = left;
        } else {
            if (parent.right === node) {
                parent.right = left;
            } else {
                parent.left = left;
            }
        }

        if (left !== null) {
            left.parent = parent;
        }

        this._balance(parent);
        return 1;
    }

    var replacement = node.right;
    var balanceFrom;

    if (replacement.left === null) {
        balanceFrom = replacement;

        if (left !== null) {
            left.parent = replacement;
        }
        replacement.left = left;

        if (parent === null) {
            this.root = replacement;
        } else {
            if (parent.right === node) {
                parent.right = replacement;
            } else {
                parent.left = replacement;
            }
        }
        replacement.parent = parent;

        this._balance(balanceFrom);

        return 1;
    }

    replacement = replacement.left;
    while (replacement.left !== null) {
        replacement = replacement.left;
    }

    if (replacement.right !== null) {
        replacement.right.parent = replacement.parent;
    }
    replacement.parent.left = replacement.right;

    if (right !== null) {
        right.parent = replacement;
    }
    replacement.right = right;

    balanceFrom = replacement.parent;

    if (left !== null) {
        left.parent = replacement;
    }
    replacement.left = left;

    if (parent === null) {
        this.root = replacement;
    } else {
        if (parent.right === node) {
            parent.right = replacement;
        } else {
            parent.left = replacement;
        }
    }
    replacement.parent = parent;

    this._balance(balanceFrom);

    return 1;
};

AvlTree.prototype.getFirst = function () {
    return this.first;
};

AvlTree.prototype.getLast = function () {
    return this.last;
};

AvlTree.prototype.getHeight = function () {
    return this.root.height;
};

AvlTree.prototype.getRoot = function () {
    return this.root;
};

AvlTree.prototype.getCount = function () {
    return this.count;
};

AvlTree.prototype.forEach = function (processingFunc, params) {
    for (var current = this.first; current; current = current.next) {
        processingFunc(current.object, params);
    }
};

AvlTree.prototype.forEachReverse = function (processingFunc, params) {
    for (var current = this.last; current; current = current.previous) {
        processingFunc(current.object, params);
    }
};

AvlTree.prototype.clear = function () {
    this.count = 0;
    this.root = null;
    this.first = null;
    this.last = null;
};

module.exports = AvlTree;

console.log('\nAVL tree insert2: ');
var test = new AvlTree();
test.add(3);
test.add(14);
test.add(25);
test.add(81);
test.add(44);

/*
 14
 /    \
 3       44
 /   \
 25     81
 */

console.log('remove_Recursive 2:');

test.remove(81);
test.remove(3);
test.remove(14);
test.remove(25);
test.remove(44);

var str = 'cknobfjtlpqaegrmdhs';
//var str = 'ckbfjlaegmdh';


test = new AvlTree();
for (var i = 0; i < str.length; ++i) {
    test.add(str[i]);
}

test.remove('e');
test.remove('h');
test.remove('b');
test.remove('l');
test.remove('f');
test.remove('j');
test.remove('g');
test.remove('d');
test.remove('k');
test.remove('a');
test.remove('m');
test.remove('n');
test.remove('o');
test.remove('p');
test.remove('q');
test.remove('r');
test.remove('s');
test.remove('t');
test.remove('c');

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*
 MIT License
 Copyright (c) 2012 Santanu Basu
 Copyright (c) 2013 Daniel Wirtz
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:
 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Based on Santanu Basu's BPlusJS
// https://github.com/santanubasu/BPlusJS
// Modified for stand-alone use

/**
 * @license BTree.js
 * Released under the MIT License
 * see: https://github.com/dcodeIO/BTree.js for details
 */
(function (global) {

    function isDefined(v) {
        return typeof v != 'undefined';
    }

    var Node = function Node(options) {
        options = options || {};
        this.order = options.order || 100;
        this.mergeThreshold = options.mergeThreshold || 40;
        this.data = [];
    };

    Node.prototype.getLeftPeer = function () {
        return this.leftPeer;
    };

    Node.prototype.setLeftPeer = function (leftPeer) {
        this.leftPeer = leftPeer;
    };

    Node.prototype.getRightPeer = function () {
        return this.rightPeer;
    };

    Node.prototype.setRightPeer = function (rightPeer) {
        this.rightPeer = rightPeer;
    };

    Node.prototype.getData = function () {
        return this.data;
    };

    Node.prototype.getSurplus = function () {
        return Math.max(0, Math.floor((this.data.length - this.mergeThreshold) / 2));
    };

    Node.prototype.getRightSurplusData = function () {
        var surplus = this.getSurplus();
        return this.data.splice(this.data.length - surplus);
    };

    Node.prototype.getLeftSurplusData = function () {
        var surplus = this.getSurplus();
        return this.data.splice(0, surplus);
    };

    var InternalNode = function InternalNode(options) {
        Node.call(this, options);
        this.data = options.data;
        this.leftPeer = options.leftPeer;
        this.rightPeer = options.rightPeer;
    };

    InternalNode.prototype = Object.create(Node.prototype);

    InternalNode.prototype.findIndex = function (key) {
        var data = this.data;
        var left = 0;
        var right = data.length - 1;
        var mid = left + Math.floor((right - left) / 2);
        var found = false;
        do {
            mid = left + Math.floor((right - left) / 2);
            if (data[mid].key < key) {
                left = mid + 1;
            } else if (data[mid].key > key) {
                right = mid;
            } else {
                found = true;
            }
        } while (left < right && !found);
        if (found) {
            return mid;
        } else {
            return right;
        }
    };

    InternalNode.prototype.findChild = function (key) {
        var index = this.findIndex(key);
        var element = this.data[index];
        var child;
        if (element.key <= key) {
            child = element.right;
        } else {
            child = element.left;
        }
        return child;
    };

    InternalNode.prototype.insert = function (key, value, clobber) {
        var index = this.findIndex(key);
        var element = this.data[index];
        var child;
        var newNodes, leftElement, rightElement;
        if (element.key <= key) {
            child = element.right;
            newNodes = child.insert(key, value, clobber);
            if (newNodes.length == 3) {
                leftElement = {
                    key: element.key,
                    left: element.left,
                    right: newNodes[0]
                };
                rightElement = {
                    key: newNodes[1],
                    left: newNodes[0],
                    right: newNodes[2]
                };
                this.data.splice(index, 1, leftElement, rightElement);
                return this.split();
            }
        } else {
            child = element.left;
            newNodes = child.insert(key, value, clobber);
            if (newNodes.length == 3) {
                leftElement = {
                    key: newNodes[1],
                    left: newNodes[0],
                    right: newNodes[2]
                };
                rightElement = {
                    key: element.key,
                    left: newNodes[2],
                    right: element.right
                };
                this.data.splice(index, 1, leftElement, rightElement);
                return this.split();
            }
        }
        return newNodes;
    };

    InternalNode.prototype.split = function () {
        if (this.data.length < this.order) {
            return [];
        }
        var splitIndex = Math.floor(this.data.length / 2);
        var leftNode = new InternalNode({
            data: this.data.slice(0, splitIndex),
            leftPeer: this.leftPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        var rightNode = new InternalNode({
            data: this.data.slice(splitIndex + 1, this.data.length),
            rightPeer: this.rightPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        leftNode.setRightPeer(rightNode);
        rightNode.setLeftPeer(leftNode);
        if (isDefined(this.leftPeer)) {
            this.leftPeer.setRightPeer(leftNode);
        }
        if (isDefined(this.rightPeer)) {
            this.rightPeer.setLeftPeer(rightNode);
        }
        return [leftNode, this.data[splitIndex].key, rightNode];
    };

    InternalNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
        var index = this.findIndex(key);
        var element = this.data[index];
        var mergeIndex = -1;
        var child;
        var retval;
        if (element.key <= key) {
            child = element.right;
            retval = child.remove(key, element.left, index < this.data.length - 1 ? child.getRightPeer() : undefined);
            if (this.data.length == 1 && retval.length == 4) {
                return [retval[0], retval[3]];
            }
            if (retval.length > 1) {
                if (retval[1] == 1) {
                    mergeIndex = index + 1;
                } else {
                    mergeIndex = index;
                }
            }
        } else {
            child = element.left;
            retval = child.remove(key, index > 0 ? child.getLeftPeer() : undefined, element.right);
            if (this.data.length == 1 && retval.length == 4) {
                return [retval[0], retval[3]];
            }
            if (retval.length > 1) {
                if (retval[1] == 1) {
                    mergeIndex = index;
                } else {
                    mergeIndex = index - 1;
                }
            }
        }
        if (mergeIndex >= 0) {
            var mergeElement = this.data[mergeIndex];
            if (retval.length == 5) {
                mergeElement.key = retval[3];
                return [retval[0]];
            } else {
                if (mergeIndex > 0) {
                    this.data[mergeIndex - 1].right = retval[3];
                }
                if (mergeIndex < this.data.length - 1) {
                    this.data[mergeIndex + 1].left = retval[3];
                }
                this.data.splice(mergeIndex, 1);
                return [retval[0]].concat(this.merge(leftMergeOption, rightMergeOption));
            }
        } else {
            return [retval[0]];
        }
    };

    InternalNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
        if (this.data.length > this.mergeThreshold) {
            return [];
        }
        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
            return [];
        }
        var retval = [];
        // var deficit = true;
        var leftSurplus = 0;
        var leftData;
        var rightSurplus = 0;
        var rightData;
        var leftPeer = this.leftPeer;
        var rightPeer = this.rightPeer;
        if (isDefined(leftMergeOption)) {
            leftData = leftMergeOption.getData();
            leftSurplus = leftMergeOption.getSurplus();
        }
        if (isDefined(rightMergeOption)) {
            rightData = rightMergeOption.getData();
            rightSurplus = rightMergeOption.getSurplus();
        }
        if (leftSurplus > rightSurplus) {
            var leftSurplusData = leftMergeOption.getRightSurplusData();
            this.data = leftSurplusData.slice(1).concat([{
                key: this.data[0].left.getData()[0].key,
                left: leftSurplusData[leftSurplusData.length - 1].right,
                right: this.data[0].left
            }], this.data);
            retval[0] = -1;
            retval[1] = leftMergeOption;
            retval[2] = leftSurplusData[0].key;
            retval[3] = this;
        } else if (rightSurplus > leftSurplus) {
            var rightSurplusData = rightMergeOption.getLeftSurplusData();
            this.data = this.data.concat([{
                key: rightSurplusData[0].left.getData()[0].key,
                left: this.data[this.data.length - 1].right,
                right: rightSurplusData[0].left
            }], rightSurplusData.slice(0, rightSurplusData.length - 1));
            retval[0] = 1;
            retval[1] = this;
            retval[2] = rightSurplusData[rightSurplusData.length - 1].key;
            retval[3] = rightMergeOption;
        } else {
            var mergedInternalNode;
            if (!isDefined(leftData)) {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat([{
                        key: rightData[0].left.getData()[0].key,
                        left: this.data[this.data.length - 1].right,
                        right: rightData[0].left
                    }], rightData)
                });
                retval[0] = 1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer);
                }
            } else if (!isDefined(rightData)) {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat([{
                        key: this.data[0].left.getData()[0].key,
                        left: leftData[leftData.length - 1].right,
                        right: this.data[0].left
                    }], this.data)
                });
                retval[0] = -1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer);
                }
            } else if (rightData.length < leftData.length) {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat([{
                        key: rightData[0].left.getData()[0].key,
                        left: this.data[this.data.length - 1].right,
                        right: rightData[0].left
                    }], rightData)
                });
                retval[0] = 1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer);
                }
            } else {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat([{
                        key: this.data[0].left.getData()[0].key,
                        left: leftData[leftData.length - 1].right,
                        right: this.data[0].left
                    }], this.data)
                });
                retval[0] = -1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer);
                }
            }
        }
        return retval;
    };

    InternalNode.prototype.find = function (key) {
        return this.findChild(key).find(key);
    };

    InternalNode.prototype.range = function (start, end) {
        return this.findChild(start).range(start, end);
    };

    InternalNode.prototype.toString = function (indent) {
        return this.data.map(function (element) {
            return [indent + "[key=" + element.key, "\n" + indent + "    LEFT\n" + element.left.toString(indent + "    "), "\n" + indent + "    RIGHT\n" + element.right.toString(indent + "    ") + "\n" + indent + "]"];
        }).join(",\n");
    };

    var LeafNode = function LeafNode(options) {
        Node.call(this, options);
        this.data = options.data;
        this.leftPeer = options.leftPeer;
        this.rightPeer = options.rightPeer;
    };

    LeafNode.prototype = Object.create(Node.prototype);

    LeafNode.prototype.findIndex = function (key) {
        var data = this.data;
        if (data.length == 0) {
            return 0;
        }
        var left = 0;
        var right = data.length;
        var mid = left + Math.floor((right - left) / 2);
        var found = false;
        do {
            mid = left + Math.floor((right - left) / 2);
            if (data[mid].key < key) {
                left = mid + 1;
            } else if (data[mid].key > key) {
                right = mid;
            } else {
                found = true;
            }
        } while (left !== right && !found);
        if (found) {
            return mid;
        } else {
            return left;
        }
    };

    LeafNode.prototype.insert = function (key, value, clobber) {
        var index = this.findIndex(key);
        var element = this.data[index];
        if (index == this.data.length) {
            this.data.push({
                key: key,
                value: value
            });
        } else if (element.key === key) {
            if (clobber) {
                element.value = value;
            } else {
                return [element.value];
            }
            // This condition may never occur, given the way findIndex is written
        } else if (element.key < key) {
            this.data.splice(index + 1, 0, {
                key: key,
                value: value
            });
        } else {
            this.data.splice(index, 0, {
                key: key,
                value: value
            });
        }
        return this.split();
    };

    LeafNode.prototype.split = function () {
        if (this.data.length < this.order) {
            return [];
        }
        var splitIndex = Math.floor(this.data.length / 2);
        var leftNode = new LeafNode({
            data: this.data.slice(0, splitIndex),
            leftPeer: this.leftPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        var rightNode = new LeafNode({
            data: this.data.slice(splitIndex, this.data.length),
            rightPeer: this.rightPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        leftNode.setRightPeer(rightNode);
        rightNode.setLeftPeer(leftNode);
        if (isDefined(this.leftPeer)) {
            this.leftPeer.setRightPeer(leftNode);
        }
        if (isDefined(this.rightPeer)) {
            this.rightPeer.setLeftPeer(rightNode);
        }
        return [leftNode, this.data[splitIndex].key, rightNode];
    };

    LeafNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
        var index = this.findIndex(key);
        var element = this.data[index];
        if (index < this.data.length && element.key === key) {
            this.data.splice(index, 1);
            return [element.value].concat(this.merge(leftMergeOption, rightMergeOption));
        } else {
            return [undefined];
        }
    };

    LeafNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
        if (this.data.length > this.mergeThreshold) {
            return [];
        }
        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
            return [];
        }
        var retval = [];
        // var deficit = true;
        var leftSurplus = 0;
        var leftData;
        var rightSurplus = 0;
        var rightData;
        var leftPeer = this.leftPeer;
        var rightPeer = this.rightPeer;
        if (isDefined(leftMergeOption)) {
            leftData = leftMergeOption.getData();
            leftSurplus = leftMergeOption.getSurplus();
        }
        if (isDefined(rightMergeOption)) {
            rightData = rightMergeOption.getData();
            rightSurplus = rightMergeOption.getSurplus();
        }
        if (leftSurplus > rightSurplus) {
            var leftSurplusData = leftMergeOption.getRightSurplusData();
            this.data = leftSurplusData.concat(this.data);
            retval[0] = -1;
            retval[1] = leftMergeOption;
            retval[2] = this.data[0].key;
            retval[3] = this;
        } else if (rightSurplus > leftSurplus) {
            var rightSurplusData = rightMergeOption.getLeftSurplusData();
            this.data = this.data.concat(rightSurplusData);
            retval[0] = 1;
            retval[1] = this;
            retval[2] = rightMergeOption.getData()[0].key;
            retval[3] = rightMergeOption;
        } else {
            var mergedLeafNode;
            if (!isDefined(leftData)) {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat(rightData)
                });
                retval[0] = 1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer);
                }
            } else if (!isDefined(rightData)) {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat(this.data)
                });
                retval[0] = -1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer);
                }
            } else if (rightData.length < leftData.length) {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat(rightData)
                });
                retval[0] = 1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer);
                }
            } else {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat(this.data)
                });
                retval[0] = -1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer);
                }
            }
        }
        return retval;
    };

    LeafNode.prototype.find = function (key) {
        var index = this.findIndex(key);
        var element = this.data[index];
        if (index < this.data.length && element.key === key) {
            return element.value;
        }
    };

    LeafNode.prototype.range = function (start, end) {
        var node = this;
        var range = [];
        while (isDefined(node)) {
            var startIndex = node.findIndex(start);
            var endIndex = node.findIndex(end);
            var nodeData = node.getData();
            if (startIndex < nodeData.length) {
                for (var i = startIndex; i < endIndex; i++) {
                    range.push(nodeData[i].value);
                }
            }
            if (endIndex == nodeData.length) {
                node = node.getRightPeer();
            } else {
                break;
            }
        }
        return range;
    };

    LeafNode.prototype.toString = function (indent) {
        return indent + "[" + this.data.map(function (element) {
            return element.key;
        }).toString() + "]";
    };

    var Tree = function Tree(options) {
        options = options || {};
        this.order = options.order || 100;
        this.mergeThreshold = options.mergeThreshold || 40;
        this.root = new LeafNode({
            order: this.order,
            mergeThreshold: this.mergeThreshold,
            data: []
        });
    };

    Tree.prototype.toString = function () {
        return this.root.toString("");
    };

    Tree.prototype.insert = function (key, value, clobber) {
        var newNodes = this.root.insert(key, value, clobber);
        if (newNodes.length == 3) {
            this.root = new InternalNode({
                order: this.order,
                mergeThreshold: this.mergeThreshold,
                data: [{
                    key: newNodes[1],
                    left: newNodes[0],
                    right: newNodes[2]
                }]
            });
        } else if (newNodes.length == 1) {
            return newNodes[0];
        }
        return value;
    };

    Tree.prototype.remove = function (key) {
        var retval = this.root.remove(key);
        if (retval.length == 2) {
            this.root = retval[1];
        }
        return retval[0];
    };

    Tree.prototype.find = function (key) {
        return this.root.find(key);
    };

    Tree.prototype.range = function (start, end) {
        return this.root.range(start, end);
    };

    // Expose all types on top
    Tree.Node = Node;
    Tree.InternalNode = InternalNode;
    Tree.LeafNode = LeafNode;

    // Enable module loading if available
    if (typeof module != 'undefined' && module["exports"]) {
        // CommonJS
        module["exports"] = Tree;
    } else if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return Tree;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        // Shim
        if (!global["dcodeIO"]) {
            global["dcodeIO"] = {};
        }
        global["dcodeIO"]["BPlusTree"] = Tree;
    }
})(undefined);

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: http://github.com/dcodeIO/btree.js for details
 */
(function (module, console) {
    'use strict';

    /**
     * Concatenates multiple arrays into a new one.
     * @param {...[Array]} var_args
     * @returns {Array}
     * @private
     */

    function concat(var_args) {
        // Array#concat behaves strangely for empty arrays, so...
        var a = [];
        for (var i = 0; i < arguments.length; i++) {
            Array.prototype.push.apply(a, arguments[i]);
        }
        return a;
    }

    /**
     * Searches an array for the specified value.
     * @param {Array} a
     * @param {*} v
     * @returns {number} Index or -1 if not found
     * @private
     */
    function asearch(a, v) {
        // This is faster than Array#indexOf because it's raw. However, we
        // cannot use binary search because nodes do not have a comparable
        // key. If the compiler is smart, it will inline this.
        for (var i = 0; i < a.length; i++) {
            if (a[i] === v) return i;
        }
        return -i;
    }

    /**
     * btree namespace.
     * @type {Object.<string,*>}
     */
    var btree = {};

    /**
     * Strictly compares two strings, character by character. No locales, no number extension.
     * @param {string} a
     * @param {string} b
     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
     * @expose
     */
    btree.strcmp = function strcmp(a, b) {
        /** @type {number} */
        var ac;
        /** @type {number} */
        var bc;
        for (var i = 0; i < a.length; i++) {
            if (i >= b.length) {
                return 1;
            }
            if ((ac = a.charCodeAt(i)) < (bc = b.charCodeAt(i))) {
                return -1;
            } else if (ac > bc) {
                return 1;
            }
            // If same, continue
        }
        return a.length == b.length ? 0 : -1;
    };

    /**
     * Compares two numbers.
     * @param {number} a
     * @param {number} b
     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
     * @expose
     */
    btree.numcmp = function intcmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    };

    /**
     * Creates a BTree class using the given order.
     * Note that this method returns a class, not an instance.
     * @param {number=} order Defaults to 2
     * @param {function(?, ?):number=} compare Compare implementation to use on keys
     * @returns {Function}
     * @expose
     */
    btree.create = function (order, compare) {

        // Validate order
        if (typeof order == 'undefined') {
            order = 52; // Benchmarks proofed that this is close to the optimum
        } else if (typeof order == 'number') {
            order = Math.floor(order);
        } else {
            order = parseInt(order, 10);
        }
        if (order < 1) order = 1;
        var minOrder = order > 1 ? Math.floor(order / 2) : 1;

        // Use numcmp by default
        if (typeof compare != 'function') {
            compare = btree.numcmp;
        }

        /**
         * Validates a node and prints debugging info if something went wrong.
         * @param {!TreeNode|!Tree} node
         * @private
         */
        function validate(node) {
            // This function will be stripped by the compiler
            if (node instanceof Tree) return;
            if (node.leaves.length + 1 != node.nodes.length) {
                console.log("ERROR: Illegal leaf/node count in " + node + ": " + node.leaves.length + "/" + node.nodes.length);
            }
            for (var i = 0; i < node.leaves.length; i++) {
                if (!node.leaves[i]) {
                    console.log("ERROR: Illegal leaf in " + node + " at " + i + ": " + node.leaves[i]);
                }
            }
            for (i = 0; i < node.nodes.length; i++) {
                if (typeof node.nodes[i] == 'undefined') {
                    console.log("ERROR: Illegal node in " + node + " at " + i + ": undefined");
                }
            }
        }

        /**
         * Constructs a new TreeNode.
         * @class A TreeNode.
         * @param {!(TreeNode|Tree)} parent Parent node
         * @param {Array.<!Leaf>=} leaves Leaf nodes
         * @param {Array.<TreeNode>=} nodes Child nodes
         * @constructor
         */
        var TreeNode = function TreeNode(parent, leaves, nodes) {

            /**
             * Parent node.
             * @type {!TreeNode|!Tree}
             */
            this.parent = parent;

            /**
             * Leaf nodes (max. order).
             * @type {!Array.<!Leaf>}
             */
            this.leaves = leaves || [];
            this.leaves.forEach(function (leaf) {
                leaf.parent = this;
            }, this);

            /**
             * Child nodes (max. order+1).
             * @type {!Array.<TreeNode>}
             */
            this.nodes = nodes || [null];
            this.nodes.forEach(function (node) {
                if (node !== null) node.parent = this;
            }, this);
        };

        /**
         * Searches for the node that would contain the specified key.
         * @param {!*} key
         * @returns {{leaf: !Leaf, index: number}|{node: !TreeNode, index: number}} Leaf if the key exists, else the insertion node
         */
        TreeNode.prototype.search = function (key) {
            if (this.leaves.length > 0) {
                var a = this.leaves[0];
                if (compare(a.key, key) == 0) return { leaf: a, index: 0 };
                if (compare(key, a.key) < 0) {
                    if (this.nodes[0] !== null) {
                        return this.nodes[0].search(key); // Left
                    }
                    return { node: this, index: 0 };
                }
                for (var i = 1; i < this.leaves.length; i++) {
                    var b = this.leaves[i];
                    if (compare(b.key, key) == 0) return { leaf: b, index: i };
                    if (compare(key, b.key) < 0) {
                        if (this.nodes[i] !== null) {
                            return this.nodes[i].search(key); // Inner
                        }
                        return { node: this, index: i };
                    }
                    a = b;
                }
                if (this.nodes[i] !== null) {
                    return this.nodes[i].search(key); // Right
                }
                return { node: this, index: i };
            }
            return { node: this, index: 0 };
        };

        /**
         * Gets the value for the given key.
         * @param {!*} key
         * @returns {*|undefined} If there is no such key, undefined is returned
         */
        TreeNode.prototype.get = function (key) {
            var result = this.search(key);
            if (result.leaf) return result.leaf.value;
            return undefined;
        };

        /**
         * Inserts a key/value pair into this node.
         * @param {!*} key
         * @param {*} value
         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
         * @returns {boolean} true if successfully set, false if already present and overwrite is `false`
         */
        TreeNode.prototype.put = function (key, value, overwrite) {
            var result = this.search(key);
            if (result.leaf) {
                if (typeof overwrite !== 'undefined' && !overwrite) {
                    return false;
                }
                result.leaf.value = value;
                return true;
            } // Key already exists
            var node = result.node,
                index = result.index;
            node.leaves.splice(index, 0, new Leaf(node, key, value));
            node.nodes.splice(index + 1, 0, null);
            if (node.leaves.length > order) {
                // Rebalance
                node.split();
            }
            return true;
        };

        /**
         * Deletes a key from this node.
         * @param {!*} key
         * @returns {boolean} true if the key has been deleted, false if the key does not exist
         */
        TreeNode.prototype.del = function (key) {
            var result = this.search(key);
            if (!result.leaf) return false;
            var leaf = result.leaf,
                node = leaf.parent,
                index = result.index,
                left = node.nodes[index];
            if (left === null) {
                node.leaves.splice(index, 1);
                node.nodes.splice(index, 1);
                node.balance();
            } else {
                var max = left.leaves[left.leaves.length - 1];
                left.del(max.key);
                max.parent = node;
                node.leaves.splice(index, 1, max);
            }
            return true;
        };

        /**
         * Balances this node to fulfill all conditions.
         */
        TreeNode.prototype.balance = function () {
            if (this.parent instanceof Tree) {
                // Special case: Root has just a single child and no leaves
                if (this.leaves.length == 0 && this.nodes[0] !== null) {
                    this.parent.root = this.nodes[0];
                    this.parent.root.parent = this.parent;
                }
                return;
            }
            if (this.leaves.length >= minOrder) {
                return;
            }
            var index = asearch(this.parent.nodes, this),
                left = index > 0 ? this.parent.nodes[index - 1] : null,
                right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null;
            var sep, leaf, rest;
            if (right !== null && right.leaves.length > minOrder) {
                // Append the seperator from parent to this
                sep = this.parent.leaves[index];
                sep.parent = this;
                this.leaves.push(sep);
                // Replace the blank with the first right leaf
                leaf = right.leaves.shift();
                leaf.parent = this.parent;
                this.parent.leaves[index] = leaf;
                // Append the right rest to this
                rest = right.nodes.shift();
                if (rest !== null) rest.parent = this;
                this.nodes.push(rest);
            } else if (left !== null && left.leaves.length > minOrder) {
                // Prepend the seperator from parent to this
                sep = this.parent.leaves[index - 1];
                sep.parent = this;
                this.leaves.unshift(sep);
                // Replace the blank with the last left leaf
                leaf = left.leaves.pop();
                leaf.parent = this.parent;
                this.parent.leaves[index - 1] = leaf;
                // Prepend the left rest to this
                rest = left.nodes.pop();
                if (rest !== null) rest.parent = this;
                this.nodes.unshift(rest);
            } else {
                var subst;
                if (right !== null) {
                    // Combine this + seperator from the parent + right
                    sep = this.parent.leaves[index];
                    subst = new TreeNode(this.parent, concat(this.leaves, [sep], right.leaves), concat(this.nodes, right.nodes));
                    // Remove the seperator from the parent
                    this.parent.leaves.splice(index, 1);
                    // And replace the nodes it seperated with subst
                    this.parent.nodes.splice(index, 2, subst);
                } else if (left !== null) {
                    // Combine left + seperator from parent + this
                    sep = this.parent.leaves[index - 1];
                    subst = new TreeNode(this.parent, concat(left.leaves, [sep], this.leaves), concat(left.nodes, this.nodes));
                    // Remove the seperator from the parent
                    this.parent.leaves.splice(index - 1, 1);
                    // And replace the nodes it seperated with subst
                    this.parent.nodes.splice(index - 1, 2, subst);
                } else {
                    // We should never end here
                    throw new Error("Internal error: " + this.toString(true) + " has neither a left nor a right sibling");
                }
                this.parent.balance();
            }
            // validate(this);
            // validate(this.parent);
        };

        /**
         * Unsplits a child.
         * @param {!Leaf} leaf
         * @param {!TreeNode} rest
         */
        TreeNode.prototype.unsplit = function (leaf, rest) {
            leaf.parent = this;
            rest.parent = this;
            var a = this.leaves[0];
            if (compare(leaf.key, a.key) < 0) {
                this.leaves.unshift(leaf);
                this.nodes.splice(1, 0, rest);
            } else {
                for (var i = 1; i < this.leaves.length; i++) {
                    var b = this.leaves[i];
                    if (compare(leaf.key, b.key) < 0) {
                        this.leaves.splice(i, 0, leaf);
                        this.nodes.splice(i + 1, 0, rest);
                        break;
                    }
                }
                if (i == this.leaves.length) {
                    this.leaves.push(leaf);
                    this.nodes.push(rest);
                }
            }
            if (this.leaves.length > order) {
                this.split();
            }
        };

        /**
         * Splits this node.
         */
        TreeNode.prototype.split = function () {
            var index = Math.floor(this.leaves.length / 2);
            if (this.parent instanceof Tree) {
                this.nodes = [new TreeNode(this, this.leaves.slice(0, index), this.nodes.slice(0, index + 1)), new TreeNode(this, this.leaves.slice(index + 1), this.nodes.slice(index + 1))];
                this.leaves = [this.leaves[index]];
            } else {
                var leaf = this.leaves[index];
                var rest = new TreeNode(this.parent, this.leaves.slice(index + 1), this.nodes.slice(index + 1));
                this.leaves = this.leaves.slice(0, index);
                this.nodes = this.nodes.slice(0, index + 1);
                this.parent.unsplit(leaf, rest);
            }
        };

        /**
         * Returns a string representation of this node.
         * @param {boolean=} includeNodes Whether to include sub-nodes or not
         * @returns {string}
         */
        TreeNode.prototype.toString = function (includeNodes) {
            var val = [];
            for (var i = 0; i < this.leaves.length; i++) {
                val.push(this.leaves[i].key);
            }
            var s = "[" + val.toString() + "]" + (this.parent instanceof Tree ? ":*" : ":" + this.parent);
            if (includeNodes) {
                for (i = 0; i < this.nodes.length; i++) {
                    s += " -> " + this.nodes[i];
                }
            }
            return s;
        };

        /**
         * Prints out the nodes leaves and nodes.
         * @param {number} indent
         */
        TreeNode.prototype.print = function (indent) {
            var space = "";
            for (var i = 0; i < indent; i++) {
                space += " ";
            }for (i = this.leaves.length - 1; i >= 0; i--) {
                if (this.nodes[i + 1] !== null) this.nodes[i + 1].print(indent + 2);
                console.log(space + this.leaves[i].key + (this.parent instanceof Tree ? "*" : ""));
            }
            if (this.nodes[0] !== null) this.nodes[0].print(indent + 2);
        };

        /**
         * Constructs a new Leaf containing a value.
         * @class A Leaf.
         * @param {!TreeNode} parent
         * @param {!*} key
         * @param {*} value
         * @constructor
         */
        var Leaf = function Leaf(parent, key, value) {

            /**
             * Parent node.
             * @type {!TreeNode}
             */
            this.parent = parent;

            /**
             * Key.
             * @type {!*}
             */
            this.key = key;

            /**
             * Value.
             * @type {*}
             */
            this.value = value;
        };

        /**
         * Returns a string representation of this instance.
         * @returns {string}
         */
        Leaf.prototype.toString = function () {
            return "" + this.key;
        };

        /**
         * Constructs a new Tree.
         * @class A Tree.
         * @constructor
         */
        function Tree() {
            this.root = new TreeNode(this);
        }

        /**
         * Inserts a key/value pair into the tree.
         * @param {!*} key
         * @param {*} value
         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
         * @returns {boolean} true if set, false if already present and overwrite is `false`
         * @throws {Error} If the key is undefined or null or the value is undefined
         * @expose
         */
        Tree.prototype.put = function (key, value, overwrite) {
            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
            if (typeof value === 'undefined') throw new Error("Illegal value: " + value);
            return this.root.put(key, value, overwrite);
        };

        /**
         * Gets the value of the specified key.
         * @param {!*} key
         * @returns {*|undefined} If there is no such key, undefined is returned
         * @throws {Error} If the key is undefined or null
         * @expose
         */
        Tree.prototype.get = function (key) {
            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
            return this.root.get(key);
        };

        /**
         * Deletes a key from the tree.
         * @param {!*} key
         * @returns {boolean} true if the key has been deleted, false if the key does not exist
         * @expose
         */
        Tree.prototype.del = function (key) {
            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
            return this.root.del(key);
        };

        /**
         * Walks through all keys [minKey, ..., maxKey] in ascending order.
         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or NULL, walks till the end
         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
         *  parameters. May explicitly return true to stop the loop.
         * @expose
         */
        Tree.prototype.walkAsc = function (minKey, maxKey, callback) {
            if (this.root.leaves.length == 0) {
                return;
            }
            if (typeof minKey == 'function') {
                callback = minKey;
                minKey = maxKey = null;
            } else if (typeof maxKey == 'function') {
                callback = maxKey;
                maxKey = null;
            }
            minKey = typeof minKey != 'undefined' ? minKey : null;
            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
            var ptr, index;
            if (minKey === null) {
                // If there is no minimum limit
                ptr = this.root; // set ptr to the outer left node
                while (ptr.nodes[0] !== null) {
                    ptr = ptr.nodes[0];
                }
                index = 0; // and start at its first leaf
            } else {
                // Else lookup
                var result = this.root.search(minKey);
                if (result.leaf) {
                    // If the minimum key itself exists
                    ptr = result.leaf.parent; // set ptr to the containing node
                    index = asearch(ptr.leaves, result.leaf); // and start at its index
                } else {
                    // If the key does not exist
                    ptr = result.node; // set ptr to the insertion node
                    index = result.index; // and start at the insertion index (key > minKey)
                    if (index >= ptr.leaves.length) {
                        // on overrun, begin at the separator in the parent
                        if (ptr.parent instanceof Tree) {
                            return; // empty range
                        }
                        index = asearch(ptr.parent.nodes, ptr);
                        if (index >= ptr.parent.leaves.length) {
                            return; // empty range
                        }
                        ptr = ptr.parent;
                    }
                }
            }
            // ptr/index now points at our first result
            while (true) {
                if (maxKey !== null && compare(ptr.leaves[index].key, maxKey) > 0) {
                    break; // if there are no more keys less than maxKey
                }
                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
                    break; // if the user explicitly breaks the loop by returning true
                }
                if (ptr.nodes[index + 1] !== null) {
                    // Descend
                    ptr = ptr.nodes[index + 1];
                    index = 0;
                    while (ptr.nodes[0] !== null) {
                        ptr = ptr.nodes[0];
                    }
                } else if (ptr.leaves.length > index + 1) {
                    // Next
                    index++;
                } else {
                    // Ascend
                    do {
                        if (ptr.parent instanceof Tree) {
                            return;
                        }
                        index = asearch(ptr.parent.nodes, ptr);
                        ptr = ptr.parent;
                    } while (index >= ptr.leaves.length);
                }
            }
        };

        /**
         * Alias of {@link Tree#walkAsc}.
         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
         * @param {(*|(function(*, *):(boolean|undefined)))=} maxKey If omitted or NULL, walks till the end
         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
         *  parameters. May explicitly return true to stop the loop.
         * @expose
         */
        Tree.prototype.walk = Tree.prototype.walkAsc;

        /**
         * Walks through all keys [minKey, ..., maxKey] in descending order.
         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or null, walks till the beginning
         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or null, starts at the end
         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
         *  parameters. May explicitly return true to stop the loop.
         * @expose
         */
        Tree.prototype.walkDesc = function (minKey, maxKey, callback) {
            if (typeof minKey == 'function') {
                callback = minKey;
                minKey = maxKey = null;
            } else if (typeof maxKey == 'function') {
                callback = maxKey;
                maxKey = null;
            }
            minKey = typeof minKey != 'undefined' ? minKey : null;
            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
            var ptr, index;
            if (maxKey === null) {
                // If there is no maximum limit
                ptr = this.root; // set ptr to the outer right node
                while (ptr.nodes[ptr.nodes.length - 1] !== null) {
                    ptr = ptr.nodes[ptr.nodes.length - 1];
                }
                index = ptr.leaves.length - 1; // and start at its last leaf
            } else {
                // Else lookup
                var result = this.root.search(maxKey);
                if (result.leaf) {
                    // If the maximum key itself exists
                    ptr = result.leaf.parent; // set ptr to the containing node
                    index = asearch(ptr.leaves, result.leaf); // and start at its index
                } else {
                    // If the key does not exist
                    ptr = result.node; // set ptr to the insertion node
                    index = result.index - 1; // and start at the insertion index-1 (key < maxKey)
                    while (index < 0) {
                        // on underrun, begin at the separator in the parent
                        if (ptr.parent instanceof Tree) {
                            return; // empty range
                        }
                        index = asearch(ptr.parent.nodes, ptr) - 1;
                        if (index < 0) {
                            return; // empty range
                        }
                        ptr = ptr.parent;
                    }
                }
            }
            // ptr/index now points at our first result
            while (true) {
                if (minKey !== null && compare(ptr.leaves[index].key, minKey) < 0) {
                    break; // if there are no more keys bigger than minKey
                }
                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
                    break; // if the user explicitly breaks the loop by returning true
                }
                if (ptr.nodes[index] !== null) {
                    // Descend
                    ptr = ptr.nodes[index];
                    while (ptr.nodes[ptr.nodes.length - 1] !== null) {
                        ptr = ptr.nodes[ptr.nodes.length - 1];
                    }
                    index = ptr.leaves.length - 1;
                } else if (index > 0) {
                    // Next
                    index--;
                } else {
                    // Ascend
                    do {
                        if (ptr.parent instanceof Tree) {
                            return;
                        }
                        index = asearch(ptr.parent.nodes, ptr) - 1;
                        ptr = ptr.parent;
                    } while (index < 0);
                }
            }
        };

        /**
         * Counts the number of keys between minKey and maxKey (both inclusive).
         * @param {*=} minKey If omitted, counts from the start
         * @param {*=} maxKey If omitted, counts till the end
         * @returns {number}
         * @expose
         */
        Tree.prototype.count = function (minKey, maxKey) {
            var n = 0;
            this.walk(typeof minKey != 'undefined' ? minKey : null, typeof maxKey != 'undefined' ? maxKey : null, function (key, value) {
                n++;
            });
            return n;
        };

        /**
         * Prints out all nodes in the tree.
         * @expose
         */
        Tree.prototype.print = function () {
            this.root.print(0);
        };

        /**
         * Returns a string representation of this instance.
         * @returns {string}
         */
        Tree.prototype.toString = function () {
            return "Tree(" + order + ") " + this.root.toString();
        };

        return Tree;
    };

    module.exports = btree;
})(module, console);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(117)(module)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.binarySearch = binarySearch;
exports.binarySearchRecursive = binarySearchRecursive;
/*
 折半查找(Binary Search)

 折半查找又称为二分查找，是一种效率较高的查找方法。
 前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。
 查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。

 1  查找思想
 用Low、High和Mid表示待查找区间的下界、上界和中间位置指针，初值为Low=0，High=n - 1。
 ⑴  取中间位置Mid：Mid=Math.floor((Low+High)/2)；
 ⑵  比较中间位置记录的关键字与给定的K值：
 ①  相等： 查找成功；
 ②  大于：待查记录在区间的前半段，修改上界指针： High=Mid-1，转⑴ ；
 ③  小于：待查记录在区间的后半段，修改下界指针：Low=Mid+1，转⑴ ；
 直到越界(Low>High)，查找失败。

 2  算法分析
 ①  查找时每经过一次比较，查找范围就缩小一半，该过程可用一棵二叉树表示：
 ◆ 根结点就是第一次进行比较的中间位置的记录；
 ◆ 排在中间位置前面的作为左子树的结点；
 ◆ 排在中间位置后面的作为右子树的结点；
 对各子树来说都是相同的。这样所得到的二叉树称为判定树(Decision Tree)。
 ②  将二叉判定树的第Math.floor(Math.log(2, n))+1层上的结点补齐就成为一棵满二叉树，深度不变，h= Math.floor(Math.log(2, n + 1)) 。
 ③  由满二叉树性质知，第i 层上的结点数为Math.pow(2, i-1)(i<=h) ，设表中每个记录的查找概率相等，即Pi=1/n，查找成功时的平均查找长度ASL：
 (n+1)/n*Math.log(2,n+1)-1
 当n很大 (n>50)时， ASL≈ Math.log(2,n+1)-1。


 时间复杂度O(logn)
 */

// 非递归式
function binarySearch(sTable, key) {
    var low = 0;
    var high = sTable.length - 1;

    while (low <= high) {
        var mid = low + high >> 1;
        var elem = sTable[mid];

        if (elem === key) return mid;else if (elem < key) low = mid + 1;else high = mid - 1;
    }

    return -1;
}

console.log('binarySearch: ');
console.log(binarySearch([1, 2, 3, 4, 5], 1)); // 0

// 递归式
function binarySearchRecursive(sTable, key) {
    var low = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var high = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sTable.length - 1;

    if (low > high) return -1;

    var mid = low + high >> 1;
    var elem = sTable[mid];

    if (elem === key) return mid;else if (elem < key) return binarySearchRecursive(sTable, key, mid + 1, high);else return binarySearchRecursive(sTable, key, low, mid - 1);
}

console.log('binarySearchRecursive: ');
console.log(binarySearchRecursive([1, 2, 3, 4, 5], 1)); // 0
console.log(binarySearchRecursive([1, 2, 3, 4, 5], 6)); // -1

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(48);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(47);

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _xxhashjs = __webpack_require__(268);

var _crypto = __webpack_require__(209);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。

 为了降低冲突的概念，Bloom Filter使用了多个哈希函数，而不是一个。

 Bloom Filter算法如下：
 创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为h（i，str），且h（i，str）的范围是0到m-1 。

 (1) 加入字符串过程
 下面是每个字符串处理的过程，首先是将字符串str“记录”到BitSet中的过程：
 对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后将BitSet的第h（1，str）、h（2，str）…… h（k，str）位设为1。

 (2) 检查字符串是否存在的过程
 下面是检查字符串str是否被BitSet记录过的过程：
 对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。
 若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）
 　但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive。

 (3) 删除字符串过程
 字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。

 Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。

 Bloom Filter参数选择
 (1)哈希函数选择
 　　哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。

 (2) m,n,k值，我们如何取值
 我们定义：
 可能把不属于这个集合的元素误认为属于这个集合（False Positive）
 不会把属于这个集合的元素误认为不属于这个集合（False Negative）。

 哈希函数的个数k、位数组大小m、加入的字符串数量n的关系。哈希函数个数k取10，位数组大小m设为字符串个数n的20倍时，false positive发生的概率是0.0000889 ，即10万次的判断中，会存在9次误判，对于一天1亿次的查询，误判的次数为9000次。

 Bloomfilter 的应用场景
 1.黑名单
 最典型的一个应用就是黑名单功能，对用户名称或者IP或者Email进行过滤，每次检查时用key进行hash后，如果不在黑名单内的，肯定可以通行，如果在的则不允许通过，误判情况增加一个排除名单来进行排除。
 误判情况：将正常用户判定为黑名单用户

 2.爬虫重复URL检测
 在爬取网站URL时，要检测这条URL是否已经访问过。
 误判情况：没有访问过的误判为访问过

 3.字典纠错
 检查单词拼写是否正确
 误判情况：错误的单词误判为正确。

 4.磁盘文件检测
 将磁盘中或者数据库中数据key存入该结构中，检测要访问的数据是否在磁盘或数据库中，然后再发起访问，避免空查询造成磁盘或数据库压力。
 误判情况：不存在该数据却误判为有该数据。

 5.CDN（squid）代理缓存技术
 先查找本地有无cache，如果没有则到其他兄弟 cache服务器上去查找。为了避免无谓的查询，在每个cache服务器上保存其兄弟服务器的缓存关键字，以bloomfilter方式存储，再去其他cache服务器查找之前，先检查该结构是否有url，如果有存在url，再去对应服务器查找。
 误判情况： 对应服务器不存在该URL的缓存。

 Thanks to:
 http://allenkim67.github.io/2016/05/17/nodejs-buffer-tutorial.html
 https://github.com/ceejbot/xx-bloom
 https://github.com/pierrec/js-xxhash
 */

var LN2_SQUARED = Math.LN2 * Math.LN2;

var BloomFilter = function () {
    function BloomFilter() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, BloomFilter);

        this.init(options);
    }

    BloomFilter.prototype.init = function init(options) {
        if (options.seeds) {
            this.seeds = options.seeds;
            this.hashes = options.seeds.length;
        } else {
            this.seeds = [];
            this.hashes = options.hashes || 0;

            this._generateSeeds();
        }

        this.bits = options.bits || 1024;
        this.buffer = Buffer.alloc(Math.ceil(this.bits / 8));

        this.clear();
    };

    BloomFilter.optimize = function optimize(itemCount) {
        var errorRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.005;

        var bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED);
        var hashes = Math.round(bits / itemCount * Math.LN2);

        return {
            bits: bits,
            hashes: hashes
        };
    };

    BloomFilter.createOptimal = function createOptimal(itemCount, errorRate) {
        var opts = this.optimize(itemCount, errorRate);

        return new this(opts);
    };

    BloomFilter.prototype.clear = function clear() {
        //  buf.fill(0) to initialize a Buffer to zeroes
        this.buffer.fill(0);
    };

    BloomFilter.prototype._generateSeeds = function _generateSeeds() {
        if (!this.seeds) this.seeds = [];

        for (var i = 0; i < this.hashes; ++i) {
            // Generates cryptographically strong pseudo-random data. Generate 4 bytes.
            var buf = (0, _crypto.randomBytes)(4);
            // Reads an unsigned 32-bit integer from the Buffer from index 0
            this.seeds[i] = buf.readUInt32LE(0);

            // Make sure we don't end up with two identical seeds,
            // which is unlikely but possible.
            for (var j = 0; j < i; ++j) {
                if (this.seeds[i] === this.seeds[j]) {
                    --i;
                    break;
                }
            }
        }
    };

    BloomFilter.prototype.add = function add(buf) {
        if (Array.isArray(buf)) {
            for (var _iterator = buf, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var item = _ref;

                this.add(item);
            }
        } else {
            buf = Buffer.from(buf);

            for (var i = 0; i < this.hashes; ++i) {
                var hash = (0, _xxhashjs.h32)(buf, this.seeds[i]).toString();
                var bit = hash % this.bits;
                this._setBit(bit);
            }
        }
    };

    BloomFilter.prototype.has = function has(item) {
        item = Buffer.from(item);

        for (var i = 0; i < this.hashes; ++i) {
            var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
            var bit = hash % this.bits;

            var isInSet = this._getBit(bit);
            if (!isInSet) return false;
        }

        return true;
    };

    BloomFilter.prototype._setBit = function _setBit(bit) {
        var pos = Math.floor(bit / 8);
        var shift = bit % 8;

        var bitField = this.buffer[pos];
        bitField |= 0x1 << shift;
        this.buffer[pos] = bitField;
    };

    BloomFilter.prototype._getBit = function _getBit(bit) {
        var pos = Math.floor(bit / 8);
        var shift = bit % 8;

        var bitField = this.buffer[pos];

        return (bitField & 0x1 << shift) !== 0;
    };

    return BloomFilter;
}();

exports.default = BloomFilter;


var filter = new BloomFilter({ hashes: 8, bits: 1024 });
filter.add(['cat', 'dog', 'coati', 'red panda']);
console.log(filter.has('cat'));
console.log(filter.has('coat'));
console.log(filter.has('null'));

var CountingBloomFilter = function (_BloomFilter) {
    (0, _inherits3.default)(CountingBloomFilter, _BloomFilter);

    function CountingBloomFilter() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, CountingBloomFilter);
        return (0, _possibleConstructorReturn3.default)(this, _BloomFilter.call(this, opts));
    }

    CountingBloomFilter.prototype.init = function init(opts) {
        if (opts.seeds) {
            this.seeds = opts.seeds;
            this.hashes = opts.seeds.length;
        } else {
            this.hashes = opts.hashes || 8;
            this._generateSeeds();
        }

        this.bits = opts.bits || 1024;
        this.buffer = Buffer.alloc(this.bits);

        this.clear();
    };

    CountingBloomFilter.createOptimal = function createOptimal(itemCount, errorRate) {
        var opts = BloomFilter.optimize(itemCount, errorRate);
        return new this(opts);
    };

    CountingBloomFilter.prototype.clear = function clear() {
        _BloomFilter.prototype.clear.call(this);

        this.overflow = 0;
    };

    CountingBloomFilter.prototype._setBit = function _setBit(bit) {
        // no-op at overflow
        if (this.buffer[bit] === 255) {
            ++this.overflow;
            return;
        }

        ++this.buffer[bit];
    };

    CountingBloomFilter.prototype._unSetBit = function _unSetBit(bit) {
        if (this.buffer[bit] === 255 || this.buffer[bit] === 0) return;

        --this.buffer[bit];
    };

    CountingBloomFilter.prototype._getBit = function _getBit(bit) {
        return this.buffer[bit] !== 0;
    };

    CountingBloomFilter.prototype.remove = function remove(item) {
        if (!Buffer.isBuffer(item)) item = Buffer.from(item);

        for (var i = 0; i < this.seeds.length; ++i) {
            var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
            var bit = hash % this.bits;

            this._unSetBit(bit);
        }
    };

    (0, _createClass3.default)(CountingBloomFilter, [{
        key: 'hasOverflowed',
        get: function get() {
            return this.overflow > 0;
        }
    }]);
    return CountingBloomFilter;
}(BloomFilter);

console.log('CountingBloomFilter');
var filter = new CountingBloomFilter({ hashes: 8, bits: 1024 });
filter.add(['cat', 'dog', 'coati', 'red panda']);
console.log(filter.has('cat'));
filter.remove('cat');
console.log(filter.has('cat'));
console.log(filter.has('coat'));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TrieTree = exports.DoubleLinkedTree = undefined;

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Created by Luke on 2015/1/11.
 */

/*

 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，也叫字典树，来表示这样的字符串的集合。

 概念

 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。键树又称为数字查找树（Digital Search Tree)或Trie树(trie为retrieve中间4个字符)，其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A,B,C,....Z的单词所在页,再对各部分标出第二字母为A,B,C,...Z的单词所在的页, ....等等。

 键树是一种特殊的查找树，它的某个节点不是包含一个或多个关键字，而是只包含组成关键字的一部分（字符或数字），比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。

 根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。事实上，还可以赋予“字符串”更广泛的含义，它可以是任何类型的对象组成的串。


 键树的存储
 1）双链树表示
 2) 多重链表表示


 键树的应用场景

 Trie是一种非常简单高效的数据结构，但有大量的应用实例。
 （1） 字符串检索
 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
 举例：
 @  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
 @  给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。

 （2）字符串最长公共前缀
 Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
 举例：
 @ 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？
 解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
 1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
 2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；
 （关于并查集，Tarjan算法，RMQ问题，网上有很多资料。）

 （3）排序
 Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
 举例：
 @ 给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。

 （4） 作为其他数据结构和算法的辅助结构
 如后缀树，AC自动机等
 */

/*
 双链树表示

 以树的孩子兄弟链表来表示键树，则每个分支结点包括三个域：
 symbol域：存储关键字的一个字符；
 first域：存储指向第一棵子树根的指针；
 next域：存储指向右兄弟的指针。

 同时，叶子结点不含first域，它的infoptr域存储指向该关键字记录的指针。
 此时的键树又称双链树。
 在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。
 结点的结构中可以设置一个枚举变量表示结点的类型，叶子结点和分支结点。
 叶子结点和分支结点都有symbol域和next域。不同的一个域可以用联合表示，叶子结点包含infoptr指向记录，而分支结点是first域指向其第一棵子树。


 双链树的查找

 假设给定值为K.ch(0..num-1), 其中K.ch[0]至 K.ch[num-2]表示待查关键字中num-1个字符， K.ch[num-1]为结束符$。
 从双链树的根指针出发，顺first指针找到第一棵子树的根结点，以K.ch[0]和此结点的symbol域比较，若相等，则顺first域再比较下一字符，否则沿next域顺序查找。
 若直至空仍比较不等，则查找不成功。

 // 相关资料
 http://www.cnblogs.com/rollenholt/archive/2012/04/24/2468932.html
 http://blog.csdn.net/v_july_v/article/details/6897097
 http://www.raychase.net/1783
 */

var LEAF = 'leaf';
var BRANCH = 'branch';
var TERMINAL = new String('$');

var DoubleLinkedTree = exports.DoubleLinkedTree = function () {
    function DoubleLinkedTree() {
        var symbol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'root';
        var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BRANCH;
        var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        (0, _classCallCheck3.default)(this, DoubleLinkedTree);

        this.symbol = symbol;
        this.next = null;
        this.kind = kind;
        this.info = info;
        this.first = null;
    }

    DoubleLinkedTree.prototype.synoSearch = function synoSearch(key) {
        var p = this.first;

        for (var i = 0; p && i < key.length; ++i) {
            if (p && p.kind === LEAF) break;
            while (p && p.symbol < key[i]) {
                p = p.next;
            }if (p && p.symbol === key[i]) p = p.first;else p = null;
        }

        return p && p.kind === LEAF ? p.info : null;
    };

    DoubleLinkedTree.prototype.search = function search(key) {
        var p = this.first;

        for (var i = 0; p && i < key.length; ++i) {
            while (p && p.symbol < key[i]) {
                p = p.next;
            }if (p && p.symbol === key[i]) p = p.first;else p = null;
        }

        return p && p.kind === LEAF ? p.info : null;
    };

    DoubleLinkedTree.prototype.insert = function insert(key, value) {
        key += '';
        var cur = this;

        for (var i = 0; i < key.length; ++i) {
            var c = key[i];
            var p = cur;
            cur = cur.first;
            var node = new DoubleLinkedTree(c, BRANCH);

            // 如果没有子结点则将新结点作为子结点
            if (!cur) {
                p.first = node;
                node.parent = p;
                cur = node;
            } else {
                // 在兄弟结点中找到对应结点
                if (c < cur.symbol) {
                    node.parent = cur.parent;
                    node.next = cur;
                    node.parent.first = node;
                    cur = node;
                } else if (c > cur.symbol) {
                    var b = void 0;
                    while (cur) {
                        // 如果相等，退出该循环查找下一字符
                        if (c === cur.symbol) break;
                        // 如果小于当前字符，则插入到当前结点前面
                        else if (c < cur.symbol) {
                                node.parent = cur.parent;
                                node.next = cur;
                                b.next = node;
                                cur = node;
                                break;
                            } else {
                                b = cur;
                                cur = cur.next;
                            }
                    }

                    // 如果没有兄弟结点则插入到兄弟结点
                    if (!cur) {
                        b.next = node;
                        node.parent = b.parent;
                        cur = node;
                    }
                }
            }
        }

        // 生成叶子结点
        var success = false;
        if (cur.kind === BRANCH) {
            var child = cur.first;

            // 如果不存在关键字则说明插入成功，否则插入失败
            if (!(child && child.symbol === TERMINAL)) {
                cur.first = new DoubleLinkedTree(TERMINAL, LEAF, value != null ? value : key);
                cur.first.parent = cur;
                cur.first.next = child;
                success = true;
            }
        }

        return success;
    };

    DoubleLinkedTree.prototype.remove = function remove(key) {
        var p = this.first;
        var i = 0;

        while (p && i < key.length) {
            while (p && p.symbol < key[i]) {
                p = p.next;
            }if (p && p.symbol === key[i]) {
                p = p.first;
                ++i;
            } else return false;
        }

        var data = p.info;
        while (!p.next && p.parent) {
            p = p.parent;
        }var top = p;

        if (top == this) {
            this.first = null;
            return data;
        }

        p = top.parent;
        if (p) {
            p = p.first;
            while (p) {
                var pre = void 0;
                if (p == top) {
                    // 删除在first域上的子树结点
                    if (!pre) top.parent.first = top.parent.first.next;
                    // 删除在next域的兄弟结点
                    else pre.next = pre.next.next;

                    return data;
                } else {
                    pre = p;
                    p = p.next;
                }
            }
        }

        return false;
    };

    return DoubleLinkedTree;
}();

var test = new DoubleLinkedTree();
test.insert('CAI');
test.insert('LAN');
test.insert('CAO');
test.insert('CHA');
test.insert('CHANG');
test.insert('CHAO');
test.insert('CHEN');
test.insert('LI');
test.insert('LIU');
test.insert('ZHAO');
test.insert('ZHAO');

console.log('\nsearch: ');
console.log(test.search('CAI'));
console.log(test.search('CHA'));
console.log(test.search('CHANG'));
console.log(test.search('ZHAOx'));

console.log('\nremove:');
console.log(test.remove('CAI'));
console.log(test.remove('CAI'));
console.log(test.remove('LAN'));
console.log(test.remove('CAO'));
console.log(test.remove('CHA'));
console.log(test.remove('CHANG'));
console.log(test.remove('CHAO'));
console.log(test.remove('CHEN'));
console.log(test.remove('LI'));
console.log(test.remove('LIU'));
console.log(test.remove('ZHAO'));

/*
 多重链表表示

 若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树。
 （Trie是从检索retrieve中取中间四个字符的，读音同try）。
 若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。
 在Trie树中有两种结点：
 分支结点：含有d个指针域和一个指示该结点中非空指针域的个数的整数域。在分支结点中不设数据域，每个分支结点所表示的字符均有其父结点中指向该结点的指针所在位置决定。
 叶子结点：含有关键字域和指向记录的指针域。


 在Trie树上进行查找

 从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功，若分支结点中和给定值相应的指针为空，或叶子结点中的关键字和给定值不相等，则查找不成功。


 优化Trie树的深度

 我们可对关键字集选择一种合适的分割。先按首字符不通分成多个子集之后，然后按最后一个字符不同分割每个子集，再按第二个字符。。。前后交叉分割。一缩减Trie树的深度
 */
// 求字符在字母表中的序号
function order(c) {
    return c ? c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1 : 0;
}

// 通过回溯法清理Trie树的函数
function removeNode(trieNode, order, clear) {
    trieNode.branch.nodes[order] = null;
    --trieNode.branch.num;

    if (!clear) return;

    var nodes = trieNode.branch.nodes;
    var parent = trieNode.parent;
    var pre = trieNode;

    while (parent) {
        for (var i in nodes) {
            if (nodes.hasOwnProperty(i) && nodes[i]) return;
        }

        var index = void 0;
        var parentNodes = parent.branch.nodes;
        for (var _i in parentNodes) {
            if (parentNodes.hasOwnProperty(_i) && parentNodes[_i] && parentNodes[_i] == pre) index = _i;
        }
        parent.branch.nodes[index] = null;
        --parent.branch.num;

        pre = parent;
        nodes = parent.branch.nodes;
        parent = parent.parent;
    }
}

var TrieTree = exports.TrieTree = function () {
    function TrieTree() {
        var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BRANCH;
        (0, _classCallCheck3.default)(this, TrieTree);

        this.kind = kind;
        this.parent = null;

        if (kind === LEAF) {
            this.leaf = {
                key: null,
                info: null
            };
        } else {
            this.branch = {
                // “$”为第一个字符，后续为26个字母
                nodes: new Array(27),
                num: 0
            };
        }
    }

    TrieTree.prototype.search = function search(key) {
        var p = this,
            i = 0;
        for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {}

        if (p) {
            if (p.kind === LEAF && p.leaf.key === key) return p.leaf.info;
            // 同义词
            else if (p.kind === BRANCH) {
                    p = p.branch.nodes[0];
                    if (p && p.leaf.key === key) return p.leaf.info;
                }
        }

        return null;
    };

    TrieTree.prototype.insert = function insert(key, value) {
        // 建叶子结点
        var q = new TrieTree(LEAF);
        q.leaf.key = key;
        q.leaf.info = value;

        // 自上而下查找
        var last = void 0;
        var p = this,
            i = 0;
        for (; p && p.kind === BRANCH && i < key.length && p.branch.nodes[order(key[i])]; p = p.branch.nodes[order(key[i])], ++i) {
            last = p;
        } // 如果最后落到分支结点（无同义词）
        // 直接连上叶子
        if (p.kind === BRANCH) {
            p.branch.nodes[order(key[i])] = q;
            q.parent = p;
            ++p.branch.num;
        }
        // 如果最后落到叶子结点（有同义词）
        else {
                if (p.leaf.key === key) return false;

                // 建立新的分支结点
                var r = new TrieTree(BRANCH);
                // 用新的分支结点取代老叶子结点和上一层的联系
                last.branch.nodes[order(key[i - 1])] = r;
                r.parent = last;
                r.branch.num = 2;
                r.branch.nodes[order(key[i])] = q;
                q.parent = r;
                // 新分支结点与新老两个叶子结点相连
                r.branch.nodes[order(p.leaf.key[i])] = p;
                p.parent = r;
            }

        return true;
    };

    /**
     *
     * @param key
     * @param {Boolean} clear 是否需要清理结点
     * @returns {*} 如果删除成功返回info数据否则返回false
     */


    TrieTree.prototype.remove = function remove(key, clear) {
        var last = void 0;
        var p = this,
            i = 0;
        // 查找待删除元素
        for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {
            last = p;
        }if (!p) return false;

        clear = typeof clear !== 'undefined' ? clear : true;
        var data = null;

        if (p.kind === LEAF && p.leaf.key === key) {
            data = p.leaf.info;
            removeNode(last, order(key[i - 1]), clear);
            return data;
        } else if (p.kind === BRANCH) {
            p = p.branch.nodes[0];
            if (p && p.leaf.key === key) {
                data = p.leaf.info;
                removeNode(p.parent, 0, clear);
                return data;
            }
        }

        return false;
    };

    return TrieTree;
}();

var test = new TrieTree();

test.insert('CHA');
test.insert('CHA');
test.insert('CHANG');
test.insert('CAI');
test.insert('CHEN');
test.insert('CAO');
test.insert('CHAO');
test.insert('LONG');
test.insert('LI');
test.insert('LAN');
test.insert('LIU');
test.insert('WANG');
test.insert('WEN');
test.insert('WU');
test.insert('YANG');
test.insert('YUN');
test.insert('ZHAO');

console.log('\nsearch: ');
console.log(test.search('YUN'));
console.log(test.search('ZHAO'));
console.log(test.search('CHA'));

test.remove('LAN');
test.remove('LIU');
test.remove('WANG');
test.remove('WEN');
test.remove('WU');
test.remove('YANG');
test.remove('YUN');
test.remove('ZHAO');
test.remove('CHA');
test.remove('CHANG');
test.remove('CAI');
test.remove('CHEN');
test.remove('CAO');
test.remove('CHAO');
test.remove('LONG');
test.remove('LI');

test.insert('LI');
test.insert('LAN');
test.insert('LIU');

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LinkedListHashTable = exports.HashTable = undefined;

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _LinkedList = __webpack_require__(80);

var _LinkedList2 = _interopRequireDefault(_LinkedList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hashSize = buildHashSize(977, 20); /**
                                        * HashTable
                                        * Created by Luke on 2014/12/30.
                                        */

/**
哈希(散列)查找

基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。

基本概念

哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数。
哈希函数是一种映象，是从关键字空间到存储地址空间的一种映象。可写成：addr(ai)=H(ki) ，其中i是表中一个元素，addr(ai)是ai的地址， ki是ai的关键字。

哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表。

哈希查找(又叫散列查找)：利用哈希函数进行查找的过程叫哈希查找。

冲突：对于不同的关键字ki、kj，若kikj，但H(ki)=H(kj)的现象叫冲突(collision) 。

同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。
哈希函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；当冲突发生时，应该有处理冲突的方法。设计一个散列表应包括：
①  散列表的空间范围，即确定散列函数的值域；
②  构造合适的散列函数，使得对于所有可能的元素(记录的关键字)，函数值均在散列表的地址空间范围内，且出现冲突的可能尽量小；
③  处理冲突的方法。即当冲突出现时如何解决。


哈希函数的构造

哈希函数是一种映象，其设定很灵活，只要使任何关键字的哈希函数值都落在表长允许的范围之内即可。哈希函数“好坏”的主要评价因素有：
◆ 散列函数的构造简单；
◆ 能“均匀”地将散列表中的关键字映射到地址空间。所谓“均匀”(uniform)是指发生冲突的可能性尽可能最少。

1  直接定址法
取关键字或关键字的某个线性函数作哈希地址，即H(key)=key    或   H(key)=a·key+b(a,b为常数)
特点：直接定址法所得地址集合与关键字集合大小相等，不会发生冲突，但实际中很少使用。

2  数字分析法
对关键字进行分析，取关键字的若干位或组合作为哈希地址。
适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。
例： 设有80个记录，关键字为8位十进制数，哈希地址为2位十进制数。
           
8  1  3  4  6  5  3  2
8  1  3  7  2  2  4  2
8  1  3  8  7  4  2  2
8  1  3  0  1  3  6  7
8  1  3  2  2  8  1  7
8  1  3  3  8  9  6  7
8  1  3  6  8  5  3  7
8  1  4  1  9  3  5  5
分析：  只取8
       只取1
       只取3、4
       只取2、7、5
      数字分布近乎随机
所以：取任意两位或两位与另两位的叠加作哈希地址

3  平方取中法
将关键字平方后取中间几位作为哈希地址。
一个数平方后中间几位和数的每一位都有关，则由随机分布的关键字得到的散列地址也是随机的。散列函数所取的位数由散列表的长度决定。这种方法适于不知道全部关键字情况，是一种较为常用的方法。

4  折叠法
将关键字分割成位数相同的几部分(最后一部分可以不同)，然后取这几部分的叠加和作为哈希地址。
数位叠加有移位叠加和间界叠加两种。
◆ 移位叠加：将分割后的几部分低位对齐相加。
◆ 间界叠加：从一端到另一端沿分割界来回折迭，然后对齐相加。
适于关键字位数很多，且每一位上数字分布大致均匀情况。
例： 设关键字为0442205864，哈希地址位数为4 。两种不同的地址计算方法如下：
    5864                        5864
    4220                        0224
      04       移位叠加            04           间界叠加
 ---------                  -------------
   10088                        6091

5  除留余数法
取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p     (p<=m)
是一种简单、常用的哈希函数构造方法。
利用这种方法的关键是p的选取，p选的不好，容易产生同义词。p的选取的分析：
◆  选取p=2i(p<=m)：运算便于用移位来实现，但等于将关键字的高位忽略而仅留下低位二进制数。高位不同而低位相同的关键字是同义词。
◆ 选取p=q*f(q、f都是质因数，p<=m)：则所有含有q或f因子的关键字的散列地址均是q或f的倍数。
◆ 选取p为素数或p=q*f(q、f是质数且均大于20，p<=m)：常用的选取方法，能减少冲突出现的可能性。

6  随机数法
取关键字的随机函数值作哈希地址，即H(key)=random(key)
当散列表中关键字长度不等时，该方法比较合适。



选取哈希函数，考虑以下因素
◆ 计算哈希函数所需时间；
◆ 关键字的长度；
◆ 哈希表长度（哈希地址范围）；
◆ 关键字分布情况；
◆ 记录的查找频率。



冲突处理的方法
冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。

1  开放定址法
基本方法：当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。散列地址的计算公式是：
Hi(key)=(H(key)+di)  MOD m，i=1, 2, …, k(k<=m-1)

其中：H(key)：哈希函数；m：散列表长度；
di：第i次探测时的增量序列；
Hi(key) ：经第i次探测后得到的散列地址。

⑴  线性探测法
将散列表T[0 …m-1]看成循环向量。当发生冲突时，从初次发生冲突的位置依次向后探测其他的地址。
增量序列为：di=1, 2, 3, …, m-1
设初次发生冲突的地址是h，则依次探测T[h+1]，T[h+2]…，直到T[m-1]时又循环到表头，再次探测T[0]，T[1]…，直到T[h-1]。探测过程终止的情况是：
◆ 探测到的地址为空：表中没有记录。若是查找则失败；若是插入则将记录写入到该地址；
◆ 探测到的地址有给定的关键字：若是查找则成功；若是插入则失败；
◆ 直到T[h]：仍未探测到空地址或给定的关键字，散列表满。

例1 ：设散列表长为7，记录关键字组为：15, 14, 28, 26, 56, 23，散列函数：H(key)=key   MOD  7，冲突处理采用线性探测法。
H(15)=15  MOD 7=1
H(14)=14  MOD 7=0
H(28)=28  MOD 7=0  冲突   H1(28)=1  又冲突
H2(28)=2           H(26)=26  MOD 7=5
H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
H2(56)=2   又冲突    H3(56)=3
H(23)=23  MOD 7=2     冲突      H1(23)=3     又冲突
H3(23)=4

0     1      2      3      4       5     6
14    15     28     56     23      26

线性探测法的特点
◆ 优点：只要散列表未满，总能找到一个不冲突的散列地址；
◆ 缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而又增加了更多的冲突机会(这种现象称为冲突的“聚集”)。

⑵  二次探测法
增量序列为：di=1²,-1²,2²,-2²,3²,……±k²  (k<=⌊m/2⌋)

上述例题若采用二次探测法进行冲突处理，则：
H(15)=15  MOD 7=1         H(14)=14  MOD 7=0
H(28)=28  MOD 7=0     冲突      H1(28)=1     又冲突
H2(28)=4
H(26)=26  MOD 7=5
H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
H2(56)=0   又冲突    H3(56)=4    又冲突
H4(56)=2
H(23)=23  MOD 7=2      冲突
H1(23)=3

二次探测法的特点
◆ 优点：探测序列跳跃式地散列到整个表中，不易产生冲突的“聚集”现象；
◆ 缺点：不能保证探测到散列表的所有地址。

⑶   伪随机探测法
增量序列使用一个伪随机函数来产生一个落在闭区间[1，m-1]的随机序列。

例2 ： 表长为11的哈希表中已填有关键字为17，60，29的记录，散列函数为H(key)=key  MOD  11 。 现有第4个记录，其关键字为38，按三种处理冲突的方法，将它填入表中。

(1)  H(38)=38 MOD 11=5    冲突
     H1=(5+1) MOD 11=6    冲突
     H2=(5+2) MOD 11=7    冲突
     H3=(5+3) MOD 11=8    不冲突
(2)  H(38)=38 MOD 11=5      冲突
     H1=(5+1²) MOD 11=6    冲突
     H2=(5-1²) MOD 11=4     不冲突
(3)  H(38)=38 MOD 11=5    冲突
     设伪随机数序列为9，则H1=(5+9) MOD 11=3 不冲突


2  再哈希法
构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即：Hi=RHi(key)     i=1, 2, …, k
RHi ：一组不同的哈希函数。第一次发生冲突时，用RH1计算，第二次发生冲突时，用RH2计算…依此类推知道得到某个Hi不再冲突为止。
◆  优点：不易产生冲突的“聚集”现象；
◆  缺点：计算时间增加。


3  链地址法
方法：将所有关键字为同义词(散列地址相同)的记录存储在一个单链表中，并用一维数组存放链表的头指针。
设散列表长为m，定义一个一维指针数组：
RecNode *linkhash[m]，其中RecNode是结点类型，每个分量的初值为空。凡散列地址为k的记录都插入到以linkhash[k]为头指针的链表中，插入位置可以在表头或表尾或按关键字排序插入。

例： 已知一组关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79) ，哈希函数为：H(key)=key MOD 13，用链地址法处理冲突:

 0
 1  --> 14 -> 1 -> 27 -> 79
 2
 3  --> 68 -> 55
 4
 5
 6  --> 19 -> 84
 7  --> 20
 8
 9
 10 --> 23 -> 10
 11 --> 11
 12

 优点：不易产生冲突的“聚集”；删除记录也很简单。


 4  建立公共溢出区
 方法：在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。
 设散列表长为m，设立基本散列表hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。

 例： 已知一组关键字(15, 4, 18, 7, 37, 47) ，散列表长度为7 ，哈希函数为：H(key)=key MOD 7，用建立公共溢出区法处理冲突。得到的基本表和溢出表如下：
                    散列地址    0     1     2     3     4     5     6
 Hashtable表：
                    关键字     7     15    37          4     47

                    溢出地址    0     1     2     3     4     5     6
 overtable表：
                     关键字    18




 哈希查找过程及分析

 1   哈希查找过程
 哈希表的主要目的是用于快速查找，且插入和删除操作都要用到查找。由于散列表的特殊组织形式，其查找有特殊的方法。

 给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定关键字相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直到哈希表中某个位置为空或者表中所填记录的关键字等于给定值时为止。



 哈希查找分析

 从哈希查找过程可见：尽管散列表在关键字与记录的存储地址之间建立了直接映象，但由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用ASL。
 哈希查找时关键字与给定值比较的次数取决于：
 ◆ 哈希函数；
 ◆ 处理冲突的方法；
 ◆ 哈希表的填满因子α 。填满因子α的定义是：

 α = 表中填入的记录数 / 哈希表长度


 各种散列函数所构造的散列表的ASL如下：

 ⑴   线性探测法的平均查找长度是：
 S成功 约等于 1 / 2 * (1 + 1 / (1 - α))
 S失败 约等于 1 / 2 * (1 + 1 / (1 - α) * (1 - α))

 ⑵   二次探测、伪随机探测、再哈希法的平均查找长度是：
 S成功 约等于 -1 / α * ln(1 - α)
 S失败 约等于 1 / (1 - α)

 ⑶   用链地址法解决冲突的平均查找长度是：
 S成功 约等于 1 + α / 2
 S失败 约等于 α + e的-α次幂


 */

var HashTable = exports.HashTable = function () {
    function HashTable() {
        (0, _classCallCheck3.default)(this, HashTable);

        this.data = [];
        // 当前数据元素个数;
        this.count = 0;
        // 当前容量
        this.sizeIndex = 0;
    }

    // 使用线性探测法解决冲突


    HashTable.prototype.search = function search(key) {
        var max = hashSize[this.sizeIndex];
        var p = hash(key, max);
        var c = 0;

        while (p < max && this.data[p] != null && key !== this.data[p]) {
            p = collision(key, ++c, max);
        }

        return {
            success: key === this.data[p],
            collisionTimes: c,
            index: p
        };
    };

    HashTable.prototype.insert = function insert(key) {
        var max = hashSize[this.sizeIndex];
        if (this.count >= max) return { success: false, errormsg: 'table overflowed' };

        var ret = this.search(key);
        var p = ret.index;
        var c = ret.collisionTimes;

        if (ret.success) return false;else if (c < hashSize[this.sizeIndex] / 2) {
            this.data[p] = key;
            ++this.count;
            return true;
        } else {
            this.recreateHashTable();
            return false;
        }
    };

    HashTable.prototype.remove = function remove(key) {
        if (!this.count) return false;

        var max = hashSize[this.sizeIndex];
        var p = hash(key, max);
        var c = 0;

        while (key !== this.data[p]) {
            p = collision(key, ++c, max);
        }if (key === this.data[p]) {
            var data = this.data[p];
            this.data.splice(p, 1);
            --this.count;

            return data;
        }

        return false;
    };

    HashTable.prototype.recreateHashTable = function recreateHashTable() {
        return ++this.sizeIndex < hashSize.length;
    };

    return HashTable;
}();

;

// ELFhash字符串散列函数
function hash(str, max) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
        hash = (hash << 5) + hash + str.charCodeAt(i);
        hash = hash & hash; // Convert to 32bit integer
        hash = Math.abs(hash);
    }
    return hash % max;
}

function collision(key, times, max) {
    // 线性探测法
    return (hash(key, max) + times) % max;
}

function isPrime(n) {
    if (n <= 3) return n > 1;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (var i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }

    return true;
}

function buildHashSize(begin, length) {
    var hashSize = [];

    while (1) {
        if (hashSize.length >= length) break;
        if (isPrime(begin)) hashSize.push(begin);
        ++begin;
    }

    return hashSize;
}

// 开放定址法
//hashSize = [5, 7]; // for test. will be deleted
var test = new HashTable();
test.insert('17');
test.insert('60');
test.insert('29');
test.insert('38');
test.insert('39');
test.insert('40');

test.remove('17');
test.remove('60');
test.remove('29');
test.remove('38');
test.remove('39');
test.remove('40');

// 使用链地址法解决冲突的哈希表

var LinkedListHashTable = exports.LinkedListHashTable = function () {
    function LinkedListHashTable() {
        (0, _classCallCheck3.default)(this, LinkedListHashTable);

        // 当前数据元素个数;
        this.count = 0;
        // 当前容量
        this.sizeIndex = 0;
        this.hNodes = [];
    }

    LinkedListHashTable.prototype.search = function search(key) {
        var max = hashSize[this.sizeIndex];
        var i = hash(key, max);
        var t = this.hNodes;

        if (t[i] == null) return { success: false, index: i };

        var p = t[i];
        var data = null;

        p.forEach(function (node) {
            if (node.data === key) {
                data = node.data;
                return true;
            }
        });

        return { success: data === key, index: i };
    };

    LinkedListHashTable.prototype.insert = function insert(key) {
        var max = hashSize[this.sizeIndex];
        if (this.count >= max) return { success: false, errormsg: 'table overflowed' };

        var ret = this.search(key);
        var index = ret.index;

        if (ret.success) return false;

        if (!this.hNodes[index]) this.hNodes[index] = new _LinkedList2.default();

        if (this.hNodes[index].size < hashSize[this.sizeIndex] / 2) {
            this.hNodes[index].orderInsert(key);
            ++this.count;
            return true;
        } else {
            this.recreateHashTable();
            return false;
        }
    };

    LinkedListHashTable.prototype.remove = function remove(key) {
        if (!this.count) return false;

        var ret = this.search(key);

        if (ret.success) {
            var index = ret.index;
            var data = ret.data;
            this.hNodes[index]['remove'](key);
            --this.count;
            return data;
        }

        return false;
    };

    LinkedListHashTable.prototype.recreateHashTable = function recreateHashTable() {
        return ++this.sizeIndex < hashSize.length;
    };

    return LinkedListHashTable;
}();

;

var test2 = new LinkedListHashTable();
test2.insert('17');
test2.insert('60');
test2.insert('29');
test2.insert('38');
test2.insert('39');
test2.insert('40');

test2.remove('17');
test2.remove('60');
test2.remove('29');
test2.remove('38');
test2.remove('39');
test2.remove('40');

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(48);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(47);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BinarySortedTree = __webpack_require__(74);

var _BinarySortedTree2 = _interopRequireDefault(_BinarySortedTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RED = 'red'; /**
                  * Red Black Tree
                  * Created by Luke on 2014/12/30.
                  */
/*
 http://blog.csdn.net/v_july_v/article/details/6105630

 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

 红黑树的5个性质：
 1.每个结点要么是红的要么是黑的。
 2.根结点是黑的。
 3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
 4.如果一个结点是红的，那么它的两个儿子都是黑的。
 5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。

 正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。


 树的旋转

当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。

树的旋转分为左旋和右旋

树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。


红黑树的插入

如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。
但当遇到下述3种情况时又该如何调整呢？
● 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况
对此，我们的解决策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
于是，插入修复情况1转换成了插入修复情况2

● 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
从而插入修复情况2转换成了插入修复情况3。

● 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。

经过上面情况3、情况4、情况5等3种插入修复情况的操作示意图，读者自会发现，后面的情况4、情况5都是针对情况3插入节点4以后，进行的一系列插入修复情况操作，不过，指向当前节点N指针一直在变化。所以，你可以想当然的认为：整个下来，情况3、4、5就是一个完整的插入修复情况的操作流程


红黑树的删除

在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。

上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。

 如果是以下情况，恢复比较简单：
 a)当前节点是红+黑色
 解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
 b)当前节点是黑+黑且是根节点， 解法：什么都不做，结束。

 但如果是以下情况呢？：
 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)
 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
 此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。

 下面，咱们便来分别处理这4种删除修复情况。

 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。

 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变）

 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持

 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确


 最后值得一提的是上述删除修复的情况1~4都只是树的局部，并非树的整体全部，且删除修复情况3、4在经过上面的调整后，调整还没结束,还得继续调整直至重新恢复平衡
*/

var BLACK = 'black';

var RedBlackNode = function (_BSTNode) {
    (0, _inherits3.default)(RedBlackNode, _BSTNode);

    function RedBlackNode() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        (0, _classCallCheck3.default)(this, RedBlackNode);

        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
        }

        var _this = (0, _possibleConstructorReturn3.default)(this, _BSTNode.call.apply(_BSTNode, [this, data].concat(rest)));

        _this.leftChild = null;
        _this.rightChild = null;
        _this.parent = null;

        _this.color = RED;
        _this.data = data;
        return _this;
    }

    return RedBlackNode;
}(_BinarySortedTree2.default);

var RedBlackLeaf = function RedBlackLeaf() {
    (0, _classCallCheck3.default)(this, RedBlackLeaf);

    this.color = BLACK;
    this.leftChild = this;
    this.rightChild = this;
};

var RedBlackTree = function () {
    function RedBlackTree() {
        (0, _classCallCheck3.default)(this, RedBlackTree);

        // 哨兵
        this.nil = new RedBlackLeaf();
        this.root = this.nil;
    }

    /**
     * 红黑树的递归查找算法
     * @param data
     */


    RedBlackTree.prototype.find = function find(data) {
        var z = this.root;
        var me = this;

        return function find(z, data) {
            if (z == me.nil || data === z.data) return z;

            if (data < z.data) return find(z.leftChild, data);else return find(z.rightChild, data);
        }(z, data);
    };

    /**
     * 红黑树的插入
     * @param {*} data
     */


    RedBlackTree.prototype.add = function add(data) {
        var z = new RedBlackNode(data);
        z.leftChild = this.nil;
        z.rightChild = this.nil;
        var y = this.nil;
        var x = this.root;

        // 找到要插入位置的结点y
        while (x != this.nil) {
            y = x;

            if (z.data < x.data) x = x.leftChild;else x = x.rightChild;
        }

        z.parent = y;

        // 如果y不是根结点，根据大小插入到左或右子树
        if (y != this.nil) {
            if (z.data < y.data) y.leftChild = z;else y.rightChild = z;
        }
        // 否则插入到根结点
        else this.root = z == this.nil ? null : z;

        // 插入修复操作
        this._addFixup(z);
    };

    /**
     * 插入算法修复
     * @param {RedBlackNode} z 待插入的结点
     * @private
     */


    RedBlackTree.prototype._addFixup = function _addFixup(z) {

        while (z != this.root && z.parent.color === RED) {
            if (z.parent == z.parent.parent.leftChild) leftAddFixup(this, z);else rightAddFixup(this, z);
        }

        // 最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡
        this.root.color = BLACK;
    };

    /**
     * 红黑树的删除算法
     * @param {RedBlackNode} z 待删除结点
     */


    RedBlackTree.prototype.removeNode = function removeNode(z) {
        var x = void 0,
            y = void 0;

        // 找到待删除结点的父结点或相邻待替换结点
        if (z.leftChild == this.nil || z.rightChild == this.nil) y = z;else y = this.successor(z);

        if (y.leftChild != this.nil) x = y.leftChild;else x = y.rightChild;

        x.parent = y.parent;

        // 删除操作
        if (y.parent == this.nil) this.root = x;else if (y == y.parent.leftChild) y.parent.leftChild = x;else y.parent.rightChild = x;

        if (y != z) z.data = y.data;

        // 删除修复
        if (y.color === BLACK) this._removeFixup(x);
    };

    // 算法导论上的删除结点


    RedBlackTree.prototype.removeNode2 = function removeNode2(z) {
        var y = z;
        var originalYColor = y.color;
        var x = void 0;

        if (z.leftChild == this.nil) {
            x = z.rightChild;
            this._transplant(z, z.rightChild);
        } else if (z.rightChild == this.nil) {
            x = z.leftChild;
            this._transplant(z, z.leftChild);
        } else {
            y = this.min(z.rightChild);
            originalYColor = y.color;
            x = y.rightChild;

            if (y.parent == z) x.parent = y;else {
                this._transplant(y, y.rightChild);
                y.rightChild = z.rightChild;
                y.rightChild.parent = y;
            }

            this._transplant(z, y);
            y.leftChild = z.leftChild;
            y.leftChild.parent = y;
            y.color = z.color;
        }

        if (originalYColor === BLACK) this._removeFixup(x);
    };

    RedBlackTree.prototype._transplant = function _transplant(u, v) {
        if (u.parent == this.nil) this.root = v;else if (u == u.parent.leftChild) u.parent.leftChild = v;else u.parent.rightChild = v;

        v.parent = u.parent;
    };

    /**
     * 删除修复
     * @param {RedBlackNode} z
     * @private
     */


    RedBlackTree.prototype._removeFixup = function _removeFixup(z) {
        while (z !== this.root && z.color === BLACK) {
            if (z == z.parent.leftChild) leftRemoveFixup(this, z);else rightRemoveFixup(this, z);
        }

        z.color = BLACK;
    };

    RedBlackTree.prototype.successor = function successor(z) {
        if (z.rightChild != this.nil) return this.min(z.rightChild);

        var y = z.parent;

        while (y != this.nil && z == y.rightChild) {
            z = y;
            y = y.parent;
        }

        return y;
    };

    RedBlackTree.prototype.min = function min(z) {
        while (z.leftChild != this.nil) {
            z = z.leftChild;
        }

        return z;
    };

    /**
     * 根据key值删除结点
     * @param {*} key
     * @returns {*}
     */


    RedBlackTree.prototype.remove = function remove(key) {
        var z = this.find(key);

        if (z == this.nil) return false;

        return this.removeNode(z);
    };

    return RedBlackTree;
}();

exports.default = RedBlackTree;


RedBlackTree.prototype._rotateLeft = rotate('left');
RedBlackTree.prototype._rotateRight = rotate('right');

function rotate(dir) {
    var c1 = void 0,
        c2 = void 0;
    if (dir === 'left') {
        c1 = 'rightChild';
        c2 = 'leftChild';
    } else {
        c1 = 'leftChild';
        c2 = 'rightChild';
    }

    return function (x) {
        var y = x[c1];
        x[c1] = y[c2];

        if (y[c2] != this.nil) y[c2].parent = x;
        y.parent = x.parent;

        if (x.parent == this.nil) this.root = y;else if (x == x.parent[c2]) x.parent[c2] = y;else x.parent[c1] = y;

        y[c2] = x;
        x.parent = y;
    };
}

function addFixup(dir) {
    var c1 = void 0,
        c2 = void 0,
        rotate1 = void 0,
        rotate2 = void 0;
    if (dir === 'left') {
        c1 = 'rightChild';
        c2 = 'leftChild';
        rotate1 = '_rotateLeft';
        rotate2 = '_rotateRight';
    } else {
        c1 = 'leftChild';
        c2 = 'rightChild';
        rotate1 = '_rotateRight';
        rotate2 = '_rotateLeft';
    }

    return function (tree, z) {
        // note: 注释以左边为情况

        // 叔结点
        var y = z.parent.parent[c1];

        // 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
        // 将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
        if (y.color === RED) {
            z.parent.color = BLACK;
            y.color = BLACK;
            z.parent.parent.color = RED;
            z = z.parent.parent;
        } else {
            // 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
            // 解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
            // 从而插入修复情况2转换成了插入修复情况3。
            if (z === z.parent[c1]) {
                z = z.parent;
                tree[rotate1](z);
            }

            // 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
            // 解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
            z.parent.color = BLACK;
            z.parent.parent.color = RED;
            tree[rotate2](z.parent.parent);
        }
    };
}

var leftAddFixup = addFixup('left');
var rightAddFixup = addFixup('right');
var leftRemoveFixup = removeFixup('left');
var rightRemoveFixup = removeFixup('right');

function removeFixup(dir) {
    var c1 = void 0,
        c2 = void 0,
        r1 = void 0,
        r2 = void 0;
    if (dir === 'left') {
        c1 = 'rightChild';
        c2 = 'leftChild';
        r1 = '_rotateLeft';
        r2 = '_rotateRight';
    } else {
        c1 = 'leftChild';
        c2 = 'rightChild';
        r1 = '_rotateRight';
        r2 = '_rotateLeft';
    }

    return function (tree, z) {
        // note: 注释以左边为情况

        // 叔结点
        var w = z.parent[c1];

        // 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
        // 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法
        if (w.color === RED) {
            w.color = BLACK;
            z.parent.color = RED;
            tree[r1](z.parent);
            w = z.parent[c1];
        }

        // 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
        // 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。
        if (w[c2].color === BLACK && w[c1].color === BLACK) {
            w.color = RED;
            z = z.parent;
        } else {
            // 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
            // 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。
            if (w[c1].color === BLACK) {
                w[c2].color = BLACK;
                w.color = RED;
                tree[r2](w);
                w = z.parent[c1];
            }

            // 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
            // 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
            w.color = z.parent.color;
            z.parent.color = BLACK;
            w[c1].color = BLACK;
            tree[r1](z.parent);
            z = tree.root;
        }
    };
}

var test = new RedBlackTree();
test.add(13);
test.add(8);
test.add(17);
test.add(1);
test.add(6);
test.add(11);
test.add(15);
test.add(22);
test.add(25);
test.add(27);

test.remove(13);
test.remove(8);
test.remove(17);
test.remove(1);
test.remove(6);
test.remove(11);
test.remove(15);
test.remove(22);
test.remove(25);
test.remove(27);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.secondOptimal = secondOptimal;
exports.createSOSTree = createSOSTree;

var _BinaryTree = __webpack_require__(24);

/**
 * 由有序表sTable[low..high]及其累计权值表weights递归构造次优查找树
 * @param {BinaryTree} tree
 * @param {Array} sTable
 * @param {Array} sWeights
 * @param {Number} low
 * @param {Number} high
 */
function secondOptimal(tree, sTable, sWeights, low, high) {
    var i = low;
    var min = Math.abs(sWeights[high] - sWeights[low]);
    var dw = sWeights[high] + (sWeights[low - 1] || 0);

    // 选择最小的△Pi值
    for (var j = low + 1; j <= high; ++j) {
        var t = Math.abs(dw - sWeights[j] - sWeights[j - 1]);
        if (t < min) {
            i = j;
            min = t;
        }
    }

    // 调整树根权，选择邻近权值较大的关键字
    var a = 0,
        b = void 0,
        c = 0;
    if (i - 1 >= low) b = sWeights[i] - sWeights[i - 1];
    if (i - 2 >= low) a = sWeights[i - 1] - sWeights[i - 2];
    if (i + 1 < high) c = sWeights[i + 1] - sWeights[i];
    if (typeof b === 'number') {
        if (a > c && a > b) --i;else if (a < c && c > b) ++i;
    }

    tree.data = sTable[i];
    //左子树
    if (i === low) tree.leftChild = null;else {
        tree.leftChild = new _BinaryTree.BinaryTree();
        secondOptimal(tree.leftChild, sTable, sWeights, low, i - 1);
    }
    // 右子树
    if (i === high) tree.rightChild = null;else {
        tree.rightChild = new _BinaryTree.BinaryTree();
        secondOptimal(tree.rightChild, sTable, sWeights, i + 1, high);
    }
} /*
   静态次优查找树
  
   适合各记录的查找概率不等的情况
  
   查找效率最高即平均查找长度最小，我们可以给出有序表在非等概率情况下应遵循的两个原则：
   1、最先访问的结点应是访问概率最大的结点；
   2、每次访问应使结点两边尚未访问的结点的被访概率之和尽可能相等。
  
  
   这两个原则可用一句话来表示，即判定树为带权内路径长度之和最小的二叉树，亦即：PH = ∑wihi  最小，其中 n 为有序表长度，hi 为第 i 个结点在判定树上的层次数，wi = cpi，c 为某个常数，pi 为第 i 个结点的查找概率。
  
  
   这样的树称为静态最优查找树（static optimal search tree），构造这样一棵树的时间代价太大，亦即时间复杂度很大，因此我们通常是构造次优查找树（nearly optimal search tree），构造它的时间代价远远低于构造最优查找树，但查找性能只比最优查找树差1%~2%，很少差3%以上。
  
   次优查找树的构造：
  
   设有序表每个记录的权值为 wl,wl+1,…,wh，第一个应访问的结点号为 i ，则有：
   Δpi =   ∑wj - ∑wj   最小，即 Δpi = Min {Δpj }
   再分别对 {rl,rl+1,…,ri-1} 和 {ri+1,ri+2,…,rh} 分别构造次优查找树
   */


var tree = new _BinaryTree.BinaryTree();
secondOptimal(tree, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'], [1, 2, 4, 9, 12, 16, 20, 23, 28], 0, 8);
console.log(tree);

/**
 * 由有序表构造一棵次优查找树
 * @param {Object} obj 有序表，数据元素含有权域weight
 */
function createSOSTree(obj) {
    var tree = void 0;
    if (obj.elems.length === 0) tree = null;else {
        // 求累计权值表
        var sw = findSW(obj.weights);
        tree = new _BinaryTree.BinaryTree();
        secondOptimal(tree, obj.elems, sw, 0, obj.elems.length - 1);
    }

    return tree;
}

function findSW(sTable) {
    var sw = [sTable[0]];

    for (var i = 1; i < sTable.length; ++i) {
        sw[i] = sw[i - 1] + sTable[i];
    }

    return sw;
}

var sosTree = createSOSTree({
    elems: ['A', 'B', 'C', 'D', 'E'],
    weights: [1, 30, 2, 29, 3]
});
sosTree.inOrderRecursive(function (value) {
    console.log('inOrder: ' + value);
});

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
后缀树算是很常见的字符串数据结构之一了，它在模式匹配中的应用非常多，比如DNA序列检测等。

后缀树的基本思路是是对一个字符串的所有后缀子串以Tries的方式进行描述，从而可以迅速地在后缀树上找出字符串的任意子串。

所以对于已经建立了后缀树的字符串，做字符串查找已经算是非常简单的任务了，同时由于Tries的特点，这种结构可以很方便地处理前/后任意字符串匹配（比如“*ABC”和“ABC*”），为了要处理中间的wildcard，比如ABC*DEF，可以分别查找ABC*和*DEF，然后再取交集即可。

后缀树也很适合于多模匹配问题，但它适用的场景主要是待匹配字符串固定，而模式串未定的场景。

一个利用后缀树的典型应用是LCS（Longest Common Substring）最大公共子串问题。采用动态规划也可以很容易地解决LCS问题，但它的时空复杂度均为O(N*M)，对于大多数应用是够了，可是，如果两个字符串是DNA序列，要从中间找出公共子串，O(N*M)的时空复杂度显然是无法接受的。而采用后缀树，复杂度就只是后缀树创建的复杂度，即O(N)

后缀树的应用

1.查找字符串 Pattern 是否在于字符串 Text 中
    方案：用 Text 构造后缀树，按在 Trie 中搜索字串的方法搜索 Pattern 即可。若 Pattern 在 Text 中，则 Pattern 必然是 Text 的某个后缀的前缀。
2.计算指定字符串 Pattern 在字符串 Text 中的出现次数
    方案：用 Text+'$' 构造后缀树，搜索 Pattern 所在节点下的叶节点数目即为重复次数。如果 Pattern 在 Text 中重复了 c 次，则 Text 应有 c 个后缀以 Pattern 为前缀。
3.查找字符串 Text 中的最长重复子串
    方案：用 Text+'$' 构造后缀树，搜索 Pattern 所在节点下的最深的非叶节点。从 root 到该节点所经历过的字符串就是最长重复子串。
4.查找两个字符串 Text1 和 Text2 的最长公共部分
    方案：连接 Text1+'#' + Text2+'$' 形成新的字符串并构造后缀树，找到最深的非叶节点，且该节点的叶节点既有 '#' 也有 '$'。
5.查找给定字符串 Text 里的最长回文
回文指："abcdefgfed" 中对称的字符串 "defgfed"。
回文半径指：回文 "defgfed" 的回文半径 "defg" 长度为 4，半径中心为字母 "g"。
    方案：将 Text 整体反转形成新的字符串 Text2，例如 "abcdefgfed" => "defgfedcba"。连接 Text+'#' + Text2+'$' 形成新的字符串并构造后缀树，然后将问题转变为查找 Text 和 Text1 的最长公共部分。

http://www.cnblogs.com/gaochundong/p/suffix_tree.html
http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%91Java%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/
*/

var Node = function () {
    function Node() {
        (0, _classCallCheck3.default)(this, Node);

        // the index of a node with a matching suffix, representing a suffix link.
        // -1 indicates this node has no suffix link.
        this.suffixNode = -1;
    }

    Node.prototype.toString = function toString() {
        return 'Node(suffix link: ' + this.suffixNode + ')';
    };

    return Node;
}();

var Edge = function () {
    /**
     * Creates an instance of Edge.
     * @param {any} firstCharIndex  index of start of string part represented by this edge
     * @param {any} lastCharIndex index of end of string part represented by this edge
     * @param {any} sourceNodeIndex ndex of source node of edge
     * @param {any} destNodeIndex index of destination node of edge
     * 
     * @memberOf Edge
     */
    function Edge(firstCharIndex, lastCharIndex, sourceNodeIndex, destNodeIndex) {
        (0, _classCallCheck3.default)(this, Edge);

        this.firstCharIndex = firstCharIndex;
        this.lastCharIndex = lastCharIndex;
        this.sourceNodeIndex = sourceNodeIndex;
        this.destNodeIndex = destNodeIndex;
    }

    Edge.prototype.toString = function toString() {
        return 'Edge(' + this.sourceNodeIndex + ', ' + this.destNodeIndex + ', ' + this.firstCharIndex + ', ' + this.lastCharIndex + ')';
    };

    (0, _createClass3.default)(Edge, [{
        key: 'length',
        get: function get() {
            return this.lastCharIndex - this.firstCharIndex;
        }
    }]);
    return Edge;
}();
/**
 * Represents a suffix from first_char_index to last_char_index.
 * 
 * @class Suffix
 */


var Suffix = function () {
    /**
     * Creates an instance of Suffix.
     * @param {any} sourceNodeIndex index of node where this suffix starts
     * @param {any} firstCharIndex index of start of suffix in string
      * @param {any} lastCharIndex index of end of suffix in string
     * 
     * @memberOf Suffix
     */
    function Suffix(sourceNodeIndex, firstCharIndex, lastCharIndex) {
        (0, _classCallCheck3.default)(this, Suffix);

        this.sourceNodeIndex = sourceNodeIndex;
        this.firstCharIndex = firstCharIndex;
        this.lastCharIndex = lastCharIndex;
    }

    (0, _createClass3.default)(Suffix, [{
        key: 'length',
        get: function get() {
            return this.lastCharIndex - this.firstCharIndex;
        }
    }, {
        key: 'explicit',
        get: function get() {
            return this.firstCharIndex > this.lastCharIndex;
        }
    }, {
        key: 'implicit',
        get: function get() {
            return this.lastCharIndex >= this.firstCharIndex;
        }
    }]);
    return Suffix;
}();

/**
 * A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
 * 
 * @class SuffixTree
 */


var SuffixTree = function () {
    function SuffixTree(string, caseInsensitive) {
        (0, _classCallCheck3.default)(this, SuffixTree);

        this.string = string;
        this.caseInsensitive = caseInsensitive;
        this.N = string.length - 1;
        this.nodes = [new Node()];
        this.edges = {};
        this.active = new Suffix(0, 0, -1);

        if (caseInsensitive) {
            this.string = string.toLowerCase();
        }

        for (var i = 0; i < string.length; ++i) {
            this.addPrefix(i);
        }
    }

    /**
     * Lists edges in the suffix tree
     * 
     * @returns 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype.toString = function toString() {
        var currentIndex = this.N;
        var s = '\tStart \tEnd \tSuf \tFirst \tLast \tString\n';
        var values = Object.values(this.edges);
        values.sort(function (a, b) {
            return a.firstCharIndex - b.firstCharIndex;
        });

        for (var _iterator = values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var edge = _ref;

            if (edge.sourceNodeIndex === -1) continue;

            s += '\t' + edge.sourceNodeIndex + ' \t' + edge.destNodeIndex + ' \t' + this.nodes[edge.destNodeIndex].suffixNode + ' \t' + edge.firstCharIndex + ' \t' + edge.lastCharIndex + ' \t';

            var top = Math.min(currentIndex, edge.lastCharIndex);
            s += this.string.substring(edge.firstCharIndex, top + 1) + '\n';
        }

        return s;
    };

    /**
     * The core construction method.
     * 
     * @param {any} lastCharIndex 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype.addPrefix = function addPrefix(lastCharIndex) {
        var lastParentNode = -1;
        var e = null;
        var parentNode = -1;

        while (true) {
            parentNode = this.active.sourceNodeIndex;

            if (this.active.explicit) {
                // prefix is already in tree
                if (this.edges[this.active.sourceNodeIndex + '-' + this.string[lastCharIndex]]) break;
            } else {
                e = this.edges[this.active.sourceNodeIndex + '-' + this.string[this.active.firstCharIndex]];

                // prefix is already in tree
                if (this.string[e.firstCharIndex + this.active.length + 1] === this.string[lastCharIndex]) break;

                parentNode = this._splitEdge(e, this.active);;
            }

            this.nodes.push(new Node());
            e = new Edge(lastCharIndex, this.N, parentNode, this.nodes.length - 1);
            this._insertEdge(e);

            if (lastParentNode > 0) {
                this.nodes[lastParentNode].suffixNode = parentNode;
            }
            lastParentNode = parentNode;

            if (this.active.sourceNodeIndex === 0) {
                this.active.firstCharIndex += 1;
            } else {
                this.active.sourceNodeIndex = this.nodes[this.active.sourceNodeIndex].suffixNode;
            }

            this._canonizeSuffix(this.active);
        }

        if (lastParentNode > 0) {
            this.nodes[lastParentNode].suffixNode = parentNode;
        }

        this.active.lastCharIndex += 1;
        this._canonizeSuffix(this.active);
    };

    SuffixTree.prototype._insertEdge = function _insertEdge(edge) {
        this.edges[edge.sourceNodeIndex + '-' + this.string[edge.firstCharIndex]] = edge;
    };

    SuffixTree.prototype._removeEdge = function _removeEdge(edge) {
        delete this.edges[edge.sourceNodeIndex + '-' + this.string[edge.firstCharIndex]];
    };

    SuffixTree.prototype._splitEdge = function _splitEdge(edge, suffix) {
        this.nodes.push(new Node());
        var e = new Edge(edge.firstCharIndex, edge.firstCharIndex + suffix.length, suffix.sourceNodeIndex, this.nodes.length - 1);

        this._removeEdge(edge);
        this._insertEdge(e);

        // need to add node for each edge
        this.nodes[e.destNodeIndex].suffixNode = suffix.sourceNodeIndex;
        edge.firstCharIndex += suffix.length + 1;
        edge.sourceNodeIndex = e.destNodeIndex;

        this._insertEdge(edge);

        return e.destNodeIndex;
    };

    /**
     * This canonizes the suffix, walking along its suffix string until it 
        is explicit or there are no more matched nodes
     * 
     * @param {any} suffix 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype._canonizeSuffix = function _canonizeSuffix(suffix) {
        if (!suffix.explicit) {
            var e = this.edges[suffix.sourceNodeIndex + '-' + this.string[suffix.firstCharIndex]];
            if (e.length <= suffix.length) {
                suffix.firstCharIndex += e.length + 1;
                suffix.sourceNodeIndex = e.destNodeIndex;
                this._canonizeSuffix(suffix);
            }
        }
    };

    /**
     * Returns the index of substring in string or -1 if it
        is not found.
     * 
     * @param {any} substr 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype.find = function find(substr) {
        if (!substr) return -1;

        if (this.caseInsensitive) substr = substr.toLowerCase();

        var currentNode = 0;
        var i = 0;
        var ln = 0;
        var edge = null;

        while (i < substr.length) {
            edge = this.edges[currentNode + '-' + substr[i]];

            if (!edge) return -1;

            ln = Math.min(edge.length + 1, substr.length - i);

            if (substr.substring(i, i + ln) !== this.string.substring(edge.firstCharIndex, edge.firstCharIndex + ln)) return -1;

            i += edge.length + 1;
            currentNode = edge.destNodeIndex;
        }

        return edge.firstCharIndex - substr.length + ln;
    };

    return SuffixTree;
}();

exports.default = SuffixTree;


var str = 'I need to be searched';
var tree = new SuffixTree(str);
console.log(tree.find('sear'));
console.log(tree + '');

var tree2 = new SuffixTree('mississippi');
console.log(tree2 + '');
console.log(tree2.find('pp'));

var tree3 = new SuffixTree('abcabxabcd');
console.log(tree3 + '');

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = fibonacciSearch;
/*
 Fibonacci查找

 Fibonacci查找方法是根据Fibonacci数列的特点对查找表进行分割。Fibonacci数列的定义是：
 F(0)=0，F(1)=1，F(j)=F(j-1)+F(j-2) 。

 1  查找思想
 设查找表中的记录数比某个Fibonacci数小1，即设n=F(j)-1。用Low、High和Mid表示待查找区间的下界、上界和分割位置，初值为Low=0，High=n - 1。
 ⑴   取分割位置Mid：Mid=F(j-1) ；
 ⑵   比较分割位置记录的关键字与给定的K值：
 ① 相等： 查找成功；
 ②  大于：待查记录在区间的前半段(区间长度为F(j-1)-1)，修改上界指针： High=Mid-1，转⑴ ；
 ③  小于：待查记录在区间的后半段(区间长度为F(j-2)-1)，修改下界指针：Low=Mid+1，转⑴ ；直到越界(Low>High)，查找失败。

 2  算法实现
 在算法实现时，为了避免频繁计算Fibonacci数，可用两个变量f1和f2保存当前相邻的两个Fibonacci数，这样在以后的计算中可以依次递推计算出。

 3  算法分析
 由算法知，Fibonacci查找在最坏情况下性能比折半查找差，但平均搜索次数少于折半查找，而且折半查找要求记录按关键字有序；Fibonacci查找的优点是分割时只需进行加、减运算。

 */

function fib(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    var f = void 0;
    var f0 = 0;
    var f1 = 1;
    for (var i = 2; i <= n; ++i) {
        f = f0 + f1;
        f0 = f1;
        f1 = f;
    }
    return f;
}

/**
 * 在有序表ST中用Fibonacci方法查找关键字为key的记录
 * @param sTable
 * @param key
 * @param n
 */
function fibonacciSearch(sTable, key) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sTable.length;

    var low = 0;
    var high = n - 1;
    var f1 = fib(n);
    var f2 = fib(n - 1);

    while (low <= high) {
        var mid = low + f1 - 1;
        if (sTable[mid] === key) return mid;else if (key < sTable[mid]) {
            high = mid - 1;
            f2 = f1 - f2;
            f1 = f1 - f2;
        } else {
            low = mid + 1;
            f1 = f1 - f2;
            f2 = f2 - f1;
        }
    }
    return -1;
}

console.log('fibonacciSearch: ');
console.log(fibonacciSearch([1, 2, 3, 4, 5], 5)); // 4
console.log(fibonacciSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sequentialSearch;
/*
 静态查找

 线性表是查找表最简单的一种组织方式

 顺序查找(Sequential Search)
 1  查找思想
 从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。

 2  算法分析
 不失一般性，设查找每个记录成功的概率相等，即Pi=1/n；查找第i个元素成功的比较次数Ci=n-i；
 ◆ 查找成功时的平均查找长度ASL：(n+1)/2
 ◆ 包含查找不成功时：查找失败的比较次数为n，若成功与不成功的概率相等，对每个记录的查找概率为Pi=1/(2n)，则平均查找长度ASL：3（n+1）/4
 */

function sequentialSearch(sTable, key) {
  for (var i = sTable.length - 1; i >= 0 && sTable[i] !== key; --i) {}
  return i;
}

console.log(sequentialSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.countSort = countSort;
exports.radixSort = radixSort;

var _index = __webpack_require__(75);

/*
 计数排序

 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。

 计数排序的特征

 当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
 通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：
 1.找出待排序的数组中最大和最小的元素
 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项
 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
 
 简要分析：
 1.计数排序仅适合于小范围的数据进行排序
 2.不能对浮点数进行排序
 3.时间复杂度为 O(n)
 4.计数排序是稳定的（排序后值相同的元素相对于原先的位置是不会发生变化的）
 */

function maxElem(arr) {
    var max = arr[0];

    for (var i = 1, len = arr.length; i < len; ++i) {
        if (max < arr[i]) max = arr[i];
    }return max;
}

/**
 *
 * @param {Array} sqList 要排序的数组
 * @param {Number} k 数组中最大的元素值
 * @returns {Array}
 */
/**
 * Created by ldp on 2015/2/18.
 */

function countSort() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : maxElem(sqList);

    var len = sqList.length;
    var c = [];
    var b = [];

    // 初始化辅助数组
    for (var i = 0; i <= k; ++i) {
        c[i] = 0;
    } // 计数数组A中值等于C数组下标的个数
    for (var _i = 0; _i < len; ++_i) {
        c[sqList[_i]]++;
    } // 计数数组A中值小于等于C数组下标的个数
    for (var _i2 = 1; _i2 <= k; ++_i2) {
        c[_i2] += c[_i2 - 1];
    }for (var _i3 = len - 1; _i3 >= 0; --_i3) {
        b[c[sqList[_i3]] - 1] = sqList[_i3];
        --c[sqList[_i3]];
    }

    for (var _i4 = 0; _i4 < len; ++_i4) {
        sqList[_i4] = b[_i4];
    }
}

var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
countSort(arr, 100);
console.log(arr + '');

/*
 基数排序

 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。
 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

 效率

 基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，k的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。
 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k = logB(N)，N是待排序数据类型全集的势。虽然有B个不同的数字，需要B个不同的桶，但在每一轮处理中，判断每个待排序数据项只需要一次计算确定对应数位的值，因此在每一轮处理的时候都需要平均n次操作来把整数放到合适的桶中去，所以就有：
 k约等于logB(N)
 所以，基数排序的平均时间T就是：
 T～= logB(N)·n
 其中前一项是一个与输入数据无关的常数，当然该项不一定小于logn
 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且在适当选择的B之下，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。

 假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。

 基数排序的简单描述就是将数字拆分为个位十位百位，每个位依次排序。因为这对算法稳定要求高，所以我们对数位排序用到上一个排序方法计数排序。因为基数排序要经过d (数据长度)次排序， 每次使用计数排序， 计数排序的复杂度为 On),  d 相当于常量和N无关，所以基数排序也是 O(n)。基数排序虽然是线性复杂度， 即对n个数字处理了n次，但是每一次代价都比较高， 而且使用计数排序的基数排序不能进行原地排序，需要更多的内存， 并且快速排序可能更好地利用硬件的缓存， 所以比较起来，像快速排序这些原地排序算法更可取。对于一个位数有限的十进制数，我们可以把它看作一个多元组，从高位到低位关键字重要程度依次递减。可以使用基数排序对一些位数有限的十进制数排序。
 */

// 求数据的最大位数
function maxBit(arr) {
    var d = 1;
    var p = 10;

    for (var i = 0, n = arr.length; i < n; ++i) {
        while (arr[i] >= p) {
            p *= 10;
            ++d;
        }
    }

    return d;
}

function radixSort() {
    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : maxBit(arr);

    var n = arr.length;
    var temp = [];
    // 计数器
    var count = [];
    var radix = 1;

    // 进行d次排序
    for (var i = 1; i <= d; ++i) {
        // 每次分配前清空计数器
        for (var j = 0; j < 10; ++j) {
            count[j] = 0;
        } // 统计每个桶中的记录数
        for (var _j = 0; _j < n; ++_j) {
            var k = Math.floor(arr[_j] / radix) % 10;
            ++count[k];
        }
        for (var _j2 = 1; _j2 < 10; ++_j2) {
            count[_j2] += count[_j2 - 1];
        } // 将所有桶中记录依次收集到tmp中
        for (var _j3 = n - 1; _j3 >= 0; --_j3) {
            var _k = Math.floor(arr[_j3] / radix) % 10;
            temp[--count[_k]] = arr[_j3];
        }
        //将临时数组的内容复制到arr中
        for (var _j4 = 0; _j4 < n; ++_j4) {
            arr[_j4] = temp[_j4];
        }radix *= 10;
    }
}

var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
radixSort(arr, 100);
console.log(arr + '');

/*
 桶排序

 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。

 基本思想

 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。

 分析

 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
 对N个关键字进行桶排序的时间复杂度分为两个部分：
     (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
     (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。
 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
     (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
     (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。

 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
 O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。

 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
 */

var BUCKETSNUM = 10;

function bucketSort(sqList) {
    var n = sqList.length;
    var bucketA = [];
    var b = [];

    // 初始化桶
    for (var i = 0; i < BUCKETSNUM; ++i) {
        b[i] = [];
        bucketA[i] = 0;

        for (var j = 0; j < n; ++j) {
            b[i][j] = Infinity;
        }
    }

    // 给桶填装数据
    for (var _i5 = 0; _i5 < n; ++_i5) {
        var data = sqList[_i5];
        // noto: 这里的映射函数是针对1-100之间的实数
        var bucket = Math.floor(data / BUCKETSNUM);
        b[bucket][bucketA[bucket]] = data;
        ++bucketA[bucket];
    }

    // 针对每个桶进行快速排序
    for (var _i6 = 0; _i6 < BUCKETSNUM; ++_i6) {
        if (bucketA[_i6] !== 0) {
            (0, _index.quickSort)(b[_i6], 0, bucketA[_i6] - 1);
            //for(let j = 1; j < bucketA[i]; ++j){
            //    let p = b[i][j];
            //    let k;
            //    for(k = j - 1; k >= 0 && p < b[i][k]; --k){
            //        b[i][k + 1] = b[i][k];
            //    }
            //    b[i][k + 1] = p;
            //}
        }
    }

    //console.log(b);
    //console.log(bucketA);

    // 复制回去
    var num = 0;
    for (var _i7 = 0; _i7 < BUCKETSNUM; ++_i7) {
        if (bucketA[_i7] !== 0) {
            for (var _j5 = 0; _j5 < bucketA[_i7]; ++_j5) {
                sqList[num++] = b[_i7][_j5];
            }
        }
    }
}
exports.bucketSort = bucketSort;

var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95];
bucketSort(arr);
console.log(arr + '');

var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95, Infinity, Infinity, Infinity];
(0, _index.quickSort)(arr);
console.log(arr + '');

/*
 性能分析
 很明显，基数排序的性能比桶排序要略差。每一次关键字的桶分配都需要O(N)的时间复杂度，而且分配之后得到新的关键字序列又需要O(N)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2N) ，当然d要远远小于N，因此基本上还是线性级别的。基数排序的空间复杂度为O(N+M)，其中M为桶的数量。一般来说N>>M，因此额外空间需要大概N个左右。
 但是，对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，基数排序的应用范围更加广泛。
 */

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.straightInsertSort = straightInsertSort;
exports.binaryInsertSort = binaryInsertSort;
exports.path2InsertSort = path2InsertSort;
exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
exports.shellSort = shellSort;

var _StaticLinkedList = __webpack_require__(73);

var _StaticLinkedList2 = _interopRequireDefault(_StaticLinkedList);

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 插入排序

 采用的是以 “玩桥牌者”的方法为基础的。即在考察记录Ri之前，设以前的所有记录R1, R2 ,…., Ri-1已排好序，然后将Ri插入到已排好序的诸记录的适当位置

 最基本的插入排序是直接插入排序(Straight Insertion Sort) 。


 直接插入排序

 1  排序思想
 将待排序的记录Ri，插入到已排好序的记录表R1, R2 ,…., Ri-1中，得到一个新的、记录数增加1的有序表。 直到所有的记录都插入完为止。
 设待排序的记录顺序存放在数组R[1…n]中，在排序的某一时刻，将记录序列分成两部分：
 ◆ R[1…i-1]：已排好序的有序部分；
 ◆ R[i…n]：未排好序的无序部分。
 显然，在刚开始排序时，R[1]是已经排好序的。

 2.算法实现

 3.算法分析
 ⑴ 最好情况：若待排序记录按关键字从小到大排列(正序)，算法中的内循环无须执行，则一趟排序时：关键字比较次数1次，记录移动次数2次(R[i]→R[0], R[0]→R[j+1])。
 则整个排序的关键字比较次数和记录移动次数分别是：
 比较次数：n - 1          移动次数： 2 * (n - 1)

 ⑵ 最坏情况：若待排序记录按关键字从大到小排列(逆序)，则一趟排序时：算法中的内循环体执行i-1，关键字比较次数i次，记录移动次数i+1。
 则就整个排序而言：
 比较次数： (n - 1) * (n + 1) / 2     移动次数: (n - 1) * (n + 4) / 2

 一般地，认为待排序的记录可能出现的各种排列的概率相同，则取以上两种情况的平均值，作为排序的关键字比较次数和记录移动次数，约为n2/4，则复杂度为O(n2) 。


 */

/**
 * Created by Luke on 2015/2/2.
 */

function straightInsertSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 1, len = sqList.length; i < len; ++i) {
        // 设置哨兵, 当设置sqList[-1] = sqList[i]时，经测试效率更慢
        // 因为js里面的变量作用域在函数内的
        var temp = sqList[i];
        // 查找插入位置，并将记录后移
        var j = i - 1;
        for (; j >= 0 && comp(temp, sqList[j]) < 0; --j) {
            sqList[j + 1] = sqList[j];
        } // 插入到正确位置
        sqList[j + 1] = temp;
    }
}

var a = [7, 4, -2, 19, 13, 6];
straightInsertSort(a);
console.log(a + '');

/*
 其它插入排序

 1  折半插入排序
 当将待排序的记录R[i] 插入到已排好序的记录子表R[1…i-1]中时，由于R1, R2 ,…, Ri-1已排好序，则查找插入位置可以用“折半查找”实现，则直接插入排序就变成为折半插入排序。

 从时间上比较，折半插入排序仅仅减少了关键字的比较次数，却没有减少记录的移动次数，故时间复杂度仍然为O(n2) 。


 */

function binaryInsertSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 1, len = sqList.length; i < len; ++i) {
        var temp = sqList[i];
        var low = 0;
        var high = i - 1;

        while (low <= high) {
            var mid = low + high >> 1;

            if (comp(temp, sqList[mid]) < 0) high = mid - 1;else low = mid + 1;
        }

        for (var j = i - 1; j >= high + 1; --j) {
            sqList[j + 1] = sqList[j];
        }

        sqList[high + 1] = temp;
    }
}

var b = [30, 13, 70, 85, 39, 42, 6, 20];
binaryInsertSort(b);
console.log(b + '');

/*
 2-路插入排序

 是对折半插入排序的改进，以减少排序过程中移动记录的次数。附加n个记录的辅助空间，方法是：
 ①  另设一个数组d，L[1]赋给d[1]，将d[1]看成是排好序的序列中中间位置的记录；
 ②  分别将L[ ]中的第i个记录依次插入到d[1]之前或之后的有序序列中，具体方法：
 ◆  L[i].key<d[1].key： L[i]插入到d[1]之前的有序表中；
 ◆ L[i].key≥d[1].key： L[i]插入到d[1]之后的有序表中；
 关键点：实现时将向量d看成是循环向量，并设两个指针first和final分别指示排序过程中得到的有序序列中的第一个和最后一个记录。

 在2-路插入排序中，移动记录的次数约为n2/8 。但当L[1]是待排序记录中关键字最大或最小的记录时，2-路插入排序就完全失去了优越性。
 */

function path2InsertSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var d = [sqList[0]];
    // first、final分别指示d中排好序的记录的第1个和最后1个记录的位置。
    var first = 0;
    var final = 0;
    var len = sqList.length;

    for (var i = 1; i < len; ++i) {
        var item = sqList[i];

        // 待插入记录小于d中最小值，插入到d[first]之前（不需移动d数组的元素）。
        if (comp(item, d[first]) < 0) {
            first = (first - 1) % len;
            d[first] = item;
        }
        // 待插入记录大于d中最小值，插入到d[final]之后（不需移动d数组的元素）。
        else if (comp(item, d[final]) > 0) {
                d[++final] = item;
            }
            // 待插入记录大于d中最小值，小于d中最大值，插入到d的中间（需要移动d数组的元素）。
            else {
                    // 移动d尾部元素以便按序插入记录。
                    var j = final++;
                    while (comp(item, d[j]) < 0) {
                        d[(j + 1) % len] = d[j];
                        j = (j - 1) % len;
                    }
                    d[(j + 1) % len] = item;
                }
    }

    // 循环把d赋给sqList
    for (var _i = 0; _i < len; ++_i) {
        sqList[_i] = d[(_i + first) % len];
    }
}

var c = [49, 38, 65, 13, 97, 27, 76, 5, 100, 78, 15, 15, 20];
path2InsertSort(c);
console.log(c + '');

/*
表插入排序

前面的插入排序不可避免地要移动记录，若不移动记录就需要改变数据结构。
初始化：下标值为0的分量作为表头结点，关键字取为最大值，各分量的指针值为空；
①  将静态链表中数组下标值为1的分量(结点)与表头结点构成一个循环链表；
② i=2 ，将分量R[i]按关键字递减插入到循环链表；
③  增加i ，重复②，直到全部分量插入到循环链表。

和直接插入排序相比，不同的是修改2n次指针值以代替移动记录，而关键字的比较次数相同，故时间复杂度为O(n2)。

表插入排序得到一个有序链表，对其可以方便地进行顺序查找，但不能实现随机查找。为了能实现有序表的折半查找根据需要，可以对记录进行重排.

重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。

例子中，链表中第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记录应移至数组的第一个分量，则将list[1]和list[6]互换，并为了不中断静态链表中的链，即在继续顺链表扫描时仍能找到互换之前在list[1]中的结点，令互换之后的list[1]中的游标改为6

推广至一般情况，若第i个最小关键字的结点是数组中下标为p且p > i的分量，则互换list[i]和list[p]，且令list[i]中的游标改为p；
由于此时数组中所有小于i的分量中已是到位记录，则当p<i时，应顺链继续查找直到p>=i为止。
 */

// 表插入排序
function staticLinkedListInsertSort(sllist) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    // 构成循环链表
    sllist[0].cur = 1;
    sllist[1].cur = 0;

    var p = void 0,
        q = void 0;
    for (var i = 2, len = sllist.length; i <= len; ++i) {
        p = 0;
        var x = sllist[i].data;

        while (sllist[p].cur && comp(sllist[sllist[p].cur].data, x) < 0) {
            p = sllist[p].cur;
        } // 当遇到大于当前关键字的下标时，插入到其前驱和后继的中间
        q = sllist[p].cur;
        sllist[p].cur = i;
        sllist[i].cur = q;
    }
}
exports.staticLinkedListInsertSort = staticLinkedListInsertSort;

// 重排静态链表，静态链表下标已排好序
function arrange(sllist) {
    var p = sllist[0].cur;

    for (var i = 1, len = sllist.length; i < len; ++i) {
        // 第i个记录在list中的当前位置应不小于i
        // 找到第i个记录，并用p指示其在list中当前位置
        while (p < i) {
            p = sllist[p].cur;
        } // q指向尚未调整的表尾
        var q = sllist[p].cur;

        if (p !== i) {
            // 交换记录，使第i个记录到位
            var temp = sllist[p];
            sllist[p] = sllist[i];
            sllist[i] = temp;
            // 指向被移走的记录，使得以后可有while循环找到
            sllist[i].cur = p;
        }

        // p指向尚未调整的表尾
        p = q;
    }
}

var arr = [49, 38, 65, 97, 76, 13, 27, 52];
var d = new _StaticLinkedList2.default();
d.create(arr);
staticLinkedListInsertSort(d);
console.log(d);
arrange(d);
console.log(d);

/*
希尔排序

希尔排序(Shell Sort，又称缩小增量法)是一种分组插入排序方法。

1  排序思想
①   先取一个正整数d1(d1<n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；
②   取新的增量d2<d1，重复①的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。

2  排序示例
设有10个待排序的记录，关键字分别为9, 13, 8, 2, 5, 13, 7, 1, 15, 11，增量序列是5, 3, 1，希尔排序的过程:
初始关键字序列:    9     13     8      2      5      13      7      1      15      11
第一趟排序后:      9     7      1      2      5      13      13     8      15      11
第二趟排序后:      2     5      1      9      7      13      11     8      15      13
第三趟排序后:      1     2      5      7      8      9      11     13      13      15


希尔排序的分析比较复杂，涉及一些数学上的问题，其时间是所取的“增量”序列的函数。

希尔排序特点
子序列的构成不是简单的“逐段分割”，而是将相隔某个增量的记录组成一个子序列。
希尔排序可提高排序速度，原因是：
◆ 分组后n值减小，n²更小，而T(n)=O(n²),所以T(n)从总体上看是减小了；
◆ 关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序。

增量序列取法
◆ 无除1以外的公因子；
◆ 最后一个增量值必须为1。

相关资料： http://wenku.baidu.com/link?url=q7kzOxXqc0BLaGUVDY43FQOh2aX1UqBHkkYd3VMwJhJo6rv4SiU686RW3kQCSqGEKytl12S8fBOpwhq-runhX_pbZcg6BeD-miYMPgDhXxK
 */

function shellInsert(sqList, dk, comp) {
    for (var i = dk, len = sqList.length; i < len; ++i) {
        var temp = sqList[i];
        if (comp(temp, sqList[i - dk]) < 0) {
            var j = i - dk;
            for (; j >= 0 && comp(temp, sqList[j]) < 0; j -= dk) {
                sqList[j + dk] = sqList[j];
            }sqList[j + dk] = temp;
        }
    }
}

function shellSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var delta = createDelta(sqList.length);
    //console.log(delta);
    for (var k = 0, t = delta.length; k < t; ++k) {
        shellInsert(sqList, delta[k], comp);
    }
}

function createDelta(n) {
    var arr = [];
    var t = Math.log(n - 1) / Math.log(2) | 0; // Math.log(n - 1) / Math.log(2), Math.log(n + 1) / Math.log(2)
    for (var k = 0; k <= t; ++k) {
        arr[k] = Math.pow(2, t - k) + 1;
    } // Math.pow(2, t - i + 1) - 1, Math.pow(2, t - i) + 1

    arr[arr.length] = 1;

    return arr;
}

console.log('\n\nShell Sort:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
shellSort(arr);
console.log(arr + '');

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.linkedListNaturalMergeSort = exports.naturalMergeSort = undefined;
exports.mergeSortRecursive = mergeSortRecursive;
exports.mergeSortNonRecursive = mergeSortNonRecursive;
exports.natureMergeSort = natureMergeSort;

var _LinkedList = __webpack_require__(80);

var _LinkedList2 = _interopRequireDefault(_LinkedList);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 归并排序

 归并(Merging) ：是指将两个或两个以上的有序序列合并成一个有序序列。若采用线性表(无论是那种存储结构)易于实现，其时间复杂度为O(m+n) 。
 归并思想实例：两堆扑克牌，都已从小到大排好序，要将两堆合并为一堆且要求从小到大排序。
 ◆  将两堆最上面的抽出(设为C1，C2)比较大小，将小者置于一边作为新的一堆(不妨设C1<C2)；再从第一堆中抽出一张继续与C2进行比较，将较小的放置在新堆的最下面；
 ◆ 重复上述过程，直到某一堆已抽完，然后将剩下一堆中的所有牌转移到新堆中。

 1   排序思想
 ①  初始时，将每个记录看成一个单独的有序序列，则n个待排序记录就是n个长度为1的有序子序列；
 ②  对所有有序子序列进行两两归并，得到n/2个长度为2或1的有序子序列——一趟归并；
 ③  重复② ，直到得到长度为n的有序序列为止。

 上述排序过程中，子序列总是两两归并，称为2-路归并排序。其核心是如何将相邻的两个子序列归并成一个子序列。设相邻的两个子序列分别为：
 {R[k], R[k+1], …, R[m]}和{R[m+1], R[m+2],…, R[h]}，将它们归并为一个有序的子序列：
 {DR[l], DR[l+1], …, DR[m], DR[m+1], …, DR[h] }

 例：设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41，归并排序的过程。
 初始关键字: [23]   [38]   [22]   [45]   [23]   [67]   [31]   [15]   [41]
              |      |      |      |      |      |      |      |
              --------      --------      --------      --------
 一趟归并后: [23    38]    [22     45]    [23     67]    [15     31]   [41]
                 |              |             |              |
                 ---------------               ---------------
 二趟归并后: [22     23      38     45]    [15     23     31     67]    [41]
                        |                              |
                        --------------------------------
 三趟归并后: [15     22      23     23     31     38     45     67]    [41]
                                       |                                |
                                       ----------------------------------
 四趟归并后: [15     22      23     23     31     38     41     45     67


 2  一趟归并排序
 一趟归并排序都是从前到后，依次将相邻的两个有序子序列归并为一个，且除最后一个子序列外，其余每个子序列的长度都相同。设这些子序列的长度为d，则一趟归并排序的过程是：
 从j=0开始，依次将相邻的两个有序子序列
 R[j…j+d-1]和R[j+d…j+2d-1]进行归并；每次归并两个子序列后，j后移动2d个位置，即
 j=j+2d；若剩下的元素不足两个子序列时，分以下两种情况处理：
 ①  剩下的元素个数>d：再调用一次上述过程，将一个长度为d的子序列和不足d的子序列进行归并；
 ②  剩下的元素个数≤d：将剩下的元素依次复制到归并后的序列中。


 3.算法分析
具有n个待排序记录的归并次数是㏒2n，而一趟归并的时间复杂度为O(n)，则整个归并排序的时间复杂度无论是最好还是最坏情况均为O(n㏒2n)。在排序过程中，使用了辅助向量DR，大小与待排序记录空间相同，则空间复杂度为O(n)。归并排序是稳定的。

 */

var nCount = 0; /**
                 * Created by ldp on 2015/2/7.
                 */

var nonRecursiveCount = 0;
var recursiveCount = 0;

/**
 * 将有序的sr[s1..e1]和sr[s2..e2]归并为有序的tr[s1..e2]
 * @param sr
 * @param s1
 * @param e1
 * @param e2
 */
function merge(sr, s1, e1, e2) {
    var comp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _defaultComparision2.default;

    var temp = [];
    var i = s1;
    var j = e1 + 1;
    var k = 0;

    while (i <= e1 && j <= e2) {
        if (comp(sr[i], sr[j]) < 0) temp[k++] = sr[i++];else temp[k++] = sr[j++];
    }
    while (i <= e1) {
        temp[k++] = sr[i++];
    }while (j <= e2) {
        temp[k++] = sr[j++];
    } // 复制回去
    for (i = s1, k = 0; i <= e2; ++i, ++k) {
        sr[i] = temp[k];
    }
}

/**
 * 2-路归并排序递归算法
 * @param {Array} sr
 * @param {Number} s
 * @param {Number} t
 */
function mergeSortRecursive(sr) {
    var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sr.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    if (s >= t) return;

    // 将sr[s..t]平分为sr[s..m]和sr[m+1..t]
    var m = s + t >> 1;
    // 递归地将sr[s..m]归并为有序的sr[s..m]
    mergeSortRecursive(sr, s, m, comp);
    // 递归地将sr[m+1..t]归并为有序的sr[m+1..t]
    mergeSortRecursive(sr, m + 1, t, comp);
    // 将sr[s..m]和sr[m+1..t]归并到sr[s..t];
    merge(sr, s, m, t, comp);
}

console.log('\n\nmergeSortRecursive:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
mergeSortRecursive(arr);
console.log(arr + '');

function mergeSortNonRecursive(sr) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var j = void 0,
        k = void 0;
    for (var d = 1, n = sr.length - 1; d < n; d *= 2) {
        // 一趟归并排序算法
        j = 0;

        // 子序列两两归并
        while ((k = j + 2 * d - 1) < n) {
            merge(sr, j, j + d - 1, k, comp);
            j = k + 1;
        }

        // 剩余元素个数超过一个子序列长度
        if (j + d - 1 < n) merge(sr, j, j + d - 1, n, comp);
        // 剩余子序列复制
        else merge(sr, j, n, n, comp);
    }
}

console.log('\nmergeSortNonRecursive:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
mergeSortNonRecursive(arr);
console.log(arr + '');

// 自然合并排序
// http://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html
// http://www.cnblogs.com/lanke/archive/2013/01/15/2860487.html
/*
自然归并是归并排序的一个变形，效率更高一些，可以在归并排序非递归实现的基础上进行修改.对于已经一个已经给定数组a,通常存在多个长度大于1的已经自然排好的子数组段,因此用一次对数组a的线性扫描就可以找出所有这些排好序的子数组段,然后再对这些子数组段俩俩合并.
 */

// 扫描得到子串的函数
function pass(sqList, rec, comp) {
    var num = 0;
    rec[num++] = 0;
    var len = sqList.length;

    for (var i = 1; i < len; ++i) {
        if (comp(sqList[i], sqList[i + 1]) > 0) rec[num++] = i + 1;
    }
    rec[num++] = len;

    return num;
}

function natureMergeSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var rec = [];

    //num=2说明已经排好序了
    //每循环一次，进行一次pass()操作
    for (var num = pass(sqList, rec, comp); num !== 2; num = pass(sqList, rec, comp)) {
        for (var i = 0; i + 2 < num; i += 2) {
            merge(sqList, rec[i], rec[i + 1] - 1, rec[i + 2] - 1, comp);
        }
    }
}

console.log('\nnatureMergeSort:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
natureMergeSort(arr);
console.log(arr + '');

console.log(recursiveCount);
console.log(nonRecursiveCount);
console.log(nCount);

// 双向自然合并排序算法
/*
双向自然合并排序是根据欲排序数据局部不是升序就是降序的自然有序特点,先线性扫描出自然有序的子数组段,再进行合并排序.扫描时的有序数段长度越长,段数越少,对应合并树的层数就会越少,算法的效率越高.
 */
var naturalMergeSort = exports.naturalMergeSort = function () {
    return naturalMergeSort;

    function naturalMergeSort(a) {
        var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

        var b = [];
        var n = a.length;
        while (!mergeRuns(a, b, n, comp)) {}
    }

    function mergeRuns(a, b, n, comp) {
        var i = 0;
        var k = 0;
        var asc = true;
        var x = void 0;

        while (i < n) {
            k = i;
            // 找到最后一个递增序列元素
            do {
                x = a[i++];
            } while (i < n && comp(x, a[i]) <= 0);
            // 找到最后一个递减序列元素
            while (i < n && comp(x, a[i]) >= 0) {
                x = a[i++];
            } // 归并递增序列和递减序列，结果可能递增或递减
            merge(a, b, k, i - 1, asc, comp);
            asc = !asc;
        }

        // 当k等于0时代表a已经排好序了
        return k === 0;
    }

    function merge(a, b, low, high, asc, comp) {
        var k = asc ? low : high;
        var c = asc ? 1 : -1;
        var i = low;
        var j = high;

        while (i <= j) {
            if (comp(a[i], a[j]) <= 0) b[k] = a[i++];else b[k] = a[j--];
            k += c;
        }
        for (i = k = low, j = high; i <= j; ++i, ++k) {
            a[i] = b[k];
        }
    }
}();

console.log('\nnaturalMergeSort:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
naturalMergeSort(arr);
console.log(arr + '');

// 链表存储结构的自然合并排序
var linkedListNaturalMergeSort = exports.linkedListNaturalMergeSort = function () {
    return mergeSort;

    function mergeSort(linkedlist) {
        var needReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var comp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _defaultComparision2.default;

        if (!linkedlist) return linkedlist;

        var queue = new _Queue2.default();
        var list = linkedlist.head;

        if (!list || !list.next) return linkedlist;

        var u = list;
        var t = list;
        var v = void 0;
        // 将递增的结点放入到队列中（会被切断）
        for (; t; t = u) {
            while (u && u.next && comp(u.data, u.next.data) <= 0) {
                u = u.next;
            }v = u;
            u = u.next;
            v.next = null;
            queue.enQueue(t);
        }

        t = queue.deQueue();
        // 合并结点
        while (queue.size) {
            queue.enQueue(t);
            var a = queue.deQueue();
            var b = queue.deQueue();
            t = merge(a, b, comp);
        }

        if (needReplace) linkedlist.head = t;

        return t;
    }

    function merge(a, b, comp) {
        var c = new _LinkedList2.default();
        var head = { data: null, next: null };
        c.head = head;
        c = c.head;

        while (a && b) {
            if (comp(a.data, b.data) < 0) {
                c.next = a;
                c = a;
                a = a.next;
            } else {
                c.next = b;
                c = b;
                b = b.next;
            }
        }

        c.next = a ? a : b;

        return head.next;
    }
}();

var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
var linkedList = new _LinkedList2.default(arr);
linkedListNaturalMergeSort(linkedList);
console.log(linkedList + '');

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.simpleSelectionSort = simpleSelectionSort;
exports.heapSort = heapSort;

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
选择排序

选择排序(Selection Sort)的基本思想是：每次从当前待排序的记录中选取关键字最小的记录表，然后与待排序的记录序列中的第一个记录进行交换，直到整个记录序列有序为止。


简单选择排序

简单选择排序(Simple Selection Sort ，又称为直接选择排序)的基本操作是：通过n-i次关键字间的比较，从n-i+1个记录中选取关键字最小的记录，然后和第i个记录进行交换，i=1, 2, … n-1 。
1  排序示例
例：设有关键字序列为：7, 4, -2, 19, 13, 6，直接选择排序的过程：
初始记录的关键字：  7     4    -2     19    13    6
    第一趟排序：  -2     4     7     19    13    6
    第二趟排序：  -2     4     7     19    13    6
    第三趟排序：  -2     4     6     19    13    7
    第四趟排序：  -2     4     6     7     13    19
    第五趟排序：  -2     4     6     7     13    19
    第六趟排序：  -2     4     6     7     13    19

2.算法分析
整个算法是二重循环：外循环控制排序的趟数，对n个记录进行排序的趟数为n-1趟；内循环控制每一趟的排序。
进行第i趟排序时，关键字的比较次数为n-i，则：
比较次数： n*(n - 1) / 2
时间复杂度是：T(n)=O(n2)
空间复杂度是：S(n)=O(1)
从排序的稳定性来看，直接选择排序是不稳定的。

 */

function simpleSelectionSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 0, len = sqList.length; i < len; ++i) {
        var k = i;
        for (var j = k + 1; j < len; ++j) {
            if (comp(sqList[j], sqList[k]) < 0) k = j;
        }if (k !== i) {
            var temp = sqList[k];
            sqList[k] = sqList[i];
            sqList[i] = temp;
        }
    }
} /**
   * Created by luke on 2015/2/2.
   */

var arr = [7, 4, -2, 19, 13, 6];
simpleSelectionSort(arr);
console.log(arr + '');

/*
树形选择排序

首先对n个记录的关键字两两进行比较，选取n/2个较小者；然后这n/2个较小者两两进行比较，选取n/4个较小者… 如此重复，直到只剩1个关键字为止。
该过程可用一棵有n个叶子结点的完全二叉树表示，每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点的关键字就是最小的关键字。
输出最小关键字后，根据关系的可传递性，欲选取次小关键字，只需将叶子结点中的最小关键字改为“最大值” ，然后重复上述步骤即可。
含有n个叶子结点的完全二叉树的深度为㏒2n+1，则总的时间复杂度为O(n㏒2n) 。

但这种排序方法尚有辅助存储空间较多,和最大值进行多余比较等缺点。为了弥补这些缺陷，出现了另一种选择排序---堆排序
 */

/*
堆排序

1  堆的定义
是n个元素的序列H={k1, k2 , … kn} ，满足：
    ki≤k2i       当2i≤n时
    ki≤k2i+1   当2i+1≤n时

由堆的定义知，堆是一棵以k1为根的完全二叉树。若对该二叉树的结点进行编号(从上到下，从左到右)，得到的序列就是将二叉树的结点以顺序结构存放，堆的结构正好和该序列结构完全一致。

2  堆的性质
    1)  堆是一棵采用顺序存储结构的完全二叉树， k1是根结点；
    2)  堆的根结点是关键字序列中的最小(或最大)值，分别称为小(或大)根堆；
    3)  从根结点到每一叶子结点路径上的元素组成的序列都是按元素值(或关键字值)非递减(或非递增)的；
    4)  堆中的任一子树也是堆。

利用堆顶记录的关键字值最小(或最大)的性质，从当前待排序的记录中依次选取关键字最小(或最大)的记录，就可以实现对数据记录的排序，这种排序方法称为堆排序。

3  堆排序思想

①  对一组待排序的记录，按堆的定义建立堆；
②  将堆顶记录和最后一个记录交换位置，则前n-1个记录是无序的，而最后一个记录是有序的；
③  堆顶记录被交换后，前n-1个记录不再是堆，需将前n-1个待排序记录重新组织成为一个堆，然后将堆顶记录和倒数第二个记录交换位置，即将整个序列中次小关键字值的记录调整(排除)出无序区；
④  重复上述步骤，直到全部记录排好序为止。

结论：排序过程中，若采用小根堆，排序后得到的是非递减序列；若采用大根堆，排序后得到的是非递增序列。

堆排序的关键
①  如何由一个无序序列建成一个堆？
②  如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？

4  堆的调整——筛选
⑴ 堆的调整思想
输出堆顶元素之后，以堆中最后一个元素替代之；然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；重复上述操作，直到是叶子结点或其关键字值小于等于左、右子树的关键字的值，将得到新的堆。称这个从堆顶至叶子的调整过程为“筛选”。

注意：筛选过程中，根结点的左、右子树都是堆，因此，筛选是从根结点到某个叶子结点的一次调整过程。

5  堆的建立
利用筛选算法，可以将任意无序的记录序列建成一个堆，设R[1],R[2], …,R[n]是待排序的记录序列。
将二叉树的每棵子树都筛选成为堆。只有根结点的树是堆。第⌊n/2⌋个结点之后的所有结点都没有子树，即以第⌊n/2⌋个结点之后的结点为根的子树都是堆。因此，以这些结点为左、右孩子的结点，其左、右子树都是堆，则进行一次筛选就可以成为堆。同理，只要将这些结点的直接父结点进行一次筛选就可以成为堆…。
只需从第⌊n/2⌋个记录到第1个记录依次进行筛选就可以建立堆。

6   堆排序算法实现
堆的根结点是关键字最小的记录，输出根结点后，是以序列的最后一个记录作为根结点，而原来堆的左、右子树都是堆，则进行一次筛选就可以成为堆。

7  算法分析
主要过程：初始建堆和重新调整成堆。设记录数为n，所对应的完全二叉树深度为h 。
◆  初始建堆：每个非叶子结点都要从上到下做“筛选” 。第i层结点数≤2i-1，结点下移的最大深度是h-i，而每下移一层要比较2次，则比较次数C1(n)为：
C1(n)≤4(n-㏒2n-1)
◆  筛选调整：每次筛选要将根结点“下沉”到一个合适位置。第i次筛选时：堆中元素个数为n-i+1；堆的深度是㏒2(n-i+1)+1，则进行n-1次“筛选”的比较次数C2(n)为：
C2(n)<2n㏒2n
堆排序的比较次数的数量级为： T(n)=O(n㏒2n)；而附加空间就是交换时所用的临时空间，故空间复杂度为： S(n)=O(1) 。

堆排序适合记录数较大的情况


http://blog.csdn.net/zz198808/article/details/7678055
 */

/**
 * 已知sqList[s..m]中记录的关键字除sqList[s]之外均满足堆的定义，
 * 本函数调整sqList[s]的关键字，使sqList[s..m]成为一个大堆顶（对其中关键字而言）
 * @param {Array} sqList
 * @param {Number} s
 * @param {Number} m
 */
function heapAdjust(sqList, s, m, comp) {
    var rc = sqList[s];

    // 沿关键字较大的孩子结点向下筛选
    for (var j = 2 * s + 1; j <= m; j = j * 2 + 1) {
        // j为关键字较大的记录下标
        if (j < m && comp(sqList[j], sqList[j + 1]) < 0) ++j;
        // rc应插入在位置s上
        if (comp(rc, sqList[j]) >= 0) break;
        sqList[s] = sqList[j];
        s = j;
    }

    sqList[s] = rc;
}

function heapSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var len = sqList.length;
    // 建立大堆顶
    for (var i = (len >> 1) - 1; i >= 0; --i) {
        heapAdjust(sqList, i, len - 1, comp);
    }for (var _i = len - 1; _i > 0; --_i) {
        // 将堆顶记录和当前未经排序子序列sqList[0..i]中
        // 最后一个记录相互交换
        var temp = sqList[_i];
        sqList[_i] = sqList[0];
        sqList[0] = temp;

        // 将sqList[0..i - 1]重新调整为大堆顶
        heapAdjust(sqList, 0, _i - 1, comp);
    }
}

var arr = [1, 3, 4, 5, 7, 2, 6, 8, 0];
heapSort(arr);
console.log(arr + '');

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 堆分配存储表示
 *
 * 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在c语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间。
 */

var HString = function () {
    function HString() {
        (0, _classCallCheck3.default)(this, HString);

        this.ch = {};
        this.length = 0;
    }

    // 1 <= position <= this.length.在串的第position个字符之前插入串tHString


    HString.prototype.strInsert = function strInsert(position, tHString) {
        if (position < 1 || position > this.length + 1) throw new Error('unexpected position');

        if (tHString.length) {
            // 为插入t而腾出位置
            var i = this.length - 1;
            for (var len = position - 1; i >= len; --i) {
                this.ch[i + tHString.length] = this.ch[i];
            }stringCopy(this.ch, tHString.ch, position - 1, tHString.length - 1, 0);

            this.length += tHString.length;
        }
    };

    HString.prototype.strAssign = function strAssign(chars) {
        stringCopy(this.ch, chars, 0, chars.length - 1, 0);
        this.length = chars.length;
    };

    HString.prototype.strLength = function strLength() {
        return this.length;
    };

    HString.prototype.strCompare = function strCompare(tHString) {
        for (var i = 0, len = this.length; i < len && i < tHString.length; i++) {
            if (this.ch[i] !== tHString.ch[i]) return this.ch[i] - tHString.ch[i];
        }return this.length - tHString.length;
    };

    HString.prototype.clearString = function clearString() {
        this.ch = {};
        this.length = 0;
    };

    HString.prototype.concat = function concat(s) {
        var t = new HString();

        // t.ch[0..this.length - 1] = this.ch[0..this.length - 1]
        stringCopy(t.ch, this.ch, 0, this.length - 1, 0);
        t.length = this.length + s.length;
        // t.ch[this.length..t.length - 1] = s.ch[0..s.length - 1]
        stringCopy(t.ch, s.ch, this.length, s.length - 1, 0);

        return t;
    };

    HString.prototype.substring = function substring(position, len) {
        position = ~~position || 0;
        len = ~~len || this.length;
        if (position < 0 || position > this.length - 1 || len < 0 || len > this.length - position) throw new Error('unexpected parameter');

        var sub = new HString();
        stringCopy(sub.ch, this.ch, 0, len - 1, position);
        sub.length = len;

        return sub;
    };

    HString.prototype.toString = function toString() {
        var s = '';
        for (var i = 0, len = this.length; i < len; i++) {
            s += this.ch[i];
        }
        return s;
    };

    return HString;
}();

exports.default = HString;


function stringCopy(destination, target, destStart, length, targetStart) {
    destStart = destStart || 0;
    length = length || target.length;
    targetStart = targetStart || 0;

    for (var i = 0; i <= length; i++) {
        destination[destStart + i] = target[targetStart + i];
    }
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Chunk = function Chunk() {
    var chunkSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
    (0, _classCallCheck3.default)(this, Chunk);

    this.chunkSize = chunkSize;
    this.ch = [];
    for (var i = 0; i < this.chunkSize; i++) {
        this.ch[i] = '#';
    }
    // type: Chunk
    this.next = null;
}; /**
    * 串的块链存储表示
    *
    * 和线性表的链式存储结构相类似，也可采用链式方式存储串值。由于串结构的特殊性--结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。
    * 下面是结点大小为4（即每个结点存放4个字符）的链表
    * head --> (a,b,c,d) --> (e,f,g,h) --> (i###)
    * 下面是结点大小为1的链表
    * head --> (a) --> (b) --> (c) --> ... --> (i)
    *
    * 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其它非串值字符。
    * 为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度，称如此定义的串存储结构为块链结构。
    *
    * 由于一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行连接操作，但应注意连接时需处理第一个串尾的无效字符。
    * 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响到串处理的效率。如果串很长，这要求我们考虑串值的存储密度：
    * 存储密度 = 串值所占的存储位 / 实际分配的存储位
    *
    * 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。
    */


var LString = function () {
    function LString() {
        var chunkSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
        (0, _classCallCheck3.default)(this, LString);

        // type Chunk
        this.head = null;
        // type: chunk
        this.tail = null;
        // 串的当前长度
        this.length = 0;
        this.chunkSize = chunkSize;
    }

    // 将字符串转换成LString类型


    LString.prototype.strAssign = function strAssign(chars) {
        this.head = this.tail = new Chunk(this.chunkSize);
        this.length = chars.length;

        var current = this.head;
        for (var i = 0, len = chars.length; i < len; i++) {
            current.ch[i % this.chunkSize] = chars[i];
            if (i + 1 < len && (i + 1) % this.chunkSize === 0) {
                current.next = new Chunk();
                current = current.next;
            }
        }

        this.tail = current;
    };
    // 字符串对比
    // TODO 是否去掉chunkSize的对比


    LString.prototype.strCompare = function strCompare(tLString) {
        var current = this.head;
        var curT = tLString.head;

        if (this.length !== tLString.length) return false;

        while (current) {
            for (var i = 0; i < this.chunkSize; i++) {
                if (current.ch[i] !== curT.ch[i]) return false;
            }

            current = current.next;
            curT = curT.next;
        }

        return true;
    };

    LString.prototype.clearString = function clearString() {
        this.head = this.tail = null;
        this.length = 0;
    };

    LString.prototype.concat = function concat(tLSting) {
        if (!tLSting.length) return;

        var ret = new LString(this.chunkSize);

        if (this.head === null) {
            copyString(ret, tLSting);
        } else {
            ret.head = ret.tail = new Chunk(this.chunkSize);
            copyString(ret, this);

            var index = ret.tail.ch.indexOf('#');
            if (index === -1) {
                copyString(ret, tLSting);
            } else {
                copyString(ret, tLSting, ret.tail, tLSting.head, index);
            }
        }

        return ret;
    };

    LString.prototype.substring = function substring(pos, len) {
        pos = ~~pos || 0;
        len = ~~len || this.length;
        if (pos < 0 || pos > this.length - 1 || len < 0 || len > this.length - pos) throw new Error('unexpected parameter');

        var sub = new LString(this.chunkSize);
        var current = findPosChunk(this, pos);
        var curS = sub.head = new Chunk(this.chunkSize);
        var i = 0;
        sub.length = len;

        outerloop: while (current) {
            for (var j = 0, size = this.chunkSize; j < size; j++) {
                if (i === len) {
                    break outerloop;
                } else {
                    curS.ch[j] = current.ch[(i + pos) % this.chunkSize];
                    i++;
                    if ((i + pos) % this.chunkSize === 0) {
                        current = current.next;
                    }
                    if (i % this.chunkSize === 0 && (current.ch[i] || current.next)) {
                        curS.next = new Chunk(this.chunkSize);
                        curS = curS.next;
                    }
                }
            }
        }

        return sub;
    };

    LString.prototype.toString = function toString() {
        var current = this.head;

        if (current === null) return '';

        var str = '';
        while (current) {
            for (var i = 0, len = this.chunkSize; i < len; i++) {
                var ch = current.ch[i];
                if (ch === '#') {
                    return str;
                } else {
                    str += current.ch[i];
                }
            }
            current = current.next;
        }

        return str;
    };

    return LString;
}();

exports.default = LString;


function findPosChunk(lString, pos) {
    var current = lString.head;
    while (current) {
        for (var i = 0, len = lString.chunkSize; i < len; i++) {
            if (pos-- === 0) return current;
        }
        current = current.next;
    }
}

function copyString(destination, target, curD, currT, offset) {
    offset = offset || 0;
    currT = currT || target.head;
    curD = curD || destination.head;
    var k = 0;

    while (currT) {
        for (var i = 0, len = target.chunkSize; i < len; i++, k++) {
            var j = k % curD.chunkSize + offset;
            curD.ch[j % curD.chunkSize] = currT.ch[i];

            if ((j + 1) % curD.chunkSize === 0 && (currT.ch[i + 1] || currT.next)) {
                curD.next = new Chunk(destination.chunkSize);
                curD = curD.next;
            }
        }

        currT = currT.next;
    }

    destination.tail = curD;
    destination.length += target.length;
}

var a = new LString();
var b = new LString();
var c = new LString();

a.strAssign('abcdefg');
console.log(a + '');
b.strAssign('hijklmno');
console.log(b + '');
c.strAssign('abcdefg');
console.log(a.strCompare(b));
console.log(a.strCompare(c));
var t = a.concat(b);
console.log(t + '');
t = t.substring(2, 5);
console.log(t + '');

// 判断是否为回文字符串
function palindrome(lStr) {
    var stack = new _index2.default();
    var p = lStr.head;
    var i = 0;

    for (var k = 1; k <= lStr.length; ++k) {
        if (k <= lStr.length / 2) stack.push(p.ch[i]);else if (k > (lStr.length + 1) / 2) {
            var _c = stack.pop();
            if (p.ch[i] !== _c) return false;
        }

        if (++i === lStr.chunkSize) {
            p = p.next;
            i = 0;
        }
    }

    return true;
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 串（string）（或字符串）是由零个或多个字符组成的有限序列。串中字符的数目称为串的长度。零个字符的串称为空串（null string），它的长度为零。
 * 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。
 * 只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。
 *
 * 串有3种机内表示方法：
 * 1.定长顺序存储表示
 * 2.堆分配存储表示
 * 3.串的块链存储表示
 */

/**
 * 定长顺序存储表示
 * 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组来描述。
 * 以下标为0的数组分量存放串的实际长度。
 */

var SString = function () {
    function SString(str) {
        (0, _classCallCheck3.default)(this, SString);

        this.MAXSTRLEN = 10;
        if (str) {
            this[0] = str.length;
            for (var i = 1; i <= str.length; ++i) {
                this[i] = str[i - 1];
            }
        }
    }

    // 返回由s1和s2连接而成的新串


    SString.prototype.concat = function concat(s2) {
        var t = new SString();
        // 未截断
        if (this[0] + s2[0] <= this.MAXSTRLEN) {
            copyStr2T(this);
            copyStr2T(s2, this[0]);
            t[0] = this[0] + s2[0];

            // 截断
        } else if (this[0] < this.MAXSTRLEN) {
            copyStr2T(this);
            copyStr2T(s2, this[0], this.MAXSTRLEN - this[0]);
            t[0] = this.MAXSTRLEN;

            // 截断（仅取s1）
        } else {
            copyStr2T(this, 0, this.MAXSTRLEN);
            t[0] = this[0] = this.MAXSTRLEN;
        }

        return t;

        function copyStr2T(str) {
            var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str[0];

            for (var i = 1, len = end || str[0]; i <= len; i++) {
                t[start + i] = str[i];
            }
        }
    };

    SString.prototype.substring = function substring() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[0];

        position = ~~position;
        len = ~~len;
        if (position < 0 || position > this[0] - 1 || len < 0 || len > this[0] - position) throw new Error('unexpected parameter');

        var sub = new SString();
        for (var i = 1; i <= len; i++) {
            sub[i] = this[position + i - 1];
        }
        sub[0] = len;

        return sub;
    };

    /**
     * 将串s中的子串t替换为v，返回替换次数
     * todo to be tested
     * @param {SString} t
     * @param {SString} v
     * @returns {number} 替换次数
     */


    SString.prototype.replace = function replace(t, v) {
        for (var _n = 0, i = 1; i <= this[0] - t[0] + 1; i++) {
            for (var j = i, _k = 1; t[_k] && this[j] === t[_k]; ++j, ++_k) {}

            // 找到了与t匹配的字串：分三种情况处理
            if (k > t[0]) {
                var l = void 0;
                // 新字串的长度与原子串相同时，直接替换
                if (t[0] === v[0]) {
                    for (l = 1; l <= t[0]; ++l) {
                        this[i + l - 1] = v[l];
                    }
                }
                // 新子串长度大于原子串时，先将后部右移
                else if (t[0] < v[0]) {
                        for (l = this[0]; l >= i + t[0]; --l) {
                            this[l + v[0] - t[0]] = this[l];
                        }for (l = 1; l <= v[0]; ++l) {
                            this[i + l - 1] = v[l];
                        }
                    }
                    // 新子串长度小于原子串时，先将后部左移
                    else {
                            for (l = i + v[0]; l <= this[0] + v[0] - t[0]; ++l) {
                                this[l] = this[l - v[0] + t[0]];
                            }for (l = 1; l <= v[0]; ++l) {
                                this[i + l - 1] = v[l];
                            }
                        }

                this[0] = this[0] - t[0] + v[0];
                i += v[0];
                ++_n;
            }
        }

        return n;
    };

    SString.prototype.toString = function toString() {
        var str = '';
        for (var i = 1; this[i]; i++) {
            str += this[i];
        }
        return str;
    };
    // 返回子串sstring在主串中的第position个字符之后的位置


    SString.prototype.index = function index(sstring, position) {
        var i = position || 1;
        var j = 1;

        while (i <= this[0] && j <= sstring[0]) {
            if (this[i] === sstring[j]) {
                i++;
                j++;
            } else {
                i = i - j + 2;
                j = 1;
            }
        }

        return j > sstring[0] ? i - sstring[0] : -1;
    };

    SString.prototype.kmpIndex = function kmpIndex(sstring, position) {
        var i = position || 1;
        var j = 1;
        var next = getNext(sstring);

        while (i <= this[0] && j <= sstring[0]) {
            if (j === 0 || this[i] === sstring[j]) {
                ++i;
                ++j;
            } else {
                j = next[j];
            }
        }

        return j > sstring[0] ? i - sstring[0] : -1;
    };

    // 求包含在字符串中而str没有的字符串


    SString.prototype.subtract = function subtract(str) {
        var r = new SString();
        r[0] = 0;

        for (var i = 1; i <= this[0]; ++i) {
            var _c = this[i];
            // 判断当前字符c是否第一次出现
            var j = 1;
            for (; j < i && this[j] !== _c; ++j) {}
            if (i === j) {
                // 判断当前字符是否包含在str中
                var _k2 = 1;
                for (; _k2 <= str[0] && str[_k2] !== _c; ++_k2) {}
                if (_k2 > str[0]) r[++r[0]] = _c;
            }
        }

        return r;
    };

    // todo bug exists


    SString.prototype.delete_substring = function delete_substring(str) {
        var n = 0;
        for (var i = 1; i <= this[0] - str[0] + 1; ++i) {
            var j = 1;
            for (; j <= str[0] && this[i + j - 1] === str[j]; ++j) {}
            if (j > str[0] - 1) {
                for (var _k3 = i; _k3 <= this[0] - str[0]; ++_k3) {
                    this[_k3] = this[_k3 + str[0]];
                }this[0] -= str[0];
                ++n;
            }
        }

        return n;
    };

    return SString;
}();

exports.default = SString;


function getNext(sstring) {
    var i = 1;
    var next = { 1: 0 };
    var j = 0;

    while (i < sstring[0]) {
        if (j === 0 || sstring[i] === sstring[j]) {
            if (sstring[++i] !== sstring[++j]) {
                next[i] = j;
            } else {
                next[i] = next[j];
            }
            //                next[++i] = ++j;
        } else {
            j = next[j];
        }
    }

    return next;
}

var a = new SString();
var b = new SString();
for (var i = 0; i < 4; i++) {
    a[i + 1] = i + '';
    b[i + 1] = i + '';
}
a[0] = b[0] = 4;
var t = a.concat(b);
console.log(t + ''); // 01230123

var d = new SString('acabaabaabcacaabc');
var c = new SString('abaabc');

console.log('index: ' + d.index(c));
console.log('kmpIndex: ' + d.kmpIndex(c));

a = new SString('abcdefg');
b = new SString('asdfg');
console.log(a.subtract(b) + '');

a = new SString('abcdefgh');
b = new SString('cdef');
console.log(a.delete_substring(b) + '');
console.log(a + '');

/*
 在顺序存储结构中，实现串操作的原操作为“字符串序列的复制”，操作时间复杂度基于复制的字符串序列的长度。
 另一操作特点是，如果在操作中出现串值序列的长度超过MAXSTRLEN时，约定用截尾法处理，这种情况不仅在求连接串时可能发生，在串的其他操作中，如插入，置换等也可能发生，克服这个弊病唯有不限定串长的最大长度，即动态分配串值的存储空间。
 */

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(26);
var inherits = __webpack_require__(1);

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(267).runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(27).Reporter;
var EncoderBuffer = __webpack_require__(27).EncoderBuffer;
var DecoderBuffer = __webpack_require__(27).DecoderBuffer;
var assert = __webpack_require__(13);

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(77);

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(78);
decoders.pem = __webpack_require__(153);


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);
var Buffer = __webpack_require__(0).Buffer;

var DERDecoder = __webpack_require__(78);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(79);
encoders.pem = __webpack_require__(155);


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);

var DEREncoder = __webpack_require__(79);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    Array: {
        // CrossList: require('./Array/CrossList').default,
        // TSMatrix: require('./Array/TSMatrix').default
        // todo array algorithms
    },

    BinaryTree: {
        // BinaryThreadTree: require('./BinaryTree/BinaryThreadTree'),
        BinaryTree: __webpack_require__(24),
        huffManCoding: __webpack_require__(119).default,
        BinaryTreeArray: __webpack_require__(118)
        // MFSet: require('./BinaryTree/MFSet'),
    },

    GeneralizedList: __webpack_require__(120).default,

    Graph: {
        AdjacencyListGraph: __webpack_require__(122).default,
        AdjacencyMatrixGraph: __webpack_require__(123).default,
        AMLGraph: __webpack_require__(121).default,
        OLGraph: __webpack_require__(124).default
    },

    List: {
        DoubleLinkedList: __webpack_require__(72).default,
        LinearList: __webpack_require__(126),
        StaticLinkedList: __webpack_require__(73).default,
        LRUCache: __webpack_require__(125).default
    },

    Queue: {
        CycleQueue: __webpack_require__(127).default,
        PriorityQueue: __webpack_require__(128).default,
        Queue: __webpack_require__(16).default
    },

    Search: {
        AVLTree: __webpack_require__(129),
        binarySearch: __webpack_require__(132),
        BinarySortedTree: __webpack_require__(74).default,
        BPlusTree: __webpack_require__(130),
        BTree: __webpack_require__(131),
        DigitalSearchTree: __webpack_require__(134),
        SuffixTree: __webpack_require__(138).default,
        fibonacciSearch: __webpack_require__(139).default,
        HashTable: __webpack_require__(135),
        RedBlackTree: __webpack_require__(136).default,
        sequentialSearch: __webpack_require__(140).default,
        SOSTree: __webpack_require__(137),
        BloomFilter: __webpack_require__(133)
    },

    Sort: {
        distribution: __webpack_require__(141),
        exchange: __webpack_require__(75),
        insertion: __webpack_require__(142),
        merging: __webpack_require__(143),
        selection: __webpack_require__(144)
    },

    Stack: __webpack_require__(25).default,

    String: {
        HString: __webpack_require__(145).default,
        LString: __webpack_require__(146).default,
        SString: __webpack_require__(147).default
        // todo string algorithms
    },

    Heap: __webpack_require__(71).default
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(173), __esModule: true };

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(174), __esModule: true };

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(175), __esModule: true };

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(176), __esModule: true };

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(177), __esModule: true };

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)
var modes = __webpack_require__(37)
var StreamCipher = __webpack_require__(90)
var AuthCipher = __webpack_require__(83)
var ebtk = __webpack_require__(45)

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: __webpack_require__(88),
  CBC: __webpack_require__(84),
  CFB: __webpack_require__(85),
  CFB8: __webpack_require__(87),
  CFB1: __webpack_require__(86),
  OFB: __webpack_require__(89),
  CTR: __webpack_require__(38),
  GCM: __webpack_require__(38)
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)
var modes = __webpack_require__(37)
var ebtk = __webpack_require__(45)
var StreamCipher = __webpack_require__(90)
var AuthCipher = __webpack_require__(83)
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: __webpack_require__(88),
  CBC: __webpack_require__(84),
  CFB: __webpack_require__(85),
  CFB8: __webpack_require__(87),
  CFB1: __webpack_require__(86),
  OFB: __webpack_require__(89),
  CTR: __webpack_require__(38),
  GCM: __webpack_require__(38)
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var ebtk = __webpack_require__(45)
var aes = __webpack_require__(49)
var DES = __webpack_require__(167)
var desModes = __webpack_require__(168)
var aesModes = __webpack_require__(37)
function createCipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}
function createDecipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createCipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createDecipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var CipherBase = __webpack_require__(17)
var des = __webpack_require__(66)
var inherits = __webpack_require__(1)

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return new Buffer(this._des.update(data))
}
DES.prototype._final = function () {
  return new Buffer(this._des.final())
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 168 */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(91)


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(21)
var stream = __webpack_require__(23)
var inherits = __webpack_require__(1)
var sign = __webpack_require__(171)
var verify = __webpack_require__(172)

var algorithms = __webpack_require__(91)
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(65)
var crt = __webpack_require__(50)
var EC = __webpack_require__(4).ec
var BN = __webpack_require__(3)
var parseKeys = __webpack_require__(46)
var curves = __webpack_require__(92)

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(3)
var EC = __webpack_require__(4).ec
var parseKeys = __webpack_require__(46)
var curves = __webpack_require__(92)

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(198);
var $Object = __webpack_require__(18).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(199);
var $Object = __webpack_require__(18).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(200);
module.exports = __webpack_require__(18).Object.setPrototypeOf;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(203);
__webpack_require__(201);
__webpack_require__(204);
__webpack_require__(205);
module.exports = __webpack_require__(18).Symbol;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(202);
__webpack_require__(206);
module.exports = __webpack_require__(64).f('iterator');

/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(11)
  , toLength  = __webpack_require__(195)
  , toIndex   = __webpack_require__(194);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(40)
  , gOPS    = __webpack_require__(100)
  , pIE     = __webpack_require__(57);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).document && document.documentElement;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(93);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(93);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(56)
  , descriptor     = __webpack_require__(41)
  , setToStringTag = __webpack_require__(58)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(19)(IteratorPrototype, __webpack_require__(20)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(40)
  , toIObject = __webpack_require__(11);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(42)('meta')
  , isObject = __webpack_require__(31)
  , has      = __webpack_require__(9)
  , setDesc  = __webpack_require__(10).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(39)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(10)
  , anObject = __webpack_require__(29)
  , getKeys  = __webpack_require__(40);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(11)
  , gOPN      = __webpack_require__(99).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(9)
  , toObject    = __webpack_require__(196)
  , IE_PROTO    = __webpack_require__(59)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(31)
  , anObject = __webpack_require__(29);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(94)(Function.call, __webpack_require__(98).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(61)
  , defined   = __webpack_require__(52);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(61)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(61)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(52);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(179)
  , step             = __webpack_require__(186)
  , Iterators        = __webpack_require__(54)
  , toIObject        = __webpack_require__(11);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(97)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(30)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(56)});

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(30);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperty: __webpack_require__(10).f});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(30);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(192).set});

/***/ }),
/* 201 */
/***/ (function(module, exports) {



/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(193)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(97)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(6)
  , has            = __webpack_require__(9)
  , DESCRIPTORS    = __webpack_require__(8)
  , $export        = __webpack_require__(30)
  , redefine       = __webpack_require__(102)
  , META           = __webpack_require__(188).KEY
  , $fails         = __webpack_require__(39)
  , shared         = __webpack_require__(60)
  , setToStringTag = __webpack_require__(58)
  , uid            = __webpack_require__(42)
  , wks            = __webpack_require__(20)
  , wksExt         = __webpack_require__(64)
  , wksDefine      = __webpack_require__(63)
  , keyOf          = __webpack_require__(187)
  , enumKeys       = __webpack_require__(181)
  , isArray        = __webpack_require__(184)
  , anObject       = __webpack_require__(29)
  , toIObject      = __webpack_require__(11)
  , toPrimitive    = __webpack_require__(62)
  , createDesc     = __webpack_require__(41)
  , _create        = __webpack_require__(56)
  , gOPNExt        = __webpack_require__(190)
  , $GOPD          = __webpack_require__(98)
  , $DP            = __webpack_require__(10)
  , $keys          = __webpack_require__(40)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(99).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(57).f  = $propertyIsEnumerable;
  __webpack_require__(100).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(55)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(63)('asyncIterator');

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(63)('observable');

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(197);
var global        = __webpack_require__(6)
  , hide          = __webpack_require__(19)
  , Iterators     = __webpack_require__(54)
  , TO_STRING_TAG = __webpack_require__(20)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(4);
var BN = __webpack_require__(3);

module.exports = function createECDH(curve) {
	return new ECDH(curve);
};

var aliases = {
	secp256k1: {
		name: 'secp256k1',
		byteLength: 32
	},
	secp224r1: {
		name: 'p224',
		byteLength: 28
	},
	prime256v1: {
		name: 'p256',
		byteLength: 32
	},
	prime192v1: {
		name: 'p192',
		byteLength: 24
	},
	ed25519: {
		name: 'ed25519',
		byteLength: 32
	},
	secp384r1: {
		name: 'p384',
		byteLength: 48
	},
	secp521r1: {
		name: 'p521',
		byteLength: 66
	}
};

aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
	this.curveType = aliases[curve];
	if (!this.curveType ) {
		this.curveType = {
			name: curve
		};
	}
	this.curve = new elliptic.ec(this.curveType.name);
	this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	var otherPub = this.curve.keyFromPublic(other).getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
	return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	this.keys._importPublic(pub);
	return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
	return this;
};

function formatReturnValue(bn, enc, len) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (len && buf.length < len) {
		var zeros = new Buffer(len - buf.length);
		zeros.fill(0);
		buf = Buffer.concat([zeros, buf]);
	}
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(33)
exports.createHash = exports.Hash = __webpack_require__(21)
exports.createHmac = exports.Hmac = __webpack_require__(65)

var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(__webpack_require__(169)))
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(109)
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(166)
;[
  'Cipher',
  'createCipher',
  'Cipheriv',
  'createCipheriv',
  'Decipher',
  'createDecipher',
  'Decipheriv',
  'createDecipheriv',
  'getCiphers',
  'listCiphers'
].forEach(function (key) {
  exports[key] = aes[key]
})

var dh = __webpack_require__(217)
;[
  'DiffieHellmanGroup',
  'createDiffieHellmanGroup',
  'getDiffieHellman',
  'createDiffieHellman',
  'DiffieHellman'
].forEach(function (key) {
  exports[key] = dh[key]
})

var sign = __webpack_require__(170)
;[
  'createSign',
  'Sign',
  'createVerify',
  'Verify'
].forEach(function (key) {
  exports[key] = sign[key]
})

exports.createECDH = __webpack_require__(207)

var publicEncrypt = __webpack_require__(247)

;[
  'publicEncrypt',
  'privateEncrypt',
  'publicDecrypt',
  'privateDecrypt'
].forEach(function (key) {
  exports[key] = publicEncrypt[key]
})

// the least I can do is make error messages for the rest of the node.js/crypto api.
;[
  'createCredentials'
].forEach(function (name) {
  exports[name] = function () {
    throw new Error([
      'sorry, ' + name + ' is not implemented yet',
      'we accept pull requests',
      'https://github.com/crypto-browserify/crypto-browserify'
    ].join('\n'))
  }
})


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	C-like unsigned 32 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		36: UINT32( Math.pow(36, 5) )
	,	16: UINT32( Math.pow(16, 7) )
	,	10: UINT32( Math.pow(10, 9) )
	,	2:  UINT32( Math.pow(2, 30) )
	}
	var radixCache = {
		36: UINT32(36)
	,	16: UINT32(16)
	,	10: UINT32(10)
	,	2:  UINT32(2)
	}

	/**
	 *	Represents an unsigned 32 bits integer
	 * @constructor
	 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
	 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
	 * @return 
	 */
	function UINT32 (l, h) {
		if ( !(this instanceof UINT32) )
			return new UINT32(l, h)

		this._low = 0
		this._high = 0
		this.remainder = null
		if (typeof h == 'undefined')
			return fromNumber.call(this, l)

		if (typeof l == 'string')
			return fromString.call(this, l, h)

		fromBits.call(this, l, h)
	}

	/**
	 * Set the current _UINT32_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} low bits
	 * @param {Number} high bits
	 * @return ThisExpression
	 */
	function fromBits (l, h) {
		this._low = l | 0
		this._high = h | 0

		return this
	}
	UINT32.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT32_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT32_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		var value = parseInt(s, radix || 10)

		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromString = fromString

	/**
	 * Convert this _UINT32_ to a number
	 * @method toNumber
	 * @return {Number} the converted UINT32
	 */
	UINT32.prototype.toNumber = function () {
		return (this._high * 65536) + this._low
	}

	/**
	 * Convert this _UINT32_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT32
	 */
	UINT32.prototype.toString = function (radix) {
		return this.toNumber().toString(radix || 10)
	}

	/**
	 * Add two _UINT32_. The current _UINT32_ stores the result
	 * @method add
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.add = function (other) {
		var a00 = this._low + other._low
		var a16 = a00 >>> 16

		a16 += this._high + other._high

		this._low = a00 & 0xFFFF
		this._high = a16 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT32_. The current _UINT32_ stores the result
	 * @method subtract
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.subtract = function (other) {
		//TODO inline
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT32_. The current _UINT32_ stores the result
	 * @method multiply
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.multiply = function (other) {
		/*
			a = a00 + a16
			b = b00 + b16
			a*b = (a00 + a16)(b00 + b16)
				= a00b00 + a00b16 + a16b00 + a16b16

			a16b16 overflows the 32bits
		 */
		var a16 = this._high
		var a00 = this._low
		var b16 = other._high
		var b00 = other._low

/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
		// this == 0 or other == 1: nothing to do
		if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this

		// other == 0 or this == 1: this = other
		if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
			this._low = other._low
			this._high = other._high
			return this
		}
*/

		var c16, c00
		c00 = a00 * b00
		c16 = c00 >>> 16

		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16

		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT32_. The current _UINT32_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT32_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.div = function (other) {
		if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')

		// other == 1
		if (other._high == 0 && other._low == 1) {
			this.remainder = new UINT32(0)
			return this
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = this.clone()
			this._low = 0
			this._high = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT32(0)
			this._low = 1
			this._high = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._low = 0
		this._high = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 16) {
					this._high |= 1 << (i - 16)
				} else {
					this._low |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT32_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT32.prototype.negate = function () {
		var v = ( ~this._low & 0xFFFF ) + 1
		this._low = v & 0xFFFF
		this._high = (~this._high + (v >>> 16)) & 0xFFFF

		return this
	}

	/**
	 * Equals
	 * @method eq
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
		return (this._low == other._low) && (this._high == other._high)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
		if (this._high > other._high) return true
		if (this._high < other._high) return false
		return this._low > other._low
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
		if (this._high < other._high) return true
		if (this._high > other._high) return false
		return this._low < other._low
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.or = function (other) {
		this._low |= other._low
		this._high |= other._high

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.and = function (other) {
		this._low &= other._low
		this._high &= other._high

		return this
	}

	/**
	 * Bitwise NOT
	 * @method not
	 * @return ThisExpression
	 */
	UINT32.prototype.not = function() {
		this._low = ~this._low & 0xFFFF
		this._high = ~this._high & 0xFFFF

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.xor = function (other) {
		this._low ^= other._low
		this._high ^= other._high

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
		if (n > 16) {
			this._low = this._high >> (n - 16)
			this._high = 0
		} else if (n == 16) {
			this._low = this._high
			this._high = 0
		} else {
			this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )
			this._high >>= n
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
		if (n > 16) {
			this._high = this._low << (n - 16)
			this._low = 0
			if (!allowOverflow) {
				this._high &= 0xFFFF
			}
		} else if (n == 16) {
			this._high = this._low
			this._low = 0
		} else {
			this._high = (this._high << n) | (this._low >> (16-n))
			this._low = (this._low << n) & 0xFFFF
			if (!allowOverflow) {
				// Overflow only allowed on the high bits...
				this._high &= 0xFFFF
			}
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
		var v = (this._high << 16) | this._low
		v = (v << n) | (v >>> (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
		var v = (this._high << 16) | this._low
		v = (v >>> n) | (v << (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Clone the current _UINT32_
	 * @method clone
	 * @return {Object} cloned UINT32
	 */
	UINT32.prototype.clone = function () {
		return new UINT32(this._low, this._high)
	}

	if (true) {
		// AMD / RequireJS
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return UINT32
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else if (typeof module != 'undefined' && module.exports) {
		// Node.js
		module.exports = UINT32
	} else {
		// Browser
		root['UINT32'] = UINT32
	}

})(this)


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	C-like unsigned 64 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		16: UINT64( Math.pow(16, 5) )
	,	10: UINT64( Math.pow(10, 5) )
	,	2:  UINT64( Math.pow(2, 5) )
	}
	var radixCache = {
		16: UINT64(16)
	,	10: UINT64(10)
	,	2:  UINT64(2)
	}

	/**
	 *	Represents an unsigned 64 bits integer
	 * @constructor
	 * @param {Number} first low bits (8)
	 * @param {Number} second low bits (8)
	 * @param {Number} first high bits (8)
	 * @param {Number} second high bits (8)
	 * or
	 * @param {Number} low bits (32)
	 * @param {Number} high bits (32)
	 * or
	 * @param {String|Number} integer as a string 		 | integer as a number
	 * @param {Number|Undefined} radix (optional, default=10)
	 * @return 
	 */
	function UINT64 (a00, a16, a32, a48) {
		if ( !(this instanceof UINT64) )
			return new UINT64(a00, a16, a32, a48)

		this.remainder = null
		if (typeof a00 == 'string')
			return fromString.call(this, a00, a16)

		if (typeof a16 == 'undefined')
			return fromNumber.call(this, a00)

		fromBits.apply(this, arguments)
	}

	/**
	 * Set the current _UINT64_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} first low bits (8)
	 * @param {Number} second low bits (8)
	 * @param {Number} first high bits (8)
	 * @param {Number} second high bits (8)
	 * or
	 * @param {Number} low bits (32)
	 * @param {Number} high bits (32)
	 * @return ThisExpression
	 */
	function fromBits (a00, a16, a32, a48) {
		if (typeof a32 == 'undefined') {
			this._a00 = a00 & 0xFFFF
			this._a16 = a00 >>> 16
			this._a32 = a16 & 0xFFFF
			this._a48 = a16 >>> 16
			return this
		}

		this._a00 = a00 | 0
		this._a16 = a16 | 0
		this._a32 = a32 | 0
		this._a48 = a48 | 0

		return this
	}
	UINT64.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT64_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._a00 = value & 0xFFFF
		this._a16 = value >>> 16
		this._a32 = 0
		this._a48 = 0

		return this
	}
	UINT64.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT64_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		radix = radix || 10

		this._a00 = 0
		this._a16 = 0
		this._a32 = 0
		this._a48 = 0

		/*
			In Javascript, bitwise operators only operate on the first 32 bits 
			of a number, even though parseInt() encodes numbers with a 53 bits 
			mantissa.
			Therefore UINT64(<Number>) can only work on 32 bits.
			The radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)
			maximum input value is m = 32bits as 1 = 2^32 - 1
			So the maximum substring length n is:
			36^(n+1) - 1 = 2^32 - 1
			36^(n+1) = 2^32
			(n+1)ln(36) = 32ln(2)
			n = 32ln(2)/ln(36) - 1
			n = 5.189644915687692
			n = 5
		 */
		var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) )

		for (var i = 0, len = s.length; i < len; i += 5) {
			var size = Math.min(5, len - i)
			var value = parseInt( s.slice(i, i + size), radix )
			this.multiply(
					size < 5
						? new UINT64( Math.pow(radix, size) )
						: radixUint
				)
				.add( new UINT64(value) )
		}

		return this
	}
	UINT64.prototype.fromString = fromString

	/**
	 * Convert this _UINT64_ to a number (last 32 bits are dropped)
	 * @method toNumber
	 * @return {Number} the converted UINT64
	 */
	UINT64.prototype.toNumber = function () {
		return (this._a16 * 65536) + this._a00
	}

	/**
	 * Convert this _UINT64_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT64
	 */
	UINT64.prototype.toString = function (radix) {
		radix = radix || 10
		var radixUint = radixCache[radix] || new UINT64(radix)

		if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)

		var self = this.clone()
		var res = new Array(64)
		for (var i = 63; i >= 0; i--) {
			self.div(radixUint)
			res[i] = self.remainder.toNumber().toString(radix)
			if ( !self.gt(radixUint) ) break
		}
		res[i-1] = self.toNumber().toString(radix)

		return res.join('')
	}

	/**
	 * Add two _UINT64_. The current _UINT64_ stores the result
	 * @method add
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.add = function (other) {
		var a00 = this._a00 + other._a00

		var a16 = a00 >>> 16
		a16 += this._a16 + other._a16

		var a32 = a16 >>> 16
		a32 += this._a32 + other._a32

		var a48 = a32 >>> 16
		a48 += this._a48 + other._a48

		this._a00 = a00 & 0xFFFF
		this._a16 = a16 & 0xFFFF
		this._a32 = a32 & 0xFFFF
		this._a48 = a48 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT64_. The current _UINT64_ stores the result
	 * @method subtract
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.subtract = function (other) {
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT64_. The current _UINT64_ stores the result
	 * @method multiply
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.multiply = function (other) {
		/*
			a = a00 + a16 + a32 + a48
			b = b00 + b16 + b32 + b48
			a*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)
				= a00b00 + a00b16 + a00b32 + a00b48
				+ a16b00 + a16b16 + a16b32 + a16b48
				+ a32b00 + a32b16 + a32b32 + a32b48
				+ a48b00 + a48b16 + a48b32 + a48b48

			a16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits
			so it comes down to:
			a*b	= a00b00 + a00b16 + a00b32 + a00b48
				+ a16b00 + a16b16 + a16b32
				+ a32b00 + a32b16
				+ a48b00
				= a00b00
				+ a00b16 + a16b00
				+ a00b32 + a16b16 + a32b00
				+ a00b48 + a16b32 + a32b16 + a48b00
		 */
		var a00 = this._a00
		var a16 = this._a16
		var a32 = this._a32
		var a48 = this._a48
		var b00 = other._a00
		var b16 = other._a16
		var b32 = other._a32
		var b48 = other._a48

		var c00 = a00 * b00

		var c16 = c00 >>> 16
		c16 += a00 * b16
		var c32 = c16 >>> 16
		c16 &= 0xFFFF
		c16 += a16 * b00

		c32 += c16 >>> 16
		c32 += a00 * b32
		var c48 = c32 >>> 16
		c32 &= 0xFFFF
		c32 += a16 * b16
		c48 += c32 >>> 16
		c32 &= 0xFFFF
		c32 += a32 * b00

		c48 += c32 >>> 16
		c48 += a00 * b48
		c48 &= 0xFFFF
		c48 += a16 * b32
		c48 &= 0xFFFF
		c48 += a32 * b16
		c48 &= 0xFFFF
		c48 += a48 * b00

		this._a00 = c00 & 0xFFFF
		this._a16 = c16 & 0xFFFF
		this._a32 = c32 & 0xFFFF
		this._a48 = c48 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT64_. The current _UINT64_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT64_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.div = function (other) {
		if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
			if (other._a00 == 0) throw Error('division by zero')

			// other == 1: this
			if (other._a00 == 1) {
				this.remainder = new UINT64(0)
				return this
			}
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = this.clone()
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT64(0)
			this._a00 = 1
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._a00 = 0
		this._a16 = 0
		this._a32 = 0
		this._a48 = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 48) {
					this._a48 |= 1 << (i - 48)
				} else if (i >= 32) {
					this._a32 |= 1 << (i - 32)
				} else if (i >= 16) {
					this._a16 |= 1 << (i - 16)
				} else {
					this._a00 |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT64_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT64.prototype.negate = function () {
		var v = ( ~this._a00 & 0xFFFF ) + 1
		this._a00 = v & 0xFFFF
		v = (~this._a16 & 0xFFFF) + (v >>> 16)
		this._a16 = v & 0xFFFF
		v = (~this._a32 & 0xFFFF) + (v >>> 16)
		this._a32 = v & 0xFFFF
		this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF

		return this
	}

	/**

	 * @method eq
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
		return (this._a48 == other._a48) && (this._a00 == other._a00)
			 && (this._a32 == other._a32) && (this._a16 == other._a16)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
		if (this._a48 > other._a48) return true
		if (this._a48 < other._a48) return false
		if (this._a32 > other._a32) return true
		if (this._a32 < other._a32) return false
		if (this._a16 > other._a16) return true
		if (this._a16 < other._a16) return false
		return this._a00 > other._a00
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
		if (this._a48 < other._a48) return true
		if (this._a48 > other._a48) return false
		if (this._a32 < other._a32) return true
		if (this._a32 > other._a32) return false
		if (this._a16 < other._a16) return true
		if (this._a16 > other._a16) return false
		return this._a00 < other._a00
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.or = function (other) {
		this._a00 |= other._a00
		this._a16 |= other._a16
		this._a32 |= other._a32
		this._a48 |= other._a48

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.and = function (other) {
		this._a00 &= other._a00
		this._a16 &= other._a16
		this._a32 &= other._a32
		this._a48 &= other._a48

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.xor = function (other) {
		this._a00 ^= other._a00
		this._a16 ^= other._a16
		this._a32 ^= other._a32
		this._a48 ^= other._a48

		return this
	}

	/**
	 * Bitwise NOT
	 * @method not
	 * @return ThisExpression
	 */
	UINT64.prototype.not = function() {
		this._a00 = ~this._a00 & 0xFFFF
		this._a16 = ~this._a16 & 0xFFFF
		this._a32 = ~this._a32 & 0xFFFF
		this._a48 = ~this._a48 & 0xFFFF

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
		n %= 64
		if (n >= 48) {
			this._a00 = this._a48 >> (n - 48)
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
		} else if (n >= 32) {
			n -= 32
			this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a16 = (this._a48 >> n) & 0xFFFF
			this._a32 = 0
			this._a48 = 0
		} else if (n >= 16) {
			n -= 16
			this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a32 = (this._a48 >> n) & 0xFFFF
			this._a48 = 0
		} else {
			this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
			this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a48 = (this._a48 >> n) & 0xFFFF
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
		n %= 64
		if (n >= 48) {
			this._a48 = this._a00 << (n - 48)
			this._a32 = 0
			this._a16 = 0
			this._a00 = 0
		} else if (n >= 32) {
			n -= 32
			this._a48 = (this._a16 << n) | (this._a00 >> (16-n))
			this._a32 = (this._a00 << n) & 0xFFFF
			this._a16 = 0
			this._a00 = 0
		} else if (n >= 16) {
			n -= 16
			this._a48 = (this._a32 << n) | (this._a16 >> (16-n))
			this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
			this._a16 = (this._a00 << n) & 0xFFFF
			this._a00 = 0
		} else {
			this._a48 = (this._a48 << n) | (this._a32 >> (16-n))
			this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
			this._a00 = (this._a00 << n) & 0xFFFF
		}
		if (!allowOverflow) {
			this._a48 &= 0xFFFF
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
		n %= 64
		if (n == 0) return this
		if (n >= 32) {
			// A.B.C.D
			// B.C.D.A rotl(16)
			// C.D.A.B rotl(32)
			var v = this._a00
			this._a00 = this._a32
			this._a32 = v
			v = this._a48
			this._a48 = this._a16
			this._a16 = v
			if (n == 32) return this
			n -= 32
		}

		var high = (this._a48 << 16) | this._a32
		var low = (this._a16 << 16) | this._a00

		var _high = (high << n) | (low >>> (32 - n))
		var _low = (low << n) | (high >>> (32 - n))

		this._a00 = _low & 0xFFFF
		this._a16 = _low >>> 16
		this._a32 = _high & 0xFFFF
		this._a48 = _high >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
		n %= 64
		if (n == 0) return this
		if (n >= 32) {
			// A.B.C.D
			// D.A.B.C rotr(16)
			// C.D.A.B rotr(32)
			var v = this._a00
			this._a00 = this._a32
			this._a32 = v
			v = this._a48
			this._a48 = this._a16
			this._a16 = v
			if (n == 32) return this
			n -= 32
		}

		var high = (this._a48 << 16) | this._a32
		var low = (this._a16 << 16) | this._a00

		var _high = (high >>> n) | (low << (32 - n))
		var _low = (low >>> n) | (high << (32 - n))

		this._a00 = _low & 0xFFFF
		this._a16 = _low >>> 16
		this._a32 = _high & 0xFFFF
		this._a48 = _high >>> 16

		return this
	}

	/**
	 * Clone the current _UINT64_
	 * @method clone
	 * @return {Object} cloned UINT64
	 */
	UINT64.prototype.clone = function () {
		return new UINT64(this._a00, this._a16, this._a32, this._a48)
	}

	if (true) {
		// AMD / RequireJS
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return UINT64
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else if (typeof module != 'undefined' && module.exports) {
		// Node.js
		module.exports = UINT64
	} else {
		// Browser
		root['UINT64'] = UINT64
	}

})(this)


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);
var inherits = __webpack_require__(1);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);
var inherits = __webpack_require__(1);

var des = __webpack_require__(66);
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);
var inherits = __webpack_require__(1);

var des = __webpack_require__(66);
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(105)
var primes = __webpack_require__(219)

var DH = __webpack_require__(218)

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(3);
var MillerRabin = __webpack_require__(107);
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(105);
var randomBytes = __webpack_require__(33);
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = {
	"modp1": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
	},
	"modp2": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
	},
	"modp5": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
	},
	"modp14": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
	},
	"modp15": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
	},
	"modp16": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
	},
	"modp17": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
	},
	"modp18": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
	}
};

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(43);
var elliptic = __webpack_require__(4);
var BN = __webpack_require__(3);
var inherits = __webpack_require__(1);
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(43);
var BN = __webpack_require__(3);
var inherits = __webpack_require__(1);
var Base = curve.base;

var elliptic = __webpack_require__(4);
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(43);
var elliptic = __webpack_require__(4);
var BN = __webpack_require__(3);
var inherits = __webpack_require__(1);
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(12);
var elliptic = __webpack_require__(4);

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(231);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var HmacDRBG = __webpack_require__(239);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(226);
var Signature = __webpack_require__(227);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);

var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(12);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(229);
var Signature = __webpack_require__(230);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),
/* 231 */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(3);
var minAssert = __webpack_require__(13);
var minUtils = __webpack_require__(108);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),
/* 233 */
/***/ (function(module, exports) {

module.exports = {
	"_args": [
		[
			{
				"raw": "elliptic@^6.0.0",
				"scope": null,
				"escapedName": "elliptic",
				"name": "elliptic",
				"rawSpec": "^6.0.0",
				"spec": ">=6.0.0 <7.0.0",
				"type": "range"
			},
			"/Users/devicalin/Desktop/workspace/js-stl/node_modules/browserify-sign"
		]
	],
	"_from": "elliptic@>=6.0.0 <7.0.0",
	"_id": "elliptic@6.4.0",
	"_inCache": true,
	"_location": "/elliptic",
	"_nodeVersion": "7.0.0",
	"_npmOperationalInternal": {
		"host": "packages-18-east.internal.npmjs.com",
		"tmp": "tmp/elliptic-6.4.0.tgz_1487798866428_0.30510620190761983"
	},
	"_npmUser": {
		"name": "indutny",
		"email": "fedor@indutny.com"
	},
	"_npmVersion": "3.10.8",
	"_phantomChildren": {},
	"_requested": {
		"raw": "elliptic@^6.0.0",
		"scope": null,
		"escapedName": "elliptic",
		"name": "elliptic",
		"rawSpec": "^6.0.0",
		"spec": ">=6.0.0 <7.0.0",
		"type": "range"
	},
	"_requiredBy": [
		"/browserify-sign",
		"/create-ecdh"
	],
	"_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz",
	"_shasum": "cac9af8762c85836187003c8dfe193e5e2eae5df",
	"_shrinkwrap": null,
	"_spec": "elliptic@^6.0.0",
	"_where": "/Users/devicalin/Desktop/workspace/js-stl/node_modules/browserify-sign",
	"author": {
		"name": "Fedor Indutny",
		"email": "fedor@indutny.com"
	},
	"bugs": {
		"url": "https://github.com/indutny/elliptic/issues"
	},
	"dependencies": {
		"bn.js": "^4.4.0",
		"brorand": "^1.0.1",
		"hash.js": "^1.0.0",
		"hmac-drbg": "^1.0.0",
		"inherits": "^2.0.1",
		"minimalistic-assert": "^1.0.0",
		"minimalistic-crypto-utils": "^1.0.0"
	},
	"description": "EC cryptography",
	"devDependencies": {
		"brfs": "^1.4.3",
		"coveralls": "^2.11.3",
		"grunt": "^0.4.5",
		"grunt-browserify": "^5.0.0",
		"grunt-cli": "^1.2.0",
		"grunt-contrib-connect": "^1.0.0",
		"grunt-contrib-copy": "^1.0.0",
		"grunt-contrib-uglify": "^1.0.1",
		"grunt-mocha-istanbul": "^3.0.1",
		"grunt-saucelabs": "^8.6.2",
		"istanbul": "^0.4.2",
		"jscs": "^2.9.0",
		"jshint": "^2.6.0",
		"mocha": "^2.1.0"
	},
	"directories": {},
	"dist": {
		"shasum": "cac9af8762c85836187003c8dfe193e5e2eae5df",
		"tarball": "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz"
	},
	"files": [
		"lib"
	],
	"gitHead": "6b0d2b76caae91471649c8e21f0b1d3ba0f96090",
	"homepage": "https://github.com/indutny/elliptic",
	"keywords": [
		"EC",
		"Elliptic",
		"curve",
		"Cryptography"
	],
	"license": "MIT",
	"main": "lib/elliptic.js",
	"maintainers": [
		{
			"name": "indutny",
			"email": "fedor@indutny.com"
		}
	],
	"name": "elliptic",
	"optionalDependencies": {},
	"readme": "ERROR: No README data found!",
	"repository": {
		"type": "git",
		"url": "git+ssh://git@github.com/indutny/elliptic.git"
	},
	"scripts": {
		"jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
		"jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
		"lint": "npm run jscs && npm run jshint",
		"test": "npm run lint && npm run unit",
		"unit": "istanbul test _mocha --reporter=spec test/index.js",
		"version": "grunt dist && git add dist/"
	},
	"version": "6.4.0"
};

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var hash = __webpack_require__(12);
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var hmac = exports;

var hash = __webpack_require__(12);
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var hash = __webpack_require__(12);
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var hash = __webpack_require__(12);
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var utils = exports;
var inherits = __webpack_require__(1);

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(12);
var utils = __webpack_require__(108);
var assert = __webpack_require__(13);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),
/* 240 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 241 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports = {
	"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
	"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
	"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
	"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
	"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
	"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
	"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
	"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
	"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
	"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
	"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
	"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(26)

exports.certificate = __webpack_require__(244)

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(26)

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\n\r?DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\n\r?\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?/m
var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n/m
var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?-----END \1-----$/m
var evp = __webpack_require__(45)
var ciphers = __webpack_require__(49)
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 246 */
/***/ (function(module, exports) {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(249);
exports.privateDecrypt = __webpack_require__(248);

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(46);
var mgf = __webpack_require__(110);
var xor = __webpack_require__(112);
var bn = __webpack_require__(3);
var crt = __webpack_require__(50);
var createHash = __webpack_require__(21);
var withPublic = __webpack_require__(111);
module.exports = function privateDecrypt(private_key, enc, reverse) {
  var padding;
  if (private_key.padding) {
    padding = private_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new bn(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, reverse){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return  msg.slice(i);
}
function compare(a, b){
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(46);
var randomBytes = __webpack_require__(33);
var createHash = __webpack_require__(21);
var mgf = __webpack_require__(110);
var xor = __webpack_require__(112);
var bn = __webpack_require__(3);
var withPublic = __webpack_require__(111);
var crt = __webpack_require__(50);

var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function publicEncrypt(public_key, msg, reverse) {
  var padding;
  if (public_key.padding) {
    padding = public_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(14)


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(0).Buffer;
/*<replacement>*/
var bufferShim = __webpack_require__(51);
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(113)


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
  try {
    return __webpack_require__(23); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = __webpack_require__(114);
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(69);
exports.Duplex = __webpack_require__(14);
exports.Transform = __webpack_require__(68);
exports.PassThrough = __webpack_require__(113);

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(68)


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(69)


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(257);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(7)))

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cédric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(7)))

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(261)
exports.sha1 = __webpack_require__(262)
exports.sha224 = __webpack_require__(263)
exports.sha256 = __webpack_require__(115)
exports.sha384 = __webpack_require__(264)
exports.sha512 = __webpack_require__(116)


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(1)
var Sha256 = __webpack_require__(115)
var Hash = __webpack_require__(22)

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(1)
var SHA512 = __webpack_require__(116)
var Hash = __webpack_require__(22)

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(259);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(241);

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
	h32: __webpack_require__(269)
,	h64: __webpack_require__(270)
}


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
xxHash implementation in pure Javascript

Copyright (C) 2013, Pierre Curto
MIT license
*/
var UINT32 = __webpack_require__(104).UINT32

/*
	Merged this sequence of method calls as it speeds up
	the calculations by a factor of 2
 */
// this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
UINT32.prototype.xxh_update = function (low, high) {
	var b00 = PRIME32_2._low
	var b16 = PRIME32_2._high

	var c16, c00
	c00 = low * b00
	c16 = c00 >>> 16

	c16 += high * b00
	c16 &= 0xFFFF		// Not required but improves performance
	c16 += low * b16

	var a00 = this._low + (c00 & 0xFFFF)
	var a16 = a00 >>> 16

	a16 += this._high + (c16 & 0xFFFF)

	var v = (a16 << 16) | (a00 & 0xFFFF)
	v = (v << 13) | (v >>> 19)

	a00 = v & 0xFFFF
	a16 = v >>> 16

	b00 = PRIME32_1._low
	b16 = PRIME32_1._high

	c00 = a00 * b00
	c16 = c00 >>> 16

	c16 += a16 * b00
	c16 &= 0xFFFF		// Not required but improves performance
	c16 += a00 * b16

	this._low = c00 & 0xFFFF
	this._high = c16 & 0xFFFF
}

/*
 * Constants
 */
var PRIME32_1 = UINT32( '2654435761' )
var PRIME32_2 = UINT32( '2246822519' )
var PRIME32_3 = UINT32( '3266489917' )
var PRIME32_4 = UINT32(  '668265263' )
var PRIME32_5 = UINT32(  '374761393' )

/**
* Convert string to proper UTF-8 array
* @param str Input string
* @returns {Uint8Array} UTF8 array is returned as uint8 array
*/
function toUTF8Array (str) {
	var utf8 = []
	for (var i=0, n=str.length; i < n; i++) {
		var charcode = str.charCodeAt(i)
		if (charcode < 0x80) utf8.push(charcode)
		else if (charcode < 0x800) {
			utf8.push(0xc0 | (charcode >> 6),
			0x80 | (charcode & 0x3f))
		}
		else if (charcode < 0xd800 || charcode >= 0xe000) {
			utf8.push(0xe0 | (charcode >> 12),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
		// surrogate pair
		else {
			i++;
			// UTF-16 encodes 0x10000-0x10FFFF by
			// subtracting 0x10000 and splitting the
			// 20 bits of 0x0-0xFFFFF into two halves
			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
			| (str.charCodeAt(i) & 0x3ff))
			utf8.push(0xf0 | (charcode >>18),
			0x80 | ((charcode>>12) & 0x3f),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
	}

	return new Uint8Array(utf8)
}

/**
 * XXH object used as a constructor or a function
 * @constructor
 * or
 * @param {Object|String} input data
 * @param {Number|UINT32} seed
 * @return ThisExpression
 * or
 * @return {UINT32} xxHash
 */
function XXH () {
	if (arguments.length == 2)
		return new XXH( arguments[1] ).update( arguments[0] ).digest()

	if (!(this instanceof XXH))
		return new XXH( arguments[0] )

	init.call(this, arguments[0])
}

/**
 * Initialize the XXH instance with the given seed
 * @method init
 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
 * @return ThisExpression
 */
 function init (seed) {
	this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed)
	this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2)
	this.v2 = this.seed.clone().add(PRIME32_2)
	this.v3 = this.seed.clone()
	this.v4 = this.seed.clone().subtract(PRIME32_1)
	this.total_len = 0
	this.memsize = 0
	this.memory = null

	return this
}
XXH.prototype.init = init

/**
 * Add data to be computed for the XXH hash
 * @method update
 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
 * @return ThisExpression
 */
XXH.prototype.update = function (input) {
	var isString = typeof input == 'string'
	var isArrayBuffer

	// Convert all strings to utf-8 first (issue #5)
	if (isString) {
		input = toUTF8Array(input)
		isString = false
		isArrayBuffer = true
	}

	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
	{
		isArrayBuffer = true
		input = new Uint8Array(input);
	}

	var p = 0
	var len = input.length
	var bEnd = p + len

	if (len == 0) return this

	this.total_len += len

	if (this.memsize == 0)
	{
		if (isString) {
			this.memory = ''
		} else if (isArrayBuffer) {
			this.memory = new Uint8Array(16)
		} else {
			this.memory = new Buffer(16)
		}
	}

	if (this.memsize + len < 16)   // fill in tmp buffer
	{
		// XXH_memcpy(this.memory + this.memsize, input, len)
		if (isString) {
			this.memory += input
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, len), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, len )
		}

		this.memsize += len
		return this
	}

	if (this.memsize > 0)   // some data left from previous update
	{
		// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
		if (isString) {
			this.memory += input.slice(0, 16 - this.memsize)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, 16 - this.memsize )
		}

		var p32 = 0
		if (isString) {
			this.v1.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v2.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v3.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v4.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
		} else {
			this.v1.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v2.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v3.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v4.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
		}

		p += 16 - this.memsize
		this.memsize = 0
		if (isString) this.memory = ''
	}

	if (p <= bEnd - 16)
	{
		var limit = bEnd - 16

		do
		{
			if (isString) {
				this.v1.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v2.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v3.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v4.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
			} else {
				this.v1.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v2.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v3.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v4.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
			}
			p += 4
		} while (p <= limit)
	}

	if (p < bEnd)
	{
		// XXH_memcpy(this.memory, p, bEnd-p);
		if (isString) {
			this.memory += input.slice(p)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(p, bEnd), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, p, bEnd )
		}

		this.memsize = bEnd - p
	}

	return this
}

/**
 * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
 * @method digest
 * @return {UINT32} xxHash
 */
XXH.prototype.digest = function () {
	var input = this.memory
	var isString = typeof input == 'string'
	var p = 0
	var bEnd = this.memsize
	var h32, h
	var u = new UINT32

	if (this.total_len >= 16)
	{
		h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) )
	}
	else
	{
		h32  = this.seed.clone().add( PRIME32_5 )
	}

	h32.add( u.fromNumber(this.total_len) )

	while (p <= bEnd - 4)
	{
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			)
		}
		h32
			.add( u.multiply(PRIME32_3) )
			.rotl(17)
			.multiply( PRIME32_4 )
		p += 4
	}

	while (p < bEnd)
	{
		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 )
		h32
			.add( u.multiply(PRIME32_5) )
			.rotl(11)
			.multiply(PRIME32_1)
	}

	h = h32.clone().shiftRight(15)
	h32.xor(h).multiply(PRIME32_2)

	h = h32.clone().shiftRight(13)
	h32.xor(h).multiply(PRIME32_3)

	h = h32.clone().shiftRight(16)
	h32.xor(h)

	// Reset the state
	this.init( this.seed )

	return h32
}

module.exports = XXH

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
xxHash64 implementation in pure Javascript

Copyright (C) 2016, Pierre Curto
MIT license
*/
var UINT64 = __webpack_require__(104).UINT64

/*
 * Constants
 */
var PRIME64_1 = UINT64( '11400714785074694791' )
var PRIME64_2 = UINT64( '14029467366897019727' )
var PRIME64_3 = UINT64(  '1609587929392839161' )
var PRIME64_4 = UINT64(  '9650029242287828579' )
var PRIME64_5 = UINT64(  '2870177450012600261' )

/**
* Convert string to proper UTF-8 array
* @param str Input string
* @returns {Uint8Array} UTF8 array is returned as uint8 array
*/
function toUTF8Array (str) {
	var utf8 = []
	for (var i=0, n=str.length; i < n; i++) {
		var charcode = str.charCodeAt(i)
		if (charcode < 0x80) utf8.push(charcode)
		else if (charcode < 0x800) {
			utf8.push(0xc0 | (charcode >> 6),
			0x80 | (charcode & 0x3f))
		}
		else if (charcode < 0xd800 || charcode >= 0xe000) {
			utf8.push(0xe0 | (charcode >> 12),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
		// surrogate pair
		else {
			i++;
			// UTF-16 encodes 0x10000-0x10FFFF by
			// subtracting 0x10000 and splitting the
			// 20 bits of 0x0-0xFFFFF into two halves
			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
			| (str.charCodeAt(i) & 0x3ff))
			utf8.push(0xf0 | (charcode >>18),
			0x80 | ((charcode>>12) & 0x3f),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
	}

	return new Uint8Array(utf8)
}

/**
 * XXH64 object used as a constructor or a function
 * @constructor
 * or
 * @param {Object|String} input data
 * @param {Number|UINT64} seed
 * @return ThisExpression
 * or
 * @return {UINT64} xxHash
 */
function XXH64 () {
	if (arguments.length == 2)
		return new XXH64( arguments[1] ).update( arguments[0] ).digest()

	if (!(this instanceof XXH64))
		return new XXH64( arguments[0] )

	init.call(this, arguments[0])
}

/**
 * Initialize the XXH64 instance with the given seed
 * @method init
 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
 * @return ThisExpression
 */
 function init (seed) {
	this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed)
	this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2)
	this.v2 = this.seed.clone().add(PRIME64_2)
	this.v3 = this.seed.clone()
	this.v4 = this.seed.clone().subtract(PRIME64_1)
	this.total_len = 0
	this.memsize = 0
	this.memory = null

	return this
}
XXH64.prototype.init = init

/**
 * Add data to be computed for the XXH64 hash
 * @method update
 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
 * @return ThisExpression
 */
XXH64.prototype.update = function (input) {
	var isString = typeof input == 'string'
	var isArrayBuffer

	// Convert all strings to utf-8 first (issue #5)
	if (isString) {
		input = toUTF8Array(input)
		isString = false
		isArrayBuffer = true
	}

	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
	{
		isArrayBuffer = true
		input = new Uint8Array(input);
	}

	var p = 0
	var len = input.length
	var bEnd = p + len

	if (len == 0) return this

	this.total_len += len

	if (this.memsize == 0)
	{
		if (isString) {
			this.memory = ''
		} else if (isArrayBuffer) {
			this.memory = new Uint8Array(32)
		} else {
			this.memory = new Buffer(32)
		}
	}

	if (this.memsize + len < 32)   // fill in tmp buffer
	{
		// XXH64_memcpy(this.memory + this.memsize, input, len)
		if (isString) {
			this.memory += input
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, len), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, len )
		}

		this.memsize += len
		return this
	}

	if (this.memsize > 0)   // some data left from previous update
	{
		// XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);
		if (isString) {
			this.memory += input.slice(0, 32 - this.memsize)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, 32 - this.memsize )
		}

		var p64 = 0
		if (isString) {
			var other
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
		} else {
			var other
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
		}

		p += 32 - this.memsize
		this.memsize = 0
		if (isString) this.memory = ''
	}

	if (p <= bEnd - 32)
	{
		var limit = bEnd - 32

		do
		{
			if (isString) {
				var other
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			} else {
				var other
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			}
			p += 8
		} while (p <= limit)
	}

	if (p < bEnd)
	{
		// XXH64_memcpy(this.memory, p, bEnd-p);
		if (isString) {
			this.memory += input.slice(p)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(p, bEnd), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, p, bEnd )
		}

		this.memsize = bEnd - p
	}

	return this
}

/**
 * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed
 * @method digest
 * @return {UINT64} xxHash
 */
XXH64.prototype.digest = function () {
	var input = this.memory
	var isString = typeof input == 'string'
	var p = 0
	var bEnd = this.memsize
	var h64, h
	var u = new UINT64

	if (this.total_len >= 32)
	{
		h64 = this.v1.clone().rotl(1)
		h64.add( this.v2.clone().rotl(7) )
		h64.add( this.v3.clone().rotl(12) )
		h64.add( this.v4.clone().rotl(18) )

		h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)
	}
	else
	{
		h64  = this.seed.clone().add( PRIME64_5 )
	}

	h64.add( u.fromNumber(this.total_len) )

	while (p <= bEnd - 8)
	{
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
			,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			,	(input[p+5] << 8) | input[p+4]
			,	(input[p+7] << 8) | input[p+6]
			)
		}
		u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1)
		h64
			.xor(u)
			.rotl(27)
			.multiply( PRIME64_1 )
			.add( PRIME64_4 )
		p += 8
	}

	if (p + 4 <= bEnd) {
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			,	0
			,	0
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			,	0
			,	0
			)
		}
		h64
			.xor( u.multiply(PRIME64_1) )
			.rotl(23)
			.multiply( PRIME64_2 )
			.add( PRIME64_3 )
		p += 4
	}

	while (p < bEnd)
	{
		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 )
		h64
			.xor( u.multiply(PRIME64_5) )
			.rotl(11)
			.multiply(PRIME64_1)
	}

	h = h64.clone().shiftRight(33)
	h64.xor(h).multiply(PRIME64_2)

	h = h64.clone().shiftRight(29)
	h64.xor(h).multiply(PRIME64_3)

	h = h64.clone().shiftRight(32)
	h64.xor(h)

	// Reset the state
	this.init( this.seed )

	return h64
}

module.exports = XXH64

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 271 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 272 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5NzllOTRhOWNhMTUwYTg0YWE2MiIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibi5qcy9saWIvYm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhc2guanMvbGliL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9taW5pbWFsaXN0aWMtYXNzZXJ0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9RdWV1ZS9RdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NpcGhlci1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQmluYXJ5VHJlZS9CaW5hcnlUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TdGFjay9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hc24xLmpzL2xpYi9hc24xL2Jhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIteG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL34vcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvYWVzLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vZXZwX2J5dGVzdG9rZXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1yc2EvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXItc2hpbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcmVhdGUtaG1hYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvSGVhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9Eb3VibGVMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L1N0YXRpY0xpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2V4Y2hhbmdlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9iYXNlL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9MaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3JhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9hdXRoQ2lwaGVyLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2JjLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjguanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9lY2IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9zdHJlYW1DaXBoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9hbGdvcml0aG1zLmpzb24iLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9jdXJ2ZXMuanNvbiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcmVhdGUtaGFzaC9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RpZmZpZS1oZWxsbWFuL2xpYi9nZW5lcmF0ZVByaW1lLmpzIiwid2VicGFjazovLy8uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21pbGxlci1yYWJpbi9saWIvbXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9taW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3Bia2RmMi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcHVibGljLWVuY3J5cHQvbWdmLmpzIiwid2VicGFjazovLy8uL34vcHVibGljLWVuY3J5cHQvd2l0aFB1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1YmxpYy1lbmNyeXB0L3hvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZUFycmF5LmpzIiwid2VicGFjazovLy8uL3NyYy9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dlbmVyYWxpemVkTGlzdC9HTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQU1MR3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dyYXBoL0FkamFjZW5jeUxpc3RHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQWRqYWNlbmN5TWF0cml4R3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dyYXBoL09MR3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTFJVLmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0xpbmVhckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1ZXVlL0N5Y2xlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1ZXVlL1ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9BVkxUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQlBsdXNUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQlRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CaW5hcnlTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CbG9vbUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0RpZ2l0YWxTZWFyY2hUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvSGFzaFRhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvUmVkQmxhY2tUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvU09TVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL1N1ZmZpeFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9maWJvbmFjY2lTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2Rpc3RyaWJ1dGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9pbnNlcnRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvbWVyZ2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0cmluZy9IU3RyaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9TdHJpbmcvTFN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RyaW5nL1NTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hc24xLmpzL2xpYi9hc24xL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9iYXNlL3JlcG9ydGVyLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL2VuY3J5cHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1jaXBoZXIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktZGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1kZXMvbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYWxnb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci92ZXJpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY3JlYXRlLWVjZGgvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyZWF0ZS1oYXNoL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2N1aW50L2xpYi91aW50MzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWludC9saWIvdWludDY0LmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvY2JjLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvZGVzLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvZWRlLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGlmZmllLWhlbGxtYW4vbGliL2RoLmpzIiwid2VicGFjazovLy8uL34vZGlmZmllLWhlbGxtYW4vbGliL3ByaW1lcy5qc29uIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9zaWduYXR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvcHJlY29tcHV0ZWQvc2VjcDI1NmsxLmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhc2guanMvbGliL2hhc2gvc2hhLmpzIiwid2VicGFjazovLy8uL34vaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2htYWMtZHJiZy9saWIvaG1hYy1kcmJnLmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2Flc2lkLmpzb24iLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2NlcnRpZmljYXRlLmpzIiwid2VicGFjazovLy8uL34vcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwid2VicGFjazovLy8uL34vcGJrZGYyL3ByZWNvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wdWJsaWMtZW5jcnlwdC9wcml2YXRlRGVjcnlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL34vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhMS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEyMjQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhMzg0LmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi92bS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34veHhoYXNoanMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34veHhoYXNoanMvbGliL3h4aGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h4aGFzaGpzL2xpYi94eGhhc2g2NC5qcyIsIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiXSwibmFtZXMiOlsiUXVldWUiLCJyZWFyIiwiZnJvbnQiLCJzaXplIiwiaXNFbXB0eSIsImNsZWFyIiwiZ2V0SGVhZCIsImRhdGEiLCJlblF1ZXVlIiwiZWxlbSIsIm5leHQiLCJwIiwiZGVRdWV1ZSIsImZvckVhY2giLCJpdGVyYXRvciIsIkVycm9yIiwiY3VycmVudCIsIlN5bWJvbCIsInBlZWtBdCIsImluZGV4IiwiaSIsInRvU3RyaW5nIiwiYXJyIiwibGVuIiwiQmluYXJ5VHJlZSIsImxlZnRDaGlsZCIsInJpZ2h0Q2hpbGQiLCJpc1NpbWlsYXIiLCJ0cmVlIiwiY3JlYXRlQmluYXJ5VHJlZSIsInByZU9yZGVyUmVjdXJzaXZlIiwibm9kZSIsIngiLCJ2aXNpdCIsInBhcmVudE5vZGUiLCJ2YWx1ZSIsIml0ZXJhdG9yVHlwZSIsInByZU9yZGVyTm9uUmVjdXJzaXZlIiwic3RhY2siLCJsZW5ndGgiLCJwdXNoIiwicG9wIiwiaW5PcmRlck5vblJlY3Vyc2l2ZSIsInBvc3RPcmRlck5vblJlY3Vyc2l2ZSIsImEiLCJpbk9yZGVyUmVjdXJzaXZlIiwicG9zdE9yZGVyUmVjdXJzaXZlIiwibGV2ZWxPcmRlclRyYXZlcnNlIiwicXVldWUiLCJnZXRQcmVTZXF1ZW5jZSIsImsiLCJjb3VudCIsInJlY3Vyc2UiLCJjb3VudExlYXZlcyIsInJldm9sdXRlQmluYXJ5VHJlZSIsInJldm9sdXRlTm9uUmVjdXJzaXZlIiwiZ2V0U3ViRGVwdGgiLCJnZXREZXB0aCIsIm0iLCJuIiwiZGVsU3ViWCIsImNvcHkiLCJjYiIsInN0YWNrMSIsInN0YWNrMiIsIkNzdHIiLCJjb25zdHJ1Y3RvciIsIm5ld1RyZWUiLCJxIiwicGVlayIsImZpbmROZWFyQW5jaWVudCIsInBOb2RlIiwicU5vZGUiLCJwYXRoUCIsImZpbmRQYXRoIiwicGF0aFEiLCJsdXNoRGVncmVlIiwiY291bnRBcnIiLCJsYXllciIsInIiLCJoZWlnaHQiLCJtYXgiLCJkZXNjTnVtIiwiZCIsImlzRnVsbEJpbmFyeVRyZWUiLCJmbGFnIiwicGF0aCIsImZvdW5kIiwiZ2xvYmFsIiwiRnVuY3Rpb24iLCJwcmludFBhdGhfbWF4RGVwdGhTMSIsIm1heGgiLCJmaW5kX2giLCJoIiwicyIsImNvbnNvbGUiLCJsb2ciLCJ0ZXN0IiwiUGFyZW50VHJlZSIsIm5vZGVzIiwibWF4RGVwdGgiLCJkZXAiLCJqIiwicGFyZW50IiwiUGFyZW50VHJlZU5vZGUiLCJwdCIsIkNoaWxkVHJlZSIsInNlbGYiLCJzdWJEZXB0aCIsInJvb3RJbmRleCIsInNkIiwiY2hpbGQiLCJDaGlsZFRyZWVCb3giLCJmaXJzdENoaWxkIiwiQ2hpbGRUcmVlTm9kZSIsIkNoaWxkU2libGluZ1RyZWUiLCJuZXh0U2libGluZyIsInByaW50IiwibGVhZkNvdW50IiwiZ2V0RGVncmVlIiwiZGVncmVlIiwibWF4ZCIsIlN0YWNrIiwidG9wIiwib3V0IiwiZGVmYXVsdENvbXBhcmUiLCJiIiwiSGVhcCIsImNvbXBhcmUiLCJkZWZhdWx0Q29tcHJlIiwiYWRkIiwiX3VwSGVhcEFkanVzdCIsInJlbW92ZSIsImhlYXAiLCJfZG93bkhlYXBBZGp1c3QiLCJ0ZW1wIiwiTWF0aCIsImNlaWwiLCJOb2RlIiwicHJldiIsIkRvdWJsZUxpbmtlZExpc3QiLCJzcUxpc3QiLCJoZWFkIiwidGFpbCIsIml0ZW0iLCJ1bnNoaWZ0Iiwic2hpZnQiLCJ1cGRhdGUiLCJmaW5kQnlJbmRleCIsImluZGV4T2YiLCJyZXR1cm5Ob2RlIiwidG9KU09OIiwibGlzdCIsIlN0YXRpY0xpbmtlZExpc3QiLCJNQVhTSVpFIiwiY3VyIiwiZmluZCIsImluaXQiLCJtYWxsb2MiLCJmcmVlIiwiY3JlYXRlIiwiZGlmZmVyZW5jZSIsInNsbGlzdCIsImFycjEiLCJhcnIyIiwic2wiLCJyZXQiLCJCU1ROb2RlIiwiYXJnIiwic2VhcmNoIiwia2V5Iiwic2VhcmNoTm9uUmVjdXJzaXZlIiwiaW5zZXJ0IiwiaW5zZXJ0Tm9uUmVjdXJzaXZlIiwiY3JlYXRlQlNUIiwidXNlTm9uUmVjdXJzaXZlIiwiZGVsZXRlTm9kZSIsInJlbW92ZU5vblJlY3Vyc2l2ZSIsImYiLCJmaW5kTmVpZ2hib3JFbGVtIiwibGFzdCIsIkluZmluaXR5IiwibWVyZ2UiLCJic3QiLCJpbnNlcnROb2RlIiwic3BsaXQiLCJpc0JTVFRyZWUiLCJwb3MiLCJic3QyIiwicHJpbnROb3RMZXNzVGhhbiIsImExIiwiYTIiLCJidWJibGVTb3J0IiwiYnViYmxlU29ydDIiLCJjb2NrVGFpbFNvcnQiLCJjb2NrVGFpbFNvcnQyIiwicXVpY2tTb3J0UmVjdXJzaXZlIiwicXVpY2tTb3J0UmVjdXJzaXZlMiIsInF1aWNrU29ydE5vblJlY3Vyc2l2ZSIsInF1aWNrU29ydCIsIm9kZEV2ZW5Tb3J0IiwiY29tcCIsImNoYW5nZSIsImMiLCJsb3ciLCJoaWdoIiwicGFydGl0aW9uMSIsInBhcnRpdGlvbjIiLCJyYW5kIiwiZmxvb3IiLCJyYW5kb20iLCJwaXZvdCIsInBhcnRpdGlvbiIsImVhc3lTb3J0IiwiUkVEIiwiV0hJVEUiLCJCTFVFIiwiZmxhZ0FycmFuZ2UiLCJjb2xvcnMiLCJMaW5rZWRMaXN0IiwibWVyZ2VMaXN0IiwiY29tcEZuIiwiaGEiLCJoYiIsInBhIiwicGIiLCJkYXRhMSIsImRhdGEyIiwiYXBwZW5kIiwicHJldmlvdXMiLCJpbnNlcnRBZnRlciIsInRhcmdldCIsImNhbGxiYWNrIiwic3RyIiwib3JkZXJJbnNlcnQiLCJjbXAiLCJtZSIsImluc2VydEJldHdlZW4iLCJkZWxldGVCZXR3ZWVuIiwibWluIiwiZGVsZXRlRXF1YWwiLCJyZXZlcnNlIiwiaHVmZk1hbkNvZGluZyIsIkh1ZmZtYW5Ob2RlIiwid2VpZ2h0Iiwid2VpZ2h0cyIsImh1ZmZtYW5UcmVlIiwiYnVpbGRIdWZmbWFuVHJlZSIsImhjIiwiY2FsY0h1ZmZtYW5Db2RlIiwiY2QiLCJzdGFydCIsInN0ckNvcHkiLCJzZWxlY3QiLCJzMSIsInMyIiwiQVRPTSIsIkxJU1QiLCJHTE5vZGUiLCJ0YWciLCJ1bmRlZmluZWQiLCJhdG9tIiwicHRyIiwiaHAiLCJ0cCIsImRlcHRoIiwiY29weUxpc3QiLCJnTGlzdCIsImNyZWF0ZUdMaXN0Iiwic3RyaW5nIiwidHJpbSIsImlzV29yZCIsInN1YiIsInN1YnN0ciIsImhzdWIiLCJjaCIsImVxdWFsIiwiZ0xpc3QxIiwiZ0xpc3QyIiwiY2FsbCIsIm9yZGVyUHJpbnQiLCJHTE5vZGUyIiwiTVBOb2RlIiwiZXhwIiwiY29lZiIsIlVOVklTSVRFRCIsIlZJU0lURUQiLCJFQm94IiwibWFyayIsIml2ZXgiLCJqdmV4IiwiaWxpbmsiLCJqbGluayIsImluZm8iLCJBTUxWZXhCb3giLCJmaXJzdEVkZ2UiLCJBTUxHcmFwaCIsImFkak11bGlzdCIsInZleG51bSIsImVkZ2VudW0iLCJsb2NhdGVWZXgiLCJ2IiwiZGVsZXRlQXJjIiwidyIsImNyZWF0ZUdyYXBoIiwicHJvbXB0IiwidCIsImVycm9yIiwiREciLCJETiIsIlVERyIsIlVETiIsIkFyY05vZGUiLCJhZGpWZXgiLCJuZXh0QXJjIiwiVmV4Tm9kZSIsImZpcnN0QXJjIiwiaW5kZWdyZWUiLCJBZGphY2VuY3lMaXN0R3JhcGgiLCJ2ZXJ0aWNlcyIsImFyY251bSIsImtpbmQiLCJ2cCIsImFkZFZlcnRleCIsImFkZEFyYyIsImFyYzEiLCJhcmMyIiwiaW5jSW5mbyIsImFsZXJ0IiwiaXNQYXNzIiwieSIsInoiLCJpc0FkaiIsImV4aXN0UGF0aERGUyIsInZpc2l0ZWQiLCJleGlzdF9wYXRoIiwiZ3JhcGgiLCJleGlzdFBhdGhCRlMiLCJ1IiwiZXhpc3RQYXRoTGVuIiwibCIsImZpbmRBbGxQYXRocyIsImdldFBhdGhOdW1fbGVuIiwic3VtIiwiZ2V0Um9vdCIsImRmcyIsImdldExvbmdlc3RQYXRoIiwibWxwIiwibWF4TGVuIiwiY291bnRJbmRlZ3JlZSIsImpvaW4iLCJERlNUcmF2ZXJzZSIsInZpc2l0Rm4iLCJERlNUcmF2ZXJzZV9Ob25SZWN1cnNlIiwiQkZTVHJhdmVyc2UiLCJjcmVhdGVERlNGb3Jlc3QiLCJERlNUcmVlIiwiZmlyc3QiLCJjcmVhdGVCRlNGb3Jlc3QiLCJwcmUiLCJub2RlMiIsImZpbmRBcnRpY3VsIiwiREZTQXJ0aWN1bCIsInYwIiwidG9wb2xvZ2ljU29ydCIsInRvcG9sb2dpY2FsT3JkZXIiLCJjcml0aWNhbFBhdGgiLCJ2ZSIsInZsIiwic2hvcnRlc3RQYXRoX0RpamtzdHJhIiwiZGlzdCIsImZpbmFsIiwiYWRqTGlzdEdyYXBoIiwiZyIsImcyIiwiYXJ0aWN1bFRlc3QiLCJ0b3BvbG9naWNUZXN0IiwiY3JpdGljYWxQYXRoVGVzdCIsImRpalRlc3QiLCJuaUJvTGFuX0RBRyIsInByaW50TmlCb0xhbiIsImV2YWx1YXRlX0RBRyIsImV2YWx1YXRlX2ltcCIsInYxIiwidjIiLCJjYWxjdWxhdGUiLCJvcGVyYXRpb24iLCJldmFsIiwiZGFnIiwiU3RyaW5nIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsIkFyY0NlbGwiLCJhZGoiLCJBZGphY2VuY3lNYXRyaXhHcmFwaCIsInZleHMiLCJhcmNzIiwiY3JlYXRlREciLCJjcmVhdGVETiIsImNyZWF0ZVVERyIsImNyZWF0ZVVETiIsInZleDEiLCJ2ZXgyIiwiYXJjIiwiZGVsZXRlVmV4IiwidmV4IiwiZmlyc3RBZGpWZXgiLCJuZXh0QWRqVmV4IiwidmVydGV4IiwibWluU3BhblRyZWVfUFJJTSIsImNsb3NlZGdlIiwiYWRqdmV4IiwibG93Y29zdCIsInRlIiwibWluU3BhblRyZWVfS3J1c2thbCIsInNldCIsInNob3J0ZXN0UGF0aF9GTE9ZRCIsInBybl9wYXNzIiwic2V0TWF0cml4VmFsdWUiLCJwYXJzZUludCIsInVkbiIsImRuIiwiZzEiLCJic2ZHIiwiZmxveWQiLCJPTEdyYXBoIiwiQXJjQm94IiwidGFpbFZleCIsImhlYWRWZXgiLCJoTGluayIsInRMaW5rIiwiT0xWZXhOb2RlIiwiZmlyc3RJbiIsImZpcnN0T3V0IiwieExpc3QiLCJwcm90b3R5cGUiLCJkZWxldGVWZXJ0ZXgiLCJnZXRTR3JhcGgiLCJmaW5pc2hlZCIsImRmczEiLCJkZnMyIiwiY29ubmVjdGVkX0RHIiwiaW5fb3JkZXIiLCJyZXZfZGZzIiwiTElNSVQiLCJMUlVDYWNoZSIsImxpbWl0Iiwic2xpY2UiLCJfX2NhY2hlIiwiX19fY2FjaGUiLCJnZXQiLCJ1bmlvbiIsImRlbCIsImxpc3RDb21wIiwiaW50ZXJzZWN0IiwiaW50ZXJzZWN0X3RydWUiLCJpbnRlcnNlY3RfZGVsZXRlIiwiYkxlbiIsImFMZW4iLCJhRWxlbSIsImJFbGVtIiwiYUxpc3QiLCJiTGlzdCIsImNMaXN0Iiwic3BsaWNlIiwic2FtZSIsIkN5Y2xlUXVldWUiLCJtYXhzaXplIiwiYmFzZSIsIk1BWFFTSVpFIiwicXVldWVUcmF2ZXJzZSIsIlByaW9yaXR5UXVldWUiLCJwcmlvcml0eSIsIm9iaiIsIm9iamVjdCIsImxlZnQiLCJyaWdodCIsIkF2bFRyZWUiLCJyb290IiwiX2FkZExlZnQiLCJfYWRkUmlnaHQiLCJuZXdOb2RlIiwiX2JhbGFuY2UiLCJfYmFsYW5jZUxlZnRSaWdodCIsImxlZnRMZWZ0IiwiX2JhbGFuY2VMZWZ0TGVmdCIsIl9iYWxhbmNlUmlnaHRMZWZ0IiwicmlnaHRSaWdodCIsIl9iYWxhbmNlUmlnaHRSaWdodCIsImxlZnRIZWlnaHQiLCJyaWdodEhlaWdodCIsIm5ld0hlaWdodCIsIl9yZW1vdmUiLCJyZXBsYWNlbWVudCIsImJhbGFuY2VGcm9tIiwicmVtb3ZlQnlSZWYiLCJnZXRGaXJzdCIsImdldExhc3QiLCJnZXRIZWlnaHQiLCJnZXRDb3VudCIsInByb2Nlc3NpbmdGdW5jIiwicGFyYW1zIiwiZm9yRWFjaFJldmVyc2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNEZWZpbmVkIiwib3B0aW9ucyIsIm9yZGVyIiwibWVyZ2VUaHJlc2hvbGQiLCJnZXRMZWZ0UGVlciIsImxlZnRQZWVyIiwic2V0TGVmdFBlZXIiLCJnZXRSaWdodFBlZXIiLCJyaWdodFBlZXIiLCJzZXRSaWdodFBlZXIiLCJnZXREYXRhIiwiZ2V0U3VycGx1cyIsImdldFJpZ2h0U3VycGx1c0RhdGEiLCJzdXJwbHVzIiwiZ2V0TGVmdFN1cnBsdXNEYXRhIiwiSW50ZXJuYWxOb2RlIiwiT2JqZWN0IiwiZmluZEluZGV4IiwibWlkIiwiZmluZENoaWxkIiwiZWxlbWVudCIsImNsb2JiZXIiLCJuZXdOb2RlcyIsImxlZnRFbGVtZW50IiwicmlnaHRFbGVtZW50Iiwic3BsaXRJbmRleCIsImxlZnROb2RlIiwicmlnaHROb2RlIiwibGVmdE1lcmdlT3B0aW9uIiwicmlnaHRNZXJnZU9wdGlvbiIsIm1lcmdlSW5kZXgiLCJyZXR2YWwiLCJtZXJnZUVsZW1lbnQiLCJjb25jYXQiLCJsZWZ0U3VycGx1cyIsImxlZnREYXRhIiwicmlnaHRTdXJwbHVzIiwicmlnaHREYXRhIiwibGVmdFN1cnBsdXNEYXRhIiwicmlnaHRTdXJwbHVzRGF0YSIsIm1lcmdlZEludGVybmFsTm9kZSIsInJhbmdlIiwiZW5kIiwiaW5kZW50IiwibWFwIiwiTGVhZk5vZGUiLCJtZXJnZWRMZWFmTm9kZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIm5vZGVEYXRhIiwiVHJlZSIsImRlZmluZSIsInZhcl9hcmdzIiwiYXJndW1lbnRzIiwiQXJyYXkiLCJhcHBseSIsImFzZWFyY2giLCJidHJlZSIsInN0cmNtcCIsImFjIiwiYmMiLCJjaGFyQ29kZUF0IiwibnVtY21wIiwiaW50Y21wIiwibWluT3JkZXIiLCJ2YWxpZGF0ZSIsImxlYXZlcyIsIlRyZWVOb2RlIiwibGVhZiIsInJlc3VsdCIsInB1dCIsIm92ZXJ3cml0ZSIsIkxlYWYiLCJiYWxhbmNlIiwic2VwIiwicmVzdCIsInN1YnN0IiwidW5zcGxpdCIsImluY2x1ZGVOb2RlcyIsInZhbCIsInNwYWNlIiwid2Fsa0FzYyIsIm1pbktleSIsIm1heEtleSIsIndhbGsiLCJ3YWxrRGVzYyIsImJpbmFyeVNlYXJjaCIsImJpbmFyeVNlYXJjaFJlY3Vyc2l2ZSIsInNUYWJsZSIsIkxOMl9TUVVBUkVEIiwiTE4yIiwiQmxvb21GaWx0ZXIiLCJzZWVkcyIsImhhc2hlcyIsIl9nZW5lcmF0ZVNlZWRzIiwiYml0cyIsImJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwib3B0aW1pemUiLCJpdGVtQ291bnQiLCJlcnJvclJhdGUiLCJyb3VuZCIsImNyZWF0ZU9wdGltYWwiLCJvcHRzIiwiZmlsbCIsImJ1ZiIsInJlYWRVSW50MzJMRSIsImlzQXJyYXkiLCJmcm9tIiwiaGFzaCIsImJpdCIsIl9zZXRCaXQiLCJoYXMiLCJpc0luU2V0IiwiX2dldEJpdCIsImJpdEZpZWxkIiwiZmlsdGVyIiwiQ291bnRpbmdCbG9vbUZpbHRlciIsIm92ZXJmbG93IiwiX3VuU2V0Qml0IiwiaXNCdWZmZXIiLCJMRUFGIiwiQlJBTkNIIiwiVEVSTUlOQUwiLCJEb3VibGVMaW5rZWRUcmVlIiwic3ltYm9sIiwic3lub1NlYXJjaCIsInN1Y2Nlc3MiLCJ0b0xvd2VyQ2FzZSIsInJlbW92ZU5vZGUiLCJ0cmllTm9kZSIsImJyYW5jaCIsIm51bSIsImhhc093blByb3BlcnR5IiwicGFyZW50Tm9kZXMiLCJUcmllVHJlZSIsImhhc2hTaXplIiwiYnVpbGRIYXNoU2l6ZSIsIkhhc2hUYWJsZSIsInNpemVJbmRleCIsImNvbGxpc2lvbiIsImNvbGxpc2lvblRpbWVzIiwiZXJyb3Jtc2ciLCJyZWNyZWF0ZUhhc2hUYWJsZSIsImFicyIsInRpbWVzIiwiaXNQcmltZSIsImJlZ2luIiwiTGlua2VkTGlzdEhhc2hUYWJsZSIsImhOb2RlcyIsInRlc3QyIiwiQkxBQ0siLCJSZWRCbGFja05vZGUiLCJjb2xvciIsIlJlZEJsYWNrTGVhZiIsIlJlZEJsYWNrVHJlZSIsIm5pbCIsIl9hZGRGaXh1cCIsImxlZnRBZGRGaXh1cCIsInJpZ2h0QWRkRml4dXAiLCJzdWNjZXNzb3IiLCJfcmVtb3ZlRml4dXAiLCJyZW1vdmVOb2RlMiIsIm9yaWdpbmFsWUNvbG9yIiwiX3RyYW5zcGxhbnQiLCJsZWZ0UmVtb3ZlRml4dXAiLCJyaWdodFJlbW92ZUZpeHVwIiwiX3JvdGF0ZUxlZnQiLCJyb3RhdGUiLCJfcm90YXRlUmlnaHQiLCJkaXIiLCJjMSIsImMyIiwiYWRkRml4dXAiLCJyb3RhdGUxIiwicm90YXRlMiIsInJlbW92ZUZpeHVwIiwicjEiLCJyMiIsInNlY29uZE9wdGltYWwiLCJjcmVhdGVTT1NUcmVlIiwic1dlaWdodHMiLCJkdyIsImVsZW1zIiwic3ciLCJmaW5kU1ciLCJzb3NUcmVlIiwic3VmZml4Tm9kZSIsIkVkZ2UiLCJmaXJzdENoYXJJbmRleCIsImxhc3RDaGFySW5kZXgiLCJzb3VyY2VOb2RlSW5kZXgiLCJkZXN0Tm9kZUluZGV4IiwiU3VmZml4IiwiU3VmZml4VHJlZSIsImNhc2VJbnNlbnNpdGl2ZSIsIk4iLCJlZGdlcyIsImFjdGl2ZSIsImFkZFByZWZpeCIsImN1cnJlbnRJbmRleCIsInZhbHVlcyIsInNvcnQiLCJlZGdlIiwic3Vic3RyaW5nIiwibGFzdFBhcmVudE5vZGUiLCJlIiwiZXhwbGljaXQiLCJfc3BsaXRFZGdlIiwiX2luc2VydEVkZ2UiLCJfY2Fub25pemVTdWZmaXgiLCJfcmVtb3ZlRWRnZSIsInN1ZmZpeCIsImN1cnJlbnROb2RlIiwibG4iLCJ0cmVlMiIsInRyZWUzIiwiZmlib25hY2NpU2VhcmNoIiwiZmliIiwiZjAiLCJmMSIsImYyIiwic2VxdWVudGlhbFNlYXJjaCIsImNvdW50U29ydCIsInJhZGl4U29ydCIsIm1heEVsZW0iLCJtYXhCaXQiLCJyYWRpeCIsIkJVQ0tFVFNOVU0iLCJidWNrZXRTb3J0IiwiYnVja2V0QSIsImJ1Y2tldCIsInN0cmFpZ2h0SW5zZXJ0U29ydCIsImJpbmFyeUluc2VydFNvcnQiLCJwYXRoMkluc2VydFNvcnQiLCJzdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydCIsInNoZWxsU29ydCIsImFycmFuZ2UiLCJzaGVsbEluc2VydCIsImRrIiwiZGVsdGEiLCJjcmVhdGVEZWx0YSIsInBvdyIsIm1lcmdlU29ydFJlY3Vyc2l2ZSIsIm1lcmdlU29ydE5vblJlY3Vyc2l2ZSIsIm5hdHVyZU1lcmdlU29ydCIsIm5Db3VudCIsIm5vblJlY3Vyc2l2ZUNvdW50IiwicmVjdXJzaXZlQ291bnQiLCJzciIsImUxIiwiZTIiLCJwYXNzIiwicmVjIiwibmF0dXJhbE1lcmdlU29ydCIsIm1lcmdlUnVucyIsImFzYyIsImxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0IiwibWVyZ2VTb3J0IiwibGlua2VkbGlzdCIsIm5lZWRSZXBsYWNlIiwibGlua2VkTGlzdCIsInNpbXBsZVNlbGVjdGlvblNvcnQiLCJoZWFwU29ydCIsImhlYXBBZGp1c3QiLCJyYyIsIkhTdHJpbmciLCJzdHJJbnNlcnQiLCJwb3NpdGlvbiIsInRIU3RyaW5nIiwic3RyaW5nQ29weSIsInN0ckFzc2lnbiIsImNoYXJzIiwic3RyTGVuZ3RoIiwic3RyQ29tcGFyZSIsImNsZWFyU3RyaW5nIiwiZGVzdGluYXRpb24iLCJkZXN0U3RhcnQiLCJ0YXJnZXRTdGFydCIsIkNodW5rIiwiY2h1bmtTaXplIiwiTFN0cmluZyIsInRMU3RyaW5nIiwiY3VyVCIsInRMU3RpbmciLCJjb3B5U3RyaW5nIiwiZmluZFBvc0NodW5rIiwiY3VyUyIsIm91dGVybG9vcCIsImxTdHJpbmciLCJjdXJEIiwiY3VyclQiLCJvZmZzZXQiLCJwYWxpbmRyb21lIiwibFN0ciIsIlNTdHJpbmciLCJNQVhTVFJMRU4iLCJjb3B5U3RyMlQiLCJyZXBsYWNlIiwic3N0cmluZyIsImttcEluZGV4IiwiZ2V0TmV4dCIsInN1YnRyYWN0IiwiZGVsZXRlX3N1YnN0cmluZyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiQmluYXJ5VHJlZUFycmF5IiwiR2VuZXJhbGl6ZWRMaXN0IiwiR3JhcGgiLCJMaXN0IiwiTGluZWFyTGlzdCIsIlNlYXJjaCIsIkFWTFRyZWUiLCJCaW5hcnlTb3J0ZWRUcmVlIiwiQlBsdXNUcmVlIiwiQlRyZWUiLCJEaWdpdGFsU2VhcmNoVHJlZSIsIlNPU1RyZWUiLCJTb3J0IiwiZGlzdHJpYnV0aW9uIiwiZXhjaGFuZ2UiLCJpbnNlcnRpb24iLCJtZXJnaW5nIiwic2VsZWN0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzV2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDUkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7O0FBRUEsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixXQUFXO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1Qjs7QUFFQSxrQ0FBa0M7QUFDbEMsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7QUNsMkdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ1pBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHOzs7Ozs7QUMxQkQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdDOzs7Ozs7QUNIdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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OztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEU7Ozs7OztBQ05BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNKQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDekdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEU7Ozs7Ozs7QUNoQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzhDQ3ZDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQzs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNuVUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQzs7QUFF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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDUEEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsRTs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDTkE7QUFD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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDZFQUE2RTtBQUN4SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzU2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QixRQUFRLFFBQVE7O0FBRWhCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNySUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6bkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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QUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkJBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtB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QUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3REQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBOzs7Ozs7O0FDL1BBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNqQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0WEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ2hiQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHVDQUF1QztBQUN2QyxlQUFlOztBQUVmLHFCQUFxQixpQkFBaUI7QUFDdEM7O0FBRUEsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbkxBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssZUFBZTtBQUNwQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDejZCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUM1TUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEhBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0SUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFVBQVUscUJBQXFCO0FBQy9CLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSwyQkFBMkI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ3JIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBLFVBQVUsWUFBWTtBQUN0QixVQUFVLE1BQU07QUFDaEIsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMvRkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsYUFBYTtBQUN2QixVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzN3QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFOzs7Ozs7QUN6SEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDMUZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5Qzs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9DQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLFFBQVEsY0FBYztBQUN0Qiw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsT0FBTyxjQUFjO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaFFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7OztBQ2xGQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDekhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzlGQTs7Ozs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDL0RBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBLG1DQUFrQztBQUNsQyxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtB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S0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6TEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QixRQUFRLFFBQVE7O0FBRWhCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QixRQUFRLFFBQVE7O0FBRWhCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdkRBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIs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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcFlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM2JBLGU7Ozs7OztBQ0FBLGUiLCJmaWxlIjoiLi9EUy1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRTXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRTXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTU2KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5NzllOTRhOWNhMTUwYTg0YWE2MiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZicgKyAnZmVyJykuQnVmZmVyO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4IChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciA8PD0gNDtcblxuICAgICAgLy8gJ2EnIC0gJ2YnXG4gICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG4gICAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQScgLSAnRidcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG4gICAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgfD0gYyAmIDB4ZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgLy8gU2NhbiAyNC1iaXQgY2h1bmtzIGFuZCBhZGQgdGhlbSB0byB0aGUgbnVtYmVyXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDYsIGogPSAwOyBpID49IHN0YXJ0OyBpIC09IDYpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIC8vIE5PVEU6IGAweDNmZmZmZmAgaXMgaW50ZW50aW9uYWwgaGVyZSwgMjZiaXRzIG1heCBzaGlmdCArIDI0Yml0IGhleCBsaW1iXG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIH1cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9O1xuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG4gICAgdmFyIGIsIGk7XG4gICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbaV0gPSBiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnN0cmlwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibi5qcy9saWIvYm4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGFzaC5qcy9saWIvaGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOmYn+WIl1F1ZXVlXG4gKlxuICog6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye677yIZmlyc3QgaW4gZmlyc3Qgb3V0LCBGSUZP77yJ55qE57q/5oCn6KGo44CC5a6D5Y+q5YWB6K645Zyo6KGo55qE5LiA56uv6L+b6KGM5o+S5YWl77yM6ICM5Zyo5Y+m5LiA56uv5Yig6Zmk5YWD57Sg44CCXG4gKiDlhYHorrjmj5LlhaXnmoTkuIDnq6/lj6vpmJ/lsL7vvIhyZWFy77yJ77yM5YWB6K645Yig6Zmk55qE5LiA56uv5Y+r6Zif5aS077yIZnJvbnTvvInjgIJcbiAqL1xuXG4vLyDpk77pmJ/liJdcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhciA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbnQgPyB0aGlzLmZyb250LmRhdGEgOiBudWxsO1xuICAgIH1cblxuICAgIGVuUXVldWUoZWxlbSkge1xuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IHsgZGF0YTogZWxlbSwgbmV4dDogbnVsbCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHAgPSB7IGRhdGE6IGVsZW0sIG5leHQ6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVhci5uZXh0ID0gcDtcbiAgICAgICAgICAgIHRoaXMucmVhciA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfVxuXG4gICAgZGVRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQpIHtcbiAgICAgICAgICAgIGxldCBlbGVtID0gdGhpcy5mcm9udC5kYXRhO1xuICAgICAgICAgICAgdGhpcy5mcm9udCA9IHRoaXMuZnJvbnQubmV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvckVhY2goaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3Igc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKGN1cnJlbnQuZGF0YSkpIGJyZWFrO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgeWllbGQgY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBlZWtBdChpbmRleCA9IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZnJvbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcnIgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnNpemU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1F1ZXVlL1F1ZXVlLmpzIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGlucHV0RW5jKVxuICB9XG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIGRvbmUoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9maW5hbCgpIHx8IG5ldyBCdWZmZXIoJycpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2lwaGVyLWJhc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxudmFyIHJtZDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG5cbmZ1bmN0aW9uIEhhc2hOb0NvbnN0cnVjdG9yKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG4gIHRoaXMuYnVmZmVycyA9IFtdXG59XG5cbmluaGVyaXRzKEhhc2hOb0NvbnN0cnVjdG9yLCBCYXNlKVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGRhdGEpXG59XG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVycylcbiAgdmFyIHIgPSB0aGlzLl9oYXNoKGJ1ZilcbiAgdGhpcy5idWZmZXJzID0gbnVsbFxuXG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIEhhc2goaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKCdtZDUnID09PSBhbGcpIHJldHVybiBuZXcgSGFzaE5vQ29uc3RydWN0b3IobWQ1KVxuICBpZiAoJ3JtZDE2MCcgPT09IGFsZyB8fCAncmlwZW1kMTYwJyA9PT0gYWxnKSByZXR1cm4gbmV3IEhhc2hOb0NvbnN0cnVjdG9yKHJtZDE2MClcblxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3JlYXRlLWhhc2gvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX3MgPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgbCA9IHRoaXMuX2xlbiArPSBkYXRhLmxlbmd0aFxuICB2YXIgcyA9IHRoaXMuX3MgfHwgMFxuICB2YXIgZiA9IDBcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuX2Jsb2NrXG5cbiAgd2hpbGUgKHMgPCBsKSB7XG4gICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICB2YXIgY2ggPSAodCAtIGYpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoOyBpKyspIHtcbiAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgfVxuXG4gICAgcyArPSBjaFxuICAgIGYgKz0gY2hcblxuICAgIGlmICgocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShidWZmZXIpXG4gICAgfVxuICB9XG4gIHRoaXMuX3MgPSBzXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICB2YXIgbCA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyBBcHBlbmQgdGhlIGJpdCAxIHRvIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAvLyBhbmQgdGhlbiBrIHplcm8gYml0cywgd2hlcmUgayBpcyB0aGUgc21hbGxlc3Qgbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobCArIDEgKyBrKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemUgKyAxKVxuXG4gIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgLy8gdG8gdGhpcyBhcHBlbmQgdGhlIGJsb2NrIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgbCB3cml0dGVuIGluIGJpbmFyeVxuICAvLyBUT0RPOiBoYW5kbGUgY2FzZSB3aGVyZSBsIGlzID4gTWF0aC5wb3coMiwgMjkpXG4gIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIHZhciBoYXNoID0gdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKSB8fCB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NoYS5qcy9oYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDmoJHnmoTkuIDkupvmpoLlv7VcbiAqXG4gKiDmoJHvvIhUcmVl77yJ5pivbu+8iG4+PTDvvInkuKrnu5PngrnnmoTmnInpmZDpm4bjgILlnKjku7vmhI/kuIDmo7XpnZ7nqbrmoJHkuK3vvJpcbiAqIO+8iDHvvInmnInkuJTku4XmnInkuIDkuKrnibnlrprnmoTnp7DkuLrmoLnvvIhSb29077yJ55qE57uT54K577ybXG4gKiDvvIgy77yJ5b2Tbj4x5pe277yM5YW25L2Z57uT54K55Y+v5YiG5Li6bShtPjAp5Liq5LqS5LiN55u45Lqk55qE5pyJ6ZmQ6ZuGVDEsVDIsVDMsLi4uVG3vvIzlhbbkuK3mr4/kuIDkuKrpm4blkIjmnKzouqvlj4jmmK/kuIDmo7XmoJHvvIzlubbkuJTnp7DkuLrmoLnnmoTlrZDmoJHvvIhTdWJ0cmVl77yJ44CCXG4gKlxuICog5L6L5aaC77yM77yIYe+8ieaYr+WPquacieS4gOS4quaguee7k+eCueeahOagke+8m1xuICog77yIYu+8ieaYr+aciTEz5Liq57uT54K555qE5qCR77yM5YW25LitQeaYr+ague+8jOWFtuS9mee7k+eCueWIhuaIkDPkuKrkupLkuI3nm7jkuqTnmoTlrZDpm4bvvJpUMT17QixFLEYsSyxMfSx0Mj17RCxILEksSixNfTtUMSxUMuWSjFQz6YO95piv5qC5QeeahOWtkOagke+8jOS4lOacrOi6q+S5n+aYr+S4gOajteagkeOAglxuICpcbiAqIOagkeeahOe7k+eCueWMheWQq+S4gOS4quaVsOaNruWFg+e0oOWPiuiLpeW5suaMh+WQkeWFtuWtkOagkeeahOWIhuaUr+OAgue7k+eCueaLpeacieeahOWtkOagkeaVsOensOS4uue7k+eCueeahOW6pu+8iERlZ3JlZe+8ieOAguS+i+Wmgu+8jO+8iGLvvInkuK1B55qE5bqm5Li6M++8jEPnmoTluqbkuLox77yMRueahOW6puS4ujAu5bqm5Li6MOeahOe7k+eCueensOS4uuWPtuWtkO+8iExlYWbvvInmiJbogIXnu4jnq6/nu5PngrnjgILluqbkuI3kuLow55qE57uT54K556ew5Li66Z2e57uI56uv57uT54K55oiW5YiG5pSv57uT54K544CC5qCR55qE5bqm5piv5qCR5YaF5ZCE57uT54K555qE5bqm55qE5pyA5aSn5YC844CC77yIYu+8ieeahOagkeeahOW6puS4ujMu57uT54K555qE5a2Q5qCR55qE5qC556ew5Li66K+l57uT54K555qE5a2p5a2Q77yIQ2hpbGTvvInjgILnm7jlupTnmoTvvIzor6Xnu5Pngrnnp7DkuLrlranlrZDnmoTlj4zkurLvvIhQYXJlbnTvvInjgILlkIzkuIDkuKrlj4zkurLnmoTlranlrZDkuYvpl7TkupLnp7DlhYTlvJ/vvIhTaWJsaW5n77yJ44CC57uT54K555qE56WW5YWI5piv5LuO5qC55Yiw6K+l57uT54K55omA57uP5YiG5pSv5LiK55qE5omA5pyJ57uT54K544CC5Y+N5LmL77yM5Lul5p+Q57uT54K55Li65qC555qE5a2Q5qCR5Lit55qE5Lu75LiA57uT54K56YO956ew5Li66K+l57uT54K555qE5a2Q5a2Z44CCXG4gKiDnu5PngrnnmoTlsYLmrKHvvIhMZXZlbO+8ieS7juagueW8gOWni+WumuS5iei1t++8jOagueS4uuesrOS4gOWxgu+8jOi3n+eahOWtqeWtkOS4uuesrOS6jOWxguOAguiLpeafkOe7k+eCueWcqOesrGzlsYLvvIzliJnlhbblrZDmoJHnmoTmoLnlsLHlnKjnrKxsKzHlsYLjgILlhbblj4zkurLlnKjlkIzkuIDlsYLnmoTnu5PngrnkupLkuLrloILlhYTlvJ/jgILkvovlpoLvvIznu5PngrlH5LiORe+8jEYsSCxJLErkupLkuLrloILlhYTlvJ/jgILmoJHkuK3nu5PngrnnmoTmnIDlpKflsYLmrKHnp7DkuLrmoJHnmoTmt7HluqbvvIhEZXB0aO+8ieaIlumrmOW6puOAgu+8iGLvvInnmoTmoJHnmoTmt7HluqbkuLo044CCXG4gKlxuICog5aaC5p6c5bCG5qCR5Lit57uT54K555qE5ZCE5a2Q5qCR55yL5oiQ5LuO5bem6Iez5Y+z5piv5pyJ5qyh5bqP55qE77yI5Y2z5LiN6IO95Lqk5o2i77yJ77yM5YiZ56ew6K+l5qCR5Li65pyJ5bqP5qCR77yM5ZCm5YiZ56ew5Li65peg5bqP5qCR44CC5Zyo5pyJ5bqP5qCR5Lit5pyA5bem6L6555qE5a2Q5qCR55qE5qC556ew5Li656ys5LiA5Liq5a2p5a2Q77yM5pyA5Y+z6L6555qE56ew5Li65pyA5ZCO5LiA5Liq5a2p5a2Q44CCXG4gKiDmo67mnpfvvIhGb3Jlc3TvvInmmK9t77yIbT49MO+8ieajteS6kuS4jeebuOS6pOeahOagkeeahOmbhuWQiOOAguWvueagkeS4reavj+S4que7k+eCueiAjOiogO+8jOWFtuWtkOagkeeahOmbhuWQiOWNs+S4uuajruael+OAglxuICpcbiAqXG4gKi9cblxuLyoqXG4gKiDkuozlj4nmoJHvvIhCaW5hcnkgVHJlZe+8ieaYr+WPpuS4gOenjeagkeWei+e7k+aehO+8jOWug+eahOeJueeCueaYr+avj+S4que7k+eCueiHs+WkmuWPquacieS4pOajteWtkOagke+8iOWNs+S6jOWPieagkeS4reS4jeWtmOWcqOW6puWkp+S6jjLnmoTnu5PngrnvvInvvIzlubbkuJTvvIzkuozlj4nmoJHnmoTlrZDmoJHmnInlt6blj7PkuYvliIbvvIjlhbbmrKHluo/kuI3og73ku7vmhI/poqDlgJLjgILvvIlcbiAqXG4gKiDkuozlj4nmoJHnmoTmgKfotKhcbiAqIDEu5Zyo5LqM5Y+J5qCR55qE56ysaeWxguS4iuiHs+WkmuaciTLnmoRpLTHmrKHmlrnkuKrnu5PngrkoaT49MSnjgIJcbiAqIDIu5rex5bqm5Li6a+eahOS6jOWPieagkeiHs+WkmuaciTLnmoRr5qyh5pa5LTHkuKrnu5PngrnvvIwoaz49MSnjgIJcbiAqIDMu5a+55Lu75L2V5LiA5qO15LqM5Y+J5qCRVO+8jOWmguaenOWFtue7iOerr+e7k+eCueaVsOS4um4w77yM5bqm5Li6MueahOe7k+eCueaVsOS4um4y77yM5YiZbjAgPSBuMiArIDE7XG4gKiAgICAgIOS4gOajtea3seW6puS4umvkuJTmnIky55qEa+asoeaWuS0x5Liq57uT54K555qE5LqM5Y+J5qCR56ew5Li65ruh5LqM5Y+J5qCR44CCXG4gKiAgICAgIOa3seW6puS4umvnmoTvvIzmnIlu5Liq57uT54K555qE5LqM5Y+J5qCR77yM5b2T5LiU5LuF5b2T5YW25q+P5LiA5Liq57uT54K56YO95LiO5rex5bqm5Li6a+eahOa7oeS6jOWPieagkeS4ree8luWPt+S7jjHoh7Nu55qE57uT54K55LiA5LiA5a+55bqU5pe277yM56ew5LmL5Li65a6M5YWo5LqM5Y+J5qCR44CCXG4gKiDkuIvpnaLmmK/lrozlhajkuozlj4nmoJHnmoTkuKTkuKrnibnmgKdcbiAqIDQu5YW35pyJbuS4que7k+eCueeahOWujOWFqOS6jOWPieagkeeahOa3seW6puS4uk1hdGguZmxvb3IobG9nIDIgbikgKyAxXG4gKiA1LuWmguaenOWvueS4gOajteaciW7kuKrnu5PngrnnmoTlrozlhajkuozlj4nmoJHvvIjlhbbmt7HluqbkuLpNYXRoLmZsb29yKGxvZyAyIG4pICsgMe+8ieeahOe7k+eCueaMieWxguW6j+e8luWPt++8iOS7juesrDHlsYLliLDnrKxNYXRoLmZsb29yKDIgbikgKyAx77yM5q+P5bGC5LuO5bem5Yiw5Y+z77yJ77yM5YiZ5a+55Lu75LiA57uT54K577yIMTw9aTw9bu+8ieacie+8mlxuICogICAgICgxKeWmguaenGk9Me+8jOWImee7k+eCuWnjgIHmmK/kuozlj4nmoJHnmoTmoLnvvIzml6Dlj4zkurLvvJvlpoLmnpxpPjHvvIzliJnlhbblj4zkurJwYXJlbnQoaSnmmK/nu5PngrlNYXRoLmZsb29yKGkvMinjgIJcbiAqICAgICAoMinlpoLmnpwyaSA+IG7vvIzliJnnu5Pngrlp5peg5bem5a2p5a2Q77yI57uT54K5aeS4uuWPtuWtkOe7k+eCue+8ie+8m+WQpuWImeWFtuW3puWtqeWtkExDaGlsZChpKeaYr+e7k+eCuTJpLlxuICogICAgICgzKeWmguaenDJpICsgMSA+IG7vvIzliJnnu5Pngrlp5peg5Y+z5a2p5a2Q77yb5ZCm5YiZ5YW25Y+z5a2p5a2QUkNoaWxkKGkp5piv57uT54K5MmkgKyAxO1xuICovXG5cbi8qXG4g5LqM5Y+J5qCR55qE5a2Y5YKo57uT5p6EXG5cbiAxLumhuuW6j+WtmOWCqOe7k+aehFxuIOeUqOS4gOe7hOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeiHquS4iuiAjOS4i++8jOiHquW3puiHs+WPs+WtmOWCqOWujOWFqOS6jOWPieagkeS4iueahOe7k+eCueWFg+e0oO+8jOWNs+WwhuS6jOWPieagkeS4iue8luWPt+S4umnnmoTnu5PngrnlhYPntKDlrZjlgqjlnKjliqDkuIrlrprkuYnnmoTkuIDnu7TmlbDnu4TkuK3kuIvmoIfkuLppLTHnmoTliIbph4/kuK3jgILigJww4oCd6KGo56S65LiN5a2Y5Zyo5q2k57uT54K544CC6L+Z56eN6aG65bqP5a2Y5YKo57uT5p6E5LuF6YCC55So5LqO5a6M5YWo5LqM5Y+J5qCR44CCXG4g5Zug5Li677yM5Zyo5pyA5Z2P5oOF5Ya15LiL77yM5LiA5Liq5rex5bqm5Li6a+S4lOWPquaciWvkuKrnu5PngrnnmoTljZXmlK/moJHvvIjmoJHkuK3kuI3lrZjlnKjluqbkuLoy55qE57uT54K577yJ5Y206ZyA6KaB6ZW/5bqm5Li6MueahG7mrKHmlrktMeeahOS4gOe7tOaVsOe7hOOAglxuXG4gMi7pk77lvI/lrZjlgqjnu5PmnoRcbiDkuozlj4nmoJHnmoTnu5PngrnnlLHkuIDkuKrmlbDmja7lhYPntKDlkozliIbliKvmjIflkJHlhbblt6blj7PlrZDmoJHnmoTkuKTkuKrliIbmlK/mnoTmiJDvvIzliJnooajnpLrkuozlj4nmoJHnmoTpk77ooajkuK3nmoTnu5Pngrnoh7PlsJHljIXlkKvkuInkuKrln5/vvJrmlbDmja7ln5/lkozlt6blj7PmjIfpkojln5/jgILmnInml7bvvIzkuLrkuobkvr/kuo7mib7liLDnu5PngrnnmoTlj4zkurLvvIzliJnov5jlj6/lnKjnu5Pngrnnu5PmnoTkuK3lop7liqDkuIDkuKrmjIflkJHlhbblj4zkurLnu5PngrnnmoTmjIfpkojln5/jgILliKnnlKjov5nkuKTnp43nu5PmnoTmiYDlvpfnmoTkuozlj4nmoJHnmoTlrZjlgqjnu5PmnoTliIbliKvnp7DkuYvkuLrkuozlj4npk77ooajlkozkuInlj4npk77ooajjgIJcbiDlnKjlkKvmnIlu5Liq57uT54K555qE5LqM5Y+J6ZO+6KGo5Lit5pyJbisx5Liq56m66ZO+5Z+f77yM5oiR5Lus5Y+v5Lul5Yip55So6L+Z5Lqb56m66ZO+5Z+f5a2Y5YKo5YW25LuW5pyJ55So5L+h5oGv77yM5LuO6ICM5b6X5Yiw5Y+m5LiA56eN6ZO+5byP5a2Y5YKo57uT5p6ELS0t57q/57Si6ZO+6KGo44CCXG5cbiDlhYjvvIjmoLnvvInluo/pgY3ljobvvJrmoLnlt6blj7NcbiDkuK3vvIjmoLnvvInluo/pgY3ljobvvJrlt6bmoLnlj7NcbiDlkI7vvIjmoLnvvInluo/pgY3ljobvvJrlt6blj7PmoLlcblxuICovXG5cbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vUXVldWUvUXVldWUnO1xuXG4vLyDpk77lvI/lrZjlgqjnu5PmnoRcbmV4cG9ydCBjbGFzcyBCaW5hcnlUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgbGVmdENoaWxkID0gbnVsbCwgcmlnaHRDaGlsZCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8g5bem5Y+z5a2p5a2Q57uT54K5XG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gbGVmdENoaWxkO1xuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkO1xuICAgIH1cblxuICAgIC8vIOWIpOaWreS4pOajteagkeaYr+WQpuebuOS8vFxuICAgIGlzU2ltaWxhcih0cmVlKSB7XG4gICAgICAgIHJldHVybiAhISh0cmVlICYmXG4gICAgICAgICAgICAoKHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmlzU2ltaWxhcih0cmVlLmxlZnRDaGlsZCkpIHx8ICghdGhpcy5sZWZ0Q2hpbGQgJiYgIXRyZWUubGVmdENoaWxkKSkgJiZcbiAgICAgICAgICAgICgodGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5pc1NpbWlsYXIodHJlZS5yaWdodENoaWxkKSkgfHwgKCF0aGlzLnJpZ2h0Q2hpbGQgJiYgIXRyZWUucmlnaHRDaGlsZCkpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVCaW5hcnlUcmVlKHRyZWUpIHtcbiAgICAgICAgdm9pZCBmdW5jdGlvbiBwcmVPcmRlclJlY3Vyc2l2ZShub2RlLCB4LCB2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQobm9kZSwgdHJlZVt4XSk7XG5cbiAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkge1xuICAgICAgICAgICAgICAgIHAgPSBub2RlLmxlZnRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XG4gICAgICAgICAgICAgICAgcHJlT3JkZXJSZWN1cnNpdmUocCwgMiAqIHggKyAxLCB2aXNpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSB7XG4gICAgICAgICAgICAgICAgcCA9IG5vZGUucmlnaHRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XG4gICAgICAgICAgICAgICAgcHJlT3JkZXJSZWN1cnNpdmUocCwgMiAqIHggKyAyLCB2aXNpdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwKSBwLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICB9KHRoaXMsIDAsIChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIOagueaNrnR5cGXnsbvlnovkvb/nlKjkuI3lkIzpobrluo/ov63ku6PvvIzpu5jorqTliY3luo/pgY3ljoZcbiAgICAgKiAxOiDliY3luo8gMjog5Lit5bqPIDM6IOWQjuW6j1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvclR5cGVcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgQmluYXJ5VHJlZVxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXShpdGVyYXRvclR5cGUgPSAxKSB7XG4gICAgICAgIHN3aXRjaCAoaXRlcmF0b3JUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgeWllbGQqIHRoaXMubGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHlpZWxkKiB0aGlzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB5aWVsZCogdGhpcy5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHlpZWxkKiB0aGlzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB5aWVsZCogdGhpcy5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgeWllbGQqIHRoaXMucmlnaHRDaGlsZDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIOWFiOW6j+mBjeWOhuS6jOWPieagkeeahOmdnumAkuW9kueul+azlVxuICAgIHByZU9yZGVyTm9uUmVjdXJzaXZlKHZpc2l0KSB7XG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG5cbiAgICAgICAgd2hpbGUgKHAgfHwgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyDlkJHlt6botbDliLDlsL3lpLRcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcbiAgICAgICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcbiAgICAgICAgICAgICAgICBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBwID0gcC5yaWdodENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5Lit5bqP6Z2e6YCS5b2S6YGN5Y6GXG4gICAgaW5PcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuXG4gICAgICAgIHdoaWxlIChwIHx8IHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHApO1xuICAgICAgICAgICAgICAgIHAgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xuICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDkuLrkuobljLrliIbkuKTmrKHov4fmoIjnmoTkuI3lkIzlpITnkIbmlrnlvI/vvIzlnKjloIbmoIjkuK3lop7liqDkuIDkuKptYXJr5Z+f77yMXG4gICAgLy8gbWFyaz0w6KGo56S65Yia5Yia6K6/6Zeu5q2k57uT54K577yMbWFyaz0x6KGo56S65bem5a2Q5qCR5aSE55CG57uT5p2f6L+U5Zue77yMXG4gICAgLy8gbWFyaz0y6KGo56S65Y+z5a2Q5qCR5aSE55CG57uT5p2f6L+U5Zue44CC5q+P5qyh5qC55o2u5qCI6aG255qEbWFya+Wfn+WGs+WumuWBmuS9leWKqOS9nFxuICAgIHBvc3RPcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgc3RhY2sucHVzaChbdGhpcywgMF0pO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBhID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFbMF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYVsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChbbm9kZSwgMV0pOyAgLy8g5L+u5pS5bWFya+Wfn1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0Q2hpbGQpIHN0YWNrLnB1c2goW25vZGUubGVmdENoaWxkLCAwXSk7ICAvLyDorr/pl67lt6blrZDmoJFcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtub2RlLCAyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2goW25vZGUucmlnaHRDaGlsZCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSAmJiB2aXNpdChub2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZU9yZGVyUmVjdXJzaXZlKHZpc2l0KSB7XG4gICAgICAgIHZpc2l0KHRoaXMuZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQucHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQucHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgIH1cblxuICAgIGluT3JkZXJSZWN1cnNpdmUodmlzaXQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcbiAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcbiAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLmluT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgIH1cblxuICAgIHBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5wb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICB2aXNpdCh0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIGxldmVsT3JkZXJUcmF2ZXJzZSh2aXNpdCkge1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh0aGlzKTtcblxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgbGV0IHAgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcbiAgICAgICAgICAgIHAubGVmdENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgcC5yaWdodENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5yaWdodENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOaxguWFiOW6j+W6j+WIl+S4umvnmoTnu5PngrnnmoTlgLxcbiAgICBnZXRQcmVTZXF1ZW5jZShrKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcblxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gaylcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0odGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8g5rGC5LqM5Y+J5qCR5Lit5Y+25a2Q57uT54K555qE5pWw55uuXG4gICAgY291bnRMZWF2ZXMoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkgcmV0dXJuIDA7XG4gICAgICAgICAgICBlbHNlIGlmICghbm9kZS5sZWZ0Q2hpbGQgJiYgIW5vZGUucmlnaHRDaGlsZCkgcmV0dXJuIDE7XG4gICAgICAgICAgICBlbHNlIHJldHVybiByZWN1cnNlKG5vZGUubGVmdENoaWxkKSArIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcbiAgICAgICAgfSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyDkuqTmjaLmiYDmnInnu5PngrnnmoTlt6blj7PlrZDmoJFcbiAgICByZXZvbHV0ZUJpbmFyeVRyZWUoKSB7XG4gICAgICAgIFt0aGlzLmxlZnRDaGlsZCwgdGhpcy5yaWdodENoaWxkXSA9IFt0aGlzLnJpZ2h0Q2hpbGQsIHRoaXMubGVmdENoaWxkXTtcblxuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnJldm9sdXRlQmluYXJ5VHJlZSgpO1xuICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQucmV2b2x1dGVCaW5hcnlUcmVlKCk7XG4gICAgfVxuXG4gICAgcmV2b2x1dGVOb25SZWN1cnNpdmUoKSB7XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBbbm9kZS5sZWZ0Q2hpbGQsIG5vZGUucmlnaHRDaGlsZF0gPSBbbm9kZS5yaWdodENoaWxkLCBub2RlLmxlZnRDaGlsZF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICBpZiAobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKG5vZGUucmlnaHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmsYLkuozlj4nmoJHkuK3ku6XlgLzkuLp455qE57uT54K55Li65qC555qE5a2Q5qCR5rex5bqmXG4gICAgZ2V0U3ViRGVwdGgoeCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSB4KSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBub2RlLmdldERlcHRoKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHRDaGlsZCkgc3RhY2sucHVzaChub2RlLnJpZ2h0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIGdldERlcHRoKCkge1xuICAgICAgICBsZXQgbSA9IHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmdldERlcHRoKCkgfHwgMDtcbiAgICAgICAgbGV0IG4gPSB0aGlzLnJpZ2h0Q2hpbGQgJiYgdGhpcy5yaWdodENoaWxkLmdldERlcHRoKCkgfHwgMDtcbiAgICAgICAgcmV0dXJuIChtID4gbiA/IG0gOiBuKSArIDE7XG4gICAgfVxuXG4gICAgLy8g5Yig6Zmk5omA5pyJ5Lul5YWD57SgeOS4uuagueeahOWtkOagkVxuICAgIGRlbFN1YlgoeCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhID09PSB4KSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5kZWxTdWJYKHgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLmRlbFN1YlgoeCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDpnZ7pgJLlvZLlpI3liLbkuozlj4nmoJFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiDmi7fotJ3ov4fnqIvkuK3kvJrmiafooYznmoTlm57osIPvvIzlj6/ku6XnlKjmnaXmi7fotJ3lhbblroPoh6rlrprkuYnlsZ7mgKdcbiAgICAgKiBAcmV0dXJucyB7Q3N0cn0g6L+U5Zue5paw55qE5a6e5L6LXG4gICAgICovXG4gICAgY29weShjYiA9IGZ1bmN0aW9uICgpIHsgfSkge1xuICAgICAgICAvLyDnlKjmnaXlrZjmlL7mnKzkvZPnu5PngrnnmoTmoIhcbiAgICAgICAgbGV0IHN0YWNrMSA9IG5ldyBTdGFjaygpO1xuICAgICAgICAvLyDnlKjmnaXlrZjmlL7mlrDkuozlj4nmoJHnu5PngrnnmoTmoIhcbiAgICAgICAgbGV0IHN0YWNrMiA9IG5ldyBTdGFjaygpO1xuICAgICAgICBzdGFjazEucHVzaCh0aGlzKTtcbiAgICAgICAgbGV0IENzdHIgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBsZXQgbmV3VHJlZSA9IG5ldyBDc3RyKCk7XG4gICAgICAgIGxldCBxID0gbmV3VHJlZTtcbiAgICAgICAgc3RhY2syLnB1c2gobmV3VHJlZSk7XG4gICAgICAgIGxldCBwO1xuXG4gICAgICAgIHdoaWxlIChzdGFjazEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyDlkJHlt6botbDliLDlsL3lpLRcbiAgICAgICAgICAgIHdoaWxlICgocCA9IHN0YWNrMS5wZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAubGVmdENoaWxkKSBxLmxlZnRDaGlsZCA9IG5ldyBDc3RyKCk7XG4gICAgICAgICAgICAgICAgcSA9IHEubGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICBzdGFjazIucHVzaChxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHN0YWNrMS5wb3AoKTtcbiAgICAgICAgICAgIHEgPSBzdGFjazIucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChzdGFjazEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcCA9IHN0YWNrMS5wb3AoKTtcbiAgICAgICAgICAgICAgICBxID0gc3RhY2syLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChwLnJpZ2h0Q2hpbGQpIHEucmlnaHRDaGlsZCA9IG5ldyBDc3RyKCk7XG4gICAgICAgICAgICAgICAgcS5kYXRhID0gcC5kYXRhO1xuICAgICAgICAgICAgICAgIGNiKHEsIHApO1xuICAgICAgICAgICAgICAgIHEgPSBxLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgc3RhY2sxLnB1c2gocC5yaWdodENoaWxkKTsgIC8vIOWQkeWPs+S4gOatpVxuICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1RyZWU7XG4gICAgfVxuXG4gICAgLy8g5rGC5LqM5Y+J5qCR5Lit57uT54K5cOWSjHHnmoTmnIDov5HnpZblhYhcbiAgICBmaW5kTmVhckFuY2llbnQocE5vZGUsIHFOb2RlKSB7XG4gICAgICAgIGxldCBwYXRoUCA9IGZpbmRQYXRoKHRoaXMsIHBOb2RlLCAwKTtcbiAgICAgICAgbGV0IHBhdGhRID0gZmluZFBhdGgodGhpcywgcU5vZGUsIDApO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBwYXRoUFtpXSA9PSBwYXRoUVtpXSAmJiBwYXRoUFtpXTsgaSsrKTtcbiAgICAgICAgcmV0dXJuIHBhdGhQWy0taV07XG4gICAgfVxuXG4gICAgLy8gdG9kb1xuICAgIHRvU3RyaW5nKCkge1xuICAgIH1cblxuICAgIC8vIOaxguS4gOajteS6jOWPieagkeeahOe5geiMguW6plxuICAgIGx1c2hEZWdyZWUoKSB7XG4gICAgICAgIGxldCBjb3VudEFyciA9IFtdO1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh7XG4gICAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgICAgbGF5ZXI6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWIqeeUqOWxguW6j+mBjeWOhuadpee7n+iuoeWQhOWxgueahOe7k+eCueaVsFxuICAgICAgICBsZXQgcjtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcbiAgICAgICAgICAgIHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICBjb3VudEFycltyLmxheWVyXSA9IChjb3VudEFycltyLmxheWVyXSB8fCAwKSArIDE7XG5cbiAgICAgICAgICAgIGlmIChyLm5vZGUubGVmdENoaWxkKVxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiByLm5vZGUubGVmdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogci5sYXllciArIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyLm5vZGUucmlnaHRDaGlsZClcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogci5ub2RlLnJpZ2h0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5pyA5ZCO5LiA5Liq6Zif5YiX5YWD57Sg5omA5Zyo5bGC5bCx5piv5qCR55qE6auY5bqmXG4gICAgICAgIGxldCBoZWlnaHQgPSByLmxheWVyO1xuICAgICAgICBsZXQgbWF4ID0gY291bnRBcnJbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBjb3VudEFycltpXTsgaSsrKVxuICAgICAgICAgICAgLy8g5rGC5bGC5pyA5aSn57uT54K55pWwXG4gICAgICAgICAgICBpZiAoY291bnRBcnJbaV0gPiBtYXgpIG1heCA9IGNvdW50QXJyW2ldO1xuXG4gICAgICAgIHJldHVybiBoZWlnaHQgKiBtYXg7XG4gICAgfVxuXG4gICAgLy8g5rGC5qCR57uT54K555qE5a2Q5a2Z5oC75pWw5aGr5YWlZGVzY051beWtl+auteS4re+8jOW5tui/lOWbnlxuICAgIGRlc2NOdW0oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBlbHNlIGQgPSByZWN1cnNlKG5vZGUubGVmdENoaWxkKSArIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKSArIDI7XG5cbiAgICAgICAgICAgIG5vZGUuZGVzY051bSA9IGQ7XG5cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KHRoaXMpO1xuICAgIH1cblxuICAgIC8vIOWIpOaWreS6jOWPieagkeaYr+WQpuWujOWFqOS6jOWPieagkVxuICAgIHN0YXRpYyBpc0Z1bGxCaW5hcnlUcmVlKHRyZWUpIHtcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIGxldCBmbGFnID0gMDtcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh0cmVlKTtcblxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgbGV0IHAgPSBxdWV1ZS5kZVF1ZXVlKCk7XG5cbiAgICAgICAgICAgIGlmICghcCkgZmxhZyA9IDE7XG4gICAgICAgICAgICBlbHNlIGlmIChmbGFnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIOaxguS7jnRyZWXliLBub2Rl57uT54K56Lev5b6E55qE6YCS5b2S566X5rOVXG5mdW5jdGlvbiBmaW5kUGF0aCh0cmVlLCBub2RlLCBpID0gMCkge1xuICAgIGxldCBwYXRoID0gW107XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2UodHJlZSwgaSkge1xuICAgICAgICBpZiAodHJlZSA9PSBub2RlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoW2ldID0gdHJlZTtcbiAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSByZWN1cnNlKHRyZWUubGVmdENoaWxkLCBpICsgMSk7XG4gICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQgJiYgIWZvdW5kKSByZWN1cnNlKHRyZWUucmlnaHRDaGlsZCwgaSArIDEpO1xuICAgICAgICBpZiAoIWZvdW5kKSBwYXRoW2ldID0gbnVsbDtcbiAgICB9KHRyZWUsIGkpO1xuXG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbmxldCBnbG9iYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXM7JykoKTtcblxuLy8g5rGC5rex5bqm562J5LqO5qCR55qE6auY5bqm5YeP5LiA55qE5pyA6Z2g5bem55qE57uT54K5XG5mdW5jdGlvbiBwcmludFBhdGhfbWF4RGVwdGhTMSh0cmVlKSB7XG4gICAgbGV0IG1heGggPSB0cmVlLmdldERlcHRoKCk7XG4gICAgbGV0IHBhdGggPSBbXTtcblxuICAgIGlmIChtYXhoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgIGZpbmRfaCh0cmVlLCAxKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRfaCh0cmVlLCBoKSB7XG4gICAgICAgIHBhdGhbaF0gPSB0cmVlO1xuXG4gICAgICAgIGlmIChoID09IG1heGggLSAxKSB7XG4gICAgICAgICAgICBsZXQgcyA9ICcgJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBwYXRoW2ldOyBpKyspIHMgKz0gcGF0aFtpXS5kYXRhICsgKHBhdGhbaSArIDFdID8gJyAtPiAnIDogJycpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHJlZS5sZWZ0Q2hpbGQpIGZpbmRfaCh0cmVlLmxlZnRDaGlsZCwgaCArIDEpO1xuICAgICAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCkgZmluZF9oKHRyZWUucmlnaHRDaGlsZCwgaCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aFtoXSA9IG51bGw7XG4gICAgfVxufVxuXG52YXIgdHJlZSA9IFsxLCAyLCAzLCA0LCA1LCAsIDYsICwgLCA3XTtcbnZhciB0ZXN0ID0gbmV3IEJpbmFyeVRyZWUoKTtcbnRlc3QuY3JlYXRlQmluYXJ5VHJlZSh0cmVlKTtcblxuY29uc29sZS5sb2coJ2l0ZXJhdG9yOiAnKTtcbmZvciAobGV0IHggb2YgdGVzdCkge1xuICAgIGNvbnNvbGUubG9nKHgpO1xufVxuXG5cbi8qKlxuICog5qCR55qEM+enjeW4uOeUqOmTvuihqOe7k+aehFxuICovXG5cbi8vIDEu5Y+M5Lqy6KGo56S65rOVXG4vLyDkvJjngrnvvJpwYXJlbnQodHJlZSwgeCnmk43kvZzlj6/ku6XlnKjluLjph4/ml7bpl7TlhoXlrp7njrBcbi8vIOe8uueCue+8muaxgue7k+eCueeahOWtqeWtkOaXtumcgOimgemBjeWOhuaVtOS4que7k+aehFxuZXhwb3J0IGNsYXNzIFBhcmVudFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgZ2V0RGVwdGgoKSB7XG4gICAgICAgIGxldCBtYXhEZXB0aCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVwID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID49IDA7IGogPSB0aGlzLm5vZGVzW2ldLnBhcmVudCkgZGVwKys7XG4gICAgICAgICAgICBpZiAoZGVwID4gbWF4RGVwdGgpIG1heERlcHRoID0gZGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heERlcHRoO1xuICAgIH1cbn1cblxuY2xhc3MgUGFyZW50VHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBwYXJlbnQgPSAwKSB7XG4gICAgICAgIC8vIHR5cGU6IFBhcmVudFRyZWVcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8g5Y+M5Lqy5L2N572u5Z+fIHtOdW1iZXJ9XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbn1cblxubGV0IHB0ID0gbmV3IFBhcmVudFRyZWUoKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdSJywgLTEpKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdBJywgMCkpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0InLCAwKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnQycsIDApKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdEJywgMSkpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0UnLCAxKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRicsIDMpKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdHJywgNikpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0gnLCA2KSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnSScsIDYpKTtcblxuXG4vLyDlranlrZDooajnpLrms5VcblxuZXhwb3J0IGNsYXNzIENoaWxkVHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3ViRGVwdGgocm9vdEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYubm9kZXNbcm9vdEluZGV4XSkgcmV0dXJuIDE7XG5cbiAgICAgICAgICAgIGxldCBzZCA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gc2VsZi5ub2Rlc1tyb290SW5kZXhdOyBwOyBwID0gcC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGQgPSBzdWJEZXB0aChwLmNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA+IHNkKSBzZCA9IGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZCArIDE7XG4gICAgICAgIH0odGhpcy5kYXRhWzBdKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gZmlyc3RDaGlsZCDlranlrZDpk77ooajlpLTmjIfpkohcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDaGlsZFRyZWVCb3gge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBmaXJzdENoaWxkID0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIH1cbn1cblxuLyoqXG4gKiDlranlrZDnu5PngrlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY2hpbGRcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gbmV4dFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENoaWxkVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkID0gbnVsbCwgbmV4dCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbn1cblxuLypcbiDlranlrZDooajnpLrms5Xkvr/kuo7mtonlj4rlranlrZDnmoTmk43kvZznmoTlrp7njrDvvIzkvYbkuI3pgILnlKjkuo5wYXJlbnTmk43kvZzjgIJcbiDmiJHku6zlj6/ku6Xmiorlj4zkurLooajnpLrms5XlkozlranlrZDooajnpLrms5Xnu5PlkIjotbfmnaXjgIJcbiAqL1xuXG5cbi8vIOWtqeWtkOWFhOW8n+ihqOekuuazlSjkuozlj4nmoJHooajnpLrms5UpXG4vLyDlj6/lop7orr7kuIDkuKpwYXJlbnTln5/lrp7njrBwYXJlbnTmk43kvZxcbmV4cG9ydCBjbGFzcyBDaGlsZFNpYmxpbmdUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgZmlyc3RDaGlsZCA9IG51bGwsIG5leHRTaWJsaW5nID0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgLy8g6L6T5Ye65a2p5a2Q5YWE5byf6ZO+6KGo6KGo56S655qE5qCR55qE5ZCE6L65XG4gICAgcHJpbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gdGhpcy5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyVjICVjJywgdGhpcy5kYXRhLCBjaGlsZC5kYXRhKTtcbiAgICAgICAgICAgIGNoaWxkLnByaW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmsYLlranlrZDlhYTlvJ/pk77ooajooajnpLrnmoTmoJHnmoTlj7blrZDmlbDnm65cbiAgICBsZWFmQ291bnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSB0aGlzLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gY2hpbGQubGVhZkNvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmsYLmoJHnmoTluqZcbiAgICBnZXREZWdyZWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVncmVlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLmZpcnN0Q2hpbGQ7IHA7IHAgPSBwLm5leHRTaWJsaW5nKSBkZWdyZWUrKztcblxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHAuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGQgPiBkZWdyZWUpIGRlZ3JlZSA9IGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IGdsb2JhbCkgcmV0dXJuIDA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1heGQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHAuZ2V0RGVwdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG1heGQpIG1heGQgPSBkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF4ZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQmluYXJ5VHJlZS9CaW5hcnlUcmVlLmpzIiwiLyoqXG4gKiDmoIhcbiAqXG4gKiDmmK/pmZDlrprku4XlnKjooajlsL7ov5vooYzmj5LlhaXmiJbliKDpmaTmk43kvZznmoTnur/mgKfooajjgILooajlsL7kuLrmoIjpobbvvIh0b3DvvInvvIzooajlpLTkuLrmoIjlupXvvIhib3R0b23vvInvvIzkuI3lkKvlhYPntKDnmoTnqbrooajkuLrnqbrmoIjjgIJcbiAqIOagiOWPiOensOS4uuWQjui/m+WFiOWHuu+8iGxhc3QgaW4gZmlyc3Qgb3V077yJ55qE57q/5oCn6KGo44CCXG4gKi9cblxuLyoqXG4gKiDpobrluo/moIhcbiAqIOagiOeahOmhuuW6j+WtmOWCqOe7k+aehOaYr+WIqeeUqOS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeWtmOaUvuiHs+agiOW6leWIsOagiOmhtueahOWFg+e0oO+8jOWQjOaXtumZhOiuvuaMh+mSiHRvcOaMh+ekuuagiOmhtuWFg+e0oOWcqOmhuuW6j+agiOS4reeahOS9jee9ruOAglxuICpcbiAqL1xuXG4vLyDmoIjnmoTpk77lvI/ooajnpLpcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IHNpemUoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBwdXNoIChkYXRhKSB7XG4gICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBub2RlLm5leHQgPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy50b3AgPSBub2RlO1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICBwZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSBudWxsID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy50b3AuZGF0YTtcbiAgICB9XG4gICAgcG9wICgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgb3V0ID0gdGhpcy50b3A7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AubmV4dDtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBcblxuICAgICAgICByZXR1cm4gb3V0LmRhdGE7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgICAgdGhpcy50b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgYXJyID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy50b3A7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU3RhY2svaW5kZXguanMiLCJ2YXIgYXNuMSA9IGV4cG9ydHM7XG5cbmFzbjEuYmlnbnVtID0gcmVxdWlyZSgnYm4uanMnKTtcblxuYXNuMS5kZWZpbmUgPSByZXF1aXJlKCcuL2FzbjEvYXBpJykuZGVmaW5lO1xuYXNuMS5iYXNlID0gcmVxdWlyZSgnLi9hc24xL2Jhc2UnKTtcbmFzbjEuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9hc24xL2NvbnN0YW50cycpO1xuYXNuMS5kZWNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9kZWNvZGVycycpO1xuYXNuMS5lbmNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9lbmNvZGVycycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEvYmFzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1ZmZlci14b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyXFxudXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiA2NTUzNikgdGhyb3cgbmV3IEVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcbiAgLy8gaW4gY2FzZSBicm93c2VyaWZ5ICBpc24ndCB1c2luZyB0aGUgVWludDhBcnJheSB2ZXJzaW9uXG4gIHZhciByYXdCeXRlcyA9IG5ldyBnbG9iYWwuVWludDhBcnJheShzaXplKVxuXG4gIC8vIFRoaXMgd2lsbCBub3Qgd29yayBpbiBvbGRlciBicm93c2Vycy5cbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhd0J5dGVzKVxuICB9XG4gIC8vIHBoYW50b21qcyBkb2Vzbid0IGxpa2UgYSBidWZmZXIgYmVpbmcgcGFzc2VkIGhlcmVcbiAgdmFyIGJ5dGVzID0gbmV3IEJ1ZmZlcihyYXdCeXRlcy5idWZmZXIpXG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYW5kb21ieXRlcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvNC8xMi5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGJhc2VkIG9uIHRoZSBhZXMgaW1wbGltZW50YXRpb24gaW4gdHJpcGxlIHNlY1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tleWJhc2UvdHJpcGxlc2VjXG5cbi8vIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gdGhlIG9uZSBmcm9tIGNyeXB0by1qc1xuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG5cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gc2NydWJfdmVjICh2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IHYrKykge1xuICAgIHZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIEdsb2JhbCAoKSB7XG4gIHRoaXMuU0JPWCA9IFtdXG4gIHRoaXMuSU5WX1NCT1ggPSBbXVxuICB0aGlzLlNVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuSU5WX1NVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XVxufVxuXG5HbG9iYWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkLCBpLCBzeCwgdCwgeCwgeDIsIHg0LCB4OCwgeGksIF9pXG4gIGQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaSwgX3Jlc3VsdHNcbiAgICBfcmVzdWx0cyA9IFtdXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaSA8PCAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoaSA8PCAxKSBeIDB4MTFiKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHNcbiAgfSkoKVxuICB4ID0gMFxuICB4aSA9IDBcbiAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpXG4gICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzXG4gICAgdGhpcy5TQk9YW3hdID0gc3hcbiAgICB0aGlzLklOVl9TQk9YW3N4XSA9IHhcbiAgICB4MiA9IGRbeF1cbiAgICB4NCA9IGRbeDJdXG4gICAgeDggPSBkW3g0XVxuICAgIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApXG4gICAgdGhpcy5TVUJfTUlYWzBdW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgdGhpcy5TVUJfTUlYWzFdW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuU1VCX01JWFsyXVt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuU1VCX01JWFszXVt4XSA9IHRcbiAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApXG4gICAgdGhpcy5JTlZfU1VCX01JWFswXVtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzFdW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICB0aGlzLklOVl9TVUJfTUlYWzJdW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbM11bc3hdID0gdFxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB4ID0geGkgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV1cbiAgICAgIHhpIF49IGRbZFt4aV1dXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBHID0gbmV3IEdsb2JhbCgpXG5cbkFFUy5ibG9ja1NpemUgPSA0ICogNFxuXG5BRVMucHJvdG90eXBlLmJsb2NrU2l6ZSA9IEFFUy5ibG9ja1NpemVcblxuQUVTLmtleVNpemUgPSAyNTYgLyA4XG5cbkFFUy5wcm90b3R5cGUua2V5U2l6ZSA9IEFFUy5rZXlTaXplXG5cbmZ1bmN0aW9uIGJ1ZmZlclRvQXJyYXkgKGJ1Zikge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAvIDRcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1Zi5yZWFkVUludDMyQkUoaSAqIDQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gQUVTIChrZXkpIHtcbiAgdGhpcy5fa2V5ID0gYnVmZmVyVG9BcnJheShrZXkpXG4gIHRoaXMuX2RvUmVzZXQoKVxufVxuXG5BRVMucHJvdG90eXBlLl9kb1Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW52S3NSb3csIGtleVNpemUsIGtleVdvcmRzLCBrc1Jvdywga3NSb3dzLCB0XG4gIGtleVdvcmRzID0gdGhpcy5fa2V5XG4gIGtleVNpemUgPSBrZXlXb3Jkcy5sZW5ndGhcbiAgdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2XG4gIGtzUm93cyA9ICh0aGlzLl9uUm91bmRzICsgMSkgKiA0XG4gIHRoaXMuX2tleVNjaGVkdWxlID0gW11cbiAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgdGhpcy5fa2V5U2NoZWR1bGVba3NSb3ddID0ga3NSb3cgPCBrZXlTaXplID8ga2V5V29yZHNba3NSb3ddIDogKHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIDFdLCAoa3NSb3cgJSBrZXlTaXplKSA9PT0gMCA/ICh0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpLCB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0sIHQgXj0gRy5SQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQpIDoga2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0ID8gdCA9IChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBHLlNCT1hbdCAmIDB4ZmZdIDogdm9pZCAwLCB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdClcbiAgfVxuICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3dcbiAgICB0ID0gdGhpcy5fa2V5U2NoZWR1bGVba3NSb3cgLSAoaW52S3NSb3cgJSA0ID8gMCA6IDQpXVxuICAgIHRoaXMuX2ludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0ID8gdCA6IEcuSU5WX1NVQl9NSVhbMF1bRy5TQk9YW3QgPj4+IDI0XV0gXiBHLklOVl9TVUJfTUlYWzFdW0cuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFsyXVtHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFszXVtHLlNCT1hbdCAmIDB4ZmZdXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9rZXlTY2hlZHVsZSwgRy5TVUJfTUlYLCBHLlNCT1gpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIHRlbXAgPSBbTVszXSwgTVsxXV1cbiAgTVsxXSA9IHRlbXBbMF1cbiAgTVszXSA9IHRlbXBbMV1cbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgRy5JTlZfU1VCX01JWCwgRy5JTlZfU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uICgpIHtcbiAgc2NydWJfdmVjKHRoaXMuX2tleVNjaGVkdWxlKVxuICBzY3J1Yl92ZWModGhpcy5faW52S2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9rZXkpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvQ3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNLCBrZXlTY2hlZHVsZSwgU1VCX01JWCwgU0JPWCkge1xuICB2YXIga3NSb3csIHMwLCBzMSwgczIsIHMzLCB0MCwgdDEsIHQyLCB0M1xuXG4gIHMwID0gTVswXSBeIGtleVNjaGVkdWxlWzBdXG4gIHMxID0gTVsxXSBeIGtleVNjaGVkdWxlWzFdXG4gIHMyID0gTVsyXSBeIGtleVNjaGVkdWxlWzJdXG4gIHMzID0gTVszXSBeIGtleVNjaGVkdWxlWzNdXG4gIGtzUm93ID0gNFxuICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgdGhpcy5fblJvdW5kczsgcm91bmQrKykge1xuICAgIHQwID0gU1VCX01JWFswXVtzMCA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQxID0gU1VCX01JWFswXVtzMSA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQyID0gU1VCX01JWFswXVtzMiA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQzID0gU1VCX01JWFswXVtzMyA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHMwID0gdDBcbiAgICBzMSA9IHQxXG4gICAgczIgPSB0MlxuICAgIHMzID0gdDNcbiAgfVxuICB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHJldHVybiBbXG4gICAgZml4dXBfdWludDMyKHQwKSxcbiAgICBmaXh1cF91aW50MzIodDEpLFxuICAgIGZpeHVwX3VpbnQzMih0MiksXG4gICAgZml4dXBfdWludDMyKHQzKVxuICBdXG59XG5cbmV4cG9ydHMuQUVTID0gQUVTXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvYWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzWydhZXMtMTI4LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTkyLWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMjU2LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTI4LWNiYyddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0JDJyxcbiAgdHlwZTogJ2Jsb2NrJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jYmMnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NCQycsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2JjJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDQkMnLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMxMjgnXSA9IGV4cG9ydHNbJ2Flcy0xMjgtY2JjJ11cbmV4cG9ydHNbJ2FlczE5MiddID0gZXhwb3J0c1snYWVzLTE5Mi1jYmMnXVxuZXhwb3J0c1snYWVzMjU2J10gPSBleHBvcnRzWydhZXMtMjU2LWNiYyddXG5leHBvcnRzWydhZXMtMTI4LWNmYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjgnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjgnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmI4J10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkI4JyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiOCddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCOCcsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjEnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjEnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmIxJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkIxJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiMSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCMScsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LW9mYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnT0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItb2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdPRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1vZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ09GQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWN0ciddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ1RSJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY3RyJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDVFInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jdHInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NUUicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMTkyLWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMjU2LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gaW5jcjMyIChpdikge1xuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciBpdGVtXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGl0ZW0gPSBpdi5yZWFkVUludDgobGVuKVxuICAgIGlmIChpdGVtID09PSAyNTUpIHtcbiAgICAgIGl2LndyaXRlVUludDgoMCwgbGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtKytcbiAgICAgIGl2LndyaXRlVUludDgoaXRlbSwgbGVuKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgaW5jcjMyKHNlbGYuX3ByZXYpXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHdoaWxlIChzZWxmLl9jYWNoZS5sZW5ndGggPCBjaHVuay5sZW5ndGgpIHtcbiAgICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX2NhY2hlLCBnZXRCbG9jayhzZWxmKV0pXG4gIH1cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmN1cnZlLnNob3J0ID0gcmVxdWlyZSgnLi9zaG9ydCcpO1xuY3VydmUubW9udCA9IHJlcXVpcmUoJy4vbW9udCcpO1xuY3VydmUuZWR3YXJkcyA9IHJlcXVpcmUoJy4vZWR3YXJkcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxubW9kdWxlLmV4cG9ydHMgPSBFVlBfQnl0ZXNUb0tleVxuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlMZW4sIGl2TGVuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgJ2JpbmFyeScpXG4gIH1cbiAgaWYgKHNhbHQgJiYgIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkge1xuICAgIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQsICdiaW5hcnknKVxuICB9XG4gIGtleUxlbiA9IGtleUxlbiAvIDhcbiAgaXZMZW4gPSBpdkxlbiB8fCAwXG4gIHZhciBraSA9IDBcbiAgdmFyIGlpID0gMFxuICB2YXIga2V5ID0gbmV3IEJ1ZmZlcihrZXlMZW4pXG4gIHZhciBpdiA9IG5ldyBCdWZmZXIoaXZMZW4pXG4gIHZhciBhZGRtZCA9IDBcbiAgdmFyIG1kX2J1ZlxuICB2YXIgaVxuICB2YXIgYnVmcyA9IFtdXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGFkZG1kKysgPiAwKSB7XG4gICAgICBidWZzLnB1c2gobWRfYnVmKVxuICAgIH1cbiAgICBidWZzLnB1c2gocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIHtcbiAgICAgIGJ1ZnMucHVzaChzYWx0KVxuICAgIH1cbiAgICBtZF9idWYgPSBtZDUoQnVmZmVyLmNvbmNhdChidWZzKSlcbiAgICBidWZzID0gW11cbiAgICBpID0gMFxuICAgIGlmIChrZXlMZW4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoa2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAga2V5W2tpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGtleUxlbi0tXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXZMZW4gPiAwICYmIGkgIT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChpdkxlbiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGl2W2lpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGl2TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlMZW4gPT09IDAgJiYgaXZMZW4gPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBtZF9idWYubGVuZ3RoOyBpKyspIHtcbiAgICBtZF9idWZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXZcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpXG52YXIgYWVzaWQgPSByZXF1aXJlKCcuL2Flc2lkLmpzb24nKVxudmFyIGZpeFByb2MgPSByZXF1aXJlKCcuL2ZpeFByb2MnKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG52YXIgY29tcGF0ID0gcmVxdWlyZSgncGJrZGYyJylcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzXG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyAoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZFxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXlcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcilcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZClcblxuICB2YXIgdHlwZSA9IHN0cmlwcGVkLnRhZ1xuICB2YXIgZGF0YSA9IHN0cmlwcGVkLmRhdGFcbiAgdmFyIHN1YnR5cGUsIG5kYXRhXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0NFUlRJRklDQVRFJzpcbiAgICAgIG5kYXRhID0gYXNuMS5jZXJ0aWZpY2F0ZS5kZWNvZGUoZGF0YSwgJ2RlcicpLnRic0NlcnRpZmljYXRlLnN1YmplY3RQdWJsaWNLZXlJbmZvXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFVCTElDIEtFWSc6XG4gICAgICBpZiAoIW5kYXRhKSB7XG4gICAgICAgIG5kYXRhID0gYXNuMS5QdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIG5kYXRhLnN1YmplY3RQcml2YXRlS2V5ID0gbmRhdGEuc3ViamVjdFB1YmxpY0tleVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZWMnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnB1Yl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVuY3J5cHRlZFByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgZGF0YSA9IGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFJJVkFURSBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJ2ZTogbmRhdGEuYWxnb3JpdGhtLmN1cnZlLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJykucHJpdmF0ZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHJpdl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgcGFyYW1zOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ1JTQSBQVUJMSUMgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnUlNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ0RTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgcGFyYW1zOiBhc24xLkRTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgIGNhc2UgJ0VDIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJ2ZTogZGF0YS5wYXJhbWV0ZXJzLnZhbHVlLFxuICAgICAgICBwcml2YXRlS2V5OiBkYXRhLnByaXZhdGVLZXlcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gIH1cbn1cbnBhcnNlS2V5cy5zaWduYXR1cmUgPSBhc24xLnNpZ25hdHVyZVxuZnVuY3Rpb24gZGVjcnlwdCAoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIHNhbHQgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuc2FsdFxuICB2YXIgaXRlcnMgPSBwYXJzZUludChkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuaXRlcnMudG9TdHJpbmcoKSwgMTApXG4gIHZhciBhbGdvID0gYWVzaWRbZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuYWxnby5qb2luKCcuJyldXG4gIHZhciBpdiA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLml2XG4gIHZhciBjaXBoZXJUZXh0ID0gZGF0YS5zdWJqZWN0UHJpdmF0ZUtleVxuICB2YXIga2V5bGVuID0gcGFyc2VJbnQoYWxnby5zcGxpdCgnLScpWzFdLCAxMCkgLyA4XG4gIHZhciBrZXkgPSBjb21wYXQucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcnMsIGtleWxlbilcbiAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihhbGdvLCBrZXksIGl2KVxuICB2YXIgb3V0ID0gW11cbiAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1hc24xL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNpcGhlcnMgPSByZXF1aXJlKCcuL2VuY3J5cHRlcicpXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY2lwaGVycy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBleHBvcnRzLkNpcGhlcml2ID0gY2lwaGVycy5jcmVhdGVDaXBoZXJpdlxudmFyIGRlY2lwaGVycyA9IHJlcXVpcmUoJy4vZGVjcnlwdGVyJylcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBleHBvcnRzLkRlY2lwaGVyID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdlxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG5mdW5jdGlvbiBnZXRDaXBoZXJzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGVzKVxufVxuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGV4cG9ydHMuZ2V0Q2lwaGVycyA9IGdldENpcGhlcnNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gY3J0O1xuZnVuY3Rpb24gYmxpbmQocHJpdikge1xuICB2YXIgciA9IGdldHIocHJpdik7XG4gIHZhciBibGluZGVyID0gci50b1JlZChibi5tb250KHByaXYubW9kdWx1cykpXG4gIC5yZWRQb3cobmV3IGJuKHByaXYucHVibGljRXhwb25lbnQpKS5mcm9tUmVkKCk7XG4gIHJldHVybiB7XG4gICAgYmxpbmRlcjogYmxpbmRlcixcbiAgICB1bmJsaW5kZXI6ci5pbnZtKHByaXYubW9kdWx1cylcbiAgfTtcbn1cbmZ1bmN0aW9uIGNydChtc2csIHByaXYpIHtcbiAgdmFyIGJsaW5kcyA9IGJsaW5kKHByaXYpO1xuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG1vZCA9IGJuLm1vbnQocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGJsaW5kZWQgPSBuZXcgYm4obXNnKS5tdWwoYmxpbmRzLmJsaW5kZXIpLnVtb2QocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGMxID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUxKSk7XG4gIHZhciBjMiA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMikpO1xuICB2YXIgcWludiA9IHByaXYuY29lZmZpY2llbnQ7XG4gIHZhciBwID0gcHJpdi5wcmltZTE7XG4gIHZhciBxID0gcHJpdi5wcmltZTI7XG4gIHZhciBtMSA9IGMxLnJlZFBvdyhwcml2LmV4cG9uZW50MSk7XG4gIHZhciBtMiA9IGMyLnJlZFBvdyhwcml2LmV4cG9uZW50Mik7XG4gIG0xID0gbTEuZnJvbVJlZCgpO1xuICBtMiA9IG0yLmZyb21SZWQoKTtcbiAgdmFyIGggPSBtMS5pc3ViKG0yKS5pbXVsKHFpbnYpLnVtb2QocCk7XG4gIGguaW11bChxKTtcbiAgbTIuaWFkZChoKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIobTIuaW11bChibGluZHMudW5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cykudG9BcnJheShmYWxzZSwgbGVuKSk7XG59XG5jcnQuZ2V0ciA9IGdldHI7XG5mdW5jdGlvbiBnZXRyKHByaXYpIHtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB3aGlsZSAoci5jbXAocHJpdi5tb2R1bHVzKSA+PSAgMCB8fCAhci51bW9kKHByaXYucHJpbWUxKSB8fCAhci51bW9kKHByaXYucHJpbWUyKSkge1xuICAgIHIgPSBuZXcgYm4ocmFuZG9tQnl0ZXMobGVuKSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1yc2EvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXI7XG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xudmFyIE1BWF9MRU4gPSBidWZmZXIua01heExlbmd0aCB8fCAyMTQ3NDgzNjQ3O1xuZXhwb3J0cy5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IG5vdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xuICB2YXIgX2ZpbGwgPSBmaWxsO1xuICBpZiAoX2ZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgICBfZmlsbCA9IDA7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIGlmICh0eXBlb2YgX2ZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGZpbGxCdWYgPSBuZXcgQnVmZmVyKF9maWxsLCBlbmMpO1xuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgc2l6ZSkge1xuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKF9maWxsKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbn1cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmICghZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheS5mcm9tICE9PSBCdWZmZXIuZnJvbSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIG9mZnNldCA9IGVuY29kaW5nT3JPZmZzZXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZVNsb3coc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXItc2hpbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9icm93c2VyJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cblxudmFyIFpFUk9TID0gbmV3IEJ1ZmZlcigxMjgpXG5aRVJPUy5maWxsKDApXG5cbmZ1bmN0aW9uIEhtYWMoYWxnLCBrZXkpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIH1cblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoa2V5KS5kaWdlc3QoKVxuXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbmluaGVyaXRzKEhtYWMsIFRyYW5zZm9ybSlcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhLCBlbmMpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSG1hYy5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG5cbiAgbmV4dCgpXG59XG5cbkhtYWMucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuXG4gIHJldHVybiBjcmVhdGVIYXNoKHRoaXMuX2FsZykudXBkYXRlKHRoaXMuX29wYWQpLnVwZGF0ZShoKS5kaWdlc3QoZW5jKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoYWxnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NyZWF0ZS1obWFjL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vZGVzL3V0aWxzJyk7XG5leHBvcnRzLkNpcGhlciA9IHJlcXVpcmUoJy4vZGVzL2NpcGhlcicpO1xuZXhwb3J0cy5ERVMgPSByZXF1aXJlKCcuL2Rlcy9kZXMnKTtcbmV4cG9ydHMuQ0JDID0gcmVxdWlyZSgnLi9kZXMvY2JjJyk7XG5leHBvcnRzLkVERSA9IHJlcXVpcmUoJy4vZGVzL2VkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Rlcy5qcy9saWIvZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSBCdWZmZXIuaXNCdWZmZXIoY2h1bmspO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RyaW5nX2RlY29kZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5aCGXG4gKiBcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBIZWFwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmUgPSBkZWZhdWx0Q29tcHJlKSB7XG4gICAgICAgIHRoaXMuYXJyID0gW107XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgfVxuXG4gICAgYWRkKGVsZW0pIHtcbiAgICAgICAgdGhpcy5hcnIucHVzaChlbGVtKTtcblxuICAgICAgICBpZiAodGhpcy5hcnIubGVuZ3RoID09PSAxKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fdXBIZWFwQWRqdXN0KCh0aGlzLmFyci5sZW5ndGggPj4gMSkgLSAxKTtcbiAgICB9XG5cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hcnIubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbGV0IGhlYXAgPSB0aGlzLmFycjtcbiAgICAgICAgLy8g5Ye66Zif5YiX5pON5L2c77yM5by55Ye65pWw5o2u5aS05YWD57SgXG4gICAgICAgIGxldCBkYXRhID0gaGVhcFswXTtcbiAgICAgICAgLy8g55So5bC+5YWD57Sg5aGr5YWF5aS05YWD57SgXG4gICAgICAgIGhlYXBbMF0gPSBoZWFwW2hlYXAubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIOWIoOmZpOWwvuiKgueCuVxuICAgICAgICBoZWFwLnBvcCgpO1xuXG4gICAgICAgIC8v54S25ZCO5LuO5qC56IqC54K55LiL5ruk5aCGXG4gICAgICAgIGlmIChoZWFwLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLl9kb3duSGVhcEFkanVzdCgwKTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hcnIubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvLyDlr7nloIbov5vooYzkuIrmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcbiAgICBfdXBIZWFwQWRqdXN0KHBhcmVudCkge1xuICAgICAgICBsZXQgaGVhcCA9IHRoaXMuYXJyO1xuICAgICAgICBsZXQgbGVuID0gaGVhcC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgbGVmdENoaWxkID0gMiAqIHBhcmVudCArIDE7XG4gICAgICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XG4gICAgICAgICAgICBsZXQgbWF4ID0gbGVmdENoaWxkO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuY29tcGFyZShoZWFwW2xlZnRDaGlsZF0sIGhlYXBbcmlnaHRDaGlsZF0pIDwgMFxuICAgICAgICAgICAgICAgICAgICA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWmguaenHBhcmVudOiKgueCueWwj+S6juWug+eahOafkOS4quWtkOiKgueCueeahOivne+8jOatpOaXtuetm+mAieaTjeS9nFxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZShoZWFwW3BhcmVudF0sIGhlYXBbbWF4XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBoZWFwW3BhcmVudF07XG4gICAgICAgICAgICAgICAgaGVhcFtwYXJlbnRdID0gaGVhcFttYXhdO1xuICAgICAgICAgICAgICAgIGhlYXBbbWF4XSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICAvLyDnu6fnu63ov5vooYzmm7TkuIrkuIDlsYLnmoTov4fmu6RcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBNYXRoLmNlaWwocGFyZW50IC8gMikgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5a+55aCG6L+b6KGM5LiL5ruk5pON5L2c77yM5L2/5b6X5ruh6Laz5aCG5oCn6LSoXG4gICAgX2Rvd25IZWFwQWRqdXN0KHBhcmVudCkge1xuICAgICAgICBsZXQgaGVhcCA9IHRoaXMuYXJyO1xuICAgICAgICBsZXQgbGVuID0gaGVhcC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKDIgKiBwYXJlbnQgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICBsZXQgbGVmdENoaWxkID0gMiAqIHBhcmVudCArIDE7XG4gICAgICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XG4gICAgICAgICAgICBsZXQgbWF4ID0gbGVmdENoaWxkO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuY29tcGFyZShoZWFwW2xlZnRDaGlsZF0sIGhlYXBbcmlnaHRDaGlsZF0pIDwgMFxuICAgICAgICAgICAgICAgICAgICA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoaGVhcFtwYXJlbnRdLCBoZWFwW21heF0pIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gaGVhcFtwYXJlbnRdO1xuICAgICAgICAgICAgICAgIGhlYXBbcGFyZW50XSA9IGhlYXBbbWF4XTtcbiAgICAgICAgICAgICAgICBoZWFwW21heF0gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbWF4O1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmYXVsdENvbXByZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG5cbi8vIHZhciBhcnIgPSBbMSwgMCwgNSwgNCwgM107XG4vLyB2YXIgaGVhcCA9IG5ldyBIZWFwKCk7XG4vLyBmb3IgKGxldCBlbGUgb2YgYXJyKSB7XG4vLyAgICAgaGVhcC5hZGQoZWxlKTtcbi8vIH1cbi8vIGNvbnNvbGUubG9nKGBoZWFwOiAke2hlYXAuYXJyLmpvaW4oJywnKX1gKTtcbi8vIGZvciAobGV0IGVsZSBvZiBhcnIpIHtcbi8vICAgICBoZWFwLnJlbW92ZSgpO1xuLy8gICAgIGNvbnNvbGUubG9nKGBoZWFwOiAke2hlYXAuYXJyLmpvaW4oJywnKX1gKTtcbi8vIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9IZWFwL2luZGV4LmpzIiwiXG4vKipcbiAqIOWPjOWQkemTvuihqFxuICpcbiAqIOWPjOWQkemTvuihqOaYr+S4uuS6huWFi+acjeWNlemTvuihqOi/meenjeWNleWQkeaAp+eahOe8uueCueOAglxuICog5Y+M5ZCR6ZO+6KGo55qE57uT54K55Lit5pyJ5Lik5Liq5oyH6ZKI5Z+f77yM5YW25LiA5oyH5ZCR55u05o6l5ZCO57un77yM5Y+m5LiA5oyH5ZCR55u05o6l5YmN6LaL44CCXG4gKlxuICog5Y+M5ZCR6ZO+6KGo5Lmf5Y+v5Lul5pyJ5b6q546v6KGo44CCXG4gKi9cblxuY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcHJldiA9IG51bGwsIG5leHQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKHNxTGlzdCA9IFtdLCBjb21wYXJlID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcblxuICAgICAgICBpZihzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBzcUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHlpZWxkIGN1cnJlbnQuZGF0YTtcblxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cblxuICAgIGNsZWFyKCl7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVzaChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcigncGFyYW0gZGF0YSByZXF1aXJlZCcpO1xuXG4gICAgICAgICsrdGhpcy5zaXplO1xuXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gbmV3IE5vZGUoZGF0YSwgdGhpcy50YWlsLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdwYXJhbSBkYXRhIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgKyt0aGlzLnNpemU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgTm9kZShkYXRhLCBudWxsLCB0aGlzLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMudGFpbC5kYXRhO1xuXG4gICAgICAgIHRoaXMudGFpbC5wcmV2Lm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuaGVhZC5kYXRhO1xuXG4gICAgICAgIHRoaXMuaGVhZC5uZXh0LnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSB2YWx1ZSBvZiBleGlzdGluZyBub2RlIGJ5IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICB1cGRhdGUoaW5kZXgsIGRhdGEpe1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZmluZEJ5SW5kZXgoaW5kZXgsIHRydWUpO1xuXG4gICAgICAgIGlmIChub2RlKSBub2RlLmRhdGEgPSBkYXRhO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuICEhbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGZpcnN0IG1hdGNoZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICByZW1vdmUoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignUGFyYW0gZGF0YSByZXF1aXJlZCcpO1xuXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlKGRhdGEsIGN1cnJlbnQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wcmV2Lm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2ID0gY3VycmVudC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleE9mKGRhdGEpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZShkYXRhLCBjdXJyZW50LmRhdGEpKSByZXR1cm4gaW5kZXg7XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZCBub2RlIG9yIGRhdGEgYnkgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5Ob2RlIHRydWU6IHJldHVybiB0aGUgbm9kZSBvYmplY3Q7IG90aGVyd2lzZSByZXR1cm4gZGF0YTtcbiAgICAgKi9cbiAgICBmaW5kQnlJbmRleChpbmRleCA9IDAsIHJldHVybk5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBqID0gMDtcblxuICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICBpZiAoaisrID09PSBpbmRleCkgYnJlYWs7XG5cbiAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gcmV0dXJuTm9kZSA/IGN1cnJlbnQgOiAoY3VycmVudCA/IGN1cnJlbnQuZGF0YSA6IG51bGwpO1xuICAgIH1cblxuICAgIGZvckVhY2goY2IgPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgY2IoY3VycmVudC5kYXRhLCBpbmRleCsrKTtcblxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChjdXJyZW50LmRhdGEpO1xuXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSlNPTigpICsgJyc7XG4gICAgfVxufVxuXG5cbi8vIGxldCBhID0gbmV3IERvdWJsZUxpbmtlZExpc3QoWzIsIDNdKTtcbi8vIGEudW5zaGlmdCgxKTtcbi8vIGEucHVzaCg0KTtcbi8vIGNvbnNvbGUubG9nKGEuaW5kZXhPZig0KSk7XG4vLyBjb25zb2xlLmxvZyhhLmZpbmRCeUluZGV4KDIpKTtcblxuLy8gZm9yKGxldCBpdGVtIG9mIGEpe1xuLy8gICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xuLy8gfVxuXG4vLyBhLnBvcCgpO1xuLy8gYS5zaGlmdCgpO1xuLy8gYS5yZW1vdmUoMik7XG4vLyBhLnJlbW92ZSgzMik7XG4vLyBhLnJlbW92ZSgzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9MaXN0L0RvdWJsZUxpbmtlZExpc3QuanMiLCIvLyDpnZnmgIHljZXpk77ooahcbi8qXG4g5pyJ5pe25Y+v5YCf55So5LiA57u05pWw57uE5p2l5o+P6L+w57q/5oCn6ZO+6KGo77yM6L+Z5bCx5piv57q/5oCn6KGo55qE6Z2Z5oCB5Y2V6ZO+6KGo5a2Y5YKo57uT5p6E44CCXG4g5Zyo6Z2Z5oCB6ZO+6KGo5Lit77yM5pWw57uE55qE5LiA5Liq5YiG6YeP6KGo56S65LiA5Liq57uT54K577yM5ZCM5pe255So5ri45qCH77yIY3Vy77yJ5Luj5pu/5oyH6ZKI5oyH56S657uT54K55Zyo5pWw57uE5Lit55qE55u45a+55L2N572u44CCXG4g5pWw57uE55qE56ysMOWIhumHj+WPr+eci+aIkOWktOe7k+eCue+8jOWFtuaMh+mSiOWfn+aMh+ekuumTvuihqOeahOesrOS4gOS4que7k+eCueOAglxuIOi/meenjeWtmOWCqOe7k+aehOmcgOimgemihOWFiOWIhumFjeS4gOS4qui+g+Wkp+eahOepuumXtO+8jOS9huWcqOe6v+aAp+ihqOeahOaPkuWFpeWSjOWIoOmZpOaTjeS9nOaXtuS4jemcgOenu+WKqOWFg+e0oO+8jFxuIOS7hemcgOimgeS/ruaUueaMh+mSiO+8jOaVheS7jeWFt+aciemTvuW8j+WtmOWCqOe7k+aehOeahOS4u+imgeS8mOeCuVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY0xpbmtlZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKE1BWFNJWkUpIHtcbiAgICAgICAgdGhpc1stMV0gPSB7Y3VyOiAwfTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLk1BWFNJWkUgPSBNQVhTSVpFICsgMSB8fCAxMDAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWcqOmdmeaAgeWNlemTvue6v+aAp+ihqEzkuK3mn6Xmib7nrKwx5Liq5YC85Li6ZeeahOWFg+e0oO+8jFxuICAgICAqIOiLpeaJvuWIsO+8jOWImei/lOWbnuWug+WcqEzkuK3nmoTkvY3luo9cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGZpbmQgKGRhdGEpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzWzBdLmN1cjtcbiAgICAgICAgd2hpbGUgKGkgJiYgdGhpc1tpXS5kYXRhICE9PSBkYXRhKSB7XG4gICAgICAgICAgICBpID0gdGhpc1tpXS5jdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWwhuS4gOe7tOaVsOe7hOS4reWQhOWIhumHj+mTvuaIkOS4gOS4quWkh+eUqOmTvuihqFxuICAgICAqIHRoaXNbMF0uY3Vy5Li65aS05oyH6ZKIXG4gICAgICovXG4gICAgaW5pdCAobGVuKSB7XG4gICAgICAgIGxlbiA9IGxlbiA/IGxlbiArIDEgOiB0aGlzLk1BWFNJWkU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdGhpc1tpXSB8fCB7ZGF0YTogbnVsbCwgY3VyOiBudWxsfTtcbiAgICAgICAgICAgIHRoaXNbaV0uY3VyID0gaSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW2xlbiAtIDFdID0gdGhpc1tsZW4gLSAxXSB8fCB7fTtcbiAgICAgICAgdGhpc1tsZW4gLSAxXS5jdXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDoi6XlpIfnlKjpk77ooajpnZ7nqbrvvIzliJnov5Tlm57liIbphY3nmoTnu5PngrnkuIvmoIfvvIzlj43liJnov5Tlm54wXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgbWFsbG9jICgpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzWy0xXS5jdXI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1stMV0uY3VyICE9PSAndW5kZWZpbmVkJykgdGhpc1stMV0uY3VyID0gdGhpc1tpXS5jdXI7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlsIbkuIvmoIfkuLpr55qE56m66Zey57uT54K55Zue5pS25Yiw5aSH55So6ZO+6KGoXG4gICAgICogQHBhcmFtIGtcbiAgICAgKi9cbiAgICBmcmVlIChrKSB7XG4gICAgICAgIHRoaXNba10uY3VyID0gdGhpc1swXS5jdXI7XG4gICAgICAgIHRoaXNbMF0uY3VyID0gaztcbiAgICB9XG5cbiAgICBjcmVhdGUgKHNxTGlzdCkge1xuICAgICAgICAvLyDliJ3lp4vljJblpIfnlKjnqbrpl7RcbiAgICAgICAgdGhpcy5pbml0KHNxTGlzdC5sZW5ndGgpO1xuICAgICAgICAvLyDnlJ/miJBz55qE5aS057uT54K5XG4gICAgICAgIGxldCBzID0gdGhpcy5tYWxsb2MoKTtcbiAgICAgICAgLy8gcuaMh+WQkXPnmoTlvZPliY3mnIDlkI7nu5PngrlcbiAgICAgICAgbGV0IHIgPSBzO1xuICAgICAgICBsZXQgbSA9IHNxTGlzdC5sZW5ndGg7XG5cbiAgICAgICAgLy8g5bu656uL6ZuG5ZCIQeeahOmTvuihqFxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgLy/liIbphY3nu5PngrlcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5tYWxsb2MoKTtcbiAgICAgICAgICAgIC8vIOi+k+WFpUHlhYPntKDnmoTlgLxcbiAgICAgICAgICAgIHRoaXNbaV0uZGF0YSA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxuICAgICAgICAgICAgdGhpc1tyXS5jdXIgPSBpO1xuICAgICAgICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIHIgPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIOWwvue7k+eCueeahOaMh+mSiOS4uuepulxuICAgICAgICB0aGlzW3JdLmN1ciA9IDA7XG4gICAgfVxuXG4gICAgLy8gdG9kb1xuICAgIGFkZCAoaW5kZXgsIGVsZW0pIHtcbiAgICB9XG5cbiAgICByZW1vdmUgKGluZGV4KSB7XG4gICAgfVxufVxuXG4vKipcbiAqIOWcqOS4gOe7tOaVsOe7hOS4reW7uueri+ihqOekuumbhuWQiChBLUIpVShCLUEpXG4gKiDnmoTpnZnmgIHpk77ooajvvIxz5Li65YW25aS05oyH6ZKI44CCXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZShzbGxpc3QsIGFycjEsIGFycjIpIHtcbiAgICAvLyDliJ3lp4vljJblpIfnlKjnqbrpl7RcbiAgICBzbGxpc3QuaW5pdCgpO1xuICAgIC8vIOeUn+aIkHPnmoTlpLTnu5PngrlcbiAgICBsZXQgcyA9IHNsbGlzdC5tYWxsb2MoKTtcbiAgICAvLyBy5oyH5ZCRc+eahOW9k+WJjeacgOWQjue7k+eCuVxuICAgIGxldCByID0gcztcbiAgICAvLyDliKDpmaRB5ZKMQueahOWFg+e0oOS4quaVsFxuICAgIGxldCBtID0gYXJyMS5sZW5ndGg7XG4gICAgbGV0IG4gPSBhcnIyLmxlbmd0aDtcblxuICAgIC8vIOW7uueri+mbhuWQiEHnmoTpk77ooahcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAvL+WIhumFjee7k+eCuVxuICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcbiAgICAgICAgLy8g6L6T5YWlQeWFg+e0oOeahOWAvFxuICAgICAgICBzbGxpc3RbaV0uZGF0YSA9IGFycjFbal07XG4gICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxuICAgICAgICBzbGxpc3Rbcl0uY3VyID0gaTtcbiAgICAgICAgciA9IGk7XG4gICAgfVxuICAgIC8vIOWwvue7k+eCueeahOaMh+mSiOS4uuepulxuICAgIHNsbGlzdFtyXS5jdXIgPSAwO1xuXG4gICAgLy8g5L6d5qyh6L6T5YWlQueahOWFg+e0oO+8jOiLpeS4jeWcqOW9k+WJjeihqOS4re+8jOWImeaPkuWFpe+8jFxuICAgIC8vIOWQpuWImeWIoOmZpFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgIGxldCBiID0gYXJyMltqXTtcbiAgICAgICAgbGV0IHAgPSBzO1xuICAgICAgICAvLyBr5oyH5ZCR6ZuG5ZCI5Lit55qE56ys5LiA5Liq57uT54K5XG4gICAgICAgIGxldCBrID0gc2xsaXN0W3NdLmN1cjtcbiAgICAgICAgLy8g5Zyo5b2T5YmN6KGo5Lit5p+l5om+XG4gICAgICAgIHdoaWxlIChrICE9PSBzbGxpc3Rbcl0uY3VyICYmIHNsbGlzdFtrXS5kYXRhICE9PSBiKSB7XG4gICAgICAgICAgICBwID0gaztcbiAgICAgICAgICAgIGsgPSBzbGxpc3Rba10uY3VyO1xuICAgICAgICB9XG4gICAgICAgIC8vIOW9k+WJjeihqOS4reS4jeWtmOWcqOivpeWFg+e0oO+8jOaPkuWFpeWcqHLmiYDmjIfnu5PngrnkuYvlkI7vvIzkuJRy55qE5L2N572u5LiN5Y+YXG4gICAgICAgIGlmIChrID09PSBzbGxpc3Rbcl0uY3VyKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcbiAgICAgICAgICAgIHNsbGlzdFtpXS5kYXRhID0gYjtcbiAgICAgICAgICAgIHNsbGlzdFtpXS5jdXIgPSBzbGxpc3Rbcl0uY3VyO1xuICAgICAgICAgICAgc2xsaXN0W3JdLmN1ciA9IGk7XG5cbiAgICAgICAgICAgIC8vIOivpeWFg+e0oOW3suWcqOihqOS4re+8jOWIoOmZpOS5i1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xsaXN0W3BdLmN1ciA9IHNsbGlzdFtrXS5jdXI7XG4gICAgICAgICAgICBzbGxpc3QuZnJlZShrKTtcbiAgICAgICAgICAgIC8vIOiLpeWIoOmZpOeahOaYr3LmiYDmjIfnu5PngrnvvIzliJnpnIDkv67mlLnlsL7mjIfpkohcbiAgICAgICAgICAgIGlmIChyID09PSBrKSByID0gcDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IHNsID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoMTApO1xubGV0IHJldCA9IGRpZmZlcmVuY2Uoc2wsIFsxLCAyLCAzXSwgWzMsIDQsIDVdKTtcbmNvbnNvbGUubG9nKHNsKTtcblxuXG5sZXQgdGVzdCA9IG5ldyBTdGF0aWNMaW5rZWRMaXN0KDEwKTtcbnRlc3QuY3JlYXRlKFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDldKTtcbmNvbnNvbGUubG9nKHRlc3QpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9MaXN0L1N0YXRpY0xpbmtlZExpc3QuanMiLCIvKlxuIOWKqOaAgeafpeaJvlxuXG4g5b2T5p+l5om+6KGo5Lul57q/5oCn6KGo55qE5b2i5byP57uE57uH5pe277yM6Iul5a+55p+l5om+6KGo6L+b6KGM5o+S5YWl44CB5Yig6Zmk5oiW5o6S5bqP5pON5L2c77yM5bCx5b+F6aG756e75Yqo5aSn6YeP55qE6K6w5b2V77yM5b2T6K6w5b2V5pWw5b6I5aSa5pe277yM6L+Z56eN56e75Yqo55qE5Luj5Lu35b6I5aSn44CCXG4g5Yip55So5qCR55qE5b2i5byP57uE57uH5p+l5om+6KGo77yM5Y+v5Lul5a+55p+l5om+6KGo6L+b6KGM5Yqo5oCB6auY5pWI55qE5p+l5om+44CCXG5cblxuIOS6jOWPieaOkuW6j+agkShCU1Qp55qE5a6a5LmJXG5cbiDkuozlj4nmjpLluo/moJEoQmluYXJ5IFNvcnQgVHJlZeaIlkJpbmFyeSBTZWFyY2ggVHJlZSkg55qE5a6a5LmJ5Li677ya5LqM5Y+J5o6S5bqP5qCR5oiW6ICF5piv56m65qCR77yM5oiW6ICF5piv5ruh6Laz5LiL5YiX5oCn6LSo55qE5LqM5Y+J5qCR44CCXG4gKDEpIO+8muiLpeW3puWtkOagkeS4jeS4uuepuu+8jOWImeW3puWtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95bCP5LqO5qC557uT54K555qE5YC877ybXG4gKDIpIO+8muiLpeWPs+WtkOagkeS4jeS4uuepuu+8jOWImeWPs+WtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95aSn5LqO5qC557uT54K555qE5YC877ybXG4gKDMpIO+8muW3puOAgeWPs+WtkOagkemDveWIhuWIq+aYr+S6jOWPieaOkuW6j+agkeOAglxuIOe7k+iuuu+8muiLpeaMieS4reW6j+mBjeWOhuS4gOajteS6jOWPieaOkuW6j+agke+8jOaJgOW+l+WIsOeahOe7k+eCueW6j+WIl+aYr+S4gOS4qumAkuWinuW6j+WIl+OAglxuXG5cbiBCU1TmoJHnmoTmn6Xmib5cbiAxICDmn6Xmib7mgJ3mg7NcbiDpppblhYjlsIbnu5nlrprnmoRL5YC85LiO5LqM5Y+J5o6S5bqP5qCR55qE5qC557uT54K555qE5YWz6ZSu5a2X6L+b6KGM5q+U6L6D77ya6Iul55u4562J77yaIOWImeafpeaJvuaIkOWKn++8m1xuIOKRoCDnu5nlrprnmoRL5YC85bCP5LqOQlNU55qE5qC557uT54K555qE5YWz6ZSu5a2X77ya57un57ut5Zyo6K+l57uT54K555qE5bem5a2Q5qCR5LiK6L+b6KGM5p+l5om+77ybXG4g4pGhIOe7meWumueahEvlgLzlpKfkuo5CU1TnmoTmoLnnu5PngrnnmoTlhbPplK7lrZfvvJrnu6fnu63lnKjor6Xnu5PngrnnmoTlj7PlrZDmoJHkuIrov5vooYzmn6Xmib7jgIJcblxuIOWcqOmaj+acuuaDheWGteS4i++8jOS6jOWPieaOkuW6j+agkeeahOW5s+Wdh+afpeaJvumVv+W6pkFTTOWSjOOPkihuKSjmoJHnmoTmt7HluqYp5piv562J5pWw6YeP57qn55qE44CCXG5cblxuIEJTVOagkeeahOaPkuWFpVxuXG4g5ZyoQlNU5qCR5Lit5o+S5YWl5LiA5Liq5paw57uT54K577yM6KaB5L+d6K+B5o+S5YWl5ZCO5LuN5ruh6LazQlNU55qE5oCn6LSo44CCXG5cbiAxIOaPkuWFpeaAneaDs1xuIOWcqEJTVOagkeS4reaPkuWFpeS4gOS4quaWsOe7k+eCuXjml7bvvIzoi6VCU1TmoJHkuLrnqbrvvIzliJnku6TmlrDnu5Pngrl45Li65o+S5YWl5ZCOQlNU5qCR55qE5qC557uT54K577yb5ZCm5YiZ77yM5bCG57uT54K5eOeahOWFs+mUruWtl+S4juaguee7k+eCuVTnmoTlhbPplK7lrZfov5vooYzmr5TovoPvvJpcbiDikaAg6Iul55u4562J77yaIOS4jemcgOimgeaPkuWFpe+8m1xuIOKRoSAg6IuleC5rZXk8VC0+a2V577ya57uT54K5eOaPkuWFpeWIsFTnmoTlt6blrZDmoJHkuK3vvJtcbiDikaIgIOiLpXgua2V5PlQtPmtlee+8mue7k+eCuXjmj5LlhaXliLBU55qE5Y+z5a2Q5qCR5Lit44CCXG5cbiDnlLHnu5Porrrnn6XvvIzlr7nkuo7kuIDkuKrml6Dluo/luo/liJflj6/ku6XpgJrov4fmnoTpgKDkuIDmo7VCU1TmoJHogIzlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcbiDnlLHnrpfms5Xnn6XvvIzmr4/mrKHmj5LlhaXnmoTmlrDnu5Pngrnpg73mmK9CU1TmoJHnmoTlj7blrZDnu5PngrnvvIzljbPlnKjmj5LlhaXml7bkuI3lv4Xnp7vliqjlhbblroPnu5PngrnvvIzku4XpnIDkv67mlLnmn5DkuKrnu5PngrnnmoTmjIfpkojjgIJcblxuXG4gQlNU5qCR55qE5Yig6ZmkXG5cbiAxICDliKDpmaTmk43kvZzov4fnqIvliIbmnpBcbiDku45CU1TmoJHkuIrliKDpmaTkuIDkuKrnu5PngrnvvIzku43nhLbopoHkv53or4HliKDpmaTlkI7mu6HotrNCU1TnmoTmgKfotKjjgILorr7ooqvliKDpmaTnu5PngrnkuLpw77yM5YW254i257uT54K55Li6ZiDvvIzliKDpmaTmg4XlhrXlpoLkuIvvvJpcbiDikaAgIOiLpXDmmK/lj7blrZDnu5PngrnvvJog55u05o6l5Yig6ZmkcOOAglxuIOKRoSAg6IulcOWPquacieS4gOajteWtkOagkSjlt6blrZDmoJHmiJblj7PlrZDmoJEp77ya55u05o6l55SocOeahOW3puWtkOagkSjmiJblj7PlrZDmoJEp5Y+W5LujcOeahOS9jee9ruiAjOaIkOS4umbnmoTkuIDmo7XlrZDmoJHjgILljbPljp/mnaVw5pivZueahOW3puWtkOagke+8jOWImXDnmoTlrZDmoJHmiJDkuLpm55qE5bem5a2Q5qCR77yb5Y6f5p2lcOaYr2bnmoTlj7PlrZDmoJHvvIzliJlw55qE5a2Q5qCR5oiQ5Li6ZueahOWPs+WtkOagkeOAglxuIOKRoiDoi6Vw5pei5pyJ5bem5a2Q5qCR5Y+I5pyJ5Y+z5a2Q5qCRIO+8muWkhOeQhuaWueazleacieS7peS4i+S4pOenje+8jOWPr+S7peS7u+mAieWFtuS4reS4gOenjeOAglxuIOKXhiAg55SocOeahOebtOaOpeWJjempsee7k+eCueS7o+abv3DjgILljbPku45w55qE5bem5a2Q5qCR5Lit6YCJ5oup5YC85pyA5aSn55qE57uT54K5c+aUvuWcqHDnmoTkvY3nva4o55So57uT54K5c+eahOWGheWuueabv+aNoue7k+eCuXDlhoXlrrkp77yM54S25ZCO5Yig6Zmk57uT54K5c+OAgnPmmK9w55qE5bem5a2Q5qCR5Lit55qE5pyA5Y+z6L6555qE57uT54K55LiU5rKh5pyJ5Y+z5a2Q5qCR77yM5a+5c+eahOWIoOmZpOWQjOKRoeOAglxuIOKXhiDnlKhw55qE55u05o6l5ZCO57un57uT54K55Luj5pu/cOOAguWNs+S7jnDnmoTlj7PlrZDmoJHkuK3pgInmi6nlgLzmnIDlsI/nmoTnu5Pngrlz5pS+5ZyocOeahOS9jee9rijnlKjnu5Pngrlz55qE5YaF5a655pu/5o2i57uT54K5cOWGheWuuSnvvIznhLblkI7liKDpmaTnu5Pngrlz44CCc+aYr3DnmoTlj7PlrZDmoJHkuK3nmoTmnIDlt6bovrnnmoTnu5PngrnkuJTmsqHmnInlt6blrZDmoJHvvIzlr7lz55qE5Yig6Zmk5ZCM4pGh44CCXG5cbiAqL1xuXG5pbXBvcnQgeyBCaW5hcnlUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQlNUTm9kZSBleHRlbmRzIEJpbmFyeVRyZWUge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZykge1xuICAgICAgICBzdXBlciguLi5hcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJTVOagkeeahOafpeaJvu+8iOmAkuW9ku+8iVxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2VhcmNoKGtleSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnRDaGlsZC5zZWFyY2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Q2hpbGQuc2VhcmNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCU1TmoJHnmoTmn6Xmib7vvIjpnZ7pgJLlvZLvvIlcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNlYXJjaE5vblJlY3Vyc2l2ZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmIHAuZGF0YSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICBlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXAgfHwga2V5ICE9PSBwLmRhdGEpIHJldHVybiBudWxsO1xuICAgICAgICBlbHNlIHJldHVybiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmAkuW9ku+8iVxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICovXG4gICAgaW5zZXJ0KGtleSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGtleTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLmRhdGEpIHJldHVybjtcblxuICAgICAgICBsZXQgbm9kZSA9IG5ldyBCU1ROb2RlKGtleSk7XG4gICAgICAgIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMubGVmdENoaWxkLmluc2VydChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQuaW5zZXJ0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCU1TmoJHnmoTmj5LlhaXvvIjpnZ7pgJLlvZLvvIlcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqL1xuICAgIGluc2VydE5vblJlY3Vyc2l2ZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBxO1xuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgaWYgKHAuZGF0YSA9PT0ga2V5KSByZXR1cm47XG4gICAgICAgICAgICAvLyBx5L2c5Li6cOeahOeItuiKgueCuVxuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICBlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IG5ldyBCU1ROb2RlKGtleSk7XG4gICAgICAgIGlmIChrZXkgPCBxLmRhdGEpIHEubGVmdENoaWxkID0gbm9kZTtcbiAgICAgICAgZWxzZSBxLnJpZ2h0Q2hpbGQgPSBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWIqeeUqEJTVOagkeeahOaPkuWFpeaTjeS9nOW7uueri+S4gOajtUJTVOagkVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnx1bmRlZmluZWR9IHVzZU5vblJlY3Vyc2l2ZSDmmK/lkKbkvb/nlKjpnZ7pgJLlvZJcbiAgICAgKi9cbiAgICBjcmVhdGVCU1QoYXJyLCB1c2VOb25SZWN1cnNpdmUpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh1c2VOb25SZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb25SZWN1cnNpdmUoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoYXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS9v+eUqOmAkuW9kueahOaWueazleWIoOmZpOS4juWFs+mUruWtl+espuWQiOeahOe7k+eCuVxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IOmcgOimgeafpeaJvueahOWFs+mUruWtl1xuICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gcGFyZW50IOeItuiKgueCue+8jOWGhemDqOiwg+eUqOmcgOimgeeUqOWIsFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHJlbW92ZShrZXksIHBhcmVudCkge1xuICAgICAgICAvLyDnqbrnu5PngrnnmoTmg4XlhrVcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8g5om+5Yiw5YWz6ZSu5a2XXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIGRlbGV0ZU5vZGUodGhpcywgcGFyZW50KTtcbiAgICAgICAgLy8g5p+l5om+5bem5a2Q5qCR77yM5aaC5p6c5pyJ55qE6K+dXG4gICAgICAgIGVsc2UgaWYgKGtleSA8IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSByZXR1cm4gdGhpcy5sZWZ0Q2hpbGQucmVtb3ZlKGtleSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5p+l5om+5Y+z5a2Q5qCR77yM5aaC5p6c5pyJ55qE6K+dXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgcmV0dXJuIHRoaXMucmlnaHRDaGlsZC5yZW1vdmUoa2V5LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOacquaJvuWIsFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Z2e6YCS5b2S5Yig6Zmk5LiO5YWz6ZSu5a2X56ym5ZCI55qE57uT54K5XG4gICAgICogQHBhcmFtIHsqfSBrZXkg6ZyA6KaB5p+l5om+55qE5YWz6ZSu5a2XXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcmVtb3ZlTm9uUmVjdXJzaXZlKGtleSkge1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBmO1xuXG4gICAgICAgIHdoaWxlIChwICYmIHAuZGF0YSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBmID0gcDtcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgICAgIGVsc2UgcCA9IHAucmlnaHRDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOayoeacieimgeWIoOmZpOeahOe7k+eCuVxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyDmib7liLDkuobopoHliKDpmaTnmoTnu5PngrlwXG4gICAgICAgIGxldCBzID0gcDtcbiAgICAgICAgbGV0IHE7XG4gICAgICAgIC8vIOWmguaenOacieW3puWPs+WtkOagkVxuICAgICAgICBpZiAocC5sZWZ0Q2hpbGQgJiYgcC5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICBmID0gcDtcbiAgICAgICAgICAgIHMgPSBwLmxlZnRDaGlsZDtcblxuICAgICAgICAgICAgLy8g5om+5Yiw5bem5a2Q5qCR55qE5pyA5aSn5Y+z5a2Q5qCR77yM5Y2z5LuF5bCP5LqO5bem5a2Q5qCR55qE5YC855qE57uT54K5XG4gICAgICAgICAgICB3aGlsZSAocy5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZiA9IHM7XG4gICAgICAgICAgICAgICAgcyA9IHMucmlnaHRDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5kYXRhID0gcy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6Iulc+acieW3puWtkOagke+8jOWPs+WtkOagkeS4uuepulxuICAgICAgICBpZiAocy5sZWZ0Q2hpbGQpIHEgPSBzLmxlZnRDaGlsZDtcbiAgICAgICAgZWxzZSBxID0gcy5yaWdodENoaWxkO1xuXG4gICAgICAgIC8vIOWPquacieS4gOS4quaguee7k+eCueeahOaDheWGtVxuICAgICAgICBpZiAoIWYpIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIGVsc2UgaWYgKGYubGVmdENoaWxkID09IHMpIGYubGVmdENoaWxkID0gcTtcbiAgICAgICAgZWxzZSBmLnJpZ2h0Q2hpbGQgPSBxO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaJvuWIsOWwj+S6jnjnmoTmnIDlpKflhYPntKDlkozlpKfkuo5455qE5pyA5bCP5YWD57SgXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge0FycmF5fSBbbWluLCBtYXhdXG4gICAgICovXG4gICAgZmluZE5laWdoYm9yRWxlbSh4KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdHlwZW9mIHRoaXMuZGF0YSA9PT0gJ251bWJlcicgPyAtSW5maW5pdHkgOiAnYSc7XG4gICAgICAgIGxldCByZXQgPSBbXTtcblxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2UodHJlZSwgeCkge1xuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSByZWN1cnNlKHRyZWUubGVmdENoaWxkLCB4KTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgeCAmJiB0cmVlLmRhdGEgPj0geCkgcmV0WzBdID0gbGFzdDtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IHggJiYgdHJlZS5kYXRhID4geCkgcmV0WzFdID0gdHJlZS5kYXRhO1xuICAgICAgICAgICAgbGFzdCA9IHRyZWUuZGF0YTtcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCB4KTtcbiAgICAgICAgfSh0aGlzLCB4KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKiuS6jOWPieaOkuW6j+agkWJzdOWQiOW5tuWIsOivpeagkeS4rVxuICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gYnN0XG4gICAgICovXG4gICAgbWVyZ2UoYnN0KSB7XG4gICAgICAgIGlmIChic3QubGVmdENoaWxkKSB0aGlzLm1lcmdlKGJzdC5sZWZ0Q2hpbGQpO1xuICAgICAgICBpZiAoYnN0LnJpZ2h0Q2hpbGQpIHRoaXMubWVyZ2UoYnN0LnJpZ2h0Q2hpbGQpO1xuICAgICAgICB0aGlzLmluc2VydChic3QuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqK57uT54K55o+S5YWl5Yiw5ZCI6YCC5L2N572uXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBub2RlIOW+heaPkuWFpeeahOe7k+eCuVxuICAgICAqL1xuICAgIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkID0gbm9kZTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMucmlnaHRDaGlsZC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmRhdGEgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLmxlZnRDaGlsZC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5sZWZ0Q2hpbGQgPSBub2RlLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWIhuijguS4uuS4pOajteS6jOWPieaOkuW6j+agkVxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm5zIHtCU1ROb2RlW2EsIGJdfSBh55qE5YWD57Sg5YWo6YOo5bCP5LqO562J5LqOeO+8jGLnmoTlhYPntKDlhajpg6jlpKfkuo54XG4gICAgICovXG4gICAgc3BsaXQoeCkge1xuICAgICAgICBsZXQgYSA9IG5ldyBCU1ROb2RlKCk7XG4gICAgICAgIGxldCBiID0gbmV3IEJTVE5vZGUoKTtcblxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHNwbGl0KHRyZWUsIHgpIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgc3BsaXQodHJlZS5sZWZ0Q2hpbGQsIHgpO1xuICAgICAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCkgc3BsaXQodHJlZS5yaWdodENoaWxkLCB4KTtcbiAgICAgICAgICAgIGlmICh0cmVlLmRhdGEgPD0geCkgYS5pbnNlcnROb2RlKHRyZWUpO1xuICAgICAgICAgICAgZWxzZSBiLmluc2VydE5vZGUodHJlZSk7XG4gICAgICAgIH0odGhpcywgeCk7XG5cbiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq10cmVl5piv5ZCm5piv5LqM5Y+J5o6S5bqP5qCRXG4gICAgICogQHBhcmFtIHRyZWVcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCU1RUcmVlKHRyZWUpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0eXBlb2YgdHJlZS5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcbiAgICAgICAgbGV0IGZsYWcgPSB0cnVlO1xuXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gaXNCU1RUcmVlKHRyZWUpIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCAmJiBmbGFnKSBpc0JTVFRyZWUodHJlZS5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRyZWUuZGF0YSA8IGxhc3QpIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxhc3QgPSB0cmVlLmRhdGE7XG4gICAgICAgICAgICBpZiAodHJlZS5yaWdodENoaWxkICYmIGZsYWcpIGlzQlNUVHJlZSh0cmVlLnJpZ2h0Q2hpbGQpO1xuXG4gICAgICAgIH0odHJlZSk7XG5cbiAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgfVxufVxuXG4vKipcbiAqIOWIoOmZpOe7k+eCuVxuICogQHBhcmFtIHtCU1ROb2RlfSBwIOimgeWIoOmZpOeahOe7k+eCuVxuICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg6KaB5Yig6Zmk55qE57uT54K555qE54i26IqC54K5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0g6L+U5Zue5Yig6Zmk5oiQ5YqfXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU5vZGUocCwgcGFyZW50KSB7XG4gICAgLy8g5Y+25a2Q57uT54K55oiW5Y+q5pyJ5LiA5Liq57uT54K5XG4gICAgaWYgKCFwLmxlZnRDaGlsZCAmJiAhcC5yaWdodENoaWxkKSB7XG4gICAgICAgIC8vIOW9k+WJjee7k+eCueaYr+WFtueItue7k+eCueeahOW3puWtkOagkei/mOaYr+WPs+WtkOagkVxuICAgICAgICBsZXQgcG9zID0gcGFyZW50ICYmIHBhcmVudC5sZWZ0Q2hpbGQgPT0gcCA/ICdsZWZ0Q2hpbGQnIDogJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICBpZiAocGFyZW50KSBwYXJlbnRbcG9zXSA9IG51bGw7XG4gICAgICAgIC8vIOWPquacieS4gOS4que7k+eCueeahOaDheWGtVxuICAgICAgICBlbHNlICBwLmRhdGEgPSBudWxsO1xuICAgIH1cbiAgICAvLyDlj6rmnInlt6blrZDmoJFcbiAgICBlbHNlIGlmICghcC5yaWdodENoaWxkKSB7XG4gICAgICAgIHAuZGF0YSA9IHAubGVmdENoaWxkLmRhdGE7XG4gICAgICAgIHAubGVmdENoaWxkID0gcC5sZWZ0Q2hpbGQubGVmdENoaWxkO1xuICAgIH1cbiAgICAvLyDlj6rmnInlj7PlrZDmoJFcbiAgICBlbHNlIGlmICghcC5sZWZ0Q2hpbGQpIHtcbiAgICAgICAgcC5kYXRhID0gcC5yaWdodENoaWxkLmRhdGE7XG4gICAgICAgIHAucmlnaHRDaGlsZCA9IHAucmlnaHRDaGlsZC5yaWdodENoaWxkO1xuICAgIH1cbiAgICAvLyDlt6blj7PlrZDmoJHpg73mnIlcbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHMgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgLy8gceS4uueItue7k+eCuVxuICAgICAgICBsZXQgcSA9IHA7XG4gICAgICAgIC8vIOaJvuWIsOW3puWtkOagkeeahOacgOWkp+WPs+WtkOagke+8jOWNs+S7heWwj+S6juW3puWtkOagkeeahOWAvOeahOe7k+eCuVxuICAgICAgICB3aGlsZSAocy5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICBxID0gcztcbiAgICAgICAgICAgIHMgPSBzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XG4gICAgICAgIGlmIChxICE9IHApIHEucmlnaHRDaGlsZCA9IHMubGVmdENoaWxkO1xuICAgICAgICBlbHNlIHEubGVmdENoaWxkID0gcy5sZWZ0Q2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmxldCBic3QgPSBuZXcgQlNUTm9kZSgpO1xuYnN0LmNyZWF0ZUJTVChbNDUsIDI0LCA1MywgMTIsIDI0LCA5MF0pO1xuY29uc29sZS5sb2coYnN0LnNlYXJjaCgxMikpO1xuY29uc29sZS5sb2coYnN0LnNlYXJjaCgxMykpO1xuXG5sZXQgYnN0MiA9IG5ldyBCU1ROb2RlKCk7XG5ic3QyLmNyZWF0ZUJTVChbNDUsIDI0LCA1MywgMTIsIDI0LCA5MF0sIHRydWUpO1xuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTIpKTtcbmNvbnNvbGUubG9nKGJzdDIuc2VhcmNoTm9uUmVjdXJzaXZlKDEzKSk7XG5cbmNvbnNvbGUubG9nKCdcXG5maW5kU2libGluZ0VsZW06ICcpO1xuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oMTIpICsgJycpO1xuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oOTApICsgJycpO1xuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oNDUpICsgJycpO1xuXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDQ1KSk7XG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDEpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoNTMpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMTIpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoOTApKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMjQpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMikpO1xuXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDQ1KSk7XG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDEpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNTMpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMTIpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoOTApKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMjQpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMikpO1xuXG5jb25zb2xlLmxvZygnXFxuaXNCU1RUcmVlOiAnKTtcbmNvbnNvbGUubG9nKEJTVE5vZGUuaXNCU1RUcmVlKGJzdCkpO1xuLy9jb25zb2xlLmxvZyhCU1ROb2RlLmlzQlNUVHJlZShzb3NUcmVlKSk7XG5cblxuLyoqXG4gKiDku47lpKfliLDlsI/ovpPlh7rkuozlj4nmjpLluo/moJHkuK3miYDmnInkuI3lsI/kuo5455qE5YWD57SgXG4gKiBAcGFyYW0gYnN0XG4gKiBAcGFyYW0geFxuICovXG5mdW5jdGlvbiBwcmludE5vdExlc3NUaGFuKGJzdCwgeCkge1xuICAgIGlmIChic3QucmlnaHRDaGlsZCkgcHJpbnROb3RMZXNzVGhhbihic3QucmlnaHRDaGlsZCwgeCk7XG4gICAgaWYgKGJzdC5kYXRhIDwgeCkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKGJzdC5kYXRhKTtcbiAgICBpZiAoYnN0LmxlZnRDaGlsZCkgcHJpbnROb3RMZXNzVGhhbihic3QubGVmdENoaWxkLCB4KTtcbn1cblxuY29uc29sZS5sb2coJ1xcbnByaW50Tm90TGVzc1RoYW46ICcpO1xucHJpbnROb3RMZXNzVGhhbihic3QyLCA5MCk7XG5jb25zb2xlLmxvZygnXFxuJyk7XG5wcmludE5vdExlc3NUaGFuKGJzdDIsIDEyKTtcblxuXG5ic3QubWVyZ2UoYnN0Mik7XG5cbmxldCBhMSA9IG5ldyBCU1ROb2RlKDUpO1xubGV0IGEyID0gbmV3IEJTVE5vZGUoOTEpO1xuYnN0Mi5pbnNlcnROb2RlKGExKTtcbmJzdDIuaW5zZXJ0Tm9kZShhMik7XG5cbmJzdDIuc3BsaXQoNDUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlLmpzIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8yLzIuXG4gKi9cblxuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XG5cbi8qXG4g5Lqk5o2i5o6S5bqPXG5cbiDmmK/kuIDnsbvln7rkuo7kuqTmjaLnmoTmjpLluo/vvIzns7vnu5/lnLDkuqTmjaLlj43luo/nmoTorrDlvZXnmoTlgbblr7nvvIznm7TliLDkuI3lho3mnInov5nmoLfnmoTlgbblr7nkuLrmraLjgILlhbbkuK3mnIDln7rmnKznmoTmmK/lhpLms6HmjpLluo8oQnViYmxlIFNvcnQp44CCXG5cbiDlhpLms6HmjpLluo9cbiAxICDmjpLluo/mgJ3mg7NcbiDkvp3mrKHmr5TovoPnm7jpgrvnmoTkuKTkuKrorrDlvZXnmoTlhbPplK7lrZfvvIzoi6XkuKTkuKrorrDlvZXmmK/lj43luo/nmoQo5Y2z5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2X5aSn5LqO5ZCO5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2XKe+8jOWImei/m+ihjOS6pOaNou+8jOebtOWIsOayoeacieWPjeW6j+eahOiusOW9leS4uuatouOAglxuICAgICDikaAg6aaW5YWI5bCGTC0+UlsxXeS4jkwtPlJbMl3nmoTlhbPplK7lrZfov5vooYzmr5TovoPvvIzoi6XkuLrlj43luo8oTC0+UlsxXeeahOWFs+mUruWtl+Wkp+S6jkwtPlJbMl3nmoTlhbPplK7lrZcp77yM5YiZ5Lqk5o2i5Lik5Liq6K6w5b2V77yb54S25ZCO5q+U6L6DTC0+UlsyXeS4jkwtPlJbM13nmoTlhbPplK7lrZfvvIzkvp3mraTnsbvmjqjvvIznm7TliLBMLT5SW24tMV3kuI5MLT5SW25d55qE5YWz6ZSu5a2X5q+U6L6D5ZCO5Li65q2i77yM56ew5Li65LiA6Laf5YaS5rOh5o6S5bqP77yMTC0+UltuXeS4uuWFs+mUruWtl+acgOWkp+eahOiusOW9leOAglxuICAgICDikaEgIOeEtuWQjui/m+ihjOesrOS6jOi2n+WGkuazoeaOkuW6j++8jOWvueWJjW4tMeS4quiusOW9lei/m+ihjOWQjOagt+eahOaTjeS9nOOAglxuIOS4gOiIrOWcsO+8jOesrGnotp/lhpLms6HmjpLluo/mmK/lr7lMLT5SWzEg4oCmIG4taSsxXeS4reeahOiusOW9lei/m+ihjOeahO+8jOWboOatpO+8jOiLpeW+heaOkuW6j+eahOiusOW9leaciW7kuKrvvIzliJnopoHnu4/ov4duLTHotp/lhpLms6HmjpLluo/miY3og73kvb/miYDmnInnmoTorrDlvZXmnInluo/jgIJcblxuIDIgIOaOkuW6j+ekuuS+i1xuIOiuvuaciTnkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLoyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXG5cbiDliJ3lp4vlhbPplK7lrZfluo/liJc6ICAyMyAgICAzOCAgICAgMjIgICAgIDQ1ICAgICAyMyAgICAgNjcgICAgIDMxICAgICAxNSAgICA0MVxuIOesrOS4gOi2n+aOkuW6j+WQjjogICAgMjMgICAgMjIgICAgIDM4ICAgICAyMyAgICAgNDUgICAgIDMxICAgICAxNSAgICAgNDEgICAgNjdcbiDnrKzkuozotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMzggICAgIDMxICAgICAxNSAgICAgNDEgICAgIDQ1ICAgIDY3XG4g56ys5LiJ6Laf5o6S5bqP5ZCOOiAgICAyMiAgICAyMyAgICAgMjMgICAgIDMxICAgICAxNSAgICAgMzggICAgIDQxICAgICA0NSAgICA2N1xuIOesrOWbm+i2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAxNSAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcbiDnrKzkupTotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAxNSAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XG4g56ys5YWt6Laf5o6S5bqP5ZCOOiAgICAyMiAgICAxNSAgICAgMjMgICAgIDIzICAgICAzMSAgICAgMzggICAgIDQxICAgICA0NSAgICA2N1xuIOesrOS4g+i2n+aOkuW6j+WQjjogICAgMTUgICAgMjIgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcblxuMy7nrpfms5XliIbmnpBcbiDml7bpl7TlpI3mnYLluqZcbiDil4YgIOacgOWlveaDheWGtSjmraPluo8p77ya5q+U6L6D5qyh5pWw77yabi0x77yb56e75Yqo5qyh5pWw77yaMO+8m1xuIOKXhiAg5pyA5Z2P5oOF5Ya1KOmAhuW6jynvvJpcbiDmr5TovoPmrKHmlbDvvJogbiAqIChuIC0gMSkgLyAyXG4g56e75Yqo5qyh5pWw77yaIDMqbioobiAtIDEpIC8gMlxuXG4g5pWF5pe26Ze05aSN5p2C5bqm77yaVChuKT1PKG7CsilcbiDnqbrpl7TlpI3mnYLluqbvvJpTKG4pPU8oMSlcblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBidWJibGVTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgY2hhbmdlID0gMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBsZW4gLSBpOyArK2opIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtqICsgMV0sIHNxTGlzdFtqXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgICAgICBzcUxpc3Rbal0gPSBzcUxpc3RbaiArIDFdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGFuZ2UpIGJyZWFrO1xuICAgIH1cbn1cblxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xuYnViYmxlU29ydChhcnIpO1xuY29uc29sZS5sb2coJ2J1YmJsZVNvcnQ6XFxuJyArIGFyciArICcnKTtcblxuXG4vLyDlhpLms6HmlLnov5sxXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlU29ydDIoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICBsZXQgY2hhbmdlID0gbGVuIC0gMTtcblxuICAgIHdoaWxlIChjaGFuZ2UpIHtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgLy8gY+aMh+ekuui/meS4gOi2n+WGkuazoeS4reWPkeeUn+S6pOaNoueahOWFg+e0oFxuICAgICAgICAgICAgICAgIGMgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZSA9IGM7XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xuYnViYmxlU29ydDIoYXJyKTtcbmNvbnNvbGUubG9nKCdidWJibGVTb3J0MjpcXG4nICsgYXJyICsgJycpO1xuXG5cbi8vIOebuOmCu+S4pOi2n+WPjeaWueWQkei1t+azoeeahOWGkuazoeaOkuW6j+eul+azlVxuZXhwb3J0IGZ1bmN0aW9uIGNvY2tUYWlsU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIGxldCBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuICAgIC8vIOWGkuazoeS4iuS4i+eVjFxuICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGVuIC0gMTtcbiAgICBsZXQgY2hhbmdlID0gMTtcbiAgICBsZXQgdGVtcDtcblxuICAgIHdoaWxlIChsb3cgPCBoaWdoICYmIGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSAwO1xuXG4gICAgICAgIC8vIOS7juS4iuWQkeS4i+i1t+azoVxuICAgICAgICBmb3IgKGxldCBpID0gbG93OyBpIDwgaGlnaDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOS/ruaUueS4iueVjFxuICAgICAgICAtLWhpZ2g7XG5cbiAgICAgICAgLy8g5LuO5LiL5ZCR5LiK6LW35rOhXG4gICAgICAgIGZvciAobGV0IGkgPSBoaWdoOyBpID4gbG93OyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgLSAxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpIC0gMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+u5pS55LiL55WMXG4gICAgICAgICsrbG93O1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbmNvY2tUYWlsU29ydChhcnIpO1xuY29uc29sZS5sb2coJ2NvY2tUYWlsU29ydDpcXG4nICsgYXJyICsgJycpO1xuXG5cbi8vIOaUuei/mzNcbmV4cG9ydCBmdW5jdGlvbiBjb2NrVGFpbFNvcnQyKHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgbGV0IGIgPSB7fTtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICAvLyBk5Li65YaS5rOh5pa55ZCR5qCH6K+G77yMIDHkuLrlkJHkuIrvvIwtMeS4uuWQkeS4i1xuICAgIGxldCBkID0gMTtcbiAgICAvLyBiWzBd5Li65YaS5rOh5LiK55WM77yMYlsyXeS4uuWGkuazoeS4iueVjO+8jGJbMV3ml6DnlKhcbiAgICBiWzBdID0gMDtcbiAgICBiWzJdID0gbGVuIC0gMTtcbiAgICBsZXQgY2hhbmdlID0gMTtcblxuICAgIHdoaWxlIChiWzBdIDwgYlsyXSAmJiBjaGFuZ2UpIHtcbiAgICAgICAgY2hhbmdlID0gMDtcblxuICAgICAgICAvLyDnu5/kuIDnmoTlhpLms6Hnrpfms5VcbiAgICAgICAgZm9yIChsZXQgaSA9IGJbMSAtIGRdOyBpICE9PSBiWzEgKyBkXTsgaSArPSBkKSB7XG4gICAgICAgICAgICAvLyDms6jmhI/ov5nkuKrkuqTmjaLmnaHku7ZcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyBkXSkgKiBkID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgZF07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyBkXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOS/ruaUuei+ueeVjFxuICAgICAgICBiWzEgKyBkXSAtPSBkO1xuICAgICAgICAvLyDmjaLkuKrmlrnlkJFcbiAgICAgICAgZCAqPSAtMTtcbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5jb2NrVGFpbFNvcnQyKGFycik7XG5jb25zb2xlLmxvZygnY29ja1RhaWxTb3J0MjpcXG4nICsgYXJyICsgJycpO1xuXG5cblxuLypcbiDlv6vpgJ/mjpLluo9cblxuIDEgIOaOkuW6j+aAneaDs1xuIOmAmui/h+S4gOi2n+aOkuW6j++8jOWwhuW+heaOkuW6j+iusOW9leWIhuWJsuaIkOeLrOeri+eahOS4pOmDqOWIhu+8jOWFtuS4reS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wdh+avlOWPpuS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wwj++8jOWGjeWIhuWIq+Wvuei/meS4pOmDqOWIhuiusOW9lei/m+ihjOS4i+S4gOi2n+aOkuW6j++8jOS7pei+vuWIsOaVtOS4quW6j+WIl+acieW6j+OAglxuXG4gMiAg5o6S5bqP6L+H56iLXG4g6K6+5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX5pivUltz4oCmdF0g77yM5Zyo6K6w5b2V5bqP5YiX5Lit5Lu75Y+W5LiA5Liq6K6w5b2VKOS4gOiIrOWPllJbc10p5L2c5Li65Y+C54WnKOWPiOensOS4uuWfuuWHhuaIluaeoui9tCnvvIzku6VSW3NdLmtleeS4uuWfuuWHhumHjeaWsOaOkuWIl+WFtuS9meeahOaJgOacieiusOW9le+8jOaWueazleaYr++8mlxuICAgICDil4Yg5omA5pyJ5YWz6ZSu5a2X5q+U5Z+65YeG5bCP55qE5pS+UltzXeS5i+WJje+8m1xuICAgICDil4Yg5omA5pyJ5YWz6ZSu5a2X5q+U5Z+65YeG5aSn55qE5pS+UltzXeS5i+WQjuOAglxuIOS7pVJbc10ua2V55pyA5ZCO5omA5Zyo5L2N572uaeS9nOS4uuWIhueVjO+8jOWwhuW6j+WIl1Jbc+KApnRd5YiG5Ymy5oiQ5Lik5Liq5a2Q5bqP5YiX77yM56ew5Li65LiA6Laf5b+r6YCf5o6S5bqP44CCXG5cbiAzICDkuIDotp/lv6vpgJ/mjpLluo/mlrnms5VcbiDku47luo/liJfnmoTkuKTnq6/kuqTmm7/miavmj4/lkITkuKrorrDlvZXvvIzlsIblhbPplK7lrZflsI/kuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXkvp3mrKHmlL7nva7liLDluo/liJfnmoTliY3ovrnvvJvogIzlsIblhbPplK7lrZflpKfkuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXku47luo/liJfnmoTmnIDlkI7nq6/otbfvvIzkvp3mrKHmlL7nva7liLDluo/liJfnmoTlkI7ovrnvvIznm7TliLDmiavmj4/lrozmiYDmnInnmoTorrDlvZXjgIJcblxuIOiuvue9ruaMh+mSiGxvd++8jGhpZ2jvvIzliJ3lgLzkuLrnrKwx5Liq5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V55qE5L2N572u44CCXG4g6K6+5Lik5Liq5Y+Y6YePae+8jGrvvIzliJ3lp4vml7bku6RpPWxvd++8jGo9aGlnaO+8jOS7pVJbbG93XS5rZXnkvZzkuLrln7rlh4Yo5bCGUltsb3dd5L+d5a2Y5ZyodGVtcOS4rSkg44CCXG4g4pGgIOS7jmrmiYDmjIfkvY3nva7lkJHliY3mkJzntKLvvJrlsIZ0ZW1w5LiOUltqXS5rZXnov5vooYzmr5TovoPvvJpcbiAgICDil4Yg6IuldGVtcOKJpFJbal0ua2V5IO+8muS7pGo9ai0x77yM54S25ZCO57un57ut6L+b6KGM5q+U6L6D77yMIOebtOWIsGk9auaIlnRlbXA+UltqXS5rZXnkuLrmraLvvJtcbiAgICDil4Yg6IuldGVtcD5SW2pdLmtleSDvvJpSW2pd74OeUltpXe+8jOiFvuepulJbal3nmoTkvY3nva7vvIwg5LiU5LukaT1pKzHvvJtcbiDikaEg5LuOaeaJgOaMh+S9jee9rui1t+WQkeWQjuaQnOe0ou+8muWwhnRlbXDkuI5SW2ldLmtleei/m+ihjOavlOi+g++8mlxuICAgIOKXhiDoi6V0ZW1w4omlUltpXS5rZXkg77ya5LukaT1pKzHvvIznhLblkI7nu6fnu63ov5vooYzmr5TovoPvvIwg55u05YiwaT1q5oiWdGVtcDxSW2ldLmtleeS4uuatou+8m1xuICAgIOKXhiDoi6V0ZW1wPFJbaV0ua2V5IO+8mlJbaV3vg55SW2pd77yM6IW+56m6UltpXeeahOS9jee9ru+8jCDkuJTku6RqPWotMe+8m1xuIOKRoiDph43lpI3ikaDjgIHikaHvvIznm7Toh7NpPWrkuLrmraLvvIxp5bCx5pivdGVtcCjln7rlh4Yp5omA5bqU5pS+572u55qE5L2N572u44CCXG5cbiDnrpfms5XliIbmnpBcbiDlv6vpgJ/mjpLluo/nmoTkuLvopoHml7bpl7TmmK/oirHotLnlnKjliJLliIbkuIrvvIzlr7nplb/luqbkuLpr55qE6K6w5b2V5bqP5YiX6L+b6KGM5YiS5YiG5pe25YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw5pivay0xIOOAguiuvumVv+W6puS4um7nmoTorrDlvZXluo/liJfov5vooYzmjpLluo/nmoTmr5TovoPmrKHmlbDkuLpDKG4p77yM5YiZQyhuKT1uLTErQyhrKStDKG4tay0xKSDjgIJcbiDil4YgIOacgOWlveaDheWGte+8muavj+asoeWIkuWIhuW+l+WIsOeahOWtkOW6j+WIl+Wkp+iHtOebuOetie+8jOWImVxuIEMobik8PWjDl24rMmjDl0Mobi8yaCkg77yM5b2Tbi8yaD0x5pe25o6S5bqP57uT5p2f44CCXG4g5Y2zQyhuKeKJpE8obsOX44+SMm4pIO+8m1xuIOKXhiAg5pyA5Z2P5oOF5Ya177ya5q+P5qyh5YiS5YiG5b6X5Yiw55qE5a2Q5bqP5YiX5Lit5pyJ5LiA5Liq5Li656m677yM5Y+m5LiA5Liq5a2Q5bqP5YiX55qE6ZW/5bqm5Li6bi0x44CC5Y2z5q+P5qyh5YiS5YiG5omA6YCJ5oup55qE5Z+65YeG5piv5b2T5YmN5b6F5o6S5bqP5bqP5YiX5Lit55qE5pyA5bCPKOaIluacgOWkpynlhbPplK7lrZfjgIJcbiDmr5TovoPmrKHmlbDvvJo6ICDljbNDKG4pPU8objIpXG4g4peGICDkuIDoiKzmg4XlhrXvvJog5a+5buS4quiusOW9lei/m+ihjOW/q+mAn+aOkuW6j+aJgOmcgOeahOaXtumXtFQobinnu4TmiJDmmK/vvJpcbiAgICAg4pGgIOWvuW7kuKrorrDlvZXov5vooYzkuIDotp/liJLliIbmiYDpnIDnmoTml7bpl7TmmK/vvJpuw5dDIO+8jEPmmK/luLjmlbDvvJtcbiAgICAg4pGhIOWvueaJgOW+l+WIsOeahOS4pOS4quWtkOW6j+WIl+i/m+ihjOW/q+mAn+aOkuW6j+eahOaXtumXtO+8mlxuICAgICAgICBUYXZnKG4pPUMobikrVGF2ZyhrLTEpK1Rhdmcobi1rKSAgICAgICAgICDigKbigKZcblxuIOW/q+mAn+aOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puaYr++8mlQobik9Tyhu44+SMm4pXG4g5LuO5omA6ZyA6KaB55qE6ZmE5Yqg56m66Ze05p2l55yL77yM5b+r6YCf5o6S5bqP566X5rOV5piv6YCS5b2S6LCD55So77yM57O757uf5YaF55So5aCG5qCI5L+d5a2Y6YCS5b2S5Y+C5pWw77yM5b2T5q+P5qyh5YiS5YiG5q+U6L6D5Z2H5YyA5pe277yM5qCI55qE5pyA5aSn5rex5bqm5Li6W+OPkjJuXSsxIOOAglxuXG4g5b+r6YCf5o6S5bqP55qE56m66Ze05aSN5p2C5bqm5piv77yaUyhuKT1PKOOPkjJuKVxuIOS7juaOkuW6j+eahOeos+WumuaAp+adpeeci++8jOW/q+mAn+aOkuW6j+aYr+S4jeeos+WumueahOOAglxuXG4gKi9cblxuZnVuY3Rpb24gcGFydGl0aW9uMShzcUxpc3QsIGxvdywgaGlnaCkge1xuICAgIGxldCB0ZW1wID0gc3FMaXN0W2xvd107XG5cbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCAmJiBzcUxpc3RbaGlnaF0gPj0gdGVtcCktLWhpZ2g7XG4gICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2hpZ2hdO1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCAmJiBzcUxpc3RbbG93XSA8PSB0ZW1wKSsrbG93O1xuICAgICAgICBzcUxpc3RbaGlnaF0gPSBzcUxpc3RbbG93XTtcbiAgICB9XG5cbiAgICBzcUxpc3RbbG93XSA9IHRlbXA7XG5cbiAgICByZXR1cm4gbG93O1xufVxuXG4vLyDkvJjljJbkuIDotp/lv6vpgJ/mjpLluo/mlrnms5XvvJog6ZqP5py65YyWcGFydGl0aW9uXG4vLyDmnIDlnY/mg4XlhrXmlYjnjoflpKfluYXmj5DljYfvvIzml7bpl7TlpI3mnYLluqZUKG4pPU8obuOPkjJuKVxuZnVuY3Rpb24gcGFydGl0aW9uMihzcUxpc3QsIGxvdywgaGlnaCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGxldCBuID0gaGlnaCAtIGxvdyArIDE7XG4gICAgbGV0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuKSArIGxvdztcblxuICAgIC8vbGV0IHJhbmQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICB0ZW1wID0gc3FMaXN0W2hpZ2hdO1xuICAgIHNxTGlzdFtoaWdoXSA9IHNxTGlzdFtyYW5kXTtcbiAgICBzcUxpc3RbcmFuZF0gPSB0ZW1wO1xuXG4gICAgbGV0IGkgPSBsb3cgLSAxO1xuICAgIGxldCBwaXZvdCA9IHNxTGlzdFtoaWdoXTtcblxuICAgIGZvciAobGV0IGogPSBsb3c7IGogPCBoaWdoOyArK2opIHtcbiAgICAgICAgaWYgKHNxTGlzdFtqXSA8PSBwaXZvdCkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICArK2k7XG4gICAgc3FMaXN0W2hpZ2hdID0gc3FMaXN0W2ldO1xuICAgIHNxTGlzdFtpXSA9IHBpdm90O1xuXG4gICAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGxldCBpID0gbG93O1xuICAgIGxldCBqID0gaGlnaCArIDE7XG4gICAgbGV0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpICsgbG93ICsgMTtcbiAgICAvL2xldCByYW5kID0gKGxvdyArIGhpZ2gpID4+IDE7XG5cbiAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbcmFuZF07XG4gICAgc3FMaXN0W3JhbmRdID0gdGVtcDtcblxuICAgIGxldCB4ID0gc3FMaXN0W2xvd107XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgICB3aGlsZSAoY29tcChzcUxpc3RbKytpXSwgeCkgPCAwICYmIGkgPCBoaWdoKTtcbiAgICAgICAgd2hpbGUgKGNvbXAoc3FMaXN0Wy0tal0sIHgpID4gMCk7XG4gICAgICAgIGlmIChpID49IGopIGJyZWFrO1xuICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3Rbal07XG4gICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XG4gICAgfVxuXG4gICAgc3FMaXN0W2xvd10gPSBzcUxpc3Rbal07XG4gICAgc3FMaXN0W2pdID0geDtcblxuICAgIHJldHVybiBqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlKFxuICAgIHNxTGlzdCA9IFtdLFxuICAgIGxvdyA9IDAsXG4gICAgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxLFxuICAgIGNvbXAgPSBkZWZhdWx0Q29tcGFyZVxuKSB7XG4gICAgaWYgKGxvdyA+PSBoaWdoKSByZXR1cm47XG5cbiAgICBsZXQgayA9IHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCk7XG4gICAgcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgbG93LCBrIC0gMSwgY29tcCk7XG4gICAgcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgayArIDEsIGhpZ2gsIGNvbXApO1xufVxuXG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5xdWlja1NvcnRSZWN1cnNpdmUoYXJyKTtcbmNvbnNvbGUubG9nKCdxdWlja1NvcnRSZWN1cnNpdmU6XFxuJyArIGFyciArICcnKTtcblxuXG4vKlxu5b+r5o6S6YCS5b2S566X5rOV5LyY5YyW77yM5Zyo5pyA5Z2P5oOF5Ya15LiL5aCG5qCI5rex5bqm5Li6Tyhsb2duKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlMihcbiAgICBzcUxpc3QgPSBbXSxcbiAgICBsb3cgPSAwLFxuICAgIGhpZ2ggPSBzcUxpc3QubGVuZ3RoIC0gMSxcbiAgICBjb21wID0gZGVmYXVsdENvbXBhcmVcbikge1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGxldCBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcblxuICAgICAgICAvLyDlr7nkuKTkuKrlrZDmlbDnu4TkuK3ovoPlsI/nmoTkuIDkuKrlrZDmlbDnu4Tov5vooYzpgJLlvZLosIPnlKjjgIJcbiAgICAgICAgLy8g6L6D5bCP5a2Q5pWw57uE55qE5aSn5bCP5pyA5aSa5Li65Y6f5pWw57uE5aSn5bCP5LiA5Y2K77yMXG4gICAgICAgIC8vIOeUseS6juavj+asoemAkuW9kuiwg+eUqOeahOaVsOe7hOWkp+Wwj+iHs+WwkeWHj+WwkeS4gOWNiu+8jOaJgOS7pemAkuW9kuiwg+eUqOeahOasoeaVsFxuICAgICAgICAvLyDmnIDlpJrkuLpPKGxvZ24pXG4gICAgICAgIGlmIChrIC0gbG93ICsgMSA8IGhpZ2ggLSBrKSB7XG4gICAgICAgICAgICBxdWlja1NvcnRSZWN1cnNpdmUyKHNxTGlzdCwgbG93LCBrIC0gMSwgY29tcCk7XG4gICAgICAgICAgICBsb3cgPSBrICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1aWNrU29ydFJlY3Vyc2l2ZTIoc3FMaXN0LCBrICsgMSwgaGlnaCwgY29tcCk7XG4gICAgICAgICAgICBoaWdoID0gayAtIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xucXVpY2tTb3J0UmVjdXJzaXZlMihhcnIpO1xuY29uc29sZS5sb2coJ3F1aWNrU29ydFJlY3Vyc2l2ZTI6XFxuJyArIGFyciArICcnKTtcblxuXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0Tm9uUmVjdXJzaXZlKFxuICAgIHNxTGlzdCA9IFtdLFxuICAgIGxvdyA9IDAsXG4gICAgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxLFxuICAgIGNvbXAgPSBkZWZhdWx0Q29tcGFyZVxuKSB7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgbGV0IGs7XG5cbiAgICBkbyB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcbiAgICAgICAgICAgIC8vIOesrOS6jOS4quWtkOW6j+WIl+eahOS4iizkuIvnlYzliIbliKvlhaXmoIhcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaGlnaCwgayArIDEpO1xuICAgICAgICAgICAgLy9zdGFjay5wdXNoKGsgKyAxKTtcbiAgICAgICAgICAgIGhpZ2ggPSBrIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbG93ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGhpZ2ggPSBzdGFjay5wb3AoKTtcbiAgICB9IHdoaWxlICgxKTtcbn1cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbnF1aWNrU29ydE5vblJlY3Vyc2l2ZShhcnIpO1xuY29uc29sZS5sb2coJ3F1aWNrU29ydE5vblJlY3Vyc2l2ZTpcXG4nICsgYXJyICsgJycpO1xuXG4vLyDkvJjljJbniYjmnKxcbmV4cG9ydCBmdW5jdGlvbiBxdWlja1NvcnQoXG4gICAgc3FMaXN0ID0gW10sXG4gICAgbG93ID0gMCxcbiAgICBoaWdoID0gc3FMaXN0Lmxlbmd0aCAtIDEsXG4gICAgY29tcCA9IGRlZmF1bHRDb21wYXJlXG4pIHtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBsZXQgcGl2b3Q7XG5cbiAgICBkbyB7XG4gICAgICAgIC8vIOWmguaenOW9k+WJjeWtkOW6j+WIl+mVv+W6puWkp+S6jjPkuJTlsJrmnKrmjpLlpb3luo9cbiAgICAgICAgaWYgKGhpZ2ggLSBsb3cgPiAyKSB7XG4gICAgICAgICAgICAvLyDov5vooYzkuIDotp/liJLliIZcbiAgICAgICAgICAgIHBpdm90ID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcblxuICAgICAgICAgICAgLy8g5ZCn6ZW/55qE5a2Q5bqP5YiX6L6555WM5YWl5qCI77yMXG4gICAgICAgICAgICAvLyDnn63nmoTlrZDluo/liJfnlZnlvoXkuIvmrKHmjpLluo9cbiAgICAgICAgICAgIGlmIChoaWdoIC0gcGl2b3QgPiBwaXZvdCAtIGxvdykge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaGlnaCwgcGl2b3QgKyAxKTtcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcbiAgICAgICAgICAgICAgICBoaWdoID0gcGl2b3QgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBpdm90IC0gMSwgbG93KTtcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcbiAgICAgICAgICAgICAgICBsb3cgPSBwaXZvdCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5aaC5p6c5b2T5YmN5a2Q5bqP5YiX6ZW/5bqm5bCP5LqOM++8jOS4lOWwmuacquaOkuWlveW6j++8jFxuICAgICAgICAvLyDnm7TmjqXov5vooYzmr5TovoPmjpLluo/kubDlvZPliY3lrZDluo/liJfmoIflv5fkuLrlt7LmjpLlpb3luo9cbiAgICAgICAgZWxzZSBpZiAobG93IDwgaGlnaCAmJiBoaWdoIC0gbG93IDwgMykge1xuICAgICAgICAgICAgZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xuICAgICAgICAgICAgbG93ID0gaGlnaDtcbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzlvZPliY3lrZDluo/liJflt7LmjpLlpb3luo/kvYbmoIjkuK3ov5jmnInmnKrmjpLluo/nmoTlrZDluo/liJdcbiAgICAgICAgLy8g5LuO5qCI5Lit5Y+W5Ye65LiA5Liq5a2Q5bqP5YiXXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgbG93ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBoaWdoID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgxKTtcbn1cblxuZnVuY3Rpb24gZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApIHtcbiAgICBsZXQgdGVtcDtcblxuICAgIGlmIChoaWdoIC0gbG93ID09PSAxKSB7XG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbaGlnaF0pID4gMCkge1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xuICAgICAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbaGlnaF07XG4gICAgICAgICAgICBzcUxpc3RbaGlnaF0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvd10sIHNxTGlzdFtsb3cgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtsb3cgKyAxXTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvdyArIDFdLCBzcUxpc3RbaGlnaF0pID4gMCkge1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3cgKyAxXTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHNxTGlzdFtoaWdoXTtcbiAgICAgICAgICAgIHNxTGlzdFtoaWdoXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvd10sIHNxTGlzdFtsb3cgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtsb3cgKyAxXTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5xdWlja1NvcnQoYXJyKTtcbmNvbnNvbGUubG9nKCdxdWlja1NvcnQ6XFxuJyArIGFyciArICcnKTtcblxuXG4vLyDlpYflgbbkuqTmjaLmjpLluo9cbmV4cG9ydCBmdW5jdGlvbiBvZGRFdmVuU29ydChzcUxpc3QgPSBbXSwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgbGV0IGNoYW5nZSA9IDE7XG4gICAgbGV0IHRlbXA7XG4gICAgbGV0IGxlbiA9IHNxTGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoY2hhbmdlKSB7XG4gICAgICAgIGNoYW5nZSA9IDA7XG4gICAgICAgIC8vIOWvueaJgOacieWlh+aVsOi/m+ihjOS4gOi2n+avlOi+g1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbiAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5a+55omA5pyJ5YG25pWw6L+b6KGM5LiA6Laf5q+U6L6DXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAyKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcblxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5vZGRFdmVuU29ydChhcnIpO1xuY29uc29sZS5sb2coJ29kZEV2ZW5Tb3J0OlxcbicgKyBhcnIgKyAnJyk7XG5cblxuLypcbuaKiueUseS4ieenjeminOiJsue7hOaIkOeahOW6j+WIl+mHjeaOkuS4uuaMieeFp+e6oueZveiTneeahOmhuuW6j+aOkuWIl++8jFxu5oCd6Lev77yaXG7orr7nq4vkuInkuKrmjIfpkojvvIzlhbbkuK1q6KGo56S65b2T5YmN5YWD57Sg77ybaeS7peWJjeeahOWFg+e0oOWFqOmDqOS4uue6ouiJsu+8m2vku6XlkI7nmoTpopzoibLlhajkuLrok53oibLjgILov5nmoLflsLHlj6/ku6XmoLnmja5q55qE6aKc6Imy5oqK5YW25Lqk5o2i5Yiw5bqP5YiX55qE5YmN6Z2i5oiW6ICF5ZCO6Z2i44CCXG4gKi9cbmNvbnN0IFJFRCA9IDA7XG5jb25zdCBXSElURSA9IDE7XG5jb25zdCBCTFVFID0gMjtcblxuZnVuY3Rpb24gZmxhZ0FycmFuZ2UoY29sb3JzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgayA9IGNvbG9ycy5sZW5ndGggLSAxO1xuICAgIGxldCB0ZW1wO1xuXG4gICAgd2hpbGUgKGogPD0gaykge1xuICAgICAgICBzd2l0Y2ggKGNvbG9yc1tqXSkge1xuICAgICAgICAgICAgY2FzZSBSRUQ6XG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSBjb2xvcnNbal07XG4gICAgICAgICAgICAgICAgY29sb3JzW2pdID0gdGVtcDtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXSElURTpcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJMVUU6XG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbG9yc1tqXTtcbiAgICAgICAgICAgICAgICBjb2xvcnNbal0gPSBjb2xvcnNba107XG4gICAgICAgICAgICAgICAgY29sb3JzW2tdID0gdGVtcDtcbiAgICAgICAgICAgICAgICAtLWs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIsIDEsIDAsIDIsIDEsIDEsIDAsIDIsIDAsIDIsIDFdO1xuZmxhZ0FycmFuZ2UoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9leGNoYW5nZS9pbmRleC5qcyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcbiAgUmVwb3J0ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYmFzZSkpIHtcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xufVxuaW5oZXJpdHMoRGVjb2RlckJ1ZmZlciwgUmVwb3J0ZXIpO1xuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XG4gIC8vIFJldHVybiBza2lwcGVkIGRhdGFcbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChieXRlcywgZmFpbCkge1xuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcblxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiByYXcoc2F2ZSkge1xuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBFbmNvZGVyQnVmZmVyKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihvdXQsIG9mZnNldCkge1xuICBpZiAoIW91dClcbiAgICBvdXQgPSBuZXcgQnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgaWYgKCFvZmZzZXQpXG4gICAgb2Zmc2V0ID0gMDtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG91dDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtLmpvaW4ob3V0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGl0ZW0ubGVuZ3RoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgb3V0LndyaXRlKHRoaXMudmFsdWUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxuICAgICAgdGhpcy52YWx1ZS5jb3B5KG91dCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICB2YXIgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICByZXNbdmFsdWVdID0ga2V5O1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3RhbnRzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJEZWNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRGVjb2RlcjtcblxuREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIGJhc2UuRGVjb2RlckJ1ZmZlcikpXG4gICAgZGF0YSA9IG5ldyBiYXNlLkRlY29kZXJCdWZmZXIoZGF0YSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMudHJlZS5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgaWYgKGJ1ZmZlci5pc0VtcHR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgJ0ZhaWxlZCB0byBwZWVrIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG5cbiAgcmV0dXJuIGRlY29kZWRUYWcudGFnID09PSB0YWcgfHwgZGVjb2RlZFRhZy50YWdTdHIgPT09IHRhZyB8fFxuICAgIChkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicpID09PSB0YWcgfHwgYW55O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRhZyA9IGZ1bmN0aW9uIGRlY29kZVRhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBkZWNvZGUgdGFnIG9mIFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFRhZy5wcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgbGVuZ3RoIG9mIFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEZhaWx1cmVcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICBpZiAoIWFueSAmJlxuICAgICAgZGVjb2RlZFRhZy50YWcgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdGYWlsZWQgdG8gbWF0Y2ggdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChkZWNvZGVkVGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aC4uLiBmaW5kIEVORCB0YWdcbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgdmFyIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChcbiAgICAgIGJ1ZmZlcixcbiAgICAgICdGYWlsZWQgdG8gc2tpcCBpbmRlZmluaXRlIGxlbmd0aCBib2R5OiBcIicgKyB0aGlzLnRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGxlbiA9IGJ1ZmZlci5vZmZzZXQgLSBzdGF0ZS5vZmZzZXQ7XG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcbiAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwVW50aWxFbmQgPSBmdW5jdGlvbiBza2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih0YWcpKVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlciwgdGFnLnByaW1pdGl2ZSwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgICByZXR1cm4gbGVuO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgICByZXMgPSBidWZmZXIuc2tpcChsZW4pXG4gICAgZWxzZVxuICAgICAgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCk7XG5cbiAgICAvLyBGYWlsdXJlXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHRhZy50YWdTdHIgPT09ICdlbmQnKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVMaXN0ID0gZnVuY3Rpb24gZGVjb2RlTGlzdChidWZmZXIsIHRhZywgZGVjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHBvc3NpYmxlRW5kID0gdGhpcy5fcGVla1RhZyhidWZmZXIsICdlbmQnKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocG9zc2libGVFbmQpKVxuICAgICAgcmV0dXJuIHBvc3NpYmxlRW5kO1xuXG4gICAgdmFyIHJlcyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlciwgJ2RlcicsIG9wdGlvbnMpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpICYmIHBvc3NpYmxlRW5kKVxuICAgICAgYnJlYWs7XG4gICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVN0ciA9IGZ1bmN0aW9uIGRlY29kZVN0cihidWZmZXIsIHRhZykge1xuICBpZiAodGFnID09PSAnYml0c3RyJykge1xuICAgIHZhciB1bnVzZWQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHVudXNlZCkpXG4gICAgICByZXR1cm4gdW51c2VkO1xuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgICBpZiAocmF3Lmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogYm1wc3RyIGxlbmd0aCBtaXNtYXRjaCcpO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Lmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmF3LnJlYWRVSW50MTZCRShpICogMikpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICB2YXIgbnVtc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNOdW1zdHIobnVtc3RyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtc3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bXN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvY3RzdHInKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAncHJpbnRzdHInKSB7XG4gICAgdmFyIHByaW50c3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihwcmludHN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaW50c3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaW50c3RyO1xuICB9IGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgKyB0YWcgKyAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVPYmppZCA9IGZ1bmN0aW9uIGRlY29kZU9iamlkKGJ1ZmZlciwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICB2YXIgcmVzdWx0O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgdmFyIGlkZW50ID0gMDtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHN1YmlkZW50ID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlkZW50IDw8PSA3O1xuICAgIGlkZW50IHw9IHN1YmlkZW50ICYgMHg3ZjtcbiAgICBpZiAoKHN1YmlkZW50ICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuICAgICAgaWRlbnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViaWRlbnQgJiAweDgwKVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuXG4gIHZhciBmaXJzdCA9IChpZGVudGlmaWVyc1swXSAvIDQwKSB8IDA7XG4gIHZhciBzZWNvbmQgPSBpZGVudGlmaWVyc1swXSAlIDQwO1xuXG4gIGlmIChyZWxhdGl2ZSlcbiAgICByZXN1bHQgPSBpZGVudGlmaWVycztcbiAgZWxzZVxuICAgIHJlc3VsdCA9IFtmaXJzdCwgc2Vjb25kXS5jb25jYXQoaWRlbnRpZmllcnMuc2xpY2UoMSkpO1xuXG4gIGlmICh2YWx1ZXMpIHtcbiAgICB2YXIgdG1wID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcgJyldO1xuICAgIGlmICh0bXAgPT09IHVuZGVmaW5lZClcbiAgICAgIHRtcCA9IHZhbHVlc1tyZXN1bHQuam9pbignLicpXTtcbiAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpXG4gICAgICByZXN1bHQgPSB0bXA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRpbWUgPSBmdW5jdGlvbiBkZWNvZGVUaW1lKGJ1ZmZlciwgdGFnKSB7XG4gIHZhciBzdHIgPSBidWZmZXIucmF3KCkudG9TdHJpbmcoKTtcbiAgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnKSB7XG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgNCkgfCAwO1xuICAgIHZhciBtb24gPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNiwgOCkgfCAwO1xuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICB2YXIgc2VjID0gc3RyLnNsaWNlKDEyLCAxNCkgfCAwO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3V0Y3RpbWUnKSB7XG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgMikgfCAwO1xuICAgIHZhciBtb24gPSBzdHIuc2xpY2UoMiwgNCkgfCAwO1xuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgbWluID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICBpZiAoeWVhciA8IDcwKVxuICAgICAgeWVhciA9IDIwMDAgKyB5ZWFyO1xuICAgIGVsc2VcbiAgICAgIHllYXIgPSAxOTAwICsgeWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyAnICsgdGFnICsgJyB0aW1lIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICByZXR1cm4gRGF0ZS5VVEMoeWVhciwgbW9uIC0gMSwgZGF5LCBob3VyLCBtaW4sIHNlYywgMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTnVsbCA9IGZ1bmN0aW9uIGRlY29kZU51bGwoYnVmZmVyKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUJvb2wgPSBmdW5jdGlvbiBkZWNvZGVCb29sKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuICBlbHNlXG4gICAgcmV0dXJuIHJlcyAhPT0gMDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnVmZmVyLCB2YWx1ZXMpIHtcbiAgLy8gQmlnaW50LCByZXR1cm4gYXMgaXQgaXMgKGFzc3VtZSBiaWcgZW5kaWFuKVxuICB2YXIgcmF3ID0gYnVmZmVyLnJhdygpO1xuICB2YXIgcmVzID0gbmV3IGJpZ251bShyYXcpO1xuXG4gIGlmICh2YWx1ZXMpXG4gICAgcmVzID0gdmFsdWVzW3Jlcy50b1N0cmluZygxMCldIHx8IHJlcztcblxuICByZXR1cm4gcmVzO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RGVjb2RlcignZGVyJykudHJlZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBkZXJEZWNvZGVUYWcoYnVmLCBmYWlsKSB7XG4gIHZhciB0YWcgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IodGFnKSlcbiAgICByZXR1cm4gdGFnO1xuXG4gIHZhciBjbHMgPSBkZXIudGFnQ2xhc3NbdGFnID4+IDZdO1xuICB2YXIgcHJpbWl0aXZlID0gKHRhZyAmIDB4MjApID09PSAwO1xuXG4gIC8vIE11bHRpLW9jdGV0IHRhZyAtIGxvYWRcbiAgaWYgKCh0YWcgJiAweDFmKSA9PT0gMHgxZikge1xuICAgIHZhciBvY3QgPSB0YWc7XG4gICAgdGFnID0gMDtcbiAgICB3aGlsZSAoKG9jdCAmIDB4ODApID09PSAweDgwKSB7XG4gICAgICBvY3QgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICAgICAgaWYgKGJ1Zi5pc0Vycm9yKG9jdCkpXG4gICAgICAgIHJldHVybiBvY3Q7XG5cbiAgICAgIHRhZyA8PD0gNztcbiAgICAgIHRhZyB8PSBvY3QgJiAweDdmO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YWcgJj0gMHgxZjtcbiAgfVxuICB2YXIgdGFnU3RyID0gZGVyLnRhZ1t0YWddO1xuXG4gIHJldHVybiB7XG4gICAgY2xzOiBjbHMsXG4gICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXG4gICAgdGFnOiB0YWcsXG4gICAgdGFnU3RyOiB0YWdTdHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVyRGVjb2RlTGVuKGJ1ZiwgcHJpbWl0aXZlLCBmYWlsKSB7XG4gIHZhciBsZW4gPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIC8vIEluZGVmaW5pdGUgZm9ybVxuICBpZiAoIXByaW1pdGl2ZSAmJiBsZW4gPT09IDB4ODApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgLy8gRGVmaW5pdGUgZm9ybVxuICBpZiAoKGxlbiAmIDB4ODApID09PSAwKSB7XG4gICAgLy8gU2hvcnQgZm9ybVxuICAgIHJldHVybiBsZW47XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgdmFyIG51bSA9IGxlbiAmIDB4N2Y7XG4gIGlmIChudW0gPiA0KVxuICAgIHJldHVybiBidWYuZXJyb3IoJ2xlbmd0aCBvY3RlY3QgaXMgdG9vIGxvbmcnKTtcblxuICBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgbGVuIDw8PSA4O1xuICAgIHZhciBqID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICBpZiAoYnVmLmlzRXJyb3IoaikpXG4gICAgICByZXR1cm4gajtcbiAgICBsZW4gfD0gajtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRW5jb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICB2YXIgZW5jb2RlZFRhZyA9IGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCB0aGlzLnJlcG9ydGVyKTtcblxuICAvLyBTaG9ydCBmb3JtXG4gIGlmIChjb250ZW50Lmxlbmd0aCA8IDB4ODApIHtcbiAgICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgdmFyIGxlbk9jdGV0cyA9IDE7XG4gIGZvciAodmFyIGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigxICsgMSArIGxlbk9jdGV0cyk7XG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gIGhlYWRlclsxXSA9IDB4ODAgfCBsZW5PY3RldHM7XG5cbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcbiAgICBoZWFkZXJbaV0gPSBqICYgMHhmZjtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIHN0ci51bnVzZWQgfCAwLCBzdHIuZGF0YSBdKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShzdHIuY2hhckNvZGVBdChpKSwgaSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogbnVtc3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgZGlnaXRzIGFuZCBzcGFjZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IHByaW50c3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgbGF0aW4gdXBwZXIgYW5kIGxvd2VyIGNhc2UgbGV0dGVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlnaXRzLCBzcGFjZSwgYXBvc3Ryb3BoZSwgbGVmdCBhbmQgcmlndGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50aGVzaXMsIHBsdXMgc2lnbiwgY29tbWEsIGh5cGhlbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG90LCBzbGFzaCwgY29sb24sIGVxdWFsIHNpZ24sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3F1ZXN0aW9uIG1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKCFudW0uc2lnbiAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnlLHkuo7pk77ooajlnKjnqbrpl7TnmoTlkIjnkIbliKnnlKjkuIrlkozmj5LlhaXvvIzliKDpmaTml7bkuI3pnIDopoHnp7vliqjnrYnnmoTmnInngrnvvIzlm6DmraTlnKjlvojlpJrlnLrlkIjkuIvvvIzlroPmmK/nur/mgKfooajnmoTpppbpgInlrZjlgqjnu5PmnoTjgILnhLbogIzvvIzlroPkuZ/lrZjlnKjnnYDlrp7njrDmn5Dkupvln7rmnKzmk43kvZzvvIzlpoLmsYLnur/mgKfooajplb/luqbml7bkuI3lpoLpobrluo/lrZjlgqjnu5PmnoTnmoTnvLrngrnvvJvlj6bkuIDmlrnpnaLvvIznlLHkuo7lnKjpk77ooajkuK3vvIznu5PngrnkuYvpl7TnmoTlhbPns7vkvb/nlKjmjIfpkojmnaXooajnpLrvvIzliJnmlbDmja7lhYPntKDlnKjnur/mgKfooajkuK3nmoTigJzkvY3luo/igJ3nmoTmpoLlv7Xlt7Lmt6HljJbvvIzogIzooqvmlbDmja7lhYPntKDlnKjnur/mgKfpk77ooajkuK3nmoTigJzkvY3nva7igJ3miYDku6Pmm7/jgILkuLrmraTvvIzku47lrp7pmYXlh7rlj5Hph43mlrDlrprkuYnnur/mgKfpk77ooajlj4rlhbbln7rmnKzmk43kvZxcbiAqL1xuXG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgbmV4dCA9IG51bGwpe1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlua2VkTGlzdCB7XG4gICAgY29uc3RydWN0b3Ioc3FMaXN0ID0gW10pe1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIGlmIChzcUxpc3QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHNxTGlzdFtpXSk7XG4gICAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIG1lcmdlIGxpc3QsIG5vdGU6IHRoaXMgb3BlcmF0aW9uIHdpbGwgZGVsZXRlIGEgYW5kIGIgbm9kZXMuXG4gICAgICogQHBhcmFtIHtMaW5rZWRMaXN0fSBhIFxuICAgICAqIEBwYXJhbSB7TGlua2VkTGlzdH0gYlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGFyZSBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2VMaXN0IChhLCBiLCBjb21wYXJlID0gY29tcEZuKSB7XG4gICAgICAgIGxldCBoYSA9IGEuaGVhZDtcbiAgICAgICAgbGV0IGhiID0gYi5oZWFkO1xuICAgICAgICBsZXQgcGEgPSBoYTtcbiAgICAgICAgbGV0IHBiID0gaGI7XG4gICAgICAgIGxldCBjID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgbGV0IHE7XG5cbiAgICAgICAgd2hpbGUgKHBhICYmIHBiKSB7XG4gICAgICAgICAgICBsZXQgZGF0YTEgPSBwYS5kYXRhO1xuICAgICAgICAgICAgbGV0IGRhdGEyID0gcGIuZGF0YTtcblxuICAgICAgICAgICAgaWYgKCFjb21wYXJlKGRhdGExLCBkYXRhMikpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgaGVhZCBub2RlXG4gICAgICAgICAgICAgICAgcSA9IGEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIG5vZGUgdG8gYyBsaW5rZWRMaXN0XG4gICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XG4gICAgICAgICAgICAgICAgcGEgPSBhLmhlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEgPSBiLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XG4gICAgICAgICAgICAgICAgcGIgPSBiLmhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwYSkge1xuICAgICAgICAgICAgYy5hcHBlbmQocGEpO1xuICAgICAgICAgICAgYy50YWlsID0gYS50YWlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYy5hcHBlbmQocGIpO1xuICAgICAgICAgICAgYy50YWlsID0gYi50YWlsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgYW5kIHJldHVybiBpdFxuICAgICAqL1xuICAgIHNoaWZ0ICgpIHtcbiAgICAgICAgbGV0IGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICBoZWFkLm5leHQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IGFuZCByZXR1cm4gaXRcbiAgICAgKi9cbiAgICBwb3AoKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGVsZW07XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaWwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzLnRhaWwuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldmlvdXM7XG5cbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFxuICAgICAqL1xuICAgIGFwcGVuZCAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGRhdGFcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgXG4gICAgICovXG4gICAgcHVzaCAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbmV3IE5vZGUoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFpbC5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgZGF0YVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICByZW1vdmUgKGRhdGEpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGVsZW07XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBjdXJyZW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGN1cnJlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMudGFpbCkgdGhpcy50YWlsID0gcHJldmlvdXM7XG5cbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIGluZGV4IG9mIG1hdGNoZWQgZGF0YSBcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgXG4gICAgICovXG4gICAgaW5kZXhPZihkYXRhKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEgPT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGRhdGEgdG8gdGhlIGZyb250XG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqL1xuICAgIHVuc2hpZnQgKGRhdGEpIHtcbiAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgdGVtcC5uZXh0ID0gdGhpcy5oZWFkO1xuICAgICAgICB0aGlzLmhlYWQgPSB0ZW1wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlciAodGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgICAgICB0ZW1wLm5leHQgPSBjdXJyZW50Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy50YWlsKSB0aGlzLnRhaWwgPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gdGVtcDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpdGVtIChpbmRleCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcblxuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKC0taW5kZXggPT09IDApIHJldHVybiBjdXJyZW50O1xuXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yRWFjaCAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQsIGluZGV4ID0gMDsgY3VycmVudDsgY3VycmVudCA9IGN1cnJlbnQubmV4dCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGN1cnJlbnQuZGF0YSwgaW5kZXgrKykpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCl7XG4gICAgICAgIGZvcihsZXQgY3VycmVudCA9IHRoaXMuaGVhZDsgY3VycmVudDsgY3VycmVudCA9IGN1cnJlbnQubmV4dCl7XG4gICAgICAgICAgICB5aWVsZCBjdXJyZW50LmRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2l6ZSAoKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICsrc2l6ZTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcblxuICAgICAgICB0aGlzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHN0ciArPSBub2RlLmRhdGEgKyAobm9kZS5uZXh0ID8gJywnIDogJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluc2VydCBlbGVtZW50IGJ5IG9yZGVyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNtcCBcbiAgICAgKi9cbiAgICBvcmRlckluc2VydCAoZGF0YSwgY21wKSB7XG4gICAgICAgIGNtcCA9IHR5cGVvZiBjbXAgPT09ICdmdW5jdGlvbicgPyBjbXAgOiAoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEgPiBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjbXAoZGF0YSwgY3VycmVudC5kYXRhKTtcbiAgICAgICAgICAgIC8vIOWmguaenOaPkuWFpeWFg+e0oOWkp+S6juW9k+WJjeWFg+e0oO+8jOWHhuWkh+S4i+asoemBjeWOhlxuICAgICAgICAgICAgaWYgKHJldCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcblxuICAgICAgICAgICAgICAgIC8vIOWmguaenOetieS6ju+8jOebtOaOpeaPkuWFpeWIsOWQjumdolxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzlsI/kuo7liJnmj5LlhaXliLDliY3oioLngrnlkozlvZPliY3oioLngrnkuK1cbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrlt7Lnu4/mmK/mjpLluo/kuobvvIzmiYDku6XkuI3pnIDopoHlpJrkvZnliKTmlq3kuoZcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gcHJldmlvdXMgJiYgcHJldmlvdXMgPT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2hpZnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmj5LlhaXliLDmnIDlkI7kuIDkuKrnu5PngrlcbiAgICAgICAgcHJldmlvdXMubmV4dCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICB0aGlzLnRhaWwgPSBwcmV2aW91cy5uZXh0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydEJldHdlZW4oZGF0YSwgYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT0gYikge1xuICAgICAgICAgICAgICAgIGlmIChhID09IG1lLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS51bnNoaWZ0KGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRlbXAubmV4dCA9IGI7XG4gICAgICAgICAgICAgICAgYS5uZXh0ID0gdGVtcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOWIoOmZpOWFg+e0oOmAkuWinuaOkuWIl+eahOmTvuihqOS4reWAvOWkp+S6jm1pbu+8jOS4lOWwj+S6jm1heOeahOaJgOacieWFg+e0oFxuICAgIGRlbGV0ZUJldHdlZW4gKG1pbiwgbWF4KSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIC8vIHDmmK/mnIDlkI7kuIDkuKrkuI3lpKfkuo5taW7nmoTlhYPntKBcbiAgICAgICAgd2hpbGUgKHAubmV4dCAmJiBwLm5leHQuZGF0YSA8PSBtaW4pIHAgPSBwLm5leHQ7XG5cbiAgICAgICAgLy8g5aaC5p6c6L+Y5pyJ5q+UbWlu5pu05aSn55qE5YWD57SgXG4gICAgICAgIGxldCBxO1xuICAgICAgICBpZiAocC5uZXh0KSB7XG4gICAgICAgICAgICBxID0gcC5uZXh0O1xuICAgICAgICAgICAgLy8gceaYr+esrOS4gOS4quS4jeWwj+S6jm1heOeahOWFg+e0oFxuICAgICAgICAgICAgd2hpbGUgKHEgJiYgcS5kYXRhIDwgbWF4KSBxID0gcS5uZXh0O1xuICAgICAgICAgICAgcC5uZXh0ID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXN0ID0gcSB8fCBwO1xuICAgICAgICB3aGlsZSAobGFzdC5uZXh0KSBsYXN0ID0gbGFzdC5uZXh0O1xuICAgICAgICB0aGlzLnRhaWwgPSBsYXN0O1xuICAgIH1cblxuICAgIC8vIOWIoOmZpOWFg+e0oOmAkuWinuaOkuWIl+eahOmTvuihqOeahOmHjeWkjeWFg+e0oFxuICAgIGRlbGV0ZUVxdWFsICgpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBxID0gcC5uZXh0O1xuXG4gICAgICAgIHdoaWxlIChwLm5leHQpIHtcbiAgICAgICAgICAgIC8vIOW9k+ebuOmCu+S4pOWFg+e0oOS4jeebuOetieaXtu+8jHAscemDveWQkeWQjuenu1xuICAgICAgICAgICAgaWYgKHAuZGF0YSAhPT0gcS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICBxID0gcC5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocS5kYXRhID09PSBwLmRhdGEpIHEgPSBxLm5leHQ7XG5cbiAgICAgICAgICAgICAgICAvLyDliKDpmaRcbiAgICAgICAgICAgICAgICBwLm5leHQgPSBxO1xuICAgICAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICAgICAgICAgIHEgPSBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXZlcnNlICgpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBxID0gcC5uZXh0O1xuICAgICAgICBsZXQgcyA9IHEubmV4dDtcbiAgICAgICAgdGhpcy50YWlsID0gcDtcbiAgICAgICAgcC5uZXh0ID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocy5uZXh0KSB7XG4gICAgICAgICAgICBxLm5leHQgPSBwO1xuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgICAgICBxID0gcztcbiAgICAgICAgICAgIHMgPSBzLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBxLm5leHQgPSBwO1xuICAgICAgICBzLm5leHQgPSBxO1xuICAgICAgICB0aGlzLmhlYWQgPSBzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcEZuKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTGlzdC9MaW5rZWRMaXN0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG4vLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcblJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICBpZiAodGhpcy5yYW5kLmdldEJ5dGVzKVxuICAgIHJldHVybiB0aGlzLnJhbmQuZ2V0Qnl0ZXMobik7XG5cbiAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKylcbiAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0Jykge1xuICBpZiAoc2VsZi5jcnlwdG8gJiYgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXJzXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChzZWxmLm1zQ3J5cHRvICYmIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gSUVcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgLy8gU2FmYXJpJ3MgV2ViV29ya2VycyBkbyBub3QgaGF2ZSBgY3J5cHRvYFxuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT2xkIGp1bmtcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfTtcbiAgfVxufSBlbHNlIHtcbiAgLy8gTm9kZS5qcyBvciBXZWIgd29ya2VyIHdpdGggbm8gY3J5cHRvIHN1cHBvcnRcbiAgdHJ5IHtcbiAgICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKTtcblxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm9yYW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBHSEFTSCA9IHJlcXVpcmUoJy4vZ2hhc2gnKVxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2ZpbklEID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDFdKV0pXG4gIGl2ID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDJdKV0pXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fYWxlbiA9IDBcbiAgdGhpcy5fbGVuID0gMFxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHZhciBoID0gbmV3IEJ1ZmZlcig0KVxuICBoLmZpbGwoMClcbiAgdGhpcy5fZ2hhc2ggPSBuZXcgR0hBU0godGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhoKSlcbiAgdGhpcy5fYXV0aFRhZyA9IG51bGxcbiAgdGhpcy5fY2FsbGVkID0gZmFsc2Vcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBpZiAoIXRoaXMuX2NhbGxlZCAmJiB0aGlzLl9hbGVuKSB7XG4gICAgdmFyIHJ1bXAgPSAxNiAtICh0aGlzLl9hbGVuICUgMTYpXG4gICAgaWYgKHJ1bXAgPCAxNikge1xuICAgICAgcnVtcCA9IG5ldyBCdWZmZXIocnVtcClcbiAgICAgIHJ1bXAuZmlsbCgwKVxuICAgICAgdGhpcy5fZ2hhc2gudXBkYXRlKHJ1bXApXG4gICAgfVxuICB9XG4gIHRoaXMuX2NhbGxlZCA9IHRydWVcbiAgdmFyIG91dCA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKG91dClcbiAgfVxuICB0aGlzLl9sZW4gKz0gY2h1bmsubGVuZ3RoXG4gIHJldHVybiBvdXRcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCAmJiAhdGhpcy5fYXV0aFRhZykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcbiAgfVxuICB2YXIgdGFnID0geG9yKHRoaXMuX2doYXNoLmZpbmFsKHRoaXMuX2FsZW4gKiA4LCB0aGlzLl9sZW4gKiA4KSwgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9maW5JRCkpXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgaWYgKHhvclRlc3QodGFnLCB0aGlzLl9hdXRoVGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH1cbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uIGdldEF1dGhUYWcgKCkge1xuICBpZiAoIXRoaXMuX2RlY3J5cHQgJiYgQnVmZmVyLmlzQnVmZmVyKHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGhUYWdcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gc2V0QXV0aFRhZyAodGFnKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uIHNldEFBRCAoYnVmKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkKSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGJ1ZilcbiAgICB0aGlzLl9hbGVuICs9IGJ1Zi5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IEFBRCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cbmZ1bmN0aW9uIHhvclRlc3QgKGEsIGIpIHtcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIG91dCsrXG4gIH1cbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0ICs9IChhW2ldIF4gYltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIGRhdGEgPSB4b3IoYmxvY2ssIHNlbGYuX3ByZXYpXG5cbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soZGF0YSlcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBwYWQgPSBzZWxmLl9wcmV2XG5cbiAgc2VsZi5fcHJldiA9IGJsb2NrXG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxuXG4gIHJldHVybiB4b3Iob3V0LCBwYWQpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2JjLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKCcnKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gbmV3IEJ1ZmZlcignJylcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZFxuICB2YXIgaSA9IC0xXG4gIHZhciBsZW4gPSA4XG4gIHZhciBvdXQgPSAwXG4gIHZhciBiaXQsIHZhbHVlXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgYml0ID0gKGJ5dGVQYXJhbSAmICgxIDw8ICg3IC0gaSkpKSA/IDB4ODAgOiAwXG4gICAgdmFsdWUgPSBwYWRbMF0gXiBiaXRcbiAgICBvdXQgKz0gKCh2YWx1ZSAmIDB4ODApID4+IChpICUgOCkpXG4gICAgc2VsZi5fcHJldiA9IHNoaWZ0SW4oc2VsZi5fcHJldiwgZGVjcnlwdCA/IGJpdCA6IHZhbHVlKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gc2hpZnRJbiAoYnVmZmVyLCB2YWx1ZSkge1xuICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGJ1ZmZlci5sZW5ndGgpXG4gIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgbmV3IEJ1ZmZlcihbdmFsdWVdKV0pXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBidWZmZXJbaV0gPDwgMSB8IGJ1ZmZlcltpICsgMV0gPj4gKDcpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjEuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldi5zbGljZSgxKSwgbmV3IEJ1ZmZlcihbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXSlcbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGJsb2NrKVxufVxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktYWVzL21vZGVzL2VjYi5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuXG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvb2ZiLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rLCB0aGlzLl9kZWNyeXB0KVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJzaGEyMjRXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMjI0XCIsXG5cdFx0XCJpZFwiOiBcIjMwMmQzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwNDA1MDAwNDFjXCJcblx0fSxcblx0XCJSU0EtU0hBMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYS9yc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyMjRcIixcblx0XHRcImlkXCI6IFwiMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWNcIlxuXHR9LFxuXHRcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyNTZcIixcblx0XHRcImlkXCI6IFwiMzAzMTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAxMDUwMDA0MjBcIlxuXHR9LFxuXHRcIlJTQS1TSEEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImVjZHNhL3JzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuXHRcdFwiaWRcIjogXCIzMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMFwiXG5cdH0sXG5cdFwic2hhMzg0V2l0aFJTQUVuY3J5cHRpb25cIjoge1xuXHRcdFwic2lnblwiOiBcInJzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTM4NFwiLFxuXHRcdFwiaWRcIjogXCIzMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMFwiXG5cdH0sXG5cdFwiUlNBLVNIQTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZWNkc2EvcnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMzg0XCIsXG5cdFx0XCJpZFwiOiBcIjMwNDEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMjA1MDAwNDMwXCJcblx0fSxcblx0XCJzaGE1MTJXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhNTEyXCIsXG5cdFx0XCJpZFwiOiBcIjMwNTEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMzA1MDAwNDQwXCJcblx0fSxcblx0XCJSU0EtU0hBNTEyXCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYS9yc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGE1MTJcIixcblx0XHRcImlkXCI6IFwiMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDBcIlxuXHR9LFxuXHRcIlJTQS1TSEExXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGExXCIsXG5cdFx0XCJpZFwiOiBcIjMwMjEzMDA5MDYwNTJiMGUwMzAyMWEwNTAwMDQxNFwiXG5cdH0sXG5cdFwiZWNkc2Etd2l0aC1TSEExXCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTFcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJzaGEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImVjZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMjU2XCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwic2hhMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTIyNFwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcInNoYTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZWNkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEzODRcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJzaGE1MTJcIjoge1xuXHRcdFwic2lnblwiOiBcImVjZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhNTEyXCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVNIQVwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMVwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcIkRTQS1TSEExXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGExXCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGExXCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVdJVEgtU0hBMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyMjRcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtU0hBMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyMjRcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtV0lUSC1TSEEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImRzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcIkRTQS1TSEEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImRzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcIkRTQS1XSVRILVNIQTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMzg0XCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVNIQTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMzg0XCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVdJVEgtU0hBNTEyXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGE1MTJcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtU0hBNTEyXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGE1MTJcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtUklQRU1EMTYwXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJybWQxNjBcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJyaXBlbWQxNjBXaXRoUlNBXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJybWQxNjBcIixcblx0XHRcImlkXCI6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCJcblx0fSxcblx0XCJSU0EtUklQRU1EMTYwXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJybWQxNjBcIixcblx0XHRcImlkXCI6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCJcblx0fSxcblx0XCJtZDVXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwibWQ1XCIsXG5cdFx0XCJpZFwiOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiXG5cdH0sXG5cdFwiUlNBLU1ENVwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwibWQ1XCIsXG5cdFx0XCJpZFwiOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiXG5cdH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL2FsZ29yaXRobXMuanNvblxuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiMS4zLjEzMi4wLjEwXCI6IFwic2VjcDI1NmsxXCIsXG5cdFwiMS4zLjEzMi4wLjMzXCI6IFwicDIyNFwiLFxuXHRcIjEuMi44NDAuMTAwNDUuMy4xLjFcIjogXCJwMTkyXCIsXG5cdFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiOiBcInAyNTZcIixcblx0XCIxLjMuMTMyLjAuMzRcIjogXCJwMzg0XCIsXG5cdFwiMS4zLjEzMi4wLjM1XCI6IFwicDUyMVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9jdXJ2ZXMuanNvblxuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcblxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jcmVhdGUtaGFzaC9tZDUuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLlVJTlQzMiA9IHJlcXVpcmUoJy4vbGliL3VpbnQzMicpXG5leHBvcnRzLlVJTlQ2NCA9IHJlcXVpcmUoJy4vbGliL3VpbnQ2NCcpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N1aW50L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZmluZFByaW1lO1xuZmluZFByaW1lLnNpbXBsZVNpZXZlID0gc2ltcGxlU2lldmU7XG5maW5kUHJpbWUuZmVybWF0VGVzdCA9IGZlcm1hdFRlc3Q7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBPTkUgPSBuZXcgQk4oMSk7XG52YXIgVFdPID0gbmV3IEJOKDIpO1xudmFyIEZJVkUgPSBuZXcgQk4oNSk7XG52YXIgU0lYVEVFTiA9IG5ldyBCTigxNik7XG52YXIgRUlHSFQgPSBuZXcgQk4oOCk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIEZPVVIgPSBuZXcgQk4oNCk7XG52YXIgVFdFTFZFID0gbmV3IEJOKDEyKTtcbnZhciBwcmltZXMgPSBudWxsO1xuXG5mdW5jdGlvbiBfZ2V0UHJpbWVzKCkge1xuICBpZiAocHJpbWVzICE9PSBudWxsKVxuICAgIHJldHVybiBwcmltZXM7XG5cbiAgdmFyIGxpbWl0ID0gMHgxMDAwMDA7XG4gIHZhciByZXMgPSBbXTtcbiAgcmVzWzBdID0gMjtcbiAgZm9yICh2YXIgaSA9IDEsIGsgPSAzOyBrIDwgbGltaXQ7IGsgKz0gMikge1xuICAgIHZhciBzcXJ0ID0gTWF0aC5jZWlsKE1hdGguc3FydChrKSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICYmIHJlc1tqXSA8PSBzcXJ0OyBqKyspXG4gICAgICBpZiAoayAlIHJlc1tqXSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG5cbiAgICBpZiAoaSAhPT0gaiAmJiByZXNbal0gPD0gc3FydClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcmVzW2krK10gPSBrO1xuICB9XG4gIHByaW1lcyA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc2ltcGxlU2lldmUocCkge1xuICB2YXIgcHJpbWVzID0gX2dldFByaW1lcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWVzLmxlbmd0aDsgaSsrKVxuICAgIGlmIChwLm1vZG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgaWYgKHAuY21wbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmVybWF0VGVzdChwKSB7XG4gIHZhciByZWQgPSBCTi5tb250KHApO1xuICByZXR1cm4gVFdPLnRvUmVkKHJlZCkucmVkUG93KHAuc3VibigxKSkuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmltZShiaXRzLCBnZW4pIHtcbiAgaWYgKGJpdHMgPCAxNikge1xuICAgIC8vIHRoaXMgaXMgd2hhdCBvcGVuc3NsIGRvZXNcbiAgICBpZiAoZ2VuID09PSAyIHx8IGdlbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHg3Yl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDI3XSk7XG4gICAgfVxuICB9XG4gIGdlbiA9IG5ldyBCTihnZW4pO1xuXG4gIHZhciBudW0sIG4yO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbnVtID0gbmV3IEJOKHJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpKTtcbiAgICB3aGlsZSAobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgbnVtLmlzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAobnVtLmlzRXZlbigpKSB7XG4gICAgICBudW0uaWFkZChPTkUpO1xuICAgIH1cbiAgICBpZiAoIW51bS50ZXN0bigxKSkge1xuICAgICAgbnVtLmlhZGQoVFdPKTtcbiAgICB9XG4gICAgaWYgKCFnZW4uY21wKFRXTykpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIG51bS5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdlbi5jbXAoRklWRSkpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRFTikuY21wKFRIUkVFKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbjIgPSBudW0uc2hybigxKTtcbiAgICBpZiAoc2ltcGxlU2lldmUobjIpICYmIHNpbXBsZVNpZXZlKG51bSkgJiZcbiAgICAgIGZlcm1hdFRlc3QobjIpICYmIGZlcm1hdFRlc3QobnVtKSAmJlxuICAgICAgbWlsbGVyUmFiaW4udGVzdChuMikgJiYgbWlsbGVyUmFiaW4udGVzdChudW0pKSB7XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGlmZmllLWhlbGxtYW4vbGliL2dlbmVyYXRlUHJpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBicm9yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuXG5mdW5jdGlvbiBNaWxsZXJSYWJpbihyYW5kKSB7XG4gIHRoaXMucmFuZCA9IHJhbmQgfHwgbmV3IGJyb3JhbmQuUmFuZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNaWxsZXJSYWJpbjtcblxuTWlsbGVyUmFiaW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHJhbmQpIHtcbiAgcmV0dXJuIG5ldyBNaWxsZXJSYWJpbihyYW5kKTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciBidWYgPSB0aGlzLnJhbmQuZ2VuZXJhdGUoTWF0aC5jZWlsKGxlbiAvIDgpKTtcblxuICAvLyBTZXQgbG93IGJpdHNcbiAgYnVmWzBdIHw9IDM7XG5cbiAgLy8gTWFzayBoaWdoIGJpdHNcbiAgdmFyIG1hc2sgPSBsZW4gJiAweDc7XG4gIGlmIChtYXNrICE9PSAwKVxuICAgIGJ1ZltidWYubGVuZ3RoIC0gMV0gPj49IDcgLSBtYXNrO1xuXG4gIHJldHVybiBuZXcgYm4oYnVmKTtcbn1cblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KG4sIGssIGNiKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICB2YXIgbjIgPSBuMS5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIHZhciBwcmltZSA9IHRydWU7XG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kKG4yKTtcbiAgICBpZiAoY2IpXG4gICAgICBjYihhKTtcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5nZXREaXZpc29yID0gZnVuY3Rpb24gZ2V0RGl2aXNvcihuLCBrKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICB2YXIgbjIgPSBuMS5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kKG4yKTtcblxuICAgIHZhciBnID0gbi5nY2QoYSk7XG4gICAgaWYgKGcuY21wbigxKSAhPT0gMClcbiAgICAgIHJldHVybiBnO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcbiAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21pbGxlci1yYWJpbi9saWIvbXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxuXG5leHBvcnRzLnBia2RmMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNoZWNrUGFyYW1ldGVycyhpdGVyYXRpb25zLCBrZXlsZW4pXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCBleHBvcnRzLnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSlcbiAgfSlcbn1cblxudmFyIGRlZmF1bHRFbmNvZGluZ1xuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICBkZWZhdWx0RW5jb2RpbmcgPSAndXRmLTgnXG59IGVsc2Uge1xuICB2YXIgcFZlcnNpb25NYWpvciA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicpWzBdLnNsaWNlKDEpLCAxMClcblxuICBkZWZhdWx0RW5jb2RpbmcgPSBwVmVyc2lvbk1ham9yID49IDYgPyAndXRmLTgnIDogJ2JpbmFyeSdcbn1cblxuZXhwb3J0cy5wYmtkZjJTeW5jID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgZGVmYXVsdEVuY29kaW5nKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIGNoZWNrUGFyYW1ldGVycyhpdGVyYXRpb25zLCBrZXlsZW4pXG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gIHZhciBoTGVuXG4gIHZhciBsID0gMVxuICB2YXIgREsgPSBuZXcgQnVmZmVyKGtleWxlbilcbiAgdmFyIGJsb2NrMSA9IG5ldyBCdWZmZXIoc2FsdC5sZW5ndGggKyA0KVxuICBzYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgclxuICB2YXIgVFxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuICAgIHZhciBVID0gY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoYmxvY2sxKS5kaWdlc3QoKVxuXG4gICAgaWYgKCFoTGVuKSB7XG4gICAgICBoTGVuID0gVS5sZW5ndGhcbiAgICAgIFQgPSBuZXcgQnVmZmVyKGhMZW4pXG4gICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pXG4gICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW5cbiAgICB9XG5cbiAgICBVLmNvcHkoVCwgMCwgMCwgaExlbilcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICBVID0gY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoVSkuZGlnZXN0KClcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaExlbjsgaysrKSBUW2tdIF49IFVba11cbiAgICB9XG5cbiAgICB2YXIgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuXG4gICAgdmFyIGxlbiA9IChpID09PSBsID8gciA6IGhMZW4pXG4gICAgVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG4gIH1cblxuICByZXR1cm4gREtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYmtkZjIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlZWQsIGxlbikge1xuICB2YXIgdCA9IG5ldyBCdWZmZXIoJycpO1xuICB2YXIgIGkgPSAwLCBjO1xuICB3aGlsZSAodC5sZW5ndGggPCBsZW4pIHtcbiAgICBjID0gaTJvcHMoaSsrKTtcbiAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwgY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzZWVkKS51cGRhdGUoYykuZGlnZXN0KCldKTtcbiAgfVxuICByZXR1cm4gdC5zbGljZSgwLCBsZW4pO1xufTtcblxuZnVuY3Rpb24gaTJvcHMoYykge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcig0KTtcbiAgb3V0LndyaXRlVUludDMyQkUoYywwKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVibGljLWVuY3J5cHQvbWdmLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbmZ1bmN0aW9uIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkZGVkTXNnXG4gICAgLnRvUmVkKGJuLm1vbnQoa2V5Lm1vZHVsdXMpKVxuICAgIC5yZWRQb3cobmV3IGJuKGtleS5wdWJsaWNFeHBvbmVudCkpXG4gICAgLmZyb21SZWQoKVxuICAgIC50b0FycmF5KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhQdWJsaWM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1YmxpYy1lbmNyeXB0L3dpdGhQdWJsaWMuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFbaV0gXj0gYltpXTtcbiAgfVxuICByZXR1cm4gYVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVibGljLWVuY3J5cHQveG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaGEuanMvc2hhMjU2LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDY0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2doLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oaCwgdGhpcy5faGwsIDU2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL3NoYTUxMi5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5LqM5Y+J5qCR55qE6aG65bqP5a2Y5YKo57uT5p6EXG4gKi9cblxuLy8g6aG65bqP5a2Y5YKo57uT5p6E55qE6YGN5Y6GXG5leHBvcnQgZnVuY3Rpb24gcHJlT3JkZXJSZWN1cnNpdmUodHJlZSwgeCwgdmlzaXQpIHtcbiAgICB2aXNpdCh0cmVlW3hdKTtcbiAgICBpZiAodHJlZVsyICogeCArIDFdKSBwcmVPcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDEsIHZpc2l0KTtcbiAgICBpZiAodHJlZVsyICogeCArIDJdKSBwcmVPcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDIsIHZpc2l0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbk9yZGVyUmVjdXJzaXZlKHRyZWUsIHgsIHZpc2l0KSB7XG4gICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgaW5PcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDEsIHZpc2l0KTtcbiAgICB2aXNpdCh0cmVlW3hdKTtcbiAgICBpZiAodHJlZVsyICogeCArIDJdKSBpbk9yZGVyUmVjdXJzaXZlKHRyZWUsIDIgKiB4ICsgMiwgdmlzaXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE9yZGVyUmVjdXJzaXZlKHRyZWUsIHgsIHZpc2l0KSB7XG4gICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgcG9zdE9yZGVyUmVjdXJzaXZlKHRyZWUsIDIgKiB4ICsgMSwgdmlzaXQpO1xuICAgIGlmICh0cmVlWzIgKiB4ICsgMl0pIHBvc3RPcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDIsIHZpc2l0KTtcbiAgICB2aXNpdCh0cmVlW3hdKTtcbn1cblxubGV0IHRyZWUgPSBbMSwgMiwgMywgNCwgNSwgLCA2LCAsICwgN107XG5cbmNvbnNvbGUubG9nKCdwcmVPcmRlcjonKTtcbnByZU9yZGVyUmVjdXJzaXZlKHRyZWUsIDAsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbn0pO1xuXG5jb25zb2xlLmxvZygnaW5PcmRlcjonKTtcbmluT3JkZXJSZWN1cnNpdmUodHJlZSwgMCwgKHZhbHVlKSA9PiB7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xufSk7XG5cbmNvbnNvbGUubG9nKCdwb3N0T3JkZXI6Jyk7XG5wb3N0T3JkZXJSZWN1cnNpdmUodHJlZSwgMCwgKHZhbHVlKSA9PiB7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQmluYXJ5VHJlZS9CaW5hcnlUcmVlQXJyYXkuanMiLCIvKipcbiAqIOi1q+Wkq+abvO+8iEh1ZmZtYW7vvInmoJHvvIzlj4jnp7DmnIDkvJjmoJHvvIzmmK/kuIDnsbvluKbmnYPot6/lvoTplb/luqbmnIDnn63nmoTmoJHvvIzmnInnnYDlub/ms5vlupTnlKjjgIJcbiAqXG4gKiDku47moJHkuK3kuIDkuKrnu5PngrnliLDlj6bkuIDkuKrnu5PngrnkuYvpl7TnmoTliIbmlK/mnoTmiJDov5nkuKTkuKrnu5PngrnkuYvpl7TnmoTot6/lvoTvvIzot6/lvoTkuIrnmoTliIbmlK/mlbDnm67np7DkvZzot6/lvoTplb/luqbjgIJcbiAqIOagkeeahOi3r+W+hOmVv+W6puaYr+S7juagkeagueWIsOavj+S4gOS4que7k+eCueeahOi3r+W+hOS5i+WSjOOAglxuICog57uT54K555qE5bim5p2D6Lev5b6E6ZW/5bqm5Li65LuO6K+l57uT54K55Yiw5qCR5qC55LmL6Ze055qE6Lev5b6E6ZW/5bqm5LiO57uT54K55LiK5p2D55qE5LmY56ev44CC5qCR55qE5bim5p2D6Lev5b6E6ZW/5bqm5Li65qCR5Lit5omA5pyJ5Y+25a2Q57uT54K555qE5bim5p2D6Lev5b6E6ZW/5bqm5LmL5ZKM44CCXG4gKlxuICog5p6E6YCg6LWr5aSr5pu85qCR55qE5q2l6aqk77yaXG4gKiDvvIgx77yJ5qC55o2u57uZ5a6a55qEbuS4quadg+WAvHt3MSx3MiwuLi53bn3mnoTmiJBu5qO15LqM5Y+J5qCR55qE6ZuG5ZCIRiA9IHtUMSxUMiwuLi5Ubn3vvIzlhbbkuK3mr4/mo7Xkuozlj4nmoJFUaeS4reWPquacieS4gOS4quW4puadg+S4undp55qE5qC557uT54K577yM5YW25bem5Y+z5a2Q5qCR5Z2H56m644CCXG4gKiDvvIgy77yJ5ZyoRuS4remAieWPluS4pOajteaguee7k+eCueeahOadg+WAvOacgOWwj+eahOagkeS9nOS4uuW3puWPs+WtkOagkeaehOmAoOS4gOajteaWsOeahOS6jOWPieagke+8jOS4lOe9ruaWsOeahOS6jOWPieagkeeahOaguee7k+eCueeahOadg+WAvOS4uuWFtuW3puWPs+WtkOagkeS4iuaguee7k+eCueeahOadg+WAvOS5i+WSjOOAglxuICog77yIM++8ieWcqEbkuK3liKDpmaTov5nkuKTmo7XmoJHvvIzlkIzml7blsIbmlrDlvpfliLDnmoTkuozlj4nmoJHliqDlhaVG5Lit44CCXG4gKiDvvIg077yJ6YeN5aSN77yIMu+8ieWSjO+8iDPvvInvvIznm7TliLBG5Y+q5ZCr5LiA5qO15qCR5Li65q2i44CC6L+Z5qO15qCR5L6/5piv6LWr5aSr5pu85qCR44CCXG4gKi9cbi8qXG7otavlpKvmm7znvJbnoIFcbmh0dHA6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlDJThEJUU1JUE0JUFCJUU2JTlCJUJDJUU3JUJDJTk2JUU3JUEwJTgxXG5cbuWBh+iuvueUteaKpemcgOS8oOmAgeeahOeUteaWh+S4uuKAnEEgQiBBIEMgQyBEIEHigJ3vvIzlroPlj6rmnIk056eN5a2X56ym5Y+q6ZyA5Lik5Liq5a2X56ym5Liy5L6/5Y+v5YiG6L6o44CC5YGH6K6+QSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAwLDAxLDEw5ZKMMTHvvIzliJnkuIrov7A35Liq5a2X56ym55qE55S15paH5L6/5Li64oCcMDAwMTAwMTAxMDExMDDigJ3vvIzlr7nmlrnmjqXmlLbml7bvvIzlj6/mjInkuozkvY3kuIDliIbov5vooYzor5HnoIHjgIJcbuWcqOS8oOmAgeeUteaWh+aXtu+8jOW4jOacm+aAu+mVv+WwveWPr+iDveWcsOefreOAguWmguaenOWvueavj+S4quWtl+espuiuvuiuoemVv+W6puS4jeetieeahOe8luegge+8jOS4lOiuqeeUteaWh+S4reWHuueOsOasoeaVsOi+g+WkmueahOWtl+espumHh+eUqOWwveWPr+iDveefreeahOe8luegge+8jOWImeS8oOmAgeeUteaWh+eahOaAu+mVv+S+v+WPr+WHj+WwkeOAglxu5aaC5p6c5raJ5Y+KQSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAsMDAsMeWSjDAx77yM5YiZ5LiK6L+wN+S4quWtl+espueahOeUteaWh+WPr+i9rOaNouaIkOaAu+mVv+S4ujnnmoTlrZfnrKbkuLLigJwwMDAwMTEwMTDigJ3jgILkvYbmmK/vvIzov5nmoLfnmoTnlLXmlofml6Dms5Xnv7vor5HvvIzlm6DkuLrlj6/mnInlpJrnp43or5Hms5XjgIJcbuWboOatpO+8jOiLpeimgeiuvuiuoemVv+efreS4jeetieeahOe8luegge+8jOWImeW/hemhu+aYr+S7u+aEj+S4quWtl+espueahOe8lueggemDveS4jeaYr+WPpuS4gOS4quWtl+espue8lueggeeahOWJjee8gO+8jOi/meenjee8lueggeensOS9nOWJjee8gOe8lueggeOAglxu5Y+v5Yip55So5LqM5Y+J5qCR5p2l6K6+6K6h5LqM6L+b5Yi255qE5YmN57yA57yW56CB44CC5YGH6K6+5pyJ5LiA5qO15LqM5Y+J5qCR77yM5YW2NOS4quWPtuWtkOe7k+eCueWIhuWIq+ihqOekukEsQixDLETov5k05Liq5a2X56ym77yM5LiU57qm5a6a5bem5YiG5pSv6KGo56S65a2X56ym4oCcMOKAne+8jOWPs+WIhuaUr+ihqOekuuWtl+espuKAnDHigJ3vvIzliJnlj6/ku6Xku47moLnnu5PngrnliLDlj7blrZDnu5PngrnnmoTot6/lvoTkuIrliIbmlK/lrZfnrKbnu4TmiJDnmoTlrZfnrKbkuLLkvZzkuLror6Xlj7blrZDnu5PngrnlrZfnrKbnmoTnvJbnoIHjgILmiYDlvpfkuozov5vliLbliY3nvIDnvJbnoIHliIbliKvkuLowLDEwLDExMCwxMTEuXG7orr7orqHnlLXmlofmgLvplb/mnIDnn63nmoTkuozov5vliLbliY3nvIDnvJbnoIHljbPku6Vu56eN5a2X56ym5Ye6546w55qE6aKR546H5L2c5p2D44CCXG4gKi9cblxuLy8g6LWr5aSr5pu85qCR5ZKM6LWr5aSr5pu857yW56CB55qE5a2Y5YKo57uT5p6EXG5mdW5jdGlvbiBIdWZmbWFuTm9kZSh3ZWlnaHQsIHBhcmVudCwgbGVmdENoaWxkLCByaWdodENoaWxkKSB7XG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQgfHwgMDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCAwO1xuICAgIHRoaXMubGVmdENoaWxkID0gbGVmdENoaWxkIHx8IDA7XG4gICAgdGhpcy5yaWdodENoaWxkID0gcmlnaHRDaGlsZCB8fCAwO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaHVmZk1hbkNvZGluZyh3ZWlnaHRzKSB7XG4gICAgbGV0IG4gPSB3ZWlnaHRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDEpIHJldHVybjtcblxuICAgIGxldCBodWZmbWFuVHJlZSA9IGJ1aWxkSHVmZm1hblRyZWUod2VpZ2h0cywgbik7XG5cbiAgICAvLyDku47lj7blrZDliLDmoLnpgIblkJHmsYLmr4/kuKrlrZfnrKbnmoTotavlpKvmm7znvJbnoIFcbiAgICBsZXQgaGMgPSBjYWxjSHVmZm1hbkNvZGUoaHVmZm1hblRyZWUsIG4pO1xuXG4gICAgcmV0dXJuIFtodWZmbWFuVHJlZSwgaGNdO1xufVxuXG5cbmZ1bmN0aW9uIGNhbGNIdWZmbWFuQ29kZShodWZmbWFuVHJlZSwgbikge1xuICAgIC8vIOS7juWPtuWtkOWIsOaguemAhuWQkeaxguavj+S4quWtl+espueahOi1q+Wkq+abvOe8lueggVxuICAgIGxldCBoYyA9IFtdO1xuICAgIGxldCBjZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IG4gLSAxO1xuICAgICAgICBmb3IgKGxldCBjID0gaSwgZiA9IGh1ZmZtYW5UcmVlW2ldLnBhcmVudDsgZiAhPSAwOyBjID0gZiwgZiA9IGh1ZmZtYW5UcmVlW2ZdLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGh1ZmZtYW5UcmVlW2ZdLmxlZnRDaGlsZCA9PSBjKSBjZFstLXN0YXJ0XSA9ICcwJztcbiAgICAgICAgICAgIGVsc2UgY2RbLS1zdGFydF0gPSAnMSc7XG4gICAgICAgIH1cblxuICAgICAgICBoY1tpXSA9IHN0ckNvcHkoY2QsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGM7XG59XG5cbi8vIOWIm+W7uuS4gOajteWPtuWtkOe7k+eCueaVsOS4um7nmoRIdWZmbWFu5qCRXG5mdW5jdGlvbiBidWlsZEh1ZmZtYW5UcmVlKHdlaWdodHMsIG4pIHtcbiAgICBuID0gbiB8fCB3ZWlnaHRzLmxlbmd0aDtcbiAgICBsZXQgbSA9IDIgKiBuIC0gMTtcbiAgICBsZXQgaHVmZm1hblRyZWUgPSBbXTtcblxuICAgIC8vIOWIneWni+WMllxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldID0gbmV3IEh1ZmZtYW5Ob2RlKHdlaWdodHNbaV0sIDAsIDAsIDApO1xuICAgIGZvciAoOyBpIDwgbTsgaSsrKVxuICAgICAgICBodWZmbWFuVHJlZVtpXSA9IG5ldyBIdWZmbWFuTm9kZSgwLCAwLCAwLCAwKTtcblxuICAgIGZvciAobGV0IGkgPSBuOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgIC8vIOWcqEhUWzEuLmktMV3pgInmi6lwYXJlbnTkuLow5LiUd2VpZ2h05pyA5bCP55qE5Lik5Liq57uT54K577yM6L+U5Zue5YW25bqP5Y+35Li6W3MxLCBzMl1cbiAgICAgICAgbGV0IHJldCA9IHNlbGVjdChodWZmbWFuVHJlZSwgaSk7XG4gICAgICAgIGxldCBzMSA9IHJldFswXTtcbiAgICAgICAgbGV0IHMyID0gcmV0WzFdO1xuICAgICAgICBodWZmbWFuVHJlZVtzMV0ucGFyZW50ID0gaTtcbiAgICAgICAgaHVmZm1hblRyZWVbczJdLnBhcmVudCA9IGk7XG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLmxlZnRDaGlsZCA9IHMxO1xuICAgICAgICBodWZmbWFuVHJlZVtpXS5yaWdodENoaWxkID0gczI7XG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLndlaWdodCA9IGh1ZmZtYW5UcmVlW3MxXS53ZWlnaHQgKyBodWZmbWFuVHJlZVtzMl0ud2VpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBodWZmbWFuVHJlZTtcbn1cblxuZnVuY3Rpb24gc3RyQ29weShzdHIsIHN0YXJ0KSB7XG4gICAgbGV0IHMgPSAnJztcbiAgICBmb3IgKDsgc3RyW3N0YXJ0XTsgc3RhcnQrKykge1xuICAgICAgICBzICs9IHN0cltzdGFydF07XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3QoaHVmZm1hblRyZWUsIGxlbikge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaHVmZm1hblRyZWVbaV07XG4gICAgICAgIGlmIChub2RlLnBhcmVudCAhPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHJldC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXQucHVzaChpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGh1ZmZtYW5UcmVlW3JldFswXV0ud2VpZ2h0ID4gaHVmZm1hblRyZWVbcmV0WzFdXS53ZWlnaHRcbiAgICAgICAgICAgICAgICA/IDAgOiAxO1xuXG4gICAgICAgICAgICBpZiAobm9kZS53ZWlnaHQgPCBodWZmbWFuVHJlZVtyZXRbaW5kZXhdXS53ZWlnaHQpXG4gICAgICAgICAgICAgICAgcmV0W2luZGV4XSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV0WzBdID4gcmV0WzFdKSB7XG4gICAgICAgIGxldCB0ZW1wID0gcmV0WzBdO1xuICAgICAgICByZXRbMF0gPSByZXRbMV07XG4gICAgICAgIHJldFsxXSA9IHRlbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY29uc29sZS5sb2coJy0tLS0tLS1odWZmbWFuIGNvZGluZyAxOi0tLS0tLScpO1xuY29uc29sZS5sb2coaHVmZk1hbkNvZGluZyhbNSwgMjksIDcsIDgsIDE0LCAyMywgMywgMTFdKSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZy5qcyIsIi8qKlxuICog5bm/5LmJ6KGoXG4gKlxuICog5bm/5LmJ6KGo5piv57q/5oCn6KGo55qE5o6o5bm/44CC5bm/5rOb55So5LqO5Lq65bel5pm66IO955qE6KGo5aSE55CG6K+t6KiATGlzcO+8jOaKiuW5v+S5ieihqOS9nOS4uuWfuuacrOeahOaVsOaNrue7k+aehOOAglxuICog5bm/5LmJ6KGo5LiA6Iis6K6w5L2c77yaXG4gKiAgICAgIExTID0gKGExLCBhMiwgLi4uLCBhbilcbiAqIExT5piv5bm/5LmJ6KGo55qE5ZCN56ew77yMbuaYr+Wug+eahOmVv+W6pu+8jGFp5Y+v5Lul5piv5Y2V5Liq5YWD57Sg77yM5Lmf5Y+v5Lul5piv5bm/5LmJ6KGo77yM5YiG5Yir56ew5Li65bm/5LmJ6KGoTFPnmoTljp/lrZDlkozlrZDooajjgILkuaDmg6/kuIrvvIznlKjlpKflhpnlrZfmr43ooajnpLrlub/kuYnooajnmoTlkI3np7DvvIzlsI/lhpnlrZfmr43ooajnpLrljp/lrZDjgILlvZPlub/kuYnooahMU+mdnuepuuaXtu+8jOensOesrOS4gOS4quWFg+e0oGEx5Li6TFPnmoTooajlpLTvvIznp7DlhbbkvZnlhYPntKDnu4TmiJDnmoTooagoYTIsIGEzLCAuLi4sIGFuKeaYr0xT55qE6KGo5bC+44CCXG4gKlxuICog5LiL6Z2i5YiX5Li+5LiA5Lqb5bm/5LmJ6KGo55qE5L6L5a2Q77yaXG4gKiAxLkEgPSAoKSAtLS0tIEHmmK/kuIDkuKrnqbrooajvvIzlroPnmoTplb/luqbkuLow44CCXG4gKiAyLkIgPSAoZSkgLS0tLSDliJfooahC5Y+q5pyJ5LiA5Liq5Y6f5a2QZe+8jELnmoTplb/luqbkuLox44CCXG4gKiAzLkMgPSAoYSwgKGIsIGMsIGQpKSAtLS0tIOWIl+ihqEPnmoTplb/luqbkuLoy77yM5Lik5Liq5YWD57Sg5YiG5Yir5Li65Y6f5a2QYeWSjOWtkOihqChiLCBjLCBkKeOAglxuICogNC5EID0gKEEsIEIsIEMpIC0tLS0g5YiX6KGoROeahOmVv+W6puS4ujMsM+S4quWFg+e0oOmDveaYr+WIl+ihqOOAguaYvuekuu+8jOWwhuWtkOihqOeahOWAvOS7o+WFpeWQju+8jOWImeaciUQgPSAoKCksIChlKSwgKGEsIChiLCBjLCBkKSkp44CCXG4gKiA1LkUgPSAoYSwgRSkgLS0tLSDov5nmmK/kuIDkuKrpgJLlvZLnmoTooajvvIzlroPnmoTplb/luqbkuLoyLkXnm7jlvZPkuo7kuIDkuKrml6DpmZDnmoTliJfooahFID0gKGEsIChhLCAoYSwgLi4uKSkp44CCXG4gKlxuICogMe+8ieWIl+ihqOeahOWFg+e0oOWPr+S7peaYr+WtkOihqO+8jOiAjOWtkOihqOeahOWFg+e0oOi/mOWPr+S7peaYr+WtkOihqOOAgueUseatpO+8jOWIl+ihqOaYr+S4gOS4quWkmuWxguasoeeahOe7k+aehO+8jOWPr+S7peeUqOWbvuW9ouixoeWcsOihqOekuuOAglxuICogMinliJfooajlj6/kuLrlhbblroPliJfooajmiYDlhbHkuqvjgILliJfooahB77yMQuWSjEPkuLpE55qE5a2Q6KGo77yM5YiZ5ZyoROS4reWPr+S7peS4jeW/heWIl+WHuuWtkOihqOeahOWAvOOAglxuICogM++8ieWIl+ihqOWPr+S7peaYr+S4gOS4qumAkuW9kueahOihqO+8jOWNs+WIl+ihqOS5n+WPr+S7peaYr+WFtuacrOi6q+eahOS4gOS4quWtkOihqOOAguS+i+WmguWIl+ihqEXjgIJcbiAqXG4gKiDku7vkvZXkuIDkuKrpnZ7nqbrliJfooajlhbbooajlpLTlj6/og73mmK/ljp/lrZDvvIzkuZ/lj6/og73mmK/liJfooajvvIzogIzlhbbooajlsL7lv4XlrprkuLrliJfooajjgIJcbiAqXG4gKi9cblxuLypcbiDlub/kuYnooajnmoTpgJLlvZLnrpfms5VcblxuIOmAkuW9kuWumuS5ieeahOW9kue6s+mhueaPj+i/sOS6huWmguS9leWunueOsOS7juW9k+WJjeeKtuaAgeWIsOe7iOe7k+eKtuaAgeeahOi9rOWMluOAglxuXG4g55Sx5LqO6YCS5b2S5Ye95pWw55qE6K6+6K6h55So55qE5piv5b2S57qz5oCd57u055qE5pa55rOV77yM5YiZ5Zyo6K6+6K6h6YCS5b2S5Ye95pWw5pe277yM5bqU5rOo5oSP77yaXG4g77yIMe+8iemmluWFiOW6lOS5puWGmeWHveaVsOeahOmmlumDqOWSjOinhOagvOivtOaYju+8jOS4peagvOWumuS5ieWHveaVsOeahOWKn+iDveWSjOaOpeWPo++8iOmAkuW9kuiwg+eUqOeahOeVjOmdou+8ie+8jOWvueaxgueyvuWHveaVsOS4reaJgOW+l+eahOWSjOWOn+mXrumimOaAp+i0qOebuOWQjOeahOWtl+mXrumimO+8jOWPquimgeaOpeWPo+S4gOiHtO+8jOS+v+WPr+i/m+ihjOmAkuW9kuiwg+eUqOOAglxuIO+8iDLvvInlr7nlh73mlbDkuK3nmoTmr4/kuIDkuKrpgJLlvZLosIPnlKjpg73nnIvmiJDlj6rmmK/kuIDkuKrnroDljZXnmoTmk43kvZzvvIzlj6ropoHmjqXlj6PkuIDoh7TvvIzlv4Xog73lrp7njrDop4TmoLzor7TmmI7kuK3lrprkuYnnmoTlip/og73vvIzliIflv4zmg7PlvpflpKrmt7HlpKrov5zjgIJcbiAqL1xuXG4vKlxuIOaxguW5v+S5ieihqOeahOa3seW6plxuXG4g5bm/5LmJ6KGo55qE5rex5bqm5a6a5LmJ5Li65bm/5LmJ6KGo5Lit5ous5byn55qE6YeN5pWw77yM5piv5bm/5LmJ6KGo55qE5LiA56eN6YeP5bqm44CCXG4g6K6+6Z2e56m65bm/5LmJ6KGo5Li6OlxuIExTID0gKGExLCBhMiwgLi4uLCBhbilcblxuIOWFtuS4rWFpKGkgPSAxLCAyLCAuLi4sIG4p5oiW5Li65Y6f5a2Q5oiW5Li6TFPnmoTlrZDooajvvIzliJnmsYJMU+eahOa3seW6puWPr+WIhuino+S4um7kuKrlrZDpl67popjvvIzmr4/kuKrlrZDpl67popjkuLrmsYJhaeeahOa3seW6pu+8jOiLpWFp5piv5Y6f5a2Q77yM5YiZ55Sx5a6a5LmJ5YW25rex5bqm5Li66Zu277yM6IulYWnmmK/lub/kuYnooajvvIzliJnpgJLlvZLlpITnkIbvvIzogIxMU+eahOa3seW6puS4uuWQhGFpKGkgPSAxLCAyLCAuLi4sIG4p55qE5rex5bqm5pyA5aSn5YC85YqgMS7nqbrooajkuZ/mmK/lub/kuYnooajvvIzkuJTmt7HluqbkuLoxLlxuXG4g5bm/5LmJ6KGo55qE5rex5bqmREVQVEgoTFMp55qE6YCS5b2S5a6a5LmJ5Li677yaXG4g5Z+65pys6aG577yaICAgIERFUFRIKExTKSA9IDEgICDlvZNMU+S4uuepuuihqOaXtlxuIERFUFRIKExTKSA9IDAgICDlvZNMU+S4uuWOn+WtkOaXtlxuIOW9kue6s+mhue+8miAgICBERVBUSChMUykgPSAxICsgTUFYe0RFUFRIKGFpKX0gIDEgPD0gaSA8PSBuXG4gKi9cblxuY29uc3QgQVRPTSA9IFN5bWJvbCgpO1xuY29uc3QgTElTVCA9IFN5bWJvbCgpO1xuXG5sZXQgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8vIOS9v+eUqOmTvumYn+WIl1xuaW1wb3J0IFF1ZXVlIGZyb20gJy4uL1F1ZXVlL1F1ZXVlLmpzJztcblxuLy8g5bm/5LmJ6KGo55qE5aS05bC+6ZO+6KGo5a2Y5YKo6KGo56S6XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHTE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIC8vIOWFrOWFsemDqOWIhu+8jOeUqOS6juWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBhdG9t5piv5Y6f5a2Q57uT54K555qE5YC85Z+fXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XG4gICAgICAgIC8vIHB0cuaYr+ihqOe7k+eCueeahOaMh+mSiOWfn1xuICAgICAgICB0aGlzLnB0ciA9IHtcbiAgICAgICAgICAgIC8vIHB0ci5ocOWSjHB0ci50cOWIhuWIq+aMh+WQkeihqOWktOWSjOihqOWwvlxuICAgICAgICAgICAgaHA6IG51bGwsXG4gICAgICAgICAgICB0cDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIOmHh+eUqOWktOWwvumTvuihqOWtmOWCqOe7k+aehO+8jOaxguW5v+S5ieihqOeahOa3seW6plxuICAgIGRlcHRoICgpe1xuICAgICAgICByZXR1cm4gZ2V0RGVwdGgodGhpcyk7XG4gICAgfVxuXG4gICAgLy8g5aSN5Yi25bm/5LmJ6KGoXG4gICAgY29weUxpc3QgKGdMaXN0KSB7XG4gICAgICAgIGdMaXN0LnRhZyA9IHRoaXMudGFnO1xuXG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gQVRPTSkge1xuICAgICAgICAgICAgZ0xpc3QuYXRvbSA9IHRoaXMuYXRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ci5ocCkge1xuICAgICAgICAgICAgICAgIGdMaXN0LnB0ci5ocCA9IG5ldyBHTE5vZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB0ci5ocC5jb3B5TGlzdChnTGlzdC5wdHIuaHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHRyLnRwKSB7XG4gICAgICAgICAgICAgICAgZ0xpc3QucHRyLnRwID0gbmV3IEdMTm9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHRyLnRwLmNvcHlMaXN0KGdMaXN0LnB0ci50cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDph4fnlKjlpLTlsL7pk77ooajlrZjlgqjnu5PmnoTvvIznlLHlub/kuYnooajnmoTkuablhpnlvaLlvI/kuLLliJvlu7rlub/kuYnooahcbiAgICBjcmVhdGVHTGlzdCAoc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG5cbiAgICAgICAgLy8g5Yib5bu65Y2V5Y6f5a2Q5bm/5LmJ6KGoXG4gICAgICAgIGxldCBxO1xuICAgICAgICBpZiAoaXNXb3JkKHN0cmluZykpIHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gQVRPTTtcbiAgICAgICAgICAgIHRoaXMuYXRvbSA9IHN0cmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gTElTVDtcbiAgICAgICAgICAgIGxldCBwID0gdGhpcztcblxuICAgICAgICAgICAgLy8g6ISx5aSW5bGC5ous5Y+3XG4gICAgICAgICAgICBsZXQgc3ViID0gc3RyaW5nLnN1YnN0cigxLCBzdHJpbmcubGVuZ3RoIC0gMik7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgaHN1YjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IHN1Yi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY2g7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3ViW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSAnKCcpICsraztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gJyknKSAtLWs7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA8IG4gJiYgKGNoICE9ICcsJyB8fCBrICE9IDApKTtcblxuICAgICAgICAgICAgICAgIC8vIGnkuLrnrKzkuIDkuKrpgJflj7fliIbpmpTntKLlvJVcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaHN1YiA9IHN1Yi5zdWJzdHIoMCwgaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWIuc3Vic3RyKGksIG4gLSBpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyDmnIDlkI7kuIDnu4RcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoc3ViID0gc3ViO1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihoc3ViID09PSAnKCknKSBwLnB0ci5ocCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8g5Yib5bu66KGo5aS057uT54K5XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHRyLmhwID0gbmV3IEdMTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBwLnB0ci5ocC5jcmVhdGVHTGlzdChoc3ViKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBxID0gcDtcblxuICAgICAgICAgICAgICAgIC8vIOWIm+W7uuihqOWwvue7k+eCuVxuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBHTE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcC50YWcgPSBMSVNUO1xuICAgICAgICAgICAgICAgICAgICBxLnB0ci50cCA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoc3ViKTtcblxuICAgICAgICAgICAgcS5wdHIudHAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsKGdMaXN0MSwgZ0xpc3QyKSB7XG4gICAgICAgIC8vIOepuuihqOaXtuebuOetieeahFxuICAgICAgICBpZiAoIWdMaXN0MSAmJiAhZ0xpc3QyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGdMaXN0MS50YWcgPT09IEFUT00gJiYgZ0xpc3QyLnRhZyA9PT0gQVRPTSAmJiBnTGlzdDEuYXRvbSA9PT0gZ0xpc3QyLmF0b20pIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmIChnTGlzdDEudGFnID09PSBMSVNUICYmIGdMaXN0Mi50YWcgPT09IExJU1QpIHtcbiAgICAgICAgICAgIC8vIOihqOWktOihqOWwvumDveebuOetiVxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwoZ0xpc3QxLnB0ci5ocCwgZ0xpc3QyLnB0ci5ocCkgJiYgdGhpcy5lcXVhbChnTGlzdDEucHRyLnRwLCBnTGlzdDIucHRyLnRwKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8g6YCS5b2S6YCG6L2s5bm/5LmJ6KGoXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgbGV0IHB0ciA9IFtdO1xuICAgICAgICAvLyDlvZNB5LiN5Li65Y6f5a2Q5LiU6KGo5bC+6Z2e56m65pe25omN6ZyA6YCG6L2sXG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gTElTVCAmJiB0aGlzLnB0ci50cCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCwgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8g6YCG6L2s5ZCE5a2Q6KGoXG4gICAgICAgICAgICAgICAgaWYgKHAucHRyLmhwKSBwLnB0ci5ocC5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgICAgICBwdHJbaV0gPSBwLnB0ci5ocDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g6YeN5paw5oyJ6YCG5bqP5o6S5YiX5ZCE5a2Q6KGo55qE6aG65bqPXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKVxuICAgICAgICAgICAgICAgIHAucHRyLmhwID0gcHRyWy0taV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgaWYgKHRoaXMgPT0gZ2xvYmFsIHx8IHRoaXMgPT0gbnVsbCkgc3RyID0gJygpJztcbiAgICAgICAgZWxzZSBpZiAodGhpcy50YWcgPT09IEFUT00pIHN0ciA9IHRoaXMuYXRvbTsgIC8vIOWOn+WtkFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSAnKCc7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy50b1N0cmluZy5jYWxsKHAucHRyLmhwKTtcbiAgICAgICAgICAgICAgICBpZiAocC5wdHIudHApIHN0ciArPSAnLCAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyICs9ICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLy8g5oyJ5bGC5bqP6L6T5Ye65bm/5LmJ6KGoXG4gICAgLy8g5bGC5bqP6YGN5Y6G55qE6Zeu6aKY77yM5LiA6Iis6YO95piv5YCf5Yqp6Zif5YiX5p2l5a6M5oiQ55qE77yM5q+P5qyh5LuO6Zif5aS0XG4gICAgLy8g5Y+W5Ye65LiA5Liq5YWD57Sg55qE5ZCM5pe25oqK5a6D5LiL5LiA5bGC55qE5a2p5a2Q5o+S5YWl6Zif5bC+77yM6L+Z5piv5bGC5bqP6YGN5Y6G55qE5Z+65pys5oCd5oOzXG4gICAgb3JkZXJQcmludCAoKXtcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG5cbiAgICAgICAgZm9yKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKSBxdWV1ZS5lblF1ZXVlKHApO1xuXG4gICAgICAgIHdoaWxlKHF1ZXVlLnNpemUpe1xuICAgICAgICAgICAgbGV0IHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICBpZihyLnRhZyA9PT0gQVRPTSkgY29uc29sZS5sb2coci5hdG9tKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcihyID0gci5wdHIuaHA7IHI7IHIgPSByLnB0ci50cClcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8g5bm/5LmJ6KGo55qE5omp5bGV57q/5oCn6ZO+6KGo5a2Y5YKo6KGo56S6XG5jbGFzcyBHTE5vZGUyIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAvLyDlhazlhbHpg6jliIbvvIznlKjkuo7ljLrliIbljp/lrZDnu5Pngrnlkozooajnu5PngrlcbiAgICAgICAgdGhpcy50YWcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8g5Y6f5a2Q57uT54K555qE5YC85Z+fXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XG4gICAgICAgIC8vIOihqOe7k+eCueeahOihqOWktOaMh+mSiFxuICAgICAgICB0aGlzLmhwID0gbnVsbDtcblxuICAgICAgICAvLyDnm7jlvZPkuo7nur/mgKfpk77ooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XG4gICAgICAgIHRoaXMudHAgPSBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVwdGgoZ0xpc3QpIHtcbiAgICBpZiAoIWdMaXN0KSByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChnTGlzdC50YWcgPT09IEFUT00pIHJldHVybiAwO1xuXG4gICAgbGV0IG0gPSBnZXREZXB0aChnTGlzdC5wdHIuaHApICsgMTtcbiAgICBsZXQgbiA9IGdldERlcHRoKGdMaXN0LnB0ci50cCk7XG5cbiAgICByZXR1cm4gbSA+IG4gPyBtIDogbjtcbn1cblxuZnVuY3Rpb24gaXNXb3JkKHN0cil7XG4gICAgcmV0dXJuIC9eW1xcdy1dKyQvLnRlc3Qoc3RyKTtcbn1cblxuXG4vKlxuIG3lhYPlpJrpobnlvI/ooajnpLpcblxuIOWmguaenOeUqOe6v+aAp+ihqOadpeihqOekuizliJnmr4/kuKrmlbDmja7lhYPntKDpnIDopoFtKzHkuKrmlbDmja7pobnvvIzku6XlrZjlgqjkuIDkuKrns7vmlbDlkoxt5Liq5oyH5pWw5YC877yM6L+Z5bCG5Lqn55Sf5Lik5Liq6Zeu6aKY44CCXG4g5LiA5piv5peg6K665aSa6aG55byP5Lit5ZCE6aG555qE5Y+Y5YWD5pWw5piv5aSa5piv5bCR77yM6Iul6YO95oyJbeS4quWPmOWFg+WIhumFjeWtmOWCqOepuumXtO+8jOWImeWwhumAoOaIkOa1qui0ue+8m+WPjeS5i++8jOiLpeaMieWQhOmhueWunumZheeahOWPmOWFg+aVsOWIhumFjeWtmOWCqOepuumXtO+8jOWwseS8mumAoOaIkOe7k+eCueeahOWkp+Wwj+S4jeWMgO+8jOe7meaTjeS9nOW4puadpeS4jeS+v+OAguS6jOaYr+WvuW3lgLzkuI3lkIznmoTlpJrpobnlvI/vvIznur/mgKfooajkuK3nmoTnu5PngrnlpKflsI/kuZ/kuI3lkIzvvIzov5nlkIzmoLflvJXotbflrZjlgqjnrqHnkIbnmoTkuI3kvr/jgIJcbiDmlYXkuI3pgILkuo7nlKjnur/mgKfooajooajnpLrjgIJcblxuIOS+i+WmguS4ieWFg+WkmumhueW8j++8mlxuIFAoeCwgeSwgeikgPSB4KDEwKXkoMyl6KDIpICsgMngoNil5KDMpeigyKSArIDN4KDUpeSgyKXooMikgKyB4KDQpeSg0KXogKyAyeXogKyAxNVxuXG4g5aaC6Iul5pS55YaZ5Li677yaXG4gUCh4LCB5LCB6KSA9ICgoeCgxMCkgKyAyeCg2KSl5KDMpICsgM3goNSl5KDIpKXooMikgKyAoKHgoNCkgKyA2eCgzKSl5KDQpICsgMnkpeiArIDE1XG5cbiDnlKjlub/kuYnooajooajnpLrvvJpcbiBQID0geigoQSwgMiksIChCLCAxKSwgKDE1LCAwKSlcbiBBID0geSgoQywgMyksIChELCAyKSlcbiBCID0geSgoRSwgNCksIChGLCAxKSlcbiBDID0geCgoMSwgMTApLCAoMiwgNikpXG4gRCA9IHgoKDMsIDUpKVxuIEUgPSB4KCgxLCA0KSwgKDYsIDMpKVxuIEYgPSB4KCgyLCAwKSlcblxuXG4gKi9cblxuZnVuY3Rpb24gTVBOb2RlKCkge1xuICAgIC8vIOWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xuICAgIC8vIOaMh+aVsOWfn1xuICAgIHRoaXMuZXhwID0gMDtcblxuICAgIC8vIOezu+aVsOWfn1xuICAgIHRoaXMuY29lZiA9IDA7XG4gICAgLy8g6KGo57uT54K555qE6KGo5aS05oyH6ZKIXG4gICAgdGhpcy5ocCA9IG51bGw7XG5cbiAgICAvLyDnm7jlvZPkuo7nur/mgKfooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XG4gICAgdGhpcy50cCA9IG51bGw7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dlbmVyYWxpemVkTGlzdC9HTGlzdC5qcyIsIi8qXG4g6YK75o6l5aSa6YeN6KGoXG5cbiDpgrvmjqXlpJrph43ooagoQWRqYWNlbmN5IE11bHRpbGlzdCnmmK/ml6DlkJHlm77nmoTlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoTjgIJcblxuIOmCu+aOpeihqOaYr+aXoOWQkeWbvueahOS4gOenjeacieaViOeahOWtmOWCqOe7k+aehO+8jOWcqOaXoOWQkeWbvueahOmCu+aOpeihqOS4re+8jOS4gOadoei+uSh2LHcp55qE5Lik5Liq6KGo57uT54K55YiG5Yir5Yid6YCJ5Zyo5LulduWSjHfkuLrlpLTnu5PngrnnmoTpk77ooajkuK3vvIzlvojlrrnmmJPmsYLlvpfpobbngrnlkozovrnnmoTkv6Hmga/vvIzkvYblnKjmtonlj4rliLDovrnnmoTmk43kvZzkvJrluKbmnaXkuI3kvr/jgIJcblxuIOmCu+aOpeWkmumHjeihqOeahOe7k+aehOWSjOWNgeWtl+mTvuihqOexu+S8vO+8jOavj+adoei+ueeUqOS4gOS4que7k+eCueihqOekuu+8m+mCu+aOpeWkmumHjeihqOS4reeahOmhtueCuee7k+eCuee7k+aehOS4jumCu+aOpeihqOS4reeahOWujOWFqOebuOWQjO+8jOiAjOihqOe7k+eCueWMheaLrOWFreS4quWfn+OAglxuXG4g4peGICBEYXRh5Z+f77ya5a2Y5YKo5ZKM6aG254K555u45YWz55qE5L+h5oGv77ybXG4g4peGIOaMh+mSiOWfn2ZpcnN0ZWRnZe+8muaMh+WQkeS+nemZhOS6juivpemhtueCueeahOesrOS4gOadoei+ueaJgOWvueW6lOeahOihqOe7k+eCue+8m1xuIOKXhiDmoIflv5fln59tYXJr77ya55So5Lul5qCH6K+G6K+l5p2h6L655piv5ZCm6KKr6K6/6Zeu6L+H77ybXG4g4peGIGl2ZXjlkoxqdmV45Z+f77ya5YiG5Yir5L+d5a2Y6K+l6L655omA5L6d6ZmE55qE5Lik5Liq6aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXG4g4peGIGluZm/ln5/vvJrkv53lrZjor6XovrnnmoTnm7jlhbPkv6Hmga/vvJtcbiDil4Yg5oyH6ZKI5Z+faWxpbmvvvJrmjIflkJHkuIvkuIDmnaHkvp3pmYTkuo7pobbngrlpdmV455qE6L6577ybXG4g4peGIOaMh+mSiOWfn2psaW5r77ya5oyH5ZCR5LiL5LiA5p2h5L6d6ZmE5LqO6aG254K5anZleOeahOi+ue+8m1xuXG4g6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo55qE5Yy65Yir77yaXG4g5ZCO6ICF55qE5ZCM5LiA5p2h6L6555So5Lik5Liq6KGo57uT54K56KGo56S677yM6ICM5YmN6ICF5Y+q55So5LiA5Liq6KGo57uT54K56KGo56S677yb6Zmk5qCH5b+X5Z+f5aSW77yM6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo6KGo6L6+55qE5L+h5oGv5piv55u45ZCM55qE77yM5Zug5q2k77yM5pON5L2c55qE5a6e546w5Lmf5Z+65pys55u45Ly844CCXG5cbiAqL1xuXG5jb25zdCBVTlZJU0lURUQgPSAwO1xuY29uc3QgVklTSVRFRCA9IDE7XG5cblxuY2xhc3MgRUJveCB7XG4gICAgLyoqXG4gICAgICog6L6555qE57uT54K56KGo56S6XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1hcmsg6K6/6Zeu5qCH6K6wIDAgLS0g5pyq6K6/6ZeuICAxID09IOW3suiuv+mXrlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBqdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxuICAgICAqIEBwYXJhbSB7RUJveH0gaWxpbmsg5YiG5Yir5oyH5ZCR5L6d6ZmE6L+Z5Lik5Liq6aG254K555qE5LiL5LiA5p2h6L65XG4gICAgICogQHBhcmFtIHtFQm94fSBqbGluayDliIbliKvmjIflkJHkvp3pmYTov5nkuKTkuKrpobbngrnnmoTkuIvkuIDmnaHovrlcbiAgICAgKiBAcGFyYW0geyp9IGluZm8g6K+l6L655L+h5oGvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFyaywgaXZleCwganZleCwgaWxpbmssIGpsaW5rLCBpbmZvKXtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyayB8fCBVTlZJU0lURUQ7XG4gICAgICAgIHRoaXMuaXZleCA9IGl2ZXggfHwgMDtcbiAgICAgICAgdGhpcy5qdmV4ID0ganZleCB8fCAwO1xuICAgICAgICB0aGlzLmlsaW5rID0gaWxpbmsgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5qbGluayA9IGpsaW5rIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcbiAgICB9XG59XG5cbmNsYXNzIEFNTFZleEJveCB7XG4gICAgLyoqXG4gICAgICog6aG254K555qE57uT54K56KGo56S6XG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtFQm94fSBmaXJzdEVkZ2Ug5oyH5ZCR56ys5LiA5p2h5L6d6ZmE6K+l6aG254K555qE6L65XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZmlyc3RFZGdlKXtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBudWxsO1xuICAgICAgICB0aGlzLmZpcnN0RWRnZSA9IGZpcnN0RWRnZSB8fCBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQU1MR3JhcGgge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IEFNTFZleEJveH0gYWRqTXVsaXN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlbnVtXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRqTXVsaXN0LCB2ZXhudW0sIGVkZ2VudW0pe1xuICAgICAgICB0aGlzLmFkak11bGlzdCA9IGFkak11bGlzdCB8fCBbXTtcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW0gfHwgMDtcbiAgICAgICAgdGhpcy5lZGdlbnVtID0gZWRnZW51bSB8fCAwO1xuICAgIH1cblxuICAgIGxvY2F0ZVZleCAodikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkak11bGlzdFtpXS5kYXRhID09PSB2KSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZGVsZXRlQXJjKHYsIHcpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcbiAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleCh3KTtcblxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHRocm93IG5ldyBFcnJvcignVmVydGV4IG5vdCBmb3VuZCEnKTtcblxuICAgICAgICB2YXIgcDtcbiAgICAgICAgLy8g5ZyoaemTvuihqOS4reWIoOmZpOivpei+uVxuICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlLmp2ZXggPT09IGopIHtcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZS5pbGluaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZTsgcCAmJiBwLmlsaW5rLmp2ZXggIT09IGo7IHAgPSBwLmlsaW5rKTtcbiAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgIHAuaWxpbmsgPSBwLmlsaW5rLmlsaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5ZyoaumTvuihqOS4reWIoOmZpOivpei+uVxuICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlLml2ZXggPT09IGkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZS5qbGluaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZTsgcCAmJiBwLmpsaW5rLml2ZXggIT09IGk7IHAgPSBwLmpsaW5rKTtcbiAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgIHAuamxpbmsgPSBwLmpsaW5rLmpsaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lZGdlbnVtLS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNyZWF0ZUdyYXBoKCkge1xuICAgICAgICB2YXIgdmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW07XG4gICAgICAgIHZhciBlZGdlbnVtID0gK3Byb21wdCgnZWRnZW51bTogJyk7XG4gICAgICAgIHRoaXMuZWRnZW51bSA9IGVkZ2VudW07XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB2ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3RbbV0gPSBuZXcgQU1MVmV4Qm94KHByb21wdCgnZGF0YTogJyksIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChtID0gMDsgbSA8IGVkZ2VudW07ICsrbSkge1xuICAgICAgICAgICAgdmFyIHQgPSBwcm9tcHQoJ3RhaWxWZXg6ICcpO1xuICAgICAgICAgICAgdmFyIGggPSBwcm9tcHQoJ2hlYWRWZXg6ICcpO1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh0KTtcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgoaCk7XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3ZlcnRleCBub3QgZm91bmQhIFRyeSBhZ2FpbjonKTtcbiAgICAgICAgICAgICAgICBtLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwID0gbmV3IEVCb3goMCwgaSwgaiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgcSwgcjtcblxuICAgICAgICAgICAgLy8g5o+S5YWlaemTvuihqOWwvumDqFxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UgPSBwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5pdmV4ID09PSBpKSBxID0gcS5pbGluaztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxID0gcS5qbGluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuaXZleCA9PT0gaSkgci5pbGluayA9IHA7XG4gICAgICAgICAgICAgICAgZWxzZSByLmpsaW5rID0gcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5o+S5YWlaumTvuihqOWwvumDqFxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UgPSBwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5qdmV4ID09PSBqKSBxID0gcS5qbGluaztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxID0gcS5pbGluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuanZleCA9PT0gaikgci5qbGluayA9IHA7XG4gICAgICAgICAgICAgICAgZWxzZSByLmlsaW5rID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy92YXIgZyA9IG5ldyBBTUxHcmFwaCgpO1xuLy9nLmNyZWF0ZUdyYXBoKCk7XG4vL2NvbnNvbGUubG9nKGcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dyYXBoL0FNTEdyYXBoLmpzIiwiLyogQ3JlYXRlIEJ5IEx1a2UgKi9cblxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XG5pbXBvcnQgeyBDaGlsZFNpYmxpbmdUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcblxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XG5jb25zdCBERyA9IDE7ICAgICAvLyDmnInlkJHlm75cbmNvbnN0IEROID0gMjsgICAgIC8vIOacieWQkee9kVxuY29uc3QgVURHID0gMzsgICAgLy8g5peg5ZCR5Zu+XG5jb25zdCBVRE4gPSA0OyAgICAvLyDml6DlkJHnvZFcblxuXG4vKlxuIOmCu+aOpemTvuihqOazlVxuXG4g5Z+65pys5oCd5oOz77ya5a+55Zu+55qE5q+P5Liq6aG254K55bu656uL5LiA5Liq5Y2V6ZO+6KGo77yM5a2Y5YKo6K+l6aG254K55omA5pyJ6YK75o6l6aG254K55Y+K5YW255u45YWz5L+h5oGv44CC5q+P5LiA5Liq5Y2V6ZO+6KGo6K6+5LiA5Liq6KGo5aS057uT54K544CCXG5cbiDnrKxp5Liq5Y2V6ZO+6KGo6KGo56S65L6d6ZmE5LqO6aG254K5VmnnmoTovrko5a+55pyJ5ZCR5Zu+5piv5Lul6aG254K5VmnkuLrlpLTmiJblsL7nmoTlvKcp44CCXG5cbiAxICDnu5Pngrnnu5PmnoTkuI7pgrvmjqXpk77ooajnpLrkvotcblxuIOmTvuihqOS4reeahOe7k+eCueensOS4uuihqOe7k+eCue+8jOavj+S4que7k+eCueeUseS4ieS4quWfn+e7hOaIkOOAguWFtuS4remCu+aOpeeCueWfnyhhZGp2ZXgp5oyH56S65LiO6aG254K5VmnpgrvmjqXnmoTpobbngrnlnKjlm77kuK3nmoTkvY3nva4o6aG254K557yW5Y+3Ke+8jOmTvuWfnyhuZXh0YXJjKeaMh+WQkeS4i+S4gOS4quS4jumhtueCuVZp6YK75o6l55qE6KGo57uT54K577yM5pWw5o2u5Z+fKGluZm8p5a2Y5YKo5ZKM6L655oiW5byn55u45YWz55qE5L+h5oGv77yM5aaC5p2D5YC8562J44CC5a+55LqO5peg5p2D5Zu+77yM5aaC5p6c5rKh5pyJ5LiO6L6555u45YWz55qE5YW25LuW5L+h5oGv77yM5Y+v55yB55Wl5q2k5Z+f44CCXG5cbiDmr4/kuKrpk77ooajorr7kuIDkuKrooajlpLTnu5Pngrko56ew5Li66aG254K557uT54K5Ke+8jOeUseS4pOS4quWfn+e7hOaIkOOAgumTvuWfnyhmaXJzdGFyYynmjIflkJHpk77ooajkuK3nmoTnrKzkuIDkuKrnu5PngrnvvIzmlbDmja7ln58oZGF0YSkg5a2Y5YKo6aG254K55ZCN5oiW5YW25LuW5L+h5oGv44CCXG5cbiDlnKjlm77nmoTpgrvmjqXpk77ooajooajnpLrkuK3vvIzmiYDmnInpobbngrnnu5PngrnnlKjkuIDkuKrlkJHph48g5Lul6aG65bqP57uT5p6E5b2i5byP5a2Y5YKo77yM5Y+v5Lul6ZqP5py66K6/6Zeu5Lu75oSP6aG254K555qE6ZO+6KGo77yM6K+l5ZCR6YeP56ew5Li66KGo5aS05ZCR6YeP77yM5ZCR6YeP55qE5LiL5qCH5oyH56S66aG254K555qE5bqP5Y+344CCXG5cbiDnlKjpgrvmjqXpk77ooajlrZjlgqjlm77ml7bvvIzlr7nml6DlkJHlm77vvIzlhbbpgrvmjqXpk77ooajmmK/llK/kuIDnmoTvvJvlr7nmnInlkJHlm77vvIzlhbbpgrvmjqXpk77ooajmnInkuKTnp43lvaLlvI/jgIJcblxuXG4gMiAg6YK75o6l6KGo5rOV55qE54m554K5XG5cbiDil4Yg6KGo5aS05ZCR6YeP5Lit5q+P5Liq5YiG6YeP5bCx5piv5LiA5Liq5Y2V6ZO+6KGo55qE5aS057uT54K577yM5YiG6YeP5Liq5pWw5bCx5piv5Zu+5Lit55qE6aG254K55pWw55uu77ybXG4g4peGIOWcqOi+ueaIluW8p+eogOeWj+eahOadoeS7tuS4i++8jOeUqOmCu+aOpeihqOihqOekuuavlOeUqOmCu+aOpeefqemYteihqOekuuiKguecgeWtmOWCqOepuumXtO+8m1xuIOKXhiDlnKjml6DlkJHlm77vvIzpobbngrlWaeeahOW6puaYr+esrGnkuKrpk77ooajnmoTnu5PngrnmlbDvvJtcbiDil4Yg5a+55pyJ5ZCR5Zu+5Y+v5Lul5bu656uL5q2j6YK75o6l6KGo5oiW6YCG6YK75o6l6KGo44CC5q2j6YK75o6l6KGo5piv5Lul6aG254K5VmnkuLrlh7rluqYo5Y2z5Li65byn55qE6LW354K5KeiAjOW7uueri+eahOmCu+aOpeihqO+8m+mAhumCu+aOpeihqOaYr+S7pemhtueCuVZp5Li65YWl5bqmKOWNs+S4uuW8p+eahOe7iOeCuSnogIzlu7rnq4vnmoTpgrvmjqXooajvvJtcbiDil4Yg5Zyo5pyJ5ZCR5Zu+5Lit77yM56ysaeS4qumTvuihqOS4reeahOe7k+eCueaVsOaYr+mhtueCuVZp55qE5Ye6ICjmiJblhaUp5bqm77yb5rGC5YWlICjmiJblh7op5bqm77yM6aG76YGN5Y6G5pW05Liq6YK75o6l6KGo77ybXG4g4peGIOWcqOmCu+aOpeihqOS4iuWuueaYk+aJvuWHuuS7u+S4gOmhtueCueeahOesrOS4gOS4qumCu+aOpeeCueWSjOS4i+S4gOS4qumCu+aOpeeCue+8m1xuXG4gKi9cblxuXG5jbGFzcyBBcmNOb2RlIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhZGpWZXhcbiAgICAgKiBAcGFyYW0ge0FyY05vZGV9IG5leHRBcmNcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGpWZXggPSAwLCBuZXh0QXJjID0gbnVsbCwgaW5mbyA9IG51bGwpe1xuICAgICAgICAvLyDor6XlvKfmiYDmjIflkJHnmoTpobbngrnnmoTkvY3nva5cbiAgICAgICAgdGhpcy5hZGpWZXggPSBhZGpWZXg7XG4gICAgICAgIC8vIOaMh+WQkeS4i+S4gOadoeW8p+eahOaMh+mSiFxuICAgICAgICB0aGlzLm5leHRBcmMgPSBuZXh0QXJjO1xuICAgICAgICAvLyDor6XlvKfnm7jlhbPkv6Hmga/nmoTmjIfpkohcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG59XG5cbmNsYXNzIFZleE5vZGUge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtBcmNOb2RlfSBmaXJzdEFyY1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlZ3JlZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGZpcnN0QXJjID0gbnVsbCwgaW5kZWdyZWUgPSAwKXtcbiAgICAgICAgLy8g6aG254K55L+h5oGvXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIC8vIOaMh+WQkeesrOS4gOadoeS+nemZhOivpemhtueCueeahOW8p+eahOaMh+mSiFxuICAgICAgICB0aGlzLmZpcnN0QXJjID0gZmlyc3RBcmM7XG4gICAgICAgIC8vICDpobbngrnnmoTluqYsIOacieWQkeWbvuaYr+WFpeW6puaIluWHuuW6puaIluayoeaciVxuICAgICAgICB0aGlzLmluZGVncmVlID0gaW5kZWdyZWU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGphY2VuY3lMaXN0R3JhcGgge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IFZleE5vZGV9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2luZFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzID0gW10sIHZleG51bSA9IDAsIGFyY251bSA9IDAsIGtpbmQgPSBERyl7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWw5ZKM5byn5pWwXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xuICAgICAgICB0aGlzLmFyY251bSA9IGFyY251bTtcbiAgICAgICAgLy8g5Zu+55qE56eN57G75qCH5b+XXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuXG4gICAgLy8g5p+l5om+6aG254K55L2N572uXG4gICAgbG9jYXRlVmV4KHZwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uZGF0YSA9PT0gdnApIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIOa3u+WKoOmhtueCuVxuICAgIGFkZFZlcnRleCh2cCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhdGVWZXgodnApICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggaGFzIGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZleG51bSsrXSA9IG5ldyBWZXhOb2RlKHZwLCBudWxsLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmV4bnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOW8p1xuICAgICAqIOWmguaenOaYr+aXoOWQkeWbvuaIluiAheaXoOWQkee9kSxhcmMx5ZKMYXJjMuaXoOmhuuW6j+imgeaxglxuICAgICAqIOWmguaenOaYr+acieWQkeWbvuaIluiAheacieWQkee9ke+8jOWPquS8mua3u+WKoGFyYzHvvIzlm6DmraTmraPpgrvmjqXooajlkozpgIbpgrvmjqXooajnmoTpobrluo/pnIDopoHms6jmhI9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJjMVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmMyXG4gICAgICogQHBhcmFtIHsqfSBpbmZvXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWRkQXJjKGFyYzEsIGFyYzIsIGluZm8pIHtcbiAgICAgICAgbGV0IGsgPSB0aGlzLmxvY2F0ZVZleChhcmMxKTtcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleChhcmMyKTtcblxuICAgICAgICBpZiAoayA9PT0gLTEgfHwgaiA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgLy8g6L6555qE6LW35aeL6KGo57uT54K56LWL5YC8XG4gICAgICAgIGxldCBwID0gbmV3IEFyY05vZGUoaywgbnVsbCwgaW5mbyk7XG4gICAgICAgIC8vIOi+ueeahOacq+WwvuihqOe7k+eCuei1i+WAvFxuICAgICAgICBsZXQgcSA9IG5ldyBBcmNOb2RlKGosIG51bGwsIGluZm8pO1xuXG4gICAgICAgIC8vIOaYr+aXoOWQkeWbvu+8jOeUqOWktOaPkuWFpeazleaPkuWFpeWIsOS4pOS4quWNlemTvuihqFxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcbiAgICAgICAgICAgIHEubmV4dEFyYyA9IHRoaXMudmVydGljZXNba10uZmlyc3RBcmM7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2tdLmZpcnN0QXJjID0gcTtcbiAgICAgICAgICAgIHAubmV4dEFyYyA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjID0gcDtcbiAgICAgICAgfVxuICAgICAgICAvLyDlu7rnq4vmnInlkJHlm77nmoTpgrvmjqXpk77ooajvvIznlKjlpLTmj5LlhaXms5VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjO1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYyA9IHA7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuYXJjbnVtO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRPRE8g5YW25LuW5Zu+57G75Z6L55qE5Yib5bu65pqC5pe25rKh5byEXG4gICAgY3JlYXRlR3JhcGgoKSB7XG4gICAgICAgIHRoaXMudmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcbiAgICAgICAgdGhpcy5hcmNudW0gPSArcHJvbXB0KCdhcmNudW06ICcpO1xuICAgICAgICAvLyBpbmNJbmZv5Li6MOWImeWQhOW8p+S4jeWQq+WFtuS7luS/oeaBr1xuICAgICAgICBsZXQgaW5jSW5mbyA9ICtwcm9tcHQoJ2luY0luZm86ICcpO1xuXG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttXSA9IG5ldyBWZXhOb2RlKCk7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW21dLmRhdGEgPSBwcm9tcHQoJ3ZlcnRleDogJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKG0gPSAwOyBtIDwgdGhpcy5hcmNudW07ICsrbSkge1xuICAgICAgICAgICAgbGV0IGggPSBwcm9tcHQoJ+W8p+WktDogJyk7XG4gICAgICAgICAgICBsZXQgdCA9IHByb21wdCgn5byn5bC+OiAnKTtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5sb2NhdGVWZXgodCk7XG4gICAgICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KGgpO1xuXG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHtcbiAgICAgICAgICAgICAgICBhbGVydCgn6aG254K55Li65om+5Yiw77yM6K+36YeN5paw6L6T5YWl77yBJyk7XG4gICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBBcmNOb2RlKGosIG51bGwsIGluY0luZm8gJiYgcHJvbXB0KCdpbmZvOiAnKSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYykgdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYyA9IHA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBxID0gdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcS5uZXh0QXJjOyBxID0gcS5uZXh0QXJjKTtcbiAgICAgICAgICAgICAgICBxLm5leHRBcmMgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5Yik5pat5LiA5Liq6YK75o6l6KGo5a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXG4gICAgaXNQYXNzKCkge1xuICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52ZXhudW07ICsreCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbeF0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHEgPSB0aGlzLnZlcnRpY2VzW3ldLmZpcnN0QXJjOyBxOyBxID0gcS5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB6ID0gcS5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuaXNBZGooeCwgeikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyDliKTmlq3mnInlkJHlm77mmK/lkKblrZjlnKjovrkobSxuKVxuICAgIGlzQWRqKG0sIG4pIHtcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbbV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgIGlmIChwLmFkalZleCA9PT0gbikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3seW6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqL1xuICAgIGV4aXN0UGF0aERGUyhpLCBqKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xuXG4gICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kIScpO1xuXG4gICAgICAgIHJldHVybiBleGlzdF9wYXRoKHRoaXMsIGksIGopO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4aXN0X3BhdGgoZ3JhcGgsIGksIGopIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtrXSAmJiBleGlzdF9wYXRoKGdyYXBoLCBrLCBqKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOW5v+W6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqL1xuICAgIGV4aXN0UGF0aEJGUyhpLCBqKSB7XG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcblxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgbGV0IHUgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICB2aXNpdGVkW3VdID0gMTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmIChrID09PSBqKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRba10pIHF1ZXVlLmVuUXVldWUoayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yik5pat6YK75o6l6KGo5pa55byP5a2Y5YKo55qE5pyJ5ZCR5Zu+55qE6aG254K5aeWIsGrmmK/lkKblrZjlnKjplb/luqbkuLpr55qE566A5Y2V6Lev5b6EXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICovXG4gICAgZXhpc3RQYXRoTGVuKGksIGosIGspIHtcbiAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KGkpO1xuICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiByZWN1cnNlKGdyYXBoLCBpLCBqLCBrKSB7XG4gICAgICAgICAgICAvLyDmib7liLDkuobkuIDmnaHot6/lvoTvvIzkuJTplb/luqbnrKblkIhcbiAgICAgICAgICAgIGlmIChpID09PSBqICYmIGsgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoayA+IDApIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDliankvZnot6/lvoTplb/luqblh4/kuIBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKGdyYXBoLCBsLCBqLCBrIC0gMSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWFgeiuuOabvue7j+iiq+iuv+mXrui/h+eahOe7k+eCueWHuueOsOWcqOWPpuS4gOadoei3r+W+hOS4ilxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKHRoaXMsIGksIGosIGspO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaxguacieWQkeWbvuS4remhtueCuXXliLB25LmL6Ze055qE5omA5pyJ566A5Y2V6Lev5b6E77yMa+S4uuW9k+WJjei3r+W+hOmVv+W6plxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgZ3JhcGguZmluZEFsbFBhdGhzKCd2MScsICd2MicsIDApO1xuICAgICAqL1xuICAgIGZpbmRBbGxQYXRocyh1LCB2LCBrKSB7XG4gICAgICAgIHUgPSB0aGlzLmxvY2F0ZVZleCh1KTtcbiAgICAgICAgdiA9IHRoaXMubG9jYXRlVmV4KHYpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xuXG4gICAgICAgIGZpbmRQYXRoKHRoaXMsIHUsIHYsIGspO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRQYXRoKGdyYXBoLCB1LCB2LCBrKSB7XG4gICAgICAgICAgICAvLyDliqDlhaXlvZPliY3ot6/lvoTkuK1cbiAgICAgICAgICAgIHBhdGhba10gPSB1O1xuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDE7XG5cbiAgICAgICAgICAgIC8vIOaJvuWIsOS4gOadoeeugOWNlei3r+W+hFxuICAgICAgICAgICAgaWYgKHUgPT09IHYpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgb25lIHBhdGghJyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IHBhdGhbaV07ICsraSkgY29uc29sZS5sb2cocGF0aFtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t1XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICAvLyDnu6fnu63lr7vmib5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSBmaW5kUGF0aChncmFwaCwgbCwgdiwgayArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDA7XG4gICAgICAgICAgICAvLyDlm57muq9cbiAgICAgICAgICAgIHBhdGhba10gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5rGC5pyJ5ZCR5Zu+55qE6aG254K55LmL6Ze06ZW/5bqm5Li6bGVu55qE566A5Y2V6Lev5b6E5p2h5pWwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5cbiAgICAgKi9cbiAgICBnZXRQYXRoTnVtX2xlbihpLCBqLCBsZW4pIHtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIHJlY3Vyc2UoZ3JhcGgsIGksIGosIGxlbikge1xuICAgICAgICAgICAgaWYgKGkgPT09IGogJiYgbGVuID09PSAwKSByZXR1cm4gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSBzdW0gKz0gcmVjdXJzZShsLCBqLCBsZW4gLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkodGhpcywgaSwgaiwgbGVuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmsYLmnInlkJHml6Dnjq/lm77nmoTmoLlcbiAgICAgKi9cbiAgICBnZXRSb290KCl7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIC8vIOavj+asoemDveimgeWwhuiuv+mXruaVsOe7hOa4hembtlxuICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB2aXNpdGVkW3ddID0gZmFsc2U7XG4gICAgICAgICAgICAvLyDku47pobbngrlp5Ye65Y+R6L+b6KGM5rex5bqm5LyY5YWI6YGN5Y6GXG4gICAgICAgICAgICBkZnModGhpcywgaSk7XG5cbiAgICAgICAgICAgIGxldCBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcih3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpe1xuICAgICAgICAgICAgICAgIC8vIOWmguaenGnmmK/moLnvvIzliJnmt7HluqbkvJjlhYjpgY3ljoblj6/ku6Xorr/pl67liLDmiYDmnInnu5PngrlcbiAgICAgICAgICAgICAgICBpZighdmlzaXRlZFt3XSkgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmbGFnKSBjb25zb2xlLmxvZygnRm91bmQgYSByb290IHZlcnRleDogJWQnLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdil7XG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yKGxldCBwID0gZ3JhcGgudmVydGljZXNbdl0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpe1xuICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgaWYoIXZpc2l0ZWRbd10pIGRmcyhncmFwaCwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmsYLkuIDkuKrmnInlkJHml6Dnjq/lm77kuK3mnIDplb/nmoTot6/lvoRcbiAgICAgKi9cbiAgICBnZXRMb25nZXN0UGF0aCgpe1xuICAgICAgICBsZXQgbWxwID0gW107XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBtYXhMZW4gPSAwO1xuXG4gICAgICAgIHRoaXMuY291bnRJbmRlZ3JlZSgpO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZpc2l0ZWRbal0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIOS7juavj+S4gOS4qumbtuWFpeW6pue7k+eCueW8gOWni+a3seW6puS8mOWFiOmBjeWOhlxuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIGRmcyh0aGlzLCBpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb25nZXN0IFBhdGg6Jyk7XG4gICAgICAgIC8vIOi+k+WHuuacgOmVv+i3r+W+hFxuICAgICAgICBmb3IoaSA9IDA7IG1scFtpXTsgKytpKSBjb25zb2xlLmxvZyhtbHAuam9pbignLCcpKTtcblxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIGksIGxlbil7XG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhdGhbbGVuXSA9IGk7XG5cbiAgICAgICAgICAgIC8vIOaWsOeahOacgOmVv+i3r+W+hFxuICAgICAgICAgICAgaWYobGVuID4gbWF4TGVuICYmICFncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYykge1xuICAgICAgICAgICAgICAgIC8vIOS/neWtmOS4i+adpVxuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPD0gbGVuOyArK2opIG1scFtqXSA9IHBhdGhbal07XG4gICAgICAgICAgICAgICAgbWF4TGVuID0gbGVuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF2aXNpdGVkW3ddKSBkZnMoZ3JhcGgsIHcsIGxlbiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aFtpXSA9IDA7XG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDpgrvmjqXooajnmoTpgJLlvZLlvI/mt7HluqbkvJjlhYjpgY3ljoZcbiAgICBERlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnModGhpcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHYpIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgICAgICAgICAgdmlzaXRGbi5jYWxsKGdyYXBoLCB2KTtcblxuICAgICAgICAgICAgbGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuYWRqVmV4XSkgZGZzKGdyYXBoLCBwLmFkalZleCk7XG5cbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6YK75o6l6KGo55qE6Z2e6YCS5b2S5rex5bqm5LyY5YWI5pCc57SiXG4gICAgREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh2ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW3AuYWRqVmV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIHAuYWRqVmV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHAuYWRqVmV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6YK75o6l6KGo55qE5bm/5bqm5LyY5YWI5pCc57SiXG4gICAgQkZTVHJhdmVyc2UodmlzaXRGbikge1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKGkpO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBpKTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXMudmVydGljZXNbd10uZmlyc3RBcmM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBwLmFkalZleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShwLmFkalZleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlu7rnq4vml6DlkJHlm77nmoTmt7HluqbkvJjlhYjnlJ/miJDmo67mnpfnmoTlranlrZDlhYTlvJ/pk77ooajmoJFcbiAgICBjcmVhdGVERlNGb3Jlc3QoKSB7XG4gICAgICAgIGxldCB0cmVlID0gbnVsbDtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG5cbiAgICAgICAgbGV0IHE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8g5paw55qE55Sf5oiQ5qCR55qE5qC557uT54K5XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBuZXcgQ2hpbGRTaWJsaW5nVHJlZSh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5qO155Sf5oiQ5qCR55qE5qC5XG4gICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gcDtcbiAgICAgICAgICAgICAgICAvLyDlhbblroPnlJ/miJDmoJHnmoTmoLlcbiAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBwO1xuXG4gICAgICAgICAgICAgICAgLy8gceS4uuW9k+WJjeeUn+aIkOagkeeahOaguVxuICAgICAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgICAgIC8vIOW7uueri+S7pXDkuLrmoLnnmoTnlJ/miJDmoJFcbiAgICAgICAgICAgICAgICBERlNUcmVlKHRoaXMsIGksIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyZWU7XG5cbiAgICAgICAgLy8g5Lul56ysduS4qumhtueCueinpuWPkea3seW6puS8mOWFiOmBjeWOhuWbvu+8jOW7uueri+S7pXRyZWXkuLrmoLnnmoTnlJ/miJDmoJFcbiAgICAgICAgZnVuY3Rpb24gREZTVHJlZShncmFwaCwgdiwgdHJlZSkge1xuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHcgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgIGxldCBxO1xuXG4gICAgICAgICAgICB3aGlsZSAodykge1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3LmFkalZleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFt3LmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKGdyYXBoLnZlcnRpY2VzW3cuYWRqVmV4XS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB35pivdueahOesrOS4gOS4quacquiiq+iuv+mXrueahOmCu+aOpee7k+eCuVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuZmlyc3RDaGlsZCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHfmmK9255qE5YW25a6D5pyq6KKr6K6/6Zeu55qE6YK75o6l6aG254K5XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcS5uZXh0U2libGluZyA9IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgcSA9IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgREZTVHJlZShncmFwaCwgdy5hZGpWZXgsIHEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHcgPSB3Lm5leHRBcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVCRlNGb3Jlc3QoKSB7XG4gICAgICAgIGxldCB0cmVlID0gbnVsbDtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKHRoaXMudmVydGljZXNbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgcSA9IG5vZGU7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzLnZlcnRpY2VzW3ddLmZpcnN0QXJjO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5hZGpWZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUyID0gbmV3IENoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1twLmFkalZleF0uZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5maXJzdENoaWxkID0gbm9kZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcHJlLm5leHRTaWJsaW5nID0gbm9kZTI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBmaW5kQXJ0aWN1bCgpIHtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgbGV0IGxvdyA9IFtdO1xuICAgICAgICBsb3dbMF0gPSBjb3VudDtcbiAgICAgICAgdmlzaXRlZFswXSA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IDA7XG4gICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1swXS5maXJzdEFyYztcbiAgICAgICAgbGV0IHYgPSBwLmFkalZleDtcblxuICAgICAgICBERlNBcnRpY3VsKHRoaXMsIHYpO1xuICAgICAgICBpZiAoY291bnQgPCB0aGlzLnZleG51bSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coMCArICcgICcgKyB0aGlzLnZlcnRpY2VzWzBdLmRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XG4gICAgICAgICAgICAgICAgdiA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW3ZdID09PSAwKSBERlNBcnRpY3VsKHRoaXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gREZTQXJ0aWN1bChncmFwaCwgdjApIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSB2aXNpdGVkW3YwXSA9ICsrY291bnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbdjBdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHcgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFt3XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBERlNBcnRpY3VsKGdyYXBoLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd1t3XSA8IG1pbikgbWluID0gbG93W3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93W3ddID49IHZpc2l0ZWRbdjBdKSBjb25zb2xlLmxvZyh2MCArICcgICcgKyBncmFwaC52ZXJ0aWNlc1t2MF0uZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddIDwgbWluKSBtaW4gPSB2aXNpdGVkW3ddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93W3YwXSA9IG1pbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOe7n+iuoeWQhOmhtueCueWFpeW6pueahOWHveaVsFxuICAgIGNvdW50SW5kZWdyZWUoKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykgdGhpcy52ZXJ0aWNlc1trXS5pbmRlZ3JlZSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1trXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYylcbiAgICAgICAgICAgICAgICArK3RoaXMudmVydGljZXNbcC5hZGpWZXhdLmluZGVncmVlO1xuICAgICAgICB9XG4gICAgfVxuXG4vLyDmi5PmiZHmjpLluo/nrpfms5VcbiAgICB0b3BvbG9naWNTb3J0KCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyID0gW107XG4gICAgICAgIHRoaXMuY291bnRJbmRlZ3JlZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIHN0YWNrLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyLnB1c2goaSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xuICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICBpZiAoLS10aGlzLnZlcnRpY2VzW2tdLmluZGVncmVlID09PSAwKSBzdGFjay5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChjb3VudCA+PSB0aGlzLnZleG51bSk7XG4gICAgfVxuXG4gICAgLy8g6L6T5Ye65pyJ5ZCR5Zu+55qE5ZCE6aG55YWz6ZSu5rS75YqoXG4gICAgY3JpdGljYWxQYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMudG9wb2xvZ2ljU29ydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ0FPRee9keS4reWtmOWcqOWbnui3r++8gScpO1xuXG4gICAgICAgIGxldCB2ZSA9IFtdO1xuICAgICAgICAvLyDkuovku7bmnIDml6nlj5HnlJ/ml7bpl7TliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB2ZVtqXSA9IDA7XG4gICAgICAgIC8vIOiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZl5YC8XG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgbGV0IGogPSB0aGlzLnRvcG9sb2dpY2FsT3JkZXJbbV07XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgaWYgKHZlW2pdICsgcC5pbmZvID4gdmVba10pIHZlW2tdID0gdmVbal0gKyBwLmluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZsID0gW107XG4gICAgICAgIC8vIOS6i+S7tuacgOaZmuWPkeeUn+aXtumXtOWIneWni+WMllxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZsW2pdID0gdmVbdGhpcy52ZXhudW0gLSAxXTtcbiAgICAgICAgLy8g6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pma5Y+R55Sf5pe26Ze0dmznmoTlgLxcbiAgICAgICAgZm9yIChsZXQgbSA9IHRoaXMudmV4bnVtIC0gMTsgbSA+PSAwOyAtLW0pIHtcbiAgICAgICAgICAgIGxldCBqID0gdGhpcy50b3BvbG9naWNhbE9yZGVyW21dO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmICh2bFtrXSAtIHAuaW5mbyA8IHZsW2pdKSB2bFtqXSA9IHZsW2tdIC0gcC5pbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOi+k+WHuuaJgOacieWFs+mUrua0u+WKqFxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW21dLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICBpZiAodmVbbV0gKyBwLmluZm8gPT09IHZsW2tdKSBjb25zb2xlLmxvZygnPCVkLCAlZD4nLCBtLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3J0ZXN0UGF0aF9EaWprc3RyYSh2MCkge1xuICAgICAgICBsZXQgZGlzdCA9IFtdO1xuICAgICAgICBsZXQgcHJlID0gW107XG4gICAgICAgIGxldCBmaW5hbCA9IFtdO1xuICAgICAgICBsZXQgdztcblxuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpXG4gICAgICAgICAgICBkaXN0W3ZdID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW3YwXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYylcbiAgICAgICAgICAgIGRpc3RbcC5hZGpWZXhdID0gcC5pbmZvO1xuXG4gICAgICAgIGxldCB2O1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xuICAgICAgICAgICAgZmluYWxbdl0gPSBmYWxzZTtcbiAgICAgICAgICAgIHByZVt2XSA9IHByZVt2XSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSBwcmVbdl1bd10gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGRpc3Rbdl0gPCBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZVt2XVt2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXN0W3YwXSA9IDA7XG4gICAgICAgIGZpbmFsW3YwXSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgZGlzdFt3XSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdztcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdFt3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbmFsW3ZdID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbdl0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICB3ID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBtaW4gKyBwLmluZm8gPCBkaXN0W3ddKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Rbd10gPSBtaW4gKyBwLmluZm87XG4gICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddW3ddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhmaW5hbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHByZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGRpc3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaW5hbDogZmluYWwsXG4gICAgICAgICAgICBwcmU6IHByZSxcbiAgICAgICAgICAgIGRpc3Q6IGRpc3RcbiAgICAgICAgfTtcbiAgICB9XG59XG5cblxuLy8g5peg5ZCR5Zu+55qE6YK75o6l6KGoXG52YXIgYWRqTGlzdEdyYXBoID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgVURHKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YxJyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjMnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NScpO1xuXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MScsICd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjEnLCAndjMnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MicsICd2MycpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjQnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3Y1Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2NCcsICd2NScpO1xuXG5jb25zb2xlLmxvZyhhZGpMaXN0R3JhcGgpO1xuXG4vLyDmnInlkJHlm77nmoTpgIbpgrvmjqXooahcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZy5hZGRWZXJ0ZXgoJ3YxJyk7XG5nLmFkZFZlcnRleCgndjInKTtcbmcuYWRkVmVydGV4KCd2MycpO1xuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5nLmFkZFZlcnRleCgndjUnKTtcblxuZy5hZGRBcmMoJ3YxJywgJ3YyJyk7XG5nLmFkZEFyYygndjEnLCAndjQnKTtcbmcuYWRkQXJjKCd2MycsICd2MicpO1xuZy5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5nLmFkZEFyYygndjQnLCAndjMnKTtcbmcuYWRkQXJjKCd2MycsICd2NScpO1xuZy5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5cbmNvbnNvbGUubG9nKGcpO1xuXG4vLyDmnInlkJHlm77nmoTmraPpgrvmjqXooahcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZy5hZGRWZXJ0ZXgoJ3YxJyk7XG5nLmFkZFZlcnRleCgndjInKTtcbmcuYWRkVmVydGV4KCd2MycpO1xuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5nLmFkZFZlcnRleCgndjUnKTtcblxuZy5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nLmFkZEFyYygndjQnLCAndjEnKTtcbmcuYWRkQXJjKCd2MicsICd2MycpO1xuZy5hZGRBcmMoJ3YxJywgJ3YzJyk7XG5nLmFkZEFyYygndjMnLCAndjQnKTtcbmcuYWRkQXJjKCd2NScsICd2MycpO1xuZy5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XG5cbmNvbnNvbGUubG9nKGcpO1xuXG5cblxuXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIERGU1RyYXZlcnNlOiAnKTtcbnZhciBhZGpMaXN0R3JhcGggPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBVREcpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjEnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YyJyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MycpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjQnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y1Jyk7XG5cbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjInLCAndjEnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5cbmFkakxpc3RHcmFwaC5ERlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XG59KTtcblxuXG5cbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggREZTVHJhdmVyc2VfTm9uUmVjdXJzZTogJyk7XG5hZGpMaXN0R3JhcGguREZTVHJhdmVyc2VfTm9uUmVjdXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XG59KTtcblxuXG5cbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggQkZTVHJhdmVyc2U6ICcpO1xudmFyIGcyID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZzIuYWRkVmVydGV4KCd2MScpO1xuZzIuYWRkVmVydGV4KCd2MicpO1xuZzIuYWRkVmVydGV4KCd2MycpO1xuZzIuYWRkVmVydGV4KCd2NCcpO1xuZzIuYWRkVmVydGV4KCd2NScpO1xuXG5nMi5hZGRBcmMoJ3Y0JywgJ3YxJyk7XG5nMi5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nMi5hZGRBcmMoJ3Y1JywgJ3YzJyk7XG5nMi5hZGRBcmMoJ3YyJywgJ3YzJyk7XG5nMi5hZGRBcmMoJ3YxJywgJ3YzJyk7XG5nMi5hZGRBcmMoJ3YzJywgJ3Y0Jyk7XG5nMi5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XG5cbmcyLkJGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XG4gICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1t2XS5kYXRhKTtcbn0pO1xuXG5jb25zb2xlLmxvZygnREZTOiBleHBlY3QgZmFsc2U6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RQYXRoREZTKCd2MScsICd2NCcpKTtcbmNvbnNvbGUubG9nKCdERlM6IGV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0UGF0aERGUygndjEnLCAndjInKSk7XG5cbmNvbnNvbGUubG9nKCdCRlMgOiBleHBlY3QgZmFsc2U6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RQYXRoQkZTKCd2MScsICd2NCcpKTtcbmNvbnNvbGUubG9nKCdCRlMgOmV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0UGF0aEJGUygndjEnLCAndjInKSk7XG5cblxuXG4vKlxuIOWbvueahOi/numAmuaAp+mXrumimFxuXG4g5peg5ZCR5Zu+55qE6L+e6YCa5YiG6YeP5LiO55Sf5oiQ5qCRXG5cbiAxIOaXoOWQkeWbvueahOi/numAmuWIhumHj+WSjOeUn+aIkOagkVxuIOWvueS6juaXoOWQkeWbvu+8jOWvueWFtui/m+ihjOmBjeWOhuaXtu+8mlxuIOKXhiDoi6XmmK/ov57pgJrlm77vvJrku4XpnIDku47lm77kuK3ku7vkuIDpobbngrnlh7rlj5HvvIzlsLHog73orr/pl67lm77kuK3nmoTmiYDmnInpobbngrnvvJtcbiDil4Yg6Iul5piv6Z2e6L+e6YCa5Zu+77ya6ZyA5LuO5Zu+5Lit5aSa5Liq6aG254K55Ye65Y+R44CC5q+P5qyh5LuO5LiA5Liq5paw6aG254K55Ye65Y+R5omA6K6/6Zeu55qE6aG254K56ZuG5bqP5YiX5oGw5aW95piv5ZCE5Liq6L+e6YCa5YiG6YeP55qE6aG254K56ZuG77ybXG5cbiDikbQg6IulRz0oVixFKeaYr+aXoOWQkei/numAmuWbvu+8jCDpobbngrnpm4blkozovrnpm4bliIbliKvmmK9WKEcpIO+8jEUoRykg44CC6Iul5LuOR+S4reS7u+aEj+eCueWHuuWPkemBjeWOhuaXtu+8jCBFKEcp6KKr5YiG5oiQ5Lik5Liq5LqS5LiN55u45Lqk55qE6ZuG5ZCI77yaXG4gVChHKSDvvJrpgY3ljobov4fnqIvkuK3miYDnu4/ov4fnmoTovrnnmoTpm4blkIjvvJtcbiBCKEcpIO+8mumBjeWOhui/h+eoi+S4reacque7j+i/h+eahOi+ueeahOmbhuWQiO+8m1xuIOaYvueEtu+8miBFKEcpPVQoRyniiKpCKEcpIO+8jFQoRyniiKlCKEcpPcOYXG4g5pi+54S277yM5Zu+R+KAmT0oViwgVChHKSnmmK9H55qE5p6B5bCP6L+e6YCa5a2Q5Zu+77yM5LiUR+KAmeaYr+S4gOajteagkeOAgkfigJnnp7DkuLrlm75H55qE5LiA5qO155Sf5oiQ5qCR44CCXG4g5LuO5Lu75oSP54K55Ye65Y+R5oyJREZT566X5rOV5b6X5Yiw55Sf5oiQ5qCRR+KAmeensOS4uua3seW6puS8mOWFiOeUn+aIkOagke+8m+aMiUJGU+eul+azleW+l+WIsOeahEfigJnnp7DkuLrlub/luqbkvJjlhYjnlJ/miJDmoJHjgIJcblxuIOKRtSAg6IulRz0oVixFKeaYr+aXoOWQkemdnui/numAmuWbvu+8jOWvueWbvui/m+ihjOmBjeWOhuaXtuW+l+WIsOiLpeW5suS4qui/numAmuWIhumHj+eahOmhtueCuembhu+8mlYxKEcpICxWMihHKSAs4oCmLFZuKEcp5ZKM55u45bqU5omA57uP6L+H55qE6L656ZuG77yaVDEoRykgLFQyKEcpICwg4oCmLFRuKEcpIOOAglxuIOWImeWvueW6lOeahOmhtueCuembhuWSjOi+uembhueahOS6jOWFg+e7hO+8mkdpPShWaShHKSxUaShHKSlcbiAoMeKJpmniiaZuKeaYr+WvueW6lOWIhumHj+eahOeUn+aIkOagke+8jOaJgOaciei/meS6m+eUn+aIkOagkeaehOaIkOS6huWOn+adpemdnui/numAmuWbvueahOeUn+aIkOajruael+OAglxuXG4g6K+05piO77ya5b2T57uZ5a6a5peg5ZCR5Zu+6KaB5rGC55S75Ye65YW25a+55bqU55qE55Sf5oiQ5qCR5oiW55Sf5oiQ5qOu5p6X5pe277yM5b+F6aG75YWI57uZ5Ye655u45bqU55qE6YK75o6l6KGo77yM54S25ZCO5omN6IO95qC55o2u6YK75o6l6KGo55S75Ye65YW25a+55bqU55qE55Sf5oiQ5qCR5oiW55Sf5oiQ5qOu5p6X44CCXG5cblxuIDIgIOWbvueahOeUn+aIkOagkeWSjOeUn+aIkOajruael+eul+azlVxuXG4g5a+55Zu+55qE5rex5bqm5LyY5YWI5pCc57Si6YGN5Y6GREZTKOaIlkJGUynnrpfms5XnqI3kvZzkv67mlLnvvIzlsLHlj6/lvpfliLDmnoTpgKDlm77nmoRERlPnlJ/miJDmoJHnrpfms5XjgIJcbiDlnKjnrpfms5XkuK3vvIzmoJHnmoTlrZjlgqjnu5PmnoTph4fnlKjlranlrZDigJTlhYTlvJ/ooajnpLrms5XjgILpppblhYjlu7rnq4vku47mn5DkuKrpobbngrlW5Ye65Y+R77yM5bu656uL5LiA5Liq5qCR57uT54K577yM54S25ZCO5YaN5YiG5Yir5LulVueahOmCu+aOpeeCueS4uui1t+Wni+eCue+8jOW7uueri+ebuOW6lOeahOWtkOeUn+aIkOagke+8jOW5tuWwhuWFtuS9nOS4ulYg57uT54K555qE5a2Q5qCR6ZO+5o6l5YiwVue7k+eCueS4iuOAguaYvueEtu+8jOeul+azleaYr+S4gOS4qumAkuW9kueul+azleOAglxuXG4gKi9cblxuXG5cblxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZURGU0ZvcmVzdCgpKTtcblxuXG5cblxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZUJGU0ZvcmVzdCgpKTtcblxuXG5cbi8qXG4g5Zyo5p+Q5Zu+5Lit77yM6Iul5Yig6Zmk6aG254K5VuS7peWPilbnm7jlhbPnmoTovrnlkI7vvIzlm77nmoTkuIDkuKrov57pgJrliIbph4/liIblibLkuLrkuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTov57pgJrliIbph4/vvIzliJnnp7DpobbngrlW5Li66K+l5Zu+55qE5LiA5Liq5YWz6IqC54K544CC5LiA5Liq5rKh5pyJ5YWz6IqC54K555qE6L+e6YCa5Zu+56ew5Li66YeN6L+e6YCa5Zu+44CCXG4g5Zyo6YeN6L+e6YCa5Zu+5Lit77yM5Lu75oSP5LiA5a+56aG254K55LmL6Ze06Iez5bCR5a2Y5Zyo5Lik5p2h6Lev5b6E77yM5YiZ5YaN5Yig5Y675p+Q5Liq6aG254K55Y2z55u45YWz5ZCE6L655ZCO5Lmf5LiN56C05Z2P5Zu+55qE6L+e6YCa5oCn44CC6Iul5Zyo5Zu+55qE6L+e6YCa5Zu+5LiK5Yig5Y67a+S4quiKgueCueaJjeiDveegtOWdj+WbvueahOi/numAmuaAp++8jOWImeensEvkuLrmraTlm77nmoTov57pgJrluqbjgIJcbiDku5bku6zluLjluLjlnKjpgJrkv6HnvZHnu5znmoTlm77miJboiKrnqbrnvZHkuK3lupTnlKjvvIxL6LaK5aSn77yM57O757uf6LaK56iz5a6a77yM5Y+N5LmL77yM5oiY5LqJ5Lit6Iul6KaB5pGn5q+B5pWM5pa555qE6L+Q6L6T57q/77yM5Y+q6aG756C05Z2P5YW26L+Q6L6T572R5Lit55qE5YWz6IqC54K55Y2z5Y+v44CCXG4gKi9cblxuXG5cbnZhciBhcnRpY3VsVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIFVERyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0EnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnQicpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdDJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0QnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRScpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdGJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0cnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSCcpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdJJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0onKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSycpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdMJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ00nKTtcblxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0InKTtcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdDJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnRicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0wnKTtcbmFydGljdWxUZXN0LmFkZEFyYygnQycsICdCJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0QnLCAnQicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0InKTtcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdCJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ00nLCAnQicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdEJywgJ0UnKTtcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdIJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnSScpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0snKTtcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdLJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0onLCAnTCcpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdKJywgJ00nKTtcbmFydGljdWxUZXN0LmFkZEFyYygnTCcsICdNJyk7XG5cbmFydGljdWxUZXN0LmZpbmRBcnRpY3VsKCk7XG5cblxuLypcbiDmnInlkJHml6Dnjq/lm77lj4rlhbblupTnlKhcblxuIOacieWQkeaXoOeOr+WbvihEaXJlY3RlZCBBY3ljbGluZyBHcmFwaCnvvJrmmK/lm77kuK3msqHmnInlm57ot68o546vKeeahOacieWQkeWbvuOAguaYr+S4gOexu+WFt+acieS7o+ihqOaAp+eahOWbvu+8jOS4u+imgeeUqOS6jueglOeptuW3peeoi+mhueebrueahOW3peW6j+mXrumimOOAgeW3peeoi+aXtumXtOi/m+W6pumXrumimOetieOAglxuXG4g5LiA5Liq5bel56iLKHByb2plY3Qp6YO95Y+v5YiG5Li66Iul5bmy5Liq56ew5Li65rS75YqoKGFjdGl2ZSnnmoTlrZDlt6XnqIso5oiW5bel5bqPKe+8jOWQhOS4quWtkOW3peeoi+WPl+WIsOS4gOWumueahOadoeS7tue6puadn++8muafkOS4quWtkOW3peeoi+W/hemhu+W8gOWni+S6juWPpuS4gOS4quWtkOW3peeoi+WujOaIkOS5i+WQju+8m+aVtOS4quW3peeoi+acieS4gOS4quW8gOWni+eCuSjotbfngrkp5ZKM5LiA5Liq57uI54K544CC5Lq65Lus5YWz5b+D77yaXG4g4peGIOW3peeoi+iDveWQpumhuuWIqeWujOaIkD/lvbHlk43lt6XnqIvnmoTlhbPplK7mtLvliqjmmK/ku4DkuYg/XG4g4peGIOS8sOeul+aVtOS4quW3peeoi+WujOaIkOaJgOW/hemhu+eahOacgOefreaXtumXtOaYr+WkmuWwkT9cblxuIOWvueW3peeoi+eahOa0u+WKqOWKoOS7peaKveixoe+8muWbvuS4remhtueCueihqOekuua0u+WKqO+8jOacieWQkei+ueihqOekuua0u+WKqOS5i+mXtOeahOS8mOWFiOWFs+ezu++8jOi/meagt+eahOacieWQkeWbvuensOS4uumhtueCueihqOekuua0u+WKqOeahOe9kShBY3Rpdml0eSBPbiBWZXJ0ZXggTmV0d29yayDvvIxBT1bnvZEpIOOAglxuXG5cbiDmi5PmiZHmjpLluo9cblxuIDEg5a6a5LmJXG4g5ouT5omR5o6S5bqPKFRvcG9sb2dpY2FsIFNvcnQpIO+8mueUseafkOS4qumbhuWQiOS4iueahOS4gOS4quWBj+W6j+W+l+WIsOivpembhuWQiOS4iueahOS4gOS4quWFqOW6j+eahOaTjeS9nOOAglxuXG4g4peGIOmbhuWQiOS4iueahOWFs+ezu++8mumbhuWQiEHkuIrnmoTlhbPns7vmmK/ku45B5YiwQeeahOWFs+ezuyhB74K0QSkg44CCXG4g4peGIOWFs+ezu+eahOiHquWPjeaAp++8muiLpe+AomHiiIhB5pyJKGHvvIxhKeKIiFLvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+iHquWPjeeahOOAglxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAglxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfkuI7lj43lr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAguWmguaenOWvueS6jmHvvIxi4oiIQSDvvIzku4XlvZNhPWLml7bmnIkoYe+8jGIp4oiIUuWSjChi77yMYSniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5Y+N5a+556ew55qE44CCXG4g4peGIOWFs+ezu+eahOS8oOmAkuaAp++8muiLpWHvvIxi77yMY+KIiEHvvIzoi6UoYe+8jGIp4oiIUu+8jOW5tuS4lChi77yMYyniiIhSIO+8jOWImShh77yMYyniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5Lyg6YCS55qE44CCXG4g4peGIOWBj+W6j++8muiLpembhuWQiEHkuIrnmoTlhbPns7tS5piv6Ieq5Y+N55qE77yM5Y+N5a+556ew55qE5ZKM5Lyg6YCS55qE77yM5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vjgIJcbiDil4Yg5YWo5bqP77ya6K6+UuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vvvIzvgKJh77yMYuKIiEHvvIzlv4XmnIlhUmLmiJZiUmHvvIwg5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlhajluo/lhbPns7vjgIJcblxuIOWNs+WBj+W6j+aYr+aMh+mbhuWQiOS4reS7heaciemDqOWIhuWFg+e0oOS5i+mXtOWPr+S7peavlOi+g++8jOiAjOWFqOW6j+aYr+aMh+mbhuWQiOS4reS7u+aEj+S4pOS4quWFg+e0oOS5i+mXtOmDveWPr+S7peavlOi+g+OAglxuIOWcqEFPVue9keS4re+8jOiLpeacieacieWQkei+uTxpLCBqPu+8jOWImWnmmK9q55qE55u05o6l5YmN6amx77yMauaYr2nnmoTnm7TmjqXlkI7nu6fvvJvmjqjogIzlub/kuYvvvIzoi6Xku47pobbngrlp5Yiw6aG254K5auacieacieWQkei3r+W+hO+8jOWImWnmmK9q55qE5YmN6amx77yMauaYr2nnmoTlkI7nu6fjgIJcbiDlnKhBT1bnvZHkuK3vvIzkuI3og73mnInnjq/vvIzlkKbliJnvvIzmn5DpobnmtLvliqjog73lkKbov5vooYzmmK/ku6Xoh6rouqvnmoTlrozmiJDkvZzkuLrliY3mj5DmnaHku7bjgIJcbiDmo4Dmn6Xmlrnms5XvvJrlr7nmnInlkJHlm77nmoTpobbngrnov5vooYzmi5PmiZHmjpLluo/vvIzoi6XmiYDmnInpobbngrnpg73lnKjlhbbmi5PmiZHmnInluo/luo/liJfkuK3vvIzliJnml6Dnjq/jgIJcbiDmnInlkJHlm77nmoTmi5PmiZHmjpLluo/vvJrmnoTpgKBBT1bnvZHkuK3pobbngrnnmoTkuIDkuKrmi5PmiZHnur/mgKfluo/liJcoduKAmTEsduKAmTIsIOKLryx24oCZbinvvIzkvb/lvpfor6Xnur/mgKfluo/liJfkuI3ku4Xkv53mjIHljp/mnaXmnInlkJHlm77kuK3pobbngrnkuYvpl7TnmoTkvJjlhYjlhbPns7vvvIzogIzkuJTlr7nljp/lm77kuK3msqHmnInkvJjlhYjlhbPns7vnmoTpobbngrnkuYvpl7TkuZ/lu7rnq4vkuIDnp40o5Lq65Li655qEKeS8mOWFiOWFs+ezu+OAglxuXG4gMiDmi5PmiZHmjpLluo/nrpfms5VcbiDnrpfms5XmgJ3mg7NcblxuIOKRoCDlnKhBT1bnvZHkuK3pgInmi6nkuIDkuKrmsqHmnInliY3pqbHnmoTpobbngrnkuJTovpPlh7rvvJtcbiDikaEg5ZyoQU9W572R5Lit5Yig6Zmk6K+l6aG254K55Lul5Y+K5LuO6K+l6aG254K55Ye65Y+R55qEKOS7peivpemhtueCueS4uuWwvueahOW8pynmiYDmnInmnInlkJHlvKco6L65KSDvvJtcbiDikaIg6YeN5aSN4pGg44CB4pGh77yM55u05Yiw5Zu+5Lit5YWo6YOo6aG254K56YO95bey6L6T5Ye6KOWbvuS4reaXoOeOrynmiJblm77kuK3kuI3lrZjlnKjml6DliY3pqbHnmoTpobbngrko5Zu+5Lit5b+F5pyJ546vKeOAglxuXG4gMyAg566X5rOV5a6e546w6K+05piOXG4g4peGIOmHh+eUqOato+mCu+aOpemTvuS9nOS4ukFPVue9keeahOWtmOWCqOe7k+aehO+8m1xuIOKXhiDorr7nq4vloIbmoIjvvIznlKjmnaXmmoLlrZjlhaXluqbkuLow55qE6aG254K577ybXG4g4peGIOWIoOmZpOmhtueCueS7peWug+S4uuWwvueahOW8p++8muW8p+WktOmhtueCueeahOWFpeW6puWHjzHjgIJcblxuIOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08obitlKSDjgIJcblxuICovXG5cbnZhciB0b3BvbG9naWNUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3YxJyk7XG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjInKTtcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2MycpO1xudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3Y0Jyk7XG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjUnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2NicpO1xuXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjInLCAndjEnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NCcsICd2MScpO1xudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YzJywgJ3YxJyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjInLCAndjMnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2MycpO1xudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y0JywgJ3Y2Jyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjQnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2NicpO1xuXG5jb25zb2xlLmxvZygndG9wb2xvZ2ljU29ydDogJyk7XG5jb25zb2xlLmxvZyh0b3BvbG9naWNUZXN0LnRvcG9sb2dpY1NvcnQoKSk7XG5cblxuXG4vKlxuIOWFs+mUrui3r+W+hChDcml0aWNhbCBQYXRoKVxuXG4g5LiOQU9W572R55u45a+55bqU55qE5pivQU9FKEFjdGl2aXR5IE9uIEVkZ2UpIO+8jOaYr+i+ueihqOekuua0u+WKqOeahOacieWQkeaXoOeOr+Wbvu+8jOWmguWbvjctMjTmiYDnpLrjgILlm77kuK3pobbngrnooajnpLrkuovku7YoRXZlbnQp77yM5q+P5Liq5LqL5Lu26KGo56S65Zyo5YW25YmN55qE5omA5pyJ5rS75Yqo5bey57uP5a6M5oiQ77yM5YW25ZCO55qE5rS75Yqo5Y+v5Lul5byA5aeL77yb5byn6KGo56S65rS75Yqo77yM5byn5LiK55qE5p2D5YC86KGo56S655u45bqU5rS75Yqo5omA6ZyA55qE5pe26Ze05oiW6LS555So44CCXG5cbiAxIOS4jkFPReacieWFs+eahOeglOeptumXrumimFxuIOKXhiDlrozmiJDmlbTkuKrlt6XnqIvoh7PlsJHpnIDopoHlpJrlsJHml7bpl7Q/XG4g4peGIOWTquS6m+a0u+WKqOaYr+W9seWTjeW3peeoi+i/m+W6pijotLnnlKgp55qE5YWz6ZSuP1xuIOW3peeoi+WujOaIkOacgOefreaXtumXtO+8muS7jui1t+eCueWIsOe7iOeCueeahOacgOmVv+i3r+W+hOmVv+W6pijot6/lvoTkuIrlkITmtLvliqjmjIHnu63ml7bpl7TkuYvlkowpIOOAgumVv+W6puacgOmVv+eahOi3r+W+hOensOS4uuWFs+mUrui3r+W+hO+8jOWFs+mUrui3r+W+hOS4iueahOa0u+WKqOensOS4uuWFs+mUrua0u+WKqOOAguWFs+mUrua0u+WKqOaYr+W9seWTjeaVtOS4quW3peeoi+eahOWFs+mUruOAglxuIOiuvnYw5piv6LW354K577yM5LuOdjDliLB2aeeahOacgOmVv+i3r+W+hOmVv+W6puensOS4uuS6i+S7tnZp55qE5pyA5pep5Y+R55Sf5pe26Ze077yM5Y2z5piv5LuldmnkuLrlsL7nmoTmiYDmnInmtLvliqjnmoTmnIDml6nlj5HnlJ/ml7bpl7TjgIJcbiDoi6XmtLvliqhhaeaYr+W8pzxqLCBrPu+8jOaMgee7reaXtumXtOaYr2R1dCg8aiwgaz4p77yM6K6+77yaXG4g4peGIGUoaSnvvJrooajnpLrmtLvliqhhaeeahOacgOaXqeW8gOWni+aXtumXtO+8m1xuIOKXhiBsKGkp77ya5Zyo5LiN5b2x5ZON6L+b5bqm55qE5YmN5o+Q5LiL77yM6KGo56S65rS75YqoYWnnmoTmnIDmmZrlvIDlp4vml7bpl7TvvJsg5YiZbChpKS1lKGkp6KGo56S65rS75YqoYWnnmoTml7bpl7TkvZnph4/vvIzoi6VsKGkpLWUoaSk9MO+8jOihqOekuua0u+WKqGFp5piv5YWz6ZSu5rS75Yqo44CCXG4g4peGIHZlKGkp77ya6KGo56S65LqL5Lu2dmnnmoTmnIDml6nlj5HnlJ/ml7bpl7TvvIzljbPku47otbfngrnliLDpobbngrl2aeeahOacgOmVv+i3r+W+hOmVv+W6pu+8m1xuIOKXhiB2bChpKe+8muihqOekuuS6i+S7tnZp55qE5pyA5pma5Y+R55Sf5pe26Ze044CC5YiZ5pyJ5Lul5LiL5YWz57O777yaXG4gZShpKT12ZShqKVxuIGwoaSk9IHZsKGspLWR1dCg8aiwgaz4pXG4gMCAgICBqPTDvvIzooajnpLp2auaYr+i1t+eCuVxuIHZlKGopPVxuIE1heHt2ZShpKStkdXQoPGksIGo+KXw8dmksIHZqPuaYr+e9keS4reeahOW8p31cblxuIOWQq+S5ieaYr++8mua6kOeCueS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtOiuvuS4ujDvvJvpmaTmupDngrnlpJbvvIzlj6rmnInov5vlhaXpobbngrl2aueahOaJgOacieW8p+aJgOS7o+ihqOeahOa0u+WKqOWFqOmDqOe7k+adn+WQju+8jOS6i+S7tnZq5omN6IO95Y+R55Sf44CC5Y2z5Y+q5pyJdmrnmoTmiYDmnInliY3pqbHkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtHZlKGkp6K6h566X5Ye65p2l5ZCO77yM5omN6IO96K6h566XdmUoaikg44CCXG4g5pa55rOV5piv77ya5a+55omA5pyJ5LqL5Lu26L+b6KGM5ouT5omR5o6S5bqP77yM54S25ZCO5L6d5qyh5oyJ5ouT5omR6aG65bqP6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pep5Y+R55Sf5pe26Ze044CCXG4gdmUobi0xKSAgICBqPW4tMe+8jOihqOekunZq5piv57uI54K5XG4gdmwoaik9XG4gTWlue3ZsKGspLWR1dCg8aiwgaz4pfDx2aiwgdms+5piv572R5Lit55qE5bynfVxuIOWQq+S5ieaYr++8muWPquaciXZq55qE5omA5pyJ5ZCO57un5LqL5Lu2dmvnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bChrKeiuoeeul+WHuuadpeWQju+8jOaJjeiDveiuoeeul3ZsKGopIOOAglxuIOaWueazleaYr++8muaMieaLk+aJkeaOkuW6j+eahOmAhumhuuW6j++8jOS+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtOOAglxuXG5cbiAyIOaxgkFPReS4reWFs+mUrui3r+W+hOWSjOWFs+mUrua0u+WKqFxuIOKRtCDnrpfms5XmgJ3mg7NcbiDikaAg5Yip55So5ouT5omR5o6S5bqP5rGC5Ye6QU9F572R55qE5LiA5Liq5ouT5omR5bqP5YiX77ybXG4g4pGhICDku47mi5PmiZHmjpLluo/nmoTluo/liJfnmoTnrKzkuIDkuKrpobbngrko5rqQ54K5KeW8gOWni++8jOaMieaLk+aJkemhuuW6j+S+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZlKGkpIO+8m1xuIOKRoiAg5LuO5ouT5omR5o6S5bqP55qE5bqP5YiX55qE5pyA5ZCO5LiA5Liq6aG254K5KOaxh+eCuSnlvIDlp4vvvIzmjInpgIbmi5PmiZHpobrluo/kvp3mrKHorqHnrpfmr4/kuKrkuovku7bnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bChpKSDvvJtcblxuIOiuvkFPRee9keaciW7kuKrkuovku7bvvIxl5Liq5rS75Yqo77yM5YiZ566X5rOV55qE5Li76KaB5omn6KGM5piv77yaXG4g4peGIOi/m+ihjOaLk+aJkeaOkuW6j++8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcbiDil4Yg5rGC5q+P5Liq5LqL5Lu255qEdmXlgLzlkox2bOWAvO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcbiDil4Yg5qC55o2udmXlgLzlkox2bOWAvOaJvuWFs+mUrua0u+WKqO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcbiDlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg44CCXG5cbiAqL1xuXG5cbnZhciBjcml0aWNhbFBhdGhUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YwJyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjEnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MicpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YzJyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjQnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NScpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y2Jyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjcnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2OCcpO1xuXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjEnLCAndjAnLCAzKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MicsICd2MCcsIDEwKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NCcsICd2MScsIDEzKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NCcsICd2MicsIDEyKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MycsICd2MScsIDkpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y1JywgJ3YyJywgNyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjcnLCAndjQnLCA2KTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NycsICd2MycsIDQpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y3JywgJ3Y1JywgMTEpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y2JywgJ3YzJywgOCk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjgnLCAndjcnLCA1KTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2OCcsICd2NicsIDIpO1xuXG5jcml0aWNhbFBhdGhUZXN0LmNyaXRpY2FsUGF0aCgpO1xuXG5cblxuXG52YXIgZGlqVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XG5cbmRpalRlc3QuYWRkVmVydGV4KCcwJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnMScpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzInKTtcbmRpalRlc3QuYWRkVmVydGV4KCczJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnNCcpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzUnKTtcblxuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMCcsIDIwKTtcbmRpalRlc3QuYWRkQXJjKCc0JywgJzAnLCAxMCk7XG5kaWpUZXN0LmFkZEFyYygnMicsICcwJywgNjApO1xuZGlqVGVzdC5hZGRBcmMoJzUnLCAnMCcsIDY1KTtcbmRpalRlc3QuYWRkQXJjKCcyJywgJzEnLCAzMCk7XG5kaWpUZXN0LmFkZEFyYygnMycsICcyJywgNDApO1xuZGlqVGVzdC5hZGRBcmMoJzInLCAnNScsIDE1KTtcbmRpalRlc3QuYWRkQXJjKCc1JywgJzQnLCAyMCk7XG5kaWpUZXN0LmFkZEFyYygnNCcsICczJywgMzUpO1xuZGlqVGVzdC5hZGRBcmMoJzMnLCAnMScsIDcwKTtcblxuZGlqVGVzdC5zaG9ydGVzdFBhdGhfRGlqa3N0cmEoMCk7XG5cblxuKGZ1bmN0aW9uKCl7XG4gICAgLyoqXG4gICAgICog6L6T5Ye65pyJ5ZCR5peg546v5Zu+5b2i5byP6KGo56S655qE6YCG5rOi5YWw5byPXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmlCb0xhbl9EQUcoZ3JhcGgpe1xuICAgICAgICBncmFwaC5jb3VudEluZGVncmVlKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBncmFwaC52ZXhudW07ICsraSl7XG4gICAgICAgICAgICAvLyDmib7liLDmnInlkJHml6Dnjq/lm77nmoTmoLlcbiAgICAgICAgICAgIGlmKGdyYXBoLnZlcnRpY2VzW2ldLmluZGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludE5pQm9MYW4oZ3JhcGgsIGkpe1xuICAgICAgICBsZXQgYyA9IGdyYXBoLnZlcnRpY2VzW2ldLmRhdGE7XG4gICAgICAgIGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7XG5cbiAgICAgICAgLy8g5a2Q6KGo6L6+5byPXG4gICAgICAgIGlmKHApIHtcbiAgICAgICAgICAgIHByaW50TmlCb0xhbihncmFwaCwgcC5hZGpWZXgpO1xuICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBwLm5leHRBcmMuYWRqVmV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uZ5pyJ5ZCR5peg546v5Zu+6KGo56S655qE6KGo6L6+5byP5rGC5YC8XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVfREFHKGdyYXBoKXtcbiAgICAgICAgZ3JhcGguY291bnRJbmRlZ3JlZSgpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZ3JhcGgudmV4bnVtOyArK2kpe1xuICAgICAgICAgICAgaWYoIWdyYXBoLnZlcnRpY2VzW2ldLmluZGVncmVlKSByZXR1cm4gZXZhbHVhdGVfaW1wKGdyYXBoLCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlX2ltcChnLCBpKXtcbiAgICAgICAgaWYoL15cXGQrJC8udGVzdChnLnZlcnRpY2VzW2ldLmRhdGEpKSByZXR1cm4gZy52ZXJ0aWNlc1tpXS5kYXRhO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwID0gZy52ZXJ0aWNlc1tpXS5maXJzdEFyYztcbiAgICAgICAgICAgIGxldCB2MSA9IGV2YWx1YXRlX2ltcChnLCBwLmFkalZleCk7XG4gICAgICAgICAgICBsZXQgdjIgPSBldmFsdWF0ZV9pbXAoZywgcC5uZXh0QXJjLmFkalZleCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlKHYxLCBnLnZlcnRpY2VzW2ldLmRhdGEsIHYyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZShhLCBvcGVyYXRpb24sIGIpe1xuICAgICAgICAvLyDlgbfkuIDkuIvmh5IuLlxuICAgICAgICByZXR1cm4gZXZhbChhICsgb3BlcmF0aW9uICsgYik7XG4gICAgfVxuXG4gICAgLy8gKCgxICsgMikgKiAoMiAqICgzICsgNCkpICsgKDMgKyA0KSAqIDUpICogKCgzICsgNCkgKiA1KVxuICAgIGxldCBkYWcgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XG5cbiAgICBsZXQgYTEgPSBuZXcgU3RyaW5nKCcqJyk7XG4gICAgbGV0IGEyID0gbmV3IFN0cmluZygnKycpO1xuICAgIGxldCBhMyA9IG5ldyBTdHJpbmcoJyonKTtcbiAgICBsZXQgYTQgPSBuZXcgU3RyaW5nKCcqJyk7XG4gICAgbGV0IGE1ID0gbmV3IFN0cmluZygnKycpO1xuICAgIGxldCBhNiA9IG5ldyBTdHJpbmcoJyonKTtcbiAgICBsZXQgYTcgPSBuZXcgU3RyaW5nKCcrJyk7XG5cbiAgICAvLyAxMlxuICAgIGRhZy5hZGRWZXJ0ZXgoYTEpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTIpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTMpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTQpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTUpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTYpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTcpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoMSk7XG4gICAgZGFnLmFkZFZlcnRleCgyKTtcbiAgICBkYWcuYWRkVmVydGV4KDMpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoNCk7XG4gICAgZGFnLmFkZFZlcnRleCg1KTtcblxuICAgIC8vIDE0XG4gICAgZGFnLmFkZEFyYyhhMiwgYTEpO1xuICAgIGRhZy5hZGRBcmMoYTQsIGExKTtcbiAgICBkYWcuYWRkQXJjKGEzLCBhMik7XG4gICAgZGFnLmFkZEFyYyhhNCwgYTIpO1xuICAgIGRhZy5hZGRBcmMoYTUsIGEzKTtcbiAgICBkYWcuYWRkQXJjKGE2LCBhMyk7XG4gICAgZGFnLmFkZEFyYyhhNywgYTYpO1xuICAgIGRhZy5hZGRBcmMoYTcsIGE0KTtcbiAgICBkYWcuYWRkQXJjKDUsIGE0KTtcbiAgICBkYWcuYWRkQXJjKDEsIGE1KTtcbiAgICBkYWcuYWRkQXJjKDIsIGE1KTtcbiAgICBkYWcuYWRkQXJjKDIsIGE2KTtcbiAgICBkYWcuYWRkQXJjKDMsIGE3KTtcbiAgICBkYWcuYWRkQXJjKDQsIGE3KTtcblxuICAgIGNvbnNvbGUubG9nKCduaUJvTGFuX0RBRzogJyk7XG4gICAgbmlCb0xhbl9EQUcoZGFnKTtcbiAgICBjb25zb2xlLmxvZygnZXZhbHVhdGVfREFHOiAnICsgZXZhbHVhdGVfREFHKGRhZykpOyAgLy8gMjY5NVxufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9HcmFwaC9BZGphY2VuY3lMaXN0R3JhcGguanMiLCIvKiBjcmVhdGUgYnkgTHVrZSAqL1xuLyoqXG4gKiDlm74oR3JhcGgpXG4gKlxuICog5Zu+KEdyYXBoKeaYr+S4gOenjeavlOe6v+aAp+ihqOWSjOagkeabtOS4uuWkjeadgueahOaVsOaNrue7k+aehOOAglxuICpcbiAqIOe6v+aAp+e7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueS4gOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOmZpOesrOS4gOS4quWSjOacgOWQjuS4gOS4quWFg+e0oOWklu+8jOS7u+S9leS4gOS4quWFg+e0oOmDveacieWUr+S4gOeahOS4gOS4quebtOaOpeWJjempseWSjOebtOaOpeWQjue7p+OAglxuICpcbiAqIOagkee7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueWkmueahOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOavj+S4quWFg+e0oOWvueS4iyjlsYIp5Y+v5Lul5pyJMOS4quaIluWkmuS4quWFg+e0oOebuOiBlOezu++8jOWvueS4iijlsYIp5Y+q5pyJ5ZSv5LiA55qE5LiA5Liq5YWD57Sg55u45YWz77yM5pWw5o2u5YWD57Sg5LmL6Ze05pyJ5piO5pi+55qE5bGC5qyh5YWz57O744CCXG4gKlxuICog5Zu+57uT5p6E77ya5piv56CU56m25pWw5o2u5YWD57Sg5LmL6Ze055qE5aSa5a+55aSa55qE5YWz57O744CC5Zyo6L+Z56eN57uT5p6E5Lit77yM5Lu75oSP5Lik5Liq5YWD57Sg5LmL6Ze05Y+v6IO95a2Y5Zyo5YWz57O744CC5Y2z57uT54K55LmL6Ze055qE5YWz57O75Y+v5Lul5piv5Lu75oSP55qE77yM5Zu+5Lit5Lu75oSP5YWD57Sg5LmL6Ze06YO95Y+v6IO955u45YWz44CCXG4gKlxuICog5Zu+55qE5bqU55So5p6B5Li65bm/5rOb77yM5bey5riX5YWl5Yiw6K+45aaC6K+t6KiA5a2m44CB6YC76L6R5a2m44CB54mp55CG44CB5YyW5a2m44CB55S16K6v44CB6K6h566X5py656eR5a2m5Lul5Y+K5pWw5a2m55qE5YW25a6D5YiG5pSv44CCXG4gKlxuICog5Zu+55qE5Z+65pys5qaC5b+1XG4gKlxuICog5LiA5Liq5Zu+KEcp5a6a5LmJ5Li65LiA5Liq5YG25a+5KFYsRSkg77yM6K6w5Li6Rz0oVixFKSDjgILlhbbkuK3vvJogVuaYr+mhtueCuShWZXJ0ZXgp55qE6Z2e56m65pyJ6ZmQ6ZuG5ZCI77yM6K6w5Li6VihHKe+8m0XmmK/ml6Dluo/pm4ZWJlbnmoTkuIDkuKrlrZDpm4bvvIzorrDkuLpFKEcpIO+8jOWFtuWFg+e0oOaYr+WbvueahOW8pyhBcmMp44CCXG4gKiDlsIbpobbngrnpm4blkIjkuLrnqbrnmoTlm77np7DkuLrnqbrlm77jgILlhbblvaLlvI/ljJblrprkuYnkuLrvvJpcbiBHPShWIO+8jEUpXG4gVj17dnx24oiIZGF0YSBvYmplY3R9XG4gRT17PHYsdz58IHYsd+KIiFbiiKdwKHYsdyl9XG4gUCh2LHcp6KGo56S65LuO6aG254K5duWIsOmhtueCuXfmnInkuIDmnaHnm7TmjqXpgJrot6/jgIJcbiAqXG4gKiDlvKcoQXJjKSDvvJrooajnpLrkuKTkuKrpobbngrl25ZKMd+S5i+mXtOWtmOWcqOS4gOS4quWFs+ezu++8jOeUqOmhtueCueWBtuWvuTx2LHc+6KGo56S644CC6YCa5bi45qC55o2u5Zu+55qE6aG254K55YG25a+55bCG5Zu+5YiG5Li65pyJ5ZCR5Zu+5ZKM5peg5ZCR5Zu+44CCXG4gKiDmnInlkJHlm74oRGlncmFwaCnvvJog6Iul5Zu+R+eahOWFs+ezu+mbhuWQiEUoRynkuK3vvIzpobbngrnlgbblr7k8dix3PueahHblkox35LmL6Ze05piv5pyJ5bqP55qE77yM56ew5Zu+R+aYr+acieWQkeWbvuOAglxuICogICDlnKjmnInlkJHlm77kuK3vvIzoi6UgPHYsdz7iiIhFKEcpIO+8jOihqOekuuS7jumhtueCuXbliLDpobbngrl35pyJ5LiA5p2h5byn44CCIOWFtuS4re+8mnbnp7DkuLrlvKflsL4odGFpbCnmiJblp4vngrkoaW5pdGlhbCBub2RlKe+8jHfnp7DkuLrlvKflpLQoaGVhZCnmiJbnu4jngrkodGVybWluYWwgbm9kZSkg44CCXG4gKiDml6DlkJHlm74oVW5kaWdyYXBoKe+8miDoi6Xlm75H55qE5YWz57O76ZuG5ZCIRShHKeS4re+8jOmhtueCueWBtuWvuTx2LHc+55qEduWSjHfkuYvpl7TmmK/ml6Dluo/nmoTvvIznp7Dlm75H5piv5peg5ZCR5Zu+44CCXG4gKiAgIOWcqOaXoOWQkeWbvuS4re+8jOiLpe+Aojx2LHc+4oiIRShHKSDvvIzmnIk8dyx2PuKIiEUoRykg77yM5Y2zRShHKeaYr+WvueensO+8jOWImeeUqOaXoOW6j+WvuSh2LHcpIOihqOekunblkox35LmL6Ze055qE5LiA5p2h6L65KEVkZ2Up77yM5Zug5q2kKHYsdykg5ZKMKHcsdinku6PooajnmoTmmK/lkIzkuIDmnaHovrnjgIJcbiAqXG4gKiDkvosx77ya6K6+5pyJ5pyJ5ZCR5Zu+RzHlkozml6DlkJHlm75HMu+8jOW9ouW8j+WMluWumuS5ieWIhuWIq+aYr++8mlxuIEcxPShWMSDvvIxFMSlcbiBWMT17YSxiLGMsZCxlfVxuIEUxPXs8YSxiPiw8YSxjPiwgPGEsZT4sPGMsZD4sPGMsZT4gLDxkLGE+LDxkLGI+LDxlLGQ+fVxuIEcyPShWMiDvvIxFMilcbiBWMj17YSxiLGMsZH1cbiBFMj17KGEsYiksIChhLGMpLCAoYSxkKSwgKGIsZCksIChiLGMpLCAoYyxkKX1cbiAqXG4gKiDlrozlhajml6DlkJHlm77vvJrlr7nkuo7ml6DlkJHlm77vvIzoi6Xlm77kuK3pobbngrnmlbDkuLpuIO+8jOeUqGXooajnpLrovrnnmoTmlbDnm67vvIzliJllIOKIiFsw77yMbihuLTEpLzJdIOOAguWFt+aciW4obi0xKS8y5p2h6L6555qE5peg5ZCR5Zu+56ew5Li65a6M5YWo5peg5ZCR5Zu+44CCXG4g5a6M5YWo5peg5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXG4gKiDlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZqIOKIiFYg77yM5b2TdmniiaB2auaXtu+8jOaciSh2aSAsdmop4oiIRe+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeaXoOWQkei+ue+8jOi/meagt+eahOaXoOWQkeWbvuensOS4uuWujOWFqOaXoOWQkeWbvuOAglxuICpcbiAqIOWujOWFqOacieWQkeWbvu+8muWvueS6juacieWQkeWbvu+8jOiLpeWbvuS4remhtueCueaVsOS4um4g77yM55SoZeihqOekuuW8p+eahOaVsOebru+8jOWImWXiiIhbMO+8jG4obi0xKV0g44CC5YW35pyJbihuLTEp5p2h6L6555qE5pyJ5ZCR5Zu+56ew5Li65a6M5YWo5pyJ5ZCR5Zu+44CCXG4g5a6M5YWo5pyJ5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXG4gKiDlr7nkuo7mnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZq4oiIViDvvIzlvZN2aSDiiaB2auaXtu+8jOaciTx2aSAsdmo+4oiIReKIpzx2aiAsIHZpID7iiIhFIO+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeW8p++8jOi/meagt+eahOacieWQkeWbvuensOS4uuWujOWFqOacieWQkeWbvuOAglxuICpcbiAqIOacieW+iOWwkei+ueaIluW8p+eahOWbvu+8iGU8buOPkm7vvInnmoTlm77np7DkuLrnqIDnlo/lm77vvIzlj43kuYvnp7DkuLrnqKDlr4blm77jgIJcbiAqIOadgyhXZWlnaHQp77ya5LiO5Zu+55qE6L655ZKM5byn55u45YWz55qE5pWw44CC5p2D5Y+v5Lul6KGo56S65LuO5LiA5Liq6aG254K55Yiw5Y+m5LiA5Liq6aG254K555qE6Led56a75oiW6ICX6LS544CCXG4gKlxuICog5a2Q5Zu+5ZKM55Sf5oiQ5a2Q5Zu+77ya6K6+5pyJ5Zu+Rz0oVu+8jEUp5ZKMR+KAmT0oVuKAme+8jEXigJkp77yM6IulVuKAmeKIiFbkuJRF4oCZ4oiIRSDvvIzliJnnp7Dlm75H4oCZ5pivR+eahOWtkOWbvu+8m+iLpVbigJk9VuS4lEXigJniiIhF77yM5YiZ56ew5Zu+R+KAmeaYr0fnmoTkuIDkuKrnlJ/miJDlrZDlm77jgIJcbiAqIOmhtueCueeahOmCu+aOpShBZGphY2VudCnvvJrlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6Xovrkodix3KeKIiEXvvIzliJnnp7Dpobbngrl25ZKMdyDkupLkuLrpgrvmjqXngrnvvIzljbN25ZKMd+ebuOmCu+aOpeOAgui+uSh2LHcp5L6d6ZmEKGluY2lkZW50KeS4jumhtueCuXblkox3IOOAglxuICog5a+55LqO5pyJ5ZCR5Zu+Rz0oViDvvIxFKe+8jOiLpeacieWQkeW8pzx2LHc+4oiIRe+8jOWImeensOmhtueCuXYg4oCc6YK75o6l5Yiw4oCd6aG254K5d++8jOmhtueCuXcg4oCc6YK75o6l6Ieq4oCd6aG254K5diDvvIzlvKc8dix3PiDkuI7pobbngrl25ZKMdyDigJznm7jlhbPogZTigJ0g44CCXG4gKlxuICog6aG254K555qE5bqm44CB5YWl5bqm44CB5Ye65bqm77ya5a+55LqO5peg5ZCR5Zu+Rz0oVu+8jEUp77yMIO+AonZp4oiIVu+8jOWbvkfkuK3kvp3pmYTkuo52aeeahOi+ueeahOaVsOebruensOS4uumhtueCuXZp55qE5bqmKGRlZ3JlZSnvvIzorrDkuLpURCh2aSnjgIJcbiDmmL7nhLbvvIzlnKjml6DlkJHlm77kuK3vvIzmiYDmnInpobbngrnluqbnmoTlkozmmK/lm77kuK3ovrnnmoQy5YCN44CCIOWNsyAgIOKIkVREKHZpKT0yZSAgICAgIGk9MSwgMiwg4oCmLCBuIO+8jGXkuLrlm77nmoTovrnmlbDjgIJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDiiIhWIO+8jOWbvkfkuK3ku6V2aeS9nOS4uui1t+eCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlh7rluqYoT3V0ZGVncmVlKe+8jOiusOS4uk9EKHZpKSDvvJvku6V2aeS9nOS4uue7iOeCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlhaXluqYoSW5kZWdyZWUp77yM6K6w5Li6SUQodmkpIOOAgumhtueCuXZp55qE5Ye65bqm5LiO5YWl5bqm5LmL5ZKM56ew5Li6dmnnmoTluqbvvIzorrDkuLpURCh2aSkg44CC5Y2zXG4gVEQodmkpPU9EKHZpKStJRCh2aSlcbiAqXG4gKiDot6/lvoQoUGF0aCnjgIHot6/lvoTplb/luqbjgIHlm57ot68oQ3ljbGUpIO+8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpeS7jumhtueCuXZp57uP6L+H6Iul5bmy5p2h6L656IO95Yiw6L6+dmrvvIznp7Dpobbngrl2aeWSjHZq5piv6L+e6YCa55qE77yM5Y+I56ew6aG254K5dmnliLB2auaciei3r+W+hOOAglxuIOWvueacieWQkeWbvkc9KFbvvIxFKe+8jOS7jumhtueCuXZp5YiwdmrmnInmnInlkJHot6/lvoTvvIzmjIfnmoTmmK/ku47pobbngrl2aee7j+i/h+iLpeW5suadoeacieWQkei+uSjlvKcp6IO95Yiw6L6+dmrjgIJcbiDmiJbot6/lvoTmmK/lm75H5Lit6L+e5o6l5Lik6aG254K55LmL6Ze05omA57uP6L+H55qE6aG254K55bqP5YiX44CC5Y2zXG4gUGF0aD12aTB2aTHigKZ2aW0g77yMdmlq4oiIVuS4lCh2aWotMSwgdmlqKeKIiEUgICBqPTEsMiwg4oCmLG1cbiDmiJZcbiBQYXRoPXZpMHZpMSDigKZ2aW0g77yMdmlq4oiIVuS4lDx2aWotMSwgdmlqPuKIiEUgIGo9MSwyLCDigKYsbVxuIOi3r+W+hOS4iui+ueaIluacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66K+l6Lev5b6E55qE6ZW/5bqm44CCXG4g5Zyo5LiA5p2h6Lev5b6E5Lit77yM6Iul5rKh5pyJ6YeN5aSN55u45ZCM55qE6aG254K577yM6K+l6Lev5b6E56ew5Li6566A5Y2V6Lev5b6E77yb56ys5LiA5Liq6aG254K55ZKM5pyA5ZCO5LiA5Liq6aG254K555u45ZCM55qE6Lev5b6E56ew5Li65Zue6LevKOeOrynvvJvlnKjkuIDkuKrlm57ot6/kuK3vvIzoi6XpmaTnrKzkuIDkuKrkuI7mnIDlkI7kuIDkuKrpobbngrnlpJbvvIzlhbbkvZnpobbngrnkuI3ph43lpI3lh7rnjrDnmoTlm57ot6/np7DkuLrnroDljZXlm57ot68o566A5Y2V546vKeOAglxuICpcbiAqIOi/numAmuWbvuOAgeWbvueahOi/numAmuWIhumHj++8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZpIO+8jHZqIOKIiFbvvIx2aeWSjHZq6YO95piv6L+e6YCa55qE77yM5YiZ56ew5Zu+R+aYr+i/numAmuWbvu+8jOWQpuWImeensOS4uumdnui/numAmuWbvuOAguiLpUfmmK/pnZ7ov57pgJrlm77vvIzliJnmnoHlpKfnmoTov57pgJrlrZDlm77np7DkuLpH55qE6L+e6YCa5YiG6YeP44CCXG4g5a+55pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74Cidmkg77yMdmog4oiIVu+8jOmDveacieS7pXZp5Li66LW354K577yMIHZqIOS4uue7iOeCueS7peWPiuS7pXZq5Li66LW354K577yMdmnkuLrnu4jngrnnmoTmnInlkJHot6/lvoTvvIznp7Dlm75H5piv5by66L+e6YCa5Zu+77yM5ZCm5YiZ56ew5Li66Z2e5by66L+e6YCa5Zu+44CC6IulR+aYr+mdnuW8uui/numAmuWbvu+8jOWImeaegeWkp+eahOW8uui/numAmuWtkOWbvuensOS4ukfnmoTlvLrov57pgJrliIbph4/jgIJcbiDigJzmnoHlpKfigJ3nmoTlkKvkuYnvvJrmjIfnmoTmmK/lr7nlrZDlm77lho3lop7liqDlm75H5Lit55qE5YW25a6D6aG254K577yM5a2Q5Zu+5bCx5LiN5YaN6L+e6YCa44CCXG4g55Sf5oiQ5qCR44CB55Sf5oiQ5qOu5p6X77ya5LiA5Liq6L+e6YCa5Zu+KOaXoOWQkeWbvinnmoTnlJ/miJDmoJHmmK/kuIDkuKrmnoHlsI/ov57pgJrlrZDlm77vvIzlroPlkKvmnInlm77kuK3lhajpg6hu5Liq6aG254K55ZKM5Y+q5pyJ6Laz5Lul5p6E5oiQ5LiA5qO15qCR55qEbi0x5p2h6L6577yM56ew5Li65Zu+55qE55Sf5oiQ5qCR44CCXG4g5YWz5LqO5peg5ZCR5Zu+55qE55Sf5oiQ5qCR55qE5Yeg5Liq57uT6K6677yaXG4g4peGIOS4gOajteaciW7kuKrpobbngrnnmoTnlJ/miJDmoJHmnInkuJTku4XmnIluLTHmnaHovrnvvJtcbiDil4Yg5aaC5p6c5LiA5Liq5Zu+5pyJbuS4qumhtueCueWSjOWwj+S6jm4tMeadoei+ue+8jOWImeaYr+mdnui/numAmuWbvu+8m1xuIOKXhiDlpoLmnpzlpJrkuo5uLTHmnaHovrnvvIzliJnkuIDlrprmnInnjq/vvJtcbiDil4Yg5pyJbi0x5p2h6L6555qE5Zu+5LiN5LiA5a6a5piv55Sf5oiQ5qCR44CCXG5cbiDmnInlkJHlm77nmoTnlJ/miJDmo67mnpfmmK/ov5nmoLfkuIDkuKrlrZDlm77vvIznlLHoi6XlubLmo7XmnInlkJHmoJHnu4TmiJDvvIzlkKvmnInlm77kuK3lhajpg6jpobbngrnjgIJcbiDmnInlkJHmoJHmmK/lj6rmnInkuIDkuKrpobbngrnnmoTlhaXluqbkuLowIO+8jOWFtuS9memhtueCueeahOWFpeW6puWdh+S4ujHnmoTmnInlkJHlm77jgIJcblxuICpcbiAqIOe9ke+8muavj+S4qui+uSjmiJblvKcp6YO96ZmE5Yqg5LiA5Liq5p2D5YC855qE5Zu+77yM56ew5Li65bim5p2D5Zu+44CC5bim5p2D55qE6L+e6YCa5Zu+KOWMheaLrOW8sei/numAmueahOacieWQkeWbvinnp7DkuLrnvZHmiJbnvZHnu5zjgILnvZHnu5zmmK/lt6XnqIvkuIrluLjnlKjnmoTkuIDkuKrmpoLlv7XvvIznlKjmnaXooajnpLrkuIDkuKrlt6XnqIvmiJbmn5Dnp43mtYHnqItcbiAqL1xuXG4vKipcbiAqIOWbvueahOWtmOWCqOe7k+aehFxuICpcbiDlm77nmoTlrZjlgqjnu5PmnoTmr5TovoPlpI3mnYLvvIzlhbblpI3mnYLmgKfkuLvopoHooajnjrDlnKjvvJpcbiDil4Yg5Lu75oSP6aG254K55LmL6Ze05Y+v6IO95a2Y5Zyo6IGU57O777yM5peg5rOV5Lul5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo5Yy65Lit55qE54mp55CG5L2N572u5p2l6KGo56S65YWD57Sg5LmL6Ze055qE5YWz57O744CCXG4g4peGIOWbvuS4remhtueCueeahOW6puS4jeS4gOagt++8jOacieeahOWPr+iDveebuOW3ruW+iOWkp++8jOiLpeaMieW6puaVsOacgOWkp+eahOmhtueCueiuvuiuoee7k+aehO+8jOWImeS8mua1qui0ueW+iOWkmuWtmOWCqOWNleWFg++8jOWPjeS5i+aMieavj+S4qumhtueCueiHquW3seeahOW6puiuvuiuoeS4jeWQjOeahOe7k+aehO+8jOWPiOS8muW9seWTjeaTjeS9nOOAglxuIOWbvueahOW4uOeUqOeahOWtmOWCqOe7k+aehOacie+8mumCu+aOpeefqemYteOAgemCu+aOpemTvuihqOOAgeWNgeWtl+mTvuihqOOAgemCu+aOpeWkmumHjeihqOWSjOi+ueihqOOAglxuICovXG5cbi8qXG4g6YK75o6l55+p6Zi1KOaVsOe7hCnooajnpLrms5VcblxuIOWfuuacrOaAneaDs++8muWvueS6juaciW7kuKrpobbngrnnmoTlm77vvIznlKjkuIDnu7TmlbDnu4R2ZXhzW25d5a2Y5YKo6aG254K55L+h5oGv77yM55So5LqM57u05pWw57uEQVtuXVtuXeWtmOWCqOmhtueCueS5i+mXtOWFs+ezu+eahOS/oeaBr+OAguivpeS6jOe7tOaVsOe7hOensOS4uumCu+aOpeefqemYteOAguWcqOmCu+aOpeefqemYteS4re+8jOS7pemhtueCueWcqHZleHPmlbDnu4TkuK3nmoTkuIvmoIfku6PooajpobbngrnvvIzpgrvmjqXnn6npmLXkuK3nmoTlhYPntKBBW2ldW2pd5a2Y5pS+55qE5piv6aG254K5aeWIsOmhtueCuWrkuYvpl7TlhbPns7vnmoTkv6Hmga/jgIJcblxuIDEgIOaXoOWQkeWbvueahOaVsOe7hOihqOekulxuXG4gKDEpICDml6DmnYPlm77nmoTpgrvmjqXnn6npmLVcbiDml6DlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIDEgICDoi6UodmkgLCB2ainiiIhF77yM5Y2zdmkgLCB2aumCu+aOpVxuIEFbaV1bal09XG4gICAgICAgICAgICAgLS0gMCAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6lXG5cbiAoMikgIOW4puadg+WbvueahOmCu+aOpeefqemYtVxuIOaXoOWQkeW4puadg+Wbvkc9KFbvvIxFKSDnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIFdpaiAgICDoi6UodmkgLCB2ainiiIhF77yM5Y2zdmkgLCB2aumCu+aOpe+8jOadg+WAvOS4undpalxuIEFbaV1bal09XG5cbiAgICAgICAgICAgIC0tIOKIniAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6l5pe2XG5cbiAoMykgIOaXoOWQkeWbvumCu+aOpeefqemYteeahOeJueaAp1xuIOKXhiDpgrvmjqXnn6npmLXmmK/lr7nnp7DmlrnpmLVcbiDil4Yg5a+55LqO6aG254K5dmnvvIzlhbbluqbmlbDmmK/nrKxp6KGM55qE6Z2eMOWFg+e0oOeahOS4quaVsO+8m1xuIOKXhiDml6DlkJHlm77nmoTovrnmlbDmmK/kuIoo5oiW5LiLKeS4ieinkuW9ouefqemYteS4remdnjDlhYPntKDkuKrmlbDjgIJcblxuIDIgIOacieWQkeWbvueahOaVsOe7hOihqOekulxuXG4gKDEpICDml6DmnYPlm77nmoTpgrvmjqXnn6npmLVcbiDoi6XmnInlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWImeWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhYPntKDlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIDEgICDoi6U8dmksIHZqPuKIiEXvvIzku452aeWIsHZq5pyJ5bynXG4gQVtpXVtqXT1cbiAgICAgICAgICAgIC0tIDAgICDoi6U8dmkgLCB2aj7iiIlFICDku452aeWIsHZqIOayoeacieW8p1xuXG4gKDIpICDluKbmnYPlm77nmoTpgrvmjqXnn6npmLVcbiDmnInlkJHluKbmnYPlm75HPShW77yMRSnnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIHdpaiAgICDoi6U8dmksdmo+4oiIRe+8jOWNs3ZpICwgdmrpgrvmjqXvvIzmnYPlgLzkuLp3aWpcbiBBW2ldW2pdPVxuICAgICAgICAgICAg4oieICAg6IulPHZpLHZqPuKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6l5pe2XG5cbiDikbYg5pyJ5ZCR5Zu+6YK75o6l55+p6Zi155qE54m55oCnXG4g4peGIOWvueS6jumhtueCuXZp77yM56ysaeihjOeahOmdnjDlhYPntKDnmoTkuKrmlbDmmK/lhbblh7rluqZPRCh2aSnvvJvnrKxp5YiX55qE6Z2eMOWFg+e0oOeahOS4quaVsOaYr+WFtuWFpeW6pklEKHZpKSDjgIJcbiDil4Yg6YK75o6l55+p6Zi15Lit6Z2eMOWFg+e0oOeahOS4quaVsOWwseaYr+WbvueahOW8p+eahOaVsOebruOAglxuXG4gMyAg5Zu+55qE6YK75o6l55+p6Zi155qE5pON5L2cXG5cbiDlm77nmoTpgrvmjqXnn6npmLXnmoTlrp7njrDmr5TovoPlrrnmmJPvvIzlrprkuYnkuKTkuKrmlbDnu4TliIbliKvlrZjlgqjpobbngrnkv6Hmga8o5pWw5o2u5YWD57SgKeWSjOi+ueaIluW8p+eahOS/oeaBryjmlbDmja7lhYPntKDkuYvpl7TnmoTlhbPns7spIOOAglxuXG4gKi9cblxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XG5pbXBvcnQgeyBDaGlsZFNpYmxpbmdUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcblxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XG5jb25zdCBERyA9IDE7ICAgICAvLyDmnInlkJHlm75cbmNvbnN0IEROID0gMjsgICAgIC8vIOacieWQkee9kVxuY29uc3QgVURHID0gMzsgICAgLy8g5peg5ZCR5Zu+XG5jb25zdCBVRE4gPSA0OyAgICAvLyDml6DlkJHnvZFcblxuXG5jbGFzcyBBcmNDZWxsIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhZGpcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGosIGluZm8gPSBudWxsKXtcbiAgICAgICAgLy8g6aG254K557G75Z6L44CC5a+55LqO5peg5p2D5Zu+77yM55SoMeaIljDooajnpLrnm7jpgrvlkKbvvJvlr7nluKbmnYPlm77vvIzliJnkuLrmnYPlgLznsbvlnotcbiAgICAgICAgdGhpcy5hZGogPSB0eXBlb2YgYWRqID09PSAnbnVtYmVyJyA/IGFkaiA6IEluZmluaXR5O1xuICAgICAgICAvLyDor6XlvKfnm7jlhbPkv6Hmga9cbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRqYWNlbmN5TWF0cml4R3JhcGgge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmV4cyDpobbngrnlkJHph49cbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgQXJjQ2VsbH0gYXJjcyDpgrvmjqXnn6npmLVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmV4bnVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyY251bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBraW5kXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmV4cyA9IFtdLCBhcmNzID0gW10sIHZleG51bSA9IDAsIGFyY251bSA9IDAsIGtpbmQgPSBERyl7XG4gICAgICAgIC8vIOmhtueCueWQkemHj1xuICAgICAgICB0aGlzLnZleHMgPSB2ZXhzO1xuICAgICAgICAvLyDpgrvmjqXnn6npmLVcbiAgICAgICAgdGhpcy5hcmNzID0gYXJjcztcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWwXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xuICAgICAgICAvLyDlm77nmoTlvZPliY3lvKfmlbBcbiAgICAgICAgdGhpcy5hcmNudW0gPSBhcmNudW07XG4gICAgICAgIC8vIOWbvueahOenjeexu+agh+W/l1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cblxuICAgIGNyZWF0ZUdyYXBoKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgICAgICAgY2FzZSBERzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlREcodGhpcyk7ICAgICAvLyDmnoTpgKDmnInlkJHlm75cbiAgICAgICAgICAgIGNhc2UgRE46XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUROKHRoaXMpOyAgICAgLy8g5p6E6YCg5pyJ5ZCR572RXG4gICAgICAgICAgICBjYXNlIFVERzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVURHKHRoaXMpOyAgICAvLyDmnoTpgKDml6DlkJHlm75cbiAgICAgICAgICAgIGNhc2UgVUROOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVRE4odGhpcyk7ICAgIC8vIOaehOmAoOaXoOWQkee9kVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+mdnuacieaViOeahOWbvuexu+WeiycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p+l5om+6aG254K5XG4gICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxvY2F0ZVZleCAodnApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXhzW2ldID09PSB2cCkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5ZCR5Zu+5Lit5aKe5Yqg6aG254K5XG4gICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cbiAgICAgKi9cbiAgICBhZGRWZXJ0ZXgodnApIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYXRlVmV4KHZwKSAhPT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBoYXMgZXhpc3RlZCEnKTtcblxuICAgICAgICBsZXQgayA9IHRoaXMudmV4bnVtO1xuICAgICAgICB0aGlzLnZleHNbdGhpcy52ZXhudW0rK10gPSB2cDtcblxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmtpbmQgPT09IERHIHx8IHRoaXMua2luZCA9PT0gVURHID9cbiAgICAgICAgICAgIDAgOiBJbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICB0aGlzLmFyY3Nbal0gPSB0aGlzLmFyY3Nbal0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmFyY3Nba10gPSB0aGlzLmFyY3Nba10gfHwgW107XG4gICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10gPSB0aGlzLmFyY3Nbal1ba10gfHwgbmV3IEFyY0NlbGwoKTtcbiAgICAgICAgICAgIHRoaXMuYXJjc1trXVtqXSA9IHRoaXMuYXJjc1trXVtqXSB8fCBuZXcgQXJjQ2VsbCgpO1xuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmFkaiA9IHRoaXMuYXJjc1trXVtqXS5hZGogPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWQkeWbvuS4reWinuWKoOS4gOadoeW8p1xuICAgICAqIEBwYXJhbSB7Kn0gdmV4MSDpobbngrkx5ZCR6YePXG4gICAgICogQHBhcmFtIHsqfSB2ZXgyIOmhtueCuTLlkJHph49cbiAgICAgKiBAcGFyYW0ge0FyY0NlbGx9IGFyY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFkZEFyYyh2ZXgxLCB2ZXgyLCBhcmMpIHtcbiAgICAgICAgYXJjID0gYXJjIHx8IG5ldyBBcmNDZWxsKHRoaXMua2luZCA9PT0gREcgfHwgdGhpcy5raW5kID09PSBVREcgPyAxIDogJ3dlaWdodCcpO1xuICAgICAgICBsZXQgayA9IHRoaXMubG9jYXRlVmV4KHZleDEpO1xuICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KHZleDIpO1xuXG4gICAgICAgIGlmIChrID09PSAtMSB8fCBqID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgdGhpcy5hcmNzW2tdW2pdLmFkaiA9IGFyYy5hZGo7XG4gICAgICAgIHRoaXMuYXJjc1trXVtqXS5pbmZvID0gYXJjLmluZm87XG4gICAgICAgIC8vIOaXoOWQkeWbvuaIluaXoOWQkee9kVxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5hZGogPSBhcmMuYWRqO1xuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmluZm8gPSBhcmMuaW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgICsrdGhpcy5hcmNudW07XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yig6Zmk6aG254K5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZleCDopoHliKDpmaTnmoTpobbngrlcbiAgICAgKi9cbiAgICBkZWxldGVWZXgodmV4KSB7XG4gICAgICAgIGxldCBuID0gdGhpcy52ZXhudW0gLSAxO1xuICAgICAgICBsZXQgbSA9IHRoaXMubG9jYXRlVmV4KHZleCk7XG5cbiAgICAgICAgaWYgKG0gPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8g5bCG5b6F5Yig6Zmk6aG254K55Lqk5o2i5Yiw5pyA5ZCO5LiA5Liq6aG254K5XG4gICAgICAgIGxldCB0ZW1wID0gdGhpcy52ZXhzW21dO1xuICAgICAgICB0aGlzLnZleHNbbV0gPSB0aGlzLnZleHNbbl07XG4gICAgICAgIHRoaXMudmV4c1tuXSA9IHRlbXA7XG5cbiAgICAgICAgLy8g5bCG6L6555qE5YWz57O76ZqP5LmL5Lqk5o2iXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hcmNzW2ldW21dID0gdGhpcy5hcmNzW2ldW25dO1xuICAgICAgICAgICAgdGhpcy5hcmNzW21dW2ldID0gdGhpcy5hcmNzW25dW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcmNzW21dW21dLmFkaiA9IDA7XG4gICAgICAgIHRoaXMudmV4cy5sZW5ndGggPSAtLXRoaXMudmV4bnVtO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliKDpmaTovrkodiwgdylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZGVsZXRlQXJjKHYsIHcpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleCh3KTtcblxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5hcmNzW2ldW2pdLmFkaikge1xuICAgICAgICAgICAgdGhpcy5hcmNzW2ldW2pdLmFkaiA9IDA7XG4gICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8g5Yik5pat5LiA5Liq6YK75o6l55+p6Zi15a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXG4gICAgaXNQYXNzKCkge1xuICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52ZXhudW07ICsreCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnZleG51bTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t4XVt5XSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMudmV4bnVtOyArK3opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuYXJjc1t5XVt6XSAmJiAhdGhpcy5hcmNzW3hdW3pdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmaXJzdEFkalZleCh2KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtpXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gSW5maW5pdHkpIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIG5leHRBZGpWZXgodiwgdykge1xuICAgICAgICBmb3IgKGxldCBpID0gdyArIDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSBJbmZpbml0eSkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8g5a+56YK75o6l55+p6Zi15Zu+5L2c6YCS5b2S5byP5rex5bqm5LyY5YWI6YGN5Y6GXG4gICAgREZTVHJhdmVyc2UodmlzaXRGbikge1xuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xuICAgICAgICAvLyDorr/pl67moIflv5fmlbDnu4TliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnModGhpcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHZlcnRleCkge1xuICAgICAgICAgICAgdmlzaXRlZFt2ZXJ0ZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChncmFwaCwgdmVydGV4KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaC52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaC5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSAwICYmIGdyYXBoLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICYmICF2aXNpdGVkW2pdKSBkZnMoZ3JhcGgsIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6Z2e6YCS5b2SXG4gICAgREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICAvLyDorr/pl67moIflv5fmlbDnu4TliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChtZSwgaSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlICgodmVydGV4ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwobWUsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlr7npgrvmjqXnn6npmLXlm77kvZzlub/luqbkvJjlhYjpgY3ljoZcbiAgICBCRlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHF1ZXVlLmRlUXVldWUoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbdV1bal0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t1XVtqXS5hZGogIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1pblNwYW5UcmVlX1BSSU0odSkge1xuICAgICAgICBsZXQgY2xvc2VkZ2UgPSBbXTtcblxuICAgICAgICAvLyDliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICBjbG9zZWRnZVtqXSA9IHthZGp2ZXg6IHUsIGxvd2Nvc3Q6ICt0aGlzLmFyY3Nbal1bdV0uYWRqfTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZWRnZVt1XS5sb3djb3N0ID0gMDtcblxuICAgICAgICBsZXQgdGUgPSBbXTtcbiAgICAgICAgLy8g6YCJ5oup5YW25L2ZdGhpcy52ZXhudW0gLSAx5Liq6aG254K5XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW0gLSAxOyArK2opIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBrO1xuICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZGdlW3ZdLmxvd2Nvc3QgIT09IDAgJiYgY2xvc2VkZ2Vbdl0ubG93Y29zdCA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjbG9zZWRnZVt2XS5sb3djb3N0O1xuICAgICAgICAgICAgICAgICAgICBrID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlW2pdID0ge1xuICAgICAgICAgICAgICAgIHZleDE6IGNsb3NlZGdlW2tdLmFkanZleCxcbiAgICAgICAgICAgICAgICB2ZXgyOiBrLFxuICAgICAgICAgICAgICAgIHdlaWdodDogY2xvc2VkZ2Vba10ubG93Y29zdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsb3NlZGdlW2tdLmxvd2Nvc3QgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtrXS5hZGogPCBjbG9zZWRnZVt2XS5sb3djb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZGdlW3ZdLmxvd2Nvc3QgPSB0aGlzLmFyY3Nbdl1ba10uYWRqO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZWRnZVt2XS5hZGp2ZXggPSBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZTtcbiAgICB9XG5cbiAgICBtaW5TcGFuVHJlZV9LcnVza2FsKCkge1xuICAgICAgICBsZXQgc2V0ID0gW107XG4gICAgICAgIGxldCB0ZSA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSBzZXRbaV0gPSBpO1xuXG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgICAgICBsZXQgYSA9IDA7XG4gICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgd2hpbGUoayA8IHRoaXMudmV4bnVtIC0gMSl7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBqID0gaSArIDE7IGogPCB0aGlzLnZleG51bTsgKytqKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmNzW2ldW2pdLmFkaiA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdGhpcy5hcmNzW2ldW2pdLmFkajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNldFthXSAhPT0gc2V0W2JdKXtcbiAgICAgICAgICAgICAgICB0ZVtrKytdID0ge1xuICAgICAgICAgICAgICAgICAgICB2ZXgxOiBhLFxuICAgICAgICAgICAgICAgICAgICB2ZXgyOiBiLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXMuYXJjc1thXVtiXS5hZGpcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpe1xuICAgICAgICAgICAgICAgICAgICBpZihzZXRbaV0gPT09IHNldFtiXSAmJiBpICE9PSBiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0W2ldID0gc2V0W2FdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRbYl0gPSBzZXRbYV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbiA9IHRoaXMuYXJjc1thXVtiXS5hZGogPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnlKhEaWprc3RyYeeul+azleaxguacieWQkee9keeahHYw6aG254K55Yiw5YW25L2Z6aG254K5dueahOacgOefrei3r+W+hHByZVt2XeWPiuWFtuW4puadg+mVv+W6pmRpc3Rbdl3jgIJcbiAgICAgKiDoi6VwcmVbdl1bd13kuLp0cnVl77yM5YiZd+aYr+S7jnYw5YiwduW9k+WJjeaxguW+l+acgOefrei3r+W+hOS4iueahOmhtueCueOAglxuICAgICAqIGZpbmFsW3Zd5Li6dHJ1ZeW9k+S4lOS7heW9k3biiIhT77yM5Y2z5bey57uP5rGC5b6XdjDliLB255qE5pyA55+t6Lev5b6EXG4gICAgICogQHBhcmFtIHYwXG4gICAgICovXG4gICAgc2hvcnRlc3RQYXRoX0RpamtzdHJhKHYwKSB7XG4gICAgICAgIGxldCBwcmUgPSBbXTtcbiAgICAgICAgbGV0IGRpc3QgPSBbXTtcbiAgICAgICAgbGV0IGZpbmFsID0gW107XG4gICAgICAgIGxldCB3LCB2O1xuXG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xuICAgICAgICAgICAgZmluYWxbdl0gPSBmYWxzZTtcbiAgICAgICAgICAgIGRpc3Rbdl0gPSB0aGlzLmFyY3NbdjBdW3ZdLmFkajtcbiAgICAgICAgICAgIHByZVt2XSA9IHByZVt2XSB8fCBbXTtcbiAgICAgICAgICAgIC8vIOiuvuepuui3r+W+hFxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHByZVt2XVt3XSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3Rbdl0gPCBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZVt2XVt2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDliJ3lp4vljJbvvIx2MOmhtueCueWxnuS6jlPpm4ZcbiAgICAgICAgZGlzdFt2MF0gPSAwO1xuICAgICAgICBmaW5hbFt2MF0gPSB0cnVlO1xuXG4gICAgICAgIC8vIOW8gOWni+S4u+W+queOr++8jOavj+asoeaxguW+l3Yw5Yiw5p+Q5LiqdumhtueCueeahOacgOefrei3r+W+hO+8jOW5tuWKoHbliLBT6ZuGXG5cbiAgICAgICAgLy8g5YW25L2Z55qE6aG254K5XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgLy8g5b2T5YmN5omA5oyH56a7djDpobbngrnnmoTmnIDov5Hot53nprtcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XG4gICAgICAgICAgICAgICAgLy8gd+mhtueCueWcqFYgLSBT5LitXG4gICAgICAgICAgICAgICAgLy8g5LiUd+mhtueCueemu3Yw6aG254K55pu06L+RXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBkaXN0W3ddIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0W3ddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g56a7djDpobbngrnmnIDov5HnmoR25Yqg5YWlU+mbhlxuICAgICAgICAgICAgZmluYWxbdl0gPSB0cnVlO1xuICAgICAgICAgICAgLy8g5pu05paw5b2T5YmN5pyA55+t6Lev5b6E5Y+K6Led56a7XG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgbWluICsgdGhpcy5hcmNzW3ZdW3ddLmFkaiA8IGRpc3Rbd10pIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdFt3XSA9IG1pbiArIHRoaXMuYXJjc1t2XVt3XS5hZGo7XG4gICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddW3ddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhmaW5hbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHByZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGRpc3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaW5hbDogZmluYWwsXG4gICAgICAgICAgICBwcmU6IHByZSxcbiAgICAgICAgICAgIGRpc3Q6IGRpc3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaG9ydGVzdFBhdGhfRkxPWUQoKSB7XG4gICAgICAgIGxldCBhID0gW107XG4gICAgICAgIGxldCBwYXRoID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICBhW2pdID0gYVtqXSB8fCBbXTtcbiAgICAgICAgICAgIHBhdGhbal0gPSBwYXRoW2pdIHx8IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICAgICAgaWYoaiA9PT0gaykgYVtqXVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZSBhW2pdW2tdID0gdGhpcy5hcmNzW2pdW2tdLmFkajtcbiAgICAgICAgICAgICAgICBwYXRoW2pdW2tdID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtqXVttXSArIGFbbV1ba10gPCBhW2pdW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2pdW2tdID0gYVtqXVttXSArIGFbbV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoW2pdW2tdID0gbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogIT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVk5YiwJWTnmoTmnIDnn63ot6/lvoTkuLrvvJonLCBqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIGopOyBwcm5fcGFzcyhqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIGspO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn5pyA55+t6Lev5b6E6ZW/5bqm5Li677yaICVkJywgYVtqXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJuX3Bhc3Moaiwgaykge1xuICAgICAgICAgICAgaWYgKHBhdGhbal1ba10gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJuX3Bhc3MoaiwgcGF0aFtqXVtrXSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJywgJWQnLCBwYXRoW2pdW2tdKTtcbiAgICAgICAgICAgICAgICBwcm5fcGFzcyhwYXRoW2pdW2tdLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IGNyZWF0ZURHID0gY3JlYXRlR3JhcGgoREcpO1xubGV0IGNyZWF0ZUROID0gY3JlYXRlR3JhcGgoRE4pO1xubGV0IGNyZWF0ZVVERyA9IGNyZWF0ZUdyYXBoKFVERyk7XG5sZXQgY3JlYXRlVUROID0gY3JlYXRlR3JhcGgoVUROKTtcblxuZnVuY3Rpb24gY3JlYXRlR3JhcGgoa2luZCkge1xuICAgIGxldCBhZGo7XG4gICAgbGV0IHNldE1hdHJpeFZhbHVlO1xuXG4gICAgaWYgKGtpbmQgPT09IDIgfHwga2luZCA9PT0gNCkge1xuICAgICAgICBhZGogPSBJbmZpbml0eTtcbiAgICAgICAgc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbXB0KCd3ZWlnaHQ6ICcpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkaiA9IDA7XG4gICAgICAgIHNldE1hdHJpeFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChBZGphY2VuY3lNYXRyaXhHcmFwaCkge1xuICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW0gPSBwYXJzZUludChwcm9tcHQoJ3ZleG51bTogJyksIDEwKTtcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtID0gcGFyc2VJbnQocHJvbXB0KCdhcmNudW06ICcpLCAxMCk7XG4gICAgICAgIC8vIGluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXG4gICAgICAgIGxldCBpbmNJbmZvID0gcGFyc2VJbnQocHJvbXB0KCdpbmNJbmZvOiAnKSwgMTApO1xuXG4gICAgICAgIC8vIOaehOmAoOmhtueCueWQkemHj1xuICAgICAgICBsZXQgaSwgajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bTsgKytpKSBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhzW2ldID0gcHJvbXB0KCfpobbngrnlkJHph492ZXg6ICcpO1xuXG4gICAgICAgIC8vIOWIneWni+WMlumCu+aOpeefqemYtVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV0gPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldIHx8IFtdO1xuICAgICAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal0gPSBuZXcgQXJjQ2VsbChhZGosIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5p6E6YCg6YK75o6l55+p6Zi1XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtOyArK2spIHtcbiAgICAgICAgICAgIC8vIOi+k+WFpeS4gOadoei+ueS+nemZhOeahOmhtueCueWPiuadg+WAvFxuICAgICAgICAgICAgbGV0IHYxID0gcHJvbXB0KCd2MTogJyk7XG4gICAgICAgICAgICBsZXQgdjIgPSBwcm9tcHQoJ3YyOiAnKTtcblxuICAgICAgICAgICAgLy8g56Gu5a6adjHvvIx2MuWcqEfkuK3nmoTkvY3nva5cbiAgICAgICAgICAgIGkgPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5sb2NhdGVWZXgodjEpO1xuICAgICAgICAgICAgaiA9IEFkamFjZW5jeU1hdHJpeEdyYXBoLmxvY2F0ZVZleCh2Mik7XG5cbiAgICAgICAgICAgIGxldCB3ID0gc2V0TWF0cml4VmFsdWUoKTtcbiAgICAgICAgICAgIC8vIOW8pzx2MSwgdjI+55qE5p2D5YC8XG4gICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdLmFkaiA9IHc7XG4gICAgICAgICAgICBpZiAoaW5jSW5mbykgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXS5pbmZvID0gcHJvbXB0KCdpbmZvOiAnKTtcbiAgICAgICAgICAgIGlmIChraW5kID09PSAzIHx8IGtpbmQgPT09IDQpIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3Nbal1baV0gPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8g56ys5LiA56eN5Yib5bu65Zu+5pa55rOVXG5sZXQgdmV4cyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG5sZXQgYXJjcyA9IFtcbiAgICBbXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfVxuICAgIF0sXG4gICAgW1xuICAgICAgICB7XCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH1cbiAgICBdLFxuICAgIFtcbiAgICAgICAge1wiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9XG4gICAgXSxcbiAgICBbXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsfVxuICAgIF0sXG4gICAgW1xuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH1cbiAgICBdXG5dO1xubGV0IHVkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaCh2ZXhzLCBhcmNzLCA1LCA3LCA0KTtcblxuLy8g56ys5LqM56eN5Yib5bu65Zu+5pa55rOVXG5sZXQgZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCAyKTtcbmRuLmFkZFZlcnRleCgnYScpO1xuZG4uYWRkVmVydGV4KCdiJyk7XG5kbi5hZGRWZXJ0ZXgoJ2MnKTtcbmRuLmFkZFZlcnRleCgnZCcpO1xuZG4uYWRkVmVydGV4KCdlJyk7XG5cbmRuLmFkZEFyYygnYScsICdiJywge1xuICAgIGFkajogNlxufSk7XG5kbi5hZGRBcmMoJ2EnLCAnYycsIHtcbiAgICBhZGo6IDJcbn0pO1xuZG4uYWRkQXJjKCdjJywgJ2InLCB7XG4gICAgYWRqOiAzXG59KTtcbmRuLmFkZEFyYygnYycsICdkJywge1xuICAgIGFkajogMVxufSk7XG5kbi5hZGRBcmMoJ2QnLCAnYicsIHtcbiAgICBhZGo6IDRcbn0pO1xuZG4uYWRkQXJjKCdiJywgJ2UnLCB7XG4gICAgYWRqOiAzXG59KTtcbmRuLmFkZEFyYygnZCcsICdlJywge1xuICAgIGFkajogNVxufSk7XG5cbmNvbnNvbGUubG9nKGRuKTtcblxuLypcblxuIC8vIOesrOS4ieenjeWIm+W7uuWbvuaWueazlVxuIGxldCBnID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKCk7XG4gZy5raW5kID0gRE47XG4gZy5jcmVhdGVHcmFwaCgpO1xuIGNvbnNvbGUubG9nKGcpO1xuXG4gKi9cblxuXG5cblxuLypcbiDlm77nmoTpgY3ljoZcblxuIOWbvueahOmBjeWOhihUcmF2ZXJpbmcgR3JhcGgp77ya5LuO5Zu+55qE5p+Q5LiA6aG254K55Ye65Y+R77yM6K6/6YGN5Zu+5Lit55qE5YW25L2Z6aG254K577yM5LiU5q+P5Liq6aG254K55LuF6KKr6K6/6Zeu5LiA5qyh44CC5Zu+55qE6YGN5Y6G566X5rOV5piv5ZCE56eN5Zu+55qE5pON5L2c55qE5Z+656GA44CCXG5cbiDil4Yg5aSN5p2C5oCn77ya5Zu+55qE5Lu75oSP6aG254K55Y+v6IO95ZKM5YW25L2Z55qE6aG254K555u46YK75o6l77yM5Y+v6IO95Zyo6K6/6Zeu5LqG5p+Q5Liq6aG254K55ZCO77yM5rK/5p+Q5p2h6Lev5b6E5pCc57Si5ZCO5Y+I5Zue5Yiw5Y6f6aG254K544CCXG4g4peGIOino+WGs+WKnuazle+8muWcqOmBjeWOhui/h+eoi+S4reiusOS4i+W3suiiq+iuv+mXrui/h+eahOmhtueCueOAguiuvue9ruS4gOS4qui+heWKqeWQkemHj1Zpc2l0ZWRbMeKApm5dKG7kuLrpobbngrnmlbAp77yM5YW25Yid5YC85Li6MO+8jOS4gOaXpuiuv+mXruS6humhtueCuXZp5ZCO77yM5L2/VmlzaXRlZFtpXeS4ujHmiJbkuLrorr/pl67nmoTmrKHluo/lj7fjgIJcbiDlm77nmoTpgY3ljobnrpfms5XmnInmt7HluqbkvJjlhYjmkJzntKLnrpfms5Xlkozlub/luqbkvJjlhYjmkJzntKLnrpfms5XjgIJcblxuIOa3seW6puS8mOWFiOaQnOe0oihEZXB0aCBGaXJzdCBTZWFyY2gtLURGUynpgY3ljobnsbvkvLzmoJHnmoTlhYjluo/pgY3ljobvvIzmmK/moJHnmoTlhYjluo/pgY3ljobnmoTmjqjlub/jgIJcblxuIOeul+azleaAneaDs1xuIOiuvuWIneWni+eKtuaAgeaXtuWbvuS4reeahOaJgOaciemhtueCueacquiiq+iuv+mXru+8jOWIme+8mlxuIOKRtCDvvJrku47lm77kuK3mn5DkuKrpobbngrl2aeWHuuWPke+8jOiuv+mXrnZp77yb54S25ZCO5om+5YiwdmnnmoTkuIDkuKrpgrvmjqXpobbngrl2aTEg77ybXG4g4pG177ya5LuOdmkx5Ye65Y+R77yM5rex5bqm5LyY5YWI5pCc57Si6K6/6Zeu5ZKMdmkx55u46YK75o6l5LiU5pyq6KKr6K6/6Zeu55qE5omA5pyJ6aG254K577ybXG4g4pG277ya6L2s4pG0IO+8jOebtOWIsOWSjHZp55u46YK75o6l55qE5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2iXG4g4pG3IO+8mue7p+e7remAieWPluWbvuS4reacquiiq+iuv+mXrumhtueCuXZq5L2c5Li66LW35aeL6aG254K577yM6L2sKDEp77yM55u05Yiw5Zu+5Lit5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2i44CCXG5cblxuIOW5v+W6puS8mOWFiOaQnOe0oihCcmVhZHRoIEZpcnN0IFNlYXJjaC0tQkZTKemBjeWOhuexu+S8vOagkeeahOaMieWxguasoemBjeWOhueahOi/h+eoi+OAglxuXG4g566X5rOV5oCd5oOzXG4g6K6+5Yid5aeL54q25oCB5pe25Zu+5Lit55qE5omA5pyJ6aG254K55pyq6KKr6K6/6Zeu77yM5YiZ77yaXG4g4pG0IO+8muS7juWbvuS4reafkOS4qumhtueCuXZp5Ye65Y+R77yM6K6/6ZeudmnvvJtcbiDikbXvvJrorr/pl652aeeahOaJgOacieebuOmCu+aOpeS4lOacquiiq+iuv+mXrueahOaJgOaciemhtueCuXZpMe+8jHZpMu+8jOKApu+8jHZpbe+8m1xuIOKRtu+8muS7pXZpMe+8jHZpMu+8jCDigKbvvIx2aW3nmoTmrKHluo/vvIzku6V2aWooMeKJpmriiaZtKeS+neatpOS9nOS4unZpIO+8jOi9rOKRtO+8m1xuIOKRtyDvvJrnu6fnu63pgInlj5blm77kuK3mnKrooqvorr/pl67pobbngrl2a+S9nOS4uui1t+Wni+mhtueCue+8jOi9rOKRtO+8jOebtOWIsOWbvuS4reaJgOaciemhtueCuemDveiiq+iuv+mXruS4uuatouOAglxuXG4g55So5bm/5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+5LiO5rex5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+55qE5ZSv5LiA5Yy65Yir5piv6YK75o6l54K55pCc57Si5qyh5bqP5LiN5ZCMLlxuICovXG5cblxuXG5jb25zb2xlLmxvZygnREZTVHJhdmVyc2U6IHVkbicpO1xuXG5sZXQgZzEgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBVREcpO1xuZzEuYWRkVmVydGV4KCd2MScpO1xuZzEuYWRkVmVydGV4KCd2MycpO1xuZzEuYWRkVmVydGV4KCd2MicpO1xuZzEuYWRkVmVydGV4KCd2NCcpO1xuZzEuYWRkVmVydGV4KCd2NScpO1xuXG5nMS5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5nMS5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5nMS5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nMS5hZGRBcmMoJ3YzJywgJ3YyJyk7XG5cblxuZzEuREZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xufSk7XG5cblxuXG5cbmNvbnNvbGUubG9nKCdERlNUcmF2ZXJzZV9Ob25SZWN1cnNlOiB1ZG4nKTtcbmcxLkRGU1RyYXZlcnNlX05vblJlY3Vyc2UoZnVuY3Rpb24gKHYpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xufSk7XG5cblxuXG5cbmNvbnNvbGUubG9nKCdCRlNUcmF2ZXJzZTogJyk7XG5sZXQgYnNmRyA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIERHKTtcbmJzZkcuYWRkVmVydGV4KCd2MScpO1xuYnNmRy5hZGRWZXJ0ZXgoJ3YyJyk7XG5ic2ZHLmFkZFZlcnRleCgndjMnKTtcbmJzZkcuYWRkVmVydGV4KCd2NCcpO1xuYnNmRy5hZGRWZXJ0ZXgoJ3Y1Jyk7XG5cbmJzZkcuYWRkQXJjKCd2MScsICd2NCcpO1xuYnNmRy5hZGRBcmMoJ3YxJywgJ3YyJyk7XG5ic2ZHLmFkZEFyYygndjMnLCAndjUnKTtcbmJzZkcuYWRkQXJjKCd2MycsICd2MicpO1xuYnNmRy5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5ic2ZHLmFkZEFyYygndjQnLCAndjMnKTtcbmJzZkcuYWRkQXJjKCd2NScsICd2NCcpO1xuXG5ic2ZHLkJGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XG4gICAgY29uc29sZS5sb2codGhpcy52ZXhzW3ZdKTtcbn0pO1xuXG5cblxuXG4vKlxuIOacgOWwj+eUn+aIkOagkVxuXG4g5aaC5p6c6L+e6YCa5Zu+5piv5LiA5Liq5bim5p2D5Zu+77yM5YiZ5YW255Sf5oiQ5qCR5Lit55qE6L655Lmf5bim5p2D77yM55Sf5oiQ5qCR5Lit5omA5pyJ6L6555qE5p2D5YC85LmL5ZKM56ew5Li655Sf5oiQ5qCR55qE5Luj5Lu344CCXG5cbiDmnIDlsI/nlJ/miJDmoJEoTWluaW11bSBTcGFubmluZyBUcmVlKSDvvJrluKbmnYPov57pgJrlm77kuK3ku6Pku7fmnIDlsI/nmoTnlJ/miJDmoJHnp7DkuLrmnIDlsI/nlJ/miJDmoJHjgIJcblxuIOacgOWwj+eUn+aIkOagkeWcqOWunumZheS4reWFt+aciemHjeimgeeUqOmAlO+8jOWmguiuvuiuoemAmuS/oee9keOAguiuvuWbvueahOmhtueCueihqOekuuWfjuW4gu+8jOi+ueihqOekuuS4pOS4quWfjuW4guS5i+mXtOeahOmAmuS/oee6v+i3r++8jOi+ueeahOadg+WAvOihqOekuuW7uumAoOmAmuS/oee6v+i3r+eahOi0ueeUqOOAgm7kuKrln47luILkuYvpl7TmnIDlpJrlj6/ku6Xlu7pu74K0KG4tMSkvMuadoee6v+i3r++8jOWmguS9lemAieaLqeWFtuS4reeahG4tMeadoe+8jOS9v+aAu+eahOW7uumAoOi0ueeUqOacgOS9jj9cblxuIOaehOmAoOacgOWwj+eUn+aIkOagkeeahOeul+azleacieiuuOWkmu+8jOWfuuacrOWOn+WImeaYr++8mlxuIOKXhiDlsL3lj6/og73pgInlj5bmnYPlgLzmnIDlsI/nmoTovrnvvIzkvYbkuI3og73mnoTmiJDlm57ot6/vvJtcbiDil4Yg6YCJ5oupbi0x5p2h6L655p6E5oiQ5pyA5bCP55Sf5oiQ5qCR44CCXG4g5Lul5LiK55qE5Z+65pys5Y6f5YiZ5piv5Z+65LqOTVNU55qE5aaC5LiL5oCn6LSo77yaXG4g6K6+Rz0oVu+8jEUp5piv5LiA5Liq5bim5p2D6L+e6YCa5Zu+77yMVeaYr+mhtueCuembhlbnmoTkuIDkuKrpnZ7nqbrlrZDpm4bjgILoi6V14oiIVSDvvIx24oiIVi1V77yM5LiUKHUsIHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOWImeW/heWtmOWcqOS4gOajteWMheWQq+i+uSh1LCB2KeeahOacgOWwj+eUn+aIkOagkeOAglxuXG4g6K+B5piO77yaIOeUqOWPjeivgeazleivgeaYjuOAglxuIOiuvuWbvkfnmoTku7vkvZXkuIDmo7XmnIDlsI/nlJ/miJDmoJHpg73kuI3ljIXlkKvovrkodSx2KeOAguiuvlTmmK9H55qE5LiA5qO155Sf5oiQ5qCR77yM5YiZVOaYr+i/numAmueahO+8jOS7jnXliLB25b+F5pyJ5LiA5p2h6Lev5b6EKHUs4oCmLHYp77yM5b2T5bCG6L65KHUsdinliqDlhaXliLBU5Lit5pe25bCx5p6E5oiQ5LqG5Zue6Lev44CC5YiZ6Lev5b6EKHUsIOKApix2KeS4reW/heacieS4gOadoei+uSh14oCZLHbigJkpIO+8jOa7oei2s3XigJniiIhVIO+8jHbigJniiIhWLVUg44CC5Yig5Y676L65KHXigJksduKAmSkg5L6/5Y+v5raI6Zmk5Zue6Lev77yM5ZCM5pe25b6X5Yiw5Y+m5LiA5qO155Sf5oiQ5qCRVOKAmeOAglxuIOeUseS6jih1LHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOaVhSh1LHYp55qE5p2D5YC85LiN5Lya6auY5LqOKHXigJksduKAmSnnmoTmnYPlgLzvvIxU4oCZ55qE5Luj5Lu35Lmf5LiN5Lya6auY5LqOVO+8jCBU4oCZ5piv5YyF5ZCrKHUsdikg55qE5LiA5qO15pyA5bCP55Sf5oiQ5qCR77yM5LiO5YGH6K6+55+b55u+44CCXG5cbiAqL1xuXG4vKlxuIOaZrumHjOWnhihQcmltKeeul+azlVxuXG4g6YCC5ZCI6L6556ig5a+G55qE572RXG5cbiDku47ov57pgJrnvZFOPShV77yMRSnkuK3mib7mnIDlsI/nlJ/miJDmoJFUPShV77yMVEUpIOOAglxuXG4gMSDnrpfms5XmgJ3mg7NcbiDikbQgIOiLpeS7jumhtueCuXYw5Ye65Y+R5p6E6YCg77yMVT17djB977yMVEU9e33vvJtcbiDikbUg5YWI5om+5p2D5YC85pyA5bCP55qE6L65KHXvvIx2Ke+8jOWFtuS4rXXiiIhV5LiUduKIiFYtVe+8jOW5tuS4lOWtkOWbvuS4jeaehOaIkOeOr++8jOWImVU9IFXiiKp7dn3vvIxURT1UReKIqnsode+8jHYpfSDvvJtcbiDikbYg6YeN5aSN4pG1IO+8jOebtOWIsFU9VuS4uuatouOAguWImVRF5Lit5b+F5pyJbi0x5p2h6L6577yMIFQ9KFXvvIxURSnlsLHmmK/mnIDlsI/nlJ/miJDmoJHjgIJcblxuIDIu566X5rOV5a6e546w6K+05piOXG4g5Li65L6/5LqO566X5rOV5a6e546w77yM6K6+572u5LiA5Liq5LiA57u05pWw57uEY2xvc2VkZ2Vbbl3vvIznlKjmnaXkv53lrZhWLSBV5Lit5ZCE6aG254K55YiwVeS4remhtueCueWFt+acieadg+WAvOacgOWwj+eahOi+ueOAglxuIGNsb3NlZGdlW2pdLmFkanZleD1r77yM6KGo5piO6L65KHZqLCB2aynmmK9WLVXkuK3pobbngrl2auWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIzogIzpobbngrl2a+aYr+ivpei+ueaJgOS+nemZhOeahFXkuK3nmoTpobbngrnjgIIgY2xvc2VkZ2Vbal0ubG93Y29zdOWtmOaUvuivpei+ueeahOadg+WAvOOAglxuIOWBh+iuvuS7jumhtueCuXZz5byA5aeL5p6E6YCg5pyA5bCP55Sf5oiQ5qCR44CC5Yid5aeL5pe25Luk77yaXG4gQ2xvc2VkZ2Vbc10ubG93Y29zdD0wIO+8muihqOaYjumhtueCuXZz6aaW5YWI5Yqg5YWl5YiwVeS4re+8m1xuIENsb3NlZGdlW2tdLmFkanZleD1zIO+8jENsb3NlZGdlW2tdLmxvd2Nvc3Q9Y29zdChrLCBzKVxuIOihqOekulYtVeS4reeahOWQhOmhtueCueWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrkoa+KJoHMpIO+8jGNvc3QoaywgcynooajnpLrovrkodmssIHZzKSDmnYPlgLzjgIJcblxuIDMu566X5rOV5q2l6aqkXG4g4pG0ICDku45jbG9zZWRnZeS4remAieaLqeS4gOadoeadg+WAvCjkuI3kuLowKeacgOWwj+eahOi+uSh2aywgdmopIO+8jOeEtuWQjuWBmu+8mlxuIOKRoCDnva5jbG9zZWRnZVtrXS5sb3djb3N05Li6MCDvvIzooajnpLp2a+W3suWKoOWFpeWIsFXkuK3jgIJcbiDikaEgIOagueaNruaWsOWKoOWFpXZr55qE5pu05pawY2xvc2VkZ2XkuK3mr4/kuKrlhYPntKDvvJpcbiDvgKJ2aeKIiFYtVSDvvIzoi6Vjb3N0KGksIGsp4ommY29sc2VkZ2VbaV0ubG93Y29zdO+8jOihqOaYjuWcqFXkuK3mlrDliqDlhaXpobbngrl2a+WQju+8jCAodmksIHZrKeaIkOS4unZp5YiwVeS4readg+WAvOacgOWwj+eahOi+ue+8jOe9ru+8mlxuIENsb3NlZGdlW2ldLmxvd2Nvc3Q9Y29zdChpLCBrKVxuIENsb3NlZGdlW2ldLmFkanZleD1rXG4g4pG1ICDph43lpI3ikbRuLTHmrKHlsLHlvpfliLDmnIDlsI/nlJ/miJDmoJHjgIJcblxuIOeul+azleWIhuaekO+8mlxuIOiuvuW4puadg+i/numAmuWbvuaciW7kuKrpobbngrnvvIzliJnnrpfms5XnmoTkuLvopoHmiafooYzmmK/kuozph43lvqrnjq/vvJog5rGCY2xvc2VkZ2XkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIzpopHluqbkuLpuLTHvvJsg5L+u5pS5Y2xvc2VkZ2XmlbDnu4TvvIzpopHluqbkuLpuIOOAguWboOatpO+8jOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08objIp77yM5LiO6L6555qE5pWw55uu5peg5YWz44CCXG5cbiAqL1xuXG51ZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCA0KTtcbnVkbi5hZGRWZXJ0ZXgoJ3YxJyk7XG51ZG4uYWRkVmVydGV4KCd2MicpO1xudWRuLmFkZFZlcnRleCgndjMnKTtcbnVkbi5hZGRWZXJ0ZXgoJ3Y0Jyk7XG51ZG4uYWRkVmVydGV4KCd2NScpO1xudWRuLmFkZFZlcnRleCgndjYnKTtcblxudWRuLmFkZEFyYygndjEnLCAndjInLCB7YWRqOiA2fSk7XG51ZG4uYWRkQXJjKCd2MScsICd2MycsIHthZGo6IDF9KTtcbnVkbi5hZGRBcmMoJ3YxJywgJ3Y0Jywge2FkajogNX0pO1xudWRuLmFkZEFyYygndjInLCAndjMnLCB7YWRqOiA1fSk7XG51ZG4uYWRkQXJjKCd2MicsICd2NScsIHthZGo6IDN9KTtcbnVkbi5hZGRBcmMoJ3YzJywgJ3Y0Jywge2FkajogNX0pO1xudWRuLmFkZEFyYygndjMnLCAndjUnLCB7YWRqOiA2fSk7XG51ZG4uYWRkQXJjKCd2MycsICd2NicsIHthZGo6IDR9KTtcbnVkbi5hZGRBcmMoJ3Y0JywgJ3Y2Jywge2FkajogMn0pO1xudWRuLmFkZEFyYygndjUnLCAndjYnLCB7YWRqOiA2fSk7XG5cbmNvbnNvbGUubG9nKCdtaW5TcGFuVHJlZV9QUklNOiAnKTtcbmNvbnNvbGUubG9nKHVkbi5taW5TcGFuVHJlZV9QUklNKDApKTtcblxuXG5cbi8qXG4g5YWL6bKB5pav5Y2h5bCUKEtydXNrYWwp566X5rOVXG5cbiDpgILlkIjovrnnqIDnlo/nmoTnvZFcblxuIDEg566X5rOV5oCd5oOzXG4g6K6+Rz0oViwgRSnmmK/lhbfmnIlu5Liq6aG254K555qE6L+e6YCa572R77yMVD0oVSwgVEUp5piv5YW25pyA5bCP55Sf5oiQ5qCR44CC5Yid5YC877yaVT1W77yMVEU9e30g44CCXG4g5a+5R+S4reeahOi+ueaMieadg+WAvOWkp+Wwj+S7juWwj+WIsOWkp+S+neasoemAieWPluOAglxuIOKRtCAgIOmAieWPluadg+WAvOacgOWwj+eahOi+uSh2ae+8jHZqKe+8jOiLpei+uSh2ae+8jHZqKeWKoOWFpeWIsFRF5ZCO5b2i5oiQ5Zue6Lev77yM5YiZ6IiN5byD6K+l6L65KOi+uSh2ae+8jHZqKSDvvJvlkKbliJnvvIzlsIbor6XovrnlubblhaXliLBUReS4re+8jOWNs1RFPVRF4oiqeyh2ae+8jHZqKX0g44CCXG4g4pG1IOmHjeWkjeKRtCDvvIznm7TliLBUReS4reWMheWQq+aciW4tMeadoei+ueS4uuatouOAglxuIOWmguWbvjctMjLmiYDmj5DnpLrjgIJcblxuIDIg566X5rOV5a6e546w6K+05piOXG4gS3J1c2thbOeul+azleWunueOsOeahOWFs+mUruaYr++8muW9k+S4gOadoei+ueWKoOWFpeWIsFRF55qE6ZuG5ZCI5ZCO77yM5aaC5L2V5Yik5pat5piv5ZCm5p6E5oiQ5Zue6LevP1xuIOeugOWNleeahOino+WGs+aWueazleaYr++8muWumuS5ieS4gOS4quS4gOe7tOaVsOe7hFZzZXRbbl0g77yM5a2Y5pS+5Zu+VOS4reavj+S4qumhtueCueaJgOWcqOeahOi/numAmuWIhumHj+eahOe8luWPt+OAglxuIOKXhiDliJ3lgLzvvJpWc2V0W2ldPWnvvIzooajnpLrmr4/kuKrpobbngrnlkIToh6rnu4TmiJDkuIDkuKrov57pgJrliIbph4/vvIzov57pgJrliIbph4/nmoTnvJblj7fnroDljZXlnLDkvb/nlKjpobbngrnlnKjlm77kuK3nmoTkvY3nva4o57yW5Y+3KeOAglxuIOKXhiDlvZPlvoBU5Lit5aKe5Yqg5LiA5p2h6L65KHZp77yMdmopIOaXtu+8jOWFiOajgOafpVZzZXRbaV3lkoxWc2V0W2pd5YC877yaXG4g4piGIOiLpVZzZXRbaV09VnNldFtqXe+8muihqOaYjnZp5ZKMdmrlpITlnKjlkIzkuIDkuKrov57pgJrliIbph4/kuK3vvIzliqDlhaXmraTovrnkvJrlvaLmiJDlm57ot6/vvJtcbiDimIYg6IulVnNldFtpXeKJoFZzZXRbal3vvIzliJnliqDlhaXmraTovrnkuI3kvJrlvaLmiJDlm57ot6/vvIzlsIbmraTovrnliqDlhaXliLDnlJ/miJDmoJHnmoTovrnpm4bkuK3jgIJcbiDil4Yg5Yqg5YWl5LiA5p2h5paw6L655ZCO77yM5bCG5Lik5Liq5LiN5ZCM55qE6L+e6YCa5YiG6YeP5ZCI5bm277ya5bCG5LiA5Liq6L+e6YCa5YiG6YeP55qE57yW5Y+35o2i5oiQ5Y+m5LiA5Liq6L+e6YCa5YiG6YeP55qE57yW5Y+344CCXG5cbiAqL1xuXG5jb25zb2xlLmxvZygnbWluU3BhblRyZWVfS3J1c2thbDogJyk7XG5jb25zb2xlLmxvZyh1ZG4ubWluU3BhblRyZWVfS3J1c2thbCgpKTtcblxuXG5cblxuLypcbiDmnIDnn63ot6/lvoRcblxuIOiLpeeUqOW4puadg+WbvuihqOekuuS6pOmAmue9ke+8jOWbvuS4remhtueCueihqOekuuWcsOeCue+8jOi+ueS7o+ihqOS4pOWcsOS5i+mXtOacieebtOaOpemBk+i3r++8jOi+ueS4iueahOadg+WAvOihqOekuui3r+eoiyjmiJbmiYDoirHotLnnlKjmiJbml7bpl7QpIOOAguS7juS4gOS4quWcsOaWueWIsOWPpuS4gOS4quWcsOaWueeahOi3r+W+hOmVv+W6puihqOekuuivpei3r+W+hOS4iuWQhOi+ueeahOadg+WAvOS5i+WSjOOAgumXrumimO+8mlxuIOKXhiDkuKTlnLDkuYvpl7TmmK/lkKbmnInpgJrot68/XG4g4peGIOWcqOacieWkmuadoemAmui3r+eahOaDheWGteS4i++8jOWTquadoeacgOefrT9cbiDogIPomZHliLDkuqTpgJrnvZHnmoTmnInlkJHmgKfvvIznm7TmjqXorqjorrrnmoTmmK/luKbmnYPmnInlkJHlm77nmoTmnIDnn63ot6/lvoTpl67popjvvIzkvYbop6PlhrPpl67popjnmoTnrpfms5XkuZ/pgILnlKjkuo7ml6DlkJHlm77jgIJcbiDlsIbkuIDkuKrot6/lvoTnmoTotbflp4vpobbngrnnp7DkuLrmupDngrnvvIzmnIDlkI7kuIDkuKrpobbngrnnp7DkuLrnu4jngrnjgIJcblxuXG4g5Y2V5rqQ54K55pyA55+t6Lev5b6EXG5cbiDlr7nkuo7nu5nlrprnmoTmnInlkJHlm75HPShW77yMRSnlj4rljZXkuKrmupDngrlWc++8jOaxglZz5YiwR+eahOWFtuS9meWQhOmhtueCueeahOacgOefrei3r+W+hOOAglxuIOmSiOWvueWNlea6kOeCueeahOacgOefrei3r+W+hOmXrumimO+8jERpamtzdHJh5o+Q5Ye65LqG5LiA56eN5oyJ6Lev5b6E6ZW/5bqm6YCS5aKe5qyh5bqP5Lqn55Sf5pyA55+t6Lev5b6E55qE566X5rOV77yM5Y2z6L+q5p2w5pav54m55ouJKERpamtzdHJhKeeul+azleOAglxuXG4gMSDln7rmnKzmgJ3mg7NcbiDku47lm77nmoTnu5nlrprmupDngrnliLDlhbblroPlkITkuKrpobbngrnkuYvpl7TlrqLop4LkuIrlupTlrZjlnKjkuIDmnaHmnIDnn63ot6/lvoTvvIzlnKjov5nnu4TmnIDnn63ot6/lvoTkuK3vvIzmjInlhbbplb/luqbnmoTpgJLlop7mrKHluo/vvIzkvp3mrKHmsYLlh7rliLDkuI3lkIzpobbngrnnmoTmnIDnn63ot6/lvoTlkozot6/lvoTplb/luqbjgIJcbiDljbPmjInplb/luqbpgJLlop7nmoTmrKHluo/nlJ/miJDlkITpobbngrnnmoTmnIDnn63ot6/lvoTvvIzljbPlhYjmsYLlh7rplb/luqbmnIDlsI/nmoTkuIDmnaHmnIDnn63ot6/lvoTvvIznhLblkI7msYLlh7rplb/luqbnrKzkuozlsI/nmoTmnIDnn63ot6/lvoTvvIzkvp3mraTnsbvmjqjvvIznm7TliLDmsYLlh7rplb/luqbmnIDplb/nmoTmnIDnn63ot6/lvoTjgIJcblxuIDIg566X5rOV5oCd5oOz6K+05piOXG4g6K6+57uZ5a6a5rqQ54K55Li6VnPvvIxT5Li65bey5rGC5b6X5pyA55+t6Lev5b6E55qE57uI54K56ZuG77yM5byA5aeL5pe25LukUz17VnN9IOOAguW9k+axguW+l+esrOS4gOadoeacgOefrei3r+W+hChWcyDvvIxWaSnlkI7vvIxT5Li6e1Zz77yMVml9IOOAguagueaNruS7peS4i+e7k+iuuuWPr+axguS4i+S4gOadoeacgOefrei3r+W+hOOAglxuIOiuvuS4i+S4gOadoeacgOefrei3r+W+hOe7iOeCueS4ulZqIO+8jOWImVZq5Y+q5pyJ77yaXG4g4peGICDmupDngrnliLDnu4jngrnmnInnm7TmjqXnmoTlvKc8VnPvvIxWaj7vvJtcbiDil4Yg5LuOVnMg5Ye65Y+R5YiwVmog55qE6L+Z5p2h5pyA55+t6Lev5b6E5omA57uP6L+H55qE5omA5pyJ5Lit6Ze06aG254K55b+F5a6a5ZyoU+S4reOAguWNs+WPquaciei/meadoeacgOefrei3r+W+hOeahOacgOWQjuS4gOadoeW8p+aJjeaYr+S7jlPlhoXmn5DkuKrpobbngrnov57mjqXliLBT5aSW55qE6aG254K5Vmog44CCXG4g6Iul5a6a5LmJ5LiA5Liq5pWw57uEZGlzdFtuXe+8jOWFtuavj+S4qmRpc3RbaV3liIbph4/kv53lrZjku45WcyDlh7rlj5HkuK3pl7Tlj6rnu4/ov4fpm4blkIhT5Lit55qE6aG254K56ICM5Yiw6L6+VmnnmoTmiYDmnInot6/lvoTkuK3plb/luqbmnIDlsI/nmoTot6/lvoTplb/luqblgLzvvIzliJnkuIvkuIDmnaHmnIDnn63ot6/lvoTnmoTnu4jngrlWauW/heWumuaYr+S4jeWcqFPkuK3kuJTlgLzmnIDlsI/nmoTpobbngrnvvIzljbPvvJpcbiBkaXN0W2ldPU1pbnsgZGlzdFtrXXwgVmviiIhWLVMgfVxuIOWIqeeUqOS4iui/sOWFrOW8j+WwseWPr+S7peS+neasoeaJvuWHuuS4i+S4gOadoeacgOefrei3r+W+hOOAglxuXG4gMyAg566X5rOV5q2l6aqkXG4g4pGgIOS7pFM9e1ZzfSDvvIznlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIzlr7nlm77kuK3mr4/kuKrpobbngrlWaeaMieS7peS4i+WOn+WImee9ruWIneWAvO+8mlxuIDAgICAgaSA9c1xuIGRpc3RbaV0gPSAgIFdzaSAgICAgaeKJoHPkuJQ8dnMsdmk+4oiIRe+8jCB3c2nkuLrlvKfkuIrnmoTmnYPlgLxcbiDiiJ4gICBp4omgc+S4lDx2cyx2aT7kuI3lsZ7kuo5FXG4g4pGhIOmAieaLqeS4gOS4qumhtueCuVZqIO+8jOS9v+W+l++8mlxuIGRpc3Rbal09TWlueyBkaXN0W2tdfCBWa+KIiFYtUyB9XG4gVmrlsLHmmK/msYLlvpfnmoTkuIvkuIDmnaHmnIDnn63ot6/lvoTnu4jngrnvvIzlsIZWaiDlubblhaXliLBT5Lit77yM5Y2zUz1T4oiqe1ZqfSDjgIJcbiDikaIg5a+5Vi1T5Lit55qE5q+P5Liq6aG254K5Vmsg77yM5L+u5pS5ZGlzdFtrXe+8jOaWueazleaYr++8mlxuIOiLpWRpc3Rbal0rV2prPGRpc3Rba13vvIzliJnkv67mlLnkuLrvvJpcbiBkaXN0W2tdPWRpc3Rbal0rV2prICjvgKJWa+KIiFYtUyApXG4g4pGjIOmHjeWkjeKRoe+8jOKRou+8jOebtOWIsFM9VuS4uuatouOAglxuXG4gNCDnrpfms5Xlrp7njrBcbiDnlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIwg5a+5UHJpbeeul+azleeVpeWKoOaUueWKqOWwseaIkOS6hkRpamtzdHJh566X5rOV77yM5bCGUHJpbeeul+azleS4reaxguavj+S4qumhtueCuVZr55qEbG93Y29zdOWAvOeUqGRpc3Rba13ku6Pmm7/ljbPlj6/jgIJcbiDil4YgIOiuvuaVsOe7hHByZVtuXeS/neWtmOS7jlZz5Yiw5YW25a6D6aG254K555qE5pyA55+t6Lev5b6E44CC6IulcHJlW2ldPWvvvIzooajnpLrku45WcyDliLBWaeeahOacgOefrei3r+W+hOS4re+8jFZp55qE5YmN5LiA5Liq6aG254K55pivVmvvvIzljbPmnIDnn63ot6/lvoTluo/liJfmmK8oVnMgLCDigKYsIFZrICAsIFZpKSDjgIJcbiDil4Yg6K6+5pWw57uEZmluYWxbbl3vvIzmoIfor4bkuIDkuKrpobbngrnmmK/lkKblt7LliqDlhaVT5Lit44CCXG5cbiA1ICDnrpfms5XliIbmnpBcbiBEaWprc3RyYeeul+azleeahOS4u+imgeaJp+ihjOaYr++8mlxuIOKXhiDmlbDnu4Tlj5jph4/nmoTliJ3lp4vljJbvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4pIO+8m1xuIOKXhiDmsYLmnIDnn63ot6/lvoTnmoTkuozph43lvqrnjq/vvJrml7bpl7TlpI3mnYLluqbmmK9PKG4yKSDvvJtcbiDlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4yKSDjgIJcblxuICovXG5cbmxldCBkaWpUZXN0ID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgRE4pO1xuXG5kaWpUZXN0LmFkZFZlcnRleCgnMCcpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzEnKTtcbmRpalRlc3QuYWRkVmVydGV4KCcyJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnMycpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzQnKTtcbmRpalRlc3QuYWRkVmVydGV4KCc1Jyk7XG5cbmRpalRlc3QuYWRkQXJjKCcwJywgJzEnLCB7YWRqOiAyMH0pO1xuZGlqVGVzdC5hZGRBcmMoJzAnLCAnNCcsIHthZGo6IDEwfSk7XG5kaWpUZXN0LmFkZEFyYygnMCcsICcyJywge2FkajogNjB9KTtcbmRpalRlc3QuYWRkQXJjKCcwJywgJzUnLCB7YWRqOiA2NX0pO1xuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMicsIHthZGo6IDMwfSk7XG5kaWpUZXN0LmFkZEFyYygnMicsICczJywge2FkajogNDB9KTtcbmRpalRlc3QuYWRkQXJjKCc1JywgJzInLCB7YWRqOiAxNX0pO1xuZGlqVGVzdC5hZGRBcmMoJzQnLCAnNScsIHthZGo6IDIwfSk7XG5kaWpUZXN0LmFkZEFyYygnMycsICc0Jywge2FkajogMzV9KTtcbmRpalRlc3QuYWRkQXJjKCcxJywgJzMnLCB7YWRqOiA3MH0pO1xuXG5kaWpUZXN0LnNob3J0ZXN0UGF0aF9EaWprc3RyYSgwKTtcblxuXG5cblxuXG4vKlxuIOavj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hFxuXG4g55SoRGlqa3N0cmHnrpfms5XkuZ/lj6/ku6XmsYLlvpfmnInlkJHlm75HPShW77yMRSnkuK3mr4/kuIDlr7npobbngrnpl7TnmoTmnIDnn63ot6/lvoTjgILmlrnms5XmmK/vvJrmr4/mrKHku6XkuIDkuKrkuI3lkIznmoTpobbngrnkuLrmupDngrnph43lpI1EaWprc3RyYeeul+azleS+v+WPr+axguW+l+avj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hO+8jOaXtumXtOWkjeadguW6puaYr08objMpIOOAglxuXG4g5byX572X5LyK5b63KEZsb3lkKeaPkOWHuuS6huWPpuS4gOS4queul+azle+8jOWFtuaXtumXtOWkjeadguW6puS7jeaYr08objMpIO+8jCDkvYbnrpfms5XlvaLlvI/mm7TkuLrnroDmmI7jgIJcblxuIDEg566X5rOV5oCd5oOzXG5cbiDorr7pobbngrnpm4ZTKOWIneWAvOS4uuepuinvvIznlKjmlbDnu4RB55qE5q+P5Liq5YWD57SgQVtpXVtqXeS/neWtmOS7jlZp5Y+q57uP6L+HU+S4reeahOmhtueCueWIsOi+vlZq55qE5pyA55+t6Lev5b6E6ZW/5bqm77yM5YW25oCd5oOz5piv77yaXG4g4pGgIOWIneWni+aXtuS7pFM9eyB9IO+8jCBBW2ldW2pd55qE6LWL5Yid5YC85pa55byP5piv77yaXG4gMCAgICBpID1q5pe2XG4gQVtpXVtqXT0gICAgV2lqICAgICBp4omgauS4lDx2aSx2aj7iiIhF77yMIHdpauS4uuW8p+S4iueahOadg+WAvFxuIOKIniAgIGniiaBq5LiUPHZpLHZqPuS4jeWxnuS6jkVcbiDikaEg5bCG5Zu+5Lit5LiA5Liq6aG254K5Vmsg5Yqg5YWl5YiwU+S4re+8jOS/ruaUuUFbaV1bal3nmoTlgLzvvIzkv67mlLnmlrnms5XmmK/vvJpcbiBBW2ldW2pdPU1pbntBW2ldW2pdICwgKEFbaV1ba10rQVtrXVtqXSkgfVxuIOWOn+WboO+8miDku45WauWPque7j+i/h1PkuK3nmoTpobbngrkoVmsp5Yiw6L6+VmrnmoTot6/lvoTplb/luqblj6/og73mr5Tljp/mnaXkuI3nu4/ov4dWa+eahOi3r+W+hOabtOefreOAglxuIOKRoiDph43lpI3ikaHvvIznm7TliLBH55qE5omA5pyJ6aG254K56YO95Yqg5YWl5YiwU+S4reS4uuatouOAglxuXG4gMiDnrpfms5Xlrp7njrBcblxuIOKXhiAg5a6a5LmJ5LqM57u05pWw57uEUGF0aFtuXVtuXShu5Li65Zu+55qE6aG254K55pWwKSDvvIzlhYPntKBQYXRoW2ldW2pd5L+d5a2Y5LuOVmnliLBWaueahOacgOefrei3r+W+hOaJgOe7j+i/h+eahOmhtueCueOAglxuIOKXhiDoi6VQYXRoW2ldW2pdPWvvvJrku45WaeWIsFZqIOe7j+i/h1ZrIO+8jOacgOefrei3r+W+hOW6j+WIl+aYryhWaSAsIOKApiwgVmsgLCDigKYsIFZqKSDvvIzliJnot6/lvoTlrZDluo/liJfvvJooVmkgLCDigKYsIFZrKeWSjChWayAsIOKApiwgVmop5LiA5a6a5piv5LuOVmnliLBWa+WSjOS7jlZr5YiwVmog55qE5pyA55+t6Lev5b6E44CC5LuO6ICM5Y+v5Lul5qC55o2uUGF0aFtpXVtrXeWSjFBhdGhba11bal3nmoTlgLzlho3mib7liLDor6Xot6/lvoTkuIrmiYDnu4/ov4fnmoTlhbblroPpobbngrnvvIzigKbkvp3mraTnsbvmjqjjgIJcbiDil4Yg5Yid5aeL5YyW5Li6UGF0aFtpXVtqXT0tMe+8jOihqOekuuS7jlZp5YiwVmog5LiN57uP6L+H5Lu75L2VKFPkuK3nmoTkuK3pl7Qp6aG254K544CC5b2T5p+Q5Liq6aG254K5VmvliqDlhaXliLBT5Lit5ZCO5L2/QVtpXVtqXeWPmOWwj+aXtu+8jOS7pFBhdGhbaV1bal09a+OAglxuXG5cbiAqL1xuXG5sZXQgZmxveWQgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YwJyk7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YxJyk7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YyJyk7XG5mbG95ZC5hZGRBcmMoJ3YwJywgJ3YyJywge2FkajogOH0pO1xuZmxveWQuYWRkQXJjKCd2MCcsICd2MScsIHthZGo6IDJ9KTtcbmZsb3lkLmFkZEFyYygndjEnLCAndjInLCB7YWRqOiA0fSk7XG5mbG95ZC5hZGRBcmMoJ3YyJywgJ3YwJywge2FkajogNX0pO1xuXG5mbG95ZC5zaG9ydGVzdFBhdGhfRkxPWUQoKTtcblxuLy8gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1L2FydGljbGUvZGV0YWlscy83NzE5NDI4XG4vLyDmt7vliqDjgIrlm77nmoTlupTnlKjor6bop6Mt5pWw5o2u57uT5p6E44CLXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoLmpzIiwiLypcbiDljYHlrZfpk77ooajms5VcblxuIOWNgeWtl+mTvuihqChPcnRob2dvbmFsIExpc3Qp5piv5pyJ5ZCR5Zu+55qE5Y+m5LiA56eN6ZO+5byP5a2Y5YKo57uT5p6E77yM5piv5bCG5pyJ5ZCR5Zu+55qE5q2j6YK75o6l6KGo5ZKM6YCG6YK75o6l6KGo57uT5ZCI6LW35p2l5b6X5Yiw55qE5LiA56eN6ZO+6KGo44CCXG5cbiDlnKjov5nnp43nu5PmnoTkuK3vvIzmr4/mnaHlvKfnmoTlvKflpLTnu5PngrnlkozlvKflsL7nu5Pngrnpg73lrZjmlL7lnKjpk77ooajkuK3vvIzlubblsIblvKfnu5PngrnliIbliKvnu4Tnu4fliLDku6XlvKflsL7nu5PngrnkuLrlpLQo6aG254K5Kee7k+eCueWSjOS7peW8p+WktOe7k+eCueS4uuWktCjpobbngrkp57uT54K555qE6ZO+6KGo5Lit44CCXG5cbiDil4YgIGRhdGHln5/vvJrlrZjlgqjlkozpobbngrnnm7jlhbPnmoTkv6Hmga/vvJtcbiDil4Yg5oyH6ZKI5Z+fZmlyc3Rpbu+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WktOeahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xuIOKXhiDmjIfpkojln59maXJzdG91dO+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WwvueahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xuIOKXhiDlsL7ln590YWlsdmV477ya5oyH56S65byn5bC+6aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXG4g4peGIOWktOWfn2hlYWR2ZXjvvJrmjIfnpLrlvKflpLTpobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcbiDil4Yg5oyH6ZKI5Z+faGxpbmvvvJrmjIflkJHlvKflpLTnm7jlkIznmoTkuIvkuIDmnaHlvKfvvJtcbiDil4Yg5oyH6ZKI5Z+fdGxpbmvvvJrmjIflkJHlvKflsL7nm7jlkIznmoTkuIvkuIDmnaHlvKfvvJtcbiDil4YgSW5mb+Wfn++8muaMh+WQkeivpeW8p+eahOebuOWFs+S/oeaBr++8m1xuXG4g5LuO6L+Z56eN5a2Y5YKo57uT5p6E5Zu+5Y+v5Lul55yL5Ye677yM5LuO5LiA5Liq6aG254K557uT54K555qEZmlyc3RvdXTlh7rlj5HvvIzmsr/ooajnu5PngrnnmoR0bGlua+aMh+mSiOaehOaIkOS6huato+mCu+aOpeihqOeahOmTvuihqOe7k+aehO+8jOiAjOS7juS4gOS4qumhtueCuee7k+eCueeahGZpcnN0aW7lh7rlj5HvvIzmsr/ooajnu5PngrnnmoRobGlua+aMh+mSiOaehOaIkOS6humAhumCu+aOpeihqOeahOmTvuihqOe7k+aehOOAglxuXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlYWRWZXgg5byn55qE5aS06aG254K555qE5L2N572uXG4gKiBAcGFyYW0ge051bWJlcn0gdGFpbFZleCDlvKfnmoTlsL7pobbngrnkvY3nva5cbiAqIEBwYXJhbSB7QXJjQm94fSBoTGluayDlvKflpLTnm7jlkIznmoTlvKfnmoTpk77ln59cbiAqIEBwYXJhbSB7QXJjQm94fSB0TGluayDlvKflsL7nm7jlkIznmoTlvKfnmoTpk77ln59cbiAqIEBwYXJhbSB7Kn0gaW5mb1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFyY0JveCh0YWlsVmV4LCBoZWFkVmV4LCBoTGluaywgdExpbmssIGluZm8pIHtcbiAgICB0aGlzLmhlYWRWZXggPSBoZWFkVmV4IHx8IDA7XG4gICAgdGhpcy50YWlsVmV4ID0gdGFpbFZleCB8fCAwO1xuICAgIHRoaXMuaExpbmsgPSBoTGluayB8fCBudWxsO1xuICAgIHRoaXMudExpbmsgPSB0TGluayB8fCBudWxsO1xuICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0ge0FyY0JveH0gZmlyc3RJbiDor6XpobbngrnnrKzkuIDmnaHlhaXlvKdcbiAqIEBwYXJhbSB7QXJjQm94fSBmaXJzdE91dCDor6XpobbngrnnrKzkuIDmnaHlh7rlvKdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPTFZleE5vZGUoZGF0YSwgZmlyc3RJbiwgZmlyc3RPdXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGw7XG4gICAgdGhpcy5maXJzdEluID0gZmlyc3RJbiB8fCBudWxsO1xuICAgIHRoaXMuZmlyc3RPdXQgPSBmaXJzdE91dCB8fCBudWxsO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0FycmF5IHwgT0xWZXhOb2RlfSB4TGlzdCDooajlpLTlkJHph49cbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW0g5pyJ5ZCR5Zu+55qE5b2T5YmN6aG254K55pWwXG4gKiBAcGFyYW0ge051bWJlcn0gYXJjbnVtIOacieWQkeWbvueahOW9k+WJjeW8p+aVsFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9MR3JhcGgoeExpc3QsIHZleG51bSwgYXJjbnVtKSB7XG4gICAgdGhpcy54TGlzdCA9IHhMaXN0IHx8IFtdO1xuICAgIHRoaXMudmV4bnVtID0gdmV4bnVtIHx8IDA7XG4gICAgdGhpcy5hcmNudW0gPSBhcmNudW0gfHwgMDtcbn1cbk9MR3JhcGgucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBPTEdyYXBoLFxuXG4gICAgbG9jYXRlVmV4OiBmdW5jdGlvbiAodnApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5kYXRhID09PSB2cCkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8vIOWIoOmZpOmhtueCuVxuICAgIGRlbGV0ZVZlcnRleDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmxvY2F0ZVZleCh2KTtcblxuICAgICAgICBpZiAobSA8IDApIHRocm93IG5ldyBFcnJvcigndmVydGV4IG5vdCBmb3VuZCEnKTtcblxuICAgICAgICB2YXIgbiA9IHRoaXMudmV4bnVtO1xuICAgICAgICB2YXIgcSwgaSwgcDtcbiAgICAgICAgLy8g5Yig6Zmk5omA5pyJ5LulduS4uuWktOeahOi+uVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzlvoXliKDpmaTnmoTovrnmmK/lpLTpk77kuIrnmoTnrKzkuIDkuKrnu5PngrlcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmZpcnN0SW4udGFpbFZleCA9PT0gbSkge1xuICAgICAgICAgICAgICAgIHEgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47XG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdEluID0gcS5oTGluaztcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47IHAgJiYgcC5oTGluay50YWlsVmV4ICE9PSBtOyBwID0gcC5oTGluayk7XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHAuaExpbms7XG4gICAgICAgICAgICAgICAgICAgIHAuaExpbmsgPSBxLmhMaW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOaJgOacieS7pXbkuLrlsL7nmoTovrlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5b6F5Yig6Zmk55qE6L655piv5bC+6ZO+5LiK55qE56ys5LiA5Liq57uT54K5XG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5maXJzdE91dC5oZWFkVmV4ID09PSBtKSB7XG4gICAgICAgICAgICAgICAgcSA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdE91dCA9IHEudExpbms7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDsgcCAmJiBwLnRMaW5rLmhlYWRWZXggIT09IG07IHAgPSBwLnRMaW5rKTtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBxID0gcC50TGluaztcbiAgICAgICAgICAgICAgICAgICAgcC50TGluayA9IHEudExpbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g6aG65qyh55So57uT54K5beS5i+WQjueahOmhtueCueWPluS7o+WJjeS4gOS4qumhtueCuVxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyDkv67mlLnooajlpLTlkJHph49cbiAgICAgICAgICAgIHRoaXMueExpc3RbaV0gPSB0aGlzLnhMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMueExpc3RbaV0uZmlyc3RJbjsgcDsgcCA9IHAuaExpbmspXG4gICAgICAgICAgICAgICAgcC5oZWFkVmV4LS07XG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaylcbiAgICAgICAgICAgICAgICBwLnRhaWxWZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmV4bnVtLS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVERzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZleG51bSA9IHByb21wdCgnVmV4bnVtOiAnKTtcbiAgICAgICAgdGhpcy5hcmNudW0gPSBwcm9tcHQoJ0FyY251bTogJyk7XG4gICAgICAgIC8vIEluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXG4gICAgICAgIHZhciBpbmNJbmZvID0gK3Byb21wdCgnSW5jSW5mbzogJyk7XG5cbiAgICAgICAgLy8g6L6T5YWl6aG254K55YC8XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgdGhpcy54TGlzdFtpXSA9IG5ldyBPTFZleE5vZGUocHJvbXB0KCdkYXRhOiAnKSwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuYXJjbnVtOyArK2spIHtcbiAgICAgICAgICAgIHZhciB2MSA9IHByb21wdCgndjE6ICcpO1xuICAgICAgICAgICAgdmFyIHYyID0gcHJvbXB0KCd2MjogJyk7XG5cbiAgICAgICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleCh2MSk7XG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KHYyKTtcblxuICAgICAgICAgICAgaWYgKGkgPT09IC0xIHx8IGogPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ+aXoOatpOmhtueCue+8jOivt+mHjeaWsOi+k+WFpSEnKTtcbiAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwID0gbmV3IEFyY0JveChpLCBqLCB0aGlzLnhMaXN0W2pdLmZpcnN0SW4sIHRoaXMueExpc3RbaV0uZmlyc3RPdXQsIGluY0luZm8gJiYgcHJvbXB0KCdpbmZvOiAnKSk7XG4gICAgICAgICAgICB0aGlzLnhMaXN0W2pdLmZpcnN0SW4gPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0ID0gcDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDmsYLmnInlkJHlm77nmoTlvLrov57pgJrliIbph49cbiAgICAgKi9cbiAgICBnZXRTR3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIC8vIOesrOS4gOasoea3seW6puS8mOWFiOmBjeWOhuW7uueri2ZpbmlzaGVk5pWw57uEXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmczEodGhpcywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5riF56m6dmlzaXRlZOaVsOe7hFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgICAgICAvLyDnrKzkuozmrKHpgIblkJHnmoTmt7HluqbkvJjlhYjpgY3ljoZcbiAgICAgICAgZm9yICh2YXIgbGVuID0gdGhpcy52ZXhudW0gLSAxOyBsZW4gPj0gMDsgLS1sZW4pIHtcbiAgICAgICAgICAgIGkgPSBmaW5pc2hlZFtpXTtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzMih0aGlzLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRmczEoZ3JhcGgsIHYpIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaykge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gcC5oZWFkVmV4O1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3XSkgZGZzMShncmFwaCwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5pc2hlZFsrK2NvdW50XSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMyKGdyYXBoLCB2KSB7XG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZCcsIHYpO1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBwLnRhaWxWZXg7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3ddKSBkZnMyKGdyYXBoLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vdmFyIGcgPSBuZXcgT0xHcmFwaCgpO1xuLy9nLmNyZWF0ZURHKCk7XG4vL2NvbnNvbGUubG9nKGcpO1xuXG5cbi8qXG4g5pyJ5ZCR5Zu+55qE5by66L+e6YCa5YiG6YePXG5cbiDlr7nkuo7mnInlkJHlm77vvIzlnKjlhbbmr4/kuIDkuKrlvLrov57pgJrliIbph4/kuK3vvIzku7vkvZXkuKTkuKrpobbngrnpg73mmK/lj6/ovr7nmoTjgIIgVuKIiEfvvIzkuI5W5Y+v55u45LqS5Yiw6L6+55qE5omA5pyJ6aG254K55bCx5piv5YyF5ZCrVueahOW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxuXG4g6K6+5LuOVuWPr+WIsOi+viAo5LulVuS4uui1t+eCueeahOaJgOacieacieWQkei3r+W+hOeahOe7iOeCuSnnmoTpobbngrnpm4blkIjkuLpUMShHKe+8jOiAjOWIsOi+vlYgKOS7pVbkuLrnu4jngrnnmoTmiYDmnInmnInlkJHot6/lvoTnmoTotbfngrkp55qE6aG254K56ZuG5ZCI5Li6VDIoRynvvIzliJnljIXlkKtW55qE5by66L+e6YCa5YiG6YeP55qE6aG254K56ZuG5ZCI5piv77yaIFQxKEcp4oipVDIoRykg44CCXG5cbiDmsYLmnInlkJHlm75H55qE5by66L+e6YCa5YiG6YeP55qE5Z+65pys5q2l6aqk5piv77yaXG4g4pG0IOWvuUfov5vooYzmt7HluqbkvJjlhYjpgY3ljobvvIznlJ/miJBH55qE5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6XVOOAglxuIOKRtSAg5a+55qOu5p6XVOeahOmhtueCueaMieS4reW6j+mBjeWOhumhuuW6j+i/m+ihjOe8luWPt+OAglxuIOKRtiAg5pS55Y+YR+S4reavj+S4gOadoeW8p+eahOaWueWQke+8jOaehOaIkOS4gOS4quaWsOeahOacieWQkeWbvkfigJnjgIJcbiDikbcgIOaMieKRteS4reagh+WHuueahOmhtueCuee8luWPt++8jOS7jue8luWPt+acgOWkp+eahOmhtueCueW8gOWni+WvuUfigJnov5vooYzmt7HluqbkvJjlhYjmkJzntKLvvIzlvpfliLDkuIDmo7Xmt7HluqbkvJjlhYjnlJ/miJDmoJHjgILoi6XkuIDmrKHlrozmlbTnmoTmkJzntKLov4fnqIvmsqHmnInpgY3ljoZH4oCZ55qE5omA5pyJ6aG254K577yM5YiZ5LuO5pyq6K6/6Zeu55qE6aG254K55Lit6YCJ5oup5LiA5Liq57yW5Y+35pyA5aSn55qE6aG254K577yM55Sx5a6D5byA5aeL5YaN6L+b6KGM5rex5bqm5LyY5YWI5pCc57Si77yM5bm25b6X5Yiw5Y+m5LiA5qO15rex5bqm5LyY5YWI55Sf5oiQ5qCR44CC5Zyo6K+l5q2l6aqk5Lit77yM5q+P5LiA5qyh5rex5bqm5LyY5YWI5pCc57Si5omA5b6X5Yiw55qE55Sf5oiQ5qCR5Lit55qE6aG254K55bCx5pivR+eahOS4gOS4quW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxuIOKRuCAg6YeN5aSN5q2l6aqk4pG3IO+8jOebtOWIsEfigJnkuK3nmoTmiYDmnInpobbngrnpg73ooqvorr/pl67jgIJcblxuIOWcqOeul+azleWunueOsOaXtu+8jOW7uueri+S4gOS4quaVsOe7hGluX29yZGVyW25d5a2Y5pS+5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6X55qE5Lit5bqP6YGN5Y6G5bqP5YiX44CC5a+55q+P5Liq6aG254K5du+8jOWcqOiwg+eUqERGU+WHveaVsOe7k+adn+aXtu+8jOWwhumhtueCueS+neasoeWtmOaUvuWcqOaVsOe7hGluX29yZGVyW25d5Lit44CC5Zu+6YeH55So5Y2B5a2X6ZO+6KGo5L2c5Li65a2Y5YKo57uT5p6E5pyA5ZCI6YCC44CCXG5cbiAqL1xuXG4vLyB0b2RvIHRvIGJlIHRlc3RlZFxuT0xHcmFwaC5wcm90b3R5cGUuY29ubmVjdGVkX0RHID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXNpdGVkID0gW107XG4gICAgdmFyIGluX29yZGVyID0gW107XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgIC8vIOWvueWbvuato+WQkemBjeWOhlxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xuICAgICAgICAgICAgZGZzKHRoaXMsIGksIGluX29yZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgLy8g5a+55Zu+6YCG5ZCR6YGN5Y6GXG4gICAgdmFyIGsgPSAxO1xuICAgIGZvciAodmFyIGogPSB0aGlzLnZleG51bSAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIHZhciB2ID0gaW5fb3JkZXJbal07XG4gICAgICAgIGlmICghdmlzaXRlZFt2XSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ+esrCcgKyBrKysgKyAn5Liq6L+e6YCa5YiG6YeP6aG254K5Jyk7XG4gICAgICAgICAgICByZXZfZGZzKHRoaXMsIHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2KSB7XG4gICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmhlYWRWZXhdKSB7XG4gICAgICAgICAgICAgICAgZGZzKGdyYXBoLCBwLmhlYWRWZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5fb3JkZXJbY291bnQrK10gPSB2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldl9kZnMoZ3JhcGgsIHYpIHtcbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCfpobbngrnvvJonICsgdik7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC50YWlsVmV4XSkge1xuICAgICAgICAgICAgICAgIHJldl9kZnMoZ3JhcGgsIHAudGFpbFZleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9HcmFwaC9PTEdyYXBoLmpzIiwiLyoqXG4gKiBMUlUoIExlYXN0IHJlY2VudGx5IHVzZWQgKVxuICovXG5cbmltcG9ydCBEb3VibGVMaW5rZWRMaXN0IGZyb20gJy4vRG91YmxlTGlua2VkTGlzdCc7XG5cbmNvbnN0IExJTUlUID0gMjA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExSVUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihzcUxpc3QsIGxpbWl0ID0gTElNSVQpe1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHNxTGlzdCA9IChzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkgPyBzcUxpc3QgJiYgc3FMaXN0LnNsaWNlKDAsIHRoaXMubGltaXQpIDogW107XG4gICAgICAgIHRoaXMuX19jYWNoZSA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KHNxTGlzdCwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICByZXR1cm4gYS5rZXkgPT09IGIua2V5O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG5cbiAgICBnZXQgc2l6ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnNpemU7XG4gICAgfVxuICAgIFxuICAgIHJlbW92ZShrZXkpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnJlbW92ZSh7IGtleSB9KTtcbiAgICB9XG5cbiAgICBjbGVhcigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX19jYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICBcbiAgICBnZXQoa2V5KXtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fX2NhY2hlLmluZGV4T2YoeyBrZXkgfSk7XG5cbiAgICAgICAgaWYoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9fY2FjaGUuZmluZEJ5SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnJlbW92ZShkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX19jYWNoZS51bnNoaWZ0KGRhdGEpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgYWRkKGtleSwgdmFsdWUpe1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmKGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jYWNoZS5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpe1xuICAgICAgICBsZXQgYXJyID0gW107XG4gICAgICAgIHRoaXMuX19jYWNoZS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgYXJyLnB1c2goYCR7IGRhdGEua2V5IH06JHsgZGF0YS52YWx1ZSB9YCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnIuam9pbignID4gJyk7XG4gICAgfVxuXG4gICAgdG9KU09OKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUudG9KU09OKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0xpc3QvTFJVLmpzIiwiLyoqXG4gKiDnur/mgKfooahcbiAqL1xuXG4vLyDnur/mgKfooajnmoTnsbvlnovlrprkuYlcbi8vIOWwhuaJgOacieWcqOaVsOe7hGLkuK3kvYbkuI3lnKjmlbDnu4Rh55qE5pWw5o2u5YWD57Sg5o+S5YWl5YiwYeS4rVxuXG52YXIgYSA9IFsxLCAyLCAzLCA0LCA1XTtcbnZhciBiID0gWzEsIDMsIDUsIDcsIDldO1xuXG5leHBvcnQgZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICAgIHZhciBlbGVtLCBlcXVhbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBiTGVuID0gYi5sZW5ndGg7IGkgPCBiTGVuOyBpKyspIHtcbiAgICAgICAgZWxlbSA9IGJbaV07XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGFMZW4gPSBhLmxlbmd0aDsgaiA8IGFMZW47IGorKykge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09IGFbal0pIHtcbiAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVxdWFsKSBhLnB1c2goZWxlbSk7XG4gICAgfVxufVxuXG51bmlvbihhLCBiKTtcbmNvbnNvbGUubG9nKGEpO1xuLy8gWzEsIDIsIDMsIDQsIDUsIDcsIDldXG5cbi8vIOaXtumXtOWkjeadguW6pu+8mk8oYUxlbiAqIGJMZW4pXG5cbi8vIOW3suefpeaVsOe7hGHlkozmlbDnu4Ri5Lit55qE5pWw5o2u5YWD57Sg5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXG4vLyDlvZLlubZh5ZKMYuW+l+WIsOaWsOeahOaVsOe7hGPvvIxj55qE5pWw5o2u5YWD57Sg5Lmf5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXG52YXIgYSA9IFszLCA1LCA4LCAxMV07XG52YXIgYiA9IFsyLCA2LCA4LCA5LCAxMSwgMTUsIDIwXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGlzdChhLCBiKSB7XG4gICAgdmFyIGMgPSBbXSwgYUVsZW0sIGJFbGVtO1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xuICAgIHZhciBhTGVuID0gYS5sZW5ndGg7XG4gICAgdmFyIGJMZW4gPSBiLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgYUxlbiAmJiBqIDwgYkxlbikge1xuICAgICAgICBhRWxlbSA9IGFbaV07XG4gICAgICAgIGJFbGVtID0gYltqXTtcblxuICAgICAgICBpZiAoYUVsZW0gPCBiRWxlbSkge1xuICAgICAgICAgICAgY1trKytdID0gYUVsZW07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjW2srK10gPSBiRWxlbTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgICBjW2srK10gPSBhW2krK107XG4gICAgfVxuXG4gICAgd2hpbGUgKGogPCBiTGVuKSB7XG4gICAgICAgIGNbaysrXSA9IGJbaisrXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn1cblxudmFyIGMgPSBtZXJnZUxpc3QoYSwgYik7XG5jb25zb2xlLmxvZyhjKTtcbi8vIFsyLCAzLCA1LCA2LCA4LCA4LCA5LCAxMSwgMTEsIDE1LCAyMF1cblxuLy8g5pe26Ze05aSN5p2C5bqm77yaIE8oYUxlbiArIGJMZW4pXG5cbi8vIOe6v+aAp+ihqOeahOmhuuW6j+ihqOekuuWSjOWunueOsFxuLy8g5L2/55So5Lyq5pWw57uE5qih5ouf57q/5oCn6KGo5o+S5YWl5pON5L2c55qE5YmN5ZCO5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo56m66Ze05Lit55qE5L2N572u5Y+Y5YyWXG52YXIgYSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1fTtcbmEubGVuZ3RoID0gNjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydChhLCBpLCBlbGVtKSB7XG4gICAgaWYgKCFlbGVtKSByZXR1cm47XG5cbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgIHdoaWxlIChsZW4gPCBpKSB7XG4gICAgICAgICAgICBhW2xlbisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGEubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgYVtpXSA9IGVsZW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgICAgICAgIGFbbGVuLS1dID0gYVtsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGFbaV0gPSBlbGVtO1xuICAgIH1cbiAgICBhLmxlbmd0aCsrO1xufVxuXG5pbnNlcnQoYSwgMywgOCk7XG5pbnNlcnQoYSwgMTAsIDEwKTtcbmNvbnNvbGUubG9nKGEpO1xuXG4vLyDkvb/nlKjkvKrmlbDnu4TmqKHmi5/nur/mgKfooajliKDpmaTmk43kvZznmoTliY3lkI7mlbDmja7lhYPntKDlnKjlrZjlgqjnqbrpl7TkuK3nmoTkvY3nva7lj5jljJZcblxuZXhwb3J0IGZ1bmN0aW9uIGRlbChhLCBpKSB7XG4gICAgdmFyIHRlbXAgPSBhW2ldO1xuICAgIHZhciBqID0gaSArIDE7XG4gICAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgYVtqIC0gMV0gPSBhW2orK107XG4gICAgfVxuICAgIGEubGVuZ3RoLS07XG4gICAgZGVsZXRlIGFbbGVuIC0gMV07XG5cbiAgICByZXR1cm4gdGVtcDtcbn1cblxuZGVsKGEsIDMpO1xuY29uc29sZS5sb2coYSk7XG5kZWwoYSwgMTApO1xuY29uc29sZS5sb2coYSk7XG5cbi8vIOaXtumXtOWkjeadguW6pu+8miBPKGEubGVuZ3RoKVxuXG4vLyDmr5TovoPlrZfnrKbooahB5ZKMQu+8jOW5tueUqOi/lOWbnuWAvOihqOekuue7k+aenO+8jOWAvOS4ujHvvIzooajnpLpBPkLvvIzlgLzkuLotMe+8jOihqOekukE8Qu+8jOWAvOS4ujDvvIzooajnpLpBPUJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q29tcChhTGlzdCwgYkxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFMaXN0Lmxlbmd0aCAmJiBpIDwgYkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFMaXN0W2ldICE9PSBiTGlzdFtpXSkgcmV0dXJuIGFMaXN0W2ldID4gYkxpc3RbaV0gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKGFMaXN0Lmxlbmd0aCA9PSBiTGlzdC5sZW5ndGgpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIGFMaXN0Lmxlbmd0aCA+IGJMaXN0Lmxlbmd0aCA/IDEgOiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2UobGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGlzdC5sZW5ndGggLSAxOyBpIDw9IGo7IGkrKywgai0tKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbGlzdFtpXTtcbiAgICAgICAgbGlzdFtpXSA9IGxpc3Rbal07XG4gICAgICAgIGxpc3Rbal0gPSB0ZW1wO1xuICAgIH1cbn1cblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0KGFMaXN0LCBiTGlzdCkge1xuICAgIHZhciBjTGlzdCA9IFtdO1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xuXG4gICAgd2hpbGUgKGFMaXN0W2ldICYmIGJMaXN0W2pdKSB7XG4gICAgICAgIGlmIChhTGlzdFtpXSA8IGJMaXN0W2pdKSBpKys7XG4gICAgICAgIGVsc2UgaWYgKGFMaXN0W2ldID4gYkxpc3Rbal0pIGorKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjTGlzdFtrKytdID0gYUxpc3RbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY0xpc3Q7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdChbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaXlm55hXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0X3RydWUoYSwgYikge1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xuXG4gICAgd2hpbGUgKGFbaV0gJiYgYltqXSkge1xuICAgICAgICBpZiAoYVtpXSA8IGJbal0pIGkrKztcbiAgICAgICAgZWxzZSBpZiAoYVtpXSA+IGJbal0pIGorKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW2srK10gPSBhW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGFba10pIGEuc3BsaWNlKGssIDEpO1xuXG4gICAgcmV0dXJuIGE7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdF90cnVlKFsxLCAzLCA1LCA3LCA5XSwgWzEsIDUsIDksIDEzLCAxN10pICsgJycpO1xuXG4vLyBh77yMYu+8jGPnmoTlhYPntKDlnYfmmK/pnZ7pgJLlh4/mjpLliJdcbi8vIOaxgmHmlbDnu4TkuK3pnZ5i5pWw57uE5ZKMY+aVsOe7hOeahOS6pOmbhueahOWFg+e0oOOAglxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdF9kZWxldGUoYSwgYiwgYykge1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwLCBtID0gMDtcblxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaiA8IGIubGVuZ3RoICYmIGsgPCBjLmxlbmd0aCkge1xuICAgICAgICBpZiAoYltqXSA8IGNba10pIGorKztcbiAgICAgICAgZWxzZSBpZiAoYltqXSA+IGNba10pIGsrKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDmib7liLDkuobnm7jlkIzlhYPntKBzYW1lXG4gICAgICAgICAgICB2YXIgc2FtZSA9IGJbal07XG5cbiAgICAgICAgICAgIC8vIGrvvIxr5ZCO56e75Yiw5paw55qE5YWD57SgXG4gICAgICAgICAgICB3aGlsZSAoYltqXSA9PT0gc2FtZSkgaisrO1xuICAgICAgICAgICAgd2hpbGUgKGNba10gPT09IHNhbWUpIGsrKztcbiAgICAgICAgICAgIC8vIOmcgOS/neeVmeeahOWFg+e0oOenu+WKqOWIsOaWsOS9jee9rlxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldIDwgc2FtZSkgYVttKytdID0gYVtpKytdO1xuICAgICAgICAgICAgLy8g6Lez6L+H55u45ZCM55qE5YWD57SgXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEubGVuZ3RoICYmIGFbaV0gPT09IHNhbWUpIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGHnmoTliankvZnlhYPntKDph43mlrDlrZjlgqhcbiAgICB3aGlsZSAoaSA8IGEubGVuZ3RoKSBhW20rK10gPSBhW2krK107XG4gICAgYS5sZW5ndGggPSBtO1xuXG4gICAgcmV0dXJuIGE7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdF9kZWxldGUoWzEsIDIsIDMsIDQsIDUsIDYsIDldLCBbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9MaXN0L0xpbmVhckxpc3QuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMS8xOS5cbiAqL1xuXG4vKipcbiAqIOW+queOr+mYn+WIl1xuICogXG4gKiDnlKjlpITvvJrnuqbnkZ/lpKvnjq9cbiAqIOS8mOeCue+8muS4uuWFheWIhuWIqeeUqOWQkemHj+epuumXtO+8jOWFi+acjVwi5YGH5rqi5Ye6XCLnjrDosaHnmoTmlrnms5XmmK/vvJrlsIblkJHph4/nqbrpl7Tmg7PosaHkuLrkuIDkuKrpppblsL7nm7jmjqXnmoTlnIbnjq/vvIzlubbnp7Dov5nnp43lkJHph4/kuLrlvqrnjq/lkJHph4/jgILlrZjlgqjlnKjlhbbkuK3nmoTpmJ/liJfnp7DkuLrlvqrnjq/pmJ/liJfvvIhDaXJjdWxhciBRdWV1Ze+8ieOAglxuICogXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQ3ljbGVRdWV1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDeWNsZVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhzaXplID0gMTAwKXtcbiAgICAgICAgdGhpcy5iYXNlID0ge307XG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xuICAgICAgICB0aGlzLk1BWFFTSVpFID0gbWF4c2l6ZTtcbiAgICB9XG5cbiAgICBlblF1ZXVlKGRhdGEpIHtcbiAgICAgICAgaWYgKCh0aGlzLnJlYXIgKyAxKSAlIHRoaXMuTUFYUVNJWkUgPT09IDApIHRocm93IG5ldyBFcnJvcignY3ljbGVRdWV1ZSBpcyBhbHJlYWR5IGZ1bGwhJyk7XG5cbiAgICAgICAgdGhpcy5iYXNlW3RoaXMucmVhcl0gPSBkYXRhO1xuICAgICAgICB0aGlzLnJlYXIgPSAodGhpcy5yZWFyICsgMSkgJSB0aGlzLk1BWFFTSVpFO1xuICAgIH1cbiAgICBkZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gdGhpcy5yZWFyKSB0aHJvdyBuZXcgRXJyb3IoJ2N5Y2xlUXVldWUgaXMgYWxyZWFkeSBlbXB0eScpO1xuXG4gICAgICAgIGxldCBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xuICAgICAgICB0aGlzLmZyb250ID0gKHRoaXMuZnJvbnQgKyAxKSAlIHRoaXMuTUFYUVNJWkU7XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmJhc2UgPSB7fTtcbiAgICAgICAgdGhpcy5mcm9udCA9IHRoaXMucmVhciA9IDA7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucmVhciAtIHRoaXMuZnJvbnQgKyB0aGlzLk1BWFFTSVpFKSAlIHRoaXMuTUFYUVNJWkU7XG4gICAgfVxuICAgIHBlZWtBdChpbmRleCA9IDApIHtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggKyB0aGlzLk1BWFFTSVpFKSAlIHRoaXMuTUFYUVNJWkU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVtpbmRleCArIHRoaXMuZnJvbnRdIHx8IG51bGw7XG4gICAgfVxuICAgIGdldEhlYWQoKSB7XG4gICAgICAgIGxldCBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xuICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0gOiBudWxsO1xuICAgIH1cbiAgICBxdWV1ZVRyYXZlcnNlKGl0ZXJhdG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb250LCBsZW4gPSB0aGlzLnJlYXIgPSB0aGlzLmZyb250OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcih0aGlzLmJhc2VbaV0sIGkpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBbXS5zbGljZS5jYWxsKHRoaXMuYmFzZSk7XG5cbiAgICAgICAgcmV0dXJuIGJhc2Uuc2xpY2UodGhpcy5mcm9udCwgdGhpcy5yZWFyIC0gdGhpcy5mcm9udCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1F1ZXVlL0N5Y2xlUXVldWUuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMjYuXG4gKi9cblxuLypcbuS8mOWFiOmYn+WIlyhwcmlvcml0eSBxdWV1ZSlcblxu5pmu6YCa55qE6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye655qE5pWw5o2u57uT5p6E77yM5YWD57Sg5Zyo6Zif5YiX5bC+6L+95Yqg77yM6ICM5LuO6Zif5YiX5aS05Yig6Zmk44CC5Zyo5LyY5YWI6Zif5YiX5Lit77yM5YWD57Sg6KKr6LWL5LqI5LyY5YWI57qn44CC5b2T6K6/6Zeu5YWD57Sg5pe277yM5YW35pyJ5pyA6auY5LyY5YWI57qn55qE5YWD57Sg5pyA5YWI5Yig6Zmk44CC5LyY5YWI6Zif5YiX5YW35pyJ5pyA6auY57qn5YWI5Ye6IO+8iGxhcmdlc3QtaW7vvIxmaXJzdC1vdXTvvInnmoTooYzkuLrnibnlvoHjgIJcblxu5LyY5YWI6Zif5YiX5pivMOS4quaIluWkmuS4quWFg+e0oOeahOmbhuWQiCzmr4/kuKrlhYPntKDpg73mnInkuIDkuKrkvJjlhYjmnYPmiJblgLws5a+55LyY5YWI6Zif5YiX5omn6KGM55qE5pON5L2c5pyJMSkg5p+l5om+OzIpIOaPkuWFpeS4gOS4quaWsOWFg+e0oDszKSDliKDpmaQu5Zyo5pyA5bCP5LyY5YWI6Zif5YiXKG1pbiBwcmlvcml0eXEgdSBlIHUgZSnkuK0s5p+l5om+5pON5L2c55So5p2l5pCc57Si5LyY5YWI5p2D5pyA5bCP55qE5YWD57SgLOWIoOmZpOaTjeS9nOeUqOadpeWIoOmZpOivpeWFg+e0oDvlr7nkuo7mnIDlpKfkvJjlhYjpmJ/liJcobWF4IHByaW9yaXR5IHF1ZXVlKSzmn6Xmib7mk43kvZznlKjmnaXmkJzntKLkvJjlhYjmnYPmnIDlpKfnmoTlhYPntKAs5Yig6Zmk5pON5L2c55So5p2l5Yig6Zmk6K+l5YWD57SgLuS8mOWFiOadg+mYn+WIl+S4reeahOWFg+e0oOWPr+S7peacieebuOWQjOeahOS8mOWFiOadgyzmn6Xmib7kuI7liKDpmaTmk43kvZzlj6/moLnmja7ku7vmhI/kvJjlhYjmnYPov5vooYwuXG5cblxu5YWl6Zif5pON5L2cXG7ikaDvvJrlrozlhajkuozlj4nmoJHnmoTmnoTlu7rmk43kvZzmmK/igJzku47kuIrliLDkuIvvvIzku47lt6bliLDlj7PigJ3nmoTlvaLlvI/vvIzmiYDku6XlhaXpmJ/nmoToioLngrnmmK/mlL7lnKjmlbDnu4TnmoTmnIDlkI7vvIzkuZ/lsLHmmK/moJHkuK3lj7blrZDlsYLnmoTmnInluo/mnIDlj7PovrnnqbrkvY3jgIJcbuKRoe+8muW9k+iKgueCueaPkuWFpeWIsOacgOWQjuaXtu+8jOacieWPr+iDveegtOWdj+S6huWghueahOaAp+i0qO+8jOatpOaXtuaIkeS7rOimgei/m+ihjOKAnOS4iua7pOaTjeS9nOKAne+8jOW9k+eEtuaXtumXtOWkjeadguW6puS4uk8obGdOKeOAglxuXG7lh7rpmJ/mk43kvZxcbuWHuumYn+aTjeS9nOaXtu+8jOaIkeS7rOmHh+WPlueahOaWueahiOaYr++8muW8ueWHuuWghumhtuWFg+e0oO+8jOeEtuWQjuWwhuWPtuWtkOWxguS4reeahOacgOWPs+WtkOiKgueCuei1i+e7meWghumhtu+8jOWQjOagt+i/meaXtuS5n+S8muWPr+iDveWtmOWcqOegtOWdj+WghueahOaAp+i0qO+8jOacgOWQjuaIkeS7rOimgeiiq+i/q+i/m+ihjOS4i+a7pOaTjeS9nOOAglxuICovXG5cbmltcG9ydCBIZWFwIGZyb20gJy4uL0hlYXAnO1xuXG4vKipcbiAqIOeUqOWghuWunueOsOS8mOWFiOmYn+WIl1xuICogXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUHJpb3JpdHlRdWV1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEhlYXAoZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBzaXplKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAuYXJyLmxlbmd0aDtcbiAgICB9XG5cbiAgICBlblF1ZXVlKHZhbHVlLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCByZXF1aXJlZCcpO1xuXG4gICAgICAgIC8vIOWwhuW9k+WJjeiKgueCuei/veWKoOWIsOWghuWwvlxuICAgICAgICB0aGlzLmhlYXAuYWRkKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGRlUXVldWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgY2xlYXIoKXtcbiAgICAgICAgdGhpcy5oZWFwLmNsZWFyKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1F1ZXVlL1ByaW9yaXR5UXVldWUuanMiLCIvKipcbiAqIEFWTCBUUkVFIENsYXNzXG4gKlxuICogQGF1dGhvciBCcmljZSBDaGV2YWxpZXJcbiAqXG4gKlxuICogQGRlc2NcbiAqXG4gKiAgICBNZXRob2QgICAgICAgICAgICAgICAgVGltZSBDb21wbGV4aXR5XG4gKiAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICpcbiAqICAgIGFkZCAgICAgICAgICAgICAgICAgICAgTyhsb2cyKG4pKVxuICogICAgcmVtb3ZlICAgICAgICAgICAgICAgIE8obG9nMihuKSlcbiAqICAgIGdldEZpcnN0ICAgICAgICAgICAgTygxKVxuICogICAgZ2V0TGFzdCAgICAgICAgICAgICAgICBPKDEpXG4gKiAgICBnZXRDb3VudCAgICAgICAgICAgIE8oMSlcbiAqICAgIGFwcGx5ICAgICAgICAgICAgICAgIE8obilcbiAqICAgIGNsZWFyICAgICAgICAgICAgICAgIE8obilcbiAqXG4gKiAgICBNZW1vcnkgQ29tcGxleGl0eSBpbiBPKG4pXG4gKi9cblxuZnVuY3Rpb24gTm9kZShvYmopIHtcbiAgICB0aGlzLm9iamVjdCA9IG9iajtcbiAgICB0aGlzLmhlaWdodCA9IDE7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gQXZsVHJlZSgpIHtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG59XG5BdmxUcmVlLmNtcCA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICBlbHNlIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgZWxzZSByZXR1cm4gMDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLl9hZGRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQucHJldmlvdXM7XG4gICAgbm9kZS5uZXh0ID0gcGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuXG4gICAgcGFyZW50LmxlZnQgPSBub2RlO1xuICAgIHBhcmVudC5wcmV2aW91cyA9IG5vZGU7XG5cbiAgICBpZiAobm9kZS5wcmV2aW91cykge1xuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IG5vZGU7XG4gICAgfVxufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQ7XG4gICAgbm9kZS5uZXh0ID0gcGFyZW50Lm5leHQ7XG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICBwYXJlbnQucmlnaHQgPSBub2RlO1xuICAgIHBhcmVudC5uZXh0ID0gbm9kZTtcblxuICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZTtcbiAgICB9XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5jb3VudCArPSAxO1xuICAgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUob2JqKTtcblxuICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5maXJzdCA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5yb290O1xuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMucm9vdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgdmFyIGNtcCA9IEF2bFRyZWUuY21wKG9iaiwgY3VycmVudC5vYmplY3QpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVmdChuZXdOb2RlLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJpZ2h0KG5ld05vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMZWZ0KG5ld05vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmlnaHQobmV3Tm9kZSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmhlaWdodCA8IGN1cnJlbnQubGVmdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9iYWxhbmNlKG5ld05vZGUucGFyZW50KTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VMZWZ0UmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIHZhciBhID0gbGVmdC5sZWZ0O1xuICAgIHZhciBiID0gbGVmdC5yaWdodC5sZWZ0O1xuXG4gICAgbGVmdC5yaWdodC5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLmxlZnQgPSBsZWZ0LnJpZ2h0O1xuICAgIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgbGVmdC5wYXJlbnQgPSBub2RlO1xuXG4gICAgdmFyIGxlZnRMZWZ0ID0gbGVmdC5sZWZ0O1xuICAgIGxlZnRMZWZ0LnBhcmVudCA9IGxlZnQ7XG4gICAgbGVmdExlZnQubGVmdCA9IGE7XG4gICAgbGVmdExlZnQucmlnaHQgPSBiO1xuICAgIGlmIChhICE9PSBudWxsKSB7XG4gICAgICAgIGEucGFyZW50ID0gbGVmdExlZnQ7XG4gICAgfVxuICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgIGIucGFyZW50ID0gbGVmdExlZnQ7XG4gICAgfVxuXG4gICAgbGVmdC5oZWlnaHQgPSBsZWZ0TGVmdC5oZWlnaHQgKyAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VMZWZ0TGVmdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgdmFyIGMgPSBsZWZ0LnJpZ2h0O1xuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSBsZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZWZ0LnJpZ2h0ID0gbm9kZTtcbiAgICBsZWZ0LnBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gbGVmdDtcbiAgICBub2RlLmxlZnQgPSBjO1xuICAgIGlmKGMgIT09IG51bGwpIHtcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xuICAgIH1cblxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodExlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgdmFyIGEgPSByaWdodC5yaWdodDtcbiAgICB2YXIgYiA9IHJpZ2h0LmxlZnQucmlnaHQ7XG5cbiAgICByaWdodC5sZWZ0LnJpZ2h0ID0gcmlnaHQ7XG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0LmxlZnQ7XG4gICAgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIHJpZ2h0LnBhcmVudCA9IG5vZGU7XG5cbiAgICB2YXIgcmlnaHRSaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgIHJpZ2h0UmlnaHQucGFyZW50ID0gcmlnaHQ7XG4gICAgcmlnaHRSaWdodC5yaWdodCA9IGE7XG4gICAgcmlnaHRSaWdodC5sZWZ0ID0gYjtcbiAgICBpZiAoYSAhPT0gbnVsbCkge1xuICAgICAgICBhLnBhcmVudCA9IHJpZ2h0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgIGIucGFyZW50ID0gcmlnaHRSaWdodDtcbiAgICB9XG5cbiAgICBub2RlLnJpZ2h0LmhlaWdodCA9IHJpZ2h0UmlnaHQuaGVpZ2h0ICsgMTtcbn07XG5cblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIHZhciBjID0gcmlnaHQubGVmdDtcblxuICAgIGlmIChub2RlID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50LmxlZnQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByaWdodC5sZWZ0ID0gbm9kZTtcbiAgICByaWdodC5wYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBub2RlLnBhcmVudCA9IHJpZ2h0O1xuICAgIG5vZGUucmlnaHQgPSBjO1xuICAgIGlmKGMgIT09IG51bGwpIHtcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xuICAgIH1cblxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEJhbGFuY2luZyB0aGUgdHJlZVxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGVmdEhlaWdodCA9IChjdXJyZW50LmxlZnQgPT09IG51bGwpID8gMCA6IGN1cnJlbnQubGVmdC5oZWlnaHQ7XG4gICAgICAgIHZhciByaWdodEhlaWdodCA9IChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSA/IDAgOiBjdXJyZW50LnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IDEgKyBNYXRoLm1heChsZWZ0SGVpZ2h0LCByaWdodEhlaWdodCk7XG5cbiAgICAgICAgaWYgKG5ld0hlaWdodCA+IGN1cnJlbnQuaGVpZ2h0KSB7XG4gICAgICAgICAgICBjdXJyZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIGlmIChsZWZ0SGVpZ2h0IC0gcmlnaHRIZWlnaHQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0LnJpZ2h0ICE9PSBudWxsICYmIChjdXJyZW50LmxlZnQubGVmdCA9PT0gbnVsbCB8fCBjdXJyZW50LmxlZnQubGVmdC5oZWlnaHQgPCBjdXJyZW50LmxlZnQucmlnaHQuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IFJpZ2h0IENhc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZUxlZnRSaWdodChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMZWZ0IExlZnQgQ2FzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VMZWZ0TGVmdChjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSB0cmVlIGhhcyBiZWVuIGJhbGFuY2VkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0SGVpZ2h0IC0gbGVmdEhlaWdodCA+IDEpIHtcblxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodC5sZWZ0ICE9PSBudWxsICYmIChjdXJyZW50LnJpZ2h0LnJpZ2h0ID09PSBudWxsIHx8IGN1cnJlbnQucmlnaHQucmlnaHQuaGVpZ2h0IDwgY3VycmVudC5yaWdodC5sZWZ0LmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgTGVmdCBDYXNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodExlZnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgUmlnaHQgQ2FzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodFJpZ2h0KGN1cnJlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRyZWUgaGFzIGJlZW4gYmFsYW5jZWRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpcyBiYWxhbmNlZFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQXZsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHRoaXMuX3JlbW92ZShvYmosIHRoaXMucm9vdCk7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKG9iaiwgbm9kZSkge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjbXAgPSBBdmxUcmVlLmNtcChvYmosIGN1cnJlbnQub2JqZWN0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBjdXJyZW50Lm9iamVjdCkge1xuXG4gICAgICAgICAgICAgICAgLy8gTm9kZSByZW1vdmFsXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCAtPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2luZyB0aGUgbm9kZSBieSB0aGUgc21hbGxlc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gaXRcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY3VycmVudC5yaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBiYWxhbmNlRnJvbTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudC5yaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcblxuICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW92ZShvYmosIGN1cnJlbnQubGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKG9iaiwgY3VycmVudC5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5yZW1vdmVCeVJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gTm9kZSByZW1vdmFsXG4gICAgdGhpcy5jb3VudCAtPSAxO1xuXG4gICAgaWYgKG5vZGUucHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IG5vZGUubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZS5wcmV2aW91cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm5leHQucHJldmlvdXMgPSBub2RlLnByZXZpb3VzO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2luZyB0aGUgbm9kZSBieSB0aGUgc21hbGxlc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gaXRcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcblxuICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYmFsYW5jZShwYXJlbnQpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBub2RlLnJpZ2h0O1xuICAgIHZhciBiYWxhbmNlRnJvbTtcblxuICAgIGlmIChyZXBsYWNlbWVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcbiAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudC5yaWdodDtcblxuICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICByaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcblxuICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXG4gICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcblxuICAgIHJldHVybiAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0Rmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3Q7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3Q7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3Q7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAocHJvY2Vzc2luZ0Z1bmMsIHBhcmFtcykge1xuICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmZpcnN0OyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XG4gICAgICAgIHByb2Nlc3NpbmdGdW5jKGN1cnJlbnQub2JqZWN0LCBwYXJhbXMpO1xuICAgIH1cbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKHByb2Nlc3NpbmdGdW5jLCBwYXJhbXMpIHtcbiAgICBmb3IgKHZhciBjdXJyZW50ID0gdGhpcy5sYXN0OyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5wcmV2aW91cykge1xuICAgICAgICBwcm9jZXNzaW5nRnVuYyhjdXJyZW50Lm9iamVjdCwgcGFyYW1zKTtcbiAgICB9XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF2bFRyZWU7XG5cblxuY29uc29sZS5sb2coJ1xcbkFWTCB0cmVlIGluc2VydDI6ICcpO1xudmFyIHRlc3QgPSBuZXcgQXZsVHJlZSgpO1xudGVzdC5hZGQoMyk7XG50ZXN0LmFkZCgxNCk7XG50ZXN0LmFkZCgyNSk7XG50ZXN0LmFkZCg4MSk7XG50ZXN0LmFkZCg0NCk7XG5cbi8qXG4gMTRcbiAvICAgIFxcXG4gMyAgICAgICA0NFxuIC8gICBcXFxuIDI1ICAgICA4MVxuICovXG5cblxuY29uc29sZS5sb2coJ3JlbW92ZV9SZWN1cnNpdmUgMjonKTtcblxudGVzdC5yZW1vdmUoODEpO1xudGVzdC5yZW1vdmUoMyk7XG50ZXN0LnJlbW92ZSgxNCk7XG50ZXN0LnJlbW92ZSgyNSk7XG50ZXN0LnJlbW92ZSg0NCk7XG5cblxubGV0IHN0ciA9ICdja25vYmZqdGxwcWFlZ3JtZGhzJztcbi8vdmFyIHN0ciA9ICdja2JmamxhZWdtZGgnO1xuXG5cbnRlc3QgPSBuZXcgQXZsVHJlZSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSl7XG4gICAgdGVzdC5hZGQoc3RyW2ldKTtcbn1cblxuXG50ZXN0LnJlbW92ZSgnZScpO1xudGVzdC5yZW1vdmUoJ2gnKTtcbnRlc3QucmVtb3ZlKCdiJyk7XG50ZXN0LnJlbW92ZSgnbCcpO1xudGVzdC5yZW1vdmUoJ2YnKTtcbnRlc3QucmVtb3ZlKCdqJyk7XG50ZXN0LnJlbW92ZSgnZycpO1xudGVzdC5yZW1vdmUoJ2QnKTtcbnRlc3QucmVtb3ZlKCdrJyk7XG50ZXN0LnJlbW92ZSgnYScpO1xudGVzdC5yZW1vdmUoJ20nKTtcbnRlc3QucmVtb3ZlKCduJyk7XG50ZXN0LnJlbW92ZSgnbycpO1xudGVzdC5yZW1vdmUoJ3AnKTtcbnRlc3QucmVtb3ZlKCdxJyk7XG50ZXN0LnJlbW92ZSgncicpO1xudGVzdC5yZW1vdmUoJ3MnKTtcbnRlc3QucmVtb3ZlKCd0Jyk7XG50ZXN0LnJlbW92ZSgnYycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQVZMVHJlZS5qcyIsIi8qXG4gTUlUIExpY2Vuc2VcbiBDb3B5cmlnaHQgKGMpIDIwMTIgU2FudGFudSBCYXN1XG4gQ29weXJpZ2h0IChjKSAyMDEzIERhbmllbCBXaXJ0elxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vLyBCYXNlZCBvbiBTYW50YW51IEJhc3UncyBCUGx1c0pTXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2FudGFudWJhc3UvQlBsdXNKU1xuLy8gTW9kaWZpZWQgZm9yIHN0YW5kLWFsb25lIHVzZVxuXG4vKipcbiAqIEBsaWNlbnNlIEJUcmVlLmpzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vQlRyZWUuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICAgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIHZhciBOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8IDEwMDtcbiAgICAgICAgdGhpcy5tZXJnZVRocmVzaG9sZCA9IG9wdGlvbnMubWVyZ2VUaHJlc2hvbGQgfHwgNDA7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRMZWZ0UGVlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLnNldExlZnRQZWVyID0gZnVuY3Rpb24gKGxlZnRQZWVyKSB7XG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBsZWZ0UGVlcjtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRQZWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLnNldFJpZ2h0UGVlciA9IGZ1bmN0aW9uIChyaWdodFBlZXIpIHtcbiAgICAgICAgdGhpcy5yaWdodFBlZXIgPSByaWdodFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldFN1cnBsdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKCh0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5tZXJnZVRocmVzaG9sZCkgLyAyKSk7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldFJpZ2h0U3VycGx1c0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdXJwbHVzID0gdGhpcy5nZXRTdXJwbHVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3BsaWNlKHRoaXMuZGF0YS5sZW5ndGggLSBzdXJwbHVzKTtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0TGVmdFN1cnBsdXNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3VycGx1cyA9IHRoaXMuZ2V0U3VycGx1cygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNwbGljZSgwLCBzdXJwbHVzKTtcbiAgICB9O1xuXG4gICAgdmFyIEludGVybmFsTm9kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIE5vZGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICB0aGlzLmxlZnRQZWVyID0gb3B0aW9ucy5sZWZ0UGVlcjtcbiAgICAgICAgdGhpcy5yaWdodFBlZXIgPSBvcHRpb25zLnJpZ2h0UGVlcjtcbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xuICAgICAgICAgICAgaWYgKGRhdGFbbWlkXS5rZXkgPCBrZXkpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdLmtleSA+IGtleSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlZnQgPCByaWdodCAmJiAhZm91bmQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kQ2hpbGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBpZiAoZWxlbWVudC5rZXkgPD0ga2V5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciBuZXdOb2RlcywgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LnJpZ2h0O1xuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSwgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmlnaHRFbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1syXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnQucmlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld05vZGVzO1xuICAgIH07XG5cbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZSgwLCBzcGxpdEluZGV4KSxcbiAgICAgICAgICAgIGxlZnRQZWVyOiB0aGlzLmxlZnRQZWVyLFxuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXggKyAxLCB0aGlzLmRhdGEubGVuZ3RoKSxcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkXG4gICAgICAgIH0pO1xuICAgICAgICBsZWZ0Tm9kZS5zZXRSaWdodFBlZXIocmlnaHROb2RlKTtcbiAgICAgICAgcmlnaHROb2RlLnNldExlZnRQZWVyKGxlZnROb2RlKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0UGVlci5zZXRSaWdodFBlZXIobGVmdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGVlci5zZXRMZWZ0UGVlcihyaWdodE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XG4gICAgfTtcblxuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB2YXIgbWVyZ2VJbmRleCA9IC0xO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciByZXR2YWw7XG4gICAgICAgIGlmIChlbGVtZW50LmtleSA8PSBrZXkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5yaWdodDtcbiAgICAgICAgICAgIHJldHZhbCA9IGNoaWxkLnJlbW92ZShrZXksIGVsZW1lbnQubGVmdCwgaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSA/IGNoaWxkLmdldFJpZ2h0UGVlcigpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID09IDEgJiYgcmV0dmFsLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF0sIHJldHZhbFszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dmFsWzFdID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcbiAgICAgICAgICAgIHJldHZhbCA9IGNoaWxkLnJlbW92ZShrZXksIGluZGV4ID4gMCA/IGNoaWxkLmdldExlZnRQZWVyKCkgOiB1bmRlZmluZWQsIGVsZW1lbnQucmlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMSAmJiByZXR2YWwubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXSwgcmV0dmFsWzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR2YWxbMV0gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZUluZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VFbGVtZW50ID0gdGhpcy5kYXRhW21lcmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPT0gNSkge1xuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudC5rZXkgPSByZXR2YWxbM107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW21lcmdlSW5kZXggLSAxXS5yaWdodCA9IHJldHZhbFszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbWVyZ2VJbmRleCArIDFdLmxlZnQgPSByZXR2YWxbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UobWVyZ2VJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcbiAgICAgICAgLy8gdmFyIGRlZmljaXQgPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdFN1cnBsdXMgPSAwO1xuICAgICAgICB2YXIgbGVmdERhdGE7XG4gICAgICAgIHZhciByaWdodFN1cnBsdXMgPSAwO1xuICAgICAgICB2YXIgcmlnaHREYXRhO1xuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xuICAgICAgICB2YXIgcmlnaHRQZWVyID0gdGhpcy5yaWdodFBlZXI7XG4gICAgICAgIGlmIChpc0RlZmluZWQobGVmdE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgbGVmdFN1cnBsdXMgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgcmlnaHRTdXJwbHVzID0gcmlnaHRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRTdXJwbHVzID4gcmlnaHRTdXJwbHVzKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFN1cnBsdXNEYXRhID0gbGVmdE1lcmdlT3B0aW9uLmdldFJpZ2h0U3VycGx1c0RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5zbGljZSgxKS5jb25jYXQoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0U3VycGx1c0RhdGFbbGVmdFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XG4gICAgICAgICAgICByZXR2YWxbMl0gPSBsZWZ0U3VycGx1c0RhdGFbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0U3VycGx1c0RhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHRTdXJwbHVzRGF0YVswXS5sZWZ0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgcmlnaHRTdXJwbHVzRGF0YS5zbGljZSgwLCByaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRTdXJwbHVzRGF0YVtyaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgIHJldHZhbFszXSA9IHJpZ2h0TWVyZ2VPcHRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiByaWdodERhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RGF0YVswXS5sZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sIHJpZ2h0RGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikgJiYgaXNEZWZpbmVkKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHJpZ2h0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0RGF0YVtsZWZ0RGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuZ2V0TGVmdFBlZXIoKS5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0RGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHREYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSwgcmlnaHREYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnREYXRhW2xlZnREYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmRhdGFbMF0ubGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLmRhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH07XG5cbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRDaGlsZChrZXkpLmZpbmQoa2V5KTtcbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRDaGlsZChzdGFydCkucmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW2luZGVudCArIFwiW2tleT1cIiArIGVsZW1lbnQua2V5LCBcIlxcblwiICsgaW5kZW50ICsgXCIgICAgTEVGVFxcblwiICsgZWxlbWVudC5sZWZ0LnRvU3RyaW5nKGluZGVudCArIFwiICAgIFwiKSwgXCJcXG5cIiArIGluZGVudCArIFwiICAgIFJJR0hUXFxuXCIgKyBlbGVtZW50LnJpZ2h0LnRvU3RyaW5nKGluZGVudCArIFwiICAgIFwiKSArIFwiXFxuXCIgKyBpbmRlbnQgKyBcIl1cIl07XG4gICAgICAgIH0pLmpvaW4oXCIsXFxuXCIpO1xuICAgIH07XG5cbiAgICB2YXIgTGVhZk5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgdGhpcy5sZWZ0UGVlciA9IG9wdGlvbnMubGVmdFBlZXI7XG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gb3B0aW9ucy5yaWdodFBlZXI7XG4gICAgfTtcblxuICAgIExlYWZOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgbWlkID0gbGVmdCArIE1hdGguZmxvb3IoKHJpZ2h0IC0gbGVmdCkgLyAyKTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICAgICAgICBpZiAoZGF0YVttaWRdLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW21pZF0ua2V5ID4ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVmdCAhPT0gcmlnaHQgJiYgIWZvdW5kKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIGlmIChjbG9iYmVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50LnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgY29uZGl0aW9uIG1heSBuZXZlciBvY2N1ciwgZ2l2ZW4gdGhlIHdheSBmaW5kSW5kZXggaXMgd3JpdHRlblxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5IDwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4ICsgMSwgMCwge1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdCgpO1xuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoIDwgdGhpcy5vcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmRhdGEubGVuZ3RoIC8gMik7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBMZWFmTm9kZSh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2UoMCwgc3BsaXRJbmRleCksXG4gICAgICAgICAgICBsZWZ0UGVlcjogdGhpcy5sZWZ0UGVlcixcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByaWdodE5vZGUgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgcmlnaHRQZWVyOiB0aGlzLnJpZ2h0UGVlcixcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xuICAgICAgICByaWdodE5vZGUuc2V0TGVmdFBlZXIobGVmdE5vZGUpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMubGVmdFBlZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLnJpZ2h0UGVlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0Tm9kZSwgdGhpcy5kYXRhW3NwbGl0SW5kZXhdLmtleSwgcmlnaHROb2RlXTtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGF0YS5sZW5ndGggJiYgZWxlbWVudC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnQudmFsdWVdLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPiB0aGlzLm1lcmdlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdE1lcmdlT3B0aW9uKSAmJiAhaXNEZWZpbmVkKHJpZ2h0TWVyZ2VPcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldHZhbCA9IFtdO1xuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XG4gICAgICAgIHZhciBsZWZ0U3VycGx1cyA9IDA7XG4gICAgICAgIHZhciBsZWZ0RGF0YTtcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XG4gICAgICAgIHZhciByaWdodERhdGE7XG4gICAgICAgIHZhciBsZWZ0UGVlciA9IHRoaXMubGVmdFBlZXI7XG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pKSB7XG4gICAgICAgICAgICBsZWZ0RGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgICByaWdodFN1cnBsdXMgPSByaWdodE1lcmdlT3B0aW9uLmdldFN1cnBsdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0U3VycGx1c0RhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0UmlnaHRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbGVmdFN1cnBsdXNEYXRhLmNvbmNhdCh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XG4gICAgICAgICAgICByZXR2YWxbMl0gPSB0aGlzLmRhdGFbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChyaWdodFN1cnBsdXNEYXRhKTtcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gcmlnaHRNZXJnZU9wdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXJnZWRMZWFmTm9kZTtcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnREYXRhKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KHJpZ2h0RGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRGVmaW5lZChyaWdodERhdGEpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdCh0aGlzLmRhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRMZWFmTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuZ2V0TGVmdFBlZXIoKS5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChyaWdodERhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQodGhpcy5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAmJiBlbGVtZW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgICB3aGlsZSAoaXNEZWZpbmVkKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IG5vZGUuZmluZEluZGV4KHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG5vZGUuZmluZEluZGV4KGVuZCk7XG4gICAgICAgICAgICB2YXIgbm9kZURhdGEgPSBub2RlLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgbm9kZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2gobm9kZURhdGFbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PSBub2RlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5nZXRSaWdodFBlZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICByZXR1cm4gaW5kZW50ICsgXCJbXCIgKyB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQua2V5O1xuICAgICAgICAgICAgfSkudG9TdHJpbmcoKSArIFwiXVwiO1xuICAgIH07XG5cbiAgICB2YXIgVHJlZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAxMDA7XG4gICAgICAgIHRoaXMubWVyZ2VUaHJlc2hvbGQgPSBvcHRpb25zLm1lcmdlVGhyZXNob2xkIHx8IDQwO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC50b1N0cmluZyhcIlwiKTtcbiAgICB9O1xuXG4gICAgVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcbiAgICAgICAgdmFyIG5ld05vZGVzID0gdGhpcy5yb290Lmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcbiAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbmV3Tm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2Rlc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHRoaXMucm9vdC5yZW1vdmUoa2V5KTtcbiAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcmV0dmFsWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR2YWxbMF07XG4gICAgfTtcblxuICAgIFRyZWUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZmluZChrZXkpO1xuICAgIH07XG5cbiAgICBUcmVlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBhbGwgdHlwZXMgb24gdG9wXG4gICAgVHJlZS5Ob2RlID0gTm9kZTtcbiAgICBUcmVlLkludGVybmFsTm9kZSA9IEludGVybmFsTm9kZTtcbiAgICBUcmVlLkxlYWZOb2RlID0gTGVhZk5vZGU7XG5cbiAgICAvLyBFbmFibGUgbW9kdWxlIGxvYWRpbmcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSkgeyAvLyBDb21tb25KU1xuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gVHJlZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lW1wiYW1kXCJdKSB7IC8vIEFNRFxuICAgICAgICBkZWZpbmUoXCJCUGx1c1RyZWVcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJlZTsgfSk7XG4gICAgfSBlbHNlIHsgLy8gU2hpbVxuICAgICAgICBpZiAoIWdsb2JhbFtcImRjb2RlSU9cIl0pIHtcbiAgICAgICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxbXCJkY29kZUlPXCJdW1wiQlBsdXNUcmVlXCJdID0gVHJlZTtcbiAgICB9XG5cbn0pKHRoaXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanMiLCIvKlxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBidHJlZS5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9kY29kZUlPL2J0cmVlLmpzIGZvciBkZXRhaWxzXG4gKi9cbihmdW5jdGlvbiAobW9kdWxlLCBjb25zb2xlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIG11bHRpcGxlIGFycmF5cyBpbnRvIGEgbmV3IG9uZS5cbiAgICAgKiBAcGFyYW0gey4uLltBcnJheV19IHZhcl9hcmdzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KHZhcl9hcmdzKSB7XG4gICAgICAgIC8vIEFycmF5I2NvbmNhdCBiZWhhdmVzIHN0cmFuZ2VseSBmb3IgZW1wdHkgYXJyYXlzLCBzby4uLlxuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYSwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBhbiBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHJldHVybnMge251bWJlcn0gSW5kZXggb3IgLTEgaWYgbm90IGZvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc2VhcmNoKGEsIHYpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBmYXN0ZXIgdGhhbiBBcnJheSNpbmRleE9mIGJlY2F1c2UgaXQncyByYXcuIEhvd2V2ZXIsIHdlXG4gICAgICAgIC8vIGNhbm5vdCB1c2UgYmluYXJ5IHNlYXJjaCBiZWNhdXNlIG5vZGVzIGRvIG5vdCBoYXZlIGEgY29tcGFyYWJsZVxuICAgICAgICAvLyBrZXkuIElmIHRoZSBjb21waWxlciBpcyBzbWFydCwgaXQgd2lsbCBpbmxpbmUgdGhpcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC1pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJ0cmVlIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gICAgICovXG4gICAgdmFyIGJ0cmVlID0ge307XG5cbiAgICAvKipcbiAgICAgKiBTdHJpY3RseSBjb21wYXJlcyB0d28gc3RyaW5ncywgY2hhcmFjdGVyIGJ5IGNoYXJhY3Rlci4gTm8gbG9jYWxlcywgbm8gbnVtYmVyIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgYSA8IGIsIDEgaWYgYSA+IGIsIDAgb3RoZXJ3aXNlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIGJ0cmVlLnN0cmNtcCA9IGZ1bmN0aW9uIHN0cmNtcChhLCBiKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB2YXIgYWM7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB2YXIgYmM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYWMgPSBhLmNoYXJDb2RlQXQoaSkpIDwgKGJjID0gYi5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWMgPiBiYykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgc2FtZSwgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggPyAwIDogLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBudW1iZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgYnRyZWUubnVtY21wID0gZnVuY3Rpb24gaW50Y21wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAoYSA+IGIgPyAxIDogMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBCVHJlZSBjbGFzcyB1c2luZyB0aGUgZ2l2ZW4gb3JkZXIuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgYSBjbGFzcywgbm90IGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb3JkZXIgRGVmYXVsdHMgdG8gMlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oPywgPyk6bnVtYmVyPX0gY29tcGFyZSBDb21wYXJlIGltcGxlbWVudGF0aW9uIHRvIHVzZSBvbiBrZXlzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBidHJlZS5jcmVhdGUgPSBmdW5jdGlvbiAob3JkZXIsIGNvbXBhcmUpIHtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBvcmRlclxuICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcmRlciA9IDUyOyAvLyBCZW5jaG1hcmtzIHByb29mZWQgdGhhdCB0aGlzIGlzIGNsb3NlIHRvIHRoZSBvcHRpbXVtXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9yZGVyID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcmRlciA9IE1hdGguZmxvb3Iob3JkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXIgPSBwYXJzZUludChvcmRlciwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRlciA8IDEpIG9yZGVyID0gMTtcbiAgICAgICAgdmFyIG1pbk9yZGVyID0gb3JkZXIgPiAxID8gTWF0aC5mbG9vcihvcmRlciAvIDIpIDogMTtcblxuICAgICAgICAvLyBVc2UgbnVtY21wIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbXBhcmUgPSBidHJlZS5udW1jbXA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGVzIGEgbm9kZSBhbmQgcHJpbnRzIGRlYnVnZ2luZyBpbmZvIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZXwhVHJlZX0gbm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkgeyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgc3RyaXBwZWQgYnkgdGhlIGNvbXBpbGVyXG4gICAgICAgICAgICBpZiAoKG5vZGUgaW5zdGFuY2VvZiBUcmVlKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhdmVzLmxlbmd0aCArIDEgIT0gbm9kZS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBJbGxlZ2FsIGxlYWYvbm9kZSBjb3VudCBpbiBcIiArIG5vZGUgKyBcIjogXCIgKyBub2RlLmxlYXZlcy5sZW5ndGggKyBcIi9cIiArIG5vZGUubm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhdmVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbGVhZiBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogXCIgKyBub2RlLmxlYXZlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubm9kZXNbaV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogSWxsZWdhbCBub2RlIGluIFwiICsgbm9kZSArIFwiIGF0IFwiICsgaSArIFwiOiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVHJlZU5vZGUuXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWVOb2RlLlxuICAgICAgICAgKiBAcGFyYW0geyEoVHJlZU5vZGV8VHJlZSl9IHBhcmVudCBQYXJlbnQgbm9kZVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjwhTGVhZj49fSBsZWF2ZXMgTGVhZiBub2Rlc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxUcmVlTm9kZT49fSBub2RlcyBDaGlsZCBub2Rlc1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBUcmVlTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGxlYXZlcywgbm9kZXMpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJlbnQgbm9kZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshVHJlZU5vZGV8IVRyZWV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlYWYgbm9kZXMgKG1heC4gb3JkZXIpLlxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48IUxlYWY+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxlYXZlcyA9IGxlYXZlcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGlsZCBub2RlcyAobWF4LiBvcmRlcisxKS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPFRyZWVOb2RlPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzIHx8IFtudWxsXTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSBub2RlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoZXMgZm9yIHRoZSBub2RlIHRoYXQgd291bGQgY29udGFpbiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHt7bGVhZjogIUxlYWYsIGluZGV4OiBudW1iZXJ9fHtub2RlOiAhVHJlZU5vZGUsIGluZGV4OiBudW1iZXJ9fSBMZWFmIGlmIHRoZSBrZXkgZXhpc3RzLCBlbHNlIHRoZSBpbnNlcnRpb24gbm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmxlYXZlc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhLmtleSwga2V5KSA9PSAwKSByZXR1cm4ge2xlYWY6IGEsIGluZGV4OiAwfTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIGEua2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLnNlYXJjaChrZXkpOyAvLyBMZWZ0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogMH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubGVhdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShiLmtleSwga2V5KSA9PSAwKSByZXR1cm4ge2xlYWY6IGIsIGluZGV4OiBpfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBiLmtleSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBJbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogaX07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBSaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge25vZGU6IHRoaXMsIGluZGV4OiBpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7bm9kZTogdGhpcywgaW5kZXg6IDB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHsqfHVuZGVmaW5lZH0gSWYgdGhlcmUgaXMgbm8gc3VjaCBrZXksIHVuZGVmaW5lZCBpcyByZXR1cm5lZFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSByZXR1cm4gcmVzdWx0LmxlYWYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIGEga2V5L3ZhbHVlIHBhaXIgaW50byB0aGlzIG5vZGUuXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzdWNjZXNzZnVsbHkgc2V0LCBmYWxzZSBpZiBhbHJlYWR5IHByZXNlbnQgYW5kIG92ZXJ3cml0ZSBpcyBgZmFsc2VgXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoKGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJ3cml0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZWFmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IC8vIEtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgdmFyIG5vZGUgPSByZXN1bHQubm9kZSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMCwgbmV3IExlYWYobm9kZSwga2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgbm9kZS5ub2Rlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYXZlcy5sZW5ndGggPiBvcmRlcikgeyAvLyBSZWJhbGFuY2VcbiAgICAgICAgICAgICAgICBub2RlLnNwbGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoaXMgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXkgaGFzIGJlZW4gZGVsZXRlZCwgZmFsc2UgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQubGVhZikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxlYWYgPSByZXN1bHQubGVhZixcbiAgICAgICAgICAgICAgICBub2RlID0gbGVhZi5wYXJlbnQsXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXgsXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5vZGUubm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxlYXZlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIG5vZGUubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBub2RlLmJhbGFuY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IGxlZnQubGVhdmVzW2xlZnQubGVhdmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxlZnQuZGVsKG1heC5rZXkpO1xuICAgICAgICAgICAgICAgIG1heC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWxhbmNlcyB0aGlzIG5vZGUgdG8gZnVsZmlsbCBhbGwgY29uZGl0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogUm9vdCBoYXMganVzdCBhIHNpbmdsZSBjaGlsZCBhbmQgbm8gbGVhdmVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA9PSAwICYmIHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucm9vdCA9IHRoaXMubm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJvb3QucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPj0gbWluT3JkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBhc2VhcmNoKHRoaXMucGFyZW50Lm5vZGVzLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaW5kZXggPiAwID8gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggLSAxXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcmVudC5ub2Rlcy5sZW5ndGggPiBpbmRleCArIDEgPyB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCArIDFdIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBzZXAsIGxlYWYsIHJlc3Q7XG4gICAgICAgICAgICBpZiAocmlnaHQgIT09IG51bGwgJiYgcmlnaHQubGVhdmVzLmxlbmd0aCA+IG1pbk9yZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzZXBlcmF0b3IgZnJvbSBwYXJlbnQgdG8gdGhpc1xuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgc2VwLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMucHVzaChzZXApO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGJsYW5rIHdpdGggdGhlIGZpcnN0IHJpZ2h0IGxlYWZcbiAgICAgICAgICAgICAgICBsZWFmID0gcmlnaHQubGVhdmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJpZ2h0IHJlc3QgdG8gdGhpc1xuICAgICAgICAgICAgICAgIHJlc3QgPSByaWdodC5ub2Rlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHJlc3QpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSBudWxsICYmIGxlZnQubGVhdmVzLmxlbmd0aCA+IG1pbk9yZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgc2VwZXJhdG9yIGZyb20gcGFyZW50IHRvIHRoaXNcbiAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBzZXAucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy51bnNoaWZ0KHNlcCk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgYmxhbmsgd2l0aCB0aGUgbGFzdCBsZWZ0IGxlYWZcbiAgICAgICAgICAgICAgICBsZWFmID0gbGVmdC5sZWF2ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXSA9IGxlYWY7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgbGVmdCByZXN0IHRvIHRoaXNcbiAgICAgICAgICAgICAgICByZXN0ID0gbGVmdC5ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdCAhPT0gbnVsbCkgcmVzdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMudW5zaGlmdChyZXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0O1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoaXMgKyBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50ICsgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gdGhpcy5wYXJlbnQubGVhdmVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIGNvbmNhdCh0aGlzLmxlYXZlcywgW3NlcF0sIHJpZ2h0LmxlYXZlcyksIGNvbmNhdCh0aGlzLm5vZGVzLCByaWdodC5ub2RlcykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVhdmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCByZXBsYWNlIHRoZSBub2RlcyBpdCBzZXBlcmF0ZWQgd2l0aCBzdWJzdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXgsIDIsIHN1YnN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluZSBsZWZ0ICsgc2VwZXJhdG9yIGZyb20gcGFyZW50ICsgdGhpc1xuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIGNvbmNhdChsZWZ0LmxlYXZlcywgW3NlcF0sIHRoaXMubGVhdmVzKSwgY29uY2F0KGxlZnQubm9kZXMsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlcy5zcGxpY2UoaW5kZXggLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHJlcGxhY2UgdGhlIG5vZGVzIGl0IHNlcGVyYXRlZCB3aXRoIHN1YnN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lm5vZGVzLnNwbGljZShpbmRleCAtIDEsIDIsIHN1YnN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IFwiICsgdGhpcy50b1N0cmluZyh0cnVlKSArIFwiIGhhcyBuZWl0aGVyIGEgbGVmdCBub3IgYSByaWdodCBzaWJsaW5nXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuYmFsYW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsaWRhdGUodGhpcyk7XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSh0aGlzLnBhcmVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuc3BsaXRzIGEgY2hpbGQuXG4gICAgICAgICAqIEBwYXJhbSB7IUxlYWZ9IGxlYWZcbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV9IHJlc3RcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS51bnNwbGl0ID0gZnVuY3Rpb24gKGxlYWYsIHJlc3QpIHtcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHJlc3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5sZWF2ZXNbMF07XG4gICAgICAgICAgICBpZiAoY29tcGFyZShsZWFmLmtleSwgYS5rZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnVuc2hpZnQobGVhZik7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zcGxpY2UoMSwgMCwgcmVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmxlYXZlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUobGVhZi5rZXksIGIua2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnNwbGljZShpLCAwLCBsZWFmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuc3BsaWNlKGkgKyAxLCAwLCByZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA+IG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGxpdHMgdGhpcyBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmxlYXZlcy5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoMCwgaW5kZXgpLCB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoaW5kZXggKyAxKSwgdGhpcy5ub2Rlcy5zbGljZShpbmRleCArIDEpKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBbdGhpcy5sZWF2ZXNbaW5kZXhdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWYgPSB0aGlzLmxlYXZlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIHRoaXMubGVhdmVzLnNsaWNlKGluZGV4ICsgMSksIHRoaXMubm9kZXMuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC51bnNwbGl0KGxlYWYsIHJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZU5vZGVzIFdoZXRoZXIgdG8gaW5jbHVkZSBzdWItbm9kZXMgb3Igbm90XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5jbHVkZU5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsLnB1c2godGhpcy5sZWF2ZXNbaV0ua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzID0gXCJbXCIgKyB2YWwudG9TdHJpbmcoKSArIFwiXVwiICsgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSA/IFwiOipcIiA6IFwiOlwiICsgdGhpcy5wYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVOb2Rlcykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCIgLT4gXCIgKyB0aGlzLm5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmludHMgb3V0IHRoZSBub2RlcyBsZWF2ZXMgYW5kIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZW50XG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRlbnQ7IGkrKykgc3BhY2UgKz0gXCIgXCI7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLmxlYXZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2kgKyAxXSAhPT0gbnVsbCkgdGhpcy5ub2Rlc1tpICsgMV0ucHJpbnQoaW5kZW50ICsgMik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3BhY2UgKyB0aGlzLmxlYXZlc1tpXS5rZXkgKyAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlID8gXCIqXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkgdGhpcy5ub2Rlc1swXS5wcmludChpbmRlbnQgKyAyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBMZWFmIGNvbnRhaW5pbmcgYSB2YWx1ZS5cbiAgICAgICAgICogQGNsYXNzIEEgTGVhZi5cbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV9IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBMZWFmID0gZnVuY3Rpb24gKHBhcmVudCwga2V5LCB2YWx1ZSkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcmVudCBub2RlLlxuICAgICAgICAgICAgICogQHR5cGUgeyFUcmVlTm9kZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogS2V5LlxuICAgICAgICAgICAgICogQHR5cGUgeyEqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWYWx1ZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIExlYWYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLmtleTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlLlxuICAgICAgICAgKiBAY2xhc3MgQSBUcmVlLlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgVHJlZU5vZGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBhIGtleS92YWx1ZSBwYWlyIGludG8gdGhlIHRyZWUuXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzZXQsIGZhbHNlIGlmIGFscmVhZHkgcHJlc2VudCBhbmQgb3ZlcndyaXRlIGlzIGBmYWxzZWBcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIgKyB2YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5wdXQoa2V5LCB2YWx1ZSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7Knx1bmRlZmluZWR9IElmIHRoZXJlIGlzIG5vIHN1Y2gga2V5LCB1bmRlZmluZWQgaXMgcmV0dXJuZWRcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGtleSA9PT0gbnVsbCkgIHRocm93KG5ldyBFcnJvcihcIklsbGVnYWwga2V5OiBcIiArIGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXQoa2V5KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGtleSBoYXMgYmVlbiBkZWxldGVkLCBmYWxzZSBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpICB0aHJvdyhuZXcgRXJyb3IoXCJJbGxlZ2FsIGtleTogXCIgKyBrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuZGVsKGtleSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhbGtzIHRocm91Z2ggYWxsIGtleXMgW21pbktleSwgLi4uLCBtYXhLZXldIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgICAgICogQHBhcmFtIHsqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCl9IG1pbktleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBOVUxMLCB3YWxrcyB0aWxsIHRoZSBlbmRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nIHRoZSBrZXkgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGFzIGl0c1xuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0FzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QubGVhdmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW5LZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWluS2V5O1xuICAgICAgICAgICAgICAgIG1pbktleSA9IG1heEtleSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXhLZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWF4S2V5O1xuICAgICAgICAgICAgICAgIG1heEtleSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaW5LZXkgPSB0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbDtcbiAgICAgICAgICAgIG1heEtleSA9IHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHB0ciwgaW5kZXg7XG4gICAgICAgICAgICBpZiAobWluS2V5ID09PSBudWxsKSB7IC8vIElmIHRoZXJlIGlzIG5vIG1pbmltdW0gbGltaXRcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJvb3Q7IC8vIHNldCBwdHIgdG8gdGhlIG91dGVyIGxlZnQgbm9kZVxuICAgICAgICAgICAgICAgIHdoaWxlIChwdHIubm9kZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7IC8vIGFuZCBzdGFydCBhdCBpdHMgZmlyc3QgbGVhZlxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gRWxzZSBsb29rdXBcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtaW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikgeyAvLyBJZiB0aGUgbWluaW11bSBrZXkgaXRzZWxmIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBwdHIgPSByZXN1bHQubGVhZi5wYXJlbnQ7IC8vIHNldCBwdHIgdG8gdGhlIGNvbnRhaW5pbmcgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgICAgICAgICBwdHIgPSByZXN1bHQubm9kZTsgLy8gc2V0IHB0ciB0byB0aGUgaW5zZXJ0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXg7IC8vIGFuZCBzdGFydCBhdCB0aGUgaW5zZXJ0aW9uIGluZGV4IChrZXkgPiBtaW5LZXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBwdHIubGVhdmVzLmxlbmd0aCkgeyAvLyBvbiBvdmVycnVuLCBiZWdpbiBhdCB0aGUgc2VwYXJhdG9yIGluIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHB0ci5wYXJlbnQubGVhdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwdHIvaW5kZXggbm93IHBvaW50cyBhdCBvdXIgZmlyc3QgcmVzdWx0XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXhLZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1heEtleSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBrZXlzIGxlc3MgdGhhbiBtYXhLZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgcHRyLmxlYXZlc1tpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGJyZWFrcyB0aGUgbG9vcCBieSByZXR1cm5pbmcgdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHRyLm5vZGVzW2luZGV4ICsgMV0gIT09IG51bGwpIHsgLy8gRGVzY2VuZFxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHB0ci5sZWF2ZXMubGVuZ3RoID4gaW5kZXggKyAxKSB7IC8vIE5leHRcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBBc2NlbmRcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4ID49IHB0ci5sZWF2ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIG9mIHtAbGluayBUcmVlI3dhbGtBc2N9LlxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICogQHBhcmFtIHsoKnwoZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSkpPX0gbWF4S2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgd2Fsa3MgdGlsbCB0aGUgZW5kXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLndhbGsgPSBUcmVlLnByb3RvdHlwZS53YWxrQXNjO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCBrZXlzIFttaW5LZXksIC4uLiwgbWF4S2V5XSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgbnVsbCwgd2Fsa3MgdGlsbCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBudWxsLCBzdGFydHMgYXQgdGhlIGVuZFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXG4gICAgICAgICAqICBwYXJhbWV0ZXJzLiBNYXkgZXhwbGljaXRseSByZXR1cm4gdHJ1ZSB0byBzdG9wIHRoZSBsb29wLlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS53YWxrRGVzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWluS2V5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1pbktleTtcbiAgICAgICAgICAgICAgICBtaW5LZXkgPSBtYXhLZXkgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4S2V5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1heEtleTtcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWluS2V5ID0gdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGw7XG4gICAgICAgICAgICBtYXhLZXkgPSB0eXBlb2YgbWF4S2V5ICE9ICd1bmRlZmluZWQnID8gbWF4S2V5IDogbnVsbDtcbiAgICAgICAgICAgIHZhciBwdHIsIGluZGV4O1xuICAgICAgICAgICAgaWYgKG1heEtleSA9PT0gbnVsbCkgeyAvLyBJZiB0aGVyZSBpcyBubyBtYXhpbXVtIGxpbWl0XG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yb290OyAvLyBzZXQgcHRyIHRvIHRoZSBvdXRlciByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwdHIubGVhdmVzLmxlbmd0aCAtIDE7IC8vIGFuZCBzdGFydCBhdCBpdHMgbGFzdCBsZWFmXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBFbHNlIGxvb2t1cFxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJvb3Quc2VhcmNoKG1heEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7IC8vIElmIHRoZSBtYXhpbXVtIGtleSBpdHNlbGYgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5sZWFmLnBhcmVudDsgLy8gc2V0IHB0ciB0byB0aGUgY29udGFpbmluZyBub2RlXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIubGVhdmVzLCByZXN1bHQubGVhZik7IC8vIGFuZCBzdGFydCBhdCBpdHMgaW5kZXhcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5ub2RlOyAvLyBzZXQgcHRyIHRvIHRoZSBpbnNlcnRpb24gbm9kZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdC5pbmRleCAtIDE7IC8vIGFuZCBzdGFydCBhdCB0aGUgaW5zZXJ0aW9uIGluZGV4LTEgKGtleSA8IG1heEtleSlcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgMCkgeyAvLyBvbiB1bmRlcnJ1biwgYmVnaW4gYXQgdGhlIHNlcGFyYXRvciBpbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVtcHR5IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB0ci9pbmRleCBub3cgcG9pbnRzIGF0IG91ciBmaXJzdCByZXN1bHRcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbktleSAhPT0gbnVsbCAmJiBjb21wYXJlKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgbWluS2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGtleXMgYmlnZ2VyIHRoYW4gbWluS2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhwdHIubGVhdmVzW2luZGV4XS5rZXksIHB0ci5sZWF2ZXNbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBicmVha3MgdGhlIGxvb3AgYnkgcmV0dXJuaW5nIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHB0ci5ub2Rlc1tpbmRleF0gIT09IG51bGwpIHsgLy8gRGVzY2VuZFxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHB0ci5sZWF2ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkgeyAvLyBOZXh0XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXNjZW5kXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5wYXJlbnQubm9kZXMsIHB0cikgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaW5kZXggPCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGtleXMgYmV0d2VlbiBtaW5LZXkgYW5kIG1heEtleSAoYm90aCBpbmNsdXNpdmUpLlxuICAgICAgICAgKiBAcGFyYW0geyo9fSBtaW5LZXkgSWYgb21pdHRlZCwgY291bnRzIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7Kj19IG1heEtleSBJZiBvbWl0dGVkLCBjb3VudHMgdGlsbCB0aGUgZW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKG1pbktleSwgbWF4S2V5KSB7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB0aGlzLndhbGsoXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgbisrOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaW50cyBvdXQgYWxsIG5vZGVzIGluIHRoZSB0cmVlLlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5wcmludCgwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUcmVlKFwiICsgb3JkZXIgKyBcIikgXCIgKyB0aGlzLnJvb3QudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVHJlZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBidHJlZTtcblxufSkobW9kdWxlLCBjb25zb2xlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQlRyZWUuanMiLCIvKlxuIOaKmOWNiuafpeaJvihCaW5hcnkgU2VhcmNoKVxuXG4g5oqY5Y2K5p+l5om+5Y+I56ew5Li65LqM5YiG5p+l5om+77yM5piv5LiA56eN5pWI546H6L6D6auY55qE5p+l5om+5pa55rOV44CCXG4g5YmN5o+Q5p2h5Lu277ya5p+l5om+6KGo5Lit55qE5omA5pyJ6K6w5b2V5piv5oyJ5YWz6ZSu5a2X5pyJ5bqPKOWNh+W6j+aIlumZjeW6jykg44CCXG4g5p+l5om+6L+H56iL5Lit77yM5YWI56Gu5a6a5b6F5p+l5om+6K6w5b2V5Zyo6KGo5Lit55qE6IyD5Zu077yM54S25ZCO6YCQ5q2l57yp5bCP6IyD5Zu0KOavj+asoeWwhuW+heafpeiusOW9leaJgOWcqOWMuumXtOe8qeWwj+S4gOWNiinvvIznm7TliLDmib7liLDmiJbmib7kuI3liLDorrDlvZXkuLrmraLjgIJcblxuIDEgIOafpeaJvuaAneaDs1xuIOeUqExvd+OAgUhpZ2jlkoxNaWTooajnpLrlvoXmn6Xmib7ljLrpl7TnmoTkuIvnlYzjgIHkuIrnlYzlkozkuK3pl7TkvY3nva7mjIfpkojvvIzliJ3lgLzkuLpMb3c9MO+8jEhpZ2g9biAtIDHjgIJcbiDikbQgIOWPluS4remXtOS9jee9rk1pZO+8mk1pZD1NYXRoLmZsb29yKChMb3crSGlnaCkvMinvvJtcbiDikbUgIOavlOi+g+S4remXtOS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcbiDikaAgIOebuOetie+8miDmn6Xmib7miJDlip/vvJtcbiDikaEgIOWkp+S6ju+8muW+heafpeiusOW9leWcqOWMuumXtOeahOWJjeWNiuaute+8jOS/ruaUueS4iueVjOaMh+mSiO+8miBIaWdoPU1pZC0x77yM6L2s4pG0IO+8m1xuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q6177yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m1xuIOebtOWIsOi2iueVjChMb3c+SGlnaCnvvIzmn6Xmib7lpLHotKXjgIJcblxuIDIgIOeul+azleWIhuaekFxuIOKRoCAg5p+l5om+5pe25q+P57uP6L+H5LiA5qyh5q+U6L6D77yM5p+l5om+6IyD5Zu05bCx57yp5bCP5LiA5Y2K77yM6K+l6L+H56iL5Y+v55So5LiA5qO15LqM5Y+J5qCR6KGo56S677yaXG4g4peGIOaguee7k+eCueWwseaYr+esrOS4gOasoei/m+ihjOavlOi+g+eahOS4remXtOS9jee9rueahOiusOW9le+8m1xuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7liY3pnaLnmoTkvZzkuLrlt6blrZDmoJHnmoTnu5PngrnvvJtcbiDil4Yg5o6S5Zyo5Lit6Ze05L2N572u5ZCO6Z2i55qE5L2c5Li65Y+z5a2Q5qCR55qE57uT54K577ybXG4g5a+55ZCE5a2Q5qCR5p2l6K+06YO95piv55u45ZCM55qE44CC6L+Z5qC35omA5b6X5Yiw55qE5LqM5Y+J5qCR56ew5Li65Yik5a6a5qCRKERlY2lzaW9uIFRyZWUp44CCXG4g4pGhICDlsIbkuozlj4nliKTlrprmoJHnmoTnrKxNYXRoLmZsb29yKE1hdGgubG9nKDIsIG4pKSsx5bGC5LiK55qE57uT54K56KGl6b2Q5bCx5oiQ5Li65LiA5qO15ruh5LqM5Y+J5qCR77yM5rex5bqm5LiN5Y+Y77yMaD0gTWF0aC5mbG9vcihNYXRoLmxvZygyLCBuICsgMSkpIOOAglxuIOKRoiAg55Sx5ruh5LqM5Y+J5qCR5oCn6LSo55+l77yM56ysaSDlsYLkuIrnmoTnu5PngrnmlbDkuLpNYXRoLnBvdygyLCBpLTEpKGk8PWgpIO+8jOiuvuihqOS4reavj+S4quiusOW9leeahOafpeaJvuamgueOh+ebuOetie+8jOWNs1BpPTEvbu+8jOafpeaJvuaIkOWKn+aXtueahOW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mlxuIChuKzEpL24qTWF0aC5sb2coMixuKzEpLTFcbiDlvZNu5b6I5aSnIChuPjUwKeaXtu+8jCBBU0ziiYggTWF0aC5sb2coMixuKzEpLTHjgIJcblxuXG4g5pe26Ze05aSN5p2C5bqmTyhsb2duKVxuICovXG5cbi8vIOmdnumAkuW9kuW8j1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChzVGFibGUsIGtleSkge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZShsb3cgPD0gaGlnaCl7XG4gICAgICAgIGxldCAgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgIGxldCBlbGVtID0gc1RhYmxlW21pZF07XG5cbiAgICAgICAgaWYoZWxlbSA9PT0ga2V5KSByZXR1cm4gbWlkO1xuICAgICAgICBlbHNlIGlmKGVsZW0gPCBrZXkpIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGlnaCA9IG1pZCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG5jb25zb2xlLmxvZygnYmluYXJ5U2VhcmNoOiAnKTtcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDEpKTsgIC8vIDBcblxuLy8g6YCS5b2S5byPXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoUmVjdXJzaXZlKHNUYWJsZSwga2V5LCBsb3cgPSAwLCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDEpIHtcbiAgICBpZihsb3cgPiBoaWdoKSByZXR1cm4gLTE7XG5cbiAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgbGV0IGVsZW0gPSBzVGFibGVbbWlkXTtcblxuICAgIGlmKGVsZW0gPT09IGtleSkgcmV0dXJuIG1pZDtcbiAgICBlbHNlIGlmKGVsZW0gPCBrZXkpIHJldHVybiBiaW5hcnlTZWFyY2hSZWN1cnNpdmUoc1RhYmxlLCBrZXksIG1pZCArIDEsIGhpZ2gpO1xuICAgIGVsc2UgcmV0dXJuIGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShzVGFibGUsIGtleSwgbG93LCBtaWQgLSAxKTtcbn1cblxuY29uc29sZS5sb2coJ2JpbmFyeVNlYXJjaFJlY3Vyc2l2ZTogJyk7XG5jb25zb2xlLmxvZyhiaW5hcnlTZWFyY2hSZWN1cnNpdmUoWzEsIDIsIDMsIDQsIDVdLCAxKSk7IC8vIDBcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQmluYXJ5U2VhcmNoLmpzIiwiLypcbiBCbG9vbSBGaWx0ZXLmmK/kuIDnp43nqbrpl7TmlYjnjoflvojpq5jnmoTpmo/mnLrmlbDmja7nu5PmnoTvvIzlroPliKnnlKjkvY3mlbDnu4TlvojnroDmtIHlnLDooajnpLrkuIDkuKrpm4blkIjvvIzlubbog73liKTmlq3kuIDkuKrlhYPntKDmmK/lkKblsZ7kuo7ov5nkuKrpm4blkIjjgIJCbG9vbSBGaWx0ZXLnmoTov5nnp43pq5jmlYjmmK/mnInkuIDlrprku6Pku7fnmoTvvJrlnKjliKTmlq3kuIDkuKrlhYPntKDmmK/lkKblsZ7kuo7mn5DkuKrpm4blkIjml7bvvIzmnInlj6/og73kvJrmiorkuI3lsZ7kuo7ov5nkuKrpm4blkIjnmoTlhYPntKDor6/orqTkuLrlsZ7kuo7ov5nkuKrpm4blkIjvvIhmYWxzZSBwb3NpdGl2Ze+8ieOAguWboOatpO+8jEJsb29tIEZpbHRlcuS4jemAguWQiOmCo+S6m+KAnOmbtumUmeivr+KAneeahOW6lOeUqOWcuuWQiOOAguiAjOWcqOiDveWuueW/jeS9jumUmeivr+eOh+eahOW6lOeUqOWcuuWQiOS4i++8jEJsb29tIEZpbHRlcumAmui/h+aegeWwkeeahOmUmeivr+aNouWPluS6huWtmOWCqOepuumXtOeahOaegeWkp+iKguecgeOAglxuXG4g5Li65LqG6ZmN5L2O5Yay56qB55qE5qaC5b+177yMQmxvb20gRmlsdGVy5L2/55So5LqG5aSa5Liq5ZOI5biM5Ye95pWw77yM6ICM5LiN5piv5LiA5Liq44CCXG5cbiBCbG9vbSBGaWx0ZXLnrpfms5XlpoLkuIvvvJpcbiDliJvlu7rkuIDkuKpt5L2NQml0U2V077yM5YWI5bCG5omA5pyJ5L2N5Yid5aeL5YyW5Li6MO+8jOeEtuWQjumAieaLqWvkuKrkuI3lkIznmoTlk4jluIzlh73mlbDjgILnrKxp5Liq5ZOI5biM5Ye95pWw5a+55a2X56ym5Liyc3Ry5ZOI5biM55qE57uT5p6c6K6w5Li6aO+8iGnvvIxzdHLvvInvvIzkuJRo77yIae+8jHN0cu+8ieeahOiMg+WbtOaYrzDliLBtLTEg44CCXG5cbiAoMSkg5Yqg5YWl5a2X56ym5Liy6L+H56iLXG4g5LiL6Z2i5piv5q+P5Liq5a2X56ym5Liy5aSE55CG55qE6L+H56iL77yM6aaW5YWI5piv5bCG5a2X56ym5Liyc3Ry4oCc6K6w5b2V4oCd5YiwQml0U2V05Lit55qE6L+H56iL77yaXG4g5a+55LqO5a2X56ym5Liyc3Ry77yM5YiG5Yir6K6h566XaO+8iDHvvIxzdHLvvInvvIxo77yIMu+8jHN0cu+8ieKApuKApiBo77yIa++8jHN0cu+8ieOAgueEtuWQjuWwhkJpdFNldOeahOesrGjvvIgx77yMc3Ry77yJ44CBaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInkvY3orr7kuLox44CCXG5cbiAoMikg5qOA5p+l5a2X56ym5Liy5piv5ZCm5a2Y5Zyo55qE6L+H56iLXG4g5LiL6Z2i5piv5qOA5p+l5a2X56ym5Liyc3Ry5piv5ZCm6KKrQml0U2V06K6w5b2V6L+H55qE6L+H56iL77yaXG4g5a+55LqO5a2X56ym5Liyc3Ry77yM5YiG5Yir6K6h566XaO+8iDHvvIxzdHLvvInvvIxo77yIMu+8jHN0cu+8ieKApuKApiBo77yIa++8jHN0cu+8ieOAgueEtuWQjuajgOafpUJpdFNldOeahOesrGjvvIgx77yMc3Ry77yJ44CBaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInkvY3mmK/lkKbkuLox77yM6Iul5YW25Lit5Lu75L2V5LiA5L2N5LiN5Li6MeWImeWPr+S7peWIpOWumnN0cuS4gOWumuayoeacieiiq+iusOW9lei/h+OAguiLpeWFqOmDqOS9jemDveaYrzHvvIzliJnigJzorqTkuLrigJ3lrZfnrKbkuLJzdHLlrZjlnKjjgIJcbiDoi6XkuIDkuKrlrZfnrKbkuLLlr7nlupTnmoRCaXTkuI3lhajkuLox77yM5YiZ5Y+v5Lul6IKv5a6a6K+l5a2X56ym5Liy5LiA5a6a5rKh5pyJ6KKrQmxvb20gRmlsdGVy6K6w5b2V6L+H44CC77yI6L+Z5piv5pi+54S255qE77yM5Zug5Li65a2X56ym5Liy6KKr6K6w5b2V6L+H77yM5YW25a+55bqU55qE5LqM6L+b5Yi25L2N6IKv5a6a5YWo6YOo6KKr6K6+5Li6MeS6hu+8iVxuIOOAgOS9huaYr+iLpeS4gOS4quWtl+espuS4suWvueW6lOeahEJpdOWFqOS4ujHvvIzlrp7pmYXkuIrmmK/kuI3og70xMDAl55qE6IKv5a6a6K+l5a2X56ym5Liy6KKrQmxvb20gRmlsdGVy6K6w5b2V6L+H55qE44CC77yI5Zug5Li65pyJ5Y+v6IO96K+l5a2X56ym5Liy55qE5omA5pyJ5L2N6YO95Yia5aW95piv6KKr5YW25LuW5a2X56ym5Liy5omA5a+55bqU77yJ6L+Z56eN5bCG6K+l5a2X56ym5Liy5YiS5YiG6ZSZ55qE5oOF5Ya177yM56ew5Li6ZmFsc2UgcG9zaXRpdmXjgIJcblxuICgzKSDliKDpmaTlrZfnrKbkuLLov4fnqItcbiDlrZfnrKbkuLLliqDlhaXkuoblsLHooqvkuI3og73liKDpmaTkuobvvIzlm6DkuLrliKDpmaTkvJrlvbHlk43liLDlhbbku5blrZfnrKbkuLLjgILlrp7lnKjpnIDopoHliKDpmaTlrZfnrKbkuLLnmoTlj6/ku6Xkvb/nlKhDb3VudGluZyBibG9vbWZpbHRlcihDQkYp77yM6L+Z5piv5LiA56eN5Z+65pysQmxvb20gRmlsdGVy55qE5Y+Y5L2T77yMQ0JG5bCG5Z+65pysQmxvb20gRmlsdGVy5q+P5LiA5LiqQml05pS55Li65LiA5Liq6K6h5pWw5Zmo77yM6L+Z5qC35bCx5Y+v5Lul5a6e546w5Yig6Zmk5a2X56ym5Liy55qE5Yqf6IO95LqG44CCXG5cbiBCbG9vbSBGaWx0ZXLot5/ljZXlk4jluIzlh73mlbBCaXQtTWFw5LiN5ZCM5LmL5aSE5Zyo5LqO77yaQmxvb20gRmlsdGVy5L2/55So5LqGa+S4quWTiOW4jOWHveaVsO+8jOavj+S4quWtl+espuS4sui3n2vkuKpiaXTlr7nlupTjgILku47ogIzpmY3kvY7kuoblhrLnqoHnmoTmpoLnjofjgIJcblxuIEJsb29tIEZpbHRlcuWPguaVsOmAieaLqVxuICgxKeWTiOW4jOWHveaVsOmAieaLqVxuIOOAgOOAgOWTiOW4jOWHveaVsOeahOmAieaLqeWvueaAp+iDveeahOW9seWTjeW6lOivpeaYr+W+iOWkp+eahO+8jOS4gOS4quWlveeahOWTiOW4jOWHveaVsOimgeiDvei/keS8vOetieamgueOh+eahOWwhuWtl+espuS4suaYoOWwhOWIsOWQhOS4qkJpdOOAgumAieaLqWvkuKrkuI3lkIznmoTlk4jluIzlh73mlbDmr5TovoPpurvng6bvvIzkuIDnp43nroDljZXnmoTmlrnms5XmmK/pgInmi6nkuIDkuKrlk4jluIzlh73mlbDvvIznhLblkI7pgIHlhaVr5Liq5LiN5ZCM55qE5Y+C5pWw44CCXG5cbiAoMikgbSxuLGvlgLzvvIzmiJHku6zlpoLkvZXlj5blgLxcbiDmiJHku6zlrprkuYnvvJpcbiDlj6/og73miorkuI3lsZ7kuo7ov5nkuKrpm4blkIjnmoTlhYPntKDor6/orqTkuLrlsZ7kuo7ov5nkuKrpm4blkIjvvIhGYWxzZSBQb3NpdGl2Ze+8iVxuIOS4jeS8muaKiuWxnuS6jui/meS4qumbhuWQiOeahOWFg+e0oOivr+iupOS4uuS4jeWxnuS6jui/meS4qumbhuWQiO+8iEZhbHNlIE5lZ2F0aXZl77yJ44CCXG5cbiDlk4jluIzlh73mlbDnmoTkuKrmlbBr44CB5L2N5pWw57uE5aSn5bCPbeOAgeWKoOWFpeeahOWtl+espuS4suaVsOmHj27nmoTlhbPns7vjgILlk4jluIzlh73mlbDkuKrmlbBr5Y+WMTDvvIzkvY3mlbDnu4TlpKflsI9t6K6+5Li65a2X56ym5Liy5Liq5pWwbueahDIw5YCN5pe277yMZmFsc2UgcG9zaXRpdmXlj5HnlJ/nmoTmpoLnjofmmK8wLjAwMDA4ODkg77yM5Y2zMTDkuIfmrKHnmoTliKTmlq3kuK3vvIzkvJrlrZjlnKg55qyh6K+v5Yik77yM5a+55LqO5LiA5aSpMeS6v+asoeeahOafpeivou+8jOivr+WIpOeahOasoeaVsOS4ujkwMDDmrKHjgIJcblxuIEJsb29tZmlsdGVyIOeahOW6lOeUqOWcuuaZr1xuIDEu6buR5ZCN5Y2VXG4g5pyA5YW45Z6L55qE5LiA5Liq5bqU55So5bCx5piv6buR5ZCN5Y2V5Yqf6IO977yM5a+555So5oi35ZCN56ew5oiW6ICFSVDmiJbogIVFbWFpbOi/m+ihjOi/h+a7pO+8jOavj+asoeajgOafpeaXtueUqGtleei/m+ihjGhhc2jlkI7vvIzlpoLmnpzkuI3lnKjpu5HlkI3ljZXlhoXnmoTvvIzogq/lrprlj6/ku6XpgJrooYzvvIzlpoLmnpzlnKjnmoTliJnkuI3lhYHorrjpgJrov4fvvIzor6/liKTmg4XlhrXlop7liqDkuIDkuKrmjpLpmaTlkI3ljZXmnaXov5vooYzmjpLpmaTjgIJcbiDor6/liKTmg4XlhrXvvJrlsIbmraPluLjnlKjmiLfliKTlrprkuLrpu5HlkI3ljZXnlKjmiLdcblxuIDIu54is6Jmr6YeN5aSNVVJM5qOA5rWLXG4g5Zyo54is5Y+W572R56uZVVJM5pe277yM6KaB5qOA5rWL6L+Z5p2hVVJM5piv5ZCm5bey57uP6K6/6Zeu6L+H44CCXG4g6K+v5Yik5oOF5Ya177ya5rKh5pyJ6K6/6Zeu6L+H55qE6K+v5Yik5Li66K6/6Zeu6L+HXG5cbiAzLuWtl+WFuOe6oOmUmVxuIOajgOafpeWNleivjeaLvOWGmeaYr+WQpuato+ehrlxuIOivr+WIpOaDheWGte+8mumUmeivr+eahOWNleivjeivr+WIpOS4uuato+ehruOAglxuXG4gNC7no4Hnm5jmlofku7bmo4DmtYtcbiDlsIbno4Hnm5jkuK3miJbogIXmlbDmja7lupPkuK3mlbDmja5rZXnlrZjlhaXor6Xnu5PmnoTkuK3vvIzmo4DmtYvopoHorr/pl67nmoTmlbDmja7mmK/lkKblnKjno4Hnm5jmiJbmlbDmja7lupPkuK3vvIznhLblkI7lho3lj5Hotbforr/pl67vvIzpgb/lhY3nqbrmn6Xor6LpgKDmiJDno4Hnm5jmiJbmlbDmja7lupPljovlipvjgIJcbiDor6/liKTmg4XlhrXvvJrkuI3lrZjlnKjor6XmlbDmja7ljbTor6/liKTkuLrmnInor6XmlbDmja7jgIJcblxuIDUuQ0RO77yIc3F1aWTvvInku6PnkIbnvJPlrZjmioDmnK9cbiDlhYjmn6Xmib7mnKzlnLDmnInml6BjYWNoZe+8jOWmguaenOayoeacieWImeWIsOWFtuS7luWFhOW8nyBjYWNoZeacjeWKoeWZqOS4iuWOu+afpeaJvuOAguS4uuS6humBv+WFjeaXoOiwk+eahOafpeivou+8jOWcqOavj+S4qmNhY2hl5pyN5Yqh5Zmo5LiK5L+d5a2Y5YW25YWE5byf5pyN5Yqh5Zmo55qE57yT5a2Y5YWz6ZSu5a2X77yM5LulYmxvb21maWx0ZXLmlrnlvI/lrZjlgqjvvIzlho3ljrvlhbbku5ZjYWNoZeacjeWKoeWZqOafpeaJvuS5i+WJje+8jOWFiOajgOafpeivpee7k+aehOaYr+WQpuaciXVybO+8jOWmguaenOacieWtmOWcqHVybO+8jOWGjeWOu+WvueW6lOacjeWKoeWZqOafpeaJvuOAglxuIOivr+WIpOaDheWGte+8miDlr7nlupTmnI3liqHlmajkuI3lrZjlnKjor6VVUkznmoTnvJPlrZjjgIJcblxuIFRoYW5rcyB0bzpcbiBodHRwOi8vYWxsZW5raW02Ny5naXRodWIuaW8vMjAxNi8wNS8xNy9ub2RlanMtYnVmZmVyLXR1dG9yaWFsLmh0bWxcbiBodHRwczovL2dpdGh1Yi5jb20vY2VlamJvdC94eC1ibG9vbVxuIGh0dHBzOi8vZ2l0aHViLmNvbS9waWVycmVjL2pzLXh4aGFzaFxuICovXG5cbmltcG9ydCB7IGgzMiBhcyB4eGhhc2ggfSBmcm9tICd4eGhhc2hqcyc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9ICBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCBMTjJfU1FVQVJFRCA9IE1hdGguTE4yICogTWF0aC5MTjI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpbml0KG9wdGlvbnMpe1xuICAgICAgICBpZihvcHRpb25zLnNlZWRzKXtcbiAgICAgICAgICAgIHRoaXMuc2VlZHMgPSBvcHRpb25zLnNlZWRzO1xuICAgICAgICAgICAgdGhpcy5oYXNoZXMgPSBvcHRpb25zLnNlZWRzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VlZHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0aW9ucy5oYXNoZXMgfHwgMDtcblxuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVTZWVkcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iaXRzID0gb3B0aW9ucy5iaXRzIHx8IDEwMjQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKE1hdGguY2VpbCh0aGlzLmJpdHMgLyA4KSk7XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHN0YXRpYyBvcHRpbWl6ZShpdGVtQ291bnQsIGVycm9yUmF0ZSA9IDAuMDA1KXtcbiAgICAgICAgbGV0IGJpdHMgPSBNYXRoLnJvdW5kKC0xICogaXRlbUNvdW50ICogTWF0aC5sb2coZXJyb3JSYXRlKSAvIExOMl9TUVVBUkVEKTtcbiAgICAgICAgbGV0IGhhc2hlcyA9IE1hdGgucm91bmQoKGJpdHMgLyBpdGVtQ291bnQpICogTWF0aC5MTjIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaXRzLFxuICAgICAgICAgICAgaGFzaGVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU9wdGltYWwoaXRlbUNvdW50LCBlcnJvclJhdGUpe1xuICAgICAgICBsZXQgb3B0cyA9IHRoaXMub3B0aW1pemUoaXRlbUNvdW50LCBlcnJvclJhdGUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRzKTtcbiAgICB9XG5cbiAgICBjbGVhcigpe1xuICAgICAgICAvLyAgYnVmLmZpbGwoMCkgdG8gaW5pdGlhbGl6ZSBhIEJ1ZmZlciB0byB6ZXJvZXNcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVTZWVkcygpe1xuICAgICAgICBpZighdGhpcy5zZWVkcykgdGhpcy5zZWVkcyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hlczsgKytpKXtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgcHNldWRvLXJhbmRvbSBkYXRhLiBHZW5lcmF0ZSA0IGJ5dGVzLlxuICAgICAgICAgICAgbGV0IGJ1ZiA9IHJhbmRvbUJ5dGVzKDQpO1xuICAgICAgICAgICAgLy8gUmVhZHMgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGUgQnVmZmVyIGZyb20gaW5kZXggMFxuICAgICAgICAgICAgdGhpcy5zZWVkc1tpXSA9IGJ1Zi5yZWFkVUludDMyTEUoMCk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBlbmQgdXAgd2l0aCB0d28gaWRlbnRpY2FsIHNlZWRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgdW5saWtlbHkgYnV0IHBvc3NpYmxlLlxuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGk7ICsrail7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zZWVkc1tpXSA9PT0gdGhpcy5zZWVkc1tqXSl7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkKGJ1Zikge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGJ1Zikpe1xuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGJ1Zil7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoZXM7ICsraSl7XG4gICAgICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goYnVmLCB0aGlzLnNlZWRzW2ldKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEJpdChiaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzKGl0ZW0pe1xuICAgICAgICBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuaGFzaGVzOyArK2kpe1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goaXRlbSwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuXG4gICAgICAgICAgICBsZXQgaXNJblNldCA9IHRoaXMuX2dldEJpdChiaXQpO1xuICAgICAgICAgICAgaWYoIWlzSW5TZXQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9zZXRCaXQoYml0KXtcbiAgICAgICAgbGV0IHBvcyA9IE1hdGguZmxvb3IoYml0IC8gOCk7XG4gICAgICAgIGxldCBzaGlmdCA9IGJpdCAlIDg7XG5cbiAgICAgICAgbGV0IGJpdEZpZWxkID0gdGhpcy5idWZmZXJbcG9zXTtcbiAgICAgICAgYml0RmllbGQgfD0gKDB4MSA8PCBzaGlmdCk7XG4gICAgICAgIHRoaXMuYnVmZmVyW3Bvc10gPSBiaXRGaWVsZDtcbiAgICB9XG5cbiAgICBfZ2V0Qml0KGJpdCl7XG4gICAgICAgIGxldCBwb3MgPSBNYXRoLmZsb29yKGJpdCAvIDgpO1xuICAgICAgICBsZXQgc2hpZnQgPSBiaXQgJSA4O1xuXG4gICAgICAgIGxldCBiaXRGaWVsZCA9IHRoaXMuYnVmZmVyW3Bvc107XG5cbiAgICAgICAgcmV0dXJuIChiaXRGaWVsZCAmICgweDEgPDwgc2hpZnQpKSAhPT0gMDtcbiAgICB9XG59XG5cbnZhciBmaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoeyBoYXNoZXM6IDgsIGJpdHM6IDEwMjQgfSk7XG5maWx0ZXIuYWRkKFsnY2F0JywgJ2RvZycsICdjb2F0aScsICdyZWQgcGFuZGEnXSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjb2F0JykpO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnbnVsbCcpKTtcblxuXG5jbGFzcyBDb3VudGluZ0Jsb29tRmlsdGVyIGV4dGVuZHMgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgIH1cblxuICAgIGluaXQob3B0cyl7XG4gICAgICAgIGlmIChvcHRzLnNlZWRzKSB7XG4gICAgICAgICAgICB0aGlzLnNlZWRzID0gb3B0cy5zZWVkcztcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0cy5zZWVkcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hlcyA9IG9wdHMuaGFzaGVzIHx8IDg7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVNlZWRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpdHMgPSBvcHRzLmJpdHMgfHwgMTAyNDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5iaXRzKTtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU9wdGltYWwoaXRlbUNvdW50LCBlcnJvclJhdGUpe1xuICAgICAgICBsZXQgb3B0cyA9IEJsb29tRmlsdGVyLm9wdGltaXplKGl0ZW1Db3VudCwgZXJyb3JSYXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdHMpO1xuICAgIH1cblxuICAgIGNsZWFyKCl7XG4gICAgICAgIHN1cGVyLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5vdmVyZmxvdyA9IDA7XG4gICAgfVxuXG4gICAgX3NldEJpdChiaXQpe1xuICAgICAgICAvLyBuby1vcCBhdCBvdmVyZmxvd1xuICAgICAgICBpZih0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUpe1xuICAgICAgICAgICAgKyt0aGlzLm92ZXJmbG93O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgKyt0aGlzLmJ1ZmZlcltiaXRdO1xuICAgIH1cblxuICAgIF91blNldEJpdChiaXQpe1xuICAgICAgICBpZih0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUgfHwgdGhpcy5idWZmZXJbYml0XSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAtLXRoaXMuYnVmZmVyW2JpdF07XG4gICAgfVxuXG4gICAgX2dldEJpdChiaXQpe1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbYml0XSAhPT0gMDtcbiAgICB9XG5cbiAgICBnZXQgaGFzT3ZlcmZsb3dlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVyZmxvdyA+IDA7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW0pe1xuICAgICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc2VlZHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goaXRlbSwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuXG4gICAgICAgICAgICB0aGlzLl91blNldEJpdChiaXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc29sZS5sb2coJ0NvdW50aW5nQmxvb21GaWx0ZXInKVxudmFyIGZpbHRlciA9IG5ldyBDb3VudGluZ0Jsb29tRmlsdGVyKHsgaGFzaGVzOiA4LCBiaXRzOiAxMDI0IH0pO1xuZmlsdGVyLmFkZChbJ2NhdCcsICdkb2cnLCAnY29hdGknLCAncmVkIHBhbmRhJ10pO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnY2F0JykpO1xuZmlsdGVyLnJlbW92ZSgnY2F0Jyk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjb2F0JykpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQmxvb21GaWx0ZXIuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzEvMTEuXG4gKi9cblxuLypcblxuIOWmguaenOS4gOS4quWFs+mUruWtl+WPr+S7peihqOekuuaIkOWtl+espueahOW6j+WPt++8jOWNs+Wtl+espuS4su+8jOmCo+S5iOWPr+S7peeUqOmUruagke+8iGtleXdvcmQgdHJlZe+8ie+8jOWPiOensOaVsOWtl+aQnOe0ouagke+8iGRpZ2l0YWwgc2VhcmNoIHRyZWXvvInmiJblrZfnrKbmoJHvvIzkuZ/lj6vlrZflhbjmoJHvvIzmnaXooajnpLrov5nmoLfnmoTlrZfnrKbkuLLnmoTpm4blkIjjgIJcblxuIOamguW/tVxuXG4g5aaC5p6c5LiA5Liq5YWz6ZSu5a2X5Y+v5Lul6KGo56S65oiQ5a2X56ym55qE5bqP5Y+377yM5Y2z5a2X56ym5Liy77yM6YKj5LmI5Y+v5Lul55So6ZSu5qCR77yIa2V5d29yZCB0cmVl77yJ77yM5Y+I56ew5pWw5a2X5pCc57Si5qCR77yIZGlnaXRhbCBzZWFyY2ggdHJlZe+8ieaIluWtl+espuagke+8jOadpeihqOekuui/meagt+eahOWtl+espuS4sueahOmbhuWQiOOAgumUruagkeWPiOensOS4uuaVsOWtl+afpeaJvuagke+8iERpZ2l0YWwgU2VhcmNoIFRyZWUp5oiWVHJpZeagkSh0cmll5Li6cmV0cmlldmXkuK3pl7Q05Liq5a2X56ymKe+8jOWFtue7k+aehOWPl+WQr+WPkeS6juS4gOmDqOWkp+Wei+Wtl+WFuOeahOKAnOS5pui+ueagh+ebruKAneOAguWtl+WFuOS4reagh+WHuummluWtl+avjeaYryBBLEIsQywuLi4uWueahOWNleivjeaJgOWcqOmhtSzlho3lr7nlkITpg6jliIbmoIflh7rnrKzkuozlrZfmr43kuLpBLEIsQywuLi5a55qE5Y2V6K+N5omA5Zyo55qE6aG1LCAuLi4u562J562J44CCXG5cbiDplK7moJHmmK/kuIDnp43nibnmrornmoTmn6Xmib7moJHvvIzlroPnmoTmn5DkuKroioLngrnkuI3mmK/ljIXlkKvkuIDkuKrmiJblpJrkuKrlhbPplK7lrZfvvIzogIzmmK/lj6rljIXlkKvnu4TmiJDlhbPplK7lrZfnmoTkuIDpg6jliIbvvIjlrZfnrKbmiJbmlbDlrZfvvInvvIzmr5TlpoLvvJrlpoLmnpzlhbPplK7lrZfmmK/mlbDlgLzvvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrmlbDkvY3vvJvlpoLmnpzlhbPplK7lrZfmmK/ljZXor43vvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrlrZfmr43lrZfnrKbjgIJcblxuIOaguee7k+eCueS4jeS7o+ihqOS7u+S9leWtl+espu+8jOagueS7peS4i+esrOS4gOWxgueahOe7k+eCueWvueW6lOS6juWtl+espuS4sueahOesrOS4gOS4quWtl+espu+8jOesrOS6jOWxgueahOe7k+eCueWvueW6lOS6juWtl+espuS4sueahOesrOS6jOS4quWtl+espuKApuKApuavj+S4quWtl+espuS4suWPr+eUseS4gOS4queJueauiueahOWtl+espuWmguKAnCTigJ3nrYnkvZzkuLrlrZfnrKbkuLLnmoTnu5PmnZ/nrKbvvIznlKjkuIDkuKrlj7blrZDnu5PngrnmnaXooajnpLror6XnibnmrorlrZfnrKbjgILmiorku47moLnliLDlj7blrZDnmoTot6/lvoTkuIrvvIzmiYDmnInnu5PngrnvvIjpmaTmoLnku6XlpJbvvInlr7nlupTnmoTlrZfnrKbov57mjqXotbfmnaXvvIzlsLHlvpfliLDkuIDkuKrlrZfnrKbkuLLjgILlm6DmraTvvIzmr4/kuKrlj7blrZDnu5Pngrnlr7nlupTkuIDkuKrlhbPplK7lrZfjgILlnKjlj7blrZDnu5Pngrnov5jlj6/ku6XljIXlkKvkuIDkuKrmjIfpkojvvIzmjIflkJHor6XlhbPplK7lrZfmiYDlr7nlupTnmoTlhYPntKDjgILmlbTkuKrlrZfnrKbkuLLpm4blkIjkuK3nmoTlrZfnrKbkuLLnmoTmlbDnm67nrYnkuo7lj7blrZDnu5PngrnnmoTmlbDnm67jgILlpoLmnpzkuIDkuKrpm4blkIjkuK3nmoTlhbPplK7lrZfpg73lhbfmnInov5nmoLfnmoTlrZfnrKbkuLLnibnmgKfvvIzpgqPkuYjvvIzor6XlhbPplK7lrZfpm4blkIjlsLHlj6/ph4fnlKjov5nmoLfkuIDmo7XplK7moJHmnaXooajnpLrjgILkuovlrp7kuIrvvIzov5jlj6/ku6XotYvkuojigJzlrZfnrKbkuLLigJ3mm7Tlub/ms5vnmoTlkKvkuYnvvIzlroPlj6/ku6XmmK/ku7vkvZXnsbvlnovnmoTlr7nosaHnu4TmiJDnmoTkuLLjgIJcblxuXG4g6ZSu5qCR55qE5a2Y5YKoXG4gMe+8ieWPjOmTvuagkeihqOekulxuIDIpIOWkmumHjemTvuihqOihqOekulxuXG5cbiDplK7moJHnmoTlupTnlKjlnLrmma9cblxuIFRyaWXmmK/kuIDnp43pnZ7luLjnroDljZXpq5jmlYjnmoTmlbDmja7nu5PmnoTvvIzkvYbmnInlpKfph4/nmoTlupTnlKjlrp7kvovjgIJcbiDvvIgx77yJIOWtl+espuS4suajgOe0olxuIOS6i+WFiOWwhuW3suefpeeahOS4gOS6m+Wtl+espuS4su+8iOWtl+WFuO+8ieeahOacieWFs+S/oeaBr+S/neWtmOWIsHRyaWXmoJHph4zvvIzmn6Xmib7lj6blpJbkuIDkupvmnKrnn6XlrZfnrKbkuLLmmK/lkKblh7rnjrDov4fmiJbogIXlh7rnjrDpopHnjofjgIJcbiDkuL7kvovvvJpcbiBAICDnu5nlh7pOIOS4quWNleivjee7hOaIkOeahOeGn+ivjeihqO+8jOS7peWPiuS4gOevh+WFqOeUqOWwj+WGmeiLseaWh+S5puWGmeeahOaWh+eroO+8jOivt+S9oOaMieacgOaXqeWHuueOsOeahOmhuuW6j+WGmeWHuuaJgOacieS4jeWcqOeGn+ivjeihqOS4reeahOeUn+ivjeOAglxuIEAgIOe7meWHuuS4gOS4quivjeWFuO+8jOWFtuS4reeahOWNleivjeS4uuS4jeiJr+WNleivjeOAguWNleivjeWdh+S4uuWwj+WGmeWtl+avjeOAguWGjee7meWHuuS4gOauteaWh+acrO+8jOaWh+acrOeahOavj+S4gOihjOS5n+eUseWwj+WGmeWtl+avjeaehOaIkOOAguWIpOaWreaWh+acrOS4reaYr+WQpuWQq+acieS7u+S9leS4jeiJr+WNleivjeOAguS+i+Wmgu+8jOiLpXJvYuaYr+S4jeiJr+WNleivje+8jOmCo+S5iOaWh+acrHByb2JsZW3lkKvmnInkuI3oia/ljZXor43jgIJcblxuIO+8iDLvvInlrZfnrKbkuLLmnIDplb/lhazlhbHliY3nvIBcbiBUcmll5qCR5Yip55So5aSa5Liq5a2X56ym5Liy55qE5YWs5YWx5YmN57yA5p2l6IqC55yB5a2Y5YKo56m66Ze077yM5Y+N5LmL77yM5b2T5oiR5Lus5oqK5aSn6YeP5a2X56ym5Liy5a2Y5YKo5Yiw5LiA5qO1dHJpZeagkeS4iuaXtu+8jOaIkeS7rOWPr+S7peW/q+mAn+W+l+WIsOafkOS6m+Wtl+espuS4sueahOWFrOWFseWJjee8gOOAglxuIOS4vuS+i++8mlxuIEAg57uZ5Ye6TiDkuKrlsI/lhpnoi7HmloflrZfmr43kuLLvvIzku6Xlj4pRIOS4quivoumXru+8jOWNs+ivoumXruafkOS4pOS4quS4sueahOacgOmVv+WFrOWFseWJjee8gOeahOmVv+W6puaYr+WkmuWwke+8n1xuIOino+WGs+aWueahiO+8mummluWFiOWvueaJgOacieeahOS4suW7uueri+WFtuWvueW6lOeahOWtl+avjeagkeOAguatpOaXtuWPkeeOsO+8jOWvueS6juS4pOS4quS4sueahOacgOmVv+WFrOWFseWJjee8gOeahOmVv+W6puWNs+Wug+S7rOaJgOWcqOe7k+eCueeahOWFrOWFseelluWFiOS4quaVsO+8jOS6juaYr++8jOmXrumimOWwsei9rOWMluS4uuS6huemu+e6v++8iE9mZmxpbmXvvInnmoTmnIDov5HlhazlhbHnpZblhYjvvIhMZWFzdCBDb21tb24gQW5jZXN0b3LvvIznroDnp7BMQ0HvvInpl67popjjgIJcbiDogIzmnIDov5HlhazlhbHnpZblhYjpl67popjlkIzmoLfmmK/kuIDkuKrnu4/lhbjpl67popjvvIzlj6/ku6XnlKjkuIvpnaLlh6Dnp43mlrnms5XvvJpcbiAxLiDliKnnlKjlubbmn6Xpm4bvvIhEaXNqb2ludCBTZXTvvInvvIzlj6/ku6Xph4fnlKjph4fnlKjnu4/lhbjnmoRUYXJqYW4g566X5rOV77ybXG4gMi4g5rGC5Ye65a2X5q+N5qCR55qE5qyn5ouJ5bqP5YiX77yIRXVsZXIgU2VxdWVuY2Ug77yJ5ZCO77yM5bCx5Y+v5Lul6L2s5Li657uP5YW455qE5pyA5bCP5YC85p+l6K+i77yIUmFuZ2UgTWluaW11bSBRdWVyee+8jOeugOensFJNUe+8iemXrumimOS6hu+8m1xuIO+8iOWFs+S6juW5tuafpembhu+8jFRhcmphbueul+azle+8jFJNUemXrumimO+8jOe9keS4iuacieW+iOWkmui1hOaWmeOAgu+8iVxuXG4g77yIM++8ieaOkuW6j1xuIFRyaWXmoJHmmK/kuIDmo7XlpJrlj4nmoJHvvIzlj6ropoHlhYjluo/pgY3ljobmlbTmo7XmoJHvvIzovpPlh7rnm7jlupTnmoTlrZfnrKbkuLLkvr/mmK/mjInlrZflhbjluo/mjpLluo/nmoTnu5PmnpzjgIJcbiDkuL7kvovvvJpcbiBAIOe7meS9oE4g5Liq5LqS5LiN55u45ZCM55qE5LuF55Sx5LiA5Liq5Y2V6K+N5p6E5oiQ55qE6Iux5paH5ZCN77yM6K6p5L2g5bCG5a6D5Lus5oyJ5a2X5YW45bqP5LuO5bCP5Yiw5aSn5o6S5bqP6L6T5Ye644CCXG5cbiDvvIg077yJIOS9nOS4uuWFtuS7luaVsOaNrue7k+aehOWSjOeul+azleeahOi+heWKqee7k+aehFxuIOWmguWQjue8gOagke+8jEFD6Ieq5Yqo5py6562JXG4gKi9cblxuXG4vKlxuIOWPjOmTvuagkeihqOekulxuXG4g5Lul5qCR55qE5a2p5a2Q5YWE5byf6ZO+6KGo5p2l6KGo56S66ZSu5qCR77yM5YiZ5q+P5Liq5YiG5pSv57uT54K55YyF5ous5LiJ5Liq5Z+f77yaXG4gc3ltYm9s5Z+f77ya5a2Y5YKo5YWz6ZSu5a2X55qE5LiA5Liq5a2X56ym77ybXG4gZmlyc3Tln5/vvJrlrZjlgqjmjIflkJHnrKzkuIDmo7XlrZDmoJHmoLnnmoTmjIfpkojvvJtcbiBuZXh05Z+f77ya5a2Y5YKo5oyH5ZCR5Y+z5YWE5byf55qE5oyH6ZKI44CCXG5cbiDlkIzml7bvvIzlj7blrZDnu5PngrnkuI3lkKtmaXJzdOWfn++8jOWug+eahGluZm9wdHLln5/lrZjlgqjmjIflkJHor6XlhbPplK7lrZforrDlvZXnmoTmjIfpkojjgIJcbiDmraTml7bnmoTplK7moJHlj4jnp7Dlj4zpk77moJHjgIJcbiDlnKjlj4zpk77moJHkuK3mj5LlhaXmiJbliKDpmaTkuIDkuKrlhbPplK7lrZfvvIznm7jlvZPkuo7lnKjmoJHkuK3mn5DkuKrnu5PngrnkuIrmj5LlhaXmiJbliKDpmaTkuIDmo7XlrZDmoJHjgIJcbiDnu5PngrnnmoTnu5PmnoTkuK3lj6/ku6Xorr7nva7kuIDkuKrmnprkuL7lj5jph4/ooajnpLrnu5PngrnnmoTnsbvlnovvvIzlj7blrZDnu5PngrnlkozliIbmlK/nu5PngrnjgIJcbiDlj7blrZDnu5PngrnlkozliIbmlK/nu5Pngrnpg73mnIlzeW1ib2zln5/lkoxuZXh05Z+f44CC5LiN5ZCM55qE5LiA5Liq5Z+f5Y+v5Lul55So6IGU5ZCI6KGo56S677yM5Y+25a2Q57uT54K55YyF5ZCraW5mb3B0cuaMh+WQkeiusOW9le+8jOiAjOWIhuaUr+e7k+eCueaYr2ZpcnN05Z+f5oyH5ZCR5YW256ys5LiA5qO15a2Q5qCR44CCXG5cblxuIOWPjOmTvuagkeeahOafpeaJvlxuXG4g5YGH6K6+57uZ5a6a5YC85Li6Sy5jaCgwLi5udW0tMSksIOWFtuS4rUsuY2hbMF3oh7MgSy5jaFtudW0tMl3ooajnpLrlvoXmn6XlhbPplK7lrZfkuK1udW0tMeS4quWtl+espu+8jCBLLmNoW251bS0xXeS4uue7k+adn+espiTjgIJcbiDku47lj4zpk77moJHnmoTmoLnmjIfpkojlh7rlj5HvvIzpobpmaXJzdOaMh+mSiOaJvuWIsOesrOS4gOajteWtkOagkeeahOaguee7k+eCue+8jOS7pUsuY2hbMF3lkozmraTnu5PngrnnmoRzeW1ib2zln5/mr5TovoPvvIzoi6Xnm7jnrYnvvIzliJnpobpmaXJzdOWfn+WGjeavlOi+g+S4i+S4gOWtl+espu+8jOWQpuWImeayv25leHTln5/pobrluo/mn6Xmib7jgIJcbiDoi6Xnm7Toh7Pnqbrku43mr5TovoPkuI3nrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcblxuIC8vIOebuOWFs+i1hOaWmVxuIGh0dHA6Ly93d3cuY25ibG9ncy5jb20vcm9sbGVuaG9sdC9hcmNoaXZlLzIwMTIvMDQvMjQvMjQ2ODkzMi5odG1sXG4gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzY4OTcwOTdcbiBodHRwOi8vd3d3LnJheWNoYXNlLm5ldC8xNzgzXG4gKi9cblxuY29uc3QgTEVBRiA9ICdsZWFmJztcbmNvbnN0IEJSQU5DSCA9ICdicmFuY2gnO1xuY29uc3QgVEVSTUlOQUwgPSBuZXcgU3RyaW5nKCckJyk7XG5cbmV4cG9ydCBjbGFzcyBEb3VibGVMaW5rZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wgPSAncm9vdCcsIGtpbmQgPSBCUkFOQ0gsIGluZm8gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzeW5vU2VhcmNoIChrZXkpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmZpcnN0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBwICYmIGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwICYmIHAua2luZCA9PT0gTEVBRikgYnJlYWs7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcblxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSlcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgIGVsc2UgcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xuICAgIH1cblxuICAgIHNlYXJjaCAoa2V5KSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgcCAmJiBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcblxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSlcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgIGVsc2UgcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xuICAgIH1cblxuICAgIGluc2VydChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSArPSAnJztcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0ga2V5W2ldO1xuICAgICAgICAgICAgbGV0IHAgPSBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuZmlyc3Q7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKGMsIEJSQU5DSCk7XG5cbiAgICAgICAgICAgIC8vIOWmguaenOayoeacieWtkOe7k+eCueWImeWwhuaWsOe7k+eCueS9nOS4uuWtkOe7k+eCuVxuICAgICAgICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgICAgICAgICBwLmZpcnN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHA7XG4gICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8g5Zyo5YWE5byf57uT54K55Lit5om+5Yiw5a+55bqU57uT54K5XG4gICAgICAgICAgICAgICAgaWYoYyA8IGN1ci5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmZpcnN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYyA+IGN1ci5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOebuOetie+8jOmAgOWHuuivpeW+queOr+afpeaJvuS4i+S4gOWtl+esplxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGN1ci5zeW1ib2wpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5bCP5LqO5b2T5YmN5a2X56ym77yM5YiZ5o+S5YWl5Yiw5b2T5YmN57uT54K55YmN6Z2iXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGMgPCBjdXIuc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInlhYTlvJ/nu5PngrnliJnmj5LlhaXliLDlhYTlvJ/nu5PngrlcbiAgICAgICAgICAgICAgICAgICAgaWYoIWN1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gYi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g55Sf5oiQ5Y+25a2Q57uT54K5XG4gICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGlmIChjdXIua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjdXIuZmlyc3Q7XG5cbiAgICAgICAgICAgIC8vIOWmguaenOS4jeWtmOWcqOWFs+mUruWtl+WImeivtOaYjuaPkuWFpeaIkOWKn++8jOWQpuWImeaPkuWFpeWksei0pVxuICAgICAgICAgICAgaWYoIShjaGlsZCAmJiBjaGlsZC5zeW1ib2wgPT09IFRFUk1JTkFMKSkge1xuICAgICAgICAgICAgICAgIGN1ci5maXJzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKFRFUk1JTkFMLCBMRUFGLCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBrZXkpO1xuICAgICAgICAgICAgICAgIGN1ci5maXJzdC5wYXJlbnQgPSBjdXI7XG4gICAgICAgICAgICAgICAgY3VyLmZpcnN0Lm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH1cblxuICAgIHJlbW92ZSAoa2V5KSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcbiAgICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwICYmIGkgPCBrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcblxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSkge1xuICAgICAgICAgICAgICAgIHAgPSBwLmZpcnN0O1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YSA9IHAuaW5mbztcbiAgICAgICAgd2hpbGUgKCFwLm5leHQgJiYgcC5wYXJlbnQpIHAgPSBwLnBhcmVudDtcbiAgICAgICAgbGV0IHRvcCA9IHA7XG5cbiAgICAgICAgaWYgKHRvcCA9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PSB0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6Zmk5ZyoZmlyc3Tln5/kuIrnmoTlrZDmoJHnu5PngrlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRvcC5wYXJlbnQuZmlyc3QgPSB0b3AucGFyZW50LmZpcnN0Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIoOmZpOWcqG5leHTln5/nmoTlhYTlvJ/nu5PngrlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBwcmUubmV4dCA9IHByZS5uZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgdGVzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKCk7XG50ZXN0Lmluc2VydCgnQ0FJJyk7XG50ZXN0Lmluc2VydCgnTEFOJyk7XG50ZXN0Lmluc2VydCgnQ0FPJyk7XG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcbnRlc3QuaW5zZXJ0KCdDSEFPJyk7XG50ZXN0Lmluc2VydCgnQ0hFTicpO1xudGVzdC5pbnNlcnQoJ0xJJyk7XG50ZXN0Lmluc2VydCgnTElVJyk7XG50ZXN0Lmluc2VydCgnWkhBTycpO1xudGVzdC5pbnNlcnQoJ1pIQU8nKTtcblxuY29uc29sZS5sb2coJ1xcbnNlYXJjaDogJyk7XG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0FJJykpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdDSEFORycpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPeCcpKTtcblxuY29uc29sZS5sb2coJ1xcbnJlbW92ZTonKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQUknKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0FJJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0xBTicpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQU8nKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hBJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU5HJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU8nKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hFTicpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSScpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSVUnKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnWkhBTycpKTtcblxuXG4vKlxuIOWkmumHjemTvuihqOihqOekulxuXG4g6Iul5Lul5qCR55qE5aSa6YeN6ZO+6KGo6KGo56S66ZSu5qCR77yM5YiZ5qCR55qE5q+P5Liq57uT54K55Lit5bqU5ZCr5pyJZOS4quaMh+mSiOWfn++8jOatpOaXtueahOmUruagkeWPiOensFRyaWXmoJHjgIJcbiDvvIhUcmll5piv5LuO5qOA57SicmV0cmlldmXkuK3lj5bkuK3pl7Tlm5vkuKrlrZfnrKbnmoTvvIzor7vpn7PlkIx0cnnvvInjgIJcbiDoi6Xku47plK7moJHkuK3mn5DkuKrnu5PngrnliLDlj7blrZDnu5PngrnnmoTot6/lvoTkuIrmr4/kuKrnu5Pngrnpg73lj6rmnInkuIDkuKrlranlrZDvvIzliJnlj6/lsIbor6Xot6/lvoTkuIrmiYDmnInnu5PngrnljovnvKnmiJDkuIDkuKrigJzlj7blrZDnu5PngrnigJ3vvIzkuJTlnKjor6Xlj7blrZDnu5PngrnkuK3lrZjlgqjlhbPplK7lrZflj4rmjIflkJHorrDlvZXnmoTmjIfpkojnrYnkv6Hmga/jgIJcbiDlnKhUcmll5qCR5Lit5pyJ5Lik56eN57uT54K577yaXG4g5YiG5pSv57uT54K577ya5ZCr5pyJZOS4quaMh+mSiOWfn+WSjOS4gOS4quaMh+ekuuivpee7k+eCueS4remdnuepuuaMh+mSiOWfn+eahOS4quaVsOeahOaVtOaVsOWfn+OAguWcqOWIhuaUr+e7k+eCueS4reS4jeiuvuaVsOaNruWfn++8jOavj+S4quWIhuaUr+e7k+eCueaJgOihqOekuueahOWtl+espuWdh+acieWFtueItue7k+eCueS4reaMh+WQkeivpee7k+eCueeahOaMh+mSiOaJgOWcqOS9jee9ruWGs+WumuOAglxuIOWPtuWtkOe7k+eCue+8muWQq+acieWFs+mUruWtl+Wfn+WSjOaMh+WQkeiusOW9leeahOaMh+mSiOWfn+OAglxuXG5cbiDlnKhUcmll5qCR5LiK6L+b6KGM5p+l5om+XG5cbiDku47moLnnu5Pngrnlh7rlj5HvvIzmsr/lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojpgJDlsYLlkJHkuIvvvIznm7Toh7Plj7blrZDnu5PngrnvvIzoi6Xlj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLznm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvIzoi6XliIbmlK/nu5PngrnkuK3lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojkuLrnqbrvvIzmiJblj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLzkuI3nm7jnrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcblxuXG4g5LyY5YyWVHJpZeagkeeahOa3seW6plxuXG4g5oiR5Lus5Y+v5a+55YWz6ZSu5a2X6ZuG6YCJ5oup5LiA56eN5ZCI6YCC55qE5YiG5Ymy44CC5YWI5oyJ6aaW5a2X56ym5LiN6YCa5YiG5oiQ5aSa5Liq5a2Q6ZuG5LmL5ZCO77yM54S25ZCO5oyJ5pyA5ZCO5LiA5Liq5a2X56ym5LiN5ZCM5YiG5Ymy5q+P5Liq5a2Q6ZuG77yM5YaN5oyJ56ys5LqM5Liq5a2X56ym44CC44CC44CC5YmN5ZCO5Lqk5Y+J5YiG5Ymy44CC5LiA57yp5YePVHJpZeagkeeahOa3seW6plxuICovXG4vLyDmsYLlrZfnrKblnKjlrZfmr43ooajkuK3nmoTluo/lj7dcbmZ1bmN0aW9uIG9yZGVyKGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9Mb3dlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gJ2EnLmNoYXJDb2RlQXQoMCkgKyAxIDogMDtcbn1cblxuLy8g6YCa6L+H5Zue5rqv5rOV5riF55CGVHJpZeagkeeahOWHveaVsFxuZnVuY3Rpb24gcmVtb3ZlTm9kZSh0cmllTm9kZSwgb3JkZXIsIGNsZWFyKSB7XG4gICAgdHJpZU5vZGUuYnJhbmNoLm5vZGVzW29yZGVyXSA9IG51bGw7XG4gICAgLS10cmllTm9kZS5icmFuY2gubnVtO1xuXG4gICAgaWYgKCFjbGVhcikgcmV0dXJuO1xuXG4gICAgbGV0IG5vZGVzID0gdHJpZU5vZGUuYnJhbmNoLm5vZGVzO1xuICAgIGxldCBwYXJlbnQgPSB0cmllTm9kZS5wYXJlbnQ7XG4gICAgbGV0IHByZSA9IHRyaWVOb2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpIGluIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgbm9kZXNbaV0pIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgbGV0IHBhcmVudE5vZGVzID0gcGFyZW50LmJyYW5jaC5ub2RlcztcbiAgICAgICAgZm9yIChsZXQgaSBpbiBwYXJlbnROb2Rlcykge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVzLmhhc093blByb3BlcnR5KGkpICYmIHBhcmVudE5vZGVzW2ldICYmIHBhcmVudE5vZGVzW2ldID09IHByZSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmJyYW5jaC5ub2Rlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAtLXBhcmVudC5icmFuY2gubnVtO1xuXG4gICAgICAgIHByZSA9IHBhcmVudDtcbiAgICAgICAgbm9kZXMgPSBwYXJlbnQuYnJhbmNoLm5vZGVzO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyaWVUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kID0gQlJBTkNIKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoa2luZCA9PT0gTEVBRikge1xuICAgICAgICAgICAgdGhpcy5sZWFmID0ge1xuICAgICAgICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICAgICAgICBpbmZvOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5icmFuY2ggPSB7XG4gICAgICAgICAgICAgICAgLy8g4oCcJOKAneS4uuesrOS4gOS4quWtl+espu+8jOWQjue7reS4ujI25Liq5a2X5q+NXG4gICAgICAgICAgICAgICAgbm9kZXM6IG5ldyBBcnJheSgyNyksXG4gICAgICAgICAgICAgICAgbnVtOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VhcmNoIChrZXkpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLCBpID0gMDtcbiAgICAgICAgZm9yICg7XG4gICAgICAgICAgICAgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aDtcbiAgICAgICAgICAgICBwID0gcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0sICsraSk7XG5cbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmIChwLmtpbmQgPT09IExFQUYgJiYgcC5sZWFmLmtleSA9PT0ga2V5KSByZXR1cm4gcC5sZWFmLmluZm87XG4gICAgICAgICAgICAvLyDlkIzkuYnor41cbiAgICAgICAgICAgIGVsc2UgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkgcmV0dXJuIHAubGVhZi5pbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaW5zZXJ0IChrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIOW7uuWPtuWtkOe7k+eCuVxuICAgICAgICBsZXQgcSA9IG5ldyBUcmllVHJlZShMRUFGKTtcbiAgICAgICAgcS5sZWFmLmtleSA9IGtleTtcbiAgICAgICAgcS5sZWFmLmluZm8gPSB2YWx1ZTtcblxuICAgICAgICAvLyDoh6rkuIrogIzkuIvmn6Xmib5cbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XG4gICAgICAgIGZvciAoO1xuICAgICAgICAgICAgIHAgJiYgcC5raW5kID09PSBCUkFOQ0ggJiYgaSA8IGtleS5sZW5ndGggJiYgcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV07XG4gICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpIGxhc3QgPSBwO1xuXG4gICAgICAgIC8vIOWmguaenOacgOWQjuiQveWIsOWIhuaUr+e7k+eCue+8iOaXoOWQjOS5ieivje+8iVxuICAgICAgICAvLyDnm7TmjqXov57kuIrlj7blrZBcbiAgICAgICAgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSA9IHE7XG4gICAgICAgICAgICBxLnBhcmVudCA9IHA7XG4gICAgICAgICAgICArK3AuYnJhbmNoLm51bTtcbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzmnIDlkI7okL3liLDlj7blrZDnu5PngrnvvIjmnInlkIzkuYnor43vvIlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocC5sZWFmLmtleSA9PT0ga2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIOW7uueri+aWsOeahOWIhuaUr+e7k+eCuVxuICAgICAgICAgICAgbGV0IHIgPSBuZXcgVHJpZVRyZWUoQlJBTkNIKTtcbiAgICAgICAgICAgIC8vIOeUqOaWsOeahOWIhuaUr+e7k+eCueWPluS7o+iAgeWPtuWtkOe7k+eCueWSjOS4iuS4gOWxgueahOiBlOezu1xuICAgICAgICAgICAgbGFzdC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2kgLSAxXSldID0gcjtcbiAgICAgICAgICAgIHIucGFyZW50ID0gbGFzdDtcbiAgICAgICAgICAgIHIuYnJhbmNoLm51bSA9IDI7XG4gICAgICAgICAgICByLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSA9IHE7XG4gICAgICAgICAgICBxLnBhcmVudCA9IHI7XG4gICAgICAgICAgICAvLyDmlrDliIbmlK/nu5PngrnkuI7mlrDogIHkuKTkuKrlj7blrZDnu5Pngrnnm7jov55cbiAgICAgICAgICAgIHIuYnJhbmNoLm5vZGVzW29yZGVyKHAubGVhZi5rZXlbaV0pXSA9IHA7XG4gICAgICAgICAgICBwLnBhcmVudCA9IHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyIOaYr+WQpumcgOimgea4heeQhue7k+eCuVxuICAgICAqIEByZXR1cm5zIHsqfSDlpoLmnpzliKDpmaTmiJDlip/ov5Tlm55pbmZv5pWw5o2u5ZCm5YiZ6L+U5ZueZmFsc2VcbiAgICAgKi9cbiAgICByZW1vdmUgKGtleSwgY2xlYXIpIHtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XG4gICAgICAgIC8vIOafpeaJvuW+heWIoOmZpOWFg+e0oFxuICAgICAgICBmb3IgKDtcbiAgICAgICAgICAgICBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoO1xuICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKSBsYXN0ID0gcDtcblxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjbGVhciA9IHR5cGVvZiBjbGVhciAhPT0gJ3VuZGVmaW5lZCcgPyBjbGVhciA6IHRydWU7XG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcblxuICAgICAgICBpZiAocC5raW5kID09PSBMRUFGICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgZGF0YSA9IHAubGVhZi5pbmZvO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShsYXN0LCBvcmRlcihrZXlbaSAtIDFdKSwgY2xlYXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcbiAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwLmxlYWYuaW5mbztcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKHAucGFyZW50LCAwLCBjbGVhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgdGVzdCA9IG5ldyBUcmllVHJlZSgpO1xuXG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcbnRlc3QuaW5zZXJ0KCdDQUknKTtcbnRlc3QuaW5zZXJ0KCdDSEVOJyk7XG50ZXN0Lmluc2VydCgnQ0FPJyk7XG50ZXN0Lmluc2VydCgnQ0hBTycpO1xudGVzdC5pbnNlcnQoJ0xPTkcnKTtcbnRlc3QuaW5zZXJ0KCdMSScpO1xudGVzdC5pbnNlcnQoJ0xBTicpO1xudGVzdC5pbnNlcnQoJ0xJVScpO1xudGVzdC5pbnNlcnQoJ1dBTkcnKTtcbnRlc3QuaW5zZXJ0KCdXRU4nKTtcbnRlc3QuaW5zZXJ0KCdXVScpO1xudGVzdC5pbnNlcnQoJ1lBTkcnKTtcbnRlc3QuaW5zZXJ0KCdZVU4nKTtcbnRlc3QuaW5zZXJ0KCdaSEFPJyk7XG5cbmNvbnNvbGUubG9nKCdcXG5zZWFyY2g6ICcpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ1lVTicpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPJykpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcblxudGVzdC5yZW1vdmUoJ0xBTicpO1xudGVzdC5yZW1vdmUoJ0xJVScpO1xudGVzdC5yZW1vdmUoJ1dBTkcnKTtcbnRlc3QucmVtb3ZlKCdXRU4nKTtcbnRlc3QucmVtb3ZlKCdXVScpO1xudGVzdC5yZW1vdmUoJ1lBTkcnKTtcbnRlc3QucmVtb3ZlKCdZVU4nKTtcbnRlc3QucmVtb3ZlKCdaSEFPJyk7XG50ZXN0LnJlbW92ZSgnQ0hBJyk7XG50ZXN0LnJlbW92ZSgnQ0hBTkcnKTtcbnRlc3QucmVtb3ZlKCdDQUknKTtcbnRlc3QucmVtb3ZlKCdDSEVOJyk7XG50ZXN0LnJlbW92ZSgnQ0FPJyk7XG50ZXN0LnJlbW92ZSgnQ0hBTycpO1xudGVzdC5yZW1vdmUoJ0xPTkcnKTtcbnRlc3QucmVtb3ZlKCdMSScpO1xuXG50ZXN0Lmluc2VydCgnTEknKTtcbnRlc3QuaW5zZXJ0KCdMQU4nKTtcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUuanMiLCIvKipcbiAqIEhhc2hUYWJsZVxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTQvMTIvMzAuXG4gKi9cblxuLyoqXG7lk4jluIwo5pWj5YiXKeafpeaJvlxuXG7ln7rmnKzmgJ3mg7PvvJrlnKjorrDlvZXnmoTlrZjlgqjlnLDlnYDlkozlroPnmoTlhbPplK7lrZfkuYvpl7Tlu7rnq4vkuIDkuKrnoa7lrprnmoTlr7nlupTlhbPns7vvvJvov5nmoLfvvIzkuI3nu4/ov4fmr5TovoPvvIzkuIDmrKHlrZjlj5blsLHog73lvpfliLDmiYDmn6XlhYPntKDnmoTmn6Xmib7mlrnms5XjgIJcblxu5Z+65pys5qaC5b+1XG5cbuWTiOW4jOWHveaVsO+8muWcqOiusOW9leeahOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+eahOS4gOenjeWvueW6lOWFs+ezu+WPq+WTiOW4jOWHveaVsOOAglxu5ZOI5biM5Ye95pWw5piv5LiA56eN5pig6LGh77yM5piv5LuO5YWz6ZSu5a2X56m66Ze05Yiw5a2Y5YKo5Zyw5Z2A56m66Ze055qE5LiA56eN5pig6LGh44CC5Y+v5YaZ5oiQ77yaYWRkcihhaSk9SChraSkg77yM5YW25LitaeaYr+ihqOS4reS4gOS4quWFg+e0oO+8jGFkZHIoYWkp5pivYWnnmoTlnLDlnYDvvIwga2nmmK9haeeahOWFs+mUruWtl+OAglxuXG7lk4jluIzooajvvJrlupTnlKjlk4jluIzlh73mlbDvvIznlLHorrDlvZXnmoTlhbPplK7lrZfnoa7lrprorrDlvZXlnKjooajkuK3nmoTlnLDlnYDvvIzlubblsIborrDlvZXmlL7lhaXmraTlnLDlnYDvvIzov5nmoLfmnoTmiJDnmoTooajlj6vlk4jluIzooajjgIJcblxu5ZOI5biM5p+l5om+KOWPiOWPq+aVo+WIl+afpeaJvinvvJrliKnnlKjlk4jluIzlh73mlbDov5vooYzmn6Xmib7nmoTov4fnqIvlj6vlk4jluIzmn6Xmib7jgIJcblxu5Yay56qB77ya5a+55LqO5LiN5ZCM55qE5YWz6ZSu5a2Xa2njgIFrau+8jOiLpWtp74K5a2rvvIzkvYZIKGtpKT1IKGtqKeeahOeOsOixoeWPq+WGsueqgShjb2xsaXNpb24pIOOAglxuXG7lkIzkuYnor43vvJrlhbfmnInnm7jlkIzlh73mlbDlgLznmoTkuKTkuKrkuI3lkIznmoTlhbPplK7lrZfvvIznp7DkuLror6Xlk4jluIzlh73mlbDnmoTlkIzkuYnor43jgIJcbuWTiOW4jOWHveaVsOmAmuW4uOaYr+S4gOenjeWOi+e8qeaYoOixoe+8jOaJgOS7peWGsueqgeS4jeWPr+mBv+WFje+8jOWPquiDveWwvemHj+WHj+Wwke+8m+W9k+WGsueqgeWPkeeUn+aXtu+8jOW6lOivpeacieWkhOeQhuWGsueqgeeahOaWueazleOAguiuvuiuoeS4gOS4quaVo+WIl+ihqOW6lOWMheaLrO+8mlxu4pGgICDmlaPliJfooajnmoTnqbrpl7TojIPlm7TvvIzljbPnoa7lrprmlaPliJflh73mlbDnmoTlgLzln5/vvJtcbuKRoSAg5p6E6YCg5ZCI6YCC55qE5pWj5YiX5Ye95pWw77yM5L2/5b6X5a+55LqO5omA5pyJ5Y+v6IO955qE5YWD57SgKOiusOW9leeahOWFs+mUruWtlynvvIzlh73mlbDlgLzlnYflnKjmlaPliJfooajnmoTlnLDlnYDnqbrpl7TojIPlm7TlhoXvvIzkuJTlh7rnjrDlhrLnqoHnmoTlj6/og73lsL3ph4/lsI/vvJtcbuKRoiAg5aSE55CG5Yay56qB55qE5pa55rOV44CC5Y2z5b2T5Yay56qB5Ye6546w5pe25aaC5L2V6Kej5Yaz44CCXG5cblxu5ZOI5biM5Ye95pWw55qE5p6E6YCgXG5cbuWTiOW4jOWHveaVsOaYr+S4gOenjeaYoOixoe+8jOWFtuiuvuWumuW+iOeBtea0u++8jOWPquimgeS9v+S7u+S9leWFs+mUruWtl+eahOWTiOW4jOWHveaVsOWAvOmDveiQveWcqOihqOmVv+WFgeiuuOeahOiMg+WbtOS5i+WGheWNs+WPr+OAguWTiOW4jOWHveaVsOKAnOWlveWdj+KAneeahOS4u+imgeivhOS7t+WboOe0oOacie+8mlxu4peGIOaVo+WIl+WHveaVsOeahOaehOmAoOeugOWNle+8m1xu4peGIOiDveKAnOWdh+WMgOKAneWcsOWwhuaVo+WIl+ihqOS4reeahOWFs+mUruWtl+aYoOWwhOWIsOWcsOWdgOepuumXtOOAguaJgOiwk+KAnOWdh+WMgOKAnSh1bmlmb3JtKeaYr+aMh+WPkeeUn+WGsueqgeeahOWPr+iDveaAp+WwveWPr+iDveacgOWwkeOAglxuXG4xICDnm7TmjqXlrprlnYDms5VcbuWPluWFs+mUruWtl+aIluWFs+mUruWtl+eahOafkOS4que6v+aAp+WHveaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgICAg5oiWICAgSChrZXkpPWHCt2tleStiKGEsYuS4uuW4uOaVsClcbueJueeCue+8muebtOaOpeWumuWdgOazleaJgOW+l+WcsOWdgOmbhuWQiOS4juWFs+mUruWtl+mbhuWQiOWkp+Wwj+ebuOetie+8jOS4jeS8muWPkeeUn+WGsueqge+8jOS9huWunumZheS4reW+iOWwkeS9v+eUqOOAglxuXG4yICDmlbDlrZfliIbmnpDms5VcbuWvueWFs+mUruWtl+i/m+ihjOWIhuaekO+8jOWPluWFs+mUruWtl+eahOiLpeW5suS9jeaIlue7hOWQiOS9nOS4uuWTiOW4jOWcsOWdgOOAglxu6YCC55So5LqO5YWz6ZSu5a2X5L2N5pWw5q+U5ZOI5biM5Zyw5Z2A5L2N5pWw5aSn77yM5LiU5Y+v6IO95Ye6546w55qE5YWz6ZSu5a2X5LqL5YWI55+l6YGT55qE5oOF5Ya144CCXG7kvovvvJog6K6+5pyJODDkuKrorrDlvZXvvIzlhbPplK7lrZfkuLo45L2N5Y2B6L+b5Yi25pWw77yM5ZOI5biM5Zyw5Z2A5Li6MuS9jeWNgei/m+WItuaVsOOAglxu74KBICDvgoIg74KDICDvgoQg74KFICDvgoYg74KHICDvgohcbjggIDEgIDMgIDQgIDYgIDUgIDMgIDJcbjggIDEgIDMgIDcgIDIgIDIgIDQgIDJcbjggIDEgIDMgIDggIDcgIDQgIDIgIDJcbjggIDEgIDMgIDAgIDEgIDMgIDYgIDdcbjggIDEgIDMgIDIgIDIgIDggIDEgIDdcbjggIDEgIDMgIDMgIDggIDkgIDYgIDdcbjggIDEgIDMgIDYgIDggIDUgIDMgIDdcbjggIDEgIDQgIDEgIDkgIDMgIDUgIDVcbuWIhuaekO+8miDvgoEg5Y+q5Y+WOFxuICAgICAg74KCIOWPquWPljFcbiAgICAgIO+CgyDlj6rlj5Yz44CBNFxuICAgICAg74KIIOWPquWPljLjgIE344CBNVxuICAgICAg74KE74KF74KG74KH5pWw5a2X5YiG5biD6L+R5LmO6ZqP5py6XG7miYDku6XvvJrlj5bvgoTvgoXvgobvgofku7vmhI/kuKTkvY3miJbkuKTkvY3kuI7lj6bkuKTkvY3nmoTlj6DliqDkvZzlk4jluIzlnLDlnYBcblxuMyAg5bmz5pa55Y+W5Lit5rOVXG7lsIblhbPplK7lrZflubPmlrnlkI7lj5bkuK3pl7Tlh6DkvY3kvZzkuLrlk4jluIzlnLDlnYDjgIJcbuS4gOS4quaVsOW5s+aWueWQjuS4remXtOWHoOS9jeWSjOaVsOeahOavj+S4gOS9jemDveacieWFs++8jOWImeeUsemaj+acuuWIhuW4g+eahOWFs+mUruWtl+W+l+WIsOeahOaVo+WIl+WcsOWdgOS5n+aYr+maj+acuueahOOAguaVo+WIl+WHveaVsOaJgOWPlueahOS9jeaVsOeUseaVo+WIl+ihqOeahOmVv+W6puWGs+WumuOAgui/meenjeaWueazlemAguS6juS4jeefpemBk+WFqOmDqOWFs+mUruWtl+aDheWGte+8jOaYr+S4gOenjei+g+S4uuW4uOeUqOeahOaWueazleOAglxuXG40ICDmipjlj6Dms5VcbuWwhuWFs+mUruWtl+WIhuWJsuaIkOS9jeaVsOebuOWQjOeahOWHoOmDqOWIhijmnIDlkI7kuIDpg6jliIblj6/ku6XkuI3lkIwp77yM54S25ZCO5Y+W6L+Z5Yeg6YOo5YiG55qE5Y+g5Yqg5ZKM5L2c5Li65ZOI5biM5Zyw5Z2A44CCXG7mlbDkvY3lj6DliqDmnInnp7vkvY3lj6DliqDlkozpl7TnlYzlj6DliqDkuKTnp43jgIJcbuKXhiDnp7vkvY3lj6DliqDvvJrlsIbliIblibLlkI7nmoTlh6Dpg6jliIbkvY7kvY3lr7npvZDnm7jliqDjgIJcbuKXhiDpl7TnlYzlj6DliqDvvJrku47kuIDnq6/liLDlj6bkuIDnq6/msr/liIblibLnlYzmnaXlm57mipjov63vvIznhLblkI7lr7npvZDnm7jliqDjgIJcbumAguS6juWFs+mUruWtl+S9jeaVsOW+iOWkmu+8jOS4lOavj+S4gOS9jeS4iuaVsOWtl+WIhuW4g+Wkp+iHtOWdh+WMgOaDheWGteOAglxu5L6L77yaIOiuvuWFs+mUruWtl+S4ujA0NDIyMDU4NjTvvIzlk4jluIzlnLDlnYDkvY3mlbDkuLo0IOOAguS4pOenjeS4jeWQjOeahOWcsOWdgOiuoeeul+aWueazleWmguS4i++8mlxuICAgIDU4NjQgICAgICAgICAgICAgICAgICAgICAgICA1ODY0XG4gICAgNDIyMCAgICAgICAgICAgICAgICAgICAgICAgIDAyMjRcbiAgICAgIDA0ICAgICAgIOenu+S9jeWPoOWKoCAgICAgICAgICAgIDA0ICAgICAgICAgICDpl7TnlYzlj6DliqBcbiAtLS0tLS0tLS0gICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tXG4gICAxMDA4OCAgICAgICAgICAgICAgICAgICAgICAgIDYwOTFcblxuNSAg6Zmk55WZ5L2Z5pWw5rOVXG7lj5blhbPplK7lrZfooqvmn5DkuKrkuI3lpKfkuo7lk4jluIzooajooajplb9t55qE5pWwcOmZpOWQjuaJgOW+l+S9meaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgTU9EIHAgICAgIChwPD1tKVxu5piv5LiA56eN566A5Y2V44CB5bi455So55qE5ZOI5biM5Ye95pWw5p6E6YCg5pa55rOV44CCXG7liKnnlKjov5nnp43mlrnms5XnmoTlhbPplK7mmK9w55qE6YCJ5Y+W77yMcOmAieeahOS4jeWlve+8jOWuueaYk+S6p+eUn+WQjOS5ieivjeOAgnDnmoTpgInlj5bnmoTliIbmnpDvvJpcbuKXhiAg6YCJ5Y+WcD0yaShwPD1tKe+8mui/kOeul+S+v+S6jueUqOenu+S9jeadpeWunueOsO+8jOS9huetieS6juWwhuWFs+mUruWtl+eahOmrmOS9jeW/veeVpeiAjOS7heeVmeS4i+S9juS9jeS6jOi/m+WItuaVsOOAgumrmOS9jeS4jeWQjOiAjOS9juS9jeebuOWQjOeahOWFs+mUruWtl+aYr+WQjOS5ieivjeOAglxu4peGIOmAieWPlnA9cSpmKHHjgIFm6YO95piv6LSo5Zug5pWw77yMcDw9bSnvvJrliJnmiYDmnInlkKvmnIlx5oiWZuWboOWtkOeahOWFs+mUruWtl+eahOaVo+WIl+WcsOWdgOWdh+aYr3HmiJZm55qE5YCN5pWw44CCXG7il4Yg6YCJ5Y+WcOS4uue0oOaVsOaIlnA9cSpmKHHjgIFm5piv6LSo5pWw5LiU5Z2H5aSn5LqOMjDvvIxwPD1tKe+8muW4uOeUqOeahOmAieWPluaWueazle+8jOiDveWHj+WwkeWGsueqgeWHuueOsOeahOWPr+iDveaAp+OAglxuXG42ICDpmo/mnLrmlbDms5VcbuWPluWFs+mUruWtl+eahOmaj+acuuWHveaVsOWAvOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1yYW5kb20oa2V5KVxu5b2T5pWj5YiX6KGo5Lit5YWz6ZSu5a2X6ZW/5bqm5LiN562J5pe277yM6K+l5pa55rOV5q+U6L6D5ZCI6YCC44CCXG5cblxuXG7pgInlj5blk4jluIzlh73mlbDvvIzogIPomZHku6XkuIvlm6DntKBcbuKXhiDorqHnrpflk4jluIzlh73mlbDmiYDpnIDml7bpl7TvvJtcbuKXhiDlhbPplK7lrZfnmoTplb/luqbvvJtcbuKXhiDlk4jluIzooajplb/luqbvvIjlk4jluIzlnLDlnYDojIPlm7TvvInvvJtcbuKXhiDlhbPplK7lrZfliIbluIPmg4XlhrXvvJtcbuKXhiDorrDlvZXnmoTmn6Xmib7popHnjofjgIJcblxuXG5cbuWGsueqgeWkhOeQhueahOaWueazlVxu5Yay56qB5aSE55CG77ya5b2T5Ye6546w5Yay56qB5pe277yM5Li65Yay56qB5YWD57Sg5om+5Yiw5Y+m5LiA5Liq5a2Y5YKo5L2N572u44CCXG5cbjEgIOW8gOaUvuWumuWdgOazlVxu5Z+65pys5pa55rOV77ya5b2T5Yay56qB5Y+R55Sf5pe277yM5b2i5oiQ5p+Q5Liq5o6i5rWL5bqP5YiX77yb5oyJ5q2k5bqP5YiX6YCQ5Liq5o6i5rWL5pWj5YiX6KGo5Lit55qE5YW25LuW5Zyw5Z2A77yM55u05Yiw5om+5Yiw57uZ5a6a55qE5YWz6ZSu5a2X5oiW5LiA5Liq56m65Zyw5Z2AKOW8gOaUvueahOWcsOWdgCnkuLrmraLvvIzlsIblj5HnlJ/lhrLnqoHnmoTorrDlvZXmlL7liLDor6XlnLDlnYDkuK3jgILmlaPliJflnLDlnYDnmoTorqHnrpflhazlvI/mmK/vvJpcbkhpKGtleSk9KEgoa2V5KStkaSkgIE1PRCBt77yMaT0xLCAyLCDigKYsIGsoazw9bS0xKVxuXG7lhbbkuK3vvJpIKGtleSnvvJrlk4jluIzlh73mlbDvvJtt77ya5pWj5YiX6KGo6ZW/5bqm77ybXG5kae+8muesrGnmrKHmjqLmtYvml7bnmoTlop7ph4/luo/liJfvvJtcbkhpKGtleSkg77ya57uP56ysaeasoeaOoua1i+WQjuW+l+WIsOeahOaVo+WIl+WcsOWdgOOAglxuXG7ikbQgIOe6v+aAp+aOoua1i+azlVxu5bCG5pWj5YiX6KGoVFswIOKApm0tMV3nnIvmiJDlvqrnjq/lkJHph4/jgILlvZPlj5HnlJ/lhrLnqoHml7bvvIzku47liJ3mrKHlj5HnlJ/lhrLnqoHnmoTkvY3nva7kvp3mrKHlkJHlkI7mjqLmtYvlhbbku5bnmoTlnLDlnYDjgIJcbuWinumHj+W6j+WIl+S4uu+8mmRpPTEsIDIsIDMsIOKApiwgbS0xXG7orr7liJ3mrKHlj5HnlJ/lhrLnqoHnmoTlnLDlnYDmmK9o77yM5YiZ5L6d5qyh5o6i5rWLVFtoKzFd77yMVFtoKzJd4oCm77yM55u05YiwVFttLTFd5pe25Y+I5b6q546v5Yiw6KGo5aS077yM5YaN5qyh5o6i5rWLVFswXe+8jFRbMV3igKbvvIznm7TliLBUW2gtMV3jgILmjqLmtYvov4fnqIvnu4jmraLnmoTmg4XlhrXmmK/vvJpcbuKXhiDmjqLmtYvliLDnmoTlnLDlnYDkuLrnqbrvvJrooajkuK3msqHmnInorrDlvZXjgILoi6XmmK/mn6Xmib7liJnlpLHotKXvvJvoi6XmmK/mj5LlhaXliJnlsIborrDlvZXlhpnlhaXliLDor6XlnLDlnYDvvJtcbuKXhiDmjqLmtYvliLDnmoTlnLDlnYDmnInnu5nlrprnmoTlhbPplK7lrZfvvJroi6XmmK/mn6Xmib7liJnmiJDlip/vvJvoi6XmmK/mj5LlhaXliJnlpLHotKXvvJtcbuKXhiDnm7TliLBUW2hd77ya5LuN5pyq5o6i5rWL5Yiw56m65Zyw5Z2A5oiW57uZ5a6a55qE5YWz6ZSu5a2X77yM5pWj5YiX6KGo5ruh44CCXG5cbuS+izEg77ya6K6+5pWj5YiX6KGo6ZW/5Li6N++8jOiusOW9leWFs+mUruWtl+e7hOS4uu+8mjE1LCAxNCwgMjgsIDI2LCA1NiwgMjPvvIzmlaPliJflh73mlbDvvJpIKGtleSk9a2V5ICAgTU9EICA377yM5Yay56qB5aSE55CG6YeH55So57q/5oCn5o6i5rWL5rOV44CCXG5IKDE1KT0xNSAgTU9EIDc9MVxuSCgxNCk9MTQgIE1PRCA3PTBcbkgoMjgpPTI4ICBNT0QgNz0wICDlhrLnqoEgICBIMSgyOCk9MSAg5Y+I5Yay56qBXG5IMigyOCk9MiAgICAgICAgICAgSCgyNik9MjYgIE1PRCA3PTVcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXG5IMig1Nik9MiAgIOWPiOWGsueqgSAgICBIMyg1Nik9M1xuSCgyMyk9MjMgIE1PRCA3PTIgICAgIOWGsueqgSAgICAgIEgxKDIzKT0zICAgICDlj4jlhrLnqoFcbkgzKDIzKT00XG5cbjAgICAgIDEgICAgICAyICAgICAgMyAgICAgIDQgICAgICAgNSAgICAgNlxuMTQgICAgMTUgICAgIDI4ICAgICA1NiAgICAgMjMgICAgICAyNlxuXG7nur/mgKfmjqLmtYvms5XnmoTnibnngrlcbuKXhiDkvJjngrnvvJrlj6ropoHmlaPliJfooajmnKrmu6HvvIzmgLvog73mib7liLDkuIDkuKrkuI3lhrLnqoHnmoTmlaPliJflnLDlnYDvvJtcbuKXhiDnvLrngrnvvJrmr4/kuKrkuqfnlJ/lhrLnqoHnmoTorrDlvZXooqvmlaPliJfliLDnprvlhrLnqoHmnIDov5HnmoTnqbrlnLDlnYDkuIrvvIzku47ogIzlj4jlop7liqDkuobmm7TlpJrnmoTlhrLnqoHmnLrkvJoo6L+Z56eN546w6LGh56ew5Li65Yay56qB55qE4oCc6IGa6ZuG4oCdKeOAglxuXG7ikbUgIOS6jOasoeaOoua1i+azlVxu5aKe6YeP5bqP5YiX5Li677yaZGk9McKyLC0xwrIsMsKyLC0ywrIsM8KyLOKApuKApsKxa8KyICAoazw94oyKbS8y4oyLKVxuXG7kuIrov7Dkvovpopjoi6Xph4fnlKjkuozmrKHmjqLmtYvms5Xov5vooYzlhrLnqoHlpITnkIbvvIzliJnvvJpcbkgoMTUpPTE1ICBNT0QgNz0xICAgICAgICAgSCgxNCk9MTQgIE1PRCA3PTBcbkgoMjgpPTI4ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSgyOCk9MSAgICAg5Y+I5Yay56qBXG5IMigyOCk9NFxuSCgyNik9MjYgIE1PRCA3PTVcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXG5IMig1Nik9MCAgIOWPiOWGsueqgSAgICBIMyg1Nik9NCAgICDlj4jlhrLnqoFcbkg0KDU2KT0yXG5IKDIzKT0yMyAgTU9EIDc9MiAgICAgIOWGsueqgVxuSDEoMjMpPTNcblxu5LqM5qyh5o6i5rWL5rOV55qE54m554K5XG7il4Yg5LyY54K577ya5o6i5rWL5bqP5YiX6Lez6LeD5byP5Zyw5pWj5YiX5Yiw5pW05Liq6KGo5Lit77yM5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd546w6LGh77ybXG7il4Yg57y654K577ya5LiN6IO95L+d6K+B5o6i5rWL5Yiw5pWj5YiX6KGo55qE5omA5pyJ5Zyw5Z2A44CCXG5cbuKRtiAgIOS8qumaj+acuuaOoua1i+azlVxu5aKe6YeP5bqP5YiX5L2/55So5LiA5Liq5Lyq6ZqP5py65Ye95pWw5p2l5Lqn55Sf5LiA5Liq6JC95Zyo6Zet5Yy66Ze0WzHvvIxtLTFd55qE6ZqP5py65bqP5YiX44CCXG5cbuS+izIg77yaIOihqOmVv+S4ujEx55qE5ZOI5biM6KGo5Lit5bey5aGr5pyJ5YWz6ZSu5a2X5Li6MTfvvIw2MO+8jDI555qE6K6w5b2V77yM5pWj5YiX5Ye95pWw5Li6SChrZXkpPWtleSAgTU9EICAxMSDjgIIg546w5pyJ56ysNOS4quiusOW9le+8jOWFtuWFs+mUruWtl+S4ujM477yM5oyJ5LiJ56eN5aSE55CG5Yay56qB55qE5pa55rOV77yM5bCG5a6D5aGr5YWl6KGo5Lit44CCXG5cbigxKSAgSCgzOCk9MzggTU9EIDExPTUgICAg5Yay56qBXG4gICAgIEgxPSg1KzEpIE1PRCAxMT02ICAgIOWGsueqgVxuICAgICBIMj0oNSsyKSBNT0QgMTE9NyAgICDlhrLnqoFcbiAgICAgSDM9KDUrMykgTU9EIDExPTggICAg5LiN5Yay56qBXG4oMikgIEgoMzgpPTM4IE1PRCAxMT01ICAgICAg5Yay56qBXG4gICAgIEgxPSg1KzHCsikgTU9EIDExPTYgICAg5Yay56qBXG4gICAgIEgyPSg1LTHCsikgTU9EIDExPTQgICAgIOS4jeWGsueqgVxuKDMpICBIKDM4KT0zOCBNT0QgMTE9NSAgICDlhrLnqoFcbiAgICAg6K6+5Lyq6ZqP5py65pWw5bqP5YiX5Li6Oe+8jOWImUgxPSg1KzkpIE1PRCAxMT0zIOS4jeWGsueqgVxuXG5cbjIgIOWGjeWTiOW4jOazlVxu5p6E6YCg6Iul5bmy5Liq5ZOI5biM5Ye95pWw77yM5b2T5Y+R55Sf5Yay56qB5pe277yM5Yip55So5LiN5ZCM55qE5ZOI5biM5Ye95pWw5YaN6K6h566X5LiL5LiA5Liq5paw5ZOI5biM5Zyw5Z2A77yM55u05Yiw5LiN5Y+R55Sf5Yay56qB5Li65q2i44CC5Y2z77yaSGk9UkhpKGtleSkgICAgIGk9MSwgMiwg4oCmLCBrXG5SSGkg77ya5LiA57uE5LiN5ZCM55qE5ZOI5biM5Ye95pWw44CC56ys5LiA5qyh5Y+R55Sf5Yay56qB5pe277yM55SoUkgx6K6h566X77yM56ys5LqM5qyh5Y+R55Sf5Yay56qB5pe277yM55SoUkgy6K6h566X4oCm5L6d5q2k57G75o6o55+l6YGT5b6X5Yiw5p+Q5LiqSGnkuI3lho3lhrLnqoHkuLrmraLjgIJcbuKXhiAg5LyY54K577ya5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd546w6LGh77ybXG7il4YgIOe8uueCue+8muiuoeeul+aXtumXtOWinuWKoOOAglxuXG5cbjMgIOmTvuWcsOWdgOazlVxu5pa55rOV77ya5bCG5omA5pyJ5YWz6ZSu5a2X5Li65ZCM5LmJ6K+NKOaVo+WIl+WcsOWdgOebuOWQjCnnmoTorrDlvZXlrZjlgqjlnKjkuIDkuKrljZXpk77ooajkuK3vvIzlubbnlKjkuIDnu7TmlbDnu4TlrZjmlL7pk77ooajnmoTlpLTmjIfpkojjgIJcbuiuvuaVo+WIl+ihqOmVv+S4um3vvIzlrprkuYnkuIDkuKrkuIDnu7TmjIfpkojmlbDnu4TvvJpcblJlY05vZGUgKmxpbmtoYXNoW21d77yM5YW25LitUmVjTm9kZeaYr+e7k+eCueexu+Wei++8jOavj+S4quWIhumHj+eahOWIneWAvOS4uuepuuOAguWHoeaVo+WIl+WcsOWdgOS4umvnmoTorrDlvZXpg73mj5LlhaXliLDku6VsaW5raGFzaFtrXeS4uuWktOaMh+mSiOeahOmTvuihqOS4re+8jOaPkuWFpeS9jee9ruWPr+S7peWcqOihqOWktOaIluihqOWwvuaIluaMieWFs+mUruWtl+aOkuW6j+aPkuWFpeOAglxuXG7kvovvvJog5bey55+l5LiA57uE5YWz6ZSu5a2XKDE5LCAxNCwgMjMsIDEsIDY4LCAyMCwgODQsIDI3LCA1NSwgMTEsIDEwLCA3OSkg77yM5ZOI5biM5Ye95pWw5Li677yaSChrZXkpPWtleSBNT0QgMTPvvIznlKjpk77lnLDlnYDms5XlpITnkIblhrLnqoE6XG5cbiAwXG4gMSAgLS0+IDE0IC0+IDEgLT4gMjcgLT4gNzlcbiAyXG4gMyAgLS0+IDY4IC0+IDU1XG4gNFxuIDVcbiA2ICAtLT4gMTkgLT4gODRcbiA3ICAtLT4gMjBcbiA4XG4gOVxuIDEwIC0tPiAyMyAtPiAxMFxuIDExIC0tPiAxMVxuIDEyXG5cbiDkvJjngrnvvJrkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3vvJvliKDpmaTorrDlvZXkuZ/lvojnroDljZXjgIJcblxuXG4gNCAg5bu656uL5YWs5YWx5rqi5Ye65Yy6XG4g5pa55rOV77ya5Zyo5Z+65pys5pWj5YiX6KGo5LmL5aSW77yM5Y+m5aSW6K6+56uL5LiA5Liq5rqi5Ye66KGo5L+d5a2Y5LiO5Z+65pys6KGo5Lit6K6w5b2V5Yay56qB55qE5omA5pyJ6K6w5b2V44CCXG4g6K6+5pWj5YiX6KGo6ZW/5Li6be+8jOiuvueri+WfuuacrOaVo+WIl+ihqGhhc2h0YWJsZVttXe+8jOavj+S4quWIhumHj+S/neWtmOS4gOS4quiusOW9le+8m+a6ouWHuuihqG92ZXJ0YWJsZVttXe+8jOS4gOaXpuafkOS4quiusOW9leeahOaVo+WIl+WcsOWdgOWPkeeUn+WGsueqge+8jOmDveWhq+WFpea6ouWHuuihqOS4reOAglxuXG4g5L6L77yaIOW3suefpeS4gOe7hOWFs+mUruWtlygxNSwgNCwgMTgsIDcsIDM3LCA0Nykg77yM5pWj5YiX6KGo6ZW/5bqm5Li6NyDvvIzlk4jluIzlh73mlbDkuLrvvJpIKGtleSk9a2V5IE1PRCA377yM55So5bu656uL5YWs5YWx5rqi5Ye65Yy65rOV5aSE55CG5Yay56qB44CC5b6X5Yiw55qE5Z+65pys6KGo5ZKM5rqi5Ye66KGo5aaC5LiL77yaXG4gICAgICAgICAgICAgICAgICAgIOaVo+WIl+WcsOWdgCAgICAwICAgICAxICAgICAyICAgICAzICAgICA0ICAgICA1ICAgICA2XG4gSGFzaHRhYmxl6KGo77yaXG4gICAgICAgICAgICAgICAgICAgIOWFs+mUruWtlyAgICAgNyAgICAgMTUgICAgMzcgICAgICAgICAgNCAgICAgNDdcblxuICAgICAgICAgICAgICAgICAgICDmuqLlh7rlnLDlnYAgICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNSAgICAgNlxuIG92ZXJ0YWJsZeihqO+8mlxuICAgICAgICAgICAgICAgICAgICAg5YWz6ZSu5a2XICAgIDE4XG5cblxuXG5cbiDlk4jluIzmn6Xmib7ov4fnqIvlj4rliIbmnpBcblxuIDEgICDlk4jluIzmn6Xmib7ov4fnqItcbiDlk4jluIzooajnmoTkuLvopoHnm67nmoTmmK/nlKjkuo7lv6vpgJ/mn6Xmib7vvIzkuJTmj5LlhaXlkozliKDpmaTmk43kvZzpg73opoHnlKjliLDmn6Xmib7jgILnlLHkuo7mlaPliJfooajnmoTnibnmrornu4Tnu4flvaLlvI/vvIzlhbbmn6Xmib7mnInnibnmrornmoTmlrnms5XjgIJcblxuIOe7meWumkvlgLzvvIzmoLnmja7pgKDooajml7borr7lrprnmoTlk4jluIzlh73mlbDmsYLlvpflk4jluIzlnLDlnYDvvIzoi6XooajkuK3mraTkvY3nva7kuIrmsqHmnInorrDlvZXvvIzliJnmn6Xmib7kuI3miJDlip/vvJvlkKbliJnmr5TovoPlhbPplK7lrZfvvIzoi6Xlkoznu5nlrprlhbPplK7lrZfnm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvJvlkKbliJnmoLnmja7pgKDooajml7borr7lrprnmoTlpITnkIblhrLnqoHnmoTmlrnms5Xmib7igJzkuIvkuIDlnLDlnYDigJ3vvIznm7TliLDlk4jluIzooajkuK3mn5DkuKrkvY3nva7kuLrnqbrmiJbogIXooajkuK3miYDloavorrDlvZXnmoTlhbPplK7lrZfnrYnkuo7nu5nlrprlgLzml7bkuLrmraLjgIJcblxuXG5cbiDlk4jluIzmn6Xmib7liIbmnpBcblxuIOS7juWTiOW4jOafpeaJvui/h+eoi+WPr+inge+8muWwveeuoeaVo+WIl+ihqOWcqOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+S6huebtOaOpeaYoOixoe+8jOS9hueUseS6juKAnOWGsueqgeKAne+8jOafpeaJvui/h+eoi+S7jeaYr+S4gOS4que7meWumuWAvOS4juWFs+mUruWtl+i/m+ihjOavlOi+g+eahOi/h+eoi++8jOivhOS7t+WTiOW4jOafpeaJvuaViOeOh+S7jeimgeeUqEFTTOOAglxuIOWTiOW4jOafpeaJvuaXtuWFs+mUruWtl+S4jue7meWumuWAvOavlOi+g+eahOasoeaVsOWPluWGs+S6ju+8mlxuIOKXhiDlk4jluIzlh73mlbDvvJtcbiDil4Yg5aSE55CG5Yay56qB55qE5pa55rOV77ybXG4g4peGIOWTiOW4jOihqOeahOWhq+a7oeWboOWtkM6xIOOAguWhq+a7oeWboOWtkM6x55qE5a6a5LmJ5piv77yaXG5cbiDOsSA9IOihqOS4reWhq+WFpeeahOiusOW9leaVsCAvIOWTiOW4jOihqOmVv+W6plxuXG5cbiDlkITnp43mlaPliJflh73mlbDmiYDmnoTpgKDnmoTmlaPliJfooajnmoRBU0zlpoLkuIvvvJpcblxuIOKRtCAgIOe6v+aAp+aOoua1i+azleeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxuIFPmiJDlip8g57qm562J5LqOIDEgLyAyICogKDEgKyAxIC8gKDEgLSDOsSkpXG4gU+Wksei0pSDnuqbnrYnkuo4gMSAvIDIgKiAoMSArIDEgLyAoMSAtIM6xKSAqICgxIC0gzrEpKVxuXG4g4pG1ICAg5LqM5qyh5o6i5rWL44CB5Lyq6ZqP5py65o6i5rWL44CB5YaN5ZOI5biM5rOV55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXG4gU+aIkOWKnyDnuqbnrYnkuo4gLTEgLyDOsSAqIGxuKDEgLSDOsSlcbiBT5aSx6LSlIOe6puetieS6jiAxIC8gKDEgLSDOsSlcblxuIOKRtiAgIOeUqOmTvuWcsOWdgOazleino+WGs+WGsueqgeeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxuIFPmiJDlip8g57qm562J5LqOIDEgKyDOsSAvIDJcbiBT5aSx6LSlIOe6puetieS6jiDOsSArIGXnmoQtzrHmrKHluYJcblxuXG4gKi9cblxuaW1wb3J0IExpbmtlZExpc3QgZnJvbSAnLi4vTGlzdC9MaW5rZWRMaXN0JztcblxuXG5sZXQgaGFzaFNpemUgPSBidWlsZEhhc2hTaXplKDk3NywgMjApO1xuXG5leHBvcnQgY2xhc3MgSGFzaFRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIC8vIOW9k+WJjeaVsOaNruWFg+e0oOS4quaVsDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIC8vIOW9k+WJjeWuuemHj1xuICAgICAgICB0aGlzLnNpemVJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8g5L2/55So57q/5oCn5o6i5rWL5rOV6Kej5Yaz5Yay56qBXG4gICAgc2VhcmNoKGtleSkge1xuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xuICAgICAgICBsZXQgcCA9IGhhc2goa2V5LCBtYXgpO1xuICAgICAgICBsZXQgYyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHAgPCBtYXggJiYgdGhpcy5kYXRhW3BdICE9IG51bGwgJiYga2V5ICE9PSB0aGlzLmRhdGFbcF0pIHtcbiAgICAgICAgICAgIHAgPSBjb2xsaXNpb24oa2V5LCArK2MsIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2Vzczoga2V5ID09PSB0aGlzLmRhdGFbcF0sXG4gICAgICAgICAgICBjb2xsaXNpb25UaW1lczogYyxcbiAgICAgICAgICAgIGluZGV4OiBwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5zZXJ0KGtleSkge1xuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5jb3VudCA+PSBtYXgpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcm1zZzogJ3RhYmxlIG92ZXJmbG93ZWQnIH07XG5cbiAgICAgICAgbGV0IHJldCA9IHRoaXMuc2VhcmNoKGtleSk7XG4gICAgICAgIGxldCBwID0gcmV0LmluZGV4O1xuICAgICAgICBsZXQgYyA9IHJldC5jb2xsaXNpb25UaW1lcztcblxuICAgICAgICBpZiAocmV0LnN1Y2Nlc3MpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwXSA9IGtleTtcbiAgICAgICAgICAgICsrdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWNyZWF0ZUhhc2hUYWJsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuY291bnQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xuICAgICAgICBsZXQgcCA9IGhhc2goa2V5LCBtYXgpO1xuICAgICAgICBsZXQgYyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGtleSAhPT0gdGhpcy5kYXRhW3BdKVxuICAgICAgICAgICAgcCA9IGNvbGxpc2lvbihrZXksICsrYywgbWF4KTtcblxuXG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMuZGF0YVtwXSkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFbcF07XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKHAsIDEpO1xuICAgICAgICAgICAgLS10aGlzLmNvdW50O1xuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZWNyZWF0ZUhhc2hUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICsrdGhpcy5zaXplSW5kZXggPCBoYXNoU2l6ZS5sZW5ndGg7XG4gICAgfVxuXG59O1xuXG4vLyBFTEZoYXNo5a2X56ym5Liy5pWj5YiX5Ye95pWwXG5mdW5jdGlvbiBoYXNoKHN0ciwgbWF4KSB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSArIGhhc2ggKyBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgICAgaGFzaCA9IE1hdGguYWJzKGhhc2gpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaCAlIG1heDtcbn1cblxuZnVuY3Rpb24gY29sbGlzaW9uKGtleSwgdGltZXMsIG1heCkge1xuICAgIC8vIOe6v+aAp+aOoua1i+azlVxuICAgIHJldHVybiAoaGFzaChrZXksIG1heCkgKyB0aW1lcykgJSBtYXg7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWUobikge1xuICAgIGlmIChuIDw9IDMpIHJldHVybiBuID4gMTtcbiAgICBpZiAobiAlIDIgPT09IDAgfHwgbiAlIDMgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gNTsgaSAqIGkgPD0gbjsgaSArPSA2KSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCB8fCBuICUgKGkgKyAyKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBidWlsZEhhc2hTaXplKGJlZ2luLCBsZW5ndGgpIHtcbiAgICBsZXQgaGFzaFNpemUgPSBbXTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAgIGlmIChoYXNoU2l6ZS5sZW5ndGggPj0gbGVuZ3RoKSBicmVhaztcbiAgICAgICAgaWYgKGlzUHJpbWUoYmVnaW4pKSBoYXNoU2l6ZS5wdXNoKGJlZ2luKTtcbiAgICAgICAgKytiZWdpbjtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaFNpemU7XG59XG5cbi8vIOW8gOaUvuWumuWdgOazlVxuLy9oYXNoU2l6ZSA9IFs1LCA3XTsgLy8gZm9yIHRlc3QuIHdpbGwgYmUgZGVsZXRlZFxubGV0IHRlc3QgPSBuZXcgSGFzaFRhYmxlKCk7XG50ZXN0Lmluc2VydCgnMTcnKTtcbnRlc3QuaW5zZXJ0KCc2MCcpO1xudGVzdC5pbnNlcnQoJzI5Jyk7XG50ZXN0Lmluc2VydCgnMzgnKTtcbnRlc3QuaW5zZXJ0KCczOScpO1xudGVzdC5pbnNlcnQoJzQwJyk7XG5cbnRlc3QucmVtb3ZlKCcxNycpO1xudGVzdC5yZW1vdmUoJzYwJyk7XG50ZXN0LnJlbW92ZSgnMjknKTtcbnRlc3QucmVtb3ZlKCczOCcpO1xudGVzdC5yZW1vdmUoJzM5Jyk7XG50ZXN0LnJlbW92ZSgnNDAnKTtcblxuXG4vLyDkvb/nlKjpk77lnLDlnYDms5Xop6PlhrPlhrLnqoHnmoTlk4jluIzooahcblxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3RIYXNoVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyDlvZPliY3mlbDmja7lhYPntKDkuKrmlbA7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAvLyDlvZPliY3lrrnph49cbiAgICAgICAgdGhpcy5zaXplSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmhOb2RlcyA9IFtdO1xuICAgIH1cblxuICAgIHNlYXJjaChrZXkpIHtcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcbiAgICAgICAgbGV0IGkgPSBoYXNoKGtleSwgbWF4KTtcbiAgICAgICAgbGV0IHQgPSB0aGlzLmhOb2RlcztcblxuICAgICAgICBpZiAodFtpXSA9PSBudWxsKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgaW5kZXg6IGkgfTtcblxuICAgICAgICBsZXQgcCA9IHRbaV07XG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcblxuICAgICAgICBwLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGRhdGEgPT09IGtleSwgaW5kZXg6IGkgfTtcbiAgICB9XG5cbiAgICBpbnNlcnQoa2V5KSB7XG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID49IG1heCkgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9ybXNnOiAndGFibGUgb3ZlcmZsb3dlZCcgfTtcblxuICAgICAgICBsZXQgcmV0ID0gdGhpcy5zZWFyY2goa2V5KTtcbiAgICAgICAgbGV0IGluZGV4ID0gcmV0LmluZGV4O1xuXG4gICAgICAgIGlmIChyZXQuc3VjY2VzcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5oTm9kZXNbaW5kZXhdKSB0aGlzLmhOb2Rlc1tpbmRleF0gPSBuZXcgTGlua2VkTGlzdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmhOb2Rlc1tpbmRleF0uc2l6ZSA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcbiAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XS5vcmRlckluc2VydChrZXkpO1xuICAgICAgICAgICAgKyt0aGlzLmNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY3JlYXRlSGFzaFRhYmxlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5jb3VudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGxldCByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xuXG4gICAgICAgIGlmIChyZXQuc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcmV0LmluZGV4O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXQuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XVsncmVtb3ZlJ10oa2V5KTtcbiAgICAgICAgICAgIC0tdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlY3JlYXRlSGFzaFRhYmxlKCkge1xuICAgICAgICByZXR1cm4gKyt0aGlzLnNpemVJbmRleCA8IGhhc2hTaXplLmxlbmd0aDtcbiAgICB9XG59O1xuXG5sZXQgdGVzdDIgPSBuZXcgTGlua2VkTGlzdEhhc2hUYWJsZSgpO1xudGVzdDIuaW5zZXJ0KCcxNycpO1xudGVzdDIuaW5zZXJ0KCc2MCcpO1xudGVzdDIuaW5zZXJ0KCcyOScpO1xudGVzdDIuaW5zZXJ0KCczOCcpO1xudGVzdDIuaW5zZXJ0KCczOScpO1xudGVzdDIuaW5zZXJ0KCc0MCcpO1xuXG50ZXN0Mi5yZW1vdmUoJzE3Jyk7XG50ZXN0Mi5yZW1vdmUoJzYwJyk7XG50ZXN0Mi5yZW1vdmUoJzI5Jyk7XG50ZXN0Mi5yZW1vdmUoJzM4Jyk7XG50ZXN0Mi5yZW1vdmUoJzM5Jyk7XG50ZXN0Mi5yZW1vdmUoJzQwJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL0hhc2hUYWJsZS5qcyIsIi8qKlxuICogUmVkIEJsYWNrIFRyZWVcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE0LzEyLzMwLlxuICovXG4vKlxuIGh0dHA6Ly9ibG9nLmNzZG4ubmV0L3ZfanVseV92L2FydGljbGUvZGV0YWlscy82MTA1NjMwXG5cbiDnuqLpu5HmoJHvvIzkuIDnp43kuozlj4nmn6Xmib7moJHvvIzkvYblnKjmr4/kuKrnu5PngrnkuIrlop7liqDkuIDkuKrlrZjlgqjkvY3ooajnpLrnu5PngrnnmoTpopzoibLvvIzlj6/ku6XmmK9SZWTmiJZCbGFja+OAglxuIOmAmui/h+WvueS7u+S9leS4gOadoeS7juagueWIsOWPtuWtkOeahOi3r+W+hOS4iuWQhOS4que7k+eCueedgOiJsuaWueW8j+eahOmZkOWItu+8jOe6oum7keagkeehruS/neayoeacieS4gOadoei3r+W+hOS8muavlOWFtuS7lui3r+W+hOmVv+WHuuS/qeWAje+8jOWboOiAjOaYr+aOpei/keW5s+ihoeeahOOAglxuXG4g57qi6buR5qCR6Jm954S25pys6LSo5LiK5piv5LiA5qO15LqM5Y+J5p+l5om+5qCR77yM5L2G5a6D5Zyo5LqM5Y+J5p+l5om+5qCR55qE5Z+656GA5LiK5aKe5Yqg5LqG552A6Imy5ZKM55u45YWz55qE5oCn6LSo5L2/5b6X57qi6buR5qCR55u45a+55bmz6KGh77yM5LuO6ICM5L+d6K+B5LqG57qi6buR5qCR55qE5p+l5om+44CB5o+S5YWl44CB5Yig6Zmk55qE5pe26Ze05aSN5p2C5bqm5pyA5Z2P5Li6Tyhsb2cgbinjgIJcblxuIOe6oum7keagkeeahDXkuKrmgKfotKjvvJpcbiAxLuavj+S4que7k+eCueimgeS5iOaYr+e6oueahOimgeS5iOaYr+m7keeahOOAglxuIDIu5qC557uT54K55piv6buR55qE44CCXG4gMy7mr4/kuKrlj7bnu5PngrnvvIjlj7bnu5PngrnljbPmjIfmoJHlsL7nq69OSUzmjIfpkojmiJZOVUxM57uT54K577yJ6YO95piv6buR55qE44CCXG4gNC7lpoLmnpzkuIDkuKrnu5PngrnmmK/nuqLnmoTvvIzpgqPkuYjlroPnmoTkuKTkuKrlhL/lrZDpg73mmK/pu5HnmoTjgIJcbiA1LuWvueS6juS7u+aEj+e7k+eCueiAjOiogO+8jOWFtuWIsOWPtue7k+eCueagkeWwvuerr05JTOaMh+mSiOeahOavj+adoei3r+W+hOmDveWMheWQq+ebuOWQjOaVsOebrueahOm7kee7k+eCueOAglxuXG4g5q2j5piv57qi6buR5qCR55qE6L+ZNeadoeaAp+i0qO+8jOS9v+S4gOajtW7kuKrnu5PngrnnmoTnuqLpu5HmoJHlp4vnu4jkv53mjIHkuoZsb2du55qE6auY5bqm77yM5LuO6ICM5Lmf5bCx6Kej6YeK5LqG5LiK6Z2i5omA6K+055qE4oCc57qi6buR5qCR55qE5p+l5om+44CB5o+S5YWl44CB5Yig6Zmk55qE5pe26Ze05aSN5p2C5bqm5pyA5Z2P5Li6Tyhsb2cgbinigJ3ov5nkuIDnu5PorrrmiJDnq4vnmoTljp/lm6DjgIJcblxuXG4g5qCR55qE5peL6L2sXG5cbuW9k+WcqOWvuee6oum7keagkei/m+ihjOaPkuWFpeWSjOWIoOmZpOetieaTjeS9nOaXtu+8jOWvueagkeWBmuS6huS/ruaUueWPr+iDveS8muegtOWdj+e6oum7keagkeeahOaAp+i0qOOAguS4uuS6hue7p+e7reS/neaMgee6oum7keagkeeahOaAp+i0qO+8jOWPr+S7pemAmui/h+Wvuee7k+eCuei/m+ihjOmHjeaWsOedgOiJsu+8jOS7peWPiuWvueagkei/m+ihjOebuOWFs+eahOaXi+i9rOaTjeS9nO+8jOWNs+mAmui/h+S/ruaUueagkeS4reafkOS6m+e7k+eCueeahOminOiJsuWPiuaMh+mSiOe7k+aehO+8jOadpei+vuWIsOWvuee6oum7keagkei/m+ihjOaPkuWFpeaIluWIoOmZpOe7k+eCueetieaTjeS9nOWQjue7p+e7reS/neaMgeWug+eahOaAp+i0qOaIluW5s+ihoeeahOebrueahOOAglxuXG7moJHnmoTml4vovazliIbkuLrlt6bml4vlkozlj7Pml4tcblxu5qCR5Zyo57uP6L+H5bem5peL5Y+z5peL5LmL5ZCO77yM5qCR55qE5pCc57Si5oCn6LSo5L+d5oyB5LiN5Y+Y77yM5L2G5qCR55qE57qi6buR5oCn6LSo5YiZ6KKr56C05Z2P5LqG77yM5omA5Lul77yM57qi6buR5qCR5o+S5YWl5ZKM5Yig6Zmk5pWw5o2u5ZCO77yM6ZyA6KaB5Yip55So5peL6L2s5LiO6aKc6Imy6YeN5raC5p2l6YeN5paw5oGi5aSN5qCR55qE57qi6buR5oCn6LSo44CCXG5cblxu57qi6buR5qCR55qE5o+S5YWlXG5cbuWmguaenOaPkuWFpeeahOaYr+aguee7k+eCue+8jOeUseS6juWOn+agkeaYr+epuuagke+8jOatpOaDheWGteWPquS8mui/neWPjeaAp+i0qDLvvIzlm6DmraTnm7TmjqXmiormraTnu5PngrnmtoLkuLrpu5HoibLvvJvlpoLmnpzmj5LlhaXnmoTnu5PngrnnmoTniLbnu5PngrnmmK/pu5HoibLvvIznlLHkuo7mraTkuI3kvJrov53lj43mgKfotKgy5ZKM5oCn6LSoNO+8jOe6oum7keagkeayoeacieiiq+egtOWdj++8jOaJgOS7peatpOaXtuS7gOS5iOS5n+S4jeWBmuOAglxu5L2G5b2T6YGH5Yiw5LiL6L+wM+enjeaDheWGteaXtuWPiOivpeWmguS9leiwg+aVtOWRou+8n1xu4pePIOaPkuWFpeS/ruWkjeaDheWGtTHvvJrlpoLmnpzlvZPliY3nu5PngrnnmoTniLbnu5PngrnmmK/nuqLoibLkuJTnpZbniLbnu5PngrnnmoTlj6bkuIDkuKrlrZDnu5PngrnvvIjlj5Tnu5PngrnvvInmmK/nuqLoibJcbuatpOaXtueItue7k+eCueeahOeItue7k+eCueS4gOWumuWtmOWcqO+8jOWQpuWImeaPkuWFpeWJjeWwseW3suS4jeaYr+e6oum7keagkeOAguS4juatpOWQjOaXtu+8jOWPiOWIhuS4uueItue7k+eCueaYr+ellueItue7k+eCueeahOW3puWtqeWtkOi/mOaYr+WPs+WtqeWtkO+8jOagueaNruWvueensOaAp++8jOaIkeS7rOWPquimgeino+W8gOS4gOS4quaWueWQkeWwseWPr+S7peS6huOAgui/memHjOWPquiAg+iZkeeItue7k+eCueS4uuellueItuW3puWtqeWtkOeahOaDheWGtVxu5a+55q2k77yM5oiR5Lus55qE6Kej5Yaz562W55Wl5piv77ya5bCG5b2T5YmN6IqC54K555qE54i26IqC54K55ZKM5Y+U5Y+U6IqC54K55raC6buR77yM56WW54i257uT54K55raC57qi77yM5oqK5b2T5YmN57uT54K55oyH5ZCR56WW54i26IqC54K577yM5LuO5paw55qE5b2T5YmN6IqC54K56YeN5paw5byA5aeL566X5rOV44CCXG7kuo7mmK/vvIzmj5LlhaXkv67lpI3mg4XlhrUx6L2s5o2i5oiQ5LqG5o+S5YWl5L+u5aSN5oOF5Ya1MlxuXG7il48g5o+S5YWl5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueeahOeItuiKgueCueaYr+e6ouiJsizlj5ToioLngrnmmK/pu5HoibLvvIzlvZPliY3oioLngrnmmK/lhbbniLboioLngrnnmoTlj7PlrZBcbuatpOaXtu+8jOino+WGs+WvueetluaYr++8muW9k+WJjeiKgueCueeahOeItuiKgueCueWBmuS4uuaWsOeahOW9k+WJjeiKgueCue+8jOS7peaWsOW9k+WJjeiKgueCueS4uuaUr+eCueW3puaXi+OAglxu5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcblxu4pePIOaPkuWFpeS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnnmoTniLboioLngrnmmK/nuqLoibIs5Y+U6IqC54K55piv6buR6Imy77yM5b2T5YmN6IqC54K55piv5YW254i26IqC54K555qE5bem5a2QXG7op6PlhrPlr7nnrZbmmK/vvJrniLboioLngrnlj5jkuLrpu5HoibLvvIznpZbniLboioLngrnlj5jkuLrnuqLoibLvvIzlnKjnpZbniLboioLngrnkuLrmlK/ngrnlj7Pml4vvvIxcbuacgOWQju+8jOaKiuaguee7k+eCuea2guS4uum7keiJsu+8jOaVtOajtee6oum7keagkeS+v+mHjeaWsOaBouWkjeS6huW5s+ihoeOAglxuXG7nu4/ov4fkuIrpnaLmg4XlhrUz44CB5oOF5Ya1NOOAgeaDheWGtTXnrYkz56eN5o+S5YWl5L+u5aSN5oOF5Ya155qE5pON5L2c56S65oSP5Zu+77yM6K+76ICF6Ieq5Lya5Y+R546w77yM5ZCO6Z2i55qE5oOF5Ya1NOOAgeaDheWGtTXpg73mmK/pkojlr7nmg4XlhrUz5o+S5YWl6IqC54K5NOS7peWQju+8jOi/m+ihjOeahOS4gOezu+WIl+aPkuWFpeS/ruWkjeaDheWGteaTjeS9nO+8jOS4jei/h++8jOaMh+WQkeW9k+WJjeiKgueCuU7mjIfpkojkuIDnm7TlnKjlj5jljJbjgILmiYDku6XvvIzkvaDlj6/ku6Xmg7PlvZPnhLbnmoTorqTkuLrvvJrmlbTkuKrkuIvmnaXvvIzmg4XlhrUz44CBNOOAgTXlsLHmmK/kuIDkuKrlrozmlbTnmoTmj5LlhaXkv67lpI3mg4XlhrXnmoTmk43kvZzmtYHnqItcblxuXG7nuqLpu5HmoJHnmoTliKDpmaRcblxu5Zyo5Yig6Zmk6IqC54K55ZCO77yM5Y6f57qi6buR5qCR55qE5oCn6LSo5Y+v6IO96KKr5pS55Y+Y77yM5aaC5p6c5Yig6Zmk55qE5piv57qi6Imy6IqC54K577yM6YKj5LmI5Y6f57qi6buR5qCR55qE5oCn6LSo5L6d5pen5L+d5oyB77yM5q2k5pe25LiN55So5YGa5L+u5q2j5pON5L2c77yM5aaC5p6c5Yig6Zmk55qE6IqC54K55piv6buR6Imy6IqC54K577yM5Y6f57qi6buR5qCR55qE5oCn6LSo5Y+v6IO95Lya6KKr5pS55Y+Y77yM5oiR5Lus6KaB5a+55YW25YGa5L+u5q2j5pON5L2c44CC6YKj5LmI5ZOq5Lqb5qCR55qE5oCn6LSo5Lya5Y+R55Sf5Y+Y5YyW5ZGi77yM5aaC5p6c5Yig6Zmk6IqC54K55LiN5piv5qCR5ZSv5LiA6IqC54K577yM6YKj5LmI5Yig6Zmk6IqC54K555qE6YKj5LiA5Liq5pSv55qE5Yiw5ZCE5Y+26IqC54K555qE6buR6Imy6IqC54K55pWw5Lya5Y+R55Sf5Y+Y5YyW77yM5q2k5pe25oCn6LSoNeiiq+egtOWdj+OAguWmguaenOiiq+WIoOiKgueCueeahOWUr+S4gOmdnuepuuWtkOiKgueCueaYr+e6ouiJsu+8jOiAjOiiq+WIoOiKgueCueeahOeItuiKgueCueS5n+aYr+e6ouiJsu+8jOmCo+S5iOaAp+i0qDTooqvnoLTlnY/jgILlpoLmnpzooqvliKDoioLngrnmmK/moLnoioLngrnvvIzogIzlroPnmoTllK/kuIDpnZ7nqbrlrZDoioLngrnmmK/nuqLoibLvvIzliJnliKDpmaTlkI7mlrDmoLnoioLngrnlsIblj5jmiJDnuqLoibLvvIzov53og4zmgKfotKgy44CCXG5cbuS4iumdoueahOS/ruWkjeaDheWGteeci+i1t+adpeacieS6m+Wkjeadgu+8jOS4i+mdouaIkeS7rOeUqOS4gOS4quWIhuaekOaKgOW3p++8muaIkeS7rOS7juiiq+WIoOiKgueCueWQjuadpemhtuabv+Wug+eahOmCo+S4quiKgueCueW8gOWni+iwg+aVtO+8jOW5tuiupOS4uuWug+aciemineWklueahOS4gOmHjem7keiJsuOAgui/memHjOmineWkluS4gOmHjem7keiJsuaYr+S7gOS5iOaEj+aAneWRou+8jOaIkeS7rOS4jeaYr+aKiue6oum7keagkeeahOiKgueCueWKoOS4iumZpOe6ouS4jum7keeahOWPpuS4gOenjeminOiJsu+8jOi/memHjOWPquaYr+S4gOenjeWBh+iuvu+8jOaIkeS7rOiupOS4uuaIkeS7rOW9k+WJjeaMh+WQkeWug++8jOWboOatpOepuuaciemineWkluS4gOenjem7keiJsu+8jOWPr+S7peiupOS4uuWug+eahOm7keiJsuaYr+S7juWug+eahOeItuiKgueCueiiq+WIoOmZpOWQjue7p+aJv+e7meWug+eahO+8jOWug+eOsOWcqOWPr+S7peWuuee6s+S4pOenjeminOiJsu+8jOWmguaenOWug+WOn+adpeaYr+e6ouiJsu+8jOmCo+S5iOeOsOWcqOaYr+e6oivpu5HvvIzlpoLmnpzljp/mnaXmmK/pu5HoibLvvIzpgqPkuYjlroPnjrDlnKjnmoTpopzoibLmmK/pu5Er6buR44CC5pyJ5LqG6L+Z6YeN6aKd5aSW55qE6buR6Imy77yM5Y6f57qi6buR5qCR5oCn6LSoNeWwseiDveS/neaMgeS4jeWPmOOAgueOsOWcqOWPquimgeaBouWkjeWFtuWug+aAp+i0qOWwseWPr+S7peS6hu+8jOWBmuazlei/mOaYr+WwvemHj+WQkeagueenu+WKqOWSjOept+S4vuaJgOacieWPr+iDveaAp+OAglxuXG4g5aaC5p6c5piv5Lul5LiL5oOF5Ya177yM5oGi5aSN5q+U6L6D566A5Y2V77yaXG4gYSnlvZPliY3oioLngrnmmK/nuqIr6buR6ImyXG4g6Kej5rOV77yM55u05o6l5oqK5b2T5YmN6IqC54K55p+T5oiQ6buR6Imy77yM57uT5p2f5q2k5pe257qi6buR5qCR5oCn6LSo5YWo6YOo5oGi5aSN44CCXG4gYinlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5piv5qC56IqC54K577yMIOino+azle+8muS7gOS5iOmDveS4jeWBmu+8jOe7k+adn+OAglxuXG4g5L2G5aaC5p6c5piv5Lul5LiL5oOF5Ya15ZGi77yf77yaXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKVxuIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibJcbiDliKDpmaTkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRK+m7ke+8jOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOWFhOW8n+eahOW3puWtkOaYr+e6ouiJsu+8jOWPs+WtkOaYr+m7keiJslxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSPXG4g5q2k5pe277yM5oiR5Lus6ZyA6KaB6LCD55SoUkItREVMRVRFLUZJWFVQKFQsIHgp77yM5p2l5oGi5aSN5LiO5L+d5oyB57qi6buR5oCn6LSo55qE5bel5L2c44CCXG5cbiDkuIvpnaLvvIzlkrHku6zkvr/mnaXliIbliKvlpITnkIbov5k056eN5Yig6Zmk5L+u5aSN5oOF5Ya144CCXG5cbiDliKDpmaTkv67lpI3mg4XlhrUx77ya5b2T5YmN6IqC54K55piv6buRK+m7keS4lOWFhOW8n+iKgueCueS4uue6ouiJsijmraTml7bniLboioLngrnlkozlhYTlvJ/oioLngrnnmoTlrZDoioLngrnliIbkuLrpu5Ep44CCXG4g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV77yI5oiR5Lus5Y+q6K6o6K665b2T5YmN6IqC54K55piv5YW254i26IqC54K55bem5a2p5a2Q5pe255qE5oOF5Ya177yJ44CC5q2k5Y+Y5o2i5ZCO5Y6f57qi6buR5qCR5oCn6LSoNeS4jeWPmO+8jOiAjOaKiumXrumimOi9rOWMluS4uuWFhOW8n+iKgueCueS4uum7keiJsueahOaDheWGtSjms6jvvJrlj5jljJbliY3vvIzljp/mnKzlsLHmnKrov53lj43mgKfotKg177yM5Y+q5piv5Li65LqG5oqK6Zeu6aKY6L2s5YyW5Li65YWE5byf6IqC54K55Li66buR6Imy55qE5oOF5Ya1KeOAglxuXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJsuOAglxuIOino+azle+8muaKiuW9k+WJjeiKgueCueWSjOWFhOW8n+iKgueCueS4reaKveWPluS4gOmHjem7keiJsui/veWKoOWIsOeItuiKgueCueS4iu+8jOaKiueItuiKgueCueW9k+aIkOaWsOeahOW9k+WJjeiKgueCue+8jOmHjeaWsOi/m+WFpeeul+azleOAgu+8iOatpOWPmOaNouWQjuaAp+i0qDXkuI3lj5jvvIlcblxuIOWIoOmZpOS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Er6buR77yM5YWE5byf6IqC54K55piv6buR6Imy77yM5YWE5byf55qE5bem5a2Q5piv57qi6Imy77yM5Y+z5a2Q5piv6buR6Imy44CCXG4g6Kej5rOV77ya5oqK5YWE5byf57uT54K55p+T57qi77yM5YWE5byf5bem5a2Q6IqC54K55p+T6buR77yM5LmL5ZCO5YaN5Zyo5YWE5byf6IqC54K55Li65pSv54K56Kej5Y+z5peL77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV44CC5q2k5piv5oqK5b2T5YmN55qE5oOF5Ya16L2s5YyW5Li65oOF5Ya1NO+8jOiAjOaAp+i0qDXlvpfku6Xkv53mjIFcblxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSP44CCXG4g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXG5cblxuIOacgOWQjuWAvOW+l+S4gOaPkOeahOaYr+S4iui/sOWIoOmZpOS/ruWkjeeahOaDheWGtTF+NOmDveWPquaYr+agkeeahOWxgOmDqO+8jOW5tumdnuagkeeahOaVtOS9k+WFqOmDqO+8jOS4lOWIoOmZpOS/ruWkjeaDheWGtTPjgIE05Zyo57uP6L+H5LiK6Z2i55qE6LCD5pW05ZCO77yM6LCD5pW06L+Y5rKh57uT5p2fLOi/mOW+l+e7p+e7reiwg+aVtOebtOiHs+mHjeaWsOaBouWkjeW5s+ihoVxuKi9cbmltcG9ydCBCU1ROb2RlIGZyb20gJy4vQmluYXJ5U29ydGVkVHJlZSc7XG5cbmNvbnN0IFJFRCA9ICdyZWQnO1xuY29uc3QgQkxBQ0sgPSAnYmxhY2snO1xuXG5jbGFzcyBSZWRCbGFja05vZGUgZXh0ZW5kcyBCU1ROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgLi4ucmVzdCl7XG4gICAgICAgIHN1cGVyKGRhdGEsIC4uLnJlc3QpO1xuXG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaWdodENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY29sb3IgPSBSRUQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuXG5jbGFzcyBSZWRCbGFja0xlYWYge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY29sb3IgPSBCTEFDSztcbiAgICAgICAgdGhpcy5sZWZ0Q2hpbGQgPSB0aGlzO1xuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVkQmxhY2tUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAvLyDlk6jlhbVcbiAgICAgICAgdGhpcy5uaWwgPSBuZXcgUmVkQmxhY2tMZWFmKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMubmlsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe6oum7keagkeeahOmAkuW9kuafpeaJvueul+azlVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgZmluZChkYXRhKXtcbiAgICAgICAgbGV0IHogPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiBmaW5kKHosIGRhdGEpe1xuICAgICAgICAgICAgaWYoeiA9PSBtZS5uaWwgfHwgZGF0YSA9PT0gei5kYXRhKSByZXR1cm4gejtcblxuICAgICAgICAgICAgaWYoZGF0YSA8IHouZGF0YSkgcmV0dXJuIGZpbmQoei5sZWZ0Q2hpbGQsIGRhdGEpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmluZCh6LnJpZ2h0Q2hpbGQsIGRhdGEpO1xuICAgICAgICB9KSh6LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnuqLpu5HmoJHnmoTmj5LlhaVcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKi9cbiAgICBhZGQoZGF0YSl7XG4gICAgICAgIGxldCB6ID0gbmV3IFJlZEJsYWNrTm9kZShkYXRhKTtcbiAgICAgICAgei5sZWZ0Q2hpbGQgPSB0aGlzLm5pbDtcbiAgICAgICAgei5yaWdodENoaWxkID0gdGhpcy5uaWw7XG4gICAgICAgIGxldCB5ID0gdGhpcy5uaWw7XG4gICAgICAgIGxldCB4ID0gdGhpcy5yb290O1xuXG4gICAgICAgIC8vIOaJvuWIsOimgeaPkuWFpeS9jee9rueahOe7k+eCuXlcbiAgICAgICAgd2hpbGUoeCAhPSB0aGlzLm5pbCl7XG4gICAgICAgICAgICB5ID0geDtcblxuICAgICAgICAgICAgaWYoei5kYXRhIDwgeC5kYXRhKSB4ID0geC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICBlbHNlIHggPSB4LnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICB6LnBhcmVudCA9IHk7XG5cbiAgICAgICAgLy8g5aaC5p6ceeS4jeaYr+aguee7k+eCue+8jOagueaNruWkp+Wwj+aPkuWFpeWIsOW3puaIluWPs+WtkOagkVxuICAgICAgICBpZih5ICE9IHRoaXMubmlsKSB7XG4gICAgICAgICAgICBpZih6LmRhdGEgPCB5LmRhdGEpIHkubGVmdENoaWxkID0gejtcbiAgICAgICAgICAgIGVsc2UgeS5yaWdodENoaWxkID0gejtcbiAgICAgICAgfVxuICAgICAgICAvLyDlkKbliJnmj5LlhaXliLDmoLnnu5PngrlcbiAgICAgICAgZWxzZSB0aGlzLnJvb3QgPSB6ID09IHRoaXMubmlsID8gbnVsbCA6IHo7XG5cbiAgICAgICAgLy8g5o+S5YWl5L+u5aSN5pON5L2cXG4gICAgICAgIHRoaXMuX2FkZEZpeHVwKHopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaPkuWFpeeul+azleS/ruWkjVxuICAgICAqIEBwYXJhbSB7UmVkQmxhY2tOb2RlfSB6IOW+heaPkuWFpeeahOe7k+eCuVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEZpeHVwKHope1xuXG4gICAgICAgIHdoaWxlKHogIT0gdGhpcy5yb290ICYmIHoucGFyZW50LmNvbG9yID09PSBSRUQpe1xuICAgICAgICAgICAgaWYoei5wYXJlbnQgPT0gei5wYXJlbnQucGFyZW50LmxlZnRDaGlsZClcbiAgICAgICAgICAgICAgICBsZWZ0QWRkRml4dXAodGhpcywgeik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmlnaHRBZGRGaXh1cCh0aGlzLCB6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOacgOWQju+8jOaKiuaguee7k+eCuea2guS4uum7keiJsu+8jOaVtOajtee6oum7keagkeS+v+mHjeaWsOaBouWkjeS6huW5s+ihoVxuICAgICAgICB0aGlzLnJvb3QuY29sb3IgPSBCTEFDSztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnuqLpu5HmoJHnmoTliKDpmaTnrpfms5VcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0geiDlvoXliKDpmaTnu5PngrlcbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKHope1xuICAgICAgICBsZXQgeCwgeTtcblxuICAgICAgICAvLyDmib7liLDlvoXliKDpmaTnu5PngrnnmoTniLbnu5PngrnmiJbnm7jpgrvlvoXmm7/mjaLnu5PngrlcbiAgICAgICAgaWYoei5sZWZ0Q2hpbGQgPT0gdGhpcy5uaWwgfHwgei5yaWdodENoaWxkID09IHRoaXMubmlsKVxuICAgICAgICAgICAgeSA9IHo7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHkgPSB0aGlzLnN1Y2Nlc3Nvcih6KTtcblxuICAgICAgICBpZih5LmxlZnRDaGlsZCAhPSB0aGlzLm5pbCkgeCA9IHkubGVmdENoaWxkO1xuICAgICAgICBlbHNlIHggPSB5LnJpZ2h0Q2hpbGQ7XG5cbiAgICAgICAgeC5wYXJlbnQgPSB5LnBhcmVudDtcblxuICAgICAgICAvLyDliKDpmaTmk43kvZxcbiAgICAgICAgaWYoeS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHg7XG4gICAgICAgIGVsc2UgaWYoeSA9PSB5LnBhcmVudC5sZWZ0Q2hpbGQpIHkucGFyZW50LmxlZnRDaGlsZCA9IHg7XG4gICAgICAgIGVsc2UgeS5wYXJlbnQucmlnaHRDaGlsZCA9IHg7XG5cbiAgICAgICAgaWYoeSAhPSB6KSB6LmRhdGEgPSB5LmRhdGE7XG5cbiAgICAgICAgLy8g5Yig6Zmk5L+u5aSNXG4gICAgICAgIGlmKHkuY29sb3IgPT09IEJMQUNLKSB0aGlzLl9yZW1vdmVGaXh1cCh4KTtcbiAgICB9XG5cbiAgICAvLyDnrpfms5Xlr7zorrrkuIrnmoTliKDpmaTnu5PngrlcbiAgICByZW1vdmVOb2RlMih6KXtcbiAgICAgICAgbGV0IHkgPSB6O1xuICAgICAgICBsZXQgb3JpZ2luYWxZQ29sb3IgPSB5LmNvbG9yO1xuICAgICAgICBsZXQgeDtcblxuICAgICAgICBpZih6LmxlZnRDaGlsZCA9PSB0aGlzLm5pbCkge1xuICAgICAgICAgICAgeCA9IHoucmlnaHRDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeiwgei5yaWdodENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmKHoucmlnaHRDaGlsZCA9PSB0aGlzLm5pbCkge1xuICAgICAgICAgICAgeCA9IHoubGVmdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwbGFudCh6LCB6LmxlZnRDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5taW4oei5yaWdodENoaWxkKTtcbiAgICAgICAgICAgIG9yaWdpbmFsWUNvbG9yID0geS5jb2xvcjtcbiAgICAgICAgICAgIHggPSB5LnJpZ2h0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGlmKHkucGFyZW50ID09IHopIHgucGFyZW50ID0geTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeSwgeS5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICB5LnJpZ2h0Q2hpbGQgPSB6LnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgeS5yaWdodENoaWxkLnBhcmVudCA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeiwgeSk7XG4gICAgICAgICAgICB5LmxlZnRDaGlsZCA9IHoubGVmdENoaWxkO1xuICAgICAgICAgICAgeS5sZWZ0Q2hpbGQucGFyZW50ID0geTtcbiAgICAgICAgICAgIHkuY29sb3IgPSB6LmNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob3JpZ2luYWxZQ29sb3IgPT09IEJMQUNLKSB0aGlzLl9yZW1vdmVGaXh1cCh4KTtcbiAgICB9XG5cbiAgICBfdHJhbnNwbGFudCh1LCB2KXtcbiAgICAgICAgaWYodS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHY7XG4gICAgICAgIGVsc2UgaWYodSA9PSB1LnBhcmVudC5sZWZ0Q2hpbGQpIHUucGFyZW50LmxlZnRDaGlsZCA9IHY7XG4gICAgICAgIGVsc2UgdS5wYXJlbnQucmlnaHRDaGlsZCA9IHY7XG5cbiAgICAgICAgdi5wYXJlbnQgPSB1LnBhcmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliKDpmaTkv67lpI1cbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0gelxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUZpeHVwKHope1xuICAgICAgICB3aGlsZSh6ICE9PSB0aGlzLnJvb3QgJiYgei5jb2xvciA9PT0gQkxBQ0spe1xuICAgICAgICAgICAgaWYoeiA9PSB6LnBhcmVudC5sZWZ0Q2hpbGQpXG4gICAgICAgICAgICAgICAgbGVmdFJlbW92ZUZpeHVwKHRoaXMsIHopO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJpZ2h0UmVtb3ZlRml4dXAodGhpcywgeik7XG4gICAgICAgIH1cblxuICAgICAgICB6LmNvbG9yID0gQkxBQ0s7XG4gICAgfVxuXG4gICAgc3VjY2Vzc29yKHope1xuICAgICAgICBpZih6LnJpZ2h0Q2hpbGQgIT0gdGhpcy5uaWwpIHJldHVybiB0aGlzLm1pbih6LnJpZ2h0Q2hpbGQpO1xuXG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUoeSAhPSB0aGlzLm5pbCAmJiB6ID09IHkucmlnaHRDaGlsZCl7XG4gICAgICAgICAgICB6ID0geTtcbiAgICAgICAgICAgIHkgPSB5LnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cblxuICAgIG1pbih6KXtcbiAgICAgICAgd2hpbGUoei5sZWZ0Q2hpbGQgIT0gdGhpcy5uaWwpe1xuICAgICAgICAgICAgeiA9IHoubGVmdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5qC55o2ua2V55YC85Yig6Zmk57uT54K5XG4gICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KXtcbiAgICAgICAgbGV0IHogPSB0aGlzLmZpbmQoa2V5KTtcblxuICAgICAgICBpZih6ID09IHRoaXMubmlsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTm9kZSh6KTtcbiAgICB9XG59XG5cblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZUxlZnQgPSByb3RhdGUoJ2xlZnQnKTtcblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gcm90YXRlKCdyaWdodCcpO1xuXG5mdW5jdGlvbiByb3RhdGUoZGlyKXtcbiAgICBsZXQgYzEsIGMyO1xuICAgIGlmKCBkaXIgPT09ICdsZWZ0Jykge1xuICAgICAgICBjMSA9ICdyaWdodENoaWxkJztcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjMSA9ICdsZWZ0Q2hpbGQnO1xuICAgICAgICBjMiA9ICdyaWdodENoaWxkJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeCl7XG4gICAgICAgIGxldCB5ID0geFtjMV07XG4gICAgICAgIHhbYzFdID0geVtjMl07XG5cbiAgICAgICAgaWYoeVtjMl0gIT0gdGhpcy5uaWwpIHlbYzJdLnBhcmVudCA9IHg7XG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XG5cbiAgICAgICAgaWYoeC5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHk7XG4gICAgICAgIGVsc2UgaWYoeCA9PSB4LnBhcmVudFtjMl0pIHgucGFyZW50W2MyXSA9IHk7XG4gICAgICAgIGVsc2UgeC5wYXJlbnRbYzFdID0geTtcblxuICAgICAgICB5W2MyXSA9IHg7XG4gICAgICAgIHgucGFyZW50ID0geTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhZGRGaXh1cChkaXIpe1xuICAgIGxldCBjMSwgYzIsIHJvdGF0ZTEsIHJvdGF0ZTI7XG4gICAgaWYoIGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICBjMiA9ICdsZWZ0Q2hpbGQnO1xuICAgICAgICByb3RhdGUxID0gJ19yb3RhdGVMZWZ0JztcbiAgICAgICAgcm90YXRlMiA9ICdfcm90YXRlUmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICByb3RhdGUxID0gJ19yb3RhdGVSaWdodCc7XG4gICAgICAgIHJvdGF0ZTIgPSAnX3JvdGF0ZUxlZnQnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbih0cmVlLCB6KXtcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XG5cbiAgICAgICAgLy8g5Y+U57uT54K5XG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQucGFyZW50W2MxXTtcblxuICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUx77ya5aaC5p6c5b2T5YmN57uT54K555qE54i257uT54K55piv57qi6Imy5LiU56WW54i257uT54K555qE5Y+m5LiA5Liq5a2Q57uT54K577yI5Y+U57uT54K577yJ5piv57qi6ImyXG4gICAgICAgIC8vIOWwhuW9k+WJjeiKgueCueeahOeItuiKgueCueWSjOWPlOWPlOiKgueCuea2gum7ke+8jOellueItue7k+eCuea2gue6ou+8jOaKiuW9k+WJjee7k+eCueaMh+WQkeellueItuiKgueCue+8jOS7juaWsOeahOW9k+WJjeiKgueCuemHjeaWsOW8gOWni+eul+azleOAglxuICAgICAgICBpZih5LmNvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICB5LmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICB6LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XG4gICAgICAgICAgICB6ID0gei5wYXJlbnQucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g5o+S5YWl5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueeahOeItuiKgueCueaYr+e6ouiJsizlj5ToioLngrnmmK/pu5HoibLvvIzlvZPliY3oioLngrnmmK/lhbbniLboioLngrnnmoTlj7PlrZBcbiAgICAgICAgICAgIC8vIOino+WGs+WvueetluaYr++8muW9k+WJjeiKgueCueeahOeItuiKgueCueWBmuS4uuaWsOeahOW9k+WJjeiKgueCue+8jOS7peaWsOW9k+WJjeiKgueCueS4uuaUr+eCueW3puaXi+OAglxuICAgICAgICAgICAgLy8g5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcbiAgICAgICAgICAgIGlmKHogPT09IHoucGFyZW50W2MxXSkge1xuICAgICAgICAgICAgICAgIHogPSB6LnBhcmVudDtcbiAgICAgICAgICAgICAgICB0cmVlW3JvdGF0ZTFdKHopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxuICAgICAgICAgICAgLy8g6Kej5Yaz5a+5562W5piv77ya54i26IqC54K55Y+Y5Li66buR6Imy77yM56WW54i26IqC54K55Y+Y5Li657qi6Imy77yM5Zyo56WW54i26IqC54K55Li65pSv54K55Y+z5peL77yMXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xuICAgICAgICAgICAgei5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgdHJlZVtyb3RhdGUyXSh6LnBhcmVudC5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubGV0IGxlZnRBZGRGaXh1cCA9IGFkZEZpeHVwKCdsZWZ0Jyk7XG5sZXQgcmlnaHRBZGRGaXh1cCA9IGFkZEZpeHVwKCdyaWdodCcpO1xubGV0IGxlZnRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdsZWZ0Jyk7XG5sZXQgcmlnaHRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdyaWdodCcpO1xuXG5mdW5jdGlvbiByZW1vdmVGaXh1cChkaXIpe1xuICAgIGxldCBjMSwgYzIsIHIxLCByMjtcbiAgICBpZihkaXIgPT09ICdsZWZ0Jykge1xuICAgICAgICBjMSA9ICdyaWdodENoaWxkJztcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcbiAgICAgICAgcjEgPSAnX3JvdGF0ZUxlZnQnO1xuICAgICAgICByMiA9ICdfcm90YXRlUmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICByMSA9ICdfcm90YXRlUmlnaHQnO1xuICAgICAgICByMiA9ICdfcm90YXRlTGVmdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRyZWUsIHope1xuICAgICAgICAvLyBub3RlOiDms6jph4rku6Xlt6bovrnkuLrmg4XlhrVcblxuICAgICAgICAvLyDlj5Tnu5PngrlcbiAgICAgICAgbGV0IHcgPSB6LnBhcmVudFtjMV07XG5cbiAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKeOAglxuICAgICAgICAvLyDop6Pms5XvvJrmiorniLboioLngrnmn5PmiJDnuqLoibLvvIzmiorlhYTlvJ/nu5Pngrnmn5PmiJDpu5HoibLvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5VcbiAgICAgICAgaWYody5jb2xvciA9PT0gUkVEKXtcbiAgICAgICAgICAgIHcuY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgdHJlZVtyMV0oei5wYXJlbnQpO1xuICAgICAgICAgICAgdyA9IHoucGFyZW50W2MxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibLjgIJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK5b2T5YmN6IqC54K55ZKM5YWE5byf6IqC54K55Lit5oq95Y+W5LiA6YeN6buR6Imy6L+95Yqg5Yiw54i26IqC54K55LiK77yM5oqK54i26IqC54K55b2T5oiQ5paw55qE5b2T5YmN6IqC54K577yM6YeN5paw6L+b5YWl566X5rOV44CCXG4gICAgICAgIGlmKHdbYzJdLmNvbG9yID09PSBCTEFDSyAmJiB3W2MxXS5jb2xvciA9PT0gQkxBQ0spe1xuICAgICAgICAgICAgdy5jb2xvciA9IFJFRDtcbiAgICAgICAgICAgIHogPSB6LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Er6buR77yM5YWE5byf6IqC54K55piv6buR6Imy77yM5YWE5byf55qE5bem5a2Q5piv57qi6Imy77yM5Y+z5a2Q5piv6buR6Imy44CCXG4gICAgICAgICAgICAvLyDop6Pms5XvvJrmiorlhYTlvJ/nu5Pngrnmn5PnuqLvvIzlhYTlvJ/lt6blrZDoioLngrnmn5Ppu5HvvIzkuYvlkI7lho3lnKjlhYTlvJ/oioLngrnkuLrmlK/ngrnop6Plj7Pml4vvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5XjgIJcbiAgICAgICAgICAgIGlmKHdbYzFdLmNvbG9yID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIHdbYzJdLmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICAgICAgdy5jb2xvciA9IFJFRDtcbiAgICAgICAgICAgICAgICB0cmVlW3IyXSh3KTtcbiAgICAgICAgICAgICAgICB3ID0gei5wYXJlbnRbYzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrU077ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRLem7keiJsu+8jOWug+eahOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOS9huaYr+WFhOW8n+iKgueCueeahOWPs+WtkOaYr+e6ouiJsu+8jOWFhOW8n+iKgueCueW3puWtkOeahOminOiJsuS7u+aEj+OAglxuICAgICAgICAgICAgLy8g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXG4gICAgICAgICAgICB3LmNvbG9yID0gei5wYXJlbnQuY29sb3I7XG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xuICAgICAgICAgICAgd1tjMV0uY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHRyZWVbcjFdKHoucGFyZW50KTtcbiAgICAgICAgICAgIHogPSB0cmVlLnJvb3Q7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbmxldCB0ZXN0ID0gbmV3IFJlZEJsYWNrVHJlZSgpO1xudGVzdC5hZGQoMTMpO1xudGVzdC5hZGQoOCk7XG50ZXN0LmFkZCgxNyk7XG50ZXN0LmFkZCgxKTtcbnRlc3QuYWRkKDYpO1xudGVzdC5hZGQoMTEpO1xudGVzdC5hZGQoMTUpO1xudGVzdC5hZGQoMjIpO1xudGVzdC5hZGQoMjUpO1xudGVzdC5hZGQoMjcpO1xuXG50ZXN0LnJlbW92ZSgxMyk7XG50ZXN0LnJlbW92ZSg4KTtcbnRlc3QucmVtb3ZlKDE3KTtcbnRlc3QucmVtb3ZlKDEpO1xudGVzdC5yZW1vdmUoNik7XG50ZXN0LnJlbW92ZSgxMSk7XG50ZXN0LnJlbW92ZSgxNSk7XG50ZXN0LnJlbW92ZSgyMik7XG50ZXN0LnJlbW92ZSgyNSk7XG50ZXN0LnJlbW92ZSgyNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL1JlZEJsYWNrVHJlZS5qcyIsIi8qXG4g6Z2Z5oCB5qyh5LyY5p+l5om+5qCRXG5cbiDpgILlkIjlkITorrDlvZXnmoTmn6Xmib7mpoLnjofkuI3nrYnnmoTmg4XlhrVcblxuIOafpeaJvuaViOeOh+acgOmrmOWNs+W5s+Wdh+afpeaJvumVv+W6puacgOWwj++8jOaIkeS7rOWPr+S7pee7meWHuuacieW6j+ihqOWcqOmdnuetieamgueOh+aDheWGteS4i+W6lOmBteW+queahOS4pOS4quWOn+WIme+8mlxuIDHjgIHmnIDlhYjorr/pl67nmoTnu5PngrnlupTmmK/orr/pl67mpoLnjofmnIDlpKfnmoTnu5PngrnvvJtcbiAy44CB5q+P5qyh6K6/6Zeu5bqU5L2/57uT54K55Lik6L655bCa5pyq6K6/6Zeu55qE57uT54K555qE6KKr6K6/5qaC546H5LmL5ZKM5bC95Y+v6IO955u4562J44CCXG5cblxuIOi/meS4pOS4quWOn+WImeWPr+eUqOS4gOWPpeivneadpeihqOekuu+8jOWNs+WIpOWumuagkeS4uuW4puadg+WGhei3r+W+hOmVv+W6puS5i+WSjOacgOWwj+eahOS6jOWPieagke+8jOS6puWNs++8mlBIID0g4oiRd2loaSAg5pyA5bCP77yM5YW25LitIG4g5Li65pyJ5bqP6KGo6ZW/5bqm77yMaGkg5Li656ysIGkg5Liq57uT54K55Zyo5Yik5a6a5qCR5LiK55qE5bGC5qyh5pWw77yMd2kgPSBjcGnvvIxjIOS4uuafkOS4quW4uOaVsO+8jHBpIOS4uuesrCBpIOS4que7k+eCueeahOafpeaJvuamgueOh+OAglxuXG5cbiDov5nmoLfnmoTmoJHnp7DkuLrpnZnmgIHmnIDkvJjmn6Xmib7moJHvvIhzdGF0aWMgb3B0aW1hbCBzZWFyY2ggdHJlZe+8ie+8jOaehOmAoOi/meagt+S4gOajteagkeeahOaXtumXtOS7o+S7t+WkquWkp++8jOS6puWNs+aXtumXtOWkjeadguW6puW+iOWkp++8jOWboOatpOaIkeS7rOmAmuW4uOaYr+aehOmAoOasoeS8mOafpeaJvuagke+8iG5lYXJseSBvcHRpbWFsIHNlYXJjaCB0cmVl77yJ77yM5p6E6YCg5a6D55qE5pe26Ze05Luj5Lu36L+c6L+c5L2O5LqO5p6E6YCg5pyA5LyY5p+l5om+5qCR77yM5L2G5p+l5om+5oCn6IO95Y+q5q+U5pyA5LyY5p+l5om+5qCR5beuMSV+MiXvvIzlvojlsJHlt64zJeS7peS4iuOAglxuXG4g5qyh5LyY5p+l5om+5qCR55qE5p6E6YCg77yaXG5cbiDorr7mnInluo/ooajmr4/kuKrorrDlvZXnmoTmnYPlgLzkuLogd2wsd2wrMSzigKYsd2jvvIznrKzkuIDkuKrlupTorr/pl67nmoTnu5Pngrnlj7fkuLogaSDvvIzliJnmnInvvJpcbiDOlHBpID0gICDiiJF3aiAtIOKIkXdqICAg5pyA5bCP77yM5Y2zIM6UcGkgPSBNaW4ge86UcGogfVxuIOWGjeWIhuWIq+WvuSB7cmwscmwrMSzigKYscmktMX0g5ZKMIHtyaSsxLHJpKzIs4oCmLHJofSDliIbliKvmnoTpgKDmrKHkvJjmn6Xmib7moJFcbiAqL1xuaW1wb3J0IHsgQmluYXJ5VHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XG5cbi8qKlxuICog55Sx5pyJ5bqP6KGoc1RhYmxlW2xvdy4uaGlnaF3lj4rlhbbntK/orqHmnYPlgLzooah3ZWlnaHRz6YCS5b2S5p6E6YCg5qyh5LyY5p+l5om+5qCRXG4gKiBAcGFyYW0ge0JpbmFyeVRyZWV9IHRyZWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNUYWJsZVxuICogQHBhcmFtIHtBcnJheX0gc1dlaWdodHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmRPcHRpbWFsKHRyZWUsIHNUYWJsZSwgc1dlaWdodHMsIGxvdywgaGlnaCkge1xuICAgIGxldCBpID0gbG93O1xuICAgIGxldCBtaW4gPSBNYXRoLmFicyhzV2VpZ2h0c1toaWdoXSAtIHNXZWlnaHRzW2xvd10pO1xuICAgIGxldCBkdyA9IHNXZWlnaHRzW2hpZ2hdICsgKHNXZWlnaHRzW2xvdyAtIDFdIHx8IDApO1xuXG4gICAgLy8g6YCJ5oup5pyA5bCP55qE4pazUGnlgLxcbiAgICBmb3IgKGxldCBqID0gbG93ICsgMTsgaiA8PSBoaWdoOyArK2opIHtcbiAgICAgICAgbGV0IHQgPSBNYXRoLmFicyhkdyAtIHNXZWlnaHRzW2pdIC0gc1dlaWdodHNbaiAtIDFdKTtcbiAgICAgICAgaWYgKHQgPCBtaW4pIHtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgbWluID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOiwg+aVtOagkeagueadg++8jOmAieaLqemCu+i/keadg+WAvOi+g+Wkp+eahOWFs+mUruWtl1xuICAgIGxldCBhID0gMCwgYiwgYyA9IDA7XG4gICAgaWYgKGkgLSAxID49IGxvdykgIGIgPSBzV2VpZ2h0c1tpXSAtIHNXZWlnaHRzW2kgLSAxXTtcbiAgICBpZiAoaSAtIDIgPj0gbG93KSBhID0gc1dlaWdodHNbaSAtIDFdIC0gc1dlaWdodHNbaSAtIDJdO1xuICAgIGlmIChpICsgMSA8IGhpZ2gpIGMgPSBzV2VpZ2h0c1tpICsgMV0gLSBzV2VpZ2h0c1tpXTtcbiAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChhID4gYyAmJiBhID4gYikgLS1pO1xuICAgICAgICBlbHNlIGlmIChhIDwgYyAmJiBjID4gYikgICsraTtcbiAgICB9XG5cbiAgICB0cmVlLmRhdGEgPSBzVGFibGVbaV07XG4gICAgLy/lt6blrZDmoJFcbiAgICBpZiAoaSA9PT0gbG93KSB0cmVlLmxlZnRDaGlsZCA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICAgIHRyZWUubGVmdENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLmxlZnRDaGlsZCwgc1RhYmxlLCBzV2VpZ2h0cywgbG93LCBpIC0gMSk7XG4gICAgfVxuICAgIC8vIOWPs+WtkOagkVxuICAgIGlmIChpID09PSBoaWdoKSB0cmVlLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgICB0cmVlLnJpZ2h0Q2hpbGQgPSBuZXcgQmluYXJ5VHJlZSgpO1xuICAgICAgICBzZWNvbmRPcHRpbWFsKHRyZWUucmlnaHRDaGlsZCwgc1RhYmxlLCBzV2VpZ2h0cywgaSArIDEsIGhpZ2gpO1xuICAgIH1cbn1cblxubGV0IHRyZWUgPSBuZXcgQmluYXJ5VHJlZSgpO1xuc2Vjb25kT3B0aW1hbCh0cmVlLCBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJ10sIFsxLCAyLCA0LCA5LCAxMiwgMTYsIDIwLCAyMywgMjhdLCAwLCA4KTtcbmNvbnNvbGUubG9nKHRyZWUpO1xuXG5cbi8qKlxuICog55Sx5pyJ5bqP6KGo5p6E6YCg5LiA5qO15qyh5LyY5p+l5om+5qCRXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIOacieW6j+ihqO+8jOaVsOaNruWFg+e0oOWQq+acieadg+Wfn3dlaWdodFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU09TVHJlZShvYmopIHtcbiAgICBsZXQgdHJlZTtcbiAgICBpZiAob2JqLmVsZW1zLmxlbmd0aCA9PT0gMCkgdHJlZSA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIOaxgue0r+iuoeadg+WAvOihqFxuICAgICAgICBsZXQgc3cgPSBmaW5kU1cob2JqLndlaWdodHMpO1xuICAgICAgICB0cmVlID0gbmV3IEJpbmFyeVRyZWUoKTtcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLCBvYmouZWxlbXMsIHN3LCAwLCBvYmouZWxlbXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRTVyhzVGFibGUpIHtcbiAgICBsZXQgc3cgPSBbc1RhYmxlWzBdXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc1RhYmxlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3W2ldID0gc3dbaSAtIDFdICsgc1RhYmxlW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBzdztcbn1cblxubGV0IHNvc1RyZWUgPSBjcmVhdGVTT1NUcmVlKHtcbiAgICBlbGVtczogWydBJywgJ0InLCAnQycsICdEJywgJ0UnXSxcbiAgICB3ZWlnaHRzOiBbMSwgMzAsIDIsIDI5LCAzXVxufSk7XG5zb3NUcmVlLmluT3JkZXJSZWN1cnNpdmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coJ2luT3JkZXI6ICcgKyB2YWx1ZSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvU09TVHJlZS5qcyIsIi8qXG7lkI7nvIDmoJHnrpfmmK/lvojluLjop4HnmoTlrZfnrKbkuLLmlbDmja7nu5PmnoTkuYvkuIDkuobvvIzlroPlnKjmqKHlvI/ljLnphY3kuK3nmoTlupTnlKjpnZ7luLjlpJrvvIzmr5TlpoJETkHluo/liJfmo4DmtYvnrYnjgIJcblxu5ZCO57yA5qCR55qE5Z+65pys5oCd6Lev5piv5piv5a+55LiA5Liq5a2X56ym5Liy55qE5omA5pyJ5ZCO57yA5a2Q5Liy5LulVHJpZXPnmoTmlrnlvI/ov5vooYzmj4/ov7DvvIzku47ogIzlj6/ku6Xov4XpgJ/lnLDlnKjlkI7nvIDmoJHkuIrmib7lh7rlrZfnrKbkuLLnmoTku7vmhI/lrZDkuLLjgIJcblxu5omA5Lul5a+55LqO5bey57uP5bu656uL5LqG5ZCO57yA5qCR55qE5a2X56ym5Liy77yM5YGa5a2X56ym5Liy5p+l5om+5bey57uP566X5piv6Z2e5bi4566A5Y2V55qE5Lu75Yqh5LqG77yM5ZCM5pe255Sx5LqOVHJpZXPnmoTnibnngrnvvIzov5nnp43nu5PmnoTlj6/ku6Xlvojmlrnkvr/lnLDlpITnkIbliY0v5ZCO5Lu75oSP5a2X56ym5Liy5Yy56YWN77yI5q+U5aaC4oCcKkFCQ+KAneWSjOKAnEFCQyrigJ3vvInvvIzkuLrkuobopoHlpITnkIbkuK3pl7TnmoR3aWxkY2FyZO+8jOavlOWmgkFCQypERUbvvIzlj6/ku6XliIbliKvmn6Xmib5BQkMq5ZKMKkRFRu+8jOeEtuWQjuWGjeWPluS6pOmbhuWNs+WPr+OAglxuXG7lkI7nvIDmoJHkuZ/lvojpgILlkIjkuo7lpJrmqKHljLnphY3pl67popjvvIzkvYblroPpgILnlKjnmoTlnLrmma/kuLvopoHmmK/lvoXljLnphY3lrZfnrKbkuLLlm7rlrprvvIzogIzmqKHlvI/kuLLmnKrlrprnmoTlnLrmma/jgIJcblxu5LiA5Liq5Yip55So5ZCO57yA5qCR55qE5YW45Z6L5bqU55So5pivTENT77yITG9uZ2VzdCBDb21tb24gU3Vic3RyaW5n77yJ5pyA5aSn5YWs5YWx5a2Q5Liy6Zeu6aKY44CC6YeH55So5Yqo5oCB6KeE5YiS5Lmf5Y+v5Lul5b6I5a655piT5Zyw6Kej5YazTENT6Zeu6aKY77yM5L2G5a6D55qE5pe256m65aSN5p2C5bqm5Z2H5Li6TyhOKk0p77yM5a+55LqO5aSn5aSa5pWw5bqU55So5piv5aSf5LqG77yM5Y+v5piv77yM5aaC5p6c5Lik5Liq5a2X56ym5Liy5pivRE5B5bqP5YiX77yM6KaB5LuO5Lit6Ze05om+5Ye65YWs5YWx5a2Q5Liy77yMTyhOKk0p55qE5pe256m65aSN5p2C5bqm5pi+54S25piv5peg5rOV5o6l5Y+X55qE44CC6ICM6YeH55So5ZCO57yA5qCR77yM5aSN5p2C5bqm5bCx5Y+q5piv5ZCO57yA5qCR5Yib5bu655qE5aSN5p2C5bqm77yM5Y2zTyhOKVxuXG7lkI7nvIDmoJHnmoTlupTnlKhcblxuMS7mn6Xmib7lrZfnrKbkuLIgUGF0dGVybiDmmK/lkKblnKjkuo7lrZfnrKbkuLIgVGV4dCDkuK1cbiAgICDmlrnmoYjvvJrnlKggVGV4dCDmnoTpgKDlkI7nvIDmoJHvvIzmjInlnKggVHJpZSDkuK3mkJzntKLlrZfkuLLnmoTmlrnms5XmkJzntKIgUGF0dGVybiDljbPlj6/jgILoi6UgUGF0dGVybiDlnKggVGV4dCDkuK3vvIzliJkgUGF0dGVybiDlv4XnhLbmmK8gVGV4dCDnmoTmn5DkuKrlkI7nvIDnmoTliY3nvIDjgIJcbjIu6K6h566X5oyH5a6a5a2X56ym5LiyIFBhdHRlcm4g5Zyo5a2X56ym5LiyIFRleHQg5Lit55qE5Ye6546w5qyh5pWwXG4gICAg5pa55qGI77ya55SoIFRleHQrJyQnIOaehOmAoOWQjue8gOagke+8jOaQnOe0oiBQYXR0ZXJuIOaJgOWcqOiKgueCueS4i+eahOWPtuiKgueCueaVsOebruWNs+S4uumHjeWkjeasoeaVsOOAguWmguaenCBQYXR0ZXJuIOWcqCBUZXh0IOS4remHjeWkjeS6hiBjIOasoe+8jOWImSBUZXh0IOW6lOaciSBjIOS4quWQjue8gOS7pSBQYXR0ZXJuIOS4uuWJjee8gOOAglxuMy7mn6Xmib7lrZfnrKbkuLIgVGV4dCDkuK3nmoTmnIDplb/ph43lpI3lrZDkuLJcbiAgICDmlrnmoYjvvJrnlKggVGV4dCsnJCcg5p6E6YCg5ZCO57yA5qCR77yM5pCc57SiIFBhdHRlcm4g5omA5Zyo6IqC54K55LiL55qE5pyA5rex55qE6Z2e5Y+26IqC54K544CC5LuOIHJvb3Qg5Yiw6K+l6IqC54K55omA57uP5Y6G6L+H55qE5a2X56ym5Liy5bCx5piv5pyA6ZW/6YeN5aSN5a2Q5Liy44CCXG40LuafpeaJvuS4pOS4quWtl+espuS4siBUZXh0MSDlkowgVGV4dDIg55qE5pyA6ZW/5YWs5YWx6YOo5YiGXG4gICAg5pa55qGI77ya6L+e5o6lIFRleHQxKycjJyArIFRleHQyKyckJyDlvaLmiJDmlrDnmoTlrZfnrKbkuLLlubbmnoTpgKDlkI7nvIDmoJHvvIzmib7liLDmnIDmt7HnmoTpnZ7lj7boioLngrnvvIzkuJTor6XoioLngrnnmoTlj7boioLngrnml6LmnIkgJyMnIOS5n+aciSAnJCfjgIJcbjUu5p+l5om+57uZ5a6a5a2X56ym5LiyIFRleHQg6YeM55qE5pyA6ZW/5Zue5paHXG7lm57mlofmjIfvvJpcImFiY2RlZmdmZWRcIiDkuK3lr7nnp7DnmoTlrZfnrKbkuLIgXCJkZWZnZmVkXCLjgIJcbuWbnuaWh+WNiuW+hOaMh++8muWbnuaWhyBcImRlZmdmZWRcIiDnmoTlm57mlofljYrlvoQgXCJkZWZnXCIg6ZW/5bqm5Li6IDTvvIzljYrlvoTkuK3lv4PkuLrlrZfmr40gXCJnXCLjgIJcbiAgICDmlrnmoYjvvJrlsIYgVGV4dCDmlbTkvZPlj43ovazlvaLmiJDmlrDnmoTlrZfnrKbkuLIgVGV4dDLvvIzkvovlpoIgXCJhYmNkZWZnZmVkXCIgPT4gXCJkZWZnZmVkY2JhXCLjgILov57mjqUgVGV4dCsnIycgKyBUZXh0MisnJCcg5b2i5oiQ5paw55qE5a2X56ym5Liy5bm25p6E6YCg5ZCO57yA5qCR77yM54S25ZCO5bCG6Zeu6aKY6L2s5Y+Y5Li65p+l5om+IFRleHQg5ZKMIFRleHQxIOeahOacgOmVv+WFrOWFsemDqOWIhuOAglxuXG5odHRwOi8vd3d3LmNuYmxvZ3MuY29tL2dhb2NodW5kb25nL3Avc3VmZml4X3RyZWUuaHRtbFxuaHR0cDovL3ZpY2t5cWkuY29tLzIwMTUvMTEvMjcvJUU2JTk1JUIwJUU2JThEJUFFJUU3JUJCJTkzJUU2JTlFJTg0JUU3JUIzJUJCJUU1JTg4JTk3JUUyJTgwJTk0JUUyJTgwJTk0JUU1JTkwJThFJUU3JUJDJTgwJUU2JUEwJTkxSmF2YSVFNSVBRSU5RSVFNyU4RSVCMCVFNCVCQiVBMyVFNyVBMCU4MS9cbiovXG5cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIC8vIHRoZSBpbmRleCBvZiBhIG5vZGUgd2l0aCBhIG1hdGNoaW5nIHN1ZmZpeCwgcmVwcmVzZW50aW5nIGEgc3VmZml4IGxpbmsuXG4gICAgICAgIC8vIC0xIGluZGljYXRlcyB0aGlzIG5vZGUgaGFzIG5vIHN1ZmZpeCBsaW5rLlxuICAgICAgICB0aGlzLnN1ZmZpeE5vZGUgPSAtMTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpe1xuICAgICAgICByZXR1cm4gYE5vZGUoc3VmZml4IGxpbms6ICR7IHRoaXMuc3VmZml4Tm9kZSB9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBFZGdlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEVkZ2UuXG4gICAgICogQHBhcmFtIHthbnl9IGZpcnN0Q2hhckluZGV4ICBpbmRleCBvZiBzdGFydCBvZiBzdHJpbmcgcGFydCByZXByZXNlbnRlZCBieSB0aGlzIGVkZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gbGFzdENoYXJJbmRleCBpbmRleCBvZiBlbmQgb2Ygc3RyaW5nIHBhcnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBlZGdlXG4gICAgICogQHBhcmFtIHthbnl9IHNvdXJjZU5vZGVJbmRleCBuZGV4IG9mIHNvdXJjZSBub2RlIG9mIGVkZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gZGVzdE5vZGVJbmRleCBpbmRleCBvZiBkZXN0aW5hdGlvbiBub2RlIG9mIGVkZ2VcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgRWRnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpcnN0Q2hhckluZGV4LCBsYXN0Q2hhckluZGV4LCBzb3VyY2VOb2RlSW5kZXgsIGRlc3ROb2RlSW5kZXgpe1xuICAgICAgICB0aGlzLmZpcnN0Q2hhckluZGV4ID0gZmlyc3RDaGFySW5kZXg7XG4gICAgICAgIHRoaXMubGFzdENoYXJJbmRleCA9IGxhc3RDaGFySW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZUluZGV4ID0gc291cmNlTm9kZUluZGV4O1xuICAgICAgICB0aGlzLmRlc3ROb2RlSW5kZXggPSBkZXN0Tm9kZUluZGV4O1xuICAgIH1cblxuICAgIGdldCBsZW5ndGggKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDaGFySW5kZXggLSB0aGlzLmZpcnN0Q2hhckluZGV4O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCl7XG4gICAgICAgIHJldHVybiBgRWRnZSgke3RoaXMuc291cmNlTm9kZUluZGV4fSwgJHt0aGlzLmRlc3ROb2RlSW5kZXh9LCAke3RoaXMuZmlyc3RDaGFySW5kZXh9LCAke3RoaXMubGFzdENoYXJJbmRleH0pYDtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWZmaXggZnJvbSBmaXJzdF9jaGFyX2luZGV4IHRvIGxhc3RfY2hhcl9pbmRleC5cbiAqIFxuICogQGNsYXNzIFN1ZmZpeFxuICovXG5jbGFzcyBTdWZmaXgge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3VmZml4LlxuICAgICAqIEBwYXJhbSB7YW55fSBzb3VyY2VOb2RlSW5kZXggaW5kZXggb2Ygbm9kZSB3aGVyZSB0aGlzIHN1ZmZpeCBzdGFydHNcbiAgICAgKiBAcGFyYW0ge2FueX0gZmlyc3RDaGFySW5kZXggaW5kZXggb2Ygc3RhcnQgb2Ygc3VmZml4IGluIHN0cmluZ1xuXG4gICAgICogQHBhcmFtIHthbnl9IGxhc3RDaGFySW5kZXggaW5kZXggb2YgZW5kIG9mIHN1ZmZpeCBpbiBzdHJpbmdcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc291cmNlTm9kZUluZGV4LCBmaXJzdENoYXJJbmRleCwgbGFzdENoYXJJbmRleCl7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZUluZGV4ID0gc291cmNlTm9kZUluZGV4O1xuICAgICAgICB0aGlzLmZpcnN0Q2hhckluZGV4ID0gZmlyc3RDaGFySW5kZXg7XG4gICAgICAgIHRoaXMubGFzdENoYXJJbmRleCA9IGxhc3RDaGFySW5kZXg7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2hhckluZGV4IC0gdGhpcy5maXJzdENoYXJJbmRleDtcbiAgICB9XG5cbiAgICBnZXQgZXhwbGljaXQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RDaGFySW5kZXggPiB0aGlzLmxhc3RDaGFySW5kZXhcbiAgICB9XG5cbiAgICBnZXQgaW1wbGljaXQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENoYXJJbmRleCA+PSB0aGlzLmZpcnN0Q2hhckluZGV4O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHN1ZmZpeCB0cmVlIGZvciBzdHJpbmcgbWF0Y2hpbmcuIFVzZXMgVWtrb25lbidzIGFsZ29yaXRobVxuICAgIGZvciBjb25zdHJ1Y3Rpb24uXG4gKiBcbiAqIEBjbGFzcyBTdWZmaXhUcmVlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1ZmZpeFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgY2FzZUluc2Vuc2l0aXZlKXtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gY2FzZUluc2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLk4gPSBzdHJpbmcubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtuZXcgTm9kZSgpXTtcbiAgICAgICAgdGhpcy5lZGdlcyA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBTdWZmaXgoMCwgMCwgLTEpO1xuXG4gICAgICAgIGlmKGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5hZGRQcmVmaXgoaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0cyBlZGdlcyBpbiB0aGUgc3VmZml4IHRyZWVcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4VHJlZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLk47XG4gICAgICAgIGxldCBzID0gYFxcdFN0YXJ0IFxcdEVuZCBcXHRTdWYgXFx0Rmlyc3QgXFx0TGFzdCBcXHRTdHJpbmdcXG5gO1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmVkZ2VzKTtcbiAgICAgICAgdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEuZmlyc3RDaGFySW5kZXggLSBiLmZpcnN0Q2hhckluZGV4KTtcblxuICAgICAgICBmb3IobGV0IGVkZ2Ugb2YgdmFsdWVzKXtcbiAgICAgICAgICAgIGlmKGVkZ2Uuc291cmNlTm9kZUluZGV4ID09PSAtMSkgY29udGludWU7XG5cbiAgICAgICAgICAgIHMgKz0gYFxcdCR7ZWRnZS5zb3VyY2VOb2RlSW5kZXh9IFxcdCR7ZWRnZS5kZXN0Tm9kZUluZGV4fSBcXHQke3RoaXMubm9kZXNbZWRnZS5kZXN0Tm9kZUluZGV4XS5zdWZmaXhOb2RlfSBcXHQke2VkZ2UuZmlyc3RDaGFySW5kZXh9IFxcdCR7ZWRnZS5sYXN0Q2hhckluZGV4fSBcXHRgO1xuXG4gICAgICAgICAgICBsZXQgdG9wID0gTWF0aC5taW4oY3VycmVudEluZGV4LCBlZGdlLmxhc3RDaGFySW5kZXgpO1xuICAgICAgICAgICAgcyArPSB0aGlzLnN0cmluZy5zdWJzdHJpbmcoZWRnZS5maXJzdENoYXJJbmRleCwgdG9wICsgMSkgKyAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb3JlIGNvbnN0cnVjdGlvbiBtZXRob2QuXG4gICAgICogXG4gICAgICogQHBhcmFtIHthbnl9IGxhc3RDaGFySW5kZXggXG4gICAgICogXG4gICAgICogQG1lbWJlck9mIFN1ZmZpeFRyZWVcbiAgICAgKi9cbiAgICBhZGRQcmVmaXgobGFzdENoYXJJbmRleCl7XG4gICAgICAgIGxldCBsYXN0UGFyZW50Tm9kZSA9IC0xO1xuICAgICAgICBsZXQgZSA9IG51bGw7XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gLTE7XG5cbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gdGhpcy5hY3RpdmUuc291cmNlTm9kZUluZGV4O1xuXG4gICAgICAgICAgICBpZih0aGlzLmFjdGl2ZS5leHBsaWNpdCl7XG4gICAgICAgICAgICAgICAgLy8gcHJlZml4IGlzIGFscmVhZHkgaW4gdHJlZVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWRnZXNbYCR7dGhpcy5hY3RpdmUuc291cmNlTm9kZUluZGV4fS0ke3RoaXMuc3RyaW5nW2xhc3RDaGFySW5kZXhdfWBdKSBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZSA9IHRoaXMuZWRnZXNbYCR7dGhpcy5hY3RpdmUuc291cmNlTm9kZUluZGV4fS0ke3RoaXMuc3RyaW5nW3RoaXMuYWN0aXZlLmZpcnN0Q2hhckluZGV4XX1gXTtcblxuICAgICAgICAgICAgICAgIC8vIHByZWZpeCBpcyBhbHJlYWR5IGluIHRyZWVcbiAgICAgICAgICAgICAgICBpZih0aGlzLnN0cmluZ1tlLmZpcnN0Q2hhckluZGV4ICsgdGhpcy5hY3RpdmUubGVuZ3RoKyAxXSA9PT0gdGhpcy5zdHJpbmdbbGFzdENoYXJJbmRleF0pIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHRoaXMuX3NwbGl0RWRnZShlLCB0aGlzLmFjdGl2ZSk7O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGUoKSk7XG4gICAgICAgICAgICBlID0gbmV3IEVkZ2UobGFzdENoYXJJbmRleCwgdGhpcy5OLCBwYXJlbnROb2RlLCB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0RWRnZShlKTtcblxuICAgICAgICAgICAgaWYobGFzdFBhcmVudE5vZGUgPiAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2xhc3RQYXJlbnROb2RlXS5zdWZmaXhOb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RQYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYodGhpcy5hY3RpdmUuc291cmNlTm9kZUluZGV4ID09PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5maXJzdENoYXJJbmRleCArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3VyY2VOb2RlSW5kZXggPSB0aGlzLm5vZGVzW3RoaXMuYWN0aXZlLnNvdXJjZU5vZGVJbmRleF0uc3VmZml4Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2Fub25pemVTdWZmaXgodGhpcy5hY3RpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobGFzdFBhcmVudE5vZGUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2xhc3RQYXJlbnROb2RlXS5zdWZmaXhOb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlLmxhc3RDaGFySW5kZXggKz0gMTtcbiAgICAgICAgdGhpcy5fY2Fub25pemVTdWZmaXgodGhpcy5hY3RpdmUpO1xuICAgIH1cblxuICAgIF9pbnNlcnRFZGdlKGVkZ2Upe1xuICAgICAgICB0aGlzLmVkZ2VzW2Ake2VkZ2Uuc291cmNlTm9kZUluZGV4fS0ke3RoaXMuc3RyaW5nW2VkZ2UuZmlyc3RDaGFySW5kZXhdfWBdID0gZWRnZTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlRWRnZShlZGdlKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuZWRnZXNbYCR7ZWRnZS5zb3VyY2VOb2RlSW5kZXh9LSR7dGhpcy5zdHJpbmdbZWRnZS5maXJzdENoYXJJbmRleF19YF07XG4gICAgfVxuXG4gICAgX3NwbGl0RWRnZShlZGdlLCBzdWZmaXgpe1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGUoKSk7XG4gICAgICAgIGxldCBlID0gbmV3IEVkZ2UoZWRnZS5maXJzdENoYXJJbmRleCwgZWRnZS5maXJzdENoYXJJbmRleCArIHN1ZmZpeC5sZW5ndGgsIHN1ZmZpeC5zb3VyY2VOb2RlSW5kZXgsIHRoaXMubm9kZXMubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRWRnZShlZGdlKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0RWRnZShlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG5lZWQgdG8gYWRkIG5vZGUgZm9yIGVhY2ggZWRnZVxuICAgICAgICB0aGlzLm5vZGVzW2UuZGVzdE5vZGVJbmRleF0uc3VmZml4Tm9kZSA9IHN1ZmZpeC5zb3VyY2VOb2RlSW5kZXg7XG4gICAgICAgIGVkZ2UuZmlyc3RDaGFySW5kZXggKz0gc3VmZml4Lmxlbmd0aCArIDE7XG4gICAgICAgIGVkZ2Uuc291cmNlTm9kZUluZGV4ID0gZS5kZXN0Tm9kZUluZGV4O1xuXG4gICAgICAgIHRoaXMuX2luc2VydEVkZ2UoZWRnZSk7XG5cbiAgICAgICAgcmV0dXJuIGUuZGVzdE5vZGVJbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbm9uaXplcyB0aGUgc3VmZml4LCB3YWxraW5nIGFsb25nIGl0cyBzdWZmaXggc3RyaW5nIHVudGlsIGl0IFxuICAgICAgICBpcyBleHBsaWNpdCBvciB0aGVyZSBhcmUgbm8gbW9yZSBtYXRjaGVkIG5vZGVzXG4gICAgICogXG4gICAgICogQHBhcmFtIHthbnl9IHN1ZmZpeCBcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4VHJlZVxuICAgICAqL1xuICAgIF9jYW5vbml6ZVN1ZmZpeChzdWZmaXgpe1xuICAgICAgICBpZighc3VmZml4LmV4cGxpY2l0KXtcbiAgICAgICAgICAgIGxldCBlID0gdGhpcy5lZGdlc1tgJHtzdWZmaXguc291cmNlTm9kZUluZGV4fS0ke3RoaXMuc3RyaW5nW3N1ZmZpeC5maXJzdENoYXJJbmRleF19YF07XG4gICAgICAgICAgICBpZihlLmxlbmd0aCA8PSBzdWZmaXgubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBzdWZmaXguZmlyc3RDaGFySW5kZXggKz0gZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIHN1ZmZpeC5zb3VyY2VOb2RlSW5kZXggPSBlLmRlc3ROb2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2Fub25pemVTdWZmaXgoc3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHN1YnN0cmluZyBpbiBzdHJpbmcgb3IgLTEgaWYgaXRcbiAgICAgICAgaXMgbm90IGZvdW5kLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7YW55fSBzdWJzdHIgXG4gICAgICogXG4gICAgICogQG1lbWJlck9mIFN1ZmZpeFRyZWVcbiAgICAgKi9cbiAgICBmaW5kKHN1YnN0cil7XG4gICAgICAgIGlmKCFzdWJzdHIpIHJldHVybiAtMTtcblxuICAgICAgICBpZih0aGlzLmNhc2VJbnNlbnNpdGl2ZSkgc3Vic3RyID0gc3Vic3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gMDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgbG4gPSAwO1xuICAgICAgICBsZXQgZWRnZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUoaSA8IHN1YnN0ci5sZW5ndGgpe1xuICAgICAgICAgICAgZWRnZSA9IHRoaXMuZWRnZXNbYCR7Y3VycmVudE5vZGV9LSR7c3Vic3RyW2ldfWBdO1xuXG4gICAgICAgICAgICBpZighZWRnZSkgcmV0dXJuIC0xO1xuXG4gICAgICAgICAgICBsbiA9IE1hdGgubWluKGVkZ2UubGVuZ3RoICsgMSwgc3Vic3RyLmxlbmd0aCAtIGkpO1xuXG4gICAgICAgICAgICBpZihzdWJzdHIuc3Vic3RyaW5nKGksIGkgKyBsbikgIT09IHRoaXMuc3RyaW5nLnN1YnN0cmluZyhlZGdlLmZpcnN0Q2hhckluZGV4LCBlZGdlLmZpcnN0Q2hhckluZGV4ICsgbG4pKSByZXR1cm4gLTE7XG5cbiAgICAgICAgICAgIGkgKz0gZWRnZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBlZGdlLmRlc3ROb2RlSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRnZS5maXJzdENoYXJJbmRleCAtIHN1YnN0ci5sZW5ndGggKyBsbjtcbiAgICB9XG59XG5cbmxldCBzdHIgPSAnSSBuZWVkIHRvIGJlIHNlYXJjaGVkJztcbmxldCB0cmVlID0gbmV3IFN1ZmZpeFRyZWUoc3RyKTtcbmNvbnNvbGUubG9nKHRyZWUuZmluZCgnc2VhcicpKTtcbmNvbnNvbGUubG9nKHRyZWUgKyAnJyk7XG5cbmxldCB0cmVlMiA9IG5ldyBTdWZmaXhUcmVlKCdtaXNzaXNzaXBwaScpO1xuY29uc29sZS5sb2codHJlZTIgKyAnJyk7XG5jb25zb2xlLmxvZyh0cmVlMi5maW5kKCdwcCcpKTtcblxubGV0IHRyZWUzID0gbmV3IFN1ZmZpeFRyZWUoJ2FiY2FieGFiY2QnKTtcbmNvbnNvbGUubG9nKHRyZWUzICsgJycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NlYXJjaC9TdWZmaXhUcmVlLmpzIiwiLypcbiBGaWJvbmFjY2nmn6Xmib5cblxuIEZpYm9uYWNjaeafpeaJvuaWueazleaYr+agueaNrkZpYm9uYWNjaeaVsOWIl+eahOeJueeCueWvueafpeaJvuihqOi/m+ihjOWIhuWJsuOAgkZpYm9uYWNjaeaVsOWIl+eahOWumuS5ieaYr++8mlxuIEYoMCk9MO+8jEYoMSk9Me+8jEYoaik9RihqLTEpK0Yoai0yKSDjgIJcblxuIDEgIOafpeaJvuaAneaDs1xuIOiuvuafpeaJvuihqOS4reeahOiusOW9leaVsOavlOafkOS4qkZpYm9uYWNjaeaVsOWwjzHvvIzljbPorr5uPUYoaiktMeOAgueUqExvd+OAgUhpZ2jlkoxNaWTooajnpLrlvoXmn6Xmib7ljLrpl7TnmoTkuIvnlYzjgIHkuIrnlYzlkozliIblibLkvY3nva7vvIzliJ3lgLzkuLpMb3c9MO+8jEhpZ2g9biAtIDHjgIJcbiDikbQgICDlj5bliIblibLkvY3nva5NaWTvvJpNaWQ9RihqLTEpIO+8m1xuIOKRtSAgIOavlOi+g+WIhuWJsuS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcbiDikaAg55u4562J77yaIOafpeaJvuaIkOWKn++8m1xuIOKRoSAg5aSn5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5YmN5Y2K5q61KOWMuumXtOmVv+W6puS4ukYoai0xKS0xKe+8jOS/ruaUueS4iueVjOaMh+mSiO+8miBIaWdoPU1pZC0x77yM6L2s4pG0IO+8m1xuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q61KOWMuumXtOmVv+W6puS4ukYoai0yKS0xKe+8jOS/ruaUueS4i+eVjOaMh+mSiO+8mkxvdz1NaWQrMe+8jOi9rOKRtCDvvJvnm7TliLDotornlYwoTG93PkhpZ2gp77yM5p+l5om+5aSx6LSl44CCXG5cbiAyICDnrpfms5Xlrp7njrBcbiDlnKjnrpfms5Xlrp7njrDml7bvvIzkuLrkuobpgb/lhY3popHnuYHorqHnrpdGaWJvbmFjY2nmlbDvvIzlj6/nlKjkuKTkuKrlj5jph49mMeWSjGYy5L+d5a2Y5b2T5YmN55u46YK755qE5Lik5LiqRmlib25hY2Np5pWw77yM6L+Z5qC35Zyo5Lul5ZCO55qE6K6h566X5Lit5Y+v5Lul5L6d5qyh6YCS5o6o6K6h566X5Ye644CCXG5cbiAzICDnrpfms5XliIbmnpBcbiDnlLHnrpfms5Xnn6XvvIxGaWJvbmFjY2nmn6Xmib7lnKjmnIDlnY/mg4XlhrXkuIvmgKfog73mr5TmipjljYrmn6Xmib7lt67vvIzkvYblubPlnYfmkJzntKLmrKHmlbDlsJHkuo7mipjljYrmn6Xmib7vvIzogIzkuJTmipjljYrmn6Xmib7opoHmsYLorrDlvZXmjInlhbPplK7lrZfmnInluo/vvJtGaWJvbmFjY2nmn6Xmib7nmoTkvJjngrnmmK/liIblibLml7blj6rpnIDov5vooYzliqDjgIHlh4/ov5DnrpfjgIJcblxuICovXG5cbmZ1bmN0aW9uIGZpYihuKSB7XG4gICAgaWYgKG4gPT09IDApIHJldHVybiAwO1xuICAgIGlmIChuID09PSAxKSByZXR1cm4gMTtcbiAgICBsZXQgZjtcbiAgICBsZXQgZjAgPSAwO1xuICAgIGxldCBmMSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgIGYgPSBmMCArIGYxO1xuICAgICAgICBmMCA9IGYxO1xuICAgICAgICBmMSA9IGY7XG4gICAgfVxuICAgIHJldHVybiBmO1xufVxuXG4vKipcbiAqIOWcqOacieW6j+ihqFNU5Lit55SoRmlib25hY2Np5pa55rOV5p+l5om+5YWz6ZSu5a2X5Li6a2V555qE6K6w5b2VXG4gKiBAcGFyYW0gc1RhYmxlXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaWJvbmFjY2lTZWFyY2goc1RhYmxlLCBrZXksIG4gPSBzVGFibGUubGVuZ3RoKSB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBuIC0gMTtcbiAgICBsZXQgZjEgPSBmaWIobik7XG4gICAgbGV0IGYyID0gZmliKG4gLSAxKTtcblxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBsZXQgbWlkID0gbG93ICsgZjEgLSAxO1xuICAgICAgICBpZiAoc1RhYmxlW21pZF0gPT09IGtleSkgcmV0dXJuIG1pZDtcbiAgICAgICAgZWxzZSBpZiAoa2V5IDwgc1RhYmxlW21pZF0pIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICAgICAgZjIgPSBmMSAtIGYyO1xuICAgICAgICAgICAgZjEgPSBmMSAtIGYyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGYxID0gZjEgLSBmMjtcbiAgICAgICAgICAgIGYyID0gZjIgLSBmMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmNvbnNvbGUubG9nKCdmaWJvbmFjY2lTZWFyY2g6ICcpO1xuY29uc29sZS5sb2coZmlib25hY2NpU2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgNSkpOyAvLyA0XG5jb25zb2xlLmxvZyhmaWJvbmFjY2lTZWFyY2goWzEsIDIsIDMsIDQsIDVdLCA2KSk7IC8vIC0xXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaC5qcyIsIi8qXG4g6Z2Z5oCB5p+l5om+XG5cbiDnur/mgKfooajmmK/mn6Xmib7ooajmnIDnroDljZXnmoTkuIDnp43nu4Tnu4fmlrnlvI9cblxuIOmhuuW6j+afpeaJvihTZXF1ZW50aWFsIFNlYXJjaClcbiAxICDmn6Xmib7mgJ3mg7NcbiDku47ooajnmoTkuIDnq6/lvIDlp4vpgJDkuKrlsIborrDlvZXnmoTlhbPplK7lrZflkoznu5nlrppL5YC86L+b6KGM5q+U6L6D77yM6Iul5p+Q5Liq6K6w5b2V55qE5YWz6ZSu5a2X5ZKM57uZ5a6aS+WAvOebuOetie+8jOafpeaJvuaIkOWKn++8m+WQpuWIme+8jOiLpeaJq+aPj+WujOaVtOS4quihqO+8jOS7jeeEtuayoeacieaJvuWIsOebuOW6lOeahOiusOW9le+8jOWImeafpeaJvuWksei0peOAglxuXG4gMiAg566X5rOV5YiG5p6QXG4g5LiN5aSx5LiA6Iis5oCn77yM6K6+5p+l5om+5q+P5Liq6K6w5b2V5oiQ5Yqf55qE5qaC546H55u4562J77yM5Y2zUGk9MS9u77yb5p+l5om+56ysaeS4quWFg+e0oOaIkOWKn+eahOavlOi+g+asoeaVsENpPW4tae+8m1xuIOKXhiDmn6Xmib7miJDlip/ml7bnmoTlubPlnYfmn6Xmib7plb/luqZBU0zvvJoobisxKS8yXG4g4peGIOWMheWQq+afpeaJvuS4jeaIkOWKn+aXtu+8muafpeaJvuWksei0peeahOavlOi+g+asoeaVsOS4um7vvIzoi6XmiJDlip/kuI7kuI3miJDlip/nmoTmpoLnjofnm7jnrYnvvIzlr7nmr4/kuKrorrDlvZXnmoTmn6Xmib7mpoLnjofkuLpQaT0xLygybinvvIzliJnlubPlnYfmn6Xmib7plb/luqZBU0zvvJoz77yIbisx77yJLzRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXF1ZW50aWFsU2VhcmNoKHNUYWJsZSwga2V5KSB7XG4gICAgZm9yICh2YXIgaSA9IHNUYWJsZS5sZW5ndGggLSAxOyBpID49IDAgJiYgc1RhYmxlW2ldICE9PSBrZXk7IC0taSk7XG4gICAgcmV0dXJuIGk7XG59XG5cbmNvbnNvbGUubG9nKHNlcXVlbnRpYWxTZWFyY2goWzEsIDIsIDMsIDQsIDVdLCA2KSk7ICAvLyAtMVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoLmpzIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGxkcCBvbiAyMDE1LzIvMTguXG4gKi9cblxuaW1wb3J0IHsgcXVpY2tTb3J0IH0gZnJvbSAnLi4vZXhjaGFuZ2UvaW5kZXgnO1xuXG4vKlxuIOiuoeaVsOaOkuW6j1xuXG4g6K6h5pWw5o6S5bqP77yIQ291bnRpbmcgc29ydO+8ieaYr+S4gOenjeeos+WumueahOe6v+aAp+aXtumXtOaOkuW6j+eul+azleOAguiuoeaVsOaOkuW6j+S9v+eUqOS4gOS4qumineWklueahOaVsOe7hEPvvIzlhbbkuK3nrKxp5Liq5YWD57Sg5piv5b6F5o6S5bqP5pWw57uEQeS4reWAvOetieS6jmnnmoTlhYPntKDnmoTkuKrmlbDjgILnhLblkI7moLnmja7mlbDnu4RD5p2l5bCGQeS4reeahOWFg+e0oOaOkuWIsOato+ehrueahOS9jee9ruOAglxuXG4g6K6h5pWw5o6S5bqP55qE54m55b6BXG5cbiDlvZPovpPlhaXnmoTlhYPntKDmmK9u5LiqMOWIsGvkuYvpl7TnmoTmlbTmlbDml7bvvIzlroPnmoTov5DooYzml7bpl7TmmK/OmChuICsgaynjgILorqHmlbDmjpLluo/kuI3mmK/mr5TovoPmjpLluo/vvIzmjpLluo/nmoTpgJ/luqblv6vkuo7ku7vkvZXmr5TovoPmjpLluo/nrpfms5XjgIJcbiDnlLHkuo7nlKjmnaXorqHmlbDnmoTmlbDnu4RD55qE6ZW/5bqm5Y+W5Yaz5LqO5b6F5o6S5bqP5pWw57uE5Lit5pWw5o2u55qE6IyD5Zu077yI562J5LqO5b6F5o6S5bqP5pWw57uE55qE5pyA5aSn5YC85LiO5pyA5bCP5YC855qE5beu5Yqg5LiKMe+8ie+8jOi/meS9v+W+l+iuoeaVsOaOkuW6j+WvueS6juaVsOaNruiMg+WbtOW+iOWkp+eahOaVsOe7hO+8jOmcgOimgeWkp+mHj+aXtumXtOWSjOWGheWtmOOAguS+i+Wmgu+8muiuoeaVsOaOkuW6j+aYr+eUqOadpeaOkuW6jzDliLAxMDDkuYvpl7TnmoTmlbDlrZfnmoTmnIDlpb3nmoTnrpfms5XvvIzkvYbmmK/lroPkuI3pgILlkIjmjInlrZfmr43pobrluo/mjpLluo/kurrlkI3jgILkvYbmmK/vvIzorqHmlbDmjpLluo/lj6/ku6XnlKjlnKjln7rmlbDmjpLluo/kuK3nmoTnrpfms5XmnaXmjpLluo/mlbDmja7ojIPlm7TlvojlpKfnmoTmlbDnu4TjgIJcbiDpgJrkv5flnLDnkIbop6PvvIzkvovlpoLmnIkxMOS4quW5tOm+hOS4jeWQjOeahOS6uu+8jOe7n+iuoeWHuuaciTjkuKrkurrnmoTlubTpvoTmr5RB5bCP77yM6YKjQeeahOW5tOm+hOWwseaOkuWcqOesrDnkvY3vvIznlKjov5nkuKrmlrnms5Xlj6/ku6XlvpfliLDlhbbku5bmr4/kuKrkurrnmoTkvY3nva7vvIzkuZ/lsLHmjpLlpb3kuobluo/jgILlvZPnhLbvvIzlubTpvoTmnInph43lpI3ml7bpnIDopoHnibnmrorlpITnkIbvvIjkv53or4HnqLPlrprmgKfvvInvvIzov5nlsLHmmK/kuLrku4DkuYjmnIDlkI7opoHlj43lkJHloavlhYXnm67moIfmlbDnu4TvvIzku6Xlj4rlsIbmr4/kuKrmlbDlrZfnmoTnu5/orqHlh4/ljrsx55qE5Y6f5Zug44CC566X5rOV55qE5q2l6aqk5aaC5LiL77yaXG4gMS7mib7lh7rlvoXmjpLluo/nmoTmlbDnu4TkuK3mnIDlpKflkozmnIDlsI/nmoTlhYPntKBcbiAyLue7n+iuoeaVsOe7hOS4reavj+S4quWAvOS4umnnmoTlhYPntKDlh7rnjrDnmoTmrKHmlbDvvIzlrZjlhaXmlbDnu4RD55qE56ysaemhuVxuIDMu5a+55omA5pyJ55qE6K6h5pWw57Sv5Yqg77yI5LuOQ+S4reeahOesrOS4gOS4quWFg+e0oOW8gOWni++8jOavj+S4gOmhueWSjOWJjeS4gOmhueebuOWKoO+8iVxuIDQu5Y+N5ZCR5aGr5YWF55uu5qCH5pWw57uE77ya5bCG5q+P5Liq5YWD57SgaeaUvuWcqOaWsOaVsOe7hOeahOesrEMoaSnpobnvvIzmr4/mlL7kuIDkuKrlhYPntKDlsLHlsIZDKGkp5YeP5Y67MVxuIFxuIOeugOimgeWIhuaekO+8mlxuIDEu6K6h5pWw5o6S5bqP5LuF6YCC5ZCI5LqO5bCP6IyD5Zu055qE5pWw5o2u6L+b6KGM5o6S5bqPXG4gMi7kuI3og73lr7nmta7ngrnmlbDov5vooYzmjpLluo9cbiAzLuaXtumXtOWkjeadguW6puS4uiBPKG4pXG4gNC7orqHmlbDmjpLluo/mmK/nqLPlrprnmoTvvIjmjpLluo/lkI7lgLznm7jlkIznmoTlhYPntKDnm7jlr7nkuo7ljp/lhYjnmoTkvY3nva7mmK/kuI3kvJrlj5HnlJ/lj5jljJbnmoTvvIlcbiAqL1xuXG5mdW5jdGlvbiBtYXhFbGVtKGFycil7XG4gICAgbGV0IG1heCA9IGFyclswXTtcblxuICAgIGZvcihsZXQgaSA9IDEsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47ICsraSlcbiAgICAgICAgaWYobWF4IDwgYXJyW2ldKSBtYXggPSBhcnJbaV07XG5cbiAgICByZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzcUxpc3Qg6KaB5o6S5bqP55qE5pWw57uEXG4gKiBAcGFyYW0ge051bWJlcn0gayDmlbDnu4TkuK3mnIDlpKfnmoTlhYPntKDlgLxcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50U29ydChzcUxpc3QgPSBbXSwgayA9IG1heEVsZW0oc3FMaXN0KSl7XG4gICAgbGV0IGxlbiA9IHNxTGlzdC5sZW5ndGg7XG4gICAgbGV0IGMgPSBbXTtcbiAgICBsZXQgYiA9IFtdO1xuXG4gICAgLy8g5Yid5aeL5YyW6L6F5Yqp5pWw57uEXG4gICAgZm9yKGxldCBpID0gMDsgaSA8PSBrOyArK2kpIGNbaV0gPSAwO1xuICAgIC8vIOiuoeaVsOaVsOe7hEHkuK3lgLznrYnkuo5D5pWw57uE5LiL5qCH55qE5Liq5pWwXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSBjW3NxTGlzdFtpXV0rKztcbiAgICAvLyDorqHmlbDmlbDnu4RB5Lit5YC85bCP5LqO562J5LqOQ+aVsOe7hOS4i+agh+eahOS4quaVsFxuICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gazsgKytpKSBjW2ldICs9IGNbaSAtIDFdO1xuICAgIGZvcihsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGJbY1tzcUxpc3RbaV1dIC0gMV0gPSBzcUxpc3RbaV07XG4gICAgICAgIC0tY1tzcUxpc3RbaV1dO1xuICAgIH1cblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkgc3FMaXN0W2ldID0gYltpXTtcbn1cblxudmFyIGFyciA9IFsxMDAsIDkzLCA5NywgOTIsIDk2LCA5OSwgOTIsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIsIDk1XTtcbmNvdW50U29ydChhcnIsIDEwMCk7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuLypcbiDln7rmlbDmjpLluo9cblxuIOWfuuaVsOaOkuW6j++8iOiLseivre+8mlJhZGl4IHNvcnTvvInmmK/kuIDnp43pnZ7mr5TovoPlnovmlbTmlbDmjpLluo/nrpfms5XvvIzlhbbljp/nkIbmmK/lsIbmlbTmlbDmjInkvY3mlbDliIflibLmiJDkuI3lkIznmoTmlbDlrZfvvIznhLblkI7mjInmr4/kuKrkvY3mlbDliIbliKvmr5TovoPjgILnlLHkuo7mlbTmlbDkuZ/lj6/ku6Xooajovr7lrZfnrKbkuLLvvIjmr5TlpoLlkI3lrZfmiJbml6XmnJ/vvInlkoznibnlrprmoLzlvI/nmoTmta7ngrnmlbDvvIzmiYDku6Xln7rmlbDmjpLluo/kuZ/kuI3mmK/lj6rog73kvb/nlKjkuo7mlbTmlbDjgILln7rmlbDmjpLluo/nmoTlj5HmmI7lj6/ku6Xov73muq/liLAxODg35bm06LWr5bCU5pu8wrfkvZXkuZDnpLzlnKjmiZPlrZTljaHniYfliLbooajmnLrvvIhUYWJ1bGF0aW9uIE1hY2hpbmXvvInkuIrnmoTotKHnjK7jgIJcbiDlroPmmK/ov5nmoLflrp7njrDnmoTvvJrlsIbmiYDmnInlvoXmr5TovoPmlbDlgLzvvIjmraPmlbTmlbDvvInnu5/kuIDkuLrlkIzmoLfnmoTmlbDkvY3plb/luqbvvIzmlbDkvY3ovoPnn63nmoTmlbDliY3pnaLooaXpm7bjgILnhLblkI7vvIzku47mnIDkvY7kvY3lvIDlp4vvvIzkvp3mrKHov5vooYzkuIDmrKHmjpLluo/jgILov5nmoLfku47mnIDkvY7kvY3mjpLluo/kuIDnm7TliLDmnIDpq5jkvY3mjpLluo/lrozmiJDku6XlkI7vvIzmlbDliJflsLHlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcbiDln7rmlbDmjpLluo/nmoTmlrnlvI/lj6/ku6Xph4fnlKhMU0TvvIhMZWFzdCBzaWduaWZpY2FudCBkaWdpdGFs77yJ5oiWTVNE77yITW9zdCBzaWduaWZpY2FudCBkaWdpdGFs77yJ77yMTFNE55qE5o6S5bqP5pa55byP55Sx6ZSu5YC855qE5pyA5Y+z6L655byA5aeL77yM6ICMTVNE5YiZ55u45Y+N77yM55Sx6ZSu5YC855qE5pyA5bem6L655byA5aeL44CCXG5cbiDmlYjnjodcblxuIOWfuuaVsOaOkuW6j+eahOaXtumXtOWkjeadguW6puaYr08oa8K3binvvIzlhbbkuK1u5piv5o6S5bqP5YWD57Sg5Liq5pWw77yMa+aYr+aVsOWtl+S9jeaVsOOAguazqOaEj+i/meS4jeaYr+ivtOi/meS4quaXtumXtOWkjeadguW6puS4gOWumuS8mOS6jk8obsK3bG9nKG4pKe+8jGvnmoTlpKflsI/lj5blhrPkuo7mlbDlrZfkvY3nmoTpgInmi6nvvIjmr5TlpoLmr5TnibnkvY3mlbDvvInvvIzlkozlvoXmjpLluo/mlbDmja7miYDlsZ7mlbDmja7nsbvlnovnmoTlhajpm4bnmoTlpKflsI/vvJtr5Yaz5a6a5LqG6L+b6KGM5aSa5bCR6L2u5aSE55CG77yM6ICMbuaYr+avj+i9ruWkhOeQhueahOaTjeS9nOaVsOebruOAglxuIOS7peaOkuW6j27kuKrkuI3lkIzmlbTmlbDmnaXkuL7kvovvvIzlgYflrprov5nkupvmlbTmlbDku6VC5Li65bqV77yM6L+Z5qC35q+P5L2N5pWw6YO95pyJQuS4quS4jeWQjOeahOaVsOWtl++8jGsgPSBsb2dCKE4p77yMTuaYr+W+heaOkuW6j+aVsOaNruexu+Wei+WFqOmbhueahOWKv+OAguiZveeEtuaciULkuKrkuI3lkIznmoTmlbDlrZfvvIzpnIDopoFC5Liq5LiN5ZCM55qE5qG277yM5L2G5Zyo5q+P5LiA6L2u5aSE55CG5Lit77yM5Yik5pat5q+P5Liq5b6F5o6S5bqP5pWw5o2u6aG55Y+q6ZyA6KaB5LiA5qyh6K6h566X56Gu5a6a5a+55bqU5pWw5L2N55qE5YC877yM5Zug5q2k5Zyo5q+P5LiA6L2u5aSE55CG55qE5pe25YCZ6YO96ZyA6KaB5bmz5Z2HbuasoeaTjeS9nOadpeaKiuaVtOaVsOaUvuWIsOWQiOmAgueahOahtuS4reWOu++8jOaJgOS7peWwseacie+8mlxuIGvnuqbnrYnkuo5sb2dCKE4pXG4g5omA5Lul77yM5Z+65pWw5o6S5bqP55qE5bmz5Z2H5pe26Ze0VOWwseaYr++8mlxuIFTvvZ49IGxvZ0IoTinCt25cbiDlhbbkuK3liY3kuIDpobnmmK/kuIDkuKrkuI7ovpPlhaXmlbDmja7ml6DlhbPnmoTluLjmlbDvvIzlvZPnhLbor6XpobnkuI3kuIDlrprlsI/kuo5sb2duXG4g5aaC5p6c6ICD6JmR5ZKM5q+U6L6D5o6S5bqP6L+b6KGM5a+554Wn77yM5Z+65pWw5o6S5bqP55qE5b2i5byP5aSN5p2C5bqm6Jm954S25LiN5LiA5a6a5pu05bCP77yM5L2G55Sx5LqO5LiN6L+b6KGM5q+U6L6D77yM5Zug5q2k5YW25Z+65pys5pON5L2c55qE5Luj5Lu36L6D5bCP77yM6ICM5LiU5Zyo6YCC5b2T6YCJ5oup55qEQuS5i+S4i++8jGvkuIDoiKzkuI3lpKfkuo5sb2du77yM5omA5Lul5Z+65pWw5o6S5bqP5LiA6Iis6KaB5b+r6L+H5Z+65LqO5q+U6L6D55qE5o6S5bqP77yM5q+U5aaC5b+r6YCf5o6S5bqP44CCXG5cbiDlgYforr7miJHku6zmnInkuIDkupvkuozlhYPnu4QoYSxiKe+8jOimgeWvueWug+S7rOi/m+ihjOS7pWHkuLrpppbopoHlhbPplK7lrZfvvIxi55qE5qyh6KaB5YWz6ZSu5a2X55qE5o6S5bqP44CC5oiR5Lus5Y+v5Lul5YWI5oqK5a6D5Lus5YWI5oyJ54Wn6aaW6KaB5YWz6ZSu5a2X5o6S5bqP77yM5YiG5oiQ6aaW6KaB5YWz6ZSu5a2X55u45ZCM55qE6Iul5bmy5aCG44CC54S25ZCO77yM5Zyo5oyJ54Wn5qyh6KaB5YWz6ZSu5YC85YiG5Yir5a+55q+P5LiA5aCG6L+b6KGM5Y2V54us5o6S5bqP44CC5pyA5ZCO5YaN5oqK6L+Z5Lqb5aCG5Liy6L+e5Yiw5LiA6LW377yM5L2/6aaW6KaB5YWz6ZSu5a2X6L6D5bCP55qE5LiA5aCG5o6S5Zyo5LiK6Z2i44CC5oyJ6L+Z56eN5pa55byP55qE5Z+65pWw5o6S5bqP56ew5Li6TVNEKE1vc3QgU2lnbmlmaWNhbnQgRGlnaHQp5o6S5bqP44CC56ys5LqM56eN5pa55byP5piv5LuO5pyA5L2O5pyJ5pWI5YWz6ZSu5a2X5byA5aeL5o6S5bqP77yM56ew5Li6TFNEKExlYXN0IFNpZ25pZmljYW50IERpZ2h0KeaOkuW6j+OAgummluWFiOWvueaJgOacieeahOaVsOaNruaMieeFp+asoeimgeWFs+mUruWtl+aOkuW6j++8jOeEtuWQjuWvueaJgOacieeahOaVsOaNruaMieeFp+mmluimgeWFs+mUruWtl+aOkuW6j+OAguimgeazqOaEj+eahOaYr++8jOS9v+eUqOeahOaOkuW6j+eul+azleW/hemhu+aYr+eos+WumueahO+8jOWQpuWImeWwseS8muWPlua2iOWJjeS4gOasoeaOkuW6j+eahOe7k+aenOOAgueUseS6juS4jemcgOimgeWIhuWghuWvueavj+WghuWNleeLrOaOkuW6j++8jExTROaWueazleW+gOW+gOavlE1TROeugOWNleiAjOW8gOmUgOWwj+OAguS4i+aWh+S7i+e7jeeahOaWueazleWFqOmDqOaYr+WfuuS6jkxTROeahOOAglxuXG4g5Z+65pWw5o6S5bqP55qE566A5Y2V5o+P6L+w5bCx5piv5bCG5pWw5a2X5ouG5YiG5Li65Liq5L2N5Y2B5L2N55m+5L2N77yM5q+P5Liq5L2N5L6d5qyh5o6S5bqP44CC5Zug5Li66L+Z5a+5566X5rOV56iz5a6a6KaB5rGC6auY77yM5omA5Lul5oiR5Lus5a+55pWw5L2N5o6S5bqP55So5Yiw5LiK5LiA5Liq5o6S5bqP5pa55rOV6K6h5pWw5o6S5bqP44CC5Zug5Li65Z+65pWw5o6S5bqP6KaB57uP6L+HZCAo5pWw5o2u6ZW/5bqmKeasoeaOkuW6j++8jCDmr4/mrKHkvb/nlKjorqHmlbDmjpLluo/vvIwg6K6h5pWw5o6S5bqP55qE5aSN5p2C5bqm5Li6IE9uKSwgIGQg55u45b2T5LqO5bi46YeP5ZKMTuaXoOWFs++8jOaJgOS7peWfuuaVsOaOkuW6j+S5n+aYryBPKG4p44CC5Z+65pWw5o6S5bqP6Jm954S25piv57q/5oCn5aSN5p2C5bqm77yMIOWNs+WvuW7kuKrmlbDlrZflpITnkIbkuoZu5qyh77yM5L2G5piv5q+P5LiA5qyh5Luj5Lu36YO95q+U6L6D6auY77yMIOiAjOS4lOS9v+eUqOiuoeaVsOaOkuW6j+eahOWfuuaVsOaOkuW6j+S4jeiDvei/m+ihjOWOn+WcsOaOkuW6j++8jOmcgOimgeabtOWkmueahOWGheWtmO+8jCDlubbkuJTlv6vpgJ/mjpLluo/lj6/og73mm7Tlpb3lnLDliKnnlKjnoazku7bnmoTnvJPlrZjvvIwg5omA5Lul5q+U6L6D6LW35p2l77yM5YOP5b+r6YCf5o6S5bqP6L+Z5Lqb5Y6f5Zyw5o6S5bqP566X5rOV5pu05Y+v5Y+W44CC5a+55LqO5LiA5Liq5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw77yM5oiR5Lus5Y+v5Lul5oqK5a6D55yL5L2c5LiA5Liq5aSa5YWD57uE77yM5LuO6auY5L2N5Yiw5L2O5L2N5YWz6ZSu5a2X6YeN6KaB56iL5bqm5L6d5qyh6YCS5YeP44CC5Y+v5Lul5L2/55So5Z+65pWw5o6S5bqP5a+55LiA5Lqb5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw5o6S5bqP44CCXG4gKi9cblxuLy8g5rGC5pWw5o2u55qE5pyA5aSn5L2N5pWwXG5mdW5jdGlvbiBtYXhCaXQoYXJyKXtcbiAgICBsZXQgZCA9IDE7XG4gICAgbGV0IHAgPSAxMDtcblxuICAgIGZvcihsZXQgaSA9IDAsIG4gPSBhcnIubGVuZ3RoOyBpIDwgbjsgKytpKXtcbiAgICAgICAgd2hpbGUoYXJyW2ldID49IHApe1xuICAgICAgICAgICAgcCAqPSAxMDtcbiAgICAgICAgICAgICsrZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFkaXhTb3J0KGFyciA9IFtdLCBkID0gbWF4Qml0KGFycikpe1xuICAgIGxldCBuID0gYXJyLmxlbmd0aDtcbiAgICBsZXQgdGVtcCA9IFtdO1xuICAgIC8vIOiuoeaVsOWZqFxuICAgIGxldCBjb3VudCA9IFtdO1xuICAgIGxldCByYWRpeCA9IDE7XG5cbiAgICAvLyDov5vooYxk5qyh5o6S5bqPXG4gICAgZm9yKGxldCBpID0gMTsgaSA8PSBkOyArK2kpe1xuICAgICAgICAvLyDmr4/mrKHliIbphY3liY3muIXnqbrorqHmlbDlmahcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IDEwOyArK2opXG4gICAgICAgICAgICBjb3VudFtqXSA9IDA7XG4gICAgICAgIC8vIOe7n+iuoeavj+S4quahtuS4reeahOiusOW9leaVsFxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbjsgKytqKXtcbiAgICAgICAgICAgIGxldCBrID0gTWF0aC5mbG9vcihhcnJbal0gLyByYWRpeCkgJSAxMDtcbiAgICAgICAgICAgICsrY291bnRba107XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBqID0gMTsgaiA8IDEwOyArK2opXG4gICAgICAgICAgICBjb3VudFtqXSArPSBjb3VudFtqIC0gMV07XG4gICAgICAgIC8vIOWwhuaJgOacieahtuS4reiusOW9leS+neasoeaUtumbhuWIsHRtcOS4rVxuICAgICAgICBmb3IobGV0IGogPSBuIC0gMTsgaiA+PSAwOyAtLWope1xuICAgICAgICAgICAgbGV0IGsgPSBNYXRoLmZsb29yKGFycltqXSAvIHJhZGl4KSAlIDEwO1xuICAgICAgICAgICAgdGVtcFstLWNvdW50W2tdXSA9IGFycltqXTtcbiAgICAgICAgfVxuICAgICAgICAvL+WwhuS4tOaXtuaVsOe7hOeahOWGheWuueWkjeWItuWIsGFycuS4rVxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbjsgKytqKVxuICAgICAgICAgICAgYXJyW2pdID0gdGVtcFtqXTtcblxuICAgICAgICByYWRpeCAqPSAxMDtcbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMTAwLCA5MywgOTcsIDkyLCA5NiwgOTksIDkyLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLCA5NV07XG5yYWRpeFNvcnQoYXJyLCAxMDApO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cblxuLypcbiDmobbmjpLluo9cblxuIOahtuaOkuW6j++8iEJ1Y2tldCBzb3J077yJ5oiW5omA6LCT55qE566x5o6S5bqP77yM5piv5LiA5Liq5o6S5bqP566X5rOV77yM5bel5L2c55qE5Y6f55CG5piv5bCG5pWw57uE5YiG5Yiw5pyJ6ZmQ5pWw6YeP55qE5qG25a2Q6YeM44CC5q+P5Liq5qG25a2Q5YaN5Liq5Yir5o6S5bqP77yI5pyJ5Y+v6IO95YaN5L2/55So5Yir55qE5o6S5bqP566X5rOV5oiW5piv5Lul6YCS5b2S5pa55byP57un57ut5L2/55So5qG25o6S5bqP6L+b6KGM5o6S5bqP77yJ44CC5qG25o6S5bqP5piv6bi95bei5o6S5bqP55qE5LiA56eN5b2S57qz57uT5p6c44CC5b2T6KaB6KKr5o6S5bqP55qE5pWw57uE5YaF55qE5pWw5YC85piv5Z2H5YyA5YiG6YWN55qE5pe25YCZ77yM5qG25o6S5bqP5L2/55So57q/5oCn5pe26Ze077yIzpgobinvvInjgILkvYbmobbmjpLluo/lubbkuI3mmK/mr5TovoPmjpLluo/vvIzku5bkuI3lj5fliLBPKG4gbG9nIG4p5LiL6ZmQ55qE5b2x5ZON44CCXG5cbiDln7rmnKzmgJ3mg7NcblxuIOWBh+iuvuacieS4gOe7hOmVv+W6puS4uk7nmoTlvoXmjpLlhbPplK7lrZfluo/liJdLWzEuLi4ubl3jgILpppblhYjlsIbov5nkuKrluo/liJfliJLliIbmiJBN5Liq55qE5a2Q5Yy66Ze0KOahtikg44CC54S25ZCO5Z+65LqO5p+Q56eN5pig5bCE5Ye95pWwIO+8jOWwhuW+heaOkuW6j+WIl+eahOWFs+mUruWtl2vmmKDlsITliLDnrKxp5Liq5qG25LitKOWNs+ahtuaVsOe7hELnmoTkuIvmoIcgaSkg77yM6YKj5LmI6K+l5YWz6ZSu5a2Xa+WwseS9nOS4ukJbaV3kuK3nmoTlhYPntKAo5q+P5Liq5qG2QltpXemDveaYr+S4gOe7hOWkp+Wwj+S4uk4vTeeahOW6j+WIlynjgILmjqXnnYDlr7nmr4/kuKrmobZCW2ld5Lit55qE5omA5pyJ5YWD57Sg6L+b6KGM5q+U6L6D5o6S5bqPKOWPr+S7peS9v+eUqOW/q+aOkinjgILnhLblkI7kvp3mrKHmnprkuL7ovpPlh7pCWzBdLi4uLkJbTV3kuK3nmoTlhajpg6jlhoXlrrnljbPmmK/kuIDkuKrmnInluo/luo/liJfjgIJcbiDlgYflpoLlvoXmjpLluo/liJdLPSB7NDnjgIEgMzgg44CBIDM144CBIDk3IOOAgSA3NuOAgSA3MyDjgIEgMjfjgIEgNDkgfeOAgui/meS6m+aVsOaNruWFqOmDqOWcqDHigJQxMDDkuYvpl7TjgILlm6DmraTmiJHku6zlrprliLYxMOS4quahtu+8jOeEtuWQjuehruWumuaYoOWwhOWHveaVsGYoayk9ay8xMOOAguWImeesrOS4gOS4quWFs+mUruWtlzQ55bCG5a6a5L2N5Yiw56ysNOS4quahtuS4rSg0OS8xMD00KeOAguS+neasoeWwhuaJgOacieWFs+mUruWtl+WFqOmDqOWghuWFpeahtuS4re+8jOW5tuWcqOavj+S4qumdnuepuueahOahtuS4rei/m+ihjOW/q+mAn+aOkuW6j+OAglxuXG4g5YiG5p6QXG5cbiDmobbmjpLluo/liKnnlKjlh73mlbDnmoTmmKDlsITlhbPns7vvvIzlh4/lsJHkuoblh6DkuY7miYDmnInnmoTmr5TovoPlt6XkvZzjgILlrp7pmYXkuIrvvIzmobbmjpLluo/nmoRmKGsp5YC855qE6K6h566X77yM5YW25L2c55So5bCx55u45b2T5LqO5b+r5o6S5Lit5YiS5YiG77yM5bey57uP5oqK5aSn6YeP5pWw5o2u5YiG5Ymy5oiQ5LqG5Z+65pys5pyJ5bqP55qE5pWw5o2u5Z2XKOahtinjgILnhLblkI7lj6rpnIDopoHlr7nmobbkuK3nmoTlsJHph4/mlbDmja7lgZrlhYjov5vnmoTmr5TovoPmjpLluo/ljbPlj6/jgIJcbiDlr7lO5Liq5YWz6ZSu5a2X6L+b6KGM5qG25o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5YiG5Li65Lik5Liq6YOo5YiG77yaXG4gICAgICgxKSDlvqrnjq/orqHnrpfmr4/kuKrlhbPplK7lrZfnmoTmobbmmKDlsITlh73mlbDvvIzov5nkuKrml7bpl7TlpI3mnYLluqbmmK9PKE4p44CCXG4gICAgICgyKSDliKnnlKjlhYjov5vnmoTmr5TovoPmjpLluo/nrpfms5Xlr7nmr4/kuKrmobblhoXnmoTmiYDmnInmlbDmja7ov5vooYzmjpLluo/vvIzlhbbml7bpl7TlpI3mnYLluqbkuLog4oiRIE8oTmkqbG9nTmkpIOOAguWFtuS4rU5pIOS4uuesrGnkuKrmobbnmoTmlbDmja7ph4/jgIJcbiDlvojmmL7nhLbvvIznrKwoMinpg6jliIbmmK/mobbmjpLluo/mgKfog73lpb3lnY/nmoTlhrPlrprlm6DntKDjgILlsL3ph4/lh4/lsJHmobblhoXmlbDmja7nmoTmlbDph4/mmK/mj5Dpq5jmlYjnjofnmoTllK/kuIDlip7ms5Uo5Zug5Li65Z+65LqO5q+U6L6D5o6S5bqP55qE5pyA5aW95bmz5Z2H5pe26Ze05aSN5p2C5bqm5Y+q6IO96L6+5YiwTyhOKmxvZ04p5LqGKeOAguWboOatpO+8jOaIkeS7rOmcgOimgeWwvemHj+WBmuWIsOS4i+mdouS4pOeCue+8mlxuICAgICAoMSkg5pig5bCE5Ye95pWwZihrKeiDveWkn+Wwhk7kuKrmlbDmja7lubPlnYfnmoTliIbphY3liLBN5Liq5qG25Lit77yM6L+Z5qC35q+P5Liq5qG25bCx5pyJW04vTV3kuKrmlbDmja7ph4/jgIJcbiAgICAgKDIpIOWwvemHj+eahOWinuWkp+ahtueahOaVsOmHj+OAguaegemZkOaDheWGteS4i+avj+S4quahtuWPquiDveW+l+WIsOS4gOS4quaVsOaNru+8jOi/meagt+WwseWujOWFqOmBv+W8gOS6huahtuWGheaVsOaNrueahOKAnOavlOi+g+KAneaOkuW6j+aTjeS9nOOAgiDlvZPnhLbvvIzlgZrliLDov5nkuIDngrnlvojkuI3lrrnmmJPvvIzmlbDmja7ph4/lt6jlpKfnmoTmg4XlhrXkuIvvvIxmKGsp5Ye95pWw5Lya5L2/5b6X5qG26ZuG5ZCI55qE5pWw6YeP5beo5aSn77yM56m66Ze05rWq6LS55Lil6YeN44CC6L+Z5bCx5piv5LiA5Liq5pe26Ze05Luj5Lu35ZKM56m66Ze05Luj5Lu355qE5p2D6KGh6Zeu6aKY5LqG44CCXG5cbiDlr7nkuo5O5Liq5b6F5o6S5pWw5o2u77yMTeS4quahtu+8jOW5s+Wdh+avj+S4quahtltOL01d5Liq5pWw5o2u55qE5qG25o6S5bqP5bmz5Z2H5pe26Ze05aSN5p2C5bqm5Li677yaXG4gTyhOKStPKE0qKE4vTSkqbG9nKE4vTSkpPU8oTitOKihsb2dOLWxvZ00pKT1PKE4rTipsb2dOLU4qbG9nTSlcbiDlvZNOPU3ml7bvvIzljbPmnoHpmZDmg4XlhrXkuIvmr4/kuKrmobblj6rmnInkuIDkuKrmlbDmja7ml7bjgILmobbmjpLluo/nmoTmnIDlpb3mlYjnjofog73lpJ/ovr7liLBPKE4p44CCXG5cbiDmgLvnu5PvvJog5qG25o6S5bqP55qE5bmz5Z2H5pe26Ze05aSN5p2C5bqm5Li657q/5oCn55qETyhOK0Mp77yM5YW25LitQz1OKihsb2dOLWxvZ00p44CC5aaC5p6c55u45a+55LqO5ZCM5qC355qETu+8jOahtuaVsOmHj03otorlpKfvvIzlhbbmlYjnjofotorpq5jvvIzmnIDlpb3nmoTml7bpl7TlpI3mnYLluqbovr7liLBPKE4p44CCIOW9k+eEtuahtuaOkuW6j+eahOepuumXtOWkjeadguW6piDkuLpPKE4rTSnvvIzlpoLmnpzovpPlhaXmlbDmja7pnZ7luLjlup7lpKfvvIzogIzmobbnmoTmlbDph4/kuZ/pnZ7luLjlpJrvvIzliJnnqbrpl7Tku6Pku7fml6DnlpHmmK/mmILotLXnmoTjgILmraTlpJbvvIzmobbmjpLluo/mmK/nqLPlrprnmoTjgIJcbiAqL1xuXG5jb25zdCBCVUNLRVRTTlVNID0gMTA7XG5cbmZ1bmN0aW9uIGJ1Y2tldFNvcnQoc3FMaXN0KXtcbiAgICBsZXQgIG4gPSBzcUxpc3QubGVuZ3RoO1xuICAgIGxldCBidWNrZXRBID0gW107XG4gICAgbGV0IGIgPSBbXTtcblxuICAgIC8vIOWIneWni+WMluahtlxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBCVUNLRVRTTlVNOyArK2kpe1xuICAgICAgICBiW2ldID0gW107XG4gICAgICAgIGJ1Y2tldEFbaV0gPSAwO1xuXG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBuOyArK2opXG4gICAgICAgICAgICBiW2ldW2pdID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgLy8g57uZ5qG25aGr6KOF5pWw5o2uXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG47ICsraSl7XG4gICAgICAgIGxldCBkYXRhID0gc3FMaXN0W2ldO1xuICAgICAgICAvLyBub3RvOiDov5nph4znmoTmmKDlsITlh73mlbDmmK/pkojlr7kxLTEwMOS5i+mXtOeahOWunuaVsFxuICAgICAgICBsZXQgYnVja2V0ID0gTWF0aC5mbG9vcihkYXRhIC8gQlVDS0VUU05VTSk7XG4gICAgICAgIGJbYnVja2V0XVtidWNrZXRBW2J1Y2tldF1dID0gZGF0YTtcbiAgICAgICAgKytidWNrZXRBW2J1Y2tldF07XG4gICAgfVxuXG4gICAgLy8g6ZKI5a+55q+P5Liq5qG26L+b6KGM5b+r6YCf5o6S5bqPXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSl7XG4gICAgICAgIGlmKGJ1Y2tldEFbaV0gIT09IDApIHtcbiAgICAgICAgICAgIHF1aWNrU29ydChiW2ldLCAwLCBidWNrZXRBW2ldIC0gMSk7XG4gICAgICAgICAgICAvL2ZvcihsZXQgaiA9IDE7IGogPCBidWNrZXRBW2ldOyArK2ope1xuICAgICAgICAgICAgLy8gICAgbGV0IHAgPSBiW2ldW2pdO1xuICAgICAgICAgICAgLy8gICAgbGV0IGs7XG4gICAgICAgICAgICAvLyAgICBmb3IoayA9IGogLSAxOyBrID49IDAgJiYgcCA8IGJbaV1ba107IC0tayl7XG4gICAgICAgICAgICAvLyAgICAgICAgYltpXVtrICsgMV0gPSBiW2ldW2tdO1xuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gICAgYltpXVtrICsgMV0gPSBwO1xuICAgICAgICAgICAgLy99XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKGIpO1xuICAgIC8vY29uc29sZS5sb2coYnVja2V0QSk7XG5cbiAgICAvLyDlpI3liLblm57ljrtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgQlVDS0VUU05VTTsgKytpKXtcbiAgICAgICAgaWYoYnVja2V0QVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGJ1Y2tldEFbaV07ICsrail7XG4gICAgICAgICAgICAgICAgc3FMaXN0W251bSsrXSA9IGJbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmJ1Y2tldFNvcnQgPSBidWNrZXRTb3J0O1xuXG52YXIgYXJyID0gWzUxLjIsIDkzLCAxLCA5Mi4yLCA4LCA5OS41LCA5Mi4wLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLjEsIDk1XTtcbmJ1Y2tldFNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxudmFyIGFyciA9IFs1MS4yLCA5MywgMSwgOTIuMiwgOCwgOTkuNSwgOTIuMCwgODksIDkzLCA5NywgOTAsIDk0LCA5Mi4xLCA5NSwgSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eV07XG5xdWlja1NvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKlxuIOaAp+iDveWIhuaekFxuIOW+iOaYjuaYvu+8jOWfuuaVsOaOkuW6j+eahOaAp+iDveavlOahtuaOkuW6j+imgeeVpeW3ruOAguavj+S4gOasoeWFs+mUruWtl+eahOahtuWIhumFjemDvemcgOimgU8oTinnmoTml7bpl7TlpI3mnYLluqbvvIzogIzkuJTliIbphY3kuYvlkI7lvpfliLDmlrDnmoTlhbPplK7lrZfluo/liJflj4jpnIDopoFPKE4p55qE5pe26Ze05aSN5p2C5bqm44CC5YGH5aaC5b6F5o6S5pWw5o2u5Y+v5Lul5YiG5Li6ZOS4quWFs+mUruWtl++8jOWImeWfuuaVsOaOkuW6j+eahOaXtumXtOWkjeadguW6puWwhuaYr08oZCoyTikg77yM5b2T54S2ZOimgei/nOi/nOWwj+S6jk7vvIzlm6DmraTln7rmnKzkuIrov5jmmK/nur/mgKfnuqfliKvnmoTjgILln7rmlbDmjpLluo/nmoTnqbrpl7TlpI3mnYLluqbkuLpPKE4rTSnvvIzlhbbkuK1N5Li65qG255qE5pWw6YeP44CC5LiA6Iis5p2l6K+0Tj4+Te+8jOWboOatpOmineWkluepuumXtOmcgOimgeWkp+amgk7kuKrlt6blj7PjgIJcbiDkvYbmmK/vvIzlr7nmr5TmobbmjpLluo/vvIzln7rmlbDmjpLluo/mr4/mrKHpnIDopoHnmoTmobbnmoTmlbDph4/lubbkuI3lpJrjgILogIzkuJTln7rmlbDmjpLluo/lh6DkuY7kuI3pnIDopoHku7vkvZXigJzmr5TovoPigJ3mk43kvZzvvIzogIzmobbmjpLluo/lnKjmobbnm7jlr7novoPlsJHnmoTmg4XlhrXkuIvvvIzmobblhoXlpJrkuKrmlbDmja7lv4Xpobvov5vooYzln7rkuo7mr5TovoPmk43kvZznmoTmjpLluo/jgILlm6DmraTvvIzlnKjlrp7pmYXlupTnlKjkuK3vvIzln7rmlbDmjpLluo/nmoTlupTnlKjojIPlm7Tmm7TliqDlub/ms5vjgIJcbiAqL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Tb3J0L2Rpc3RyaWJ1dGlvbi9pbmRleC5qcyIsIi8qKlxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTUvMi8yLlxuICovXG5cbmltcG9ydCBTdGF0aWNMaW5rZWRMaXN0IGZyb20gJy4uLy4uL0xpc3QvU3RhdGljTGlua2VkTGlzdCc7XG5pbXBvcnQgZGVmYXVsdENvbXBhcmUgZnJvbSAnLi4vZGVmYXVsdENvbXBhcmlzaW9uJztcblxuLypcbiDmj5LlhaXmjpLluo9cblxuIOmHh+eUqOeahOaYr+S7pSDigJznjqnmoaXniYzogIXigJ3nmoTmlrnms5XkuLrln7rnoYDnmoTjgILljbPlnKjogIPlr5/orrDlvZVSaeS5i+WJje+8jOiuvuS7peWJjeeahOaJgOacieiusOW9lVIxLCBSMiAs4oCmLiwgUmktMeW3suaOkuWlveW6j++8jOeEtuWQjuWwhlJp5o+S5YWl5Yiw5bey5o6S5aW95bqP55qE6K+46K6w5b2V55qE6YCC5b2T5L2N572uXG5cbiDmnIDln7rmnKznmoTmj5LlhaXmjpLluo/mmK/nm7TmjqXmj5LlhaXmjpLluo8oU3RyYWlnaHQgSW5zZXJ0aW9uIFNvcnQpIOOAglxuXG5cbiDnm7TmjqXmj5LlhaXmjpLluo9cblxuIDEgIOaOkuW6j+aAneaDs1xuIOWwhuW+heaOkuW6j+eahOiusOW9lVJp77yM5o+S5YWl5Yiw5bey5o6S5aW95bqP55qE6K6w5b2V6KGoUjEsIFIyICzigKYuLCBSaS0x5Lit77yM5b6X5Yiw5LiA5Liq5paw55qE44CB6K6w5b2V5pWw5aKe5YqgMeeahOacieW6j+ihqOOAgiDnm7TliLDmiYDmnInnmoTorrDlvZXpg73mj5LlhaXlrozkuLrmraLjgIJcbiDorr7lvoXmjpLluo/nmoTorrDlvZXpobrluo/lrZjmlL7lnKjmlbDnu4RSWzHigKZuXeS4re+8jOWcqOaOkuW6j+eahOafkOS4gOaXtuWIu++8jOWwhuiusOW9leW6j+WIl+WIhuaIkOS4pOmDqOWIhu+8mlxuIOKXhiBSWzHigKZpLTFd77ya5bey5o6S5aW95bqP55qE5pyJ5bqP6YOo5YiG77ybXG4g4peGIFJbaeKApm5d77ya5pyq5o6S5aW95bqP55qE5peg5bqP6YOo5YiG44CCXG4g5pi+54S277yM5Zyo5Yia5byA5aeL5o6S5bqP5pe277yMUlsxXeaYr+W3sue7j+aOkuWlveW6j+eahOOAglxuXG4gMi7nrpfms5Xlrp7njrBcblxuIDMu566X5rOV5YiG5p6QXG4g4pG0IOacgOWlveaDheWGte+8muiLpeW+heaOkuW6j+iusOW9leaMieWFs+mUruWtl+S7juWwj+WIsOWkp+aOkuWIlyjmraPluo8p77yM566X5rOV5Lit55qE5YaF5b6q546v5peg6aG75omn6KGM77yM5YiZ5LiA6Laf5o6S5bqP5pe277ya5YWz6ZSu5a2X5q+U6L6D5qyh5pWwMeasoe+8jOiusOW9leenu+WKqOasoeaVsDLmrKEoUltpXeKGklJbMF0sIFJbMF3ihpJSW2orMV0p44CCXG4g5YiZ5pW05Liq5o6S5bqP55qE5YWz6ZSu5a2X5q+U6L6D5qyh5pWw5ZKM6K6w5b2V56e75Yqo5qyh5pWw5YiG5Yir5piv77yaXG4g5q+U6L6D5qyh5pWw77yabiAtIDEgICAgICAgICAg56e75Yqo5qyh5pWw77yaIDIgKiAobiAtIDEpXG5cbiDikbUg5pyA5Z2P5oOF5Ya177ya6Iul5b6F5o6S5bqP6K6w5b2V5oyJ5YWz6ZSu5a2X5LuO5aSn5Yiw5bCP5o6S5YiXKOmAhuW6jynvvIzliJnkuIDotp/mjpLluo/ml7bvvJrnrpfms5XkuK3nmoTlhoXlvqrnjq/kvZPmiafooYxpLTHvvIzlhbPplK7lrZfmr5TovoPmrKHmlbBp5qyh77yM6K6w5b2V56e75Yqo5qyh5pWwaSsx44CCXG4g5YiZ5bCx5pW05Liq5o6S5bqP6ICM6KiA77yaXG4g5q+U6L6D5qyh5pWw77yaIChuIC0gMSkgKiAobiArIDEpIC8gMiAgICAg56e75Yqo5qyh5pWwOiAobiAtIDEpICogKG4gKyA0KSAvIDJcblxuIOS4gOiIrOWcsO+8jOiupOS4uuW+heaOkuW6j+eahOiusOW9leWPr+iDveWHuueOsOeahOWQhOenjeaOkuWIl+eahOamgueOh+ebuOWQjO+8jOWImeWPluS7peS4iuS4pOenjeaDheWGteeahOW5s+Wdh+WAvO+8jOS9nOS4uuaOkuW6j+eahOWFs+mUruWtl+avlOi+g+asoeaVsOWSjOiusOW9leenu+WKqOasoeaVsO+8jOe6puS4um4yLzTvvIzliJnlpI3mnYLluqbkuLpPKG4yKSDjgIJcblxuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmFpZ2h0SW5zZXJ0U29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8g6K6+572u5ZOo5YW1LCDlvZPorr7nva5zcUxpc3RbLTFdID0gc3FMaXN0W2ld5pe277yM57uP5rWL6K+V5pWI546H5pu05oWiXG4gICAgICAgIC8vIOWboOS4umpz6YeM6Z2i55qE5Y+Y6YeP5L2c55So5Z+f5Zyo5Ye95pWw5YaF55qEXG4gICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAvLyDmn6Xmib7mj5LlhaXkvY3nva7vvIzlubblsIborrDlvZXlkI7np7tcbiAgICAgICAgbGV0IGogPSBpIC0gMTtcbiAgICAgICAgZm9yKDsgaiA+PSAwICYmIGNvbXAodGVtcCwgc3FMaXN0W2pdKSA8IDA7IC0tailcbiAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSBzcUxpc3Rbal07XG5cbiAgICAgICAgLy8g5o+S5YWl5Yiw5q2j56Gu5L2N572uXG4gICAgICAgIHNxTGlzdFtqICsgMV0gPSB0ZW1wO1xuICAgIH1cbn1cblxudmFyIGEgPSBbNywgNCwgLTIsIDE5LCAxMywgNl07XG5zdHJhaWdodEluc2VydFNvcnQoYSk7XG5jb25zb2xlLmxvZyhhICsgJycpO1xuXG5cbi8qXG4g5YW25a6D5o+S5YWl5o6S5bqPXG5cbiAxICDmipjljYrmj5LlhaXmjpLluo9cbiDlvZPlsIblvoXmjpLluo/nmoTorrDlvZVSW2ldIOaPkuWFpeWIsOW3suaOkuWlveW6j+eahOiusOW9leWtkOihqFJbMeKApmktMV3kuK3ml7bvvIznlLHkuo5SMSwgUjIgLOKApiwgUmktMeW3suaOkuWlveW6j++8jOWImeafpeaJvuaPkuWFpeS9jee9ruWPr+S7peeUqOKAnOaKmOWNiuafpeaJvuKAneWunueOsO+8jOWImeebtOaOpeaPkuWFpeaOkuW6j+WwseWPmOaIkOS4uuaKmOWNiuaPkuWFpeaOkuW6j+OAglxuXG4g5LuO5pe26Ze05LiK5q+U6L6D77yM5oqY5Y2K5o+S5YWl5o6S5bqP5LuF5LuF5YeP5bCR5LqG5YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw77yM5Y205rKh5pyJ5YeP5bCR6K6w5b2V55qE56e75Yqo5qyh5pWw77yM5pWF5pe26Ze05aSN5p2C5bqm5LuN54S25Li6TyhuMikg44CCXG5cblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlJbnNlcnRTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gaSAtIDE7XG5cbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG5cbiAgICAgICAgICAgIGlmIChjb21wKHRlbXAsIHNxTGlzdFttaWRdKSA8IDApIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICAgICAgZWxzZSBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IGkgLSAxOyBqID49IGhpZ2ggKyAxOyAtLWopIHtcbiAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSBzcUxpc3Rbal07XG4gICAgICAgIH1cblxuICAgICAgICBzcUxpc3RbaGlnaCArIDFdID0gdGVtcDtcbiAgICB9XG59XG5cbnZhciBiID0gWzMwLCAxMywgNzAsIDg1LCAzOSwgNDIsIDYsIDIwXTtcbmJpbmFyeUluc2VydFNvcnQoYik7XG5jb25zb2xlLmxvZyhiICsgJycpO1xuXG5cbi8qXG4gMi3ot6/mj5LlhaXmjpLluo9cblxuIOaYr+WvueaKmOWNiuaPkuWFpeaOkuW6j+eahOaUuei/m++8jOS7peWHj+WwkeaOkuW6j+i/h+eoi+S4reenu+WKqOiusOW9leeahOasoeaVsOOAgumZhOWKoG7kuKrorrDlvZXnmoTovoXliqnnqbrpl7TvvIzmlrnms5XmmK/vvJpcbiDikaAgIOWPpuiuvuS4gOS4quaVsOe7hGTvvIxMWzFd6LWL57uZZFsxXe+8jOWwhmRbMV3nnIvmiJDmmK/mjpLlpb3luo/nmoTluo/liJfkuK3kuK3pl7TkvY3nva7nmoTorrDlvZXvvJtcbiDikaEgIOWIhuWIq+WwhkxbIF3kuK3nmoTnrKxp5Liq6K6w5b2V5L6d5qyh5o+S5YWl5YiwZFsxXeS5i+WJjeaIluS5i+WQjueahOacieW6j+W6j+WIl+S4re+8jOWFt+S9k+aWueazle+8mlxuIOKXhiAgTFtpXS5rZXk8ZFsxXS5rZXnvvJogTFtpXeaPkuWFpeWIsGRbMV3kuYvliY3nmoTmnInluo/ooajkuK3vvJtcbiDil4YgTFtpXS5rZXniiaVkWzFdLmtlee+8miBMW2ld5o+S5YWl5YiwZFsxXeS5i+WQjueahOacieW6j+ihqOS4re+8m1xuIOWFs+mUrueCue+8muWunueOsOaXtuWwhuWQkemHj2TnnIvmiJDmmK/lvqrnjq/lkJHph4/vvIzlubborr7kuKTkuKrmjIfpkohmaXJzdOWSjGZpbmFs5YiG5Yir5oyH56S65o6S5bqP6L+H56iL5Lit5b6X5Yiw55qE5pyJ5bqP5bqP5YiX5Lit55qE56ys5LiA5Liq5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V44CCXG5cbiDlnKgyLei3r+aPkuWFpeaOkuW6j+S4re+8jOenu+WKqOiusOW9leeahOasoeaVsOe6puS4um4yLzgg44CC5L2G5b2TTFsxXeaYr+W+heaOkuW6j+iusOW9leS4reWFs+mUruWtl+acgOWkp+aIluacgOWwj+eahOiusOW9leaXtu+8jDIt6Lev5o+S5YWl5o6S5bqP5bCx5a6M5YWo5aSx5Y675LqG5LyY6LaK5oCn44CCXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGgySW5zZXJ0U29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIGxldCBkID0gW3NxTGlzdFswXV07XG4gICAgLy8gZmlyc3TjgIFmaW5hbOWIhuWIq+aMh+ekumTkuK3mjpLlpb3luo/nmoTorrDlvZXnmoTnrKwx5Liq5ZKM5pyA5ZCOMeS4quiusOW9leeahOS9jee9ruOAglxuICAgIGxldCBmaXJzdCA9IDA7XG4gICAgbGV0IGZpbmFsID0gMDtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSBzcUxpc3RbaV07XG5cbiAgICAgICAgLy8g5b6F5o+S5YWl6K6w5b2V5bCP5LqOZOS4reacgOWwj+WAvO+8jOaPkuWFpeWIsGRbZmlyc3Rd5LmL5YmN77yI5LiN6ZyA56e75YqoZOaVsOe7hOeahOWFg+e0oO+8ieOAglxuICAgICAgICBpZiAoY29tcChpdGVtLCBkW2ZpcnN0XSkgPCAwKSB7XG4gICAgICAgICAgICBmaXJzdCA9IChmaXJzdCAtIDEpICUgbGVuO1xuICAgICAgICAgICAgZFtmaXJzdF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIC8vIOW+heaPkuWFpeiusOW9leWkp+S6jmTkuK3mnIDlsI/lgLzvvIzmj5LlhaXliLBkW2ZpbmFsXeS5i+WQju+8iOS4jemcgOenu+WKqGTmlbDnu4TnmoTlhYPntKDvvInjgIJcbiAgICAgICAgZWxzZSBpZiAoY29tcChpdGVtLCBkW2ZpbmFsXSkgPiAwKSB7XG4gICAgICAgICAgICBkWysrZmluYWxdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICAvLyDlvoXmj5LlhaXorrDlvZXlpKfkuo5k5Lit5pyA5bCP5YC877yM5bCP5LqOZOS4reacgOWkp+WAvO+8jOaPkuWFpeWIsGTnmoTkuK3pl7TvvIjpnIDopoHnp7vliqhk5pWw57uE55qE5YWD57Sg77yJ44CCXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8g56e75YqoZOWwvumDqOWFg+e0oOS7peS+v+aMieW6j+aPkuWFpeiusOW9leOAglxuICAgICAgICAgICAgbGV0IGogPSBmaW5hbCsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXAoaXRlbSwgZFtqXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZFsoaiArIDEpICUgbGVuXSA9IGRbal07XG4gICAgICAgICAgICAgICAgaiA9IChqIC0gMSkgJSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkWyhqICsgMSkgJSBsZW5dID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOW+queOr+aKimTotYvnu5lzcUxpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHNxTGlzdFtpXSA9IGRbKGkgKyBmaXJzdCkgJSBsZW5dO1xuICAgIH1cbn1cblxudmFyIGMgPSBbNDksIDM4LCA2NSwgMTMsIDk3LCAyNywgNzYsIDUsIDEwMCwgNzgsIDE1LCAxNSwgMjBdO1xucGF0aDJJbnNlcnRTb3J0KGMpO1xuY29uc29sZS5sb2coYyArICcnKTtcblxuXG4vKlxu6KGo5o+S5YWl5o6S5bqPXG5cbuWJjemdoueahOaPkuWFpeaOkuW6j+S4jeWPr+mBv+WFjeWcsOimgeenu+WKqOiusOW9le+8jOiLpeS4jeenu+WKqOiusOW9leWwsemcgOimgeaUueWPmOaVsOaNrue7k+aehOOAglxu5Yid5aeL5YyW77ya5LiL5qCH5YC85Li6MOeahOWIhumHj+S9nOS4uuihqOWktOe7k+eCue+8jOWFs+mUruWtl+WPluS4uuacgOWkp+WAvO+8jOWQhOWIhumHj+eahOaMh+mSiOWAvOS4uuepuu+8m1xu4pGgICDlsIbpnZnmgIHpk77ooajkuK3mlbDnu4TkuIvmoIflgLzkuLox55qE5YiG6YePKOe7k+eCuSnkuI7ooajlpLTnu5PngrnmnoTmiJDkuIDkuKrlvqrnjq/pk77ooajvvJtcbuKRoSBpPTIg77yM5bCG5YiG6YePUltpXeaMieWFs+mUruWtl+mAkuWHj+aPkuWFpeWIsOW+queOr+mTvuihqO+8m1xu4pGiICDlop7liqBpIO+8jOmHjeWkjeKRoe+8jOebtOWIsOWFqOmDqOWIhumHj+aPkuWFpeWIsOW+queOr+mTvuihqOOAglxuXG7lkoznm7TmjqXmj5LlhaXmjpLluo/nm7jmr5TvvIzkuI3lkIznmoTmmK/kv67mlLkybuasoeaMh+mSiOWAvOS7peS7o+abv+enu+WKqOiusOW9le+8jOiAjOWFs+mUruWtl+eahOavlOi+g+asoeaVsOebuOWQjO+8jOaVheaXtumXtOWkjeadguW6puS4uk8objIp44CCXG5cbuihqOaPkuWFpeaOkuW6j+W+l+WIsOS4gOS4quacieW6j+mTvuihqO+8jOWvueWFtuWPr+S7peaWueS+v+WcsOi/m+ihjOmhuuW6j+afpeaJvu+8jOS9huS4jeiDveWunueOsOmaj+acuuafpeaJvuOAguS4uuS6huiDveWunueOsOacieW6j+ihqOeahOaKmOWNiuafpeaJvuagueaNrumcgOimge+8jOWPr+S7peWvueiusOW9lei/m+ihjOmHjeaOki5cblxu6YeN5o6S6K6w5b2V55qE5YGa5rOV5piv77ya6aG65bqP5omr5o+P5pyJ5bqP6ZO+6KGo77yM5bCG6ZO+6KGo5Lit56ysaeS4que7k+eCueenu+WKqOiHs+aVsOe7hOeahOesrGnkuKrliIbph4/kuK3jgIJcblxu5L6L5a2Q5Lit77yM6ZO+6KGo5Lit56ys5LiA5Liq57uT54K577yM5Y2z5YWz6ZSu5a2X5pyA5bCP55qE57uT54K55piv5pWw57uE5Lit5LiL5qCH5Li6NueahOWIhumHj++8jOWFtuS4reiusOW9leW6lOenu+iHs+aVsOe7hOeahOesrOS4gOS4quWIhumHj++8jOWImeWwhmxpc3RbMV3lkoxsaXN0WzZd5LqS5o2i77yM5bm25Li65LqG5LiN5Lit5pat6Z2Z5oCB6ZO+6KGo5Lit55qE6ZO+77yM5Y2z5Zyo57un57ut6aG66ZO+6KGo5omr5o+P5pe25LuN6IO95om+5Yiw5LqS5o2i5LmL5YmN5ZyobGlzdFsxXeS4reeahOe7k+eCue+8jOS7pOS6kuaNouS5i+WQjueahGxpc3RbMV3kuK3nmoTmuLjmoIfmlLnkuLo2XG5cbuaOqOW5v+iHs+S4gOiIrOaDheWGte+8jOiLpeesrGnkuKrmnIDlsI/lhbPplK7lrZfnmoTnu5PngrnmmK/mlbDnu4TkuK3kuIvmoIfkuLpw5LiUcCA+IGnnmoTliIbph4/vvIzliJnkupLmjaJsaXN0W2ld5ZKMbGlzdFtwXe+8jOS4lOS7pGxpc3RbaV3kuK3nmoTmuLjmoIfmlLnkuLpw77ybXG7nlLHkuo7mraTml7bmlbDnu4TkuK3miYDmnInlsI/kuo5p55qE5YiG6YeP5Lit5bey5piv5Yiw5L2N6K6w5b2V77yM5YiZ5b2TcDxp5pe277yM5bqU6aG66ZO+57un57ut5p+l5om+55u05YiwcD49aeS4uuatouOAglxuICovXG5cblxuLy8g6KGo5o+S5YWl5o6S5bqPXG5leHBvcnQgZnVuY3Rpb24gc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQoc2xsaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICAvLyDmnoTmiJDlvqrnjq/pk77ooahcbiAgICBzbGxpc3RbMF0uY3VyID0gMTtcbiAgICBzbGxpc3RbMV0uY3VyID0gMDtcblxuICAgIGxldCBwLCBxO1xuICAgIGZvciAobGV0IGkgPSAyLCBsZW4gPSBzbGxpc3QubGVuZ3RoOyBpIDw9IGxlbjsgKytpKSB7XG4gICAgICAgIHAgPSAwO1xuICAgICAgICBsZXQgeCA9IHNsbGlzdFtpXS5kYXRhO1xuXG4gICAgICAgIHdoaWxlIChzbGxpc3RbcF0uY3VyICYmIGNvbXAoc2xsaXN0W3NsbGlzdFtwXS5jdXJdLmRhdGEsIHgpIDwgMClcbiAgICAgICAgICAgIHAgPSBzbGxpc3RbcF0uY3VyO1xuXG4gICAgICAgIC8vIOW9k+mBh+WIsOWkp+S6juW9k+WJjeWFs+mUruWtl+eahOS4i+agh+aXtu+8jOaPkuWFpeWIsOWFtuWJjempseWSjOWQjue7p+eahOS4remXtFxuICAgICAgICBxID0gc2xsaXN0W3BdLmN1cjtcbiAgICAgICAgc2xsaXN0W3BdLmN1ciA9IGk7XG4gICAgICAgIHNsbGlzdFtpXS5jdXIgPSBxO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQgPSBzdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydDtcblxuLy8g6YeN5o6S6Z2Z5oCB6ZO+6KGo77yM6Z2Z5oCB6ZO+6KGo5LiL5qCH5bey5o6S5aW95bqPXG5mdW5jdGlvbiBhcnJhbmdlKHNsbGlzdCkge1xuICAgIGxldCBwID0gc2xsaXN0WzBdLmN1cjtcblxuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBzbGxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8g56ysaeS4quiusOW9leWcqGxpc3TkuK3nmoTlvZPliY3kvY3nva7lupTkuI3lsI/kuo5pXG4gICAgICAgIC8vIOaJvuWIsOesrGnkuKrorrDlvZXvvIzlubbnlKhw5oyH56S65YW25ZyobGlzdOS4reW9k+WJjeS9jee9rlxuICAgICAgICB3aGlsZSAocCA8IGkpIHAgPSBzbGxpc3RbcF0uY3VyO1xuICAgICAgICAvLyBx5oyH5ZCR5bCa5pyq6LCD5pW055qE6KGo5bC+XG4gICAgICAgIGxldCBxID0gc2xsaXN0W3BdLmN1cjtcblxuICAgICAgICBpZiAocCAhPT0gaSkge1xuICAgICAgICAgICAgLy8g5Lqk5o2i6K6w5b2V77yM5L2/56ysaeS4quiusOW9leWIsOS9jVxuICAgICAgICAgICAgbGV0IHRlbXAgPSBzbGxpc3RbcF07XG4gICAgICAgICAgICBzbGxpc3RbcF0gPSBzbGxpc3RbaV07XG4gICAgICAgICAgICBzbGxpc3RbaV0gPSB0ZW1wO1xuICAgICAgICAgICAgLy8g5oyH5ZCR6KKr56e76LWw55qE6K6w5b2V77yM5L2/5b6X5Lul5ZCO5Y+v5pyJd2hpbGXlvqrnjq/mib7liLBcbiAgICAgICAgICAgIHNsbGlzdFtpXS5jdXIgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcOaMh+WQkeWwmuacquiwg+aVtOeahOihqOWwvlxuICAgICAgICBwID0gcTtcbiAgICB9XG59XG5cblxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNTJdO1xudmFyIGQgPSBuZXcgU3RhdGljTGlua2VkTGlzdCgpO1xuZC5jcmVhdGUoYXJyKTtcbnN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0KGQpO1xuY29uc29sZS5sb2coZCk7XG5hcnJhbmdlKGQpO1xuY29uc29sZS5sb2coZCk7XG5cblxuLypcbuW4jOWwlOaOkuW6j1xuXG7luIzlsJTmjpLluo8oU2hlbGwgU29ydO+8jOWPiOensOe8qeWwj+WinumHj+azlSnmmK/kuIDnp43liIbnu4Tmj5LlhaXmjpLluo/mlrnms5XjgIJcblxuMSAg5o6S5bqP5oCd5oOzXG7ikaAgICDlhYjlj5bkuIDkuKrmraPmlbTmlbBkMShkMTxuKeS9nOS4uuesrOS4gOS4quWinumHj++8jOWwhuWFqOmDqG7kuKrorrDlvZXliIbmiJBkMee7hO+8jOaKiuaJgOacieebuOmalGQx55qE6K6w5b2V5pS+5Zyo5LiA57uE5Lit77yM5Y2z5a+55LqO5q+P5LiqayhrPTEsIDIsICDigKYgZDEp77yMUltrXSwgUltkMStrXSwgUlsyZDEra10gLCDigKbliIblnKjlkIzkuIDnu4TkuK3vvIzlnKjlkITnu4TlhoXov5vooYznm7TmjqXmj5LlhaXmjpLluo/jgILov5nmoLfkuIDmrKHliIbnu4TlkozmjpLluo/ov4fnqIvnp7DkuLrkuIDotp/luIzlsJTmjpLluo/vvJtcbuKRoSAgIOWPluaWsOeahOWinumHj2QyPGQx77yM6YeN5aSN4pGg55qE5YiG57uE5ZKM5o6S5bqP5pON5L2c77yb55u06Iez5omA5Y+W55qE5aKe6YePZGk9MeS4uuatou+8jOWNs+aJgOacieiusOW9leaUvui/m+S4gOS4que7hOS4reaOkuW6j+S4uuatouOAglxuXG4yICDmjpLluo/npLrkvotcbuiuvuaciTEw5Liq5b6F5o6S5bqP55qE6K6w5b2V77yM5YWz6ZSu5a2X5YiG5Yir5Li6OSwgMTMsIDgsIDIsIDUsIDEzLCA3LCAxLCAxNSwgMTHvvIzlop7ph4/luo/liJfmmK81LCAzLCAx77yM5biM5bCU5o6S5bqP55qE6L+H56iLOlxu5Yid5aeL5YWz6ZSu5a2X5bqP5YiXOiAgICA5ICAgICAxMyAgICAgOCAgICAgIDIgICAgICA1ICAgICAgMTMgICAgICA3ICAgICAgMSAgICAgIDE1ICAgICAgMTFcbuesrOS4gOi2n+aOkuW6j+WQjjogICAgICA5ICAgICA3ICAgICAgMSAgICAgIDIgICAgICA1ICAgICAgMTMgICAgICAxMyAgICAgOCAgICAgIDE1ICAgICAgMTFcbuesrOS6jOi2n+aOkuW6j+WQjjogICAgICAyICAgICA1ICAgICAgMSAgICAgIDkgICAgICA3ICAgICAgMTMgICAgICAxMSAgICAgOCAgICAgIDE1ICAgICAgMTNcbuesrOS4iei2n+aOkuW6j+WQjjogICAgICAxICAgICAyICAgICAgNSAgICAgIDcgICAgICA4ICAgICAgOSAgICAgIDExICAgICAxMyAgICAgIDEzICAgICAgMTVcblxuXG7luIzlsJTmjpLluo/nmoTliIbmnpDmr5TovoPlpI3mnYLvvIzmtonlj4rkuIDkupvmlbDlrabkuIrnmoTpl67popjvvIzlhbbml7bpl7TmmK/miYDlj5bnmoTigJzlop7ph4/igJ3luo/liJfnmoTlh73mlbDjgIJcblxu5biM5bCU5o6S5bqP54m554K5XG7lrZDluo/liJfnmoTmnoTmiJDkuI3mmK/nroDljZXnmoTigJzpgJDmrrXliIblibLigJ3vvIzogIzmmK/lsIbnm7jpmpTmn5DkuKrlop7ph4/nmoTorrDlvZXnu4TmiJDkuIDkuKrlrZDluo/liJfjgIJcbuW4jOWwlOaOkuW6j+WPr+aPkOmrmOaOkuW6j+mAn+W6pu+8jOWOn+WboOaYr++8mlxu4peGIOWIhue7hOWQjm7lgLzlh4/lsI/vvIxuwrLmm7TlsI/vvIzogIxUKG4pPU8obsKyKSzmiYDku6VUKG4p5LuO5oC75L2T5LiK55yL5piv5YeP5bCP5LqG77ybXG7il4Yg5YWz6ZSu5a2X6L6D5bCP55qE6K6w5b2V6Lez6LeD5byP5YmN56e777yM5Zyo6L+b6KGM5pyA5ZCO5LiA6Laf5aKe6YeP5Li6MeeahOaPkuWFpeaOkuW6j+aXtu+8jOW6j+WIl+W3suWfuuacrOacieW6j+OAglxuXG7lop7ph4/luo/liJflj5bms5VcbuKXhiDml6DpmaQx5Lul5aSW55qE5YWs5Zug5a2Q77ybXG7il4Yg5pyA5ZCO5LiA5Liq5aKe6YeP5YC85b+F6aG75Li6MeOAglxuXG7nm7jlhbPotYTmlpnvvJogaHR0cDovL3dlbmt1LmJhaWR1LmNvbS9saW5rP3VybD1xN2t6T3hYcWMwQkxhR1VWRFk0M0ZRT2gyYVgxVXFCSGtrWWQzVk13SmhKbzZydjRTaVU2ODZSVzNrUUNTcUdFS3l0bDEyUzhmQk9wd2hxLXJ1bmhYX3BiWmNnNkJlRC1taVlNUGdEaFh4S1xuICovXG5cbmZ1bmN0aW9uIHNoZWxsSW5zZXJ0KHNxTGlzdCwgZGssIGNvbXApIHtcbiAgICBmb3IgKGxldCBpID0gZGssIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgaWYgKGNvbXAodGVtcCwgc3FMaXN0W2kgLSBka10pIDwgMCkge1xuICAgICAgICAgICAgbGV0IGogPSBpIC0gZGs7XG4gICAgICAgICAgICBmb3IgKDsgaiA+PSAwICYmIGNvbXAodGVtcCwgc3FMaXN0W2pdKSA8IDA7IGogLT0gZGspXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ogKyBka10gPSBzcUxpc3Rbal07XG5cbiAgICAgICAgICAgIHNxTGlzdFtqICsgZGtdID0gdGVtcDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoZWxsU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIGxldCBkZWx0YSA9IGNyZWF0ZURlbHRhKHNxTGlzdC5sZW5ndGgpO1xuICAgIC8vY29uc29sZS5sb2coZGVsdGEpO1xuICAgIGZvciAobGV0IGsgPSAwLCB0ID0gZGVsdGEubGVuZ3RoOyBrIDwgdDsgKytrKSB7XG4gICAgICAgIHNoZWxsSW5zZXJ0KHNxTGlzdCwgZGVsdGFba10sIGNvbXApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVsdGEobikge1xuICAgIGxldCBhcnIgPSBbXTtcbiAgICBsZXQgdCA9IChNYXRoLmxvZyhuIC0gMSkgLyBNYXRoLmxvZygyKSkgfCAwOyAgLy8gTWF0aC5sb2cobiAtIDEpIC8gTWF0aC5sb2coMiksIE1hdGgubG9nKG4gKyAxKSAvIE1hdGgubG9nKDIpXG4gICAgZm9yKGxldCBrID0gMDsgayA8PSB0OyArK2spXG4gICAgICAgIGFycltrXSA9IE1hdGgucG93KDIsIHQgLSBrKSArIDE7ICAgIC8vIE1hdGgucG93KDIsIHQgLSBpICsgMSkgLSAxLCBNYXRoLnBvdygyLCB0IC0gaSkgKyAxXG5cbiAgICBhcnJbYXJyLmxlbmd0aF0gPSAxO1xuXG4gICAgcmV0dXJuIGFycjtcbn1cblxuXG5jb25zb2xlLmxvZygnXFxuXFxuU2hlbGwgU29ydDonKTtcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XG5zaGVsbFNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9pbnNlcnRpb24vaW5kZXguanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMi83LlxuICovXG5pbXBvcnQgTGlua2VkTGlzdCBmcm9tICcuLi8uLi9MaXN0L0xpbmtlZExpc3QnO1xuaW1wb3J0IFF1ZXVlIGZyb20gJy4uLy4uL1F1ZXVlL1F1ZXVlJztcbmltcG9ydCBkZWZhdWx0Q29tcGFyZSBmcm9tICcuLi9kZWZhdWx0Q29tcGFyaXNpb24nO1xuXG4vKlxuIOW9kuW5tuaOkuW6j1xuXG4g5b2S5bm2KE1lcmdpbmcpIO+8muaYr+aMh+WwhuS4pOS4quaIluS4pOS4quS7peS4iueahOacieW6j+W6j+WIl+WQiOW5tuaIkOS4gOS4quacieW6j+W6j+WIl+OAguiLpemHh+eUqOe6v+aAp+ihqCjml6DorrrmmK/pgqPnp43lrZjlgqjnu5PmnoQp5piT5LqO5a6e546w77yM5YW25pe26Ze05aSN5p2C5bqm5Li6TyhtK24pIOOAglxuIOW9kuW5tuaAneaDs+WunuS+i++8muS4pOWghuaJkeWFi+eJjO+8jOmDveW3suS7juWwj+WIsOWkp+aOkuWlveW6j++8jOimgeWwhuS4pOWghuWQiOW5tuS4uuS4gOWghuS4lOimgeaxguS7juWwj+WIsOWkp+aOkuW6j+OAglxuIOKXhiAg5bCG5Lik5aCG5pyA5LiK6Z2i55qE5oq95Ye6KOiuvuS4ukMx77yMQzIp5q+U6L6D5aSn5bCP77yM5bCG5bCP6ICF572u5LqO5LiA6L655L2c5Li65paw55qE5LiA5aCGKOS4jeWmqOiuvkMxPEMyKe+8m+WGjeS7juesrOS4gOWghuS4reaKveWHuuS4gOW8oOe7p+e7reS4jkMy6L+b6KGM5q+U6L6D77yM5bCG6L6D5bCP55qE5pS+572u5Zyo5paw5aCG55qE5pyA5LiL6Z2i77ybXG4g4peGIOmHjeWkjeS4iui/sOi/h+eoi++8jOebtOWIsOafkOS4gOWghuW3suaKveWujO+8jOeEtuWQjuWwhuWJqeS4i+S4gOWghuS4reeahOaJgOacieeJjOi9rOenu+WIsOaWsOWghuS4reOAglxuXG4gMSAgIOaOkuW6j+aAneaDs1xuIOKRoCAg5Yid5aeL5pe277yM5bCG5q+P5Liq6K6w5b2V55yL5oiQ5LiA5Liq5Y2V54us55qE5pyJ5bqP5bqP5YiX77yM5YiZbuS4quW+heaOkuW6j+iusOW9leWwseaYr27kuKrplb/luqbkuLox55qE5pyJ5bqP5a2Q5bqP5YiX77ybXG4g4pGhICDlr7nmiYDmnInmnInluo/lrZDluo/liJfov5vooYzkuKTkuKTlvZLlubbvvIzlvpfliLDvg6luLzLvg7nkuKrplb/luqbkuLoy5oiWMeeahOacieW6j+WtkOW6j+WIl+KAlOKAlOS4gOi2n+W9kuW5tu+8m1xuIOKRoiAg6YeN5aSN4pGhIO+8jOebtOWIsOW+l+WIsOmVv+W6puS4um7nmoTmnInluo/luo/liJfkuLrmraLjgIJcblxuIOS4iui/sOaOkuW6j+i/h+eoi+S4re+8jOWtkOW6j+WIl+aAu+aYr+S4pOS4pOW9kuW5tu+8jOensOS4ujIt6Lev5b2S5bm25o6S5bqP44CC5YW25qC45b+D5piv5aaC5L2V5bCG55u46YK755qE5Lik5Liq5a2Q5bqP5YiX5b2S5bm25oiQ5LiA5Liq5a2Q5bqP5YiX44CC6K6+55u46YK755qE5Lik5Liq5a2Q5bqP5YiX5YiG5Yir5Li677yaXG4ge1Jba10sIFJbaysxXSwg4oCmLCBSW21dfeWSjHtSW20rMV0sIFJbbSsyXSzigKYsIFJbaF1977yM5bCG5a6D5Lus5b2S5bm25Li65LiA5Liq5pyJ5bqP55qE5a2Q5bqP5YiX77yaXG4ge0RSW2xdLCBEUltsKzFdLCDigKYsIERSW21dLCBEUlttKzFdLCDigKYsIERSW2hdIH1cblxuIOS+i++8muiuvuaciTnkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLoyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQx77yM5b2S5bm25o6S5bqP55qE6L+H56iL44CCXG4g5Yid5aeL5YWz6ZSu5a2XOiBbMjNdICAgWzM4XSAgIFsyMl0gICBbNDVdICAgWzIzXSAgIFs2N10gICBbMzFdICAgWzE1XSAgIFs0MV1cbiAgICAgICAgICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHxcbiAgICAgICAgICAgICAgLS0tLS0tLS0gICAgICAtLS0tLS0tLSAgICAgIC0tLS0tLS0tICAgICAgLS0tLS0tLS1cbiDkuIDotp/lvZLlubblkI46IFsyMyAgICAzOF0gICAgWzIyICAgICA0NV0gICAgWzIzICAgICA2N10gICAgWzE1ICAgICAzMV0gICBbNDFdXG4gICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS1cbiDkuozotp/lvZLlubblkI46IFsyMiAgICAgMjMgICAgICAzOCAgICAgNDVdICAgIFsxNSAgICAgMjMgICAgIDMxICAgICA2N10gICAgWzQxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4g5LiJ6Laf5b2S5bm25ZCOOiBbMTUgICAgIDIyICAgICAgMjMgICAgIDIzICAgICAzMSAgICAgMzggICAgIDQ1ICAgICA2N10gICAgWzQxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuIOWbm+i2n+W9kuW5tuWQjjogWzE1ICAgICAyMiAgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgIDY3XG5cblxuIDIgIOS4gOi2n+W9kuW5tuaOkuW6j1xuIOS4gOi2n+W9kuW5tuaOkuW6j+mDveaYr+S7juWJjeWIsOWQju+8jOS+neasoeWwhuebuOmCu+eahOS4pOS4quacieW6j+WtkOW6j+WIl+W9kuW5tuS4uuS4gOS4qu+8jOS4lOmZpOacgOWQjuS4gOS4quWtkOW6j+WIl+Wklu+8jOWFtuS9meavj+S4quWtkOW6j+WIl+eahOmVv+W6pumDveebuOWQjOOAguiuvui/meS6m+WtkOW6j+WIl+eahOmVv+W6puS4umTvvIzliJnkuIDotp/lvZLlubbmjpLluo/nmoTov4fnqIvmmK/vvJpcbiDku45qPTDlvIDlp4vvvIzkvp3mrKHlsIbnm7jpgrvnmoTkuKTkuKrmnInluo/lrZDluo/liJdcbiBSW2rigKZqK2QtMV3lkoxSW2orZOKApmorMmQtMV3ov5vooYzlvZLlubbvvJvmr4/mrKHlvZLlubbkuKTkuKrlrZDluo/liJflkI7vvIxq5ZCO56e75YqoMmTkuKrkvY3nva7vvIzljbNcbiBqPWorMmTvvJvoi6XliankuIvnmoTlhYPntKDkuI3otrPkuKTkuKrlrZDluo/liJfml7bvvIzliIbku6XkuIvkuKTnp43mg4XlhrXlpITnkIbvvJpcbiDikaAgIOWJqeS4i+eahOWFg+e0oOS4quaVsD5k77ya5YaN6LCD55So5LiA5qyh5LiK6L+w6L+H56iL77yM5bCG5LiA5Liq6ZW/5bqm5Li6ZOeahOWtkOW6j+WIl+WSjOS4jei2s2TnmoTlrZDluo/liJfov5vooYzlvZLlubbvvJtcbiDikaEgIOWJqeS4i+eahOWFg+e0oOS4quaVsOKJpGTvvJrlsIbliankuIvnmoTlhYPntKDkvp3mrKHlpI3liLbliLDlvZLlubblkI7nmoTluo/liJfkuK3jgIJcblxuXG4gMy7nrpfms5XliIbmnpBcbuWFt+aciW7kuKrlvoXmjpLluo/orrDlvZXnmoTlvZLlubbmrKHmlbDmmK/jj5Iybu+8jOiAjOS4gOi2n+W9kuW5tueahOaXtumXtOWkjeadguW6puS4uk8obinvvIzliJnmlbTkuKrlvZLlubbmjpLluo/nmoTml7bpl7TlpI3mnYLluqbml6DorrrmmK/mnIDlpb3ov5jmmK/mnIDlnY/mg4XlhrXlnYfkuLpPKG7jj5IybinjgILlnKjmjpLluo/ov4fnqIvkuK3vvIzkvb/nlKjkuobovoXliqnlkJHph49EUu+8jOWkp+Wwj+S4juW+heaOkuW6j+iusOW9leepuumXtOebuOWQjO+8jOWImeepuumXtOWkjeadguW6puS4uk8obinjgILlvZLlubbmjpLluo/mmK/nqLPlrprnmoTjgIJcblxuICovXG5cbmxldCBuQ291bnQgPSAwO1xubGV0IG5vblJlY3Vyc2l2ZUNvdW50ID0gMDtcbmxldCByZWN1cnNpdmVDb3VudCA9IDA7XG5cbi8qKlxuICog5bCG5pyJ5bqP55qEc3JbczEuLmUxXeWSjHNyW3MyLi5lMl3lvZLlubbkuLrmnInluo/nmoR0cltzMS4uZTJdXG4gKiBAcGFyYW0gc3JcbiAqIEBwYXJhbSBzMVxuICogQHBhcmFtIGUxXG4gKiBAcGFyYW0gZTJcbiAqL1xuZnVuY3Rpb24gbWVyZ2Uoc3IsIHMxLCBlMSwgZTIsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSl7XG4gICAgbGV0IHRlbXAgPSBbXTtcbiAgICBsZXQgaSA9IHMxO1xuICAgIGxldCBqID0gZTEgKyAxO1xuICAgIGxldCBrID0gMDtcblxuICAgIHdoaWxlKGkgPD0gZTEgJiYgaiA8PSBlMil7XG4gICAgICAgIGlmKGNvbXAoc3JbaV0sIHNyW2pdKSA8IDApIHRlbXBbaysrXSA9IHNyW2krK107XG4gICAgICAgIGVsc2UgdGVtcFtrKytdID0gc3JbaisrXTtcbiAgICB9XG4gICAgd2hpbGUoaSA8PSBlMSkgdGVtcFtrKytdID0gc3JbaSsrXTtcbiAgICB3aGlsZShqIDw9IGUyKSB0ZW1wW2srK10gPSBzcltqKytdO1xuXG4gICAgLy8g5aSN5Yi25Zue5Y67XG4gICAgZm9yKGkgPSBzMSwgayA9IDA7IGkgPD0gZTI7ICsraSwgKytrKSBzcltpXSA9IHRlbXBba107XG59XG5cbi8qKlxuICogMi3ot6/lvZLlubbmjpLluo/pgJLlvZLnrpfms5VcbiAqIEBwYXJhbSB7QXJyYXl9IHNyXG4gKiBAcGFyYW0ge051bWJlcn0gc1xuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydFJlY3Vyc2l2ZShzciwgcyA9IDAsIHQgPSBzci5sZW5ndGggLSAxLCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xuICAgIGlmKHMgPj0gdCkgcmV0dXJuO1xuXG4gICAgLy8g5bCGc3Jbcy4udF3lubPliIbkuLpzcltzLi5tXeWSjHNyW20rMS4udF1cbiAgICBsZXQgbSA9IChzICsgdCkgPj4gMTtcbiAgICAvLyDpgJLlvZLlnLDlsIZzcltzLi5tXeW9kuW5tuS4uuacieW6j+eahHNyW3MuLm1dXG4gICAgbWVyZ2VTb3J0UmVjdXJzaXZlKHNyLCBzLCBtLCBjb21wKTtcbiAgICAvLyDpgJLlvZLlnLDlsIZzclttKzEuLnRd5b2S5bm25Li65pyJ5bqP55qEc3JbbSsxLi50XVxuICAgIG1lcmdlU29ydFJlY3Vyc2l2ZShzciwgbSArIDEsIHQsIGNvbXApO1xuICAgIC8vIOWwhnNyW3MuLm1d5ZKMc3JbbSsxLi50XeW9kuW5tuWIsHNyW3MuLnRdO1xuICAgIG1lcmdlKHNyLCBzLCBtLCB0LCBjb21wKTtcbn1cblxuXG5jb25zb2xlLmxvZygnXFxuXFxubWVyZ2VTb3J0UmVjdXJzaXZlOicpO1xudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcbm1lcmdlU29ydFJlY3Vyc2l2ZShhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydE5vblJlY3Vyc2l2ZShzciwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcbiAgICBsZXQgaiwgaztcbiAgICBmb3IobGV0IGQgPSAxLCBuID0gc3IubGVuZ3RoIC0gMTsgZCA8IG47IGQgKj0gMikge1xuICAgICAgICAvLyDkuIDotp/lvZLlubbmjpLluo/nrpfms5VcbiAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgLy8g5a2Q5bqP5YiX5Lik5Lik5b2S5bm2XG4gICAgICAgIHdoaWxlKChrID0gKGogKyAyICogZCAtIDEpKSA8IG4pe1xuICAgICAgICAgICAgbWVyZ2Uoc3IsIGosICBqICsgZCAtIDEsIGssIGNvbXApO1xuICAgICAgICAgICAgaiA9IGsgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5Ymp5L2Z5YWD57Sg5Liq5pWw6LaF6L+H5LiA5Liq5a2Q5bqP5YiX6ZW/5bqmXG4gICAgICAgIGlmKGogKyBkIC0gMSA8IG4pIG1lcmdlKHNyLCBqLCBqICsgZCAtIDEsIG4sIGNvbXApO1xuICAgICAgICAvLyDliankvZnlrZDluo/liJflpI3liLZcbiAgICAgICAgZWxzZSBtZXJnZShzciwgaiwgbiwgbiwgY29tcCk7XG4gICAgfVxufVxuXG5jb25zb2xlLmxvZygnXFxubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlOicpO1xudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcbm1lcmdlU29ydE5vblJlY3Vyc2l2ZShhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8vIOiHqueEtuWQiOW5tuaOkuW6j1xuLy8gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9saXVzaGFuZzA0MTkvYXJjaGl2ZS8yMDExLzA5LzE5LzIxODE0NzYuaHRtbFxuLy8gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9sYW5rZS9hcmNoaXZlLzIwMTMvMDEvMTUvMjg2MDQ4Ny5odG1sXG4vKlxu6Ieq54S25b2S5bm25piv5b2S5bm25o6S5bqP55qE5LiA5Liq5Y+Y5b2i77yM5pWI546H5pu06auY5LiA5Lqb77yM5Y+v5Lul5Zyo5b2S5bm25o6S5bqP6Z2e6YCS5b2S5a6e546w55qE5Z+656GA5LiK6L+b6KGM5L+u5pS5LuWvueS6juW3sue7j+S4gOS4quW3sue7j+e7meWumuaVsOe7hGEs6YCa5bi45a2Y5Zyo5aSa5Liq6ZW/5bqm5aSn5LqOMeeahOW3sue7j+iHqueEtuaOkuWlveeahOWtkOaVsOe7hOautSzlm6DmraTnlKjkuIDmrKHlr7nmlbDnu4Rh55qE57q/5oCn5omr5o+P5bCx5Y+v5Lul5om+5Ye65omA5pyJ6L+Z5Lqb5o6S5aW95bqP55qE5a2Q5pWw57uE5q61LOeEtuWQjuWGjeWvuei/meS6m+WtkOaVsOe7hOauteS/qeS/qeWQiOW5ti5cbiAqL1xuXG5cbi8vIOaJq+aPj+W+l+WIsOWtkOS4sueahOWHveaVsFxuZnVuY3Rpb24gcGFzcyhzcUxpc3QsIHJlYywgY29tcCl7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgcmVjW251bSsrXSA9IDA7XG4gICAgbGV0IGxlbiA9IHNxTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuOyArK2kpe1xuICAgICAgICBpZihjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSByZWNbbnVtKytdID0gaSArIDE7XG4gICAgfVxuICAgIHJlY1tudW0rK10gPSBsZW47XG5cbiAgICByZXR1cm4gbnVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF0dXJlTWVyZ2VTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcbiAgICBsZXQgcmVjID0gW107XG5cbiAgICAvL251bT0y6K+05piO5bey57uP5o6S5aW95bqP5LqGXG4gICAgLy/mr4/lvqrnjq/kuIDmrKHvvIzov5vooYzkuIDmrKFwYXNzKCnmk43kvZxcbiAgICBmb3IobGV0IG51bSA9IHBhc3Moc3FMaXN0LCByZWMsIGNvbXApOyBudW0gIT09IDI7IG51bSA9IHBhc3Moc3FMaXN0LCByZWMsIGNvbXApKXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSArIDIgPCBudW07IGkgKz0gMikge1xuICAgICAgICAgICAgbWVyZ2Uoc3FMaXN0LCByZWNbaV0sIHJlY1tpICsgMV0gLSAxLCByZWNbaSArIDJdIC0gMSwgY29tcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnNvbGUubG9nKCdcXG5uYXR1cmVNZXJnZVNvcnQ6Jyk7XG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xubmF0dXJlTWVyZ2VTb3J0KGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuY29uc29sZS5sb2cocmVjdXJzaXZlQ291bnQpO1xuY29uc29sZS5sb2cobm9uUmVjdXJzaXZlQ291bnQpO1xuY29uc29sZS5sb2cobkNvdW50KTtcblxuLy8g5Y+M5ZCR6Ieq54S25ZCI5bm25o6S5bqP566X5rOVXG4vKlxu5Y+M5ZCR6Ieq54S25ZCI5bm25o6S5bqP5piv5qC55o2u5qyy5o6S5bqP5pWw5o2u5bGA6YOo5LiN5piv5Y2H5bqP5bCx5piv6ZmN5bqP55qE6Ieq54S25pyJ5bqP54m554K5LOWFiOe6v+aAp+aJq+aPj+WHuuiHqueEtuacieW6j+eahOWtkOaVsOe7hOautSzlho3ov5vooYzlkIjlubbmjpLluo8u5omr5o+P5pe255qE5pyJ5bqP5pWw5q616ZW/5bqm6LaK6ZW/LOauteaVsOi2iuWwkSzlr7nlupTlkIjlubbmoJHnmoTlsYLmlbDlsLHkvJrotorlsJEs566X5rOV55qE5pWI546H6LaK6auYLlxuICovXG5leHBvcnQgbGV0IG5hdHVyYWxNZXJnZVNvcnQgPSAoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF0dXJhbE1lcmdlU29ydDtcblxuICAgIGZ1bmN0aW9uIG5hdHVyYWxNZXJnZVNvcnQoYSwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcbiAgICAgICAgbGV0IGIgPSBbXTtcbiAgICAgICAgbGV0IG4gPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUoIW1lcmdlUnVucyhhLCBiLCBuLCBjb21wKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VSdW5zKGEsIGIsIG4sIGNvbXApe1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgbGV0IGFzYyA9IHRydWU7XG4gICAgICAgIGxldCB4O1xuXG4gICAgICAgIHdoaWxlKGkgPCBuKXtcbiAgICAgICAgICAgIGsgPSBpO1xuICAgICAgICAgICAgLy8g5om+5Yiw5pyA5ZCO5LiA5Liq6YCS5aKe5bqP5YiX5YWD57SgXG4gICAgICAgICAgICBkbyB4ID0gYVtpKytdOyB3aGlsZShpIDwgbiAmJiBjb21wKHgsIGFbaV0pIDw9IDApO1xuICAgICAgICAgICAgLy8g5om+5Yiw5pyA5ZCO5LiA5Liq6YCS5YeP5bqP5YiX5YWD57SgXG4gICAgICAgICAgICB3aGlsZShpIDwgbiAmJiBjb21wKHgsIGFbaV0pID49IDApIHggPSBhW2krK107XG4gICAgICAgICAgICAvLyDlvZLlubbpgJLlop7luo/liJflkozpgJLlh4/luo/liJfvvIznu5Pmnpzlj6/og73pgJLlop7miJbpgJLlh49cbiAgICAgICAgICAgIG1lcmdlKGEsIGIsIGssIGkgLSAxLCBhc2MsIGNvbXApO1xuICAgICAgICAgICAgYXNjID0gIWFzYztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW9k2vnrYnkuo4w5pe25Luj6KGoYeW3sue7j+aOkuWlveW6j+S6hlxuICAgICAgICByZXR1cm4gayA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiLCBsb3csIGhpZ2gsIGFzYywgY29tcCl7XG4gICAgICAgIGxldCBrID0gYXNjID8gbG93IDogaGlnaDtcbiAgICAgICAgbGV0IGMgPSBhc2MgPyAxIDogLTE7XG4gICAgICAgIGxldCBpID0gbG93O1xuICAgICAgICBsZXQgaiA9IGhpZ2g7XG5cbiAgICAgICAgd2hpbGUoaSA8PSBqKXtcbiAgICAgICAgICAgIGlmKGNvbXAoYVtpXSwgYVtqXSkgPD0gMCkgYltrXSA9IGFbaSsrXTtcbiAgICAgICAgICAgIGVsc2UgYltrXSA9IGFbai0tXTtcbiAgICAgICAgICAgIGsgKz0gYztcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IGsgPSBsb3csIGogPSBoaWdoOyBpIDw9IGo7ICsraSwgKytrKSBhW2ldID0gYltrXTtcbiAgICB9XG59KSgpO1xuXG5jb25zb2xlLmxvZygnXFxubmF0dXJhbE1lcmdlU29ydDonKTtcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XG5uYXR1cmFsTWVyZ2VTb3J0KGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuLy8g6ZO+6KGo5a2Y5YKo57uT5p6E55qE6Ieq54S25ZCI5bm25o6S5bqPXG5leHBvcnQgbGV0IGxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0ID0gKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG1lcmdlU29ydDtcblxuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChsaW5rZWRsaXN0LCBuZWVkUmVwbGFjZSA9IHRydWUsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSl7XG4gICAgICAgIGlmKCFsaW5rZWRsaXN0KSByZXR1cm4gbGlua2VkbGlzdDtcblxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgbGV0IGxpc3QgPSBsaW5rZWRsaXN0LmhlYWQ7XG5cbiAgICAgICAgaWYoIWxpc3QgfHwgIWxpc3QubmV4dCkgcmV0dXJuIGxpbmtlZGxpc3Q7XG5cbiAgICAgICAgbGV0IHUgPSBsaXN0O1xuICAgICAgICBsZXQgdCA9IGxpc3Q7XG4gICAgICAgIGxldCB2O1xuICAgICAgICAvLyDlsIbpgJLlop7nmoTnu5PngrnmlL7lhaXliLDpmJ/liJfkuK3vvIjkvJrooqvliIfmlq3vvIlcbiAgICAgICAgZm9yKDsgdDsgdCA9IHUpe1xuICAgICAgICAgICAgd2hpbGUodSAmJiB1Lm5leHQgJiYgY29tcCh1LmRhdGEsIHUubmV4dC5kYXRhKSA8PSAwKVxuICAgICAgICAgICAgICAgIHUgPSB1Lm5leHQ7XG4gICAgICAgICAgICB2ID0gdTtcbiAgICAgICAgICAgIHUgPSB1Lm5leHQ7XG4gICAgICAgICAgICB2Lm5leHQgPSBudWxsO1xuICAgICAgICAgICAgcXVldWUuZW5RdWV1ZSh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgIC8vIOWQiOW5tue7k+eCuVxuICAgICAgICB3aGlsZShxdWV1ZS5zaXplKXtcbiAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUodCk7XG4gICAgICAgICAgICBsZXQgYSA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgICAgIGxldCBiID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgdCA9IG1lcmdlKGEsIGIsIGNvbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobmVlZFJlcGxhY2UpIGxpbmtlZGxpc3QuaGVhZCA9IHQ7XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2UoYSwgYiwgY29tcCl7XG4gICAgICAgIGxldCBjID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgbGV0IGhlYWQgPSB7ZGF0YTogbnVsbCwgbmV4dDogbnVsbH07XG4gICAgICAgIGMuaGVhZCA9IGhlYWQ7XG4gICAgICAgIGMgPSBjLmhlYWQ7XG5cbiAgICAgICAgd2hpbGUoYSAmJiBiKXtcbiAgICAgICAgICAgIGlmKGNvbXAoYS5kYXRhLCBiLmRhdGEpIDwgMCkge1xuICAgICAgICAgICAgICAgIGMubmV4dCA9IGE7XG4gICAgICAgICAgICAgICAgYyA9IGE7XG4gICAgICAgICAgICAgICAgYSA9IGEubmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYy5uZXh0ID0gYjtcbiAgICAgICAgICAgICAgICBjID0gYjtcbiAgICAgICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5uZXh0ID0gYSA/IGEgOiBiO1xuXG4gICAgICAgIHJldHVybiBoZWFkLm5leHQ7XG4gICAgfVxufSkoKTtcblxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcbnZhciBsaW5rZWRMaXN0ID0gbmV3IExpbmtlZExpc3QoYXJyKTtcbmxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0KGxpbmtlZExpc3QpO1xuY29uc29sZS5sb2cobGlua2VkTGlzdCArICcnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9tZXJnaW5nL2luZGV4LmpzIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGx1a2Ugb24gMjAxNS8yLzIuXG4gKi9cblxuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XG5cbi8qXG7pgInmi6nmjpLluo9cblxu6YCJ5oup5o6S5bqPKFNlbGVjdGlvbiBTb3J0KeeahOWfuuacrOaAneaDs+aYr++8muavj+asoeS7juW9k+WJjeW+heaOkuW6j+eahOiusOW9leS4remAieWPluWFs+mUruWtl+acgOWwj+eahOiusOW9leihqO+8jOeEtuWQjuS4juW+heaOkuW6j+eahOiusOW9leW6j+WIl+S4reeahOesrOS4gOS4quiusOW9lei/m+ihjOS6pOaNou+8jOebtOWIsOaVtOS4quiusOW9leW6j+WIl+acieW6j+S4uuatouOAglxuXG5cbueugOWNlemAieaLqeaOkuW6j1xuXG7nroDljZXpgInmi6nmjpLluo8oU2ltcGxlIFNlbGVjdGlvbiBTb3J0IO+8jOWPiOensOS4uuebtOaOpemAieaLqeaOkuW6jynnmoTln7rmnKzmk43kvZzmmK/vvJrpgJrov4duLWnmrKHlhbPplK7lrZfpl7TnmoTmr5TovoPvvIzku45uLWkrMeS4quiusOW9leS4remAieWPluWFs+mUruWtl+acgOWwj+eahOiusOW9le+8jOeEtuWQjuWSjOesrGnkuKrorrDlvZXov5vooYzkuqTmjaLvvIxpPTEsIDIsIOKApiBuLTEg44CCXG4xICDmjpLluo/npLrkvotcbuS+i++8muiuvuacieWFs+mUruWtl+W6j+WIl+S4uu+8mjcsIDQsIC0yLCAxOSwgMTMsIDbvvIznm7TmjqXpgInmi6nmjpLluo/nmoTov4fnqIvvvJpcbuWIneWni+iusOW9leeahOWFs+mUruWtl++8miAgNyAgICAgNCAgICAtMiAgICAgMTkgICAgMTMgICAgNlxuICAgIOesrOS4gOi2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDcgICAgIDE5ICAgIDEzICAgIDZcbiAgICDnrKzkuozotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA3ICAgICAxOSAgICAxMyAgICA2XG4gICAg56ys5LiJ6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgMTkgICAgMTMgICAgN1xuICAgIOesrOWbm+i2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDcgICAgIDEzICAgIDE5XG4gICAg56ys5LqU6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgNyAgICAgMTMgICAgMTlcbiAgICDnrKzlha3otp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICA3ICAgICAxMyAgICAxOVxuXG4yLueul+azleWIhuaekFxu5pW05Liq566X5rOV5piv5LqM6YeN5b6q546v77ya5aSW5b6q546v5o6n5Yi25o6S5bqP55qE6Laf5pWw77yM5a+5buS4quiusOW9lei/m+ihjOaOkuW6j+eahOi2n+aVsOS4um4tMei2n++8m+WGheW+queOr+aOp+WItuavj+S4gOi2n+eahOaOkuW6j+OAglxu6L+b6KGM56ysaei2n+aOkuW6j+aXtu+8jOWFs+mUruWtl+eahOavlOi+g+asoeaVsOS4um4tae+8jOWIme+8mlxu5q+U6L6D5qyh5pWw77yaIG4qKG4gLSAxKSAvIDJcbuaXtumXtOWkjeadguW6puaYr++8mlQobik9TyhuMilcbuepuumXtOWkjeadguW6puaYr++8mlMobik9TygxKVxu5LuO5o6S5bqP55qE56iz5a6a5oCn5p2l55yL77yM55u05o6l6YCJ5oup5o6S5bqP5piv5LiN56iz5a6a55qE44CCXG5cbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb25Tb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgayA9IGk7XG4gICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IGxlbjsgKytqKVxuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2pdLCBzcUxpc3Rba10pIDwgMCkgayA9IGo7XG5cbiAgICAgICAgaWYgKGsgIT09IGkpIHtcbiAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2tdO1xuICAgICAgICAgICAgc3FMaXN0W2tdID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgc3FMaXN0W2ldID0gdGVtcDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGFyciA9IFs3LCA0LCAtMiwgMTksIDEzLCA2XTtcbnNpbXBsZVNlbGVjdGlvblNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKlxu5qCR5b2i6YCJ5oup5o6S5bqPXG5cbummluWFiOWvuW7kuKrorrDlvZXnmoTlhbPplK7lrZfkuKTkuKTov5vooYzmr5TovoPvvIzpgInlj5bvg6luLzLvg7nkuKrovoPlsI/ogIXvvJvnhLblkI7ov5nvg6luLzLvg7nkuKrovoPlsI/ogIXkuKTkuKTov5vooYzmr5TovoPvvIzpgInlj5bvg6luLzTvg7nkuKrovoPlsI/ogIXigKYg5aaC5q2k6YeN5aSN77yM55u05Yiw5Y+q5YmpMeS4quWFs+mUruWtl+S4uuatouOAglxu6K+l6L+H56iL5Y+v55So5LiA5qO15pyJbuS4quWPtuWtkOe7k+eCueeahOWujOWFqOS6jOWPieagkeihqOekuu+8jOavj+S4quaenee7k+eCueeahOWFs+mUruWtl+mDveetieS6juWFtuW3puOAgeWPs+WtqeWtkOe7k+eCueS4rei+g+Wwj+eahOWFs+mUruWtl++8jOaguee7k+eCueeahOWFs+mUruWtl+WwseaYr+acgOWwj+eahOWFs+mUruWtl+OAglxu6L6T5Ye65pyA5bCP5YWz6ZSu5a2X5ZCO77yM5qC55o2u5YWz57O755qE5Y+v5Lyg6YCS5oCn77yM5qyy6YCJ5Y+W5qyh5bCP5YWz6ZSu5a2X77yM5Y+q6ZyA5bCG5Y+25a2Q57uT54K55Lit55qE5pyA5bCP5YWz6ZSu5a2X5pS55Li64oCc5pyA5aSn5YC84oCdIO+8jOeEtuWQjumHjeWkjeS4iui/sOatpemqpOWNs+WPr+OAglxu5ZCr5pyJbuS4quWPtuWtkOe7k+eCueeahOWujOWFqOS6jOWPieagkeeahOa3seW6puS4uu+DqeOPkjJu74O5KzHvvIzliJnmgLvnmoTml7bpl7TlpI3mnYLluqbkuLpPKG7jj5Iybikg44CCXG5cbuS9hui/meenjeaOkuW6j+aWueazleWwmuaciei+heWKqeWtmOWCqOepuumXtOi+g+WkmizlkozmnIDlpKflgLzov5vooYzlpJrkvZnmr5TovoPnrYnnvLrngrnjgILkuLrkuoblvKXooaXov5nkupvnvLrpmbfvvIzlh7rnjrDkuoblj6bkuIDnp43pgInmi6nmjpLluo8tLS3loIbmjpLluo9cbiAqL1xuXG5cblxuLypcbuWghuaOkuW6j1xuXG4xICDloIbnmoTlrprkuYlcbuaYr27kuKrlhYPntKDnmoTluo/liJdIPXtrMSwgazIgLCDigKYga259IO+8jOa7oei2s++8mlxuICAgIGtp4omkazJpICAgICAgIOW9kzJp4omkbuaXtlxuICAgIGtp4omkazJpKzEgICDlvZMyaSsx4omkbuaXtlxuXG7nlLHloIbnmoTlrprkuYnnn6XvvIzloIbmmK/kuIDmo7Xku6VrMeS4uuagueeahOWujOWFqOS6jOWPieagkeOAguiLpeWvueivpeS6jOWPieagkeeahOe7k+eCuei/m+ihjOe8luWPtyjku47kuIrliLDkuIvvvIzku47lt6bliLDlj7Mp77yM5b6X5Yiw55qE5bqP5YiX5bCx5piv5bCG5LqM5Y+J5qCR55qE57uT54K55Lul6aG65bqP57uT5p6E5a2Y5pS+77yM5aCG55qE57uT5p6E5q2j5aW95ZKM6K+l5bqP5YiX57uT5p6E5a6M5YWo5LiA6Ie044CCXG5cbjIgIOWghueahOaAp+i0qFxuICAgIDEpICDloIbmmK/kuIDmo7Xph4fnlKjpobrluo/lrZjlgqjnu5PmnoTnmoTlrozlhajkuozlj4nmoJHvvIwgazHmmK/moLnnu5PngrnvvJtcbiAgICAyKSAg5aCG55qE5qC557uT54K55piv5YWz6ZSu5a2X5bqP5YiX5Lit55qE5pyA5bCPKOaIluacgOWkpynlgLzvvIzliIbliKvnp7DkuLrlsI8o5oiW5aSnKeagueWghu+8m1xuICAgIDMpICDku47moLnnu5PngrnliLDmr4/kuIDlj7blrZDnu5Pngrnot6/lvoTkuIrnmoTlhYPntKDnu4TmiJDnmoTluo/liJfpg73mmK/mjInlhYPntKDlgLwo5oiW5YWz6ZSu5a2X5YC8KemdnumAkuWHjyjmiJbpnZ7pgJLlop4p55qE77ybXG4gICAgNCkgIOWghuS4reeahOS7u+S4gOWtkOagkeS5n+aYr+WghuOAglxuXG7liKnnlKjloIbpobborrDlvZXnmoTlhbPplK7lrZflgLzmnIDlsI8o5oiW5pyA5aSnKeeahOaAp+i0qO+8jOS7juW9k+WJjeW+heaOkuW6j+eahOiusOW9leS4reS+neasoemAieWPluWFs+mUruWtl+acgOWwjyjmiJbmnIDlpKcp55qE6K6w5b2V77yM5bCx5Y+v5Lul5a6e546w5a+55pWw5o2u6K6w5b2V55qE5o6S5bqP77yM6L+Z56eN5o6S5bqP5pa55rOV56ew5Li65aCG5o6S5bqP44CCXG5cbjMgIOWghuaOkuW6j+aAneaDs1xuXG7ikaAgIOWvueS4gOe7hOW+heaOkuW6j+eahOiusOW9le+8jOaMieWghueahOWumuS5ieW7uueri+Wghu+8m1xu4pGhICDlsIbloIbpobborrDlvZXlkozmnIDlkI7kuIDkuKrorrDlvZXkuqTmjaLkvY3nva7vvIzliJnliY1uLTHkuKrorrDlvZXmmK/ml6Dluo/nmoTvvIzogIzmnIDlkI7kuIDkuKrorrDlvZXmmK/mnInluo/nmoTvvJtcbuKRoiAg5aCG6aG26K6w5b2V6KKr5Lqk5o2i5ZCO77yM5YmNbi0x5Liq6K6w5b2V5LiN5YaN5piv5aCG77yM6ZyA5bCG5YmNbi0x5Liq5b6F5o6S5bqP6K6w5b2V6YeN5paw57uE57uH5oiQ5Li65LiA5Liq5aCG77yM54S25ZCO5bCG5aCG6aG26K6w5b2V5ZKM5YCS5pWw56ys5LqM5Liq6K6w5b2V5Lqk5o2i5L2N572u77yM5Y2z5bCG5pW05Liq5bqP5YiX5Lit5qyh5bCP5YWz6ZSu5a2X5YC855qE6K6w5b2V6LCD5pW0KOaOkumZpCnlh7rml6Dluo/ljLrvvJtcbuKRoyAg6YeN5aSN5LiK6L+w5q2l6aqk77yM55u05Yiw5YWo6YOo6K6w5b2V5o6S5aW95bqP5Li65q2i44CCXG5cbue7k+iuuu+8muaOkuW6j+i/h+eoi+S4re+8jOiLpemHh+eUqOWwj+agueWghu+8jOaOkuW6j+WQjuW+l+WIsOeahOaYr+mdnumAkuWHj+W6j+WIl++8m+iLpemHh+eUqOWkp+agueWghu+8jOaOkuW6j+WQjuW+l+WIsOeahOaYr+mdnumAkuWinuW6j+WIl+OAglxuXG7loIbmjpLluo/nmoTlhbPplK5cbuKRoCAg5aaC5L2V55Sx5LiA5Liq5peg5bqP5bqP5YiX5bu65oiQ5LiA5Liq5aCG77yfXG7ikaEgIOWmguS9leWcqOi+k+WHuuWghumhtuWFg+e0oOS5i+WQju+8jOiwg+aVtOWJqeS9meWFg+e0oO+8jOS9v+S5i+aIkOS4uuS4gOS4quaWsOeahOWghu+8n1xuXG40ICDloIbnmoTosIPmlbTigJTigJTnrZvpgIlcbuKRtCDloIbnmoTosIPmlbTmgJ3mg7Ncbui+k+WHuuWghumhtuWFg+e0oOS5i+WQju+8jOS7peWghuS4reacgOWQjuS4gOS4quWFg+e0oOabv+S7o+S5i++8m+eEtuWQjuWwhuaguee7k+eCueWAvOS4juW3puOAgeWPs+WtkOagkeeahOaguee7k+eCueWAvOi/m+ihjOavlOi+g++8jOW5tuS4juWFtuS4reWwj+iAhei/m+ihjOS6pOaNou+8m+mHjeWkjeS4iui/sOaTjeS9nO+8jOebtOWIsOaYr+WPtuWtkOe7k+eCueaIluWFtuWFs+mUruWtl+WAvOWwj+S6juetieS6juW3puOAgeWPs+WtkOagkeeahOWFs+mUruWtl+eahOWAvO+8jOWwhuW+l+WIsOaWsOeahOWghuOAguensOi/meS4quS7juWghumhtuiHs+WPtuWtkOeahOiwg+aVtOi/h+eoi+S4uuKAnOetm+mAieKAneOAglxuXG7ms6jmhI/vvJrnrZvpgInov4fnqIvkuK3vvIzmoLnnu5PngrnnmoTlt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzlm6DmraTvvIznrZvpgInmmK/ku47moLnnu5PngrnliLDmn5DkuKrlj7blrZDnu5PngrnnmoTkuIDmrKHosIPmlbTov4fnqIvjgIJcblxuNSAg5aCG55qE5bu656uLXG7liKnnlKjnrZvpgInnrpfms5XvvIzlj6/ku6XlsIbku7vmhI/ml6Dluo/nmoTorrDlvZXluo/liJflu7rmiJDkuIDkuKrloIbvvIzorr5SWzFdLFJbMl0sIOKApixSW25d5piv5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX44CCXG7lsIbkuozlj4nmoJHnmoTmr4/mo7XlrZDmoJHpg73nrZvpgInmiJDkuLrloIbjgILlj6rmnInmoLnnu5PngrnnmoTmoJHmmK/loIbjgILnrKzijIpuLzLijIvkuKrnu5PngrnkuYvlkI7nmoTmiYDmnInnu5Pngrnpg73msqHmnInlrZDmoJHvvIzljbPku6XnrKzijIpuLzLijIvkuKrnu5PngrnkuYvlkI7nmoTnu5PngrnkuLrmoLnnmoTlrZDmoJHpg73mmK/loIbjgILlm6DmraTvvIzku6Xov5nkupvnu5PngrnkuLrlt6bjgIHlj7PlranlrZDnmoTnu5PngrnvvIzlhbblt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzliJnov5vooYzkuIDmrKHnrZvpgInlsLHlj6/ku6XmiJDkuLrloIbjgILlkIznkIbvvIzlj6ropoHlsIbov5nkupvnu5PngrnnmoTnm7TmjqXniLbnu5Pngrnov5vooYzkuIDmrKHnrZvpgInlsLHlj6/ku6XmiJDkuLrloIbigKbjgIJcbuWPqumcgOS7juesrOKMim4vMuKMi+S4quiusOW9leWIsOesrDHkuKrorrDlvZXkvp3mrKHov5vooYznrZvpgInlsLHlj6/ku6Xlu7rnq4vloIbjgIJcblxuNiAgIOWghuaOkuW6j+eul+azleWunueOsFxu5aCG55qE5qC557uT54K55piv5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V77yM6L6T5Ye65qC557uT54K55ZCO77yM5piv5Lul5bqP5YiX55qE5pyA5ZCO5LiA5Liq6K6w5b2V5L2c5Li65qC557uT54K577yM6ICM5Y6f5p2l5aCG55qE5bem44CB5Y+z5a2Q5qCR6YO95piv5aCG77yM5YiZ6L+b6KGM5LiA5qyh562b6YCJ5bCx5Y+v5Lul5oiQ5Li65aCG44CCXG5cbjcgIOeul+azleWIhuaekFxu5Li76KaB6L+H56iL77ya5Yid5aeL5bu65aCG5ZKM6YeN5paw6LCD5pW05oiQ5aCG44CC6K6+6K6w5b2V5pWw5Li6bu+8jOaJgOWvueW6lOeahOWujOWFqOS6jOWPieagkea3seW6puS4umgg44CCXG7il4YgIOWIneWni+W7uuWghu+8muavj+S4qumdnuWPtuWtkOe7k+eCuemDveimgeS7juS4iuWIsOS4i+WBmuKAnOetm+mAieKAnSDjgILnrKxp5bGC57uT54K55pWw4omkMmktMe+8jOe7k+eCueS4i+enu+eahOacgOWkp+a3seW6puaYr2gtae+8jOiAjOavj+S4i+enu+S4gOWxguimgeavlOi+gzLmrKHvvIzliJnmr5TovoPmrKHmlbBDMShuKeS4uu+8mlxuQzEobiniiaQ0KG4t44+SMm4tMSlcbuKXhiAg562b6YCJ6LCD5pW077ya5q+P5qyh562b6YCJ6KaB5bCG5qC557uT54K54oCc5LiL5rKJ4oCd5Yiw5LiA5Liq5ZCI6YCC5L2N572u44CC56ysaeasoeetm+mAieaXtu+8muWghuS4reWFg+e0oOS4quaVsOS4um4taSsx77yb5aCG55qE5rex5bqm5piv74Or44+SMihuLWkrMSnvg7srMe+8jOWImei/m+ihjG4tMeasoeKAnOetm+mAieKAneeahOavlOi+g+asoeaVsEMyKG4p5Li677yaXG5DMihuKTwybuOPkjJuXG7loIbmjpLluo/nmoTmr5TovoPmrKHmlbDnmoTmlbDph4/nuqfkuLrvvJogVChuKT1PKG7jj5IybinvvJvogIzpmYTliqDnqbrpl7TlsLHmmK/kuqTmjaLml7bmiYDnlKjnmoTkuLTml7bnqbrpl7TvvIzmlYXnqbrpl7TlpI3mnYLluqbkuLrvvJogUyhuKT1PKDEpIOOAglxuXG7loIbmjpLluo/pgILlkIjorrDlvZXmlbDovoPlpKfnmoTmg4XlhrVcblxuXG5odHRwOi8vYmxvZy5jc2RuLm5ldC96ejE5ODgwOC9hcnRpY2xlL2RldGFpbHMvNzY3ODA1NVxuICovXG5cbi8qKlxuICog5bey55+lc3FMaXN0W3MuLm1d5Lit6K6w5b2V55qE5YWz6ZSu5a2X6Zmkc3FMaXN0W3Nd5LmL5aSW5Z2H5ruh6Laz5aCG55qE5a6a5LmJ77yMXG4gKiDmnKzlh73mlbDosIPmlbRzcUxpc3Rbc13nmoTlhbPplK7lrZfvvIzkvb9zcUxpc3Rbcy4ubV3miJDkuLrkuIDkuKrlpKfloIbpobbvvIjlr7nlhbbkuK3lhbPplK7lrZfogIzoqIDvvIlcbiAqIEBwYXJhbSB7QXJyYXl9IHNxTGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKi9cbmZ1bmN0aW9uIGhlYXBBZGp1c3Qoc3FMaXN0LCBzLCBtLCBjb21wKSB7XG4gICAgbGV0IHJjID0gc3FMaXN0W3NdO1xuXG4gICAgLy8g5rK/5YWz6ZSu5a2X6L6D5aSn55qE5a2p5a2Q57uT54K55ZCR5LiL562b6YCJXG4gICAgZm9yIChsZXQgaiA9IDIgKiBzICsgMTsgaiA8PSBtOyBqID0gaiAqIDIgKyAxKSB7XG4gICAgICAgIC8vIGrkuLrlhbPplK7lrZfovoPlpKfnmoTorrDlvZXkuIvmoIdcbiAgICAgICAgaWYgKGogPCBtICYmIGNvbXAoc3FMaXN0W2pdLCBzcUxpc3RbaiArIDFdKSA8IDApICsrajtcbiAgICAgICAgLy8gcmPlupTmj5LlhaXlnKjkvY3nva5z5LiKXG4gICAgICAgIGlmIChjb21wKHJjLCBzcUxpc3Rbal0pID49IDApIGJyZWFrO1xuICAgICAgICBzcUxpc3Rbc10gPSBzcUxpc3Rbal07XG4gICAgICAgIHMgPSBqO1xuICAgIH1cblxuICAgIHNxTGlzdFtzXSA9IHJjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGVhcFNvcnQoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICAvLyDlu7rnq4vlpKfloIbpobZcbiAgICBmb3IgKGxldCBpID0gKGxlbiA+PiAxKSAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICBoZWFwQWRqdXN0KHNxTGlzdCwgaSwgbGVuIC0gMSwgY29tcCk7XG5cbiAgICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+IDA7IC0taSkge1xuICAgICAgICAvLyDlsIbloIbpobborrDlvZXlkozlvZPliY3mnKrnu4/mjpLluo/lrZDluo/liJdzcUxpc3RbMC4uaV3kuK1cbiAgICAgICAgLy8g5pyA5ZCO5LiA5Liq6K6w5b2V55u45LqS5Lqk5o2iXG4gICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbMF07XG4gICAgICAgIHNxTGlzdFswXSA9IHRlbXA7XG5cbiAgICAgICAgLy8g5bCGc3FMaXN0WzAuLmkgLSAxXemHjeaWsOiwg+aVtOS4uuWkp+WghumhtlxuICAgICAgICBoZWFwQWRqdXN0KHNxTGlzdCwgMCwgaSAtIDEsIGNvbXApO1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsxLCAzLCA0LCA1LCA3LCAyLCA2LCA4LCAwXTtcbmhlYXBTb3J0KGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9zZWxlY3Rpb24vaW5kZXguanMiLCIvKipcbiAqIOWghuWIhumFjeWtmOWCqOihqOekulxuICpcbiAqIOi/meenjeWtmOWCqOihqOekuueahOeJueeCueaYr++8jOS7jeS7peS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+WtmOaUvuS4suWAvOWtl+espuW6j+WIl++8jOS9huWug+S7rOeahOWtmOWCqOepuumXtOaYr+WcqOeoi+W6j+aJp+ihjOi/h+eoi+S4reWKqOaAgeWIhumFjeiAjOW+l+OAguWcqGPor63oqIDkuK3vvIzlrZjlnKjkuIDkuKrnp7DkuYvkuLrigJzloIbigJ3nmoToh6rnlLHlrZjlgqjljLrvvIzlubbnlLFj6K+t6KiA55qE5Yqo5oCB5YiG6YWN5Ye95pWwbWFsbG9jKCnlkoxmcmVlKCnmnaXnrqHnkIbjgILliKnnlKjlh73mlbBtYWxsb2MoKeS4uuavj+S4quaWsOS6p+eUn+eahOS4suWIhumFjeS4gOWdl+WunumZheS4sumVv+aJgOmcgOeahOWtmOWCqOepuumXtOOAglxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY2ggPSB7fTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIC8vIDEgPD0gcG9zaXRpb24gPD0gdGhpcy5sZW5ndGgu5Zyo5Liy55qE56yscG9zaXRpb27kuKrlrZfnrKbkuYvliY3mj5LlhaXkuLJ0SFN0cmluZ1xuICAgIHN0ckluc2VydCAocG9zaXRpb24sIHRIU3RyaW5nKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDEgfHwgcG9zaXRpb24gPiB0aGlzLmxlbmd0aCArIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcG9zaXRpb24nKTtcblxuICAgICAgICBpZiAodEhTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyDkuLrmj5LlhaV06ICM6IW+5Ye65L2N572uXG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGxlbiA9IHBvc2l0aW9uIC0gMTsgaSA+PSBsZW47IC0taSlcbiAgICAgICAgICAgICAgICB0aGlzLmNoW2kgKyB0SFN0cmluZy5sZW5ndGhdID0gdGhpcy5jaFtpXTtcblxuICAgICAgICAgICAgc3RyaW5nQ29weSh0aGlzLmNoLCB0SFN0cmluZy5jaCwgcG9zaXRpb24gLSAxLCB0SFN0cmluZy5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gdEhTdHJpbmcubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0ckFzc2lnbiAoY2hhcnMpIHtcbiAgICAgICAgc3RyaW5nQ29weSh0aGlzLmNoLCBjaGFycywgMCwgY2hhcnMubGVuZ3RoIC0gMSwgMCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICBzdHJMZW5ndGggKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHN0ckNvbXBhcmUgKHRIU3RyaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbiAmJiBpIDwgdEhTdHJpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5jaFtpXSAhPT0gdEhTdHJpbmcuY2hbaV0pIHJldHVybiB0aGlzLmNoW2ldIC0gdEhTdHJpbmcuY2hbaV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdEhTdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBjbGVhclN0cmluZyAoKSB7XG4gICAgICAgIHRoaXMuY2ggPSB7fTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBjb25jYXQgKHMpIHtcbiAgICAgICAgbGV0IHQgPSBuZXcgSFN0cmluZygpO1xuXG4gICAgICAgIC8vIHQuY2hbMC4udGhpcy5sZW5ndGggLSAxXSA9IHRoaXMuY2hbMC4udGhpcy5sZW5ndGggLSAxXVxuICAgICAgICBzdHJpbmdDb3B5KHQuY2gsIHRoaXMuY2gsIDAsIHRoaXMubGVuZ3RoIC0gMSwgMCk7XG4gICAgICAgIHQubGVuZ3RoID0gdGhpcy5sZW5ndGggKyBzLmxlbmd0aDtcbiAgICAgICAgLy8gdC5jaFt0aGlzLmxlbmd0aC4udC5sZW5ndGggLSAxXSA9IHMuY2hbMC4ucy5sZW5ndGggLSAxXVxuICAgICAgICBzdHJpbmdDb3B5KHQuY2gsIHMuY2gsIHRoaXMubGVuZ3RoLCBzLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBzdWJzdHJpbmcgKHBvc2l0aW9uLCBsZW4pIHtcbiAgICAgICAgcG9zaXRpb24gPSB+fnBvc2l0aW9uIHx8IDA7XG4gICAgICAgIGxlbiA9IH5+bGVuIHx8IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpcy5sZW5ndGggLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpcy5sZW5ndGggLSBwb3NpdGlvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwYXJhbWV0ZXInKTtcblxuICAgICAgICBsZXQgc3ViID0gbmV3IEhTdHJpbmcoKTtcbiAgICAgICAgc3RyaW5nQ29weShzdWIuY2gsIHRoaXMuY2gsIDAsIGxlbiAtIDEsIHBvc2l0aW9uKTtcbiAgICAgICAgc3ViLmxlbmd0aCA9IGxlbjtcblxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzICs9IHRoaXMuY2hbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdDb3B5KGRlc3RpbmF0aW9uLCB0YXJnZXQsIGRlc3RTdGFydCwgbGVuZ3RoLCB0YXJnZXRTdGFydCkge1xuICAgIGRlc3RTdGFydCA9IGRlc3RTdGFydCB8fCAwO1xuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCB0YXJnZXQubGVuZ3RoO1xuICAgIHRhcmdldFN0YXJ0ID0gdGFyZ2V0U3RhcnQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW2Rlc3RTdGFydCArIGldID0gdGFyZ2V0W3RhcmdldFN0YXJ0ICsgaV07XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TdHJpbmcvSFN0cmluZy5qcyIsIi8qKlxuICog5Liy55qE5Z2X6ZO+5a2Y5YKo6KGo56S6XG4gKlxuICog5ZKM57q/5oCn6KGo55qE6ZO+5byP5a2Y5YKo57uT5p6E55u457G75Ly877yM5Lmf5Y+v6YeH55So6ZO+5byP5pa55byP5a2Y5YKo5Liy5YC844CC55Sx5LqO5Liy57uT5p6E55qE54m55q6K5oCnLS3nu5PmnoTkuK3nmoTmr4/kuKrmlbDmja7lhYPntKDmmK/kuIDkuKrlrZfnrKbvvIzliJnnlKjpk77ooajlrZjlgqjkuLLlgLzml7bvvIzlrZjlnKjkuIDkuKrigJznu5PngrnlpKflsI/igJ3nmoTpl67popjvvIzljbPmr4/kuKrnu5Pngrnlj6/ku6XlrZjmlL7kuIDkuKrlrZfnrKbvvIzkuZ/lj6/ku6XlrZjmlL7lpJrkuKrlrZfnrKbjgIJcbiAqIOS4i+mdouaYr+e7k+eCueWkp+Wwj+S4ujTvvIjljbPmr4/kuKrnu5PngrnlrZjmlL405Liq5a2X56ym77yJ55qE6ZO+6KGoXG4gKiBoZWFkIC0tPiAoYSxiLGMsZCkgLS0+IChlLGYsZyxoKSAtLT4gKGkjIyMpXG4gKiDkuIvpnaLmmK/nu5PngrnlpKflsI/kuLox55qE6ZO+6KGoXG4gKiBoZWFkIC0tPiAoYSkgLS0+IChiKSAtLT4gKGMpIC0tPiAuLi4gLS0+IChpKVxuICpcbiAqIOW9k+e7k+eCueWkp+Wwj+Wkp+S6jjHml7bvvIznlLHkuo7kuLLplb/kuI3kuIDlrprmmK/nu5PngrnlpKflsI/nmoTmlbTlgI3mlbDvvIzliJnpk77ooajkuK3nmoTmnIDlkI7kuIDkuKrnu5PngrnkuI3kuIDlrprlhajooqvkuLLlgLzljaDmu6HvvIzmraTml7bpgJrluLjooaXkuIrigJwj4oCd5oiW5YW25a6D6Z2e5Liy5YC85a2X56ym44CCXG4gKiDkuLrkuobkvr/kuo7ov5vooYzkuLLnmoTmk43kvZzvvIzlvZPku6Xpk77ooajlrZjlgqjkuLLlgLzml7bvvIzpmaTlpLTmjIfpkojlpJbov5jlj6/pmYTorr7kuIDkuKrlsL7mjIfpkojmjIfnpLrpk77ooajkuK3nmoTmnIDlkI7kuIDkuKrnu5PngrnvvIzlubbnu5nlh7rlvZPliY3kuLLnmoTplb/luqbvvIznp7DlpoLmraTlrprkuYnnmoTkuLLlrZjlgqjnu5PmnoTkuLrlnZfpk77nu5PmnoTjgIJcbiAqXG4gKiDnlLHkuo7kuIDoiKzmg4XlhrXkuIvvvIzlr7nkuLLov5vooYzmk43kvZzml7bvvIzlj6rpnIDopoHku47lpLTlkJHlsL7pobrluo/miavmj4/ljbPlj6/vvIzliJnlr7nkuLLlgLzkuI3lv4Xlu7rnq4vlj4zlkJHpk77ooajjgILorr7lsL7mjIfpkojnmoTnm67nmoTmmK/kuLrkuobkvr/kuo7ov5vooYzov57mjqXmk43kvZzvvIzkvYblupTms6jmhI/ov57mjqXml7bpnIDlpITnkIbnrKzkuIDkuKrkuLLlsL7nmoTml6DmlYjlrZfnrKbjgIJcbiAqIOWcqOmTvuW8j+WtmOWCqOaWueW8j+S4re+8jOe7k+eCueWkp+Wwj+eahOmAieaLqeWSjOmhuuW6j+WtmOWCqOaWueW8j+eahOagvOW8j+mAieaLqeS4gOagt+mDveW+iOmHjeimge+8jOWug+ebtOaOpeW9seWTjeWIsOS4suWkhOeQhueahOaViOeOh+OAguWmguaenOS4suW+iOmVv++8jOi/meimgeaxguaIkeS7rOiAg+iZkeS4suWAvOeahOWtmOWCqOWvhuW6pu+8mlxuICog5a2Y5YKo5a+G5bqmID0g5Liy5YC85omA5Y2g55qE5a2Y5YKo5L2NIC8g5a6e6ZmF5YiG6YWN55qE5a2Y5YKo5L2NXG4gKlxuICog5Liy5YC855qE6ZO+5byP5a2Y5YKo57uT5p6E5a+55p+Q5Lqb5Liy5pON5L2c77yM5aaC6L+e5o6l5pON5L2c562J5pyJ5LiA5a6a5pa55L6/5LmL5aSE77yM5L2G5oC755qE5p2l6K+05LiN5aaC5Y+m5aSW5Lik56eN5a2Y5YKo57uT5p6E54G15rS777yM5a6D5Y2g55So5a2Y5YKo6YeP5aSn5LiU5pON5L2c5aSN5p2C44CCXG4gKi9cbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XG5cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihjaHVua1NpemUgPSA0KSB7XG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmNoID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua1NpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaFtpXSA9ICcjJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlOiBDaHVua1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IoY2h1bmtTaXplID0gNCkge1xuICAgICAgICAvLyB0eXBlIENodW5rXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIC8vIHR5cGU6IGNodW5rXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIC8vIOS4sueahOW9k+WJjemVv+W6plxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIOWwhuWtl+espuS4sui9rOaNouaIkExTdHJpbmfnsbvlnotcbiAgICBzdHJBc3NpZ24gKGNoYXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hhcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnQuY2hbaSAlIHRoaXMuY2h1bmtTaXplXSA9IGNoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuICYmIChpICsgMSkgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IG5ldyBDaHVuaygpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50O1xuICAgIH1cbiAgICAvLyDlrZfnrKbkuLLlr7nmr5RcbiAgICAvLyBUT0RPIOaYr+WQpuWOu+aOiWNodW5rU2l6ZeeahOWvueavlFxuICAgIHN0ckNvbXBhcmUgKHRMU3RyaW5nKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBsZXQgY3VyVCA9IHRMU3RyaW5nLmhlYWQ7XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB0TFN0cmluZy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hbaV0gIT09IGN1clQuY2hbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGN1clQgPSBjdXJULm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXJTdHJpbmcgKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGNvbmNhdCAodExTdGluZykge1xuICAgICAgICBpZiAoIXRMU3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHJldCA9IG5ldyBMU3RyaW5nKHRoaXMuY2h1bmtTaXplKTtcblxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdExTdGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQuaGVhZCA9IHJldC50YWlsID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcbiAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0aGlzKTtcblxuICAgICAgICAgICAgbGV0IGluZGV4ID0gcmV0LnRhaWwuY2guaW5kZXhPZignIycpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0TFN0aW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcsIHJldC50YWlsLCB0TFN0aW5nLmhlYWQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHN1YnN0cmluZyAocG9zLCBsZW4pIHtcbiAgICAgICAgcG9zID0gfn5wb3MgfHwgMDtcbiAgICAgICAgbGVuID0gfn5sZW4gfHwgdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoIC0gMSB8fCBsZW4gPCAwIHx8IGxlbiA+IHRoaXMubGVuZ3RoIC0gcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBhcmFtZXRlcicpO1xuXG4gICAgICAgIGxldCBzdWIgPSBuZXcgTFN0cmluZyh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gZmluZFBvc0NodW5rKHRoaXMsIHBvcyk7XG4gICAgICAgIGxldCBjdXJTID0gc3ViLmhlYWQgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHN1Yi5sZW5ndGggPSBsZW47XG5cbiAgICAgICAgb3V0ZXJsb29wOiB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHNpemUgPSB0aGlzLmNodW5rU2l6ZTsgaiA8IHNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXJsb29wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1clMuY2hbal0gPSBjdXJyZW50LmNoWyhpICsgcG9zKSAlIHRoaXMuY2h1bmtTaXplXTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyBwb3MpICUgdGhpcy5jaHVua1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCAmJiAoY3VycmVudC5jaFtpXSB8fCBjdXJyZW50Lm5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTLm5leHQgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyUyA9IGN1clMubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5jaHVua1NpemU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IGN1cnJlbnQuY2hbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY3VycmVudC5jaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQb3NDaHVuayhsU3RyaW5nLCBwb3MpIHtcbiAgICBsZXQgY3VycmVudCA9IGxTdHJpbmcuaGVhZDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbFN0cmluZy5jaHVua1NpemU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvcy0tID09PSAwKSByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29weVN0cmluZyhkZXN0aW5hdGlvbiwgdGFyZ2V0LCBjdXJELCBjdXJyVCwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgY3VyclQgPSBjdXJyVCB8fCB0YXJnZXQuaGVhZDtcbiAgICBjdXJEID0gY3VyRCB8fCBkZXN0aW5hdGlvbi5oZWFkO1xuICAgIGxldCBrID0gMDtcblxuICAgIHdoaWxlIChjdXJyVCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGFyZ2V0LmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrLCBrKyspIHtcbiAgICAgICAgICAgIGxldCBqID0gayAlIGN1ckQuY2h1bmtTaXplICsgb2Zmc2V0O1xuICAgICAgICAgICAgY3VyRC5jaFtqICUgY3VyRC5jaHVua1NpemVdID0gY3VyclQuY2hbaV07XG5cbiAgICAgICAgICAgIGlmICgoaiArIDEpICUgY3VyRC5jaHVua1NpemUgPT09IDAgJiYgKGN1cnJULmNoW2kgKyAxXSB8fCBjdXJyVC5uZXh0KSkge1xuICAgICAgICAgICAgICAgIGN1ckQubmV4dCA9IG5ldyBDaHVuayhkZXN0aW5hdGlvbi5jaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIGN1ckQgPSBjdXJELm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyVCA9IGN1cnJULm5leHQ7XG4gICAgfVxuXG4gICAgZGVzdGluYXRpb24udGFpbCA9IGN1ckQ7XG4gICAgZGVzdGluYXRpb24ubGVuZ3RoICs9IHRhcmdldC5sZW5ndGg7XG59XG5cbmxldCBhID0gbmV3IExTdHJpbmcoKTtcbmxldCBiID0gbmV3IExTdHJpbmcoKTtcbmxldCBjID0gbmV3IExTdHJpbmcoKTtcblxuYS5zdHJBc3NpZ24oJ2FiY2RlZmcnKTtcbmNvbnNvbGUubG9nKGEgKyAnJyk7XG5iLnN0ckFzc2lnbignaGlqa2xtbm8nKTtcbmNvbnNvbGUubG9nKGIgKyAnJyk7XG5jLnN0ckFzc2lnbignYWJjZGVmZycpO1xuY29uc29sZS5sb2coYS5zdHJDb21wYXJlKGIpKTtcbmNvbnNvbGUubG9nKGEuc3RyQ29tcGFyZShjKSk7XG5sZXQgdCA9IGEuY29uY2F0KGIpO1xuY29uc29sZS5sb2codCArICcnKTtcbnQgPSB0LnN1YnN0cmluZygyLCA1KTtcbmNvbnNvbGUubG9nKHQgKyAnJyk7XG5cblxuLy8g5Yik5pat5piv5ZCm5Li65Zue5paH5a2X56ym5LiyXG5mdW5jdGlvbiBwYWxpbmRyb21lKGxTdHIpIHtcbiAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBsZXQgcCA9IGxTdHIuaGVhZDtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKGxldCBrID0gMTsgayA8PSBsU3RyLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGlmIChrIDw9IGxTdHIubGVuZ3RoIC8gMikgc3RhY2sucHVzaChwLmNoW2ldKTtcbiAgICAgICAgZWxzZSBpZiAoayA+IChsU3RyLmxlbmd0aCArIDEpIC8gMikge1xuICAgICAgICAgICAgbGV0IGMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwLmNoW2ldICE9PSBjKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKytpID09PSBsU3RyLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1N0cmluZy9MU3RyaW5nLmpzIiwiLyoqXG4gKiDkuLLvvIhzdHJpbmfvvInvvIjmiJblrZfnrKbkuLLvvInmmK/nlLHpm7bkuKrmiJblpJrkuKrlrZfnrKbnu4TmiJDnmoTmnInpmZDluo/liJfjgILkuLLkuK3lrZfnrKbnmoTmlbDnm67np7DkuLrkuLLnmoTplb/luqbjgILpm7bkuKrlrZfnrKbnmoTkuLLnp7DkuLrnqbrkuLLvvIhudWxsIHN0cmluZ++8ie+8jOWug+eahOmVv+W6puS4uumbtuOAglxuICog5Liy5Lit5Lu75oSP5Liq6L+e57ut55qE5a2X56ym57uE5oiQ55qE5a2Q5bqP5YiX56ew5Li66K+l5Liy55qE5a2Q5Liy44CC5YyF5ZCr5a2Q5Liy55qE5Liy55u45bqU5Zyw56ew5Li65Li75Liy44CC6YCa5bi456ew5a2X56ym5Zyo5bqP5YiX5Lit55qE5bqP5Y+35Li66K+l5a2X56ym5Zyo5Liy5Lit55qE5L2N572u44CC5a2Q5Liy5Zyo5Li75Liy5Lit55qE5L2N572u5YiZ5Lul5a2Q5Liy55qE56ys5LiA5Liq5a2X56ym5Zyo5Li75Liy5Lit55qE5L2N572u5p2l6KGo56S644CCXG4gKiDlj6rmnInlvZPkuKTkuKrkuLLnmoTplb/luqbnm7jnrYnvvIzlubbkuJTlkITkuKrlr7nlupTkvY3nva7nmoTlrZfnrKbpg73nm7jnrYnml7bmiY3nm7jnrYnjgIJcbiAqXG4gKiDkuLLmnIkz56eN5py65YaF6KGo56S65pa55rOV77yaXG4gKiAxLuWumumVv+mhuuW6j+WtmOWCqOihqOekulxuICogMi7loIbliIbphY3lrZjlgqjooajnpLpcbiAqIDMu5Liy55qE5Z2X6ZO+5a2Y5YKo6KGo56S6XG4gKi9cblxuLyoqXG4gKiDlrprplb/pobrluo/lrZjlgqjooajnpLpcbiAqIOexu+S8vOS6jue6v+aAp+ihqOeahOmhuuW6j+WtmOWCqOe7k+aehO+8jOeUqOS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+WtmOWCqOS4suWAvOW+l+Wtl+espuW6j+WIl+OAguWcqOS4sueahOWumumVv+mhuuW6j+WtmOWCqOe7k+aehOS4re+8jOaMieeFp+mihOWumuS5ieeahOWkp+Wwj++8jOS4uuavj+S4quWumuS5ieeahOS4suWPmOmHj+WIhumFjeS4gOS4quWbuuWumumVv+W6pueahOWtmOWCqOWMuu+8jOWImeWPr+eUqOWumumVv+aVsOe7hOadpeaPj+i/sOOAglxuICog5Lul5LiL5qCH5Li6MOeahOaVsOe7hOWIhumHj+WtmOaUvuS4sueahOWunumZhemVv+W6puOAglxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKHN0cil7XG4gICAgICAgIHRoaXMuTUFYU1RSTEVOID0gMTA7XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIHRoaXNbMF0gPSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHN0cltpIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDov5Tlm57nlLFzMeWSjHMy6L+e5o6l6ICM5oiQ55qE5paw5LiyXG4gICAgY29uY2F0IChzMikge1xuICAgICAgICBsZXQgdCA9IG5ldyBTU3RyaW5nKCk7XG4gICAgICAgIC8vIOacquaIquaWrVxuICAgICAgICBpZiAodGhpc1swXSArIHMyWzBdIDw9IHRoaXMuTUFYU1RSTEVOKSB7XG4gICAgICAgICAgICBjb3B5U3RyMlQodGhpcyk7XG4gICAgICAgICAgICBjb3B5U3RyMlQoczIsIHRoaXNbMF0pO1xuICAgICAgICAgICAgdFswXSA9IHRoaXNbMF0gKyBzMlswXTtcblxuICAgICAgICAgICAgLy8g5oiq5patXG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1swXSA8IHRoaXMuTUFYU1RSTEVOKSB7XG4gICAgICAgICAgICBjb3B5U3RyMlQodGhpcyk7XG4gICAgICAgICAgICBjb3B5U3RyMlQoczIsIHRoaXNbMF0sIHRoaXMuTUFYU1RSTEVOIC0gdGhpc1swXSk7XG4gICAgICAgICAgICB0WzBdID0gdGhpcy5NQVhTVFJMRU47XG5cbiAgICAgICAgICAgIC8vIOaIquaWre+8iOS7heWPlnMx77yJXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3B5U3RyMlQodGhpcywgMCwgdGhpcy5NQVhTVFJMRU4pO1xuICAgICAgICAgICAgdFswXSA9IHRoaXNbMF0gPSB0aGlzLk1BWFNUUkxFTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvcHlTdHIyVChzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyWzBdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gZW5kIHx8IHN0clswXTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRbc3RhcnQgKyBpXSA9IHN0cltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzdHJpbmcgKHBvc2l0aW9uID0gMCwgbGVuID0gdGhpc1swXSkge1xuICAgICAgICBwb3NpdGlvbiA9IH5+cG9zaXRpb247XG4gICAgICAgIGxlbiA9IH5+bGVuO1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpc1swXSAtIDEgfHwgbGVuIDwgMCB8fCBsZW4gPiB0aGlzWzBdIC0gcG9zaXRpb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgbGV0IHN1YiA9IG5ldyBTU3RyaW5nKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzdWJbaV0gPSB0aGlzW3Bvc2l0aW9uICsgaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHN1YlswXSA9IGxlbjtcblxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWwhuS4snPkuK3nmoTlrZDkuLJ05pu/5o2i5Li6du+8jOi/lOWbnuabv+aNouasoeaVsFxuICAgICAqIHRvZG8gdG8gYmUgdGVzdGVkXG4gICAgICogQHBhcmFtIHtTU3RyaW5nfSB0XG4gICAgICogQHBhcmFtIHtTU3RyaW5nfSB2XG4gICAgICogQHJldHVybnMge251bWJlcn0g5pu/5o2i5qyh5pWwXG4gICAgICovXG4gICAgcmVwbGFjZSAodCwgdikge1xuICAgICAgICBmb3IgKGxldCBuID0gMCwgaSA9IDE7IGkgPD0gdGhpc1swXSAtIHRbMF0gKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpLCBrID0gMTsgdFtrXSAmJiB0aGlzW2pdID09PSB0W2tdOyArK2osICsrayk7XG5cbiAgICAgICAgICAgIC8vIOaJvuWIsOS6huS4jnTljLnphY3nmoTlrZfkuLLvvJrliIbkuInnp43mg4XlhrXlpITnkIZcbiAgICAgICAgICAgIGlmIChrID4gdFswXSkge1xuICAgICAgICAgICAgICAgIGxldCBsO1xuICAgICAgICAgICAgICAgIC8vIOaWsOWtl+S4sueahOmVv+W6puS4juWOn+WtkOS4suebuOWQjOaXtu+8jOebtOaOpeabv+aNolxuICAgICAgICAgICAgICAgIGlmICh0WzBdID09PSB2WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDE7IGwgPD0gdFswXTsgKytsKSB0aGlzW2kgKyBsIC0gMV0gPSB2W2xdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDmlrDlrZDkuLLplb/luqblpKfkuo7ljp/lrZDkuLLml7bvvIzlhYjlsIblkI7pg6jlj7Pnp7tcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0WzBdIDwgdlswXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSB0aGlzWzBdOyBsID49IGkgKyB0WzBdOyAtLWwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2wgKyB2WzBdIC0gdFswXV0gPSB0aGlzW2xdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDE7IGwgPD0gdlswXTsgKytsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpICsgbCAtIDFdID0gdltsXTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDmlrDlrZDkuLLplb/luqblsI/kuo7ljp/lrZDkuLLml7bvvIzlhYjlsIblkI7pg6jlt6bnp7tcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gaSArIHZbMF07IGwgPD0gdGhpc1swXSArIHZbMF0gLSB0WzBdOyArK2wpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2xdID0gdGhpc1tsIC0gdlswXSArIHRbMF1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDE7IGwgPD0gdlswXTsgKytsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpICsgbCAtIDFdID0gdltsXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXNbMF0gPSB0aGlzWzBdIC0gdFswXSArIHZbMF07XG4gICAgICAgICAgICAgICAgaSArPSB2WzBdO1xuICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgdGhpc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICBzdHIgKz0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICAvLyDov5Tlm57lrZDkuLJzc3RyaW5n5Zyo5Li75Liy5Lit55qE56yscG9zaXRpb27kuKrlrZfnrKbkuYvlkI7nmoTkvY3nva5cbiAgICBpbmRleCAoc3N0cmluZywgcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGkgPSBwb3NpdGlvbiB8fCAxO1xuICAgICAgICBsZXQgaiA9IDE7XG5cbiAgICAgICAgd2hpbGUgKGkgPD0gdGhpc1swXSAmJiBqIDw9IHNzdHJpbmdbMF0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBzc3RyaW5nW2pdKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGkgLSBqICsgMjtcbiAgICAgICAgICAgICAgICBqID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqID4gc3N0cmluZ1swXSA/IGkgLSBzc3RyaW5nWzBdIDogLTE7XG4gICAgfVxuICAgIGttcEluZGV4IChzc3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgICBsZXQgaSA9IHBvc2l0aW9uIHx8IDE7XG4gICAgICAgIGxldCBqID0gMTtcbiAgICAgICAgbGV0IG5leHQgPSBnZXROZXh0KHNzdHJpbmcpO1xuXG4gICAgICAgIHdoaWxlIChpIDw9IHRoaXNbMF0gJiYgaiA8PSBzc3RyaW5nWzBdKSB7XG4gICAgICAgICAgICBpZiAoaiA9PT0gMCB8fCB0aGlzW2ldID09PSBzc3RyaW5nW2pdKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaiA9IG5leHRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaiA+IHNzdHJpbmdbMF0gPyBpIC0gc3N0cmluZ1swXSA6IC0xO1xuICAgIH1cblxuICAgIC8vIOaxguWMheWQq+WcqOWtl+espuS4suS4reiAjHN0cuayoeacieeahOWtl+espuS4slxuICAgIHN1YnRyYWN0IChzdHIpIHtcbiAgICAgICAgbGV0IHIgPSBuZXcgU1N0cmluZygpO1xuICAgICAgICByWzBdID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0gdGhpc1tpXTtcbiAgICAgICAgICAgIC8vIOWIpOaWreW9k+WJjeWtl+espmPmmK/lkKbnrKzkuIDmrKHlh7rnjrBcbiAgICAgICAgICAgIGxldCBqID0gMTtcbiAgICAgICAgICAgIGZvciAoOyBqIDwgaSAmJiB0aGlzW2pdICE9PSBjOyArK2opO1xuICAgICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgICAgICAvLyDliKTmlq3lvZPliY3lrZfnrKbmmK/lkKbljIXlkKvlnKhzdHLkuK1cbiAgICAgICAgICAgICAgICBsZXQgayA9IDFcbiAgICAgICAgICAgICAgICBmb3IgKDsgayA8PSBzdHJbMF0gJiYgc3RyW2tdICE9PSBjOyArK2spO1xuICAgICAgICAgICAgICAgIGlmIChrID4gc3RyWzBdKSByWysrclswXV0gPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBidWcgZXhpc3RzXG4gICAgZGVsZXRlX3N1YnN0cmluZyAoc3RyKSB7XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpc1swXSAtIHN0clswXSArIDE7ICsraSkge1xuICAgICAgICAgICAgbGV0IGogPSAxO1xuICAgICAgICAgICAgZm9yICg7IGogPD0gc3RyWzBdICYmIHRoaXNbaSArIGogLSAxXSA9PT0gc3RyW2pdOyArK2opO1xuICAgICAgICAgICAgaWYgKGogPiBzdHJbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IGk7IGsgPD0gdGhpc1swXSAtIHN0clswXTsgKytrKSB0aGlzW2tdID0gdGhpc1trICsgc3RyWzBdXTtcbiAgICAgICAgICAgICAgICB0aGlzWzBdIC09IHN0clswXTtcbiAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldE5leHQoc3N0cmluZykge1xuICAgIGxldCBpID0gMTtcbiAgICBsZXQgbmV4dCA9IHsxOiAwfTtcbiAgICBsZXQgaiA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNzdHJpbmdbMF0pIHtcbiAgICAgICAgaWYgKGogPT09IDAgfHwgc3N0cmluZ1tpXSA9PT0gc3N0cmluZ1tqXSkge1xuICAgICAgICAgICAgaWYgKHNzdHJpbmdbKytpXSAhPT0gc3N0cmluZ1srK2pdKSB7XG4gICAgICAgICAgICAgICAgbmV4dFtpXSA9IGo7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRbaV0gPSBuZXh0W2pdO1xuICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbmV4dFsrK2ldID0gKytqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaiA9IG5leHRbal07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dDtcbn1cblxubGV0IGEgPSBuZXcgU1N0cmluZygpO1xubGV0IGIgPSBuZXcgU1N0cmluZygpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBhW2kgKyAxXSA9IGkgKyAnJztcbiAgICBiW2kgKyAxXSA9IGkgKyAnJztcbn1cbmFbMF0gPSBiWzBdID0gNDtcbmxldCB0ID0gYS5jb25jYXQoYik7XG5jb25zb2xlLmxvZyh0ICsgJycpOyAgICAgICAvLyAwMTIzMDEyM1xuXG5sZXQgZCA9IG5ldyBTU3RyaW5nKCdhY2FiYWFiYWFiY2FjYWFiYycpO1xubGV0IGMgPSBuZXcgU1N0cmluZygnYWJhYWJjJyk7XG5cbmNvbnNvbGUubG9nKCdpbmRleDogJyArIGQuaW5kZXgoYykpO1xuY29uc29sZS5sb2coJ2ttcEluZGV4OiAnICsgZC5rbXBJbmRleChjKSk7XG5cbmEgPSBuZXcgU1N0cmluZygnYWJjZGVmZycpO1xuYiA9IG5ldyBTU3RyaW5nKCdhc2RmZycpO1xuY29uc29sZS5sb2coYS5zdWJ0cmFjdChiKSArICcnKTtcblxuYSA9IG5ldyBTU3RyaW5nKCdhYmNkZWZnaCcpO1xuYiA9IG5ldyBTU3RyaW5nKCdjZGVmJyk7XG5jb25zb2xlLmxvZyhhLmRlbGV0ZV9zdWJzdHJpbmcoYikgKyAnJyk7XG5jb25zb2xlLmxvZyhhICsgJycpO1xuXG4vKlxuIOWcqOmhuuW6j+WtmOWCqOe7k+aehOS4re+8jOWunueOsOS4suaTjeS9nOeahOWOn+aTjeS9nOS4uuKAnOWtl+espuS4suW6j+WIl+eahOWkjeWItuKAne+8jOaTjeS9nOaXtumXtOWkjeadguW6puWfuuS6juWkjeWItueahOWtl+espuS4suW6j+WIl+eahOmVv+W6puOAglxuIOWPpuS4gOaTjeS9nOeJueeCueaYr++8jOWmguaenOWcqOaTjeS9nOS4reWHuueOsOS4suWAvOW6j+WIl+eahOmVv+W6pui2hei/h01BWFNUUkxFTuaXtu+8jOe6puWumueUqOaIquWwvuazleWkhOeQhu+8jOi/meenjeaDheWGteS4jeS7heWcqOaxgui/nuaOpeS4suaXtuWPr+iDveWPkeeUn++8jOWcqOS4sueahOWFtuS7luaTjeS9nOS4re+8jOWmguaPkuWFpe+8jOe9ruaNouetieS5n+WPr+iDveWPkeeUn++8jOWFi+acjei/meS4quW8iueXheWUr+acieS4jemZkOWumuS4sumVv+eahOacgOWkp+mVv+W6pu+8jOWNs+WKqOaAgeWIhumFjeS4suWAvOeahOWtmOWCqOepuumXtOOAglxuICovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1N0cmluZy9TU3RyaW5nLmpzIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuLi9hc24xJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgYXBpID0gZXhwb3J0cztcblxuYXBpLmRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShuYW1lLCBib2R5KSB7XG4gIHJldHVybiBuZXcgRW50aXR5KG5hbWUsIGJvZHkpO1xufTtcblxuZnVuY3Rpb24gRW50aXR5KG5hbWUsIGJvZHkpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICB0aGlzLmRlY29kZXJzID0ge307XG4gIHRoaXMuZW5jb2RlcnMgPSB7fTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2NyZWF0ZU5hbWVkID0gZnVuY3Rpb24gY3JlYXRlTmFtZWQoYmFzZSkge1xuICB2YXIgbmFtZWQ7XG4gIHRyeSB7XG4gICAgbmFtZWQgPSByZXF1aXJlKCd2bScpLnJ1bkluVGhpc0NvbnRleHQoXG4gICAgICAnKGZ1bmN0aW9uICcgKyB0aGlzLm5hbWUgKyAnKGVudGl0eSkge1xcbicgK1xuICAgICAgJyAgdGhpcy5faW5pdE5hbWVkKGVudGl0eSk7XFxuJyArXG4gICAgICAnfSknXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG5hbWVkID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgdGhpcy5faW5pdE5hbWVkKGVudGl0eSk7XG4gICAgfTtcbiAgfVxuICBpbmhlcml0cyhuYW1lZCwgYmFzZSk7XG4gIG5hbWVkLnByb3RvdHlwZS5faW5pdE5hbWVkID0gZnVuY3Rpb24gaW5pdG5hbWVkKGVudGl0eSkge1xuICAgIGJhc2UuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB9O1xuXG4gIHJldHVybiBuZXcgbmFtZWQodGhpcyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXREZWNvZGVyID0gZnVuY3Rpb24gX2dldERlY29kZXIoZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAnZGVyJztcbiAgLy8gTGF6aWx5IGNyZWF0ZSBkZWNvZGVyXG4gIGlmICghdGhpcy5kZWNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZGVjb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZGVjb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmRlY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldERlY29kZXIoZW5jKS5kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXRFbmNvZGVyID0gZnVuY3Rpb24gX2dldEVuY29kZXIoZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAnZGVyJztcbiAgLy8gTGF6aWx5IGNyZWF0ZSBlbmNvZGVyXG4gIGlmICghdGhpcy5lbmNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZW5jb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZW5jb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmVuY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBlbmMsIC8qIGludGVybmFsICovIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmNvZGVyKGVuYykuZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9hcGkuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5FbmNvZGVyQnVmZmVyO1xudmFyIERlY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuRGVjb2RlckJ1ZmZlcjtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbi8vIFN1cHBvcnRlZCB0YWdzXG52YXIgdGFncyA9IFtcbiAgJ3NlcScsICdzZXFvZicsICdzZXQnLCAnc2V0b2YnLCAnb2JqaWQnLCAnYm9vbCcsXG4gICdnZW50aW1lJywgJ3V0Y3RpbWUnLCAnbnVsbF8nLCAnZW51bScsICdpbnQnLCAnb2JqRGVzYycsXG4gICdiaXRzdHInLCAnYm1wc3RyJywgJ2NoYXJzdHInLCAnZ2Vuc3RyJywgJ2dyYXBoc3RyJywgJ2lhNXN0cicsICdpc282NDZzdHInLFxuICAnbnVtc3RyJywgJ29jdHN0cicsICdwcmludHN0cicsICd0NjFzdHInLCAndW5pc3RyJywgJ3V0ZjhzdHInLCAndmlkZW9zdHInXG5dO1xuXG4vLyBQdWJsaWMgbWV0aG9kcyBsaXN0XG52YXIgbWV0aG9kcyA9IFtcbiAgJ2tleScsICdvYmonLCAndXNlJywgJ29wdGlvbmFsJywgJ2V4cGxpY2l0JywgJ2ltcGxpY2l0JywgJ2RlZicsICdjaG9pY2UnLFxuICAnYW55JywgJ2NvbnRhaW5zJ1xuXS5jb25jYXQodGFncyk7XG5cbi8vIE92ZXJyaWRlZCBtZXRob2RzIGxpc3RcbnZhciBvdmVycmlkZWQgPSBbXG4gICdfcGVla1RhZycsICdfZGVjb2RlVGFnJywgJ191c2UnLFxuICAnX2RlY29kZVN0cicsICdfZGVjb2RlT2JqaWQnLCAnX2RlY29kZVRpbWUnLFxuICAnX2RlY29kZU51bGwnLCAnX2RlY29kZUludCcsICdfZGVjb2RlQm9vbCcsICdfZGVjb2RlTGlzdCcsXG5cbiAgJ19lbmNvZGVDb21wb3NpdGUnLCAnX2VuY29kZVN0cicsICdfZW5jb2RlT2JqaWQnLCAnX2VuY29kZVRpbWUnLFxuICAnX2VuY29kZU51bGwnLCAnX2VuY29kZUludCcsICdfZW5jb2RlQm9vbCdcbl07XG5cbmZ1bmN0aW9uIE5vZGUoZW5jLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0ge307XG4gIHRoaXMuX2Jhc2VTdGF0ZSA9IHN0YXRlO1xuXG4gIHN0YXRlLmVuYyA9IGVuYztcblxuICBzdGF0ZS5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgc3RhdGUuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8vIFN0YXRlXG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmFyZ3MgPSBudWxsO1xuICBzdGF0ZS5yZXZlcnNlQXJncyA9IG51bGw7XG4gIHN0YXRlLmNob2ljZSA9IG51bGw7XG4gIHN0YXRlLm9wdGlvbmFsID0gZmFsc2U7XG4gIHN0YXRlLmFueSA9IGZhbHNlO1xuICBzdGF0ZS5vYmogPSBmYWxzZTtcbiAgc3RhdGUudXNlID0gbnVsbDtcbiAgc3RhdGUudXNlRGVjb2RlciA9IG51bGw7XG4gIHN0YXRlLmtleSA9IG51bGw7XG4gIHN0YXRlWydkZWZhdWx0J10gPSBudWxsO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVsbDtcbiAgc3RhdGUuY29udGFpbnMgPSBudWxsO1xuXG4gIC8vIFNob3VsZCBjcmVhdGUgbmV3IGluc3RhbmNlIG9uIGVhY2ggbWV0aG9kXG4gIGlmICghc3RhdGUucGFyZW50KSB7XG4gICAgc3RhdGUuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl93cmFwKCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxudmFyIHN0YXRlUHJvcHMgPSBbXG4gICdlbmMnLCAncGFyZW50JywgJ2NoaWxkcmVuJywgJ3RhZycsICdhcmdzJywgJ3JldmVyc2VBcmdzJywgJ2Nob2ljZScsXG4gICdvcHRpb25hbCcsICdhbnknLCAnb2JqJywgJ3VzZScsICdhbHRlcmVkVXNlJywgJ2tleScsICdkZWZhdWx0JywgJ2V4cGxpY2l0JyxcbiAgJ2ltcGxpY2l0JywgJ2NvbnRhaW5zJ1xuXTtcblxuTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgY3N0YXRlID0ge307XG4gIHN0YXRlUHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgY3N0YXRlW3Byb3BdID0gc3RhdGVbcHJvcF07XG4gIH0pO1xuICB2YXIgcmVzID0gbmV3IHRoaXMuY29uc3RydWN0b3IoY3N0YXRlLnBhcmVudCk7XG4gIHJlcy5fYmFzZVN0YXRlID0gY3N0YXRlO1xuICByZXR1cm4gcmVzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3dyYXAgPSBmdW5jdGlvbiB3cmFwKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICB0aGlzW21ldGhvZF0gPSBmdW5jdGlvbiBfd3JhcHBlZE1ldGhvZCgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgc3RhdGUuY2hpbGRyZW4ucHVzaChjbG9uZSk7XG4gICAgICByZXR1cm4gY2xvbmVbbWV0aG9kXS5hcHBseShjbG9uZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCB0aGlzKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChib2R5KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUucGFyZW50ID09PSBudWxsKTtcbiAgYm9keS5jYWxsKHRoaXMpO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlblxuICBzdGF0ZS5jaGlsZHJlbiA9IHN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9PT0gdGhpcztcbiAgfSwgdGhpcyk7XG4gIGFzc2VydC5lcXVhbChzdGF0ZS5jaGlsZHJlbi5sZW5ndGgsIDEsICdSb290IG5vZGUgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl91c2VBcmdzID0gZnVuY3Rpb24gdXNlQXJncyhhcmdzKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW4gYW5kIGFyZ3NcbiAgdmFyIGNoaWxkcmVuID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I7XG4gIH0sIHRoaXMpO1xuICBhcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuICEoYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuY2hpbGRyZW4gPT09IG51bGwpO1xuICAgIHN0YXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAvLyBSZXBsYWNlIHBhcmVudCB0byBtYWludGFpbiBiYWNrd2FyZCBsaW5rXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPSB0aGlzO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzc2VydChzdGF0ZS5hcmdzID09PSBudWxsKTtcbiAgICBzdGF0ZS5hcmdzID0gYXJncztcbiAgICBzdGF0ZS5yZXZlcnNlQXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnIHx8IGFyZy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KVxuICAgICAgICByZXR1cm4gYXJnO1xuXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gKGtleSB8IDApKVxuICAgICAgICAgIGtleSB8PSAwO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdba2V5XTtcbiAgICAgICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxufTtcblxuLy9cbi8vIE92ZXJyaWRlZCBtZXRob2RzXG4vL1xuXG5vdmVycmlkZWQuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgTm9kZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIF9vdmVycmlkZWQoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIG5vdCBpbXBsZW1lbnRlZCBmb3IgZW5jb2Rpbmc6ICcgKyBzdGF0ZS5lbmMpO1xuICB9O1xufSk7XG5cbi8vXG4vLyBQdWJsaWMgbWV0aG9kc1xuLy9cblxudGFncy5mb3JFYWNoKGZ1bmN0aW9uKHRhZykge1xuICBOb2RlLnByb3RvdHlwZVt0YWddID0gZnVuY3Rpb24gX3RhZ01ldGhvZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXNzZXJ0KHN0YXRlLnRhZyA9PT0gbnVsbCk7XG4gICAgc3RhdGUudGFnID0gdGFnO1xuXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbk5vZGUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShpdGVtKSB7XG4gIGFzc2VydChpdGVtKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS51c2UgPT09IG51bGwpO1xuICBzdGF0ZS51c2UgPSBpdGVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbiBvcHRpb25hbCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmRlZiA9IGZ1bmN0aW9uIGRlZih2YWwpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZVsnZGVmYXVsdCddID09PSBudWxsKTtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IHZhbDtcbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZXhwbGljaXQgPSBmdW5jdGlvbiBleHBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuaW1wbGljaXQgPSBmdW5jdGlvbiBpbXBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub2JqID0gZnVuY3Rpb24gb2JqKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBzdGF0ZS5vYmogPSB0cnVlO1xuXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMClcbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24ga2V5KG5ld0tleSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmtleSA9PT0gbnVsbCk7XG4gIHN0YXRlLmtleSA9IG5ld0tleTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLmFueSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5jaG9pY2UgPSBmdW5jdGlvbiBjaG9pY2Uob2JqKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuY2hvaWNlID09PSBudWxsKTtcbiAgc3RhdGUuY2hvaWNlID0gb2JqO1xuICB0aGlzLl91c2VBcmdzKE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhpdGVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUuY29udGFpbnMgPSBpdGVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIERlY29kaW5nXG4vL1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIGlucHV0LndyYXBSZXN1bHQoc3RhdGUuY2hpbGRyZW5bMF0uX2RlY29kZShpbnB1dCwgb3B0aW9ucykpO1xuXG4gIHZhciByZXN1bHQgPSBzdGF0ZVsnZGVmYXVsdCddO1xuICB2YXIgcHJlc2VudCA9IHRydWU7XG5cbiAgdmFyIHByZXZLZXkgPSBudWxsO1xuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsKVxuICAgIHByZXZLZXkgPSBpbnB1dC5lbnRlcktleShzdGF0ZS5rZXkpO1xuXG4gIC8vIENoZWNrIGlmIHRhZyBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwpIHtcbiAgICB2YXIgdGFnID0gbnVsbDtcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5leHBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmltcGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLnRhZztcblxuICAgIGlmICh0YWcgPT09IG51bGwgJiYgIXN0YXRlLmFueSkge1xuICAgICAgLy8gVHJpYWwgYW5kIEVycm9yXG4gICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIHByZXNlbnQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcmVzZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVzZW50ID0gdGhpcy5fcGVla1RhZyhpbnB1dCwgdGFnLCBzdGF0ZS5hbnkpO1xuXG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihwcmVzZW50KSlcbiAgICAgICAgcmV0dXJuIHByZXNlbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBvYmplY3Qgb24gc3RhY2tcbiAgdmFyIHByZXZPYmo7XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICBwcmV2T2JqID0gaW5wdXQuZW50ZXJPYmplY3QoKTtcblxuICBpZiAocHJlc2VudCkge1xuICAgIC8vIFVud3JhcCBleHBsaWNpdCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHRoaXMuX2RlY29kZVRhZyhpbnB1dCwgc3RhdGUuZXhwbGljaXQpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoZXhwbGljaXQpKVxuICAgICAgICByZXR1cm4gZXhwbGljaXQ7XG4gICAgICBpbnB1dCA9IGV4cGxpY2l0O1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IGlucHV0Lm9mZnNldDtcblxuICAgIC8vIFVud3JhcCBpbXBsaWNpdCBhbmQgbm9ybWFsIHZhbHVlc1xuICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5fZGVjb2RlVGFnKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZyxcbiAgICAgICAgc3RhdGUuYW55XG4gICAgICApO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoYm9keSkpXG4gICAgICAgIHJldHVybiBib2R5O1xuXG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICByZXN1bHQgPSBpbnB1dC5yYXcoc2F2ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGlucHV0ID0gYm9keTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrICYmIHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIG9wdGlvbnMudHJhY2soaW5wdXQucGF0aCgpLCBzdGFydCwgaW5wdXQubGVuZ3RoLCAndGFnZ2VkJyk7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrICYmIHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIG9wdGlvbnMudHJhY2soaW5wdXQucGF0aCgpLCBpbnB1dC5vZmZzZXQsIGlucHV0Lmxlbmd0aCwgJ2NvbnRlbnQnKTtcblxuICAgIC8vIFNlbGVjdCBwcm9wZXIgbWV0aG9kIGZvciB0YWdcbiAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgcmVzdWx0ID0gcmVzdWx0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmNob2ljZSA9PT0gbnVsbClcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKTtcblxuICAgIGlmIChpbnB1dC5pc0Vycm9yKHJlc3VsdCkpXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgLy8gRGVjb2RlIGNoaWxkcmVuXG4gICAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsICYmIHN0YXRlLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBzdGF0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIGRlY29kZUNoaWxkcmVuKGNoaWxkKSB7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSBpZ25vcmluZyBlcnJvcnMgaGVyZSwgdG8gbGV0IHBhcnNlciBjb250aW51ZSB3aXRoIG90aGVyXG4gICAgICAgIC8vIHBhcnRzIG9mIGVuY29kZWQgZGF0YVxuICAgICAgICBjaGlsZC5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERlY29kZSBjb250YWluZWQvZW5jb2RlZCBieSBzY2hlbWEsIG9ubHkgaW4gYml0IG9yIG9jdGV0IHN0cmluZ3NcbiAgICBpZiAoc3RhdGUuY29udGFpbnMgJiYgKHN0YXRlLnRhZyA9PT0gJ29jdHN0cicgfHwgc3RhdGUudGFnID09PSAnYml0c3RyJykpIHtcbiAgICAgIHZhciBkYXRhID0gbmV3IERlY29kZXJCdWZmZXIocmVzdWx0KTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS5jb250YWlucywgaW5wdXQuX3JlcG9ydGVyU3RhdGUub2JqKVxuICAgICAgICAgIC5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBvcCBvYmplY3RcbiAgaWYgKHN0YXRlLm9iaiAmJiBwcmVzZW50KVxuICAgIHJlc3VsdCA9IGlucHV0LmxlYXZlT2JqZWN0KHByZXZPYmopO1xuXG4gIC8vIFNldCBrZXlcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbCAmJiAocmVzdWx0ICE9PSBudWxsIHx8IHByZXNlbnQgPT09IHRydWUpKVxuICAgIGlucHV0LmxlYXZlS2V5KHByZXZLZXksIHN0YXRlLmtleSwgcmVzdWx0KTtcbiAgZWxzZSBpZiAocHJldktleSAhPT0gbnVsbClcbiAgICBpbnB1dC5leGl0S2V5KHByZXZLZXkpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlR2VuZXJpYyA9IGZ1bmN0aW9uIGRlY29kZUdlbmVyaWModGFnLCBpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgaWYgKHRhZyA9PT0gJ3NlcScgfHwgdGFnID09PSAnc2V0JylcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJyB8fCB0YWcgPT09ICdzZXRvZicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUxpc3QoaW5wdXQsIHRhZywgc3RhdGUuYXJnc1swXSwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBzdGF0ZS5hcmdzWzBdLCBzdGF0ZS5hcmdzWzFdLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgbnVsbCwgbnVsbCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVUaW1lKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU51bGwoaW5wdXQsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlQm9vbChpbnB1dCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUludChpbnB1dCwgc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzWzBdLCBvcHRpb25zKTtcblxuICBpZiAoc3RhdGUudXNlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIGlucHV0Ll9yZXBvcnRlclN0YXRlLm9iailcbiAgICAgICAgLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnB1dC5lcnJvcigndW5rbm93biB0YWc6ICcgKyB0YWcpO1xuICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZ2V0VXNlID0gZnVuY3Rpb24gX2dldFVzZShlbnRpdHksIG9iaikge1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgLy8gQ3JlYXRlIGFsdGVyZWQgdXNlIGRlY29kZXIgaWYgaW1wbGljaXQgaXMgc2V0XG4gIHN0YXRlLnVzZURlY29kZXIgPSB0aGlzLl91c2UoZW50aXR5LCBvYmopO1xuICBhc3NlcnQoc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuY2hpbGRyZW5bMF07XG4gIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0KSB7XG4gICAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuY2xvbmUoKTtcbiAgICBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlRGVjb2Rlcjtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVDaG9pY2UgPSBmdW5jdGlvbiBkZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2tleV07XG4gICAgdHJ5IHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgcmVzdWx0ID0geyB0eXBlOiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCB0aGlzKTtcblxuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFbmNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyQnVmZmVyKGRhdGEsIHRoaXMucmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwgJiYgc3RhdGVbJ2RlZmF1bHQnXSA9PT0gZGF0YSlcbiAgICByZXR1cm47XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2VuY29kZVZhbHVlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpO1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuO1xuXG4gIGlmICh0aGlzLl9za2lwRGVmYXVsdChyZXN1bHQsIHJlcG9ydGVyLCBwYXJlbnQpKVxuICAgIHJldHVybjtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVZhbHVlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XG5cbiAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgLy8gU2V0IHJlcG9ydGVyIHRvIHNoYXJlIGl0IHdpdGggYSBjaGlsZCBjbGFzc1xuICB0aGlzLnJlcG9ydGVyID0gcmVwb3J0ZXI7XG5cbiAgLy8gQ2hlY2sgaWYgZGF0YSBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwpXG4gICAgICBkYXRhID0gc3RhdGVbJ2RlZmF1bHQnXVxuICAgIGVsc2VcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVuY29kZSBjaGlsZHJlbiBmaXJzdFxuICB2YXIgY29udGVudCA9IG51bGw7XG4gIHZhciBwcmltaXRpdmUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmFueSkge1xuICAgIC8vIEFueXRoaW5nIHRoYXQgd2FzIGdpdmVuIGlzIHRyYW5zbGF0ZWQgdG8gYnVmZmVyXG4gICAgcmVzdWx0ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaG9pY2UpIHtcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNvbnRhaW5zKSB7XG4gICAgY29udGVudCA9IHRoaXMuX2dldFVzZShzdGF0ZS5jb250YWlucywgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICBwcmltaXRpdmUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNoaWxkcmVuKSB7XG4gICAgY29udGVudCA9IHN0YXRlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9iYXNlU3RhdGUudGFnID09PSAnbnVsbF8nKVxuICAgICAgICByZXR1cm4gY2hpbGQuX2VuY29kZShudWxsLCByZXBvcnRlciwgZGF0YSk7XG5cbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLmtleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdDaGlsZCBzaG91bGQgaGF2ZSBhIGtleScpO1xuICAgICAgdmFyIHByZXZLZXkgPSByZXBvcnRlci5lbnRlcktleShjaGlsZC5fYmFzZVN0YXRlLmtleSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgZXhwZWN0ZWQsIGJ1dCBpbnB1dCBpcyBub3Qgb2JqZWN0Jyk7XG5cbiAgICAgIHZhciByZXMgPSBjaGlsZC5fZW5jb2RlKGRhdGFbY2hpbGQuX2Jhc2VTdGF0ZS5rZXldLCByZXBvcnRlciwgZGF0YSk7XG4gICAgICByZXBvcnRlci5sZWF2ZUtleShwcmV2S2V5KTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9KTtcbiAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnc2Vxb2YnIHx8IHN0YXRlLnRhZyA9PT0gJ3NldG9mJykge1xuICAgICAgLy8gVE9ETyhpbmR1dG55KTogdGhpcyBzaG91bGQgYmUgdGhyb3duIG9uIERTTCBsZXZlbFxuICAgICAgaWYgKCEoc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzLmxlbmd0aCA9PT0gMSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVG9vIG1hbnkgYXJncyBmb3IgOiAnICsgc3RhdGUudGFnKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ3NlcW9mL3NldG9mLCBidXQgZGF0YSBpcyBub3QgQXJyYXknKTtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gICAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLmFyZ3NbMF0sIGRhdGEpLl9lbmNvZGUoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgfSwgY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuX2VuY29kZVByaW1pdGl2ZShzdGF0ZS50YWcsIGRhdGEpO1xuICAgICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgdmFyIHRhZyA9IHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWc7XG4gICAgdmFyIGNscyA9IHN0YXRlLmltcGxpY2l0ID09PSBudWxsID8gJ3VuaXZlcnNhbCcgOiAnY29udGV4dCc7XG5cbiAgICBpZiAodGFnID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXBvcnRlci5lcnJvcignVGFnIGNvdWxkIGJlIG9tbWl0ZWQgb25seSBmb3IgLnVzZSgpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZSh0YWcsIHByaW1pdGl2ZSwgY2xzLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwIGluIGV4cGxpY2l0XG4gIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUoc3RhdGUuZXhwbGljaXQsIGZhbHNlLCAnY29udGV4dCcsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVDaG9pY2UgPSBmdW5jdGlvbiBlbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2RhdGEudHlwZV07XG4gIGlmICghbm9kZSkge1xuICAgIGFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGRhdGEudHlwZSArICcgbm90IGZvdW5kIGluICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKSkpO1xuICB9XG4gIHJldHVybiBub2RlLl9lbmNvZGUoZGF0YS52YWx1ZSwgcmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uIGVuY29kZVByaW1pdGl2ZSh0YWcsIGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIHN0YXRlLnJldmVyc2VBcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBudWxsLCBudWxsKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVRpbWUoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVOdWxsKCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUludChkYXRhLCBzdGF0ZS5hcmdzICYmIHN0YXRlLnJldmVyc2VBcmdzWzBdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUJvb2woZGF0YSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdGFnOiAnICsgdGFnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc051bXN0ciA9IGZ1bmN0aW9uIGlzTnVtc3RyKHN0cikge1xuICByZXR1cm4gL15bMC05IF0qJC8udGVzdChzdHIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzUHJpbnRzdHIgPSBmdW5jdGlvbiBpc1ByaW50c3RyKHN0cikge1xuICByZXR1cm4gL15bQS1aYS16MC05ICdcXChcXClcXCssXFwtXFwuXFwvOj1cXD9dKiQvLnRlc3Qoc3RyKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9iYXNlL25vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBSZXBvcnRlcihvcHRpb25zKSB7XG4gIHRoaXMuX3JlcG9ydGVyU3RhdGUgPSB7XG4gICAgb2JqOiBudWxsLFxuICAgIHBhdGg6IFtdLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgZXJyb3JzOiBbXVxuICB9O1xufVxuZXhwb3J0cy5SZXBvcnRlciA9IFJlcG9ydGVyO1xuXG5SZXBvcnRlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJldHVybiB7IG9iajogc3RhdGUub2JqLCBwYXRoTGVuOiBzdGF0ZS5wYXRoLmxlbmd0aCB9O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5vYmogPSBkYXRhLm9iajtcbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgZGF0YS5wYXRoTGVuKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlcktleSA9IGZ1bmN0aW9uIGVudGVyS2V5KGtleSkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLnB1c2goa2V5KTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5leGl0S2V5ID0gZnVuY3Rpb24gZXhpdEtleShpbmRleCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGluZGV4IC0gMSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVLZXkgPSBmdW5jdGlvbiBsZWF2ZUtleShpbmRleCwga2V5LCB2YWx1ZSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHRoaXMuZXhpdEtleShpbmRleCk7XG4gIGlmIChzdGF0ZS5vYmogIT09IG51bGwpXG4gICAgc3RhdGUub2JqW2tleV0gPSB2YWx1ZTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5qb2luKCcvJyk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJPYmplY3QgPSBmdW5jdGlvbiBlbnRlck9iamVjdCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgcHJldiA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0ge307XG4gIHJldHVybiBwcmV2O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlT2JqZWN0ID0gZnVuY3Rpb24gbGVhdmVPYmplY3QocHJldikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBub3cgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHByZXY7XG4gIHJldHVybiBub3c7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgdmFyIGVycjtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgaW5oZXJpdGVkID0gbXNnIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbiAgaWYgKGluaGVyaXRlZCkge1xuICAgIGVyciA9IG1zZztcbiAgfSBlbHNlIHtcbiAgICBlcnIgPSBuZXcgUmVwb3J0ZXJFcnJvcihzdGF0ZS5wYXRoLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gJ1snICsgSlNPTi5zdHJpbmdpZnkoZWxlbSkgKyAnXSc7XG4gICAgfSkuam9pbignJyksIG1zZy5tZXNzYWdlIHx8IG1zZywgbXNnLnN0YWNrKTtcbiAgfVxuXG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxuICAgIHRocm93IGVycjtcblxuICBpZiAoIWluaGVyaXRlZClcbiAgICBzdGF0ZS5lcnJvcnMucHVzaChlcnIpO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUud3JhcFJlc3VsdCA9IGZ1bmN0aW9uIHdyYXBSZXN1bHQocmVzdWx0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgcmV0dXJuIHtcbiAgICByZXN1bHQ6IHRoaXMuaXNFcnJvcihyZXN1bHQpID8gbnVsbCA6IHJlc3VsdCxcbiAgICBlcnJvcnM6IHN0YXRlLmVycm9yc1xuICB9O1xufTtcblxuZnVuY3Rpb24gUmVwb3J0ZXJFcnJvcihwYXRoLCBtc2cpIHtcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5yZXRocm93KG1zZyk7XG59O1xuaW5oZXJpdHMoUmVwb3J0ZXJFcnJvciwgRXJyb3IpO1xuXG5SZXBvcnRlckVycm9yLnByb3RvdHlwZS5yZXRocm93ID0gZnVuY3Rpb24gcmV0aHJvdyhtc2cpIHtcbiAgdGhpcy5tZXNzYWdlID0gbXNnICsgJyBhdDogJyArICh0aGlzLnBhdGggfHwgJyhzaGFsbG93KScpO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVwb3J0ZXJFcnJvcik7XG5cbiAgaWYgKCF0aGlzLnN0YWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIElFIG9ubHkgYWRkcyBzdGFjayB3aGVuIHRocm93blxuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMubWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2Jhc2UvcmVwb3J0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbmV4cG9ydHMudGFnQ2xhc3MgPSB7XG4gIDA6ICd1bml2ZXJzYWwnLFxuICAxOiAnYXBwbGljYXRpb24nLFxuICAyOiAnY29udGV4dCcsXG4gIDM6ICdwcml2YXRlJ1xufTtcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWdDbGFzcyk7XG5cbmV4cG9ydHMudGFnID0ge1xuICAweDAwOiAnZW5kJyxcbiAgMHgwMTogJ2Jvb2wnLFxuICAweDAyOiAnaW50JyxcbiAgMHgwMzogJ2JpdHN0cicsXG4gIDB4MDQ6ICdvY3RzdHInLFxuICAweDA1OiAnbnVsbF8nLFxuICAweDA2OiAnb2JqaWQnLFxuICAweDA3OiAnb2JqRGVzYycsXG4gIDB4MDg6ICdleHRlcm5hbCcsXG4gIDB4MDk6ICdyZWFsJyxcbiAgMHgwYTogJ2VudW0nLFxuICAweDBiOiAnZW1iZWQnLFxuICAweDBjOiAndXRmOHN0cicsXG4gIDB4MGQ6ICdyZWxhdGl2ZU9pZCcsXG4gIDB4MTA6ICdzZXEnLFxuICAweDExOiAnc2V0JyxcbiAgMHgxMjogJ251bXN0cicsXG4gIDB4MTM6ICdwcmludHN0cicsXG4gIDB4MTQ6ICd0NjFzdHInLFxuICAweDE1OiAndmlkZW9zdHInLFxuICAweDE2OiAnaWE1c3RyJyxcbiAgMHgxNzogJ3V0Y3RpbWUnLFxuICAweDE4OiAnZ2VudGltZScsXG4gIDB4MTk6ICdncmFwaHN0cicsXG4gIDB4MWE6ICdpc282NDZzdHInLFxuICAweDFiOiAnZ2Vuc3RyJyxcbiAgMHgxYzogJ3VuaXN0cicsXG4gIDB4MWQ6ICdjaGFyc3RyJyxcbiAgMHgxZTogJ2JtcHN0cidcbn07XG5leHBvcnRzLnRhZ0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlY29kZXJzID0gZXhwb3J0cztcblxuZGVjb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbmRlY29kZXJzLnBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgREVSRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cbmZ1bmN0aW9uIFBFTURlY29kZXIoZW50aXR5KSB7XG4gIERFUkRlY29kZXIuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB0aGlzLmVuYyA9ICdwZW0nO1xufTtcbmluaGVyaXRzKFBFTURlY29kZXIsIERFUkRlY29kZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBQRU1EZWNvZGVyO1xuXG5QRU1EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgbGluZXMgPSBkYXRhLnRvU3RyaW5nKCkuc3BsaXQoL1tcXHJcXG5dKy9nKTtcblxuICB2YXIgbGFiZWwgPSBvcHRpb25zLmxhYmVsLnRvVXBwZXJDYXNlKCk7XG5cbiAgdmFyIHJlID0gL14tLS0tLShCRUdJTnxFTkQpIChbXi1dKyktLS0tLSQvO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hdGNoID0gbGluZXNbaV0ubWF0Y2gocmUpO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgaWYgKG1hdGNoWzJdICE9PSBsYWJlbClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgaWYgKG1hdGNoWzFdICE9PSAnQkVHSU4nKVxuICAgICAgICBicmVhaztcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hdGNoWzFdICE9PSAnRU5EJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbmQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BFTSBzZWN0aW9uIG5vdCBmb3VuZCBmb3I6ICcgKyBsYWJlbCk7XG5cbiAgdmFyIGJhc2U2NCA9IGxpbmVzLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKS5qb2luKCcnKTtcbiAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSBzeW1ib2xzXG4gIGJhc2U2NC5yZXBsYWNlKC9bXmEtejAtOVxcK1xcLz1dKy9naSwgJycpO1xuXG4gIHZhciBpbnB1dCA9IG5ldyBCdWZmZXIoYmFzZTY0LCAnYmFzZTY0Jyk7XG4gIHJldHVybiBERVJEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCBpbnB1dCwgb3B0aW9ucyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVuY29kZXJzID0gZXhwb3J0cztcblxuZW5jb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbmVuY29kZXJzLnBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBERVJFbmNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcblxuZnVuY3Rpb24gUEVNRW5jb2RlcihlbnRpdHkpIHtcbiAgREVSRW5jb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIHRoaXMuZW5jID0gJ3BlbSc7XG59O1xuaW5oZXJpdHMoUEVNRW5jb2RlciwgREVSRW5jb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTUVuY29kZXI7XG5cblBFTUVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBidWYgPSBERVJFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCBkYXRhKTtcblxuICB2YXIgcCA9IGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG4gIHZhciBvdXQgPSBbICctLS0tLUJFR0lOICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDY0KVxuICAgIG91dC5wdXNoKHAuc2xpY2UoaSwgaSArIDY0KSk7XG4gIG91dC5wdXNoKCctLS0tLUVORCAnICsgb3B0aW9ucy5sYWJlbCArICctLS0tLScpO1xuICByZXR1cm4gb3V0LmpvaW4oJ1xcbicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL3BlbS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQXJyYXk6IHtcbiAgICAgICAgLy8gQ3Jvc3NMaXN0OiByZXF1aXJlKCcuL0FycmF5L0Nyb3NzTGlzdCcpLmRlZmF1bHQsXG4gICAgICAgIC8vIFRTTWF0cml4OiByZXF1aXJlKCcuL0FycmF5L1RTTWF0cml4JykuZGVmYXVsdFxuICAgICAgICAvLyB0b2RvIGFycmF5IGFsZ29yaXRobXNcbiAgICB9LFxuICAgIFxuICAgIEJpbmFyeVRyZWU6IHtcbiAgICAgICAgLy8gQmluYXJ5VGhyZWFkVHJlZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRocmVhZFRyZWUnKSxcbiAgICAgICAgQmluYXJ5VHJlZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWUnKSxcbiAgICAgICAgaHVmZk1hbkNvZGluZzogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcnKS5kZWZhdWx0LFxuICAgICAgICBCaW5hcnlUcmVlQXJyYXk6IHJlcXVpcmUoJy4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlQXJyYXkuanMnKVxuICAgICAgICAvLyBNRlNldDogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL01GU2V0JyksXG4gICAgfSxcbiAgICBcbiAgICBHZW5lcmFsaXplZExpc3Q6IHJlcXVpcmUoJy4vR2VuZXJhbGl6ZWRMaXN0L0dMaXN0JykuZGVmYXVsdCxcbiAgICBcbiAgICBHcmFwaDoge1xuICAgICAgICBBZGphY2VuY3lMaXN0R3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoJykuZGVmYXVsdCxcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvQWRqYWNlbmN5TWF0cml4R3JhcGgnKS5kZWZhdWx0LFxuICAgICAgICBBTUxHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9BTUxHcmFwaCcpLmRlZmF1bHQsXG4gICAgICAgIE9MR3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvT0xHcmFwaCcpLmRlZmF1bHRcbiAgICB9LFxuICAgIFxuICAgIExpc3Q6IHtcbiAgICAgICAgRG91YmxlTGlua2VkTGlzdDogcmVxdWlyZSgnLi9MaXN0L0RvdWJsZUxpbmtlZExpc3QnKS5kZWZhdWx0LFxuICAgICAgICBMaW5lYXJMaXN0OiByZXF1aXJlKCcuL0xpc3QvTGluZWFyTGlzdCcpLFxuICAgICAgICBTdGF0aWNMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0xpc3QvU3RhdGljTGlua2VkTGlzdCcpLmRlZmF1bHQsXG4gICAgICAgIExSVUNhY2hlOiByZXF1aXJlKCcuL0xpc3QvTFJVJykuZGVmYXVsdFxuICAgIH0sXG4gICAgXG4gICAgUXVldWU6IHtcbiAgICAgICAgQ3ljbGVRdWV1ZTogcmVxdWlyZSgnLi9RdWV1ZS9DeWNsZVF1ZXVlJykuZGVmYXVsdCxcbiAgICAgICAgUHJpb3JpdHlRdWV1ZTogcmVxdWlyZSgnLi9RdWV1ZS9Qcmlvcml0eVF1ZXVlJykuZGVmYXVsdCxcbiAgICAgICAgUXVldWU6IHJlcXVpcmUoJy4vUXVldWUvUXVldWUnKS5kZWZhdWx0XG4gICAgfSxcbiAgICBcbiAgICBTZWFyY2g6IHtcbiAgICAgICAgQVZMVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQVZMVHJlZScpLFxuICAgICAgICBiaW5hcnlTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL0JpbmFyeVNlYXJjaCcpLFxuICAgICAgICBCaW5hcnlTb3J0ZWRUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlJykuZGVmYXVsdCxcbiAgICAgICAgQlBsdXNUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CUGx1c1RyZWUnKSxcbiAgICAgICAgQlRyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL0JUcmVlJyksXG4gICAgICAgIERpZ2l0YWxTZWFyY2hUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9EaWdpdGFsU2VhcmNoVHJlZScpLFxuICAgICAgICBTdWZmaXhUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9TdWZmaXhUcmVlLmpzJykuZGVmYXVsdCxcbiAgICAgICAgZmlib25hY2NpU2VhcmNoOiByZXF1aXJlKCcuL1NlYXJjaC9maWJvbmFjY2lTZWFyY2gnKS5kZWZhdWx0LFxuICAgICAgICBIYXNoVGFibGU6IHJlcXVpcmUoJy4vU2VhcmNoL0hhc2hUYWJsZScpLFxuICAgICAgICBSZWRCbGFja1RyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL1JlZEJsYWNrVHJlZScpLmRlZmF1bHQsXG4gICAgICAgIHNlcXVlbnRpYWxTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL3NlcXVlbnRpYWxTZWFyY2gnKS5kZWZhdWx0LFxuICAgICAgICBTT1NUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9TT1NUcmVlJyksXG4gICAgICAgIEJsb29tRmlsdGVyOiByZXF1aXJlKCcuL1NlYXJjaC9CbG9vbUZpbHRlcicpXG4gICAgfSxcblxuICAgIFNvcnQ6IHtcbiAgICAgICAgZGlzdHJpYnV0aW9uOiByZXF1aXJlKCcuL1NvcnQvZGlzdHJpYnV0aW9uL2luZGV4JyksXG4gICAgICAgIGV4Y2hhbmdlOiByZXF1aXJlKCcuL1NvcnQvZXhjaGFuZ2UvaW5kZXgnKSxcbiAgICAgICAgaW5zZXJ0aW9uOiByZXF1aXJlKCcuL1NvcnQvaW5zZXJ0aW9uL2luZGV4JyksXG4gICAgICAgIG1lcmdpbmc6IHJlcXVpcmUoJy4vU29ydC9tZXJnaW5nL2luZGV4JyksXG4gICAgICAgIHNlbGVjdGlvbjogcmVxdWlyZSgnLi9Tb3J0L3NlbGVjdGlvbi9pbmRleCcpXG4gICAgfSxcblxuICAgIFN0YWNrOiByZXF1aXJlKCcuL1N0YWNrL2luZGV4JykuZGVmYXVsdCxcblxuICAgIFN0cmluZzoge1xuICAgICAgICBIU3RyaW5nOiByZXF1aXJlKCcuL1N0cmluZy9IU3RyaW5nJykuZGVmYXVsdCxcbiAgICAgICAgTFN0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvTFN0cmluZycpLmRlZmF1bHQsXG4gICAgICAgIFNTdHJpbmc6IHJlcXVpcmUoJy4vU3RyaW5nL1NTdHJpbmcnKS5kZWZhdWx0XG4gICAgICAgIC8vIHRvZG8gc3RyaW5nIGFsZ29yaXRobXNcbiAgICB9LFxuXG4gICAgSGVhcDogcmVxdWlyZSgnLi9IZWFwJykuZGVmYXVsdFxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxuXG5pbmhlcml0cyhEZWNpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gRGVjaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlY2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgRGVjaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2xhc3QgPSB2b2lkIDBcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KHRoaXMuX2F1dG9wYWRkaW5nKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIHJldHVybiB1bnBhZCh0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspKVxuICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5EZWNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG4gIHJldHVybiB0aGlzXG59XG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXV0b1BhZGRpbmcpIHtcbiAgdmFyIG91dFxuICBpZiAoYXV0b1BhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVcbiAgfVxufVxuZnVuY3Rpb24gdW5wYWQgKGxhc3QpIHtcbiAgdmFyIHBhZGRlZCA9IGxhc3RbMTVdXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IHBhZGRlZCkge1xuICAgIGlmIChsYXN0WyhpICsgKDE2IC0gcGFkZGVkKSldICE9PSBwYWRkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gICAgfVxuICB9XG4gIGlmIChwYWRkZWQgPT09IDE2KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGxhc3Quc2xpY2UoMCwgMTYgLSBwYWRkZWQpXG59XG5cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvZGVjcnlwdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbmluaGVyaXRzKENpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQoKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICBjaHVuayA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHJldHVybiBjaHVua1xuICB9IGVsc2UgaWYgKGNodW5rLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwJykge1xuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5DaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE1KSB7XG4gICAgdmFyIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIHJldHVybiBudWxsXG59XG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW4gPSAxNiAtIHRoaXMuY2FjaGUubGVuZ3RoXG4gIHZhciBwYWRCdWZmID0gbmV3IEJ1ZmZlcihsZW4pXG5cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkQnVmZi53cml0ZVVJbnQ4KGxlbiwgaSlcbiAgfVxuICB2YXIgb3V0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgcGFkQnVmZl0pXG4gIHJldHVybiBvdXRcbn1cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICBpdiA9IG5ldyBCdWZmZXIoaXYpXG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gIH1cbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcbiAgfVxuICBpZiAoaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuICB9XG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9XG4gIHJldHVybiBuZXcgQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBjcmVhdGVDaXBoZXJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgemVyb3MgPSBuZXcgQnVmZmVyKDE2KVxuemVyb3MuZmlsbCgwKVxubW9kdWxlLmV4cG9ydHMgPSBHSEFTSFxuZnVuY3Rpb24gR0hBU0ggKGtleSkge1xuICB0aGlzLmggPSBrZXlcbiAgdGhpcy5zdGF0ZSA9IG5ldyBCdWZmZXIoMTYpXG4gIHRoaXMuc3RhdGUuZmlsbCgwKVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cbi8vIGZyb20gaHR0cDovL2JpdHdpc2VzaGlmdGxlZnQuZ2l0aHViLmlvL3NqY2wvZG9jL3N5bWJvbHMvc3JjL2NvcmVfZ2NtLmpzLmh0bWxcbi8vIGJ5IEp1aG8gVsOkaMOkLUhlcnR0dWFcbkdIQVNILnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBibG9jay5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YXRlW2ldIF49IGJsb2NrW2ldXG4gIH1cbiAgdGhpcy5fbXVsdGlwbHkoKVxufVxuXG5HSEFTSC5wcm90b3R5cGUuX211bHRpcGx5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgVmkgPSB0b0FycmF5KHRoaXMuaClcbiAgdmFyIFppID0gWzAsIDAsIDAsIDBdXG4gIHZhciBqLCB4aSwgbHNiX1ZpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IDEyOCkge1xuICAgIHhpID0gKHRoaXMuc3RhdGVbfn4oaSAvIDgpXSAmICgxIDw8ICg3IC0gaSAlIDgpKSkgIT09IDBcbiAgICBpZiAoeGkpIHtcbiAgICAgIC8vIFpfaSsxID0gWl9pIF4gVl9pXG4gICAgICBaaSA9IHhvcihaaSwgVmkpXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIHZhbHVlIG9mIExTQihWX2kpXG4gICAgbHNiX1ZpID0gKFZpWzNdICYgMSkgIT09IDBcblxuICAgIC8vIFZfaSsxID0gVl9pID4+IDFcbiAgICBmb3IgKGogPSAzOyBqID4gMDsgai0tKSB7XG4gICAgICBWaVtqXSA9IChWaVtqXSA+Pj4gMSkgfCAoKFZpW2ogLSAxXSAmIDEpIDw8IDMxKVxuICAgIH1cbiAgICBWaVswXSA9IFZpWzBdID4+PiAxXG5cbiAgICAvLyBJZiBMU0IoVl9pKSBpcyAxLCBWX2krMSA9IChWX2kgPj4gMSkgXiBSXG4gICAgaWYgKGxzYl9WaSkge1xuICAgICAgVmlbMF0gPSBWaVswXSBeICgweGUxIDw8IDI0KVxuICAgIH1cbiAgfVxuICB0aGlzLnN0YXRlID0gZnJvbUFycmF5KFppKVxufVxuR0hBU0gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGJ1Zl0pXG4gIHZhciBjaHVua1xuICB3aGlsZSAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICBjaHVuayA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgdGhpcy5naGFzaChjaHVuaylcbiAgfVxufVxuR0hBU0gucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gKGFibCwgYmwpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5naGFzaChCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCB6ZXJvc10sIDE2KSlcbiAgfVxuICB0aGlzLmdoYXNoKGZyb21BcnJheShbXG4gICAgMCwgYWJsLFxuICAgIDAsIGJsXG4gIF0pKVxuICByZXR1cm4gdGhpcy5zdGF0ZVxufVxuXG5mdW5jdGlvbiB0b0FycmF5IChidWYpIHtcbiAgcmV0dXJuIFtcbiAgICBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoNCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDEyKVxuICBdXG59XG5mdW5jdGlvbiBmcm9tQXJyYXkgKG91dCkge1xuICBvdXQgPSBvdXQubWFwKGZpeHVwX3VpbnQzMilcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHJldHVybiBbXG4gICAgYVswXSBeIGJbMF0sXG4gICAgYVsxXSBeIGJbMV0sXG4gICAgYVsyXSBeIGJbMl0sXG4gICAgYVszXSBeIGJbM11cbiAgXVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMvYnJvd3NlcicpXG52YXIgREVTID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1kZXMnKVxudmFyIGRlc01vZGVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1kZXMvbW9kZXMnKVxudmFyIGFlc01vZGVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMvbW9kZXMnKVxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleUxlbiwgaXZMZW5cbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIga2V5TGVuLCBpdkxlblxuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGFlc01vZGVzW3N1aXRlXS5rZXlcbiAgICBpdkxlbiA9IGFlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGRlc01vZGVzW3N1aXRlXS5rZXkgKiA4XG4gICAgaXZMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAgcmV0dXJuIGFlcy5jcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICByZXR1cm4gbmV3IERFUyh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGl2OiBpdixcbiAgICAgIG1vZGU6IHN1aXRlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwga2V5LCBpdikge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIHJldHVybiBhZXMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICByZXR1cm4gbmV3IERFUyh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGl2OiBpdixcbiAgICAgIG1vZGU6IHN1aXRlLFxuICAgICAgZGVjcnlwdDogdHJ1ZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxufVxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNyZWF0ZUNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGV4cG9ydHMuQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGV4cG9ydHMuRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXNNb2RlcykuY29uY2F0KGFlcy5nZXRDaXBoZXJzKCkpXG59XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktY2lwaGVyL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lwaGVyQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBkZXMgPSByZXF1aXJlKCdkZXMuanMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgbW9kZXMgPSB7XG4gICdkZXMtZWRlMy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZTMnOiBkZXMuRURFLFxuICAnZGVzLWVkZS1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZSc6IGRlcy5FREUsXG4gICdkZXMtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuREVTKSxcbiAgJ2Rlcy1lY2InOiBkZXMuREVTXG59XG5tb2Rlcy5kZXMgPSBtb2Rlc1snZGVzLWNiYyddXG5tb2Rlcy5kZXMzID0gbW9kZXNbJ2Rlcy1lZGUzLWNiYyddXG5tb2R1bGUuZXhwb3J0cyA9IERFU1xuaW5oZXJpdHMoREVTLCBDaXBoZXJCYXNlKVxuZnVuY3Rpb24gREVTIChvcHRzKSB7XG4gIENpcGhlckJhc2UuY2FsbCh0aGlzKVxuICB2YXIgbW9kZU5hbWUgPSBvcHRzLm1vZGUudG9Mb3dlckNhc2UoKVxuICB2YXIgbW9kZSA9IG1vZGVzW21vZGVOYW1lXVxuICB2YXIgdHlwZVxuICBpZiAob3B0cy5kZWNyeXB0KSB7XG4gICAgdHlwZSA9ICdkZWNyeXB0J1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSAnZW5jcnlwdCdcbiAgfVxuICB2YXIga2V5ID0gb3B0cy5rZXlcbiAgaWYgKG1vZGVOYW1lID09PSAnZGVzLWVkZScgfHwgbW9kZU5hbWUgPT09ICdkZXMtZWRlLWNiYycpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIGtleS5zbGljZSgwLCA4KV0pXG4gIH1cbiAgdmFyIGl2ID0gb3B0cy5pdlxuICB0aGlzLl9kZXMgPSBtb2RlLmNyZWF0ZSh7XG4gICAga2V5OiBrZXksXG4gICAgaXY6IGl2LFxuICAgIHR5cGU6IHR5cGVcbiAgfSlcbn1cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMuX2Rlcy51cGRhdGUoZGF0YSkpXG59XG5ERVMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5fZGVzLmZpbmFsKCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1kZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzWydkZXMtZWNiJ10gPSB7XG4gIGtleTogOCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1jYmMnXSA9IGV4cG9ydHMuZGVzID0ge1xuICBrZXk6IDgsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlMy1jYmMnXSA9IGV4cG9ydHMuZGVzMyA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzJ10gPSB7XG4gIGtleTogMjQsXG4gIGl2OiAwXG59XG5leHBvcnRzWydkZXMtZWRlLWNiYyddID0ge1xuICBrZXk6IDE2LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZSddID0ge1xuICBrZXk6IDE2LFxuICBpdjogMFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktZGVzL21vZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIvYWxnb3JpdGhtcy5qc29uJylcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LXNpZ24vYWxnb3MuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL3NpZ24nKVxudmFyIHZlcmlmeSA9IHJlcXVpcmUoJy4vdmVyaWZ5JylcblxudmFyIGFsZ29yaXRobXMgPSByZXF1aXJlKCcuL2FsZ29yaXRobXMuanNvbicpXG5PYmplY3Qua2V5cyhhbGdvcml0aG1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgYWxnb3JpdGhtc1trZXldLmlkID0gbmV3IEJ1ZmZlcihhbGdvcml0aG1zW2tleV0uaWQsICdoZXgnKVxuICBhbGdvcml0aG1zW2tleS50b0xvd2VyQ2FzZSgpXSA9IGFsZ29yaXRobXNba2V5XVxufSlcblxuZnVuY3Rpb24gU2lnbiAoYWxnb3JpdGhtKSB7XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdmFyIGRhdGEgPSBhbGdvcml0aG1zW2FsZ29yaXRobV1cbiAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2hUeXBlID0gZGF0YS5oYXNoXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGRhdGEuaGFzaClcbiAgdGhpcy5fdGFnID0gZGF0YS5pZFxuICB0aGlzLl9zaWduVHlwZSA9IGRhdGEuc2lnblxufVxuaW5oZXJpdHMoU2lnbiwgc3RyZWFtLldyaXRhYmxlKVxuXG5TaWduLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgZG9uZSgpXG59XG5cblNpZ24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcblxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG5TaWduLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbk1ldGhvZCAoa2V5LCBlbmMpIHtcbiAgdGhpcy5lbmQoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgdmFyIHNpZyA9IHNpZ24oaGFzaCwga2V5LCB0aGlzLl9oYXNoVHlwZSwgdGhpcy5fc2lnblR5cGUsIHRoaXMuX3RhZylcblxuICByZXR1cm4gZW5jID8gc2lnLnRvU3RyaW5nKGVuYykgOiBzaWdcbn1cblxuZnVuY3Rpb24gVmVyaWZ5IChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29yaXRobXNbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhWZXJpZnksIHN0cmVhbS5Xcml0YWJsZSlcblxuVmVyaWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgZG9uZSgpXG59XG5cblZlcmlmeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblZlcmlmeS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5TWV0aG9kIChrZXksIHNpZywgZW5jKSB7XG4gIGlmICh0eXBlb2Ygc2lnID09PSAnc3RyaW5nJykgc2lnID0gbmV3IEJ1ZmZlcihzaWcsIGVuYylcblxuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICByZXR1cm4gdmVyaWZ5KHNpZywgaGFzaCwga2V5LCB0aGlzLl9zaWduVHlwZSwgdGhpcy5fdGFnKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTaWduIChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBTaWduKGFsZ29yaXRobSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyaWZ5IChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBWZXJpZnkoYWxnb3JpdGhtKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU2lnbjogY3JlYXRlU2lnbixcbiAgVmVyaWZ5OiBjcmVhdGVWZXJpZnksXG4gIGNyZWF0ZVNpZ246IGNyZWF0ZVNpZ24sXG4gIGNyZWF0ZVZlcmlmeTogY3JlYXRlVmVyaWZ5XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG5cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIGtleSwgaGFzaFR5cGUsIHNpZ25UeXBlLCB0YWcpIHtcbiAgdmFyIHByaXYgPSBwYXJzZUtleXMoa2V5KVxuICBpZiAocHJpdi5jdXJ2ZSkge1xuICAgIC8vIHJzYSBrZXlzIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBlY2RzYSBvbmVzIGluIG9wZW5zc2xcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICAgIHJldHVybiBlY1NpZ24oaGFzaCwgcHJpdilcbiAgfSBlbHNlIGlmIChwcml2LnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICByZXR1cm4gZHNhU2lnbihoYXNoLCBwcml2LCBoYXNoVHlwZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdyc2EnICYmIHNpZ25UeXBlICE9PSAnZWNkc2EvcnNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgfVxuICBoYXNoID0gQnVmZmVyLmNvbmNhdChbdGFnLCBoYXNoXSlcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMCwgMSBdXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAxIDwgbGVuKSBwYWQucHVzaCgweGZmKVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkgcGFkLnB1c2goaGFzaFtpXSlcblxuICB2YXIgb3V0ID0gY3J0KHBhZCwgcHJpdilcbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBlY1NpZ24gKGhhc2gsIHByaXYpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHJpdi5jdXJ2ZS5qb2luKCcuJyldXG4gIGlmICghY3VydmVJZCkgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwcml2LmN1cnZlLmpvaW4oJy4nKSlcblxuICB2YXIgY3VydmUgPSBuZXcgRUMoY3VydmVJZClcbiAgdmFyIGtleSA9IGN1cnZlLmtleUZyb21Qcml2YXRlKHByaXYucHJpdmF0ZUtleSlcbiAgdmFyIG91dCA9IGtleS5zaWduKGhhc2gpXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIob3V0LnRvREVSKCkpXG59XG5cbmZ1bmN0aW9uIGRzYVNpZ24gKGhhc2gsIHByaXYsIGFsZ28pIHtcbiAgdmFyIHggPSBwcml2LnBhcmFtcy5wcml2X2tleVxuICB2YXIgcCA9IHByaXYucGFyYW1zLnBcbiAgdmFyIHEgPSBwcml2LnBhcmFtcy5xXG4gIHZhciBnID0gcHJpdi5wYXJhbXMuZ1xuICB2YXIgciA9IG5ldyBCTigwKVxuICB2YXIga1xuICB2YXIgSCA9IGJpdHMyaW50KGhhc2gsIHEpLm1vZChxKVxuICB2YXIgcyA9IGZhbHNlXG4gIHZhciBrdiA9IGdldEtleSh4LCBxLCBoYXNoLCBhbGdvKVxuICB3aGlsZSAocyA9PT0gZmFsc2UpIHtcbiAgICBrID0gbWFrZUtleShxLCBrdiwgYWxnbylcbiAgICByID0gbWFrZVIoZywgaywgcCwgcSlcbiAgICBzID0gay5pbnZtKHEpLmltdWwoSC5hZGQoeC5tdWwocikpKS5tb2QocSlcbiAgICBpZiAocy5jbXBuKDApID09PSAwKSB7XG4gICAgICBzID0gZmFsc2VcbiAgICAgIHIgPSBuZXcgQk4oMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvREVSKHIsIHMpXG59XG5cbmZ1bmN0aW9uIHRvREVSIChyLCBzKSB7XG4gIHIgPSByLnRvQXJyYXkoKVxuICBzID0gcy50b0FycmF5KClcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MCkgciA9IFsgMCBdLmNvbmNhdChyKVxuICBpZiAoc1swXSAmIDB4ODApIHMgPSBbIDAgXS5jb25jYXQocylcblxuICB2YXIgdG90YWwgPSByLmxlbmd0aCArIHMubGVuZ3RoICsgNFxuICB2YXIgcmVzID0gWyAweDMwLCB0b3RhbCwgMHgwMiwgci5sZW5ndGggXVxuICByZXMgPSByZXMuY29uY2F0KHIsIFsgMHgwMiwgcy5sZW5ndGggXSwgcylcbiAgcmV0dXJuIG5ldyBCdWZmZXIocmVzKVxufVxuXG5mdW5jdGlvbiBnZXRLZXkgKHgsIHEsIGhhc2gsIGFsZ28pIHtcbiAgeCA9IG5ldyBCdWZmZXIoeC50b0FycmF5KCkpXG4gIGlmICh4Lmxlbmd0aCA8IHEuYnl0ZUxlbmd0aCgpKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihxLmJ5dGVMZW5ndGgoKSAtIHgubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICB4ID0gQnVmZmVyLmNvbmNhdChbIHplcm9zLCB4IF0pXG4gIH1cbiAgdmFyIGhsZW4gPSBoYXNoLmxlbmd0aFxuICB2YXIgaGJpdHMgPSBiaXRzMm9jdGV0cyhoYXNoLCBxKVxuICB2YXIgdiA9IG5ldyBCdWZmZXIoaGxlbilcbiAgdi5maWxsKDEpXG4gIHZhciBrID0gbmV3IEJ1ZmZlcihobGVuKVxuICBrLmZpbGwoMClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMCBdKSkudXBkYXRlKHgpLnVwZGF0ZShoYml0cykuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gIGsgPSBjcmVhdGVIbWFjKGFsZ28sIGspLnVwZGF0ZSh2KS51cGRhdGUobmV3IEJ1ZmZlcihbIDEgXSkpLnVwZGF0ZSh4KS51cGRhdGUoaGJpdHMpLmRpZ2VzdCgpXG4gIHYgPSBjcmVhdGVIbWFjKGFsZ28sIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuICByZXR1cm4geyBrOiBrLCB2OiB2IH1cbn1cblxuZnVuY3Rpb24gYml0czJpbnQgKG9iaXRzLCBxKSB7XG4gIHZhciBiaXRzID0gbmV3IEJOKG9iaXRzKVxuICB2YXIgc2hpZnQgPSAob2JpdHMubGVuZ3RoIDw8IDMpIC0gcS5iaXRMZW5ndGgoKVxuICBpZiAoc2hpZnQgPiAwKSBiaXRzLmlzaHJuKHNoaWZ0KVxuICByZXR1cm4gYml0c1xufVxuXG5mdW5jdGlvbiBiaXRzMm9jdGV0cyAoYml0cywgcSkge1xuICBiaXRzID0gYml0czJpbnQoYml0cywgcSlcbiAgYml0cyA9IGJpdHMubW9kKHEpXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGJpdHMudG9BcnJheSgpKVxuICBpZiAob3V0Lmxlbmd0aCA8IHEuYnl0ZUxlbmd0aCgpKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihxLmJ5dGVMZW5ndGgoKSAtIG91dC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoWyB6ZXJvcywgb3V0IF0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBtYWtlS2V5IChxLCBrdiwgYWxnbykge1xuICB2YXIgdFxuICB2YXIga1xuXG4gIGRvIHtcbiAgICB0ID0gbmV3IEJ1ZmZlcigwKVxuXG4gICAgd2hpbGUgKHQubGVuZ3RoICogOCA8IHEuYml0TGVuZ3RoKCkpIHtcbiAgICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS5kaWdlc3QoKVxuICAgICAgdCA9IEJ1ZmZlci5jb25jYXQoWyB0LCBrdi52IF0pXG4gICAgfVxuXG4gICAgayA9IGJpdHMyaW50KHQsIHEpXG4gICAga3YuayA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMCBdKSkuZGlnZXN0KClcbiAgICBrdi52ID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikuZGlnZXN0KClcbiAgfSB3aGlsZSAoay5jbXAocSkgIT09IC0xKVxuXG4gIHJldHVybiBrXG59XG5cbmZ1bmN0aW9uIG1ha2VSIChnLCBrLCBwLCBxKSB7XG4gIHJldHVybiBnLnRvUmVkKEJOLm1vbnQocCkpLnJlZFBvdyhrKS5mcm9tUmVkKCkubW9kKHEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2lnblxubW9kdWxlLmV4cG9ydHMuZ2V0S2V5ID0gZ2V0S2V5XG5tb2R1bGUuZXhwb3J0cy5tYWtlS2V5ID0gbWFrZUtleVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG5cbmZ1bmN0aW9uIHZlcmlmeSAoc2lnLCBoYXNoLCBrZXksIHNpZ25UeXBlLCB0YWcpIHtcbiAgdmFyIHB1YiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwdWIudHlwZSA9PT0gJ2VjJykge1xuICAgIC8vIHJzYSBrZXlzIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBlY2RzYSBvbmVzIGluIG9wZW5zc2xcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2UgaWYgKHB1Yi50eXBlID09PSAnZHNhJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2RzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICByZXR1cm4gZHNhVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gIH1cbiAgaGFzaCA9IEJ1ZmZlci5jb25jYXQoW3RhZywgaGFzaF0pXG4gIHZhciBsZW4gPSBwdWIubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMSBdXG4gIHZhciBwYWROdW0gPSAwXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAyIDwgbGVuKSB7XG4gICAgcGFkLnB1c2goMHhmZilcbiAgICBwYWROdW0rK1xuICB9XG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSB7XG4gICAgcGFkLnB1c2goaGFzaFtpXSlcbiAgfVxuICBwYWQgPSBuZXcgQnVmZmVyKHBhZClcbiAgdmFyIHJlZCA9IEJOLm1vbnQocHViLm1vZHVsdXMpXG4gIHNpZyA9IG5ldyBCTihzaWcpLnRvUmVkKHJlZClcblxuICBzaWcgPSBzaWcucmVkUG93KG5ldyBCTihwdWIucHVibGljRXhwb25lbnQpKVxuICBzaWcgPSBuZXcgQnVmZmVyKHNpZy5mcm9tUmVkKCkudG9BcnJheSgpKVxuICB2YXIgb3V0ID0gcGFkTnVtIDwgOCA/IDEgOiAwXG4gIGxlbiA9IE1hdGgubWluKHNpZy5sZW5ndGgsIHBhZC5sZW5ndGgpXG4gIGlmIChzaWcubGVuZ3RoICE9PSBwYWQubGVuZ3RoKSBvdXQgPSAxXG5cbiAgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIG91dCB8PSBzaWdbaV0gXiBwYWRbaV1cbiAgcmV0dXJuIG91dCA9PT0gMFxufVxuXG5mdW5jdGlvbiBlY1ZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHB1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBwdWJrZXkgPSBwdWIuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleS5kYXRhXG5cbiAgcmV0dXJuIGN1cnZlLnZlcmlmeShoYXNoLCBzaWcsIHB1YmtleSlcbn1cblxuZnVuY3Rpb24gZHNhVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgcCA9IHB1Yi5kYXRhLnBcbiAgdmFyIHEgPSBwdWIuZGF0YS5xXG4gIHZhciBnID0gcHViLmRhdGEuZ1xuICB2YXIgeSA9IHB1Yi5kYXRhLnB1Yl9rZXlcbiAgdmFyIHVucGFja2VkID0gcGFyc2VLZXlzLnNpZ25hdHVyZS5kZWNvZGUoc2lnLCAnZGVyJylcbiAgdmFyIHMgPSB1bnBhY2tlZC5zXG4gIHZhciByID0gdW5wYWNrZWQuclxuICBjaGVja1ZhbHVlKHMsIHEpXG4gIGNoZWNrVmFsdWUociwgcSlcbiAgdmFyIG1vbnRwID0gQk4ubW9udChwKVxuICB2YXIgdyA9IHMuaW52bShxKVxuICB2YXIgdiA9IGcudG9SZWQobW9udHApXG4gICAgLnJlZFBvdyhuZXcgQk4oaGFzaCkubXVsKHcpLm1vZChxKSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLm11bCh5LnRvUmVkKG1vbnRwKS5yZWRQb3coci5tdWwodykubW9kKHEpKS5mcm9tUmVkKCkpXG4gICAgLm1vZChwKVxuICAgIC5tb2QocSlcbiAgcmV0dXJuIHYuY21wKHIpID09PSAwXG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUgKGIsIHEpIHtcbiAgaWYgKGIuY21wbigwKSA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbiAgaWYgKGIuY21wKHEpID49IHEpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmeVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL3ZlcmlmeS5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVsbGlwdGljID0gcmVxdWlyZSgnZWxsaXB0aWMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRUNESChjdXJ2ZSkge1xuXHRyZXR1cm4gbmV3IEVDREgoY3VydmUpO1xufTtcblxudmFyIGFsaWFzZXMgPSB7XG5cdHNlY3AyNTZrMToge1xuXHRcdG5hbWU6ICdzZWNwMjU2azEnLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHNlY3AyMjRyMToge1xuXHRcdG5hbWU6ICdwMjI0Jyxcblx0XHRieXRlTGVuZ3RoOiAyOFxuXHR9LFxuXHRwcmltZTI1NnYxOiB7XG5cdFx0bmFtZTogJ3AyNTYnLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHByaW1lMTkydjE6IHtcblx0XHRuYW1lOiAncDE5MicsXG5cdFx0Ynl0ZUxlbmd0aDogMjRcblx0fSxcblx0ZWQyNTUxOToge1xuXHRcdG5hbWU6ICdlZDI1NTE5Jyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9LFxuXHRzZWNwMzg0cjE6IHtcblx0XHRuYW1lOiAncDM4NCcsXG5cdFx0Ynl0ZUxlbmd0aDogNDhcblx0fSxcblx0c2VjcDUyMXIxOiB7XG5cdFx0bmFtZTogJ3A1MjEnLFxuXHRcdGJ5dGVMZW5ndGg6IDY2XG5cdH1cbn07XG5cbmFsaWFzZXMucDIyNCA9IGFsaWFzZXMuc2VjcDIyNHIxO1xuYWxpYXNlcy5wMjU2ID0gYWxpYXNlcy5zZWNwMjU2cjEgPSBhbGlhc2VzLnByaW1lMjU2djE7XG5hbGlhc2VzLnAxOTIgPSBhbGlhc2VzLnNlY3AxOTJyMSA9IGFsaWFzZXMucHJpbWUxOTJ2MTtcbmFsaWFzZXMucDM4NCA9IGFsaWFzZXMuc2VjcDM4NHIxO1xuYWxpYXNlcy5wNTIxID0gYWxpYXNlcy5zZWNwNTIxcjE7XG5cbmZ1bmN0aW9uIEVDREgoY3VydmUpIHtcblx0dGhpcy5jdXJ2ZVR5cGUgPSBhbGlhc2VzW2N1cnZlXTtcblx0aWYgKCF0aGlzLmN1cnZlVHlwZSApIHtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHtcblx0XHRcdG5hbWU6IGN1cnZlXG5cdFx0fTtcblx0fVxuXHR0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmVjKHRoaXMuY3VydmVUeXBlLm5hbWUpO1xuXHR0aGlzLmtleXMgPSB2b2lkIDA7XG59XG5cbkVDREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuXHR0aGlzLmtleXMgPSB0aGlzLmN1cnZlLmdlbktleVBhaXIoKTtcblx0cmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KGVuYywgZm9ybWF0KTtcbn07XG5cbkVDREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIsIGluZW5jLCBlbmMpIHtcblx0aW5lbmMgPSBpbmVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKG90aGVyKSkge1xuXHRcdG90aGVyID0gbmV3IEJ1ZmZlcihvdGhlciwgaW5lbmMpO1xuXHR9XG5cdHZhciBvdGhlclB1YiA9IHRoaXMuY3VydmUua2V5RnJvbVB1YmxpYyhvdGhlcikuZ2V0UHVibGljKCk7XG5cdHZhciBvdXQgPSBvdGhlclB1Yi5tdWwodGhpcy5rZXlzLmdldFByaXZhdGUoKSkuZ2V0WCgpO1xuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUob3V0LCBlbmMsIHRoaXMuY3VydmVUeXBlLmJ5dGVMZW5ndGgpO1xufTtcblxuRUNESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG5cdHZhciBrZXkgPSB0aGlzLmtleXMuZ2V0UHVibGljKGZvcm1hdCA9PT0gJ2NvbXByZXNzZWQnLCB0cnVlKTtcblx0aWYgKGZvcm1hdCA9PT0gJ2h5YnJpZCcpIHtcblx0XHRpZiAoa2V5W2tleS5sZW5ndGggLSAxXSAlIDIpIHtcblx0XHRcdGtleVswXSA9IDc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtleSBbMF0gPSA2O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoa2V5LCBlbmMpO1xufTtcblxuRUNESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChlbmMpIHtcblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMua2V5cy5nZXRQcml2YXRlKCksIGVuYyk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViLCBlbmMpIHtcblx0ZW5jID0gZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuXHRcdHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpO1xuXHR9XG5cdHRoaXMua2V5cy5faW1wb3J0UHVibGljKHB1Yik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuRUNESC5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2LCBlbmMpIHtcblx0ZW5jID0gZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcblx0XHRwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpO1xuXHR9XG5cdHZhciBfcHJpdiA9IG5ldyBCTihwcml2KTtcblx0X3ByaXYgPSBfcHJpdi50b1N0cmluZygxNik7XG5cdHRoaXMua2V5cy5faW1wb3J0UHJpdmF0ZShfcHJpdik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUoYm4sIGVuYywgbGVuKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShibikpIHtcblx0XHRibiA9IGJuLnRvQXJyYXkoKTtcblx0fVxuXHR2YXIgYnVmID0gbmV3IEJ1ZmZlcihibik7XG5cdGlmIChsZW4gJiYgYnVmLmxlbmd0aCA8IGxlbikge1xuXHRcdHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIobGVuIC0gYnVmLmxlbmd0aCk7XG5cdFx0emVyb3MuZmlsbCgwKTtcblx0XHRidWYgPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgYnVmXSk7XG5cdH1cblx0aWYgKCFlbmMpIHtcblx0XHRyZXR1cm4gYnVmO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NyZWF0ZS1lY2RoL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3JlYXRlLWhhc2gvaGVscGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5ybmcgPSBleHBvcnRzLnBzZXVkb1JhbmRvbUJ5dGVzID0gZXhwb3J0cy5wcm5nID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZXhwb3J0cy5IYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxuZXhwb3J0cy5jcmVhdGVIbWFjID0gZXhwb3J0cy5IbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxuXG52YXIgaGFzaGVzID0gWydzaGExJywgJ3NoYTIyNCcsICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicsICdtZDUnLCAncm1kMTYwJ10uY29uY2F0KE9iamVjdC5rZXlzKHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbi9hbGdvcycpKSlcbmV4cG9ydHMuZ2V0SGFzaGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGFzaGVzXG59XG5cbnZhciBwID0gcmVxdWlyZSgncGJrZGYyJylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1jaXBoZXInKVxuO1tcbiAgJ0NpcGhlcicsXG4gICdjcmVhdGVDaXBoZXInLFxuICAnQ2lwaGVyaXYnLFxuICAnY3JlYXRlQ2lwaGVyaXYnLFxuICAnRGVjaXBoZXInLFxuICAnY3JlYXRlRGVjaXBoZXInLFxuICAnRGVjaXBoZXJpdicsXG4gICdjcmVhdGVEZWNpcGhlcml2JyxcbiAgJ2dldENpcGhlcnMnLFxuICAnbGlzdENpcGhlcnMnXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBhZXNba2V5XVxufSlcblxudmFyIGRoID0gcmVxdWlyZSgnZGlmZmllLWhlbGxtYW4nKVxuO1tcbiAgJ0RpZmZpZUhlbGxtYW5Hcm91cCcsXG4gICdjcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAnLFxuICAnZ2V0RGlmZmllSGVsbG1hbicsXG4gICdjcmVhdGVEaWZmaWVIZWxsbWFuJyxcbiAgJ0RpZmZpZUhlbGxtYW4nXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBkaFtrZXldXG59KVxuXG52YXIgc2lnbiA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbicpXG47W1xuICAnY3JlYXRlU2lnbicsXG4gICdTaWduJyxcbiAgJ2NyZWF0ZVZlcmlmeScsXG4gICdWZXJpZnknXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBzaWduW2tleV1cbn0pXG5cbmV4cG9ydHMuY3JlYXRlRUNESCA9IHJlcXVpcmUoJ2NyZWF0ZS1lY2RoJylcblxudmFyIHB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCdwdWJsaWMtZW5jcnlwdCcpXG5cbjtbXG4gICdwdWJsaWNFbmNyeXB0JyxcbiAgJ3ByaXZhdGVFbmNyeXB0JyxcbiAgJ3B1YmxpY0RlY3J5cHQnLFxuICAncHJpdmF0ZURlY3J5cHQnXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBwdWJsaWNFbmNyeXB0W2tleV1cbn0pXG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuO1tcbiAgJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICdzb3JyeSwgJyArIG5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnLFxuICAgICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbiAgfVxufSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuXHRDLWxpa2UgdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VycyBpbiBKYXZhc2NyaXB0XG5cdENvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5cdE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKHJvb3QpIHtcblxuXHQvLyBMb2NhbCBjYWNoZSBmb3IgdHlwaWNhbCByYWRpY2VzXG5cdHZhciByYWRpeFBvd2VyQ2FjaGUgPSB7XG5cdFx0MzY6IFVJTlQzMiggTWF0aC5wb3coMzYsIDUpIClcblx0LFx0MTY6IFVJTlQzMiggTWF0aC5wb3coMTYsIDcpIClcblx0LFx0MTA6IFVJTlQzMiggTWF0aC5wb3coMTAsIDkpIClcblx0LFx0MjogIFVJTlQzMiggTWF0aC5wb3coMiwgMzApIClcblx0fVxuXHR2YXIgcmFkaXhDYWNoZSA9IHtcblx0XHQzNjogVUlOVDMyKDM2KVxuXHQsXHQxNjogVUlOVDMyKDE2KVxuXHQsXHQxMDogVUlOVDMyKDEwKVxuXHQsXHQyOiAgVUlOVDMyKDIpXG5cdH1cblxuXHQvKipcblx0ICpcdFJlcHJlc2VudHMgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8TnVtYmVyfSBsb3cgYml0cyAgICAgfCBpbnRlZ2VyIGFzIGEgc3RyaW5nIFx0XHQgfCBpbnRlZ2VyIGFzIGEgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcnxVbmRlZmluZWR9IGhpZ2ggYml0cyB8IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBcblx0ICovXG5cdGZ1bmN0aW9uIFVJTlQzMiAobCwgaCkge1xuXHRcdGlmICggISh0aGlzIGluc3RhbmNlb2YgVUlOVDMyKSApXG5cdFx0XHRyZXR1cm4gbmV3IFVJTlQzMihsLCBoKVxuXG5cdFx0dGhpcy5fbG93ID0gMFxuXHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0dGhpcy5yZW1haW5kZXIgPSBudWxsXG5cdFx0aWYgKHR5cGVvZiBoID09ICd1bmRlZmluZWQnKVxuXHRcdFx0cmV0dXJuIGZyb21OdW1iZXIuY2FsbCh0aGlzLCBsKVxuXG5cdFx0aWYgKHR5cGVvZiBsID09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIGZyb21TdHJpbmcuY2FsbCh0aGlzLCBsLCBoKVxuXG5cdFx0ZnJvbUJpdHMuY2FsbCh0aGlzLCBsLCBoKVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3Qgd2l0aCBpdHMgbG93IGFuZCBoaWdoIGJpdHNcblx0ICogQG1ldGhvZCBmcm9tQml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0c1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tQml0cyAobCwgaCkge1xuXHRcdHRoaXMuX2xvdyA9IGwgfCAwXG5cdFx0dGhpcy5faGlnaCA9IGggfCAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQzMi5wcm90b3R5cGUuZnJvbUJpdHMgPSBmcm9tQml0c1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IGZyb20gYSBudW1iZXJcblx0ICogQG1ldGhvZCBmcm9tTnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbU51bWJlciAodmFsdWUpIHtcblx0XHR0aGlzLl9sb3cgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2YWx1ZSA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnJvbU51bWJlclxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQzMl8gb2JqZWN0IGZyb20gYSBzdHJpbmdcblx0ICogQG1ldGhvZCBmcm9tU3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlZ2VyIGFzIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHMsIHJhZGl4KSB7XG5cdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQocywgcmFkaXggfHwgMTApXG5cblx0XHR0aGlzLl9sb3cgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2YWx1ZSA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZ1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQzMl8gdG8gYSBudW1iZXJcblx0ICogQG1ldGhvZCB0b051bWJlclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb252ZXJ0ZWQgVUlOVDMyXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAodGhpcy5faGlnaCAqIDY1NTM2KSArIHRoaXMuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDMyXyB0byBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGNvbnZlcnRlZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcblx0XHRyZXR1cm4gdGhpcy50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4IHx8IDEwKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR2YXIgYTAwID0gdGhpcy5fbG93ICsgb3RoZXIuX2xvd1xuXHRcdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cblx0XHRhMTYgKz0gdGhpcy5faGlnaCArIG90aGVyLl9oaWdoXG5cblx0XHR0aGlzLl9sb3cgPSBhMDAgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gYTE2ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBzdWJ0cmFjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvL1RPRE8gaW5saW5lXG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBvdGhlci5jbG9uZSgpLm5lZ2F0ZSgpIClcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgbXVsdGlwbHlcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0Lypcblx0XHRcdGEgPSBhMDAgKyBhMTZcblx0XHRcdGIgPSBiMDAgKyBiMTZcblx0XHRcdGEqYiA9IChhMDAgKyBhMTYpKGIwMCArIGIxNilcblx0XHRcdFx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMTZiMDAgKyBhMTZiMTZcblxuXHRcdFx0YTE2YjE2IG92ZXJmbG93cyB0aGUgMzJiaXRzXG5cdFx0ICovXG5cdFx0dmFyIGExNiA9IHRoaXMuX2hpZ2hcblx0XHR2YXIgYTAwID0gdGhpcy5fbG93XG5cdFx0dmFyIGIxNiA9IG90aGVyLl9oaWdoXG5cdFx0dmFyIGIwMCA9IG90aGVyLl9sb3dcblxuLyogUmVtb3ZlZCB0byBpbmNyZWFzZSBzcGVlZCB1bmRlciBub3JtYWwgY2lyY3Vtc3RhbmNlcyAoaS5lLiBub3QgbXVsdGlwbHlpbmcgYnkgMCBvciAxKVxuXHRcdC8vIHRoaXMgPT0gMCBvciBvdGhlciA9PSAxOiBub3RoaW5nIHRvIGRvXG5cdFx0aWYgKChhMDAgPT0gMCAmJiBhMTYgPT0gMCkgfHwgKGIwMCA9PSAxICYmIGIxNiA9PSAwKSkgcmV0dXJuIHRoaXNcblxuXHRcdC8vIG90aGVyID09IDAgb3IgdGhpcyA9PSAxOiB0aGlzID0gb3RoZXJcblx0XHRpZiAoKGIwMCA9PSAwICYmIGIxNiA9PSAwKSB8fCAoYTAwID09IDEgJiYgYTE2ID09IDApKSB7XG5cdFx0XHR0aGlzLl9sb3cgPSBvdGhlci5fbG93XG5cdFx0XHR0aGlzLl9oaWdoID0gb3RoZXIuX2hpZ2hcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuKi9cblxuXHRcdHZhciBjMTYsIGMwMFxuXHRcdGMwMCA9IGEwMCAqIGIwMFxuXHRcdGMxNiA9IGMwMCA+Pj4gMTZcblxuXHRcdGMxNiArPSBhMTYgKiBiMDBcblx0XHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0XHRjMTYgKz0gYTAwICogYjE2XG5cblx0XHR0aGlzLl9sb3cgPSBjMDAgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gYzE2ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZSB0d28gX1VJTlQzMl8uIFRoZSBjdXJyZW50IF9VSU5UMzJfIHN0b3JlcyB0aGUgcmVzdWx0LlxuXHQgKiBUaGUgcmVtYWluZGVyIGlzIG1hZGUgYXZhaWxhYmxlIGFzIHRoZSBfcmVtYWluZGVyXyBwcm9wZXJ0eSBvblxuXHQgKiB0aGUgX1VJTlQzMl8gb2JqZWN0LiBJdCBjYW4gYmUgbnVsbCwgbWVhbmluZyB0aGVyZSBhcmUgbm8gcmVtYWluZGVyLlxuXHQgKiBAbWV0aG9kIGRpdlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKCAob3RoZXIuX2xvdyA9PSAwKSAmJiAob3RoZXIuX2hpZ2ggPT0gMCkgKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG5cblx0XHQvLyBvdGhlciA9PSAxXG5cdFx0aWYgKG90aGVyLl9oaWdoID09IDAgJiYgb3RoZXIuX2xvdyA9PSAxKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UMzIoMClcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgPiB0aGlzOiAwXG5cdFx0aWYgKCBvdGhlci5ndCh0aGlzKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Ly8gb3RoZXIgPT0gdGhpczogMVxuXHRcdGlmICggdGhpcy5lcShvdGhlcikgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UMzIoMClcblx0XHRcdHRoaXMuX2xvdyA9IDFcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdC8vIFNoaWZ0IHRoZSBkaXZpc29yIGxlZnQgdW50aWwgaXQgaXMgaGlnaGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0dmFyIF9vdGhlciA9IG90aGVyLmNsb25lKClcblx0XHR2YXIgaSA9IC0xXG5cdFx0d2hpbGUgKCAhdGhpcy5sdChfb3RoZXIpICkge1xuXHRcdFx0Ly8gSGlnaCBiaXQgY2FuIG92ZXJmbG93IHRoZSBkZWZhdWx0IDE2Yml0c1xuXHRcdFx0Ly8gSXRzIG9rIHNpbmNlIHdlIHJpZ2h0IHNoaWZ0IGFmdGVyIHRoaXMgbG9vcFxuXHRcdFx0Ly8gVGhlIG92ZXJmbG93biBiaXQgbXVzdCBiZSBrZXB0IHRob3VnaFxuXHRcdFx0X290aGVyLnNoaWZ0TGVmdCgxLCB0cnVlKVxuXHRcdFx0aSsrXG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSByZW1haW5kZXJcblx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgcmVzdWx0IHRvIDBcblx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0dGhpcy5faGlnaCA9IDBcblx0XHRmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdF9vdGhlci5zaGlmdFJpZ2h0KDEpXG5cdFx0XHQvLyBJZiBzaGlmdGVkIGRpdmlzb3IgaXMgc21hbGxlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdFx0Ly8gdGhlbiBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBkaXZpZGVuZFxuXHRcdFx0aWYgKCAhdGhpcy5yZW1haW5kZXIubHQoX290aGVyKSApIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIuc3VidHJhY3QoX290aGVyKVxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcmVzdWx0XG5cdFx0XHRcdGlmIChpID49IDE2KSB7XG5cdFx0XHRcdFx0dGhpcy5faGlnaCB8PSAxIDw8IChpIC0gMTYpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fbG93IHw9IDEgPDwgaVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBOZWdhdGUgdGhlIGN1cnJlbnQgX1VJTlQzMl9cblx0ICogQG1ldGhvZCBuZWdhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHYgPSAoIH50aGlzLl9sb3cgJiAweEZGRkYgKSArIDFcblx0XHR0aGlzLl9sb3cgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9ICh+dGhpcy5faGlnaCArICh2ID4+PiAxNikpICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEVxdWFsc1xuXHQgKiBAbWV0aG9kIGVxXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZXF1YWxzID0gVUlOVDMyLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiAodGhpcy5fbG93ID09IG90aGVyLl9sb3cpICYmICh0aGlzLl9oaWdoID09IG90aGVyLl9oaWdoKVxuXHR9XG5cblx0LyoqXG5cdCAqIEdyZWF0ZXIgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGd0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBVSU5UMzIucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2hpZ2ggPiBvdGhlci5faGlnaCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fbG93ID4gb3RoZXIuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIExlc3MgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubGVzc1RoYW4gPSBVSU5UMzIucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2hpZ2ggPCBvdGhlci5faGlnaCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fbG93IDwgb3RoZXIuX2xvd1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgT1Jcblx0ICogQG1ldGhvZCBvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9sb3cgfD0gb3RoZXIuX2xvd1xuXHRcdHRoaXMuX2hpZ2ggfD0gb3RoZXIuX2hpZ2hcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBBTkRcblx0ICogQG1ldGhvZCBhbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyAmPSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCAmPSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE5PVFxuXHQgKiBAbWV0aG9kIG5vdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xvdyA9IH50aGlzLl9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gfnRoaXMuX2hpZ2ggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBYT1Jcblx0ICogQG1ldGhvZCB4b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyBePSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCBePSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IHJpZ2h0XG5cdCAqIEBtZXRob2Qgc2hpZnRSaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2ggPj4gKG4gLSAxNilcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIGlmIChuID09IDE2KSB7XG5cdFx0XHR0aGlzLl9sb3cgPSB0aGlzLl9oaWdoXG5cdFx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9sb3cgPSAodGhpcy5fbG93ID4+IG4pIHwgKCAodGhpcy5faGlnaCA8PCAoMTYtbikpICYgMHhGRkZGIClcblx0XHRcdHRoaXMuX2hpZ2ggPj49IG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgbGVmdFxuXHQgKiBAbWV0aG9kIHNoaWZ0TGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyBvdmVyZmxvd1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFVJTlQzMi5wcm90b3R5cGUuc2hpZnRsID0gZnVuY3Rpb24gKG4sIGFsbG93T3ZlcmZsb3cpIHtcblx0XHRpZiAobiA+IDE2KSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gdGhpcy5fbG93IDw8IChuIC0gMTYpXG5cdFx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdFx0dGhpcy5faGlnaCAmPSAweEZGRkZcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3dcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlnaCA9ICh0aGlzLl9oaWdoIDw8IG4pIHwgKHRoaXMuX2xvdyA+PiAoMTYtbikpXG5cdFx0XHR0aGlzLl9sb3cgPSAodGhpcy5fbG93IDw8IG4pICYgMHhGRkZGXG5cdFx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdFx0Ly8gT3ZlcmZsb3cgb25seSBhbGxvd2VkIG9uIHRoZSBoaWdoIGJpdHMuLi5cblx0XHRcdFx0dGhpcy5faGlnaCAmPSAweEZGRkZcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIGxlZnRcblx0ICogQG1ldGhvZCByb3RsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5yb3RsID0gZnVuY3Rpb24gKG4pIHtcblx0XHR2YXIgdiA9ICh0aGlzLl9oaWdoIDw8IDE2KSB8IHRoaXMuX2xvd1xuXHRcdHYgPSAodiA8PCBuKSB8ICh2ID4+PiAoMzIgLSBuKSlcblx0XHR0aGlzLl9sb3cgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHYgPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIHJpZ2h0XG5cdCAqIEBtZXRob2Qgcm90clxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnJvdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2ID4+PiBuKSB8ICh2IDw8ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhlIGN1cnJlbnQgX1VJTlQzMl9cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGNsb25lZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBVSU5UMzIodGhpcy5fbG93LCB0aGlzLl9oaWdoKVxuXHR9XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRCAvIFJlcXVpcmVKU1xuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFVJTlQzMlxuXHRcdH0pXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuanNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFVJTlQzMlxuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRyb290WydVSU5UMzInXSA9IFVJTlQzMlxuXHR9XG5cbn0pKHRoaXMpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3VpbnQvbGliL3VpbnQzMi5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuXHRDLWxpa2UgdW5zaWduZWQgNjQgYml0cyBpbnRlZ2VycyBpbiBKYXZhc2NyaXB0XG5cdENvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5cdE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKHJvb3QpIHtcblxuXHQvLyBMb2NhbCBjYWNoZSBmb3IgdHlwaWNhbCByYWRpY2VzXG5cdHZhciByYWRpeFBvd2VyQ2FjaGUgPSB7XG5cdFx0MTY6IFVJTlQ2NCggTWF0aC5wb3coMTYsIDUpIClcblx0LFx0MTA6IFVJTlQ2NCggTWF0aC5wb3coMTAsIDUpIClcblx0LFx0MjogIFVJTlQ2NCggTWF0aC5wb3coMiwgNSkgKVxuXHR9XG5cdHZhciByYWRpeENhY2hlID0ge1xuXHRcdDE2OiBVSU5UNjQoMTYpXG5cdCxcdDEwOiBVSU5UNjQoMTApXG5cdCxcdDI6ICBVSU5UNjQoMilcblx0fVxuXG5cdC8qKlxuXHQgKlx0UmVwcmVzZW50cyBhbiB1bnNpZ25lZCA2NCBiaXRzIGludGVnZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGhpZ2ggYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBoaWdoIGJpdHMgKDgpXG5cdCAqIG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0cyAoMzIpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIGJpdHMgKDMyKVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGludGVnZXIgYXMgYSBzdHJpbmcgXHRcdCB8IGludGVnZXIgYXMgYSBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ8VW5kZWZpbmVkfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gXG5cdCAqL1xuXHRmdW5jdGlvbiBVSU5UNjQgKGEwMCwgYTE2LCBhMzIsIGE0OCkge1xuXHRcdGlmICggISh0aGlzIGluc3RhbmNlb2YgVUlOVDY0KSApXG5cdFx0XHRyZXR1cm4gbmV3IFVJTlQ2NChhMDAsIGExNiwgYTMyLCBhNDgpXG5cblx0XHR0aGlzLnJlbWFpbmRlciA9IG51bGxcblx0XHRpZiAodHlwZW9mIGEwMCA9PSAnc3RyaW5nJylcblx0XHRcdHJldHVybiBmcm9tU3RyaW5nLmNhbGwodGhpcywgYTAwLCBhMTYpXG5cblx0XHRpZiAodHlwZW9mIGExNiA9PSAndW5kZWZpbmVkJylcblx0XHRcdHJldHVybiBmcm9tTnVtYmVyLmNhbGwodGhpcywgYTAwKVxuXG5cdFx0ZnJvbUJpdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3Qgd2l0aCBpdHMgbG93IGFuZCBoaWdoIGJpdHNcblx0ICogQG1ldGhvZCBmcm9tQml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBoaWdoIGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgaGlnaCBiaXRzICg4KVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHMgKDMyKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzICgzMilcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbUJpdHMgKGEwMCwgYTE2LCBhMzIsIGE0OCkge1xuXHRcdGlmICh0eXBlb2YgYTMyID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aGlzLl9hMDAgPSBhMDAgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9IGEwMCA+Pj4gMTZcblx0XHRcdHRoaXMuX2EzMiA9IGExNiAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTQ4ID0gYTE2ID4+PiAxNlxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHR0aGlzLl9hMDAgPSBhMDAgfCAwXG5cdFx0dGhpcy5fYTE2ID0gYTE2IHwgMFxuXHRcdHRoaXMuX2EzMiA9IGEzMiB8IDBcblx0XHR0aGlzLl9hNDggPSBhNDggfCAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQ2NC5wcm90b3R5cGUuZnJvbUJpdHMgPSBmcm9tQml0c1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IGZyb20gYSBudW1iZXJcblx0ICogQG1ldGhvZCBmcm9tTnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbU51bWJlciAodmFsdWUpIHtcblx0XHR0aGlzLl9hMDAgPSB2YWx1ZSAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IHZhbHVlID4+PiAxNlxuXHRcdHRoaXMuX2EzMiA9IDBcblx0XHR0aGlzLl9hNDggPSAwXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQ2NC5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZyb21OdW1iZXJcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCBmcm9tIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgZnJvbVN0cmluZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZWdlciBhcyBhIHN0cmluZ1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tU3RyaW5nIChzLCByYWRpeCkge1xuXHRcdHJhZGl4ID0gcmFkaXggfHwgMTBcblxuXHRcdHRoaXMuX2EwMCA9IDBcblx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblxuXHRcdC8qXG5cdFx0XHRJbiBKYXZhc2NyaXB0LCBiaXR3aXNlIG9wZXJhdG9ycyBvbmx5IG9wZXJhdGUgb24gdGhlIGZpcnN0IDMyIGJpdHMgXG5cdFx0XHRvZiBhIG51bWJlciwgZXZlbiB0aG91Z2ggcGFyc2VJbnQoKSBlbmNvZGVzIG51bWJlcnMgd2l0aCBhIDUzIGJpdHMgXG5cdFx0XHRtYW50aXNzYS5cblx0XHRcdFRoZXJlZm9yZSBVSU5UNjQoPE51bWJlcj4pIGNhbiBvbmx5IHdvcmsgb24gMzIgYml0cy5cblx0XHRcdFRoZSByYWRpeCBtYXhpbXVtIHZhbHVlIGlzIDM2IChhcyBwZXIgRUNNQSBzcGVjcykgKDI2IGxldHRlcnMgKyAxMCBkaWdpdHMpXG5cdFx0XHRtYXhpbXVtIGlucHV0IHZhbHVlIGlzIG0gPSAzMmJpdHMgYXMgMSA9IDJeMzIgLSAxXG5cdFx0XHRTbyB0aGUgbWF4aW11bSBzdWJzdHJpbmcgbGVuZ3RoIG4gaXM6XG5cdFx0XHQzNl4obisxKSAtIDEgPSAyXjMyIC0gMVxuXHRcdFx0MzZeKG4rMSkgPSAyXjMyXG5cdFx0XHQobisxKWxuKDM2KSA9IDMybG4oMilcblx0XHRcdG4gPSAzMmxuKDIpL2xuKDM2KSAtIDFcblx0XHRcdG4gPSA1LjE4OTY0NDkxNTY4NzY5MlxuXHRcdFx0biA9IDVcblx0XHQgKi9cblx0XHR2YXIgcmFkaXhVaW50ID0gcmFkaXhQb3dlckNhY2hlW3JhZGl4XSB8fCBuZXcgVUlOVDY0KCBNYXRoLnBvdyhyYWRpeCwgNSkgKVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDUpIHtcblx0XHRcdHZhciBzaXplID0gTWF0aC5taW4oNSwgbGVuIC0gaSlcblx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlSW50KCBzLnNsaWNlKGksIGkgKyBzaXplKSwgcmFkaXggKVxuXHRcdFx0dGhpcy5tdWx0aXBseShcblx0XHRcdFx0XHRzaXplIDwgNVxuXHRcdFx0XHRcdFx0PyBuZXcgVUlOVDY0KCBNYXRoLnBvdyhyYWRpeCwgc2l6ZSkgKVxuXHRcdFx0XHRcdFx0OiByYWRpeFVpbnRcblx0XHRcdFx0KVxuXHRcdFx0XHQuYWRkKCBuZXcgVUlOVDY0KHZhbHVlKSApXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDY0XyB0byBhIG51bWJlciAobGFzdCAzMiBiaXRzIGFyZSBkcm9wcGVkKVxuXHQgKiBAbWV0aG9kIHRvTnVtYmVyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbnZlcnRlZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9hMTYgKiA2NTUzNikgKyB0aGlzLl9hMDBcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQ2NF8gdG8gYSBzdHJpbmdcblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBjb252ZXJ0ZWQgVUlOVDY0XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4KSB7XG5cdFx0cmFkaXggPSByYWRpeCB8fCAxMFxuXHRcdHZhciByYWRpeFVpbnQgPSByYWRpeENhY2hlW3JhZGl4XSB8fCBuZXcgVUlOVDY0KHJhZGl4KVxuXG5cdFx0aWYgKCAhdGhpcy5ndChyYWRpeFVpbnQpICkgcmV0dXJuIHRoaXMudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblxuXHRcdHZhciBzZWxmID0gdGhpcy5jbG9uZSgpXG5cdFx0dmFyIHJlcyA9IG5ldyBBcnJheSg2NClcblx0XHRmb3IgKHZhciBpID0gNjM7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRzZWxmLmRpdihyYWRpeFVpbnQpXG5cdFx0XHRyZXNbaV0gPSBzZWxmLnJlbWFpbmRlci50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXHRcdFx0aWYgKCAhc2VsZi5ndChyYWRpeFVpbnQpICkgYnJlYWtcblx0XHR9XG5cdFx0cmVzW2ktMV0gPSBzZWxmLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cblx0XHRyZXR1cm4gcmVzLmpvaW4oJycpXG5cdH1cblxuXHQvKipcblx0ICogQWRkIHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHZhciBhMDAgPSB0aGlzLl9hMDAgKyBvdGhlci5fYTAwXG5cblx0XHR2YXIgYTE2ID0gYTAwID4+PiAxNlxuXHRcdGExNiArPSB0aGlzLl9hMTYgKyBvdGhlci5fYTE2XG5cblx0XHR2YXIgYTMyID0gYTE2ID4+PiAxNlxuXHRcdGEzMiArPSB0aGlzLl9hMzIgKyBvdGhlci5fYTMyXG5cblx0XHR2YXIgYTQ4ID0gYTMyID4+PiAxNlxuXHRcdGE0OCArPSB0aGlzLl9hNDggKyBvdGhlci5fYTQ4XG5cblx0XHR0aGlzLl9hMDAgPSBhMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBhMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSBhMzIgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBhNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3QgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIHN1YnRyYWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiB0aGlzLmFkZCggb3RoZXIuY2xvbmUoKS5uZWdhdGUoKSApXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbHkgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIG11bHRpcGx5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdC8qXG5cdFx0XHRhID0gYTAwICsgYTE2ICsgYTMyICsgYTQ4XG5cdFx0XHRiID0gYjAwICsgYjE2ICsgYjMyICsgYjQ4XG5cdFx0XHRhKmIgPSAoYTAwICsgYTE2ICsgYTMyICsgYTQ4KShiMDAgKyBiMTYgKyBiMzIgKyBiNDgpXG5cdFx0XHRcdD0gYTAwYjAwICsgYTAwYjE2ICsgYTAwYjMyICsgYTAwYjQ4XG5cdFx0XHRcdCsgYTE2YjAwICsgYTE2YjE2ICsgYTE2YjMyICsgYTE2YjQ4XG5cdFx0XHRcdCsgYTMyYjAwICsgYTMyYjE2ICsgYTMyYjMyICsgYTMyYjQ4XG5cdFx0XHRcdCsgYTQ4YjAwICsgYTQ4YjE2ICsgYTQ4YjMyICsgYTQ4YjQ4XG5cblx0XHRcdGExNmI0OCwgYTMyYjMyLCBhNDhiMTYsIGE0OGIzMiBhbmQgYTQ4YjQ4IG92ZXJmbG93IHRoZSA2NCBiaXRzXG5cdFx0XHRzbyBpdCBjb21lcyBkb3duIHRvOlxuXHRcdFx0YSpiXHQ9IGEwMGIwMCArIGEwMGIxNiArIGEwMGIzMiArIGEwMGI0OFxuXHRcdFx0XHQrIGExNmIwMCArIGExNmIxNiArIGExNmIzMlxuXHRcdFx0XHQrIGEzMmIwMCArIGEzMmIxNlxuXHRcdFx0XHQrIGE0OGIwMFxuXHRcdFx0XHQ9IGEwMGIwMFxuXHRcdFx0XHQrIGEwMGIxNiArIGExNmIwMFxuXHRcdFx0XHQrIGEwMGIzMiArIGExNmIxNiArIGEzMmIwMFxuXHRcdFx0XHQrIGEwMGI0OCArIGExNmIzMiArIGEzMmIxNiArIGE0OGIwMFxuXHRcdCAqL1xuXHRcdHZhciBhMDAgPSB0aGlzLl9hMDBcblx0XHR2YXIgYTE2ID0gdGhpcy5fYTE2XG5cdFx0dmFyIGEzMiA9IHRoaXMuX2EzMlxuXHRcdHZhciBhNDggPSB0aGlzLl9hNDhcblx0XHR2YXIgYjAwID0gb3RoZXIuX2EwMFxuXHRcdHZhciBiMTYgPSBvdGhlci5fYTE2XG5cdFx0dmFyIGIzMiA9IG90aGVyLl9hMzJcblx0XHR2YXIgYjQ4ID0gb3RoZXIuX2E0OFxuXG5cdFx0dmFyIGMwMCA9IGEwMCAqIGIwMFxuXG5cdFx0dmFyIGMxNiA9IGMwMCA+Pj4gMTZcblx0XHRjMTYgKz0gYTAwICogYjE2XG5cdFx0dmFyIGMzMiA9IGMxNiA+Pj4gMTZcblx0XHRjMTYgJj0gMHhGRkZGXG5cdFx0YzE2ICs9IGExNiAqIGIwMFxuXG5cdFx0YzMyICs9IGMxNiA+Pj4gMTZcblx0XHRjMzIgKz0gYTAwICogYjMyXG5cdFx0dmFyIGM0OCA9IGMzMiA+Pj4gMTZcblx0XHRjMzIgJj0gMHhGRkZGXG5cdFx0YzMyICs9IGExNiAqIGIxNlxuXHRcdGM0OCArPSBjMzIgPj4+IDE2XG5cdFx0YzMyICY9IDB4RkZGRlxuXHRcdGMzMiArPSBhMzIgKiBiMDBcblxuXHRcdGM0OCArPSBjMzIgPj4+IDE2XG5cdFx0YzQ4ICs9IGEwMCAqIGI0OFxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTE2ICogYjMyXG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhMzIgKiBiMTZcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGE0OCAqIGIwMFxuXG5cdFx0dGhpcy5fYTAwID0gYzAwICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gYzE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gYzMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gYzQ4ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZSB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0LlxuXHQgKiBUaGUgcmVtYWluZGVyIGlzIG1hZGUgYXZhaWxhYmxlIGFzIHRoZSBfcmVtYWluZGVyXyBwcm9wZXJ0eSBvblxuXHQgKiB0aGUgX1VJTlQ2NF8gb2JqZWN0LiBJdCBjYW4gYmUgbnVsbCwgbWVhbmluZyB0aGVyZSBhcmUgbm8gcmVtYWluZGVyLlxuXHQgKiBAbWV0aG9kIGRpdlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKCAob3RoZXIuX2ExNiA9PSAwKSAmJiAob3RoZXIuX2EzMiA9PSAwKSAmJiAob3RoZXIuX2E0OCA9PSAwKSApIHtcblx0XHRcdGlmIChvdGhlci5fYTAwID09IDApIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcblxuXHRcdFx0Ly8gb3RoZXIgPT0gMTogdGhpc1xuXHRcdFx0aWYgKG90aGVyLl9hMDAgPT0gMSkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UNjQoMClcblx0XHRcdFx0cmV0dXJuIHRoaXNcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBvdGhlciA+IHRoaXM6IDBcblx0XHRpZiAoIG90aGVyLmd0KHRoaXMpICkge1xuXHRcdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXHRcdC8vIG90aGVyID09IHRoaXM6IDFcblx0XHRpZiAoIHRoaXMuZXEob3RoZXIpICkge1xuXHRcdFx0dGhpcy5yZW1haW5kZXIgPSBuZXcgVUlOVDY0KDApXG5cdFx0XHR0aGlzLl9hMDAgPSAxXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdC8vIFNoaWZ0IHRoZSBkaXZpc29yIGxlZnQgdW50aWwgaXQgaXMgaGlnaGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0dmFyIF9vdGhlciA9IG90aGVyLmNsb25lKClcblx0XHR2YXIgaSA9IC0xXG5cdFx0d2hpbGUgKCAhdGhpcy5sdChfb3RoZXIpICkge1xuXHRcdFx0Ly8gSGlnaCBiaXQgY2FuIG92ZXJmbG93IHRoZSBkZWZhdWx0IDE2Yml0c1xuXHRcdFx0Ly8gSXRzIG9rIHNpbmNlIHdlIHJpZ2h0IHNoaWZ0IGFmdGVyIHRoaXMgbG9vcFxuXHRcdFx0Ly8gVGhlIG92ZXJmbG93biBiaXQgbXVzdCBiZSBrZXB0IHRob3VnaFxuXHRcdFx0X290aGVyLnNoaWZ0TGVmdCgxLCB0cnVlKVxuXHRcdFx0aSsrXG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSByZW1haW5kZXJcblx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgcmVzdWx0IHRvIDBcblx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0dGhpcy5fYTE2ID0gMFxuXHRcdHRoaXMuX2EzMiA9IDBcblx0XHR0aGlzLl9hNDggPSAwXG5cdFx0Zm9yICg7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRfb3RoZXIuc2hpZnRSaWdodCgxKVxuXHRcdFx0Ly8gSWYgc2hpZnRlZCBkaXZpc29yIGlzIHNtYWxsZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHRcdC8vIHRoZW4gc3VidHJhY3QgaXQgZnJvbSB0aGUgZGl2aWRlbmRcblx0XHRcdGlmICggIXRoaXMucmVtYWluZGVyLmx0KF9vdGhlcikgKSB7XG5cdFx0XHRcdHRoaXMucmVtYWluZGVyLnN1YnRyYWN0KF9vdGhlcilcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBjdXJyZW50IHJlc3VsdFxuXHRcdFx0XHRpZiAoaSA+PSA0OCkge1xuXHRcdFx0XHRcdHRoaXMuX2E0OCB8PSAxIDw8IChpIC0gNDgpXG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA+PSAzMikge1xuXHRcdFx0XHRcdHRoaXMuX2EzMiB8PSAxIDw8IChpIC0gMzIpXG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA+PSAxNikge1xuXHRcdFx0XHRcdHRoaXMuX2ExNiB8PSAxIDw8IChpIC0gMTYpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYTAwIHw9IDEgPDwgaVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBOZWdhdGUgdGhlIGN1cnJlbnQgX1VJTlQ2NF9cblx0ICogQG1ldGhvZCBuZWdhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHYgPSAoIH50aGlzLl9hMDAgJiAweEZGRkYgKSArIDFcblx0XHR0aGlzLl9hMDAgPSB2ICYgMHhGRkZGXG5cdFx0diA9ICh+dGhpcy5fYTE2ICYgMHhGRkZGKSArICh2ID4+PiAxNilcblx0XHR0aGlzLl9hMTYgPSB2ICYgMHhGRkZGXG5cdFx0diA9ICh+dGhpcy5fYTMyICYgMHhGRkZGKSArICh2ID4+PiAxNilcblx0XHR0aGlzLl9hMzIgPSB2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gKH50aGlzLl9hNDggKyAodiA+Pj4gMTYpKSAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXG5cdCAqIEBtZXRob2QgZXFcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5lcXVhbHMgPSBVSU5UNjQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9hNDggPT0gb3RoZXIuX2E0OCkgJiYgKHRoaXMuX2EwMCA9PSBvdGhlci5fYTAwKVxuXHRcdFx0ICYmICh0aGlzLl9hMzIgPT0gb3RoZXIuX2EzMikgJiYgKHRoaXMuX2ExNiA9PSBvdGhlci5fYTE2KVxuXHR9XG5cblx0LyoqXG5cdCAqIEdyZWF0ZXIgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGd0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBVSU5UNjQucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2E0OCA+IG90aGVyLl9hNDgpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2E0OCA8IG90aGVyLl9hNDgpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMzIgPiBvdGhlci5fYTMyKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMzIgPCBvdGhlci5fYTMyKSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTE2ID4gb3RoZXIuX2ExNikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTE2IDwgb3RoZXIuX2ExNikgcmV0dXJuIGZhbHNlXG5cdFx0cmV0dXJuIHRoaXMuX2EwMCA+IG90aGVyLl9hMDBcblx0fVxuXG5cdC8qKlxuXHQgKiBMZXNzIHRoYW4gKHN0cmljdClcblx0ICogQG1ldGhvZCBsdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmxlc3NUaGFuID0gVUlOVDY0LnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICh0aGlzLl9hNDggPCBvdGhlci5fYTQ4KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hNDggPiBvdGhlci5fYTQ4KSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTMyIDwgb3RoZXIuX2EzMikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTMyID4gb3RoZXIuX2EzMikgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2ExNiA8IG90aGVyLl9hMTYpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2ExNiA+IG90aGVyLl9hMTYpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9hMDAgPCBvdGhlci5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBPUlxuXHQgKiBAbWV0aG9kIG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCB8PSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2IHw9IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgfD0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCB8PSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgQU5EXG5cdCAqIEBtZXRob2QgYW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgJj0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiAmPSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyICY9IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggJj0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIFhPUlxuXHQgKiBAbWV0aG9kIHhvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwIF49IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgXj0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiBePSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4IF49IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBOT1Rcblx0ICogQG1ldGhvZCBub3Rcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hMDAgPSB+dGhpcy5fYTAwICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gfnRoaXMuX2ExNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IH50aGlzLl9hMzIgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSB+dGhpcy5fYTQ4ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgcmlnaHRcblx0ICogQG1ldGhvZCBzaGlmdFJpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBVSU5UNjQucHJvdG90eXBlLnNoaWZ0ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID49IDQ4KSB7XG5cdFx0XHR0aGlzLl9hMDAgPSB0aGlzLl9hNDggPj4gKG4gLSA0OClcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMzIpIHtcblx0XHRcdG4gLT0gMzJcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIGlmIChuID49IDE2KSB7XG5cdFx0XHRuIC09IDE2XG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMTYgPj4gbikgfCAodGhpcy5fYTMyIDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTAwID4+IG4pIHwgKHRoaXMuX2ExNiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2ExNiA+PiBuKSB8ICh0aGlzLl9hMzIgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMzIgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCBsZWZ0XG5cdCAqIEBtZXRob2Qgc2hpZnRMZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93IG92ZXJmbG93XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gVUlOVDY0LnByb3RvdHlwZS5zaGlmdGwgPSBmdW5jdGlvbiAobiwgYWxsb3dPdmVyZmxvdykge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA+PSA0OCkge1xuXHRcdFx0dGhpcy5fYTQ4ID0gdGhpcy5fYTAwIDw8IChuIC0gNDgpXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0fSBlbHNlIGlmIChuID49IDMyKSB7XG5cdFx0XHRuIC09IDMyXG5cdFx0XHR0aGlzLl9hNDggPSAodGhpcy5fYTE2IDw8IG4pIHwgKHRoaXMuX2EwMCA+PiAoMTYtbikpXG5cdFx0XHR0aGlzLl9hMzIgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0fSBlbHNlIGlmIChuID49IDE2KSB7XG5cdFx0XHRuIC09IDE2XG5cdFx0XHR0aGlzLl9hNDggPSAodGhpcy5fYTMyIDw8IG4pIHwgKHRoaXMuX2ExNiA+PiAoMTYtbikpXG5cdFx0XHR0aGlzLl9hMzIgPSAoICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hNDggPSAodGhpcy5fYTQ4IDw8IG4pIHwgKHRoaXMuX2EzMiA+PiAoMTYtbikpXG5cdFx0XHR0aGlzLl9hMzIgPSAoICh0aGlzLl9hMzIgPDwgbikgfCAodGhpcy5fYTE2ID4+ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKCAodGhpcy5fYTE2IDw8IG4pIHwgKHRoaXMuX2EwMCA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EwMCA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHR9XG5cdFx0aWYgKCFhbGxvd092ZXJmbG93KSB7XG5cdFx0XHR0aGlzLl9hNDggJj0gMHhGRkZGXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHJvdGF0ZSBsZWZ0XG5cdCAqIEBtZXRob2Qgcm90bFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUucm90YXRlTGVmdCA9IFVJTlQ2NC5wcm90b3R5cGUucm90bCA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID09IDApIHJldHVybiB0aGlzXG5cdFx0aWYgKG4gPj0gMzIpIHtcblx0XHRcdC8vIEEuQi5DLkRcblx0XHRcdC8vIEIuQy5ELkEgcm90bCgxNilcblx0XHRcdC8vIEMuRC5BLkIgcm90bCgzMilcblx0XHRcdHZhciB2ID0gdGhpcy5fYTAwXG5cdFx0XHR0aGlzLl9hMDAgPSB0aGlzLl9hMzJcblx0XHRcdHRoaXMuX2EzMiA9IHZcblx0XHRcdHYgPSB0aGlzLl9hNDhcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2ExNlxuXHRcdFx0dGhpcy5fYTE2ID0gdlxuXHRcdFx0aWYgKG4gPT0gMzIpIHJldHVybiB0aGlzXG5cdFx0XHRuIC09IDMyXG5cdFx0fVxuXG5cdFx0dmFyIGhpZ2ggPSAodGhpcy5fYTQ4IDw8IDE2KSB8IHRoaXMuX2EzMlxuXHRcdHZhciBsb3cgPSAodGhpcy5fYTE2IDw8IDE2KSB8IHRoaXMuX2EwMFxuXG5cdFx0dmFyIF9oaWdoID0gKGhpZ2ggPDwgbikgfCAobG93ID4+PiAoMzIgLSBuKSlcblx0XHR2YXIgX2xvdyA9IChsb3cgPDwgbikgfCAoaGlnaCA+Pj4gKDMyIC0gbikpXG5cblx0XHR0aGlzLl9hMDAgPSBfbG93ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gX2xvdyA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSBfaGlnaCAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IF9oaWdoID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHJvdGF0ZSByaWdodFxuXHQgKiBAbWV0aG9kIHJvdHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gVUlOVDY0LnByb3RvdHlwZS5yb3RyID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPT0gMCkgcmV0dXJuIHRoaXNcblx0XHRpZiAobiA+PSAzMikge1xuXHRcdFx0Ly8gQS5CLkMuRFxuXHRcdFx0Ly8gRC5BLkIuQyByb3RyKDE2KVxuXHRcdFx0Ly8gQy5ELkEuQiByb3RyKDMyKVxuXHRcdFx0dmFyIHYgPSB0aGlzLl9hMDBcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2EzMlxuXHRcdFx0dGhpcy5fYTMyID0gdlxuXHRcdFx0diA9IHRoaXMuX2E0OFxuXHRcdFx0dGhpcy5fYTQ4ID0gdGhpcy5fYTE2XG5cdFx0XHR0aGlzLl9hMTYgPSB2XG5cdFx0XHRpZiAobiA9PSAzMikgcmV0dXJuIHRoaXNcblx0XHRcdG4gLT0gMzJcblx0XHR9XG5cblx0XHR2YXIgaGlnaCA9ICh0aGlzLl9hNDggPDwgMTYpIHwgdGhpcy5fYTMyXG5cdFx0dmFyIGxvdyA9ICh0aGlzLl9hMTYgPDwgMTYpIHwgdGhpcy5fYTAwXG5cblx0XHR2YXIgX2hpZ2ggPSAoaGlnaCA+Pj4gbikgfCAobG93IDw8ICgzMiAtIG4pKVxuXHRcdHZhciBfbG93ID0gKGxvdyA+Pj4gbikgfCAoaGlnaCA8PCAoMzIgLSBuKSlcblxuXHRcdHRoaXMuX2EwMCA9IF9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBfbG93ID4+PiAxNlxuXHRcdHRoaXMuX2EzMiA9IF9oaWdoICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gX2hpZ2ggPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb25lIHRoZSBjdXJyZW50IF9VSU5UNjRfXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7T2JqZWN0fSBjbG9uZWQgVUlOVDY0XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgVUlOVDY0KHRoaXMuX2EwMCwgdGhpcy5fYTE2LCB0aGlzLl9hMzIsIHRoaXMuX2E0OClcblx0fVxuXG5cdGlmICh0eXBlb2YgZGVmaW5lICE9ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTUQgLyBSZXF1aXJlSlNcblx0XHRkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBVSU5UNjRcblx0XHR9KVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHQvLyBOb2RlLmpzXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBVSU5UNjRcblx0fSBlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0cm9vdFsnVUlOVDY0J10gPSBVSU5UNjRcblx0fVxuXG59KSh0aGlzKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N1aW50L2xpYi91aW50NjQuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgcHJvdG8gPSB7fTtcblxuZnVuY3Rpb24gQ0JDU3RhdGUoaXYpIHtcbiAgYXNzZXJ0LmVxdWFsKGl2Lmxlbmd0aCwgOCwgJ0ludmFsaWQgSVYgbGVuZ3RoJyk7XG5cbiAgdGhpcy5pdiA9IG5ldyBBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml2Lmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuaXZbaV0gPSBpdltpXTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGUoQmFzZSkge1xuICBmdW5jdGlvbiBDQkMob3B0aW9ucykge1xuICAgIEJhc2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9jYmNJbml0KCk7XG4gIH1cbiAgaW5oZXJpdHMoQ0JDLCBCYXNlKTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgQ0JDLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgfVxuXG4gIENCQy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ0JDKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBDQkM7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxucHJvdG8uX2NiY0luaXQgPSBmdW5jdGlvbiBfY2JjSW5pdCgpIHtcbiAgdmFyIHN0YXRlID0gbmV3IENCQ1N0YXRlKHRoaXMub3B0aW9ucy5pdik7XG4gIHRoaXMuX2NiY1N0YXRlID0gc3RhdGU7XG59O1xuXG5wcm90by5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9jYmNTdGF0ZTtcbiAgdmFyIHN1cGVyUHJvdG8gPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgdmFyIGl2ID0gc3RhdGUuaXY7XG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0Jykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldIF49IGlucFtpbk9mZiArIGldO1xuXG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaXYsIDAsIG91dCwgb3V0T2ZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldID0gb3V0W291dE9mZiArIGldO1xuICB9IGVsc2Uge1xuICAgIHN1cGVyUHJvdG8uX3VwZGF0ZS5jYWxsKHRoaXMsIGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIG91dFtvdXRPZmYgKyBpXSBePSBpdltpXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldID0gaW5wW2luT2ZmICsgaV07XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVzLmpzL2xpYi9kZXMvY2JjLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBDaXBoZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIHRoaXMudHlwZSA9IHRoaXMub3B0aW9ucy50eXBlO1xuICB0aGlzLmJsb2NrU2l6ZSA9IDg7XG4gIHRoaXMuX2luaXQoKTtcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuYnVmZmVyT2ZmID0gMDtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyO1xuXG5DaXBoZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIE1pZ2h0IGJlIG92ZXJyaWRlZFxufTtcblxuQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICdkZWNyeXB0JylcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRGVjcnlwdChkYXRhKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl91cGRhdGVFbmNyeXB0KGRhdGEpO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fYnVmZmVyID0gZnVuY3Rpb24gX2J1ZmZlcihkYXRhLCBvZmYpIHtcbiAgLy8gQXBwZW5kIGRhdGEgdG8gYnVmZmVyXG4gIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLmJ1ZmZlck9mZiwgZGF0YS5sZW5ndGggLSBvZmYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKVxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyT2ZmICsgaV0gPSBkYXRhW29mZiArIGldO1xuICB0aGlzLmJ1ZmZlck9mZiArPSBtaW47XG5cbiAgLy8gU2hpZnQgbmV4dFxuICByZXR1cm4gbWluO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmx1c2hCdWZmZXIgPSBmdW5jdGlvbiBfZmx1c2hCdWZmZXIob3V0LCBvZmYpIHtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuYnVmZmVyLCAwLCBvdXQsIG9mZik7XG4gIHRoaXMuYnVmZmVyT2ZmID0gMDtcbiAgcmV0dXJuIHRoaXMuYmxvY2tTaXplO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlRW5jcnlwdCA9IGZ1bmN0aW9uIF91cGRhdGVFbmNyeXB0KGRhdGEpIHtcbiAgdmFyIGlucHV0T2ZmID0gMDtcbiAgdmFyIG91dHB1dE9mZiA9IDA7XG5cbiAgdmFyIGNvdW50ID0gKCh0aGlzLmJ1ZmZlck9mZiArIGRhdGEubGVuZ3RoKSAvIHRoaXMuYmxvY2tTaXplKSB8IDA7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoY291bnQgKiB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgaWYgKHRoaXMuYnVmZmVyT2ZmICE9PSAwKSB7XG4gICAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcblxuICAgIGlmICh0aGlzLmJ1ZmZlck9mZiA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgb3V0cHV0T2ZmICs9IHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgb3V0cHV0T2ZmKTtcbiAgfVxuXG4gIC8vIFdyaXRlIGJsb2Nrc1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGggLSAoKGRhdGEubGVuZ3RoIC0gaW5wdXRPZmYpICUgdGhpcy5ibG9ja1NpemUpO1xuICBmb3IgKDsgaW5wdXRPZmYgPCBtYXg7IGlucHV0T2ZmICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKGRhdGEsIGlucHV0T2ZmLCBvdXQsIG91dHB1dE9mZik7XG4gICAgb3V0cHV0T2ZmICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG5cbiAgLy8gUXVldWUgcmVzdFxuICBmb3IgKDsgaW5wdXRPZmYgPCBkYXRhLmxlbmd0aDsgaW5wdXRPZmYrKywgdGhpcy5idWZmZXJPZmYrKylcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlck9mZl0gPSBkYXRhW2lucHV0T2ZmXTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlRGVjcnlwdCA9IGZ1bmN0aW9uIF91cGRhdGVEZWNyeXB0KGRhdGEpIHtcbiAgdmFyIGlucHV0T2ZmID0gMDtcbiAgdmFyIG91dHB1dE9mZiA9IDA7XG5cbiAgdmFyIGNvdW50ID0gTWF0aC5jZWlsKCh0aGlzLmJ1ZmZlck9mZiArIGRhdGEubGVuZ3RoKSAvIHRoaXMuYmxvY2tTaXplKSAtIDE7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoY291bnQgKiB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogb3B0aW1pemUgaXQsIHRoaXMgaXMgZmFyIGZyb20gb3B0aW1hbFxuICBmb3IgKDsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcbiAgICBvdXRwdXRPZmYgKz0gdGhpcy5fZmx1c2hCdWZmZXIob3V0LCBvdXRwdXRPZmYpO1xuICB9XG5cbiAgLy8gQnVmZmVyIHJlc3Qgb2YgdGhlIGlucHV0XG4gIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiBmaW5hbChidWZmZXIpIHtcbiAgdmFyIGZpcnN0O1xuICBpZiAoYnVmZmVyKVxuICAgIGZpcnN0ID0gdGhpcy51cGRhdGUoYnVmZmVyKTtcblxuICB2YXIgbGFzdDtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIGxhc3QgPSB0aGlzLl9maW5hbEVuY3J5cHQoKTtcbiAgZWxzZVxuICAgIGxhc3QgPSB0aGlzLl9maW5hbERlY3J5cHQoKTtcblxuICBpZiAoZmlyc3QpXG4gICAgcmV0dXJuIGZpcnN0LmNvbmNhdChsYXN0KTtcbiAgZWxzZVxuICAgIHJldHVybiBsYXN0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gX3BhZChidWZmZXIsIG9mZikge1xuICBpZiAob2ZmID09PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB3aGlsZSAob2ZmIDwgYnVmZmVyLmxlbmd0aClcbiAgICBidWZmZXJbb2ZmKytdID0gMDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsRW5jcnlwdCA9IGZ1bmN0aW9uIF9maW5hbEVuY3J5cHQoKSB7XG4gIGlmICghdGhpcy5fcGFkKHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlck9mZikpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl91cGRhdGUodGhpcy5idWZmZXIsIDAsIG91dCwgMCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91bnBhZCA9IGZ1bmN0aW9uIF91bnBhZChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsRGVjcnlwdCA9IGZ1bmN0aW9uIF9maW5hbERlY3J5cHQoKSB7XG4gIGFzc2VydC5lcXVhbCh0aGlzLmJ1ZmZlck9mZiwgdGhpcy5ibG9ja1NpemUsICdOb3QgZW5vdWdoIGRhdGEgdG8gZGVjcnlwdCcpO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5fZmx1c2hCdWZmZXIob3V0LCAwKTtcblxuICByZXR1cm4gdGhpcy5fdW5wYWQob3V0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGRlcyA9IHJlcXVpcmUoJy4uL2RlcycpO1xudmFyIHV0aWxzID0gZGVzLnV0aWxzO1xudmFyIENpcGhlciA9IGRlcy5DaXBoZXI7XG5cbmZ1bmN0aW9uIERFU1N0YXRlKCkge1xuICB0aGlzLnRtcCA9IG5ldyBBcnJheSgyKTtcbiAgdGhpcy5rZXlzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gREVTKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IERFU1N0YXRlKCk7XG4gIHRoaXMuX2Rlc1N0YXRlID0gc3RhdGU7XG5cbiAgdGhpcy5kZXJpdmVLZXlzKHN0YXRlLCBvcHRpb25zLmtleSk7XG59XG5pbmhlcml0cyhERVMsIENpcGhlcik7XG5tb2R1bGUuZXhwb3J0cyA9IERFUztcblxuREVTLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgREVTKG9wdGlvbnMpO1xufTtcblxudmFyIHNoaWZ0VGFibGUgPSBbXG4gIDEsIDEsIDIsIDIsIDIsIDIsIDIsIDIsXG4gIDEsIDIsIDIsIDIsIDIsIDIsIDIsIDFcbl07XG5cbkRFUy5wcm90b3R5cGUuZGVyaXZlS2V5cyA9IGZ1bmN0aW9uIGRlcml2ZUtleXMoc3RhdGUsIGtleSkge1xuICBzdGF0ZS5rZXlzID0gbmV3IEFycmF5KDE2ICogMik7XG5cbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIHRoaXMuYmxvY2tTaXplLCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGtMID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgMCk7XG4gIHZhciBrUiA9IHV0aWxzLnJlYWRVSW50MzJCRShrZXksIDQpO1xuXG4gIHV0aWxzLnBjMShrTCwga1IsIHN0YXRlLnRtcCwgMCk7XG4gIGtMID0gc3RhdGUudG1wWzBdO1xuICBrUiA9IHN0YXRlLnRtcFsxXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHNoaWZ0ID0gc2hpZnRUYWJsZVtpID4+PiAxXTtcbiAgICBrTCA9IHV0aWxzLnIyOHNobChrTCwgc2hpZnQpO1xuICAgIGtSID0gdXRpbHMucjI4c2hsKGtSLCBzaGlmdCk7XG4gICAgdXRpbHMucGMyKGtMLCBrUiwgc3RhdGUua2V5cywgaSk7XG4gIH1cbn07XG5cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fZGVzU3RhdGU7XG5cbiAgdmFyIGwgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZik7XG4gIHZhciByID0gdXRpbHMucmVhZFVJbnQzMkJFKGlucCwgaW5PZmYgKyA0KTtcblxuICAvLyBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLmlwKGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIHRoaXMuX2VuY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGVsc2VcbiAgICB0aGlzLl9kZWNyeXB0KHN0YXRlLCBsLCByLCBzdGF0ZS50bXAsIDApO1xuXG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIGwsIG91dE9mZik7XG4gIHV0aWxzLndyaXRlVUludDMyQkUob3V0LCByLCBvdXRPZmYgKyA0KTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgdmFyIHZhbHVlID0gYnVmZmVyLmxlbmd0aCAtIG9mZjtcbiAgZm9yICh2YXIgaSA9IG9mZjsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICB2YXIgcGFkID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXTtcbiAgZm9yICh2YXIgaSA9IGJ1ZmZlci5sZW5ndGggLSBwYWQ7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlcltpXSwgcGFkKTtcblxuICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSBwYWQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fZW5jcnlwdCA9IGZ1bmN0aW9uIF9lbmNyeXB0KHN0YXRlLCBsU3RhcnQsIHJTdGFydCwgb3V0LCBvZmYpIHtcbiAgdmFyIGwgPSBsU3RhcnQ7XG4gIHZhciByID0gclN0YXJ0O1xuXG4gIC8vIEFwcGx5IGYoKSB4MTYgdGltZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSByO1xuICAgIHIgPSAobCBeIGYpID4+PiAwO1xuICAgIGwgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChyLCBsLCBvdXQsIG9mZik7XG59O1xuXG5ERVMucHJvdG90eXBlLl9kZWNyeXB0ID0gZnVuY3Rpb24gX2RlY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IHJTdGFydDtcbiAgdmFyIHIgPSBsU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gc3RhdGUua2V5cy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgIHZhciBrZXlMID0gc3RhdGUua2V5c1tpXTtcbiAgICB2YXIga2V5UiA9IHN0YXRlLmtleXNbaSArIDFdO1xuXG4gICAgLy8gZihyLCBrKVxuICAgIHV0aWxzLmV4cGFuZChsLCBzdGF0ZS50bXAsIDApO1xuXG4gICAga2V5TCBePSBzdGF0ZS50bXBbMF07XG4gICAga2V5UiBePSBzdGF0ZS50bXBbMV07XG4gICAgdmFyIHMgPSB1dGlscy5zdWJzdGl0dXRlKGtleUwsIGtleVIpO1xuICAgIHZhciBmID0gdXRpbHMucGVybXV0ZShzKTtcblxuICAgIHZhciB0ID0gbDtcbiAgICBsID0gKHIgXiBmKSA+Pj4gMDtcbiAgICByID0gdDtcbiAgfVxuXG4gIC8vIFJldmVyc2UgSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5yaXAobCwgciwgb3V0LCBvZmYpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZXMuanMvbGliL2Rlcy9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgZGVzID0gcmVxdWlyZSgnLi4vZGVzJyk7XG52YXIgQ2lwaGVyID0gZGVzLkNpcGhlcjtcbnZhciBERVMgPSBkZXMuREVTO1xuXG5mdW5jdGlvbiBFREVTdGF0ZSh0eXBlLCBrZXkpIHtcbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIDI0LCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGsxID0ga2V5LnNsaWNlKDAsIDgpO1xuICB2YXIgazIgPSBrZXkuc2xpY2UoOCwgMTYpO1xuICB2YXIgazMgPSBrZXkuc2xpY2UoMTYsIDI0KTtcblxuICBpZiAodHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgdGhpcy5jaXBoZXJzID0gW1xuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMSB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazIgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGszIH0pXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGszIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazEgfSlcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIEVERShvcHRpb25zKSB7XG4gIENpcGhlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBFREVTdGF0ZSh0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5rZXkpO1xuICB0aGlzLl9lZGVTdGF0ZSA9IHN0YXRlO1xufVxuaW5oZXJpdHMoRURFLCBDaXBoZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVERTtcblxuRURFLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRURFKG9wdGlvbnMpO1xufTtcblxuRURFLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9lZGVTdGF0ZTtcblxuICBzdGF0ZS5jaXBoZXJzWzBdLl91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzFdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbiAgc3RhdGUuY2lwaGVyc1syXS5fdXBkYXRlKG91dCwgb3V0T2ZmLCBvdXQsIG91dE9mZik7XG59O1xuXG5FREUucHJvdG90eXBlLl9wYWQgPSBERVMucHJvdG90eXBlLl9wYWQ7XG5FREUucHJvdG90eXBlLl91bnBhZCA9IERFUy5wcm90b3R5cGUuX3VucGFkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Rlcy5qcy9saWIvZGVzL2VkZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUoYnl0ZXMsIG9mZikge1xuICB2YXIgcmVzID0gIChieXRlc1swICsgb2ZmXSA8PCAyNCkgfFxuICAgICAgICAgICAgIChieXRlc1sxICsgb2ZmXSA8PCAxNikgfFxuICAgICAgICAgICAgIChieXRlc1syICsgb2ZmXSA8PCA4KSB8XG4gICAgICAgICAgICAgYnl0ZXNbMyArIG9mZl07XG4gIHJldHVybiByZXMgPj4+IDA7XG59O1xuXG5leHBvcnRzLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGJ5dGVzLCB2YWx1ZSwgb2ZmKSB7XG4gIGJ5dGVzWzAgKyBvZmZdID0gdmFsdWUgPj4+IDI0O1xuICBieXRlc1sxICsgb2ZmXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgYnl0ZXNbMiArIG9mZl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgYnl0ZXNbMyArIG9mZl0gPSB2YWx1ZSAmIDB4ZmY7XG59O1xuXG5leHBvcnRzLmlwID0gZnVuY3Rpb24gaXAoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSA2OyBpID49IDA7IGkgLT0gMikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSA2OyBpID49IDA7IGkgLT0gMikge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDI1OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMjU7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnJpcCA9IGZ1bmN0aW9uIHJpcChpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSA0OyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnBjMSA9IGZ1bmN0aW9uIHBjMShpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgLy8gNywgMTUsIDIzLCAzMSwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNiwgMTQsIDIyLCAzMCwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNSwgMTMsIDIxLCAyOSwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNCwgMTIsIDIwLCAyOFxuICBmb3IgKHZhciBpID0gNzsgaSA+PSA1OyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICBvdXRMIDw8PSAxO1xuICAgIG91dEwgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gIH1cblxuICAvLyAxLCA5LCAxNywgMjUsIDMzLCA0MSwgNDksIDU3XG4gIC8vIDIsIDEwLCAxOCwgMjYsIDM0LCA0MiwgNTAsIDU4XG4gIC8vIDMsIDExLCAxOSwgMjcsIDM1LCA0MywgNTEsIDU5XG4gIC8vIDM2LCA0NCwgNTIsIDYwXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgIG91dFIgPDw9IDE7XG4gICAgb3V0UiB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnIyOHNobCA9IGZ1bmN0aW9uIHIyOHNobChudW0sIHNoaWZ0KSB7XG4gIHJldHVybiAoKG51bSA8PCBzaGlmdCkgJiAweGZmZmZmZmYpIHwgKG51bSA+Pj4gKDI4IC0gc2hpZnQpKTtcbn07XG5cbnZhciBwYzJ0YWJsZSA9IFtcbiAgLy8gaW5MID0+IG91dExcbiAgMTQsIDExLCAxNywgNCwgMjcsIDIzLCAyNSwgMCxcbiAgMTMsIDIyLCA3LCAxOCwgNSwgOSwgMTYsIDI0LFxuICAyLCAyMCwgMTIsIDIxLCAxLCA4LCAxNSwgMjYsXG5cbiAgLy8gaW5SID0+IG91dFJcbiAgMTUsIDQsIDI1LCAxOSwgOSwgMSwgMjYsIDE2LFxuICA1LCAxMSwgMjMsIDgsIDEyLCA3LCAxNywgMCxcbiAgMjIsIDMsIDEwLCAxNCwgNiwgMjAsIDI3LCAyNFxuXTtcblxuZXhwb3J0cy5wYzIgPSBmdW5jdGlvbiBwYzIoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIHZhciBsZW4gPSBwYzJ0YWJsZS5sZW5ndGggPj4+IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRMIDw8PSAxO1xuICAgIG91dEwgfD0gKGluTCA+Pj4gcGMydGFibGVbaV0pICYgMHgxO1xuICB9XG4gIGZvciAodmFyIGkgPSBsZW47IGkgPCBwYzJ0YWJsZS5sZW5ndGg7IGkrKykge1xuICAgIG91dFIgPDw9IDE7XG4gICAgb3V0UiB8PSAoaW5SID4+PiBwYzJ0YWJsZVtpXSkgJiAweDE7XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5leHBhbmQgPSBmdW5jdGlvbiBleHBhbmQociwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgb3V0TCA9ICgociAmIDEpIDw8IDUpIHwgKHIgPj4+IDI3KTtcbiAgZm9yICh2YXIgaSA9IDIzOyBpID49IDE1OyBpIC09IDQpIHtcbiAgICBvdXRMIDw8PSA2O1xuICAgIG91dEwgfD0gKHIgPj4+IGkpICYgMHgzZjtcbiAgfVxuICBmb3IgKHZhciBpID0gMTE7IGkgPj0gMzsgaSAtPSA0KSB7XG4gICAgb3V0UiB8PSAociA+Pj4gaSkgJiAweDNmO1xuICAgIG91dFIgPDw9IDY7XG4gIH1cbiAgb3V0UiB8PSAoKHIgJiAweDFmKSA8PCAxKSB8IChyID4+PiAzMSk7XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbnZhciBzVGFibGUgPSBbXG4gIDE0LCAwLCA0LCAxNSwgMTMsIDcsIDEsIDQsIDIsIDE0LCAxNSwgMiwgMTEsIDEzLCA4LCAxLFxuICAzLCAxMCwgMTAsIDYsIDYsIDEyLCAxMiwgMTEsIDUsIDksIDksIDUsIDAsIDMsIDcsIDgsXG4gIDQsIDE1LCAxLCAxMiwgMTQsIDgsIDgsIDIsIDEzLCA0LCA2LCA5LCAyLCAxLCAxMSwgNyxcbiAgMTUsIDUsIDEyLCAxMSwgOSwgMywgNywgMTQsIDMsIDEwLCAxMCwgMCwgNSwgNiwgMCwgMTMsXG5cbiAgMTUsIDMsIDEsIDEzLCA4LCA0LCAxNCwgNywgNiwgMTUsIDExLCAyLCAzLCA4LCA0LCAxNCxcbiAgOSwgMTIsIDcsIDAsIDIsIDEsIDEzLCAxMCwgMTIsIDYsIDAsIDksIDUsIDExLCAxMCwgNSxcbiAgMCwgMTMsIDE0LCA4LCA3LCAxMCwgMTEsIDEsIDEwLCAzLCA0LCAxNSwgMTMsIDQsIDEsIDIsXG4gIDUsIDExLCA4LCA2LCAxMiwgNywgNiwgMTIsIDksIDAsIDMsIDUsIDIsIDE0LCAxNSwgOSxcblxuICAxMCwgMTMsIDAsIDcsIDksIDAsIDE0LCA5LCA2LCAzLCAzLCA0LCAxNSwgNiwgNSwgMTAsXG4gIDEsIDIsIDEzLCA4LCAxMiwgNSwgNywgMTQsIDExLCAxMiwgNCwgMTEsIDIsIDE1LCA4LCAxLFxuICAxMywgMSwgNiwgMTAsIDQsIDEzLCA5LCAwLCA4LCA2LCAxNSwgOSwgMywgOCwgMCwgNyxcbiAgMTEsIDQsIDEsIDE1LCAyLCAxNCwgMTIsIDMsIDUsIDExLCAxMCwgNSwgMTQsIDIsIDcsIDEyLFxuXG4gIDcsIDEzLCAxMywgOCwgMTQsIDExLCAzLCA1LCAwLCA2LCA2LCAxNSwgOSwgMCwgMTAsIDMsXG4gIDEsIDQsIDIsIDcsIDgsIDIsIDUsIDEyLCAxMSwgMSwgMTIsIDEwLCA0LCAxNCwgMTUsIDksXG4gIDEwLCAzLCA2LCAxNSwgOSwgMCwgMCwgNiwgMTIsIDEwLCAxMSwgMSwgNywgMTMsIDEzLCA4LFxuICAxNSwgOSwgMSwgNCwgMywgNSwgMTQsIDExLCA1LCAxMiwgMiwgNywgOCwgMiwgNCwgMTQsXG5cbiAgMiwgMTQsIDEyLCAxMSwgNCwgMiwgMSwgMTIsIDcsIDQsIDEwLCA3LCAxMSwgMTMsIDYsIDEsXG4gIDgsIDUsIDUsIDAsIDMsIDE1LCAxNSwgMTAsIDEzLCAzLCAwLCA5LCAxNCwgOCwgOSwgNixcbiAgNCwgMTEsIDIsIDgsIDEsIDEyLCAxMSwgNywgMTAsIDEsIDEzLCAxNCwgNywgMiwgOCwgMTMsXG4gIDE1LCA2LCA5LCAxNSwgMTIsIDAsIDUsIDksIDYsIDEwLCAzLCA0LCAwLCA1LCAxNCwgMyxcblxuICAxMiwgMTAsIDEsIDE1LCAxMCwgNCwgMTUsIDIsIDksIDcsIDIsIDEyLCA2LCA5LCA4LCA1LFxuICAwLCA2LCAxMywgMSwgMywgMTMsIDQsIDE0LCAxNCwgMCwgNywgMTEsIDUsIDMsIDExLCA4LFxuICA5LCA0LCAxNCwgMywgMTUsIDIsIDUsIDEyLCAyLCA5LCA4LCA1LCAxMiwgMTUsIDMsIDEwLFxuICA3LCAxMSwgMCwgMTQsIDQsIDEsIDEwLCA3LCAxLCA2LCAxMywgMCwgMTEsIDgsIDYsIDEzLFxuXG4gIDQsIDEzLCAxMSwgMCwgMiwgMTEsIDE0LCA3LCAxNSwgNCwgMCwgOSwgOCwgMSwgMTMsIDEwLFxuICAzLCAxNCwgMTIsIDMsIDksIDUsIDcsIDEyLCA1LCAyLCAxMCwgMTUsIDYsIDgsIDEsIDYsXG4gIDEsIDYsIDQsIDExLCAxMSwgMTMsIDEzLCA4LCAxMiwgMSwgMywgNCwgNywgMTAsIDE0LCA3LFxuICAxMCwgOSwgMTUsIDUsIDYsIDAsIDgsIDE1LCAwLCAxNCwgNSwgMiwgOSwgMywgMiwgMTIsXG5cbiAgMTMsIDEsIDIsIDE1LCA4LCAxMywgNCwgOCwgNiwgMTAsIDE1LCAzLCAxMSwgNywgMSwgNCxcbiAgMTAsIDEyLCA5LCA1LCAzLCA2LCAxNCwgMTEsIDUsIDAsIDAsIDE0LCAxMiwgOSwgNywgMixcbiAgNywgMiwgMTEsIDEsIDQsIDE0LCAxLCA3LCA5LCA0LCAxMiwgMTAsIDE0LCA4LCAyLCAxMyxcbiAgMCwgMTUsIDYsIDEyLCAxMCwgOSwgMTMsIDAsIDE1LCAzLCAzLCA1LCA1LCA2LCA4LCAxMVxuXTtcblxuZXhwb3J0cy5zdWJzdGl0dXRlID0gZnVuY3Rpb24gc3Vic3RpdHV0ZShpbkwsIGluUikge1xuICB2YXIgb3V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgYiA9IChpbkwgPj4+ICgxOCAtIGkgKiA2KSkgJiAweDNmO1xuICAgIHZhciBzYiA9IHNUYWJsZVtpICogMHg0MCArIGJdO1xuXG4gICAgb3V0IDw8PSA0O1xuICAgIG91dCB8PSBzYjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBiID0gKGluUiA+Pj4gKDE4IC0gaSAqIDYpKSAmIDB4M2Y7XG4gICAgdmFyIHNiID0gc1RhYmxlWzQgKiAweDQwICsgaSAqIDB4NDAgKyBiXTtcblxuICAgIG91dCA8PD0gNDtcbiAgICBvdXQgfD0gc2I7XG4gIH1cbiAgcmV0dXJuIG91dCA+Pj4gMDtcbn07XG5cbnZhciBwZXJtdXRlVGFibGUgPSBbXG4gIDE2LCAyNSwgMTIsIDExLCAzLCAyMCwgNCwgMTUsIDMxLCAxNywgOSwgNiwgMjcsIDE0LCAxLCAyMixcbiAgMzAsIDI0LCA4LCAxOCwgMCwgNSwgMjksIDIzLCAxMywgMTksIDIsIDI2LCAxMCwgMjEsIDI4LCA3XG5dO1xuXG5leHBvcnRzLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlKG51bSkge1xuICB2YXIgb3V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZXJtdXRlVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXQgPDw9IDE7XG4gICAgb3V0IHw9IChudW0gPj4+IHBlcm11dGVUYWJsZVtpXSkgJiAweDE7XG4gIH1cbiAgcmV0dXJuIG91dCA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucGFkU3BsaXQgPSBmdW5jdGlvbiBwYWRTcGxpdChudW0sIHNpemUsIGdyb3VwKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMik7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICBzdHIgPSAnMCcgKyBzdHI7XG5cbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gZ3JvdXApXG4gICAgb3V0LnB1c2goc3RyLnNsaWNlKGksIGkgKyBncm91cCkpO1xuICByZXR1cm4gb3V0LmpvaW4oJyAnKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVzLmpzL2xpYi9kZXMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2VuZXJhdGVQcmltZSA9IHJlcXVpcmUoJy4vbGliL2dlbmVyYXRlUHJpbWUnKVxudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vbGliL3ByaW1lcy5qc29uJylcblxudmFyIERIID0gcmVxdWlyZSgnLi9saWIvZGgnKVxuXG5mdW5jdGlvbiBnZXREaWZmaWVIZWxsbWFuIChtb2QpIHtcbiAgdmFyIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5wcmltZSwgJ2hleCcpXG4gIHZhciBnZW4gPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLmdlbiwgJ2hleCcpXG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuKVxufVxuXG52YXIgRU5DT0RJTkdTID0ge1xuICAnYmluYXJ5JzogdHJ1ZSwgJ2hleCc6IHRydWUsICdiYXNlNjQnOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZpZUhlbGxtYW4gKHByaW1lLCBlbmMsIGdlbmVyYXRvciwgZ2VuYykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVuYykgfHwgRU5DT0RJTkdTW2VuY10gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVEaWZmaWVIZWxsbWFuKHByaW1lLCAnYmluYXJ5JywgZW5jLCBnZW5lcmF0b3IpXG4gIH1cblxuICBlbmMgPSBlbmMgfHwgJ2JpbmFyeSdcbiAgZ2VuYyA9IGdlbmMgfHwgJ2JpbmFyeSdcbiAgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yIHx8IG5ldyBCdWZmZXIoWzJdKVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbmVyYXRvcikpIHtcbiAgICBnZW5lcmF0b3IgPSBuZXcgQnVmZmVyKGdlbmVyYXRvciwgZ2VuYylcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJpbWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5ldyBESChnZW5lcmF0ZVByaW1lKHByaW1lLCBnZW5lcmF0b3IpLCBnZW5lcmF0b3IsIHRydWUpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcmltZSkpIHtcbiAgICBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWUsIGVuYylcbiAgfVxuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbmVyYXRvciwgdHJ1ZSlcbn1cblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGdldERpZmZpZUhlbGxtYW5cbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGNyZWF0ZURpZmZpZUhlbGxtYW5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBNaWxsZXJSYWJpbiA9IHJlcXVpcmUoJ21pbGxlci1yYWJpbicpO1xudmFyIG1pbGxlclJhYmluID0gbmV3IE1pbGxlclJhYmluKCk7XG52YXIgVFdFTlRZRk9VUiA9IG5ldyBCTigyNCk7XG52YXIgRUxFVkVOID0gbmV3IEJOKDExKTtcbnZhciBURU4gPSBuZXcgQk4oMTApO1xudmFyIFRIUkVFID0gbmV3IEJOKDMpO1xudmFyIFNFVkVOID0gbmV3IEJOKDcpO1xudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVQcmltZScpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gREg7XG5cbmZ1bmN0aW9uIHNldFB1YmxpY0tleShwdWIsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWIpKSB7XG4gICAgcHViID0gbmV3IEJ1ZmZlcihwdWIsIGVuYyk7XG4gIH1cbiAgdGhpcy5fcHViID0gbmV3IEJOKHB1Yik7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRQcml2YXRlS2V5KHByaXYsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcml2KSkge1xuICAgIHByaXYgPSBuZXcgQnVmZmVyKHByaXYsIGVuYyk7XG4gIH1cbiAgdGhpcy5fcHJpdiA9IG5ldyBCTihwcml2KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcmltZUNhY2hlID0ge307XG5mdW5jdGlvbiBjaGVja1ByaW1lKHByaW1lLCBnZW5lcmF0b3IpIHtcbiAgdmFyIGdlbiA9IGdlbmVyYXRvci50b1N0cmluZygnaGV4Jyk7XG4gIHZhciBoZXggPSBbZ2VuLCBwcmltZS50b1N0cmluZygxNildLmpvaW4oJ18nKTtcbiAgaWYgKGhleCBpbiBwcmltZUNhY2hlKSB7XG4gICAgcmV0dXJuIHByaW1lQ2FjaGVbaGV4XTtcbiAgfVxuICB2YXIgZXJyb3IgPSAwO1xuXG4gIGlmIChwcmltZS5pc0V2ZW4oKSB8fFxuICAgICFwcmltZXMuc2ltcGxlU2lldmUgfHxcbiAgICAhcHJpbWVzLmZlcm1hdFRlc3QocHJpbWUpIHx8XG4gICAgIW1pbGxlclJhYmluLnRlc3QocHJpbWUpKSB7XG4gICAgLy9ub3QgYSBwcmltZSBzbyArMVxuICAgIGVycm9yICs9IDE7XG5cbiAgICBpZiAoZ2VuID09PSAnMDInIHx8IGdlbiA9PT0gJzA1Jykge1xuICAgICAgLy8gd2UnZCBiZSBhYmxlIHRvIGNoZWNrIHRoZSBnZW5lcmF0b3JcbiAgICAgIC8vIGl0IHdvdWxkIGZhaWwgc28gKzhcbiAgICAgIGVycm9yICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vd2Ugd291bGRuJ3QgYmUgYWJsZSB0byB0ZXN0IHRoZSBnZW5lcmF0b3JcbiAgICAgIC8vIHNvICs0XG4gICAgICBlcnJvciArPSA0O1xuICAgIH1cbiAgICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKCFtaWxsZXJSYWJpbi50ZXN0KHByaW1lLnNocm4oMSkpKSB7XG4gICAgLy9ub3QgYSBzYWZlIHByaW1lXG4gICAgZXJyb3IgKz0gMjtcbiAgfVxuICB2YXIgcmVtO1xuICBzd2l0Y2ggKGdlbikge1xuICAgIGNhc2UgJzAyJzpcbiAgICAgIGlmIChwcmltZS5tb2QoVFdFTlRZRk9VUikuY21wKEVMRVZFTikpIHtcbiAgICAgICAgLy8gdW5zdWlkYWJsZSBnZW5lcmF0b3JcbiAgICAgICAgZXJyb3IgKz0gODtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzA1JzpcbiAgICAgIHJlbSA9IHByaW1lLm1vZChURU4pO1xuICAgICAgaWYgKHJlbS5jbXAoVEhSRUUpICYmIHJlbS5jbXAoU0VWRU4pKSB7XG4gICAgICAgIC8vIHByaW1lIG1vZCAxMCBuZWVkcyB0byBlcXVhbCAzIG9yIDdcbiAgICAgICAgZXJyb3IgKz0gODtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciArPSA0O1xuICB9XG4gIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIERIKHByaW1lLCBnZW5lcmF0b3IsIG1hbGxlYWJsZSkge1xuICB0aGlzLnNldEdlbmVyYXRvcihnZW5lcmF0b3IpO1xuICB0aGlzLl9fcHJpbWUgPSBuZXcgQk4ocHJpbWUpO1xuICB0aGlzLl9wcmltZSA9IEJOLm1vbnQodGhpcy5fX3ByaW1lKTtcbiAgdGhpcy5fcHJpbWVMZW4gPSBwcmltZS5sZW5ndGg7XG4gIHRoaXMuX3B1YiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJpdiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJpbWVDb2RlID0gdW5kZWZpbmVkO1xuICBpZiAobWFsbGVhYmxlKSB7XG4gICAgdGhpcy5zZXRQdWJsaWNLZXkgPSBzZXRQdWJsaWNLZXk7XG4gICAgdGhpcy5zZXRQcml2YXRlS2V5ID0gc2V0UHJpdmF0ZUtleTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9wcmltZUNvZGUgPSA4O1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREgucHJvdG90eXBlLCAndmVyaWZ5RXJyb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcHJpbWVDb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fcHJpbWVDb2RlID0gY2hlY2tQcmltZSh0aGlzLl9fcHJpbWUsIHRoaXMuX19nZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJpbWVDb2RlO1xuICB9XG59KTtcbkRILnByb3RvdHlwZS5nZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fcHJpdikge1xuICAgIHRoaXMuX3ByaXYgPSBuZXcgQk4ocmFuZG9tQnl0ZXModGhpcy5fcHJpbWVMZW4pKTtcbiAgfVxuICB0aGlzLl9wdWIgPSB0aGlzLl9nZW4udG9SZWQodGhpcy5fcHJpbWUpLnJlZFBvdyh0aGlzLl9wcml2KS5mcm9tUmVkKCk7XG4gIHJldHVybiB0aGlzLmdldFB1YmxpY0tleSgpO1xufTtcblxuREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgb3RoZXIgPSBuZXcgQk4ob3RoZXIpO1xuICBvdGhlciA9IG90aGVyLnRvUmVkKHRoaXMuX3ByaW1lKTtcbiAgdmFyIHNlY3JldCA9IG90aGVyLnJlZFBvdyh0aGlzLl9wcml2KS5mcm9tUmVkKCk7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKHNlY3JldC50b0FycmF5KCkpO1xuICB2YXIgcHJpbWUgPSB0aGlzLmdldFByaW1lKCk7XG4gIGlmIChvdXQubGVuZ3RoIDwgcHJpbWUubGVuZ3RoKSB7XG4gICAgdmFyIGZyb250ID0gbmV3IEJ1ZmZlcihwcmltZS5sZW5ndGggLSBvdXQubGVuZ3RoKTtcbiAgICBmcm9udC5maWxsKDApO1xuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW2Zyb250LCBvdXRdKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuREgucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIGdldFB1YmxpY0tleShlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX3B1YiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZUtleShlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX3ByaXYsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpbWUgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9fcHJpbWUsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fZ2VuLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLnNldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChnZW4sIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW4pKSB7XG4gICAgZ2VuID0gbmV3IEJ1ZmZlcihnZW4sIGVuYyk7XG4gIH1cbiAgdGhpcy5fX2dlbiA9IGdlbjtcbiAgdGhpcy5fZ2VuID0gbmV3IEJOKGdlbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUoYm4sIGVuYykge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihibi50b0FycmF5KCkpO1xuICBpZiAoIWVuYykge1xuICAgIHJldHVybiBidWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZyhlbmMpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGlmZmllLWhlbGxtYW4vbGliL2RoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwibW9kcDFcIjoge1xuXHRcdFwiZ2VuXCI6IFwiMDJcIixcblx0XHRcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzYTM2MjBmZmZmZmZmZmZmZmZmZmZmXCJcblx0fSxcblx0XCJtb2RwMlwiOiB7XG5cdFx0XCJnZW5cIjogXCIwMlwiLFxuXHRcdFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNjUzODFmZmZmZmZmZmZmZmZmZmZmXCJcblx0fSxcblx0XCJtb2RwNVwiOiB7XG5cdFx0XCJnZW5cIjogXCIwMlwiLFxuXHRcdFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTIzNzMyN2ZmZmZmZmZmZmZmZmZmZmZcIlxuXHR9LFxuXHRcIm1vZHAxNFwiOiB7XG5cdFx0XCJnZW5cIjogXCIwMlwiLFxuXHRcdFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWNhYTY4ZmZmZmZmZmZmZmZmZmZmZlwiXG5cdH0sXG5cdFwibW9kcDE1XCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5M2FkMmNhZmZmZmZmZmZmZmZmZmZmZlwiXG5cdH0sXG5cdFwibW9kcDE2XCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDA2MzE5OWZmZmZmZmZmZmZmZmZmZmZcIlxuXHR9LFxuXHRcIm1vZHAxN1wiOiB7XG5cdFx0XCJnZW5cIjogXCIwMlwiLFxuXHRcdFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWFjNDJkYWQzMzE3MGQwNDUwN2EzM2E4NTUyMWFiZGYxY2JhNjRlY2ZiODUwNDU4ZGJlZjBhOGFlYTcxNTc1ZDA2MGM3ZGIzOTcwZjg1YTZlMWU0YzdhYmY1YWU4Y2RiMDkzM2Q3MWU4Yzk0ZTA0YTI1NjE5ZGNlZTNkMjI2MWFkMmVlNmJmMTJmZmEwNmQ5OGEwODY0ZDg3NjAyNzMzZWM4NmE2NDUyMWYyYjE4MTc3YjIwMGNiYmUxMTc1NzdhNjE1ZDZjNzcwOTg4YzBiYWQ5NDZlMjA4ZTI0ZmEwNzRlNWFiMzE0M2RiNWJmY2UwZmQxMDhlNGI4MmQxMjBhOTIxMDgwMTFhNzIzYzEyYTc4N2U2ZDc4ODcxOWExMGJkYmE1YjI2OTljMzI3MTg2YWY0ZTIzYzFhOTQ2ODM0YjYxNTBiZGEyNTgzZTljYTJhZDQ0Y2U4ZGJiYmMyZGIwNGRlOGVmOTJlOGVmYzE0MWZiZWNhYTYyODdjNTk0NzRlNmJjMDVkOTliMjk2NGZhMDkwYzNhMjIzM2JhMTg2NTE1YmU3ZWQxZjYxMjk3MGNlZTJkN2FmYjgxYmRkNzYyMTcwNDgxY2QwMDY5MTI3ZDViMDVhYTk5M2I0ZWE5ODhkOGZkZGMxODZmZmI3ZGM5MGE2YzA4ZjRkZjQzNWM5MzQwMjg0OTIzNmMzZmFiNGQyN2M3MDI2YzFkNGRjYjI2MDI2NDZkZWM5NzUxZTc2M2RiYTM3YmRmOGZmOTQwNmFkOWU1MzBlZTVkYjM4MmY0MTMwMDFhZWIwNmE1M2VkOTAyN2Q4MzExNzk3MjdiMDg2NWE4OTE4ZGEzZWRiZWJjZjliMTRlZDQ0Y2U2Y2JhY2VkNGJiMWJkYjdmMTQ0N2U2Y2MyNTRiMzMyMDUxNTEyYmQ3YWY0MjZmYjhmNDAxMzc4Y2QyYmY1OTgzY2EwMWM2NGI5MmVjZjAzMmVhMTVkMTcyMWQwM2Y0ODJkN2NlNmU3NGZlZjZkNTVlNzAyZjQ2OTgwYzgyYjVhODQwMzE5MDBiMWM5ZTU5ZTdjOTdmYmVjN2U4ZjMyM2E5N2E3ZTM2Y2M4OGJlMGYxZDQ1YjdmZjU4NWFjNTRiZDQwN2IyMmI0MTU0YWFjYzhmNmQ3ZWJmNDhlMWQ4MTRjYzVlZDIwZjgwMzdlMGE3OTcxNWVlZjI5YmUzMjgwNmExZDU4YmI3YzVkYTc2ZjU1MGFhM2Q4YTFmYmZmMGViMTljY2IxYTMxM2Q1NWNkYTU2YzllYzJlZjI5NjMyMzg3ZmU4ZDc2ZTNjMDQ2ODA0M2U4ZjY2M2Y0ODYwZWUxMmJmMmQ1YjBiNzQ3NGQ2ZTY5NGY5MWU2ZGNjNDAyNGZmZmZmZmZmZmZmZmZmZmZcIlxuXHR9LFxuXHRcIm1vZHAxOFwiOiB7XG5cdFx0XCJnZW5cIjogXCIwMlwiLFxuXHRcdFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWFjNDJkYWQzMzE3MGQwNDUwN2EzM2E4NTUyMWFiZGYxY2JhNjRlY2ZiODUwNDU4ZGJlZjBhOGFlYTcxNTc1ZDA2MGM3ZGIzOTcwZjg1YTZlMWU0YzdhYmY1YWU4Y2RiMDkzM2Q3MWU4Yzk0ZTA0YTI1NjE5ZGNlZTNkMjI2MWFkMmVlNmJmMTJmZmEwNmQ5OGEwODY0ZDg3NjAyNzMzZWM4NmE2NDUyMWYyYjE4MTc3YjIwMGNiYmUxMTc1NzdhNjE1ZDZjNzcwOTg4YzBiYWQ5NDZlMjA4ZTI0ZmEwNzRlNWFiMzE0M2RiNWJmY2UwZmQxMDhlNGI4MmQxMjBhOTIxMDgwMTFhNzIzYzEyYTc4N2U2ZDc4ODcxOWExMGJkYmE1YjI2OTljMzI3MTg2YWY0ZTIzYzFhOTQ2ODM0YjYxNTBiZGEyNTgzZTljYTJhZDQ0Y2U4ZGJiYmMyZGIwNGRlOGVmOTJlOGVmYzE0MWZiZWNhYTYyODdjNTk0NzRlNmJjMDVkOTliMjk2NGZhMDkwYzNhMjIzM2JhMTg2NTE1YmU3ZWQxZjYxMjk3MGNlZTJkN2FmYjgxYmRkNzYyMTcwNDgxY2QwMDY5MTI3ZDViMDVhYTk5M2I0ZWE5ODhkOGZkZGMxODZmZmI3ZGM5MGE2YzA4ZjRkZjQzNWM5MzQwMjg0OTIzNmMzZmFiNGQyN2M3MDI2YzFkNGRjYjI2MDI2NDZkZWM5NzUxZTc2M2RiYTM3YmRmOGZmOTQwNmFkOWU1MzBlZTVkYjM4MmY0MTMwMDFhZWIwNmE1M2VkOTAyN2Q4MzExNzk3MjdiMDg2NWE4OTE4ZGEzZWRiZWJjZjliMTRlZDQ0Y2U2Y2JhY2VkNGJiMWJkYjdmMTQ0N2U2Y2MyNTRiMzMyMDUxNTEyYmQ3YWY0MjZmYjhmNDAxMzc4Y2QyYmY1OTgzY2EwMWM2NGI5MmVjZjAzMmVhMTVkMTcyMWQwM2Y0ODJkN2NlNmU3NGZlZjZkNTVlNzAyZjQ2OTgwYzgyYjVhODQwMzE5MDBiMWM5ZTU5ZTdjOTdmYmVjN2U4ZjMyM2E5N2E3ZTM2Y2M4OGJlMGYxZDQ1YjdmZjU4NWFjNTRiZDQwN2IyMmI0MTU0YWFjYzhmNmQ3ZWJmNDhlMWQ4MTRjYzVlZDIwZjgwMzdlMGE3OTcxNWVlZjI5YmUzMjgwNmExZDU4YmI3YzVkYTc2ZjU1MGFhM2Q4YTFmYmZmMGViMTljY2IxYTMxM2Q1NWNkYTU2YzllYzJlZjI5NjMyMzg3ZmU4ZDc2ZTNjMDQ2ODA0M2U4ZjY2M2Y0ODYwZWUxMmJmMmQ1YjBiNzQ3NGQ2ZTY5NGY5MWU2ZGJlMTE1OTc0YTM5MjZmMTJmZWU1ZTQzODc3N2NiNmE5MzJkZjhjZDhiZWM0ZDA3M2I5MzFiYTNiYzgzMmI2OGQ5ZGQzMDA3NDFmYTdiZjhhZmM0N2VkMjU3NmY2OTM2YmE0MjQ2NjNhYWI2MzljNWFlNGY1NjgzNDIzYjQ3NDJiZjFjOTc4MjM4ZjE2Y2JlMzlkNjUyZGUzZmRiOGJlZmM4NDhhZDkyMjIyMmUwNGE0MDM3YzA3MTNlYjU3YTgxYTIzZjBjNzM0NzNmYzY0NmNlYTMwNmI0YmNiYzg4NjJmODM4NWRkZmE5ZDRiN2ZhMmMwODdlODc5NjgzMzAzZWQ1YmRkM2EwNjJiM2NmNWIzYTI3OGE2NmQyYTEzZjgzZjQ0ZjgyZGRmMzEwZWUwNzRhYjZhMzY0NTk3ZTg5OWEwMjU1ZGMxNjRmMzFjYzUwODQ2ODUxZGY5YWI0ODE5NWRlZDdlYTFiMWQ1MTBiZDdlZTc0ZDczZmFmMzZiYzMxZWNmYTI2ODM1OTA0NmY0ZWI4NzlmOTI0MDA5NDM4YjQ4MWM2Y2Q3ODg5YTAwMmVkNWVlMzgyYmM5MTkwZGE2ZmMwMjZlNDc5NTU4ZTQ0NzU2NzdlOWFhOWUzMDUwZTI3NjU2OTRkZmM4MWY1NmU4ODBiOTZlNzE2MGM5ODBkZDk4ZWRkM2RmZmZmZmZmZmZmZmZmZmZmZlwiXG5cdH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RpZmZpZS1oZWxsbWFuL2xpYi9wcmltZXMuanNvblxuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBnZXROQUYgPSB1dGlscy5nZXROQUY7XG52YXIgZ2V0SlNGID0gdXRpbHMuZ2V0SlNGO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgLy8gR2VuZXJhbGl6ZWQgR3JlZyBNYXh3ZWxsJ3MgdHJpY2tcbiAgdmFyIGFkanVzdENvdW50ID0gdGhpcy5uICYmIHRoaXMucC5kaXYodGhpcy5uKTtcbiAgaWYgKCFhZGp1c3RDb3VudCB8fCBhZGp1c3RDb3VudC5jbXBuKDEwMCkgPiAwKSB7XG4gICAgdGhpcy5yZWROID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9tYXh3ZWxsVHJpY2sgPSB0cnVlO1xuICAgIHRoaXMucmVkTiA9IHRoaXMubi50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQmFzZUN1cnZlO1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG4gIGFzc2VydChwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIHZhciBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBrID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGsgPj0gajsgay0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2tdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3KTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgaysrO1xuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0pO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0pO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMyAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yICh2YXIgaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG4gIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuXG4gIC8vIHVuY29tcHJlc3NlZCwgaHlicmlkLW9kZCwgaHlicmlkLWV2ZW5cbiAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcbiAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcbiAgICBpZiAoYnl0ZXNbMF0gPT09IDB4MDYpXG4gICAgICBhc3NlcnQoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDEpO1xuXG4gICAgdmFyIHJlcyA9ICB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSkgO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbFxuICB9O1xuICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcbiAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgaWYgKCFkb3VibGVzKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuICB2YXIgYWNjID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG4gICAgICBhY2MgPSBhY2MuZGJsKCk7XG4gICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIHBvaW50czogZG91Ymxlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG4gIHZhciByZXMgPSBbIHRoaXMgXTtcbiAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG4gICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgcmV0dXJuIHtcbiAgICB3bmQ6IHduZCxcbiAgICBwb2ludHM6IHJlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEVkd2FyZHNDdXJ2ZShjb25mKSB7XG4gIC8vIE5PVEU6IEltcG9ydGFudCBhcyB3ZSBhcmUgY3JlYXRpbmcgcG9pbnQgaW4gQmFzZS5jYWxsKClcbiAgdGhpcy50d2lzdGVkID0gKGNvbmYuYSB8IDApICE9PSAxO1xuICB0aGlzLm1PbmVBID0gdGhpcy50d2lzdGVkICYmIChjb25mLmEgfCAwKSA9PT0gLTE7XG4gIHRoaXMuZXh0ZW5kZWQgPSB0aGlzLm1PbmVBO1xuXG4gIEJhc2UuY2FsbCh0aGlzLCAnZWR3YXJkcycsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS51bW9kKHRoaXMucmVkLm0pO1xuICB0aGlzLmEgPSB0aGlzLmEudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMgPSBuZXcgQk4oY29uZi5jLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMyID0gdGhpcy5jLnJlZFNxcigpO1xuICB0aGlzLmQgPSBuZXcgQk4oY29uZi5kLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmRkID0gdGhpcy5kLnJlZEFkZCh0aGlzLmQpO1xuXG4gIGFzc2VydCghdGhpcy50d2lzdGVkIHx8IHRoaXMuYy5mcm9tUmVkKCkuY21wbigxKSA9PT0gMCk7XG4gIHRoaXMub25lQyA9IChjb25mLmMgfCAwKSA9PT0gMTtcbn1cbmluaGVyaXRzKEVkd2FyZHNDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IEVkd2FyZHNDdXJ2ZTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQSA9IGZ1bmN0aW9uIF9tdWxBKG51bSkge1xuICBpZiAodGhpcy5tT25lQSlcbiAgICByZXR1cm4gbnVtLnJlZE5lZygpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYS5yZWRNdWwobnVtKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEMgPSBmdW5jdGlvbiBfbXVsQyhudW0pIHtcbiAgaWYgKHRoaXMub25lQylcbiAgICByZXR1cm4gbnVtO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYy5yZWRNdWwobnVtKTtcbn07XG5cbi8vIEp1c3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTaG9ydCBjdXJ2ZVxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5LCB6LCB0KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRTdWIodGhpcy5hLnJlZE11bCh4MikpO1xuICB2YXIgbGhzID0gdGhpcy5vbmUucmVkU3ViKHRoaXMuYzIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHgyKSk7XG5cbiAgdmFyIHkyID0gcmhzLnJlZE11bChsaHMucmVkSW52bSgpKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWSA9IGZ1bmN0aW9uIHBvaW50RnJvbVkoeSwgb2RkKSB7XG4gIHkgPSBuZXcgQk4oeSwgMTYpO1xuICBpZiAoIXkucmVkKVxuICAgIHkgPSB5LnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyB4XjIgPSAoeV4yIC0gMSkgLyAoZCB5XjIgKyAxKVxuICB2YXIgeTIgPSB5LnJlZFNxcigpO1xuICB2YXIgbGhzID0geTIucmVkU3ViKHRoaXMub25lKTtcbiAgdmFyIHJocyA9IHkyLnJlZE11bCh0aGlzLmQpLnJlZEFkZCh0aGlzLm9uZSk7XG4gIHZhciB4MiA9IGxocy5yZWRNdWwocmhzLnJlZEludm0oKSk7XG5cbiAgaWYgKHgyLmNtcCh0aGlzLnplcm8pID09PSAwKSB7XG4gICAgaWYgKG9kZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLnBvaW50KHRoaXMuemVybywgeSk7XG4gIH1cblxuICB2YXIgeCA9IHgyLnJlZFNxcnQoKTtcbiAgaWYgKHgucmVkU3FyKCkucmVkU3ViKHgyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICBpZiAoeC5pc09kZCgpICE9PSBvZGQpXG4gICAgeCA9IHgucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBDdXJ2ZTogQSAqIFheMiArIFleMiA9IENeMiAqICgxICsgRCAqIFheMiAqIFleMilcbiAgcG9pbnQubm9ybWFsaXplKCk7XG5cbiAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgdmFyIHkyID0gcG9pbnQueS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHgyLnJlZE11bCh0aGlzLmEpLnJlZEFkZCh5Mik7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuXG4gIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgeiwgdCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IHogPyBuZXcgQk4oeiwgMTYpIDogdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdCAmJiBuZXcgQk4odCwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICh0aGlzLnQgJiYgIXRoaXMudC5yZWQpXG4gICAgICB0aGlzLnQgPSB0aGlzLnQudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cbiAgICAvLyBVc2UgZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZCAmJiAhdGhpcy50KSB7XG4gICAgICB0aGlzLnQgPSB0aGlzLngucmVkTXVsKHRoaXMueSk7XG4gICAgICBpZiAoIXRoaXMuek9uZSlcbiAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICB9XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMueC5jbXBuKDApID09PSAwICYmXG4gICAgICAgICB0aGlzLnkuY21wKHRoaXMueikgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dERibCA9IGZ1bmN0aW9uIF9leHREYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgLy8gNE0gKyA0U1xuXG4gIC8vIEEgPSBYMV4yXG4gIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBCID0gWTFeMlxuICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gQyA9IDIgKiBaMV4yXG4gIHZhciBjID0gdGhpcy56LnJlZFNxcigpO1xuICBjID0gYy5yZWRJQWRkKGMpO1xuICAvLyBEID0gYSAqIEFcbiAgdmFyIGQgPSB0aGlzLmN1cnZlLl9tdWxBKGEpO1xuICAvLyBFID0gKFgxICsgWTEpXjIgLSBBIC0gQlxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gIC8vIEcgPSBEICsgQlxuICB2YXIgZyA9IGQucmVkQWRkKGIpO1xuICAvLyBGID0gRyAtIENcbiAgdmFyIGYgPSBnLnJlZFN1YihjKTtcbiAgLy8gSCA9IEQgLSBCXG4gIHZhciBoID0gZC5yZWRTdWIoYik7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1iYmpscFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA3LWJsXG4gIC8vIGFuZCBvdGhlcnNcbiAgLy8gR2VuZXJhbGx5IDNNICsgNFMgb3IgMk0gKyA0U1xuXG4gIC8vIEIgPSAoWDEgKyBZMSleMlxuICB2YXIgYiA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxXjJcbiAgdmFyIGMgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEQgPSBZMV4yXG4gIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuXG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBFID0gYSAqIENcbiAgICB2YXIgZSA9IHRoaXMuY3VydmUuX211bEEoYyk7XG4gICAgLy8gRiA9IEUgKyBEXG4gICAgdmFyIGYgPSBlLnJlZEFkZChkKTtcbiAgICBpZiAodGhpcy56T25lKSB7XG4gICAgICAvLyBYMyA9IChCIC0gQyAtIEQpICogKEYgLSAyKVxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRTdWIoZCkucmVkTXVsKGYucmVkU3ViKHRoaXMuY3VydmUudHdvKSk7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRl4yIC0gMiAqIEZcbiAgICAgIG56ID0gZi5yZWRTcXIoKS5yZWRTdWIoZikucmVkU3ViKGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIID0gWjFeMlxuICAgICAgdmFyIGggPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAvLyBKID0gRiAtIDIgKiBIXG4gICAgICB2YXIgaiA9IGYucmVkU3ViKGgpLnJlZElTdWIoaCk7XG4gICAgICAvLyBYMyA9IChCLUMtRCkqSlxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRJU3ViKGQpLnJlZE11bChqKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGICogSlxuICAgICAgbnogPSBmLnJlZE11bChqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRSA9IEMgKyBEXG4gICAgdmFyIGUgPSBjLnJlZEFkZChkKTtcbiAgICAvLyBIID0gKGMgKiBaMSleMlxuICAgIHZhciBoID0gdGhpcy5jdXJ2ZS5fbXVsQyh0aGlzLmMucmVkTXVsKHRoaXMueikpLnJlZFNxcigpO1xuICAgIC8vIEogPSBFIC0gMiAqIEhcbiAgICB2YXIgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAvLyBYMyA9IGMgKiAoQiAtIEUpICogSlxuICAgIG54ID0gdGhpcy5jdXJ2ZS5fbXVsQyhiLnJlZElTdWIoZSkpLnJlZE11bChqKTtcbiAgICAvLyBZMyA9IGMgKiBFICogKEMgLSBEKVxuICAgIG55ID0gdGhpcy5jdXJ2ZS5fbXVsQyhlKS5yZWRNdWwoYy5yZWRJU3ViKGQpKTtcbiAgICAvLyBaMyA9IEUgKiBKXG4gICAgbnogPSBlLnJlZE11bChqKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBEb3VibGUgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0QWRkID0gZnVuY3Rpb24gX2V4dEFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtM1xuICAvLyA4TVxuXG4gIC8vIEEgPSAoWTEgLSBYMSkgKiAoWTIgLSBYMilcbiAgdmFyIGEgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKHAueS5yZWRTdWIocC54KSk7XG4gIC8vIEIgPSAoWTEgKyBYMSkgKiAoWTIgKyBYMilcbiAgdmFyIGIgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKHAueS5yZWRBZGQocC54KSk7XG4gIC8vIEMgPSBUMSAqIGsgKiBUMlxuICB2YXIgYyA9IHRoaXMudC5yZWRNdWwodGhpcy5jdXJ2ZS5kZCkucmVkTXVsKHAudCk7XG4gIC8vIEQgPSBaMSAqIDIgKiBaMlxuICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgLy8gRSA9IEIgLSBBXG4gIHZhciBlID0gYi5yZWRTdWIoYSk7XG4gIC8vIEYgPSBEIC0gQ1xuICB2YXIgZiA9IGQucmVkU3ViKGMpO1xuICAvLyBHID0gRCArIENcbiAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgLy8gSCA9IEIgKyBBXG4gIHZhciBoID0gYi5yZWRBZGQoYSk7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakFkZCA9IGZ1bmN0aW9uIF9wcm9qQWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtYmJqbHBcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwNy1ibFxuICAvLyAxME0gKyAxU1xuXG4gIC8vIEEgPSBaMSAqIFoyXG4gIHZhciBhID0gdGhpcy56LnJlZE11bChwLnopO1xuICAvLyBCID0gQV4yXG4gIHZhciBiID0gYS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxICogWDJcbiAgdmFyIGMgPSB0aGlzLngucmVkTXVsKHAueCk7XG4gIC8vIEQgPSBZMSAqIFkyXG4gIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAvLyBFID0gZCAqIEMgKiBEXG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gIC8vIEYgPSBCIC0gRVxuICB2YXIgZiA9IGIucmVkU3ViKGUpO1xuICAvLyBHID0gQiArIEVcbiAgdmFyIGcgPSBiLnJlZEFkZChlKTtcbiAgLy8gWDMgPSBBICogRiAqICgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBDIC0gRClcbiAgdmFyIHRtcCA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRNdWwocC54LnJlZEFkZChwLnkpKS5yZWRJU3ViKGMpLnJlZElTdWIoZCk7XG4gIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIGEgKiBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKHRoaXMuY3VydmUuX211bEEoYykpKTtcbiAgICAvLyBaMyA9IEYgKiBHXG4gICAgbnogPSBmLnJlZE11bChnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKGMpKTtcbiAgICAvLyBaMyA9IGMgKiBGICogR1xuICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIGZhbHNlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdmFyIHppID0gdGhpcy56LnJlZEludm0oKTtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh6aSk7XG4gIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICBpZiAodGhpcy50KVxuICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgdGhpcy56T25lID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAgICB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMCAmJlxuICAgICAgICAgdGhpcy5nZXRZKCkuY21wKG90aGVyLmdldFkoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHRoaXMueik7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0aGlzLnopO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBDb21wYXRpYmlsaXR5IHdpdGggQmFzZUN1cnZlXG5Qb2ludC5wcm90b3R5cGUudG9QID0gUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZTtcblBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IFBvaW50LnByb3RvdHlwZS5hZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Vkd2FyZHMuanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xuXG5mdW5jdGlvbiBNb250Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ21vbnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmk0ID0gbmV3IEJOKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB4Mi5yZWRNdWwoeCkucmVkQWRkKHgyLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQoeCk7XG4gIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcblxuICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLnplcm87XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQodXRpbHMudG9BcnJheShieXRlcywgZW5jKSwgMSk7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeikge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHopO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gIC8vIE5vLW9wXG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RvdWJsaW5nLWRibC0xOTg3LW0tM1xuICAvLyAyTSArIDJTICsgNEFcblxuICAvLyBBID0gWDEgKyBaMVxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQUEgPSBBXjJcbiAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgLy8gQiA9IFgxIC0gWjFcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEJCID0gQl4yXG4gIHZhciBiYiA9IGIucmVkU3FyKCk7XG4gIC8vIEMgPSBBQSAtIEJCXG4gIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgLy8gWDMgPSBBQSAqIEJCXG4gIHZhciBueCA9IGFhLnJlZE11bChiYik7XG4gIC8vIFozID0gQyAqIChCQiArIEEyNCAqIEMpXG4gIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkaWZmYWRkLWRhZGQtMTk4Ny1tLTNcbiAgLy8gNE0gKyAyUyArIDZBXG5cbiAgLy8gQSA9IFgyICsgWjJcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEIgPSBYMiAtIFoyXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBDID0gWDMgKyBaM1xuICB2YXIgYyA9IHAueC5yZWRBZGQocC56KTtcbiAgLy8gRCA9IFgzIC0gWjNcbiAgdmFyIGQgPSBwLngucmVkU3ViKHAueik7XG4gIC8vIERBID0gRCAqIEFcbiAgdmFyIGRhID0gZC5yZWRNdWwoYSk7XG4gIC8vIENCID0gQyAqIEJcbiAgdmFyIGNiID0gYy5yZWRNdWwoYik7XG4gIC8vIFg1ID0gWjEgKiAoREEgKyBDQileMlxuICB2YXIgbnggPSBkaWZmLnoucmVkTXVsKGRhLnJlZEFkZChjYikucmVkU3FyKCkpO1xuICAvLyBaNSA9IFgxICogKERBIC0gQ0IpXjJcbiAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgdmFyIHQgPSBrLmNsb25lKCk7XG4gIHZhciBhID0gdGhpczsgLy8gKE4gLyAyKSAqIFEgKyBRXG4gIHZhciBiID0gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTsgLy8gKE4gLyAyKSAqIFFcbiAgdmFyIGMgPSB0aGlzOyAvLyBRXG5cbiAgZm9yICh2YXIgYml0cyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXVzaHJuKDEpKVxuICAgIGJpdHMucHVzaCh0LmFuZGxuKDEpKTtcblxuICBmb3IgKHZhciBpID0gYml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChiaXRzW2ldID09PSAwKSB7XG4gICAgICAvLyBOICogUSArIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSkgKyAoTiAvIDIpICogUVxuICAgICAgYSA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRID0gMiAqICgoTiAvIDIpICogUSArIFEpKVxuICAgICAgYiA9IGIuZGJsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE4gKiBRID0gKChOIC8gMikgKiBRICsgUSkgKyAoKE4gLyAyKSAqIFEpXG4gICAgICBiID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgKyBRID0gMiAqICgoTiAvIDIpICogUSArIFEpXG4gICAgICBhID0gYS5kYmwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmp1bWxBZGQgPSBmdW5jdGlvbiBqdW1sQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdGhpcy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL21vbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG4gIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcbiAgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO1xuICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxuaW5oZXJpdHMoU2hvcnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0KHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZXRhOiBiZXRhLFxuICAgIGxhbWJkYTogbGFtYmRhLFxuICAgIGJhc2lzOiBiYXNpc1xuICB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKSB7XG4gIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcbiAgLy8gUm9vdCA9ICgtMSArLSBTcXJ0KC0zKSkgLyAyXG4gIC8vXG4gIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogQk4ubW9udChudW0pO1xuICB2YXIgdGludiA9IG5ldyBCTigyKS50b1JlZChyZWQpLnJlZEludm0oKTtcbiAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuICB2YXIgcyA9IG5ldyBCTigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cbiAgdmFyIGwxID0gbnRpbnYucmVkQWRkKHMpLmZyb21SZWQoKTtcbiAgdmFyIGwyID0gbnRpbnYucmVkU3ViKHMpLmZyb21SZWQoKTtcbiAgcmV0dXJuIFsgbDEsIGwyIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpIHtcbiAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG4gIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuICAvLyAzLjc0XG4gIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG4gIHZhciB1ID0gbGFtYmRhO1xuICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB5MSA9IG5ldyBCTigwKTtcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xuICB2YXIgeTIgPSBuZXcgQk4oMSk7XG5cbiAgLy8gTk9URTogYWxsIHZlY3RvcnMgYXJlIHJvb3RzIG9mOiBhICsgYiAqIGxhbWJkYSA9IDAgKG1vZCBuKVxuICB2YXIgYTA7XG4gIHZhciBiMDtcbiAgLy8gRmlyc3QgdmVjdG9yXG4gIHZhciBhMTtcbiAgdmFyIGIxO1xuICAvLyBTZWNvbmQgdmVjdG9yXG4gIHZhciBhMjtcbiAgdmFyIGIyO1xuXG4gIHZhciBwcmV2UjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcjtcbiAgdmFyIHg7XG4gIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICB2YXIgcSA9IHYuZGl2KHUpO1xuICAgIHIgPSB2LnN1YihxLm11bCh1KSk7XG4gICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cbiAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICBiMCA9IHgxO1xuICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgYjEgPSB4O1xuICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldlIgPSByO1xuXG4gICAgdiA9IHU7XG4gICAgdSA9IHI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHg7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHk7XG4gIH1cbiAgYTIgPSByLm5lZygpO1xuICBiMiA9IHg7XG5cbiAgdmFyIGxlbjEgPSBhMS5zcXIoKS5hZGQoYjEuc3FyKCkpO1xuICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG4gICAgYTIgPSBhMDtcbiAgICBiMiA9IGIwO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHNpZ25zXG4gIGlmIChhMS5uZWdhdGl2ZSkge1xuICAgIGExID0gYTEubmVnKCk7XG4gICAgYjEgPSBiMS5uZWcoKTtcbiAgfVxuICBpZiAoYTIubmVnYXRpdmUpIHtcbiAgICBhMiA9IGEyLm5lZygpO1xuICAgIGIyID0gYjIubmVnKCk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHsgYTogYTEsIGI6IGIxIH0sXG4gICAgeyBhOiBhMiwgYjogYjIgfVxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMS5pbmVnKCk7XG4gICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgIH1cblxuICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG4gICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gIH1cbiAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIsIGphY29iaWFuUmVzdWx0KTtcblxuICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKVxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG4gICAgfVxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IEJOKGssIDE2KTtcblxuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICByZXR1cm4gdGhpcyA9PT0gcCB8fFxuICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG4gICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICB9O1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gbmV3IEJOKDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICB9XG4gIGlmICghdGhpcy54LnJlZClcbiAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMueS5yZWQpXG4gICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnoucmVkKVxuICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cbmluaGVyaXRzKEpQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcbiAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG4gICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG4gICAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICAgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG4gICAgZG55ID0gZG55LnJlZElBZGQoZG55KS5yZWRJU3ViKGp5ZDQpO1xuICAgIHZhciBueiA9IGp5ZC5yZWRNdWwoanopO1xuICAgIGlmIChpICsgMSA8IHBvdylcbiAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG5cbiAgICBqeCA9IG54O1xuICAgIGp6ID0gbno7XG4gICAganlkID0gZG55O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUudGhyZWVBKVxuICAgIHJldHVybiB0aGlzLl90aHJlZURibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX2RibCgpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNEFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgICAvLyBUID0gTSBeIDIgLSAyKlNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDktbFxuICAgIC8vIDJNICsgNVMgKyAxM0FcblxuICAgIC8vIEEgPSBYMV4yXG4gICAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBDID0gQl4yXG4gICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcbiAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuICAgIGQgPSBkLnJlZElBZGQoZCk7XG4gICAgLy8gRSA9IDMgKiBBXG4gICAgdmFyIGUgPSBhLnJlZEFkZChhKS5yZWRJQWRkKGEpO1xuICAgIC8vIEYgPSBFXjJcbiAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cbiAgICAvLyBYMyA9IEYgLSAyICogRFxuICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG4gICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuICAgIG55ID0gZS5yZWRNdWwoZC5yZWRJU3ViKG54KSkucmVkSVN1YihjOCk7XG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopO1xuICAgIG56ID0gbnoucmVkSUFkZChueik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTVBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYVxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KS5yZWRJQWRkKHRoaXMuY3VydmUuYSk7XG4gICAgLy8gVCA9IE1eMiAtIDIgKiBTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyICogWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbCNkb3VibGluZy1kYmwtMjAwMS1iXG4gICAgLy8gM00gKyA1U1xuXG4gICAgLy8gZGVsdGEgPSBaMV4yXG4gICAgdmFyIGRlbHRhID0gdGhpcy56LnJlZFNxcigpO1xuICAgIC8vIGdhbW1hID0gWTFeMlxuICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBiZXRhID0gWDEgKiBnYW1tYVxuICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG4gICAgLy8gYWxwaGEgPSAzICogKFgxIC0gZGVsdGEpICogKFgxICsgZGVsdGEpXG4gICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcbiAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG4gICAgLy8gWDMgPSBhbHBoYV4yIC0gOCAqIGJldGFcbiAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG4gICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcbiAgICB2YXIgYmV0YTggPSBiZXRhNC5yZWRBZGQoYmV0YTQpO1xuICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG4gICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTtcbiAgICAvLyBZMyA9IGFscGhhICogKDQgKiBiZXRhIC0gWDMpIC0gOCAqIGdhbW1hXjJcbiAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIG55ID0gYWxwaGEucmVkTXVsKGJldGE0LnJlZElTdWIobngpKS5yZWRJU3ViKGdnYW1tYTgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24gX2RibCgpIHtcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgLy8gNE0gKyA2UyArIDEwQVxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICB2YXIgankyID0gankucmVkU3FyKCk7XG5cbiAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuICBqeGQ0ID0ganhkNC5yZWRJQWRkKGp4ZDQpO1xuICB2YXIgdDEgPSBqeGQ0LnJlZE11bChqeTIpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXG4gIHZhciBqeWQ4ID0gankyLnJlZFNxcigpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcbiAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uIHRycGwoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjdHJpcGxpbmctdHBsLTIwMDctYmxcbiAgLy8gNU0gKyAxMFMgKyAuLi5cblxuICAvLyBYWCA9IFgxXjJcbiAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBZWSA9IFkxXjJcbiAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBaWiA9IFoxXjJcbiAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuICAvLyBZWVlZID0gWVleMlxuICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAvLyBNID0gMyAqIFhYICsgYSAqIFpaMjsgYSA9IDBcbiAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAvLyBNTSA9IE1eMlxuICB2YXIgbW0gPSBtLnJlZFNxcigpO1xuICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gIGUgPSBlLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRJU3ViKG1tKTtcbiAgLy8gRUUgPSBFXjJcbiAgdmFyIGVlID0gZS5yZWRTcXIoKTtcbiAgLy8gVCA9IDE2KllZWVlcbiAgdmFyIHQgPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuICAvLyBYMyA9IDQgKiAoWDEgKiBFRSAtIDQgKiBZWSAqIFUpXG4gIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcbiAgdmFyIG55ID0gdGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIC8vIFozID0gKFoxICsgRSleMiAtIFpaIC0gRUVcbiAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuICBrID0gbmV3IEJOKGssIGtiYXNlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG4gIGlmICh0aGlzID09PSBwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHkxICogejJeMyA9PSB5MiAqIHoxXjNcbiAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG4gIHZhciBwejMgPSBwejIucmVkTXVsKHAueik7XG4gIHJldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKSA9PT0gMDtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHpzID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9zaG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vZWxsaXB0aWMnKTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUubW9udChvcHRpb25zKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblxuICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcbn1cbmN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjdXJ2ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfVxuICB9KTtcbn1cblxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDE5MicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG4gICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMzg0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmYycsXG4gIGI6ICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOSAxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiAnICtcbiAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuICAgICAnZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzMnLFxuICBoYXNoOiBoYXNoLnNoYTM4NCxcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggJyArXG4gICAgJzU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3JyxcbiAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG4gICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG4gIHR5cGU6ICdtb250JyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICc3NmQwNicsXG4gIGI6ICcxJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnOSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuICB0eXBlOiAnZWR3YXJkcycsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnLTEnLFxuICBjOiAnMScsXG4gIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcblxuICAgIC8vIDQvNVxuICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4J1xuICBdXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IHJlcXVpcmUoJy4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxJyk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnXG4gICAgfSxcbiAgICB7XG4gICAgICBhOiAnMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyxcbiAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNSdcbiAgICB9XG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZVxuICBdXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIEhtYWNEUkJHID0gcmVxdWlyZSgnaG1hYy1kcmJnJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0KGVsbGlwdGljLmN1cnZlcy5oYXNPd25Qcm9wZXJ0eShvcHRpb25zKSwgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IGVsbGlwdGljLmN1cnZlc1tvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgZWxsaXB0aWMuY3VydmVzLlByZXNldEN1cnZlKVxuICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG5cbiAgdGhpcy5jdXJ2ZSA9IG9wdGlvbnMuY3VydmUuY3VydmU7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5uaCA9IHRoaXMubi51c2hybigxKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuXG4gIC8vIFBvaW50IG9uIGN1cnZlXG4gIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUob3B0aW9ucy5jdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgLy8gSGFzaCBmb3IgZnVuY3Rpb24gZm9yIERSQkdcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoIHx8IG9wdGlvbnMuY3VydmUuaGFzaDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgS2V5UGFpcih0aGlzLCBvcHRpb25zKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgZWxsaXB0aWMucmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuICB9KTtcblxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgQk4oMikpO1xuICBkbyB7XG4gICAgdmFyIHByaXYgPSBuZXcgQk4oZHJiZy5nZW5lcmF0ZShieXRlcykpO1xuICAgIGlmIChwcml2LmNtcChuczIpID4gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcHJpdi5pYWRkbigxKTtcbiAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59O1xuXG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IEhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCdcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG5cbiAgZm9yICh2YXIgaXRlciA9IDA7IHRydWU7IGl0ZXIrKykge1xuICAgIHZhciBrID0gb3B0aW9ucy5rID9cbiAgICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgICAgbmV3IEJOKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcbiAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG4gICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG4gICAgLy8gVXNlIGNvbXBsZW1lbnQgb2YgYHNgLCBpZiBpdCBpcyA+IGBuIC8gMmBcbiAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG4gICAgICBzID0gdGhpcy5uLnN1YihzKTtcbiAgICAgIHJlY292ZXJ5UGFyYW0gXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCAnaGV4Jyk7XG5cbiAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcblxuICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuICAgIHZhciBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgdmFyIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gQ29tcGFyZSBgcC54YCBvZiBKYWNvYmlhbiBwb2ludCB3aXRoIGByYCxcbiAgLy8gdGhpcyB3aWxsIGRvIGBwLnggPT0gciAqIHAuel4yYCBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIGBwLnhgIGJ5IHRoZVxuICAvLyBpbnZlcnNlIG9mIGBwLnpeMmBcbiAgcmV0dXJuIHAuZXFYVG9QKHIpO1xufTtcblxuRUMucHJvdG90eXBlLnJlY292ZXJQdWJLZXkgPSBmdW5jdGlvbihtc2csIHNpZ25hdHVyZSwgaiwgZW5jKSB7XG4gIGFzc2VydCgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcblxuICB2YXIgbiA9IHRoaXMubjtcbiAgdmFyIGUgPSBuZXcgQk4obXNnKTtcbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGogJiAxO1xuICB2YXIgaXNTZWNvbmRLZXkgPSBqID4+IDE7XG4gIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7XG5cbiAgLy8gMS4xLiBMZXQgeCA9IHIgKyBqbi5cbiAgaWYgKGlzU2Vjb25kS2V5KVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSwgaXNZT2RkKTtcbiAgZWxzZVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuICB2YXIgckludiA9IHNpZ25hdHVyZS5yLmludm0obik7XG4gIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoczEsIHIsIHMyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsIGVuYyk7XG4gIGlmIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgUXByaW1lO1xuICAgIHRyeSB7XG4gICAgICBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlLCBpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoUXByaW1lLmVxKFEpKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICB0aGlzLmVjID0gZWM7XG4gIHRoaXMucHJpdiA9IG51bGw7XG4gIHRoaXMucHViID0gbnVsbDtcblxuICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcbiAgaWYgKG9wdGlvbnMucHJpdilcbiAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgaWYgKG9wdGlvbnMucHViKVxuICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydChrZXkueCwgJ05lZWQgeCBjb29yZGluYXRlJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdzaG9ydCcgfHxcbiAgICAgICAgICAgICAgIHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ2Vkd2FyZHMnKSB7XG4gICAgICBhc3NlcnQoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG4gICAgfVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gU2lnbmF0dXJlKG9wdGlvbnMsIGVuYykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICByZXR1cm4gb3B0aW9ucztcblxuICBpZiAodGhpcy5faW1wb3J0REVSKG9wdGlvbnMsIGVuYykpXG4gICAgcmV0dXJuO1xuXG4gIGFzc2VydChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG4gIHRoaXMuciA9IG5ldyBCTihvcHRpb25zLnIsIDE2KTtcbiAgdGhpcy5zID0gbmV3IEJOKG9wdGlvbnMucywgMTYpO1xuICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgZWxzZVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5wbGFjZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcbiAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH1cbiAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcbiAgdmFyIHZhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICB2YWwgPDw9IDg7XG4gICAgdmFsIHw9IGJ1ZltvZmZdO1xuICB9XG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlscy50b0FycmF5KGRhdGEsIGVuYyk7XG4gIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKChsZW4gKyBwLnBsYWNlKSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcbiAgcC5wbGFjZSArPSBybGVuO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG4gIGlmIChyWzBdID09PSAwICYmIChyWzFdICYgMHg4MCkpIHtcbiAgICByID0gci5zbGljZSgxKTtcbiAgfVxuICBpZiAoc1swXSA9PT0gMCAmJiAoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgQk4ocik7XG4gIHRoaXMucyA9IG5ldyBCTihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL3NpZ25hdHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gIGFzc2VydChjdXJ2ZSA9PT0gJ2VkMjU1MTknLCAnb25seSB0ZXN0ZWQgd2l0aCBlZDI1NTE5IHNvIGZhcicpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFRERTQSkpXG4gICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG5cbiAgdmFyIGN1cnZlID0gZWxsaXB0aWMuY3VydmVzW2N1cnZlXS5jdXJ2ZTtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLmcgPSBjdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShjdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgdGhpcy5wb2ludENsYXNzID0gY3VydmUucG9pbnQoKS5jb25zdHJ1Y3RvcjtcbiAgdGhpcy5lbmNvZGluZ0xlbmd0aCA9IE1hdGguY2VpbChjdXJ2ZS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gIHRoaXMuaGFzaCA9IGhhc2guc2hhNTEyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVERFNBO1xuXG4vKipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfEtleVBhaXJ9IHNlY3JldCAtIHNlY3JldCBieXRlcyBvciBhIGtleXBhaXJcbiogQHJldHVybnMge1NpZ25hdHVyZX0gLSBzaWduYXR1cmVcbiovXG5FRERTQS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgc2VjcmV0KSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tU2VjcmV0KHNlY3JldCk7XG4gIHZhciByID0gdGhpcy5oYXNoSW50KGtleS5tZXNzYWdlUHJlZml4KCksIG1lc3NhZ2UpO1xuICB2YXIgUiA9IHRoaXMuZy5tdWwocik7XG4gIHZhciBSZW5jb2RlZCA9IHRoaXMuZW5jb2RlUG9pbnQoUik7XG4gIHZhciBzXyA9IHRoaXMuaGFzaEludChSZW5jb2RlZCwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAubXVsKGtleS5wcml2KCkpO1xuICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gIHJldHVybiB0aGlzLm1ha2VTaWduYXR1cmUoeyBSOiBSLCBTOiBTLCBSZW5jb2RlZDogUmVuY29kZWQgfSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtBcnJheX0gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8U2lnbmF0dXJlfSBzaWcgLSBzaWcgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8UG9pbnR8S2V5UGFpcn0gcHViIC0gcHVibGljIGtleVxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHB1YmxpYyBrZXkgbWF0Y2hlcyBzaWcgb2YgbWVzc2FnZVxuKi9cbkVERFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnLCBwdWIpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHNpZyA9IHRoaXMubWFrZVNpZ25hdHVyZShzaWcpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKHB1Yik7XG4gIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gIHZhciBTRyA9IHRoaXMuZy5tdWwoc2lnLlMoKSk7XG4gIHZhciBScGx1c0FoID0gc2lnLlIoKS5hZGQoa2V5LnB1YigpLm11bChoKSk7XG4gIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludCgpIHtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShoYXNoLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVNlY3JldCh0aGlzLCBzZWNyZXQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBzaWc7XG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMsIHNpZyk7XG59O1xuXG4vKipcbiogKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtam9zZWZzc29uLWVkZHNhLWVkMjU1MTktMDMjc2VjdGlvbi01LjJcbipcbiogRUREU0EgZGVmaW5lcyBtZXRob2RzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9pbnRzIGFuZCBpbnRlZ2Vycy4gVGhlc2UgYXJlXG4qIGhlbHBlciBjb252ZW5pZW5jZSBtZXRob2RzLCB0aGF0IHBhc3MgYWxvbmcgdG8gdXRpbGl0eSBmdW5jdGlvbnMgaW1wbGllZFxuKiBwYXJhbWV0ZXJzLlxuKlxuKi9cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVQb2ludCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG4gIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgZW5jW3RoaXMuZW5jb2RpbmdMZW5ndGggLSAxXSB8PSBwb2ludC5nZXRYKCkuaXNPZGQoKSA/IDB4ODAgOiAwO1xuICByZXR1cm4gZW5jO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzKGJ5dGVzKTtcblxuICB2YXIgbGFzdEl4ID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gIHZhciB4SXNPZGQgPSAoYnl0ZXNbbGFzdEl4XSAmIDB4ODApICE9PSAwO1xuXG4gIHZhciB5ID0gdXRpbHMuaW50RnJvbUxFKG5vcm1lZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50RnJvbVkoeSwgeElzT2RkKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtKSB7XG4gIHJldHVybiBudW0udG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShieXRlcyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaXNQb2ludCA9IGZ1bmN0aW9uIGlzUG9pbnQodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiB0aGlzLnBvaW50Q2xhc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBpbnN0YW5jZVxuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcHVibGljL3ByaXZhdGUga2V5IHBhcmFtZXRlcnNcbipcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5zZWNyZXRdIC0gc2VjcmV0IHNlZWQgYnl0ZXNcbiogQHBhcmFtIHtQb2ludH0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCAoYWthIGBBYCBpbiBlZGRzYSB0ZXJtcylcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCBlbmNvZGVkIGFzIGJ5dGVzXG4qXG4qL1xuZnVuY3Rpb24gS2V5UGFpcihlZGRzYSwgcGFyYW1zKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgdGhpcy5fc2VjcmV0ID0gcGFyc2VCeXRlcyhwYXJhbXMuc2VjcmV0KTtcbiAgaWYgKGVkZHNhLmlzUG9pbnQocGFyYW1zLnB1YikpXG4gICAgdGhpcy5fcHViID0gcGFyYW1zLnB1YjtcbiAgZWxzZVxuICAgIHRoaXMuX3B1YkJ5dGVzID0gcGFyc2VCeXRlcyhwYXJhbXMucHViKTtcbn1cblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBwdWI6IHB1YiB9KTtcbn07XG5cbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gc2VjcmV0O1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgc2VjcmV0OiBzZWNyZXQgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gIHJldHVybiB0aGlzLl9zZWNyZXQ7XG59O1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViQnl0ZXMnLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YicsIGZ1bmN0aW9uIHB1YigpIHtcbiAgaWYgKHRoaXMuX3B1YkJ5dGVzKVxuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuX3B1YkJ5dGVzKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZy5tdWwodGhpcy5wcml2KCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2Qnl0ZXMnLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gIHZhciBlZGRzYSA9IHRoaXMuZWRkc2E7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG5cbiAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgYVswXSAmPSAyNDg7XG4gIGFbbGFzdEl4XSAmPSAxMjc7XG4gIGFbbGFzdEl4XSB8PSA2NDtcblxuICByZXR1cm4gYTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdicsIGZ1bmN0aW9uIHByaXYoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLnByaXZCeXRlcygpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnaGFzaCcsIGZ1bmN0aW9uIGhhc2goKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ21lc3NhZ2VQcmVmaXgnLCBmdW5jdGlvbiBtZXNzYWdlUHJlZml4KCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSkge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2Euc2lnbihtZXNzYWdlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KG1lc3NhZ2UsIHNpZywgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGlzIHB1YmxpYyBvbmx5Jyk7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5zZWNyZXQoKSwgZW5jKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhlbmMpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnB1YkJ5dGVzKCksIGVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcblxuLyoqXG4qIEBwYXJhbSB7RUREU0F9IGVkZHNhIC0gZWRkc2EgaW5zdGFuY2VcbiogQHBhcmFtIHtBcnJheTxCeXRlcz58T2JqZWN0fSBzaWcgLVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxQb2ludH0gW3NpZy5SXSAtIFIgcG9pbnQgYXMgUG9pbnQgb3IgYnl0ZXNcbiogQHBhcmFtIHtBcnJheTxCeXRlcz58Ym59IFtzaWcuU10gLSBTIHNjYWxhciBhcyBibiBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5SZW5jb2RlZF0gLSBSIHBvaW50IGVuY29kZWRcbiogQHBhcmFtIHtBcnJheTxCeXRlcz59IFtzaWcuU2VuY29kZWRdIC0gUyBzY2FsYXIgZW5jb2RlZFxuKi9cbmZ1bmN0aW9uIFNpZ25hdHVyZShlZGRzYSwgc2lnKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcblxuICBpZiAodHlwZW9mIHNpZyAhPT0gJ29iamVjdCcpXG4gICAgc2lnID0gcGFyc2VCeXRlcyhzaWcpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICBzaWcgPSB7XG4gICAgICBSOiBzaWcuc2xpY2UoMCwgZWRkc2EuZW5jb2RpbmdMZW5ndGgpLFxuICAgICAgUzogc2lnLnNsaWNlKGVkZHNhLmVuY29kaW5nTGVuZ3RoKVxuICAgIH07XG4gIH1cblxuICBhc3NlcnQoc2lnLlIgJiYgc2lnLlMsICdTaWduYXR1cmUgd2l0aG91dCBSIG9yIFMnKTtcblxuICBpZiAoZWRkc2EuaXNQb2ludChzaWcuUikpXG4gICAgdGhpcy5fUiA9IHNpZy5SO1xuICBpZiAoc2lnLlMgaW5zdGFuY2VvZiBCTilcbiAgICB0aGlzLl9TID0gc2lnLlM7XG5cbiAgdGhpcy5fUmVuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5SKSA/IHNpZy5SIDogc2lnLlJlbmNvZGVkO1xuICB0aGlzLl9TZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlMpID8gc2lnLlMgOiBzaWcuU2VuY29kZWQ7XG59XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1MnLCBmdW5jdGlvbiBTKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5TZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSJywgZnVuY3Rpb24gUigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5SZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSZW5jb2RlZCcsIGZ1bmN0aW9uIFJlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLlIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnU2VuY29kZWQnLCBmdW5jdGlvbiBTZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlSW50KHRoaXMuUygpKTtcbn0pO1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKCkge1xuICByZXR1cm4gdGhpcy5SZW5jb2RlZCgpLmNvbmNhdCh0aGlzLlNlbmNvZGVkKCkpO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMudG9CeXRlcygpLCAnaGV4JykudG9VcHBlckNhc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9zaWduYXR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG91Ymxlczoge1xuICAgIHN0ZXA6IDQsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdlNjBmY2U5M2I1OWU5ZWM1MzAxMWFhYmMyMWMyM2U5N2IyYTMxMzY5Yjg3YTVhZTljNDRlZTg5ZTJhNmRlYzBhJyxcbiAgICAgICAgJ2Y3ZTM1MDczOTllNTk1OTI5ZGI5OWYzNGY1NzkzNzEwMTI5Njg5MWU0NGQyM2YwYmUxZjMyY2NlNjk2MTY4MjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI4MjI2MzIxMmM2MDlkOWVhMmE2ZTNlMTcyZGUyMzhkOGMzOWNhYmQ1YWMxY2ExMDY0NmUyM2ZkNWY1MTUwOCcsXG4gICAgICAgICcxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAnZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNjNkOTBkNDQ3YjAwYzljOTljZWFjMDViNjI2MmVlMDUzNDQxYzdlNTU1NTJmZmU1MjZiYWQ4ZjgzZmY0NjQwJyxcbiAgICAgICAgJzRlMjczYWRmYzczMjIyMTk1M2I0NDUzOTdmMzM2MzE0NWI5YTg5MDA4MTk5ZWNiNjIwMDNjN2YzYmVlOWRlOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YjRiNWYxNjVkZjNjMmJlOGM2MjQ0YjViNzQ1NjM4ODQzZTRhNzgxYTE1YmNkMWI2OWY3OWE1NWRmZmRmODBjJyxcbiAgICAgICAgJzRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICc5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlYmZhNGQ0OTNiZWJmOThiYTVmZWVjODEyYzJkM2I1MDk0Nzk2MTIzN2E5MTk4MzlhNTMzZWNhMGU3ZGQ3ZmEnLFxuICAgICAgICAnNWQ5YThjYTM5NzBlZjBmMjY5ZWU3ZWRhZjE3ODA4OWQ5YWU0Y2RjM2E3MTFmNzEyZGRmZDRmZGFlMWRlODk5OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMDBmNDRkYTY5NmU3MTY3Mjc5MWQwYTA5YjdiZGU0NTlmMTIxNWEyOWIzYzAzYmZlZmQ3ODM1YjM5YTQ4ZGIwJyxcbiAgICAgICAgJ2NkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICc5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlZWE2Y2FlNDZkNTViNTMwYWMyODM5ZjE0M2JkN2VjNWNmOGIyNjZhNDFkNmFmNTJkNWU2ODhkOTA5NDY5NmQnLFxuICAgICAgICAnZTU3YzZiNmM5N2RjZTFiYWIwNmU0ZTEyYmYzZWNkNWM5ODFjODk1N2NjNDE0NDJkMzE1NWRlYmYxODA5MDA4OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY3YTkxZDkxMDQ5Y2RjYjM2N2JlNGJlNmZmY2EzY2ZlZWQ2NTdkODA4NTgzZGUzM2ZhOTc4YmMxZWM2Y2IxJyxcbiAgICAgICAgJzliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICc1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlN2JjZDBiZDM1OTgzYTc3MTljY2E3NzY0Y2E5MDY3NzliNTNhMDQzYTliOGJjYWVmZjk1OWY0M2FkODYwNDcnLFxuICAgICAgICAnMTBiNzc3MGIyYTNkYTRiMzk0MDMxMDQyMGNhOTUxNDU3OWU4OGUyZTQ3ZmQ2OGIzZWExMDA0N2U4NDYwMzcyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczODVlZWQzNGMxY2RmZjIxZTZkMDgxODY4OWI4MWJkZTcxYTdmNGYxODM5N2U2NjkwYTg0MWUxNTk5YzQzODYyJyxcbiAgICAgICAgJzI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgJzdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzMyMmQ0MDEyNDNjNGUyNTgyYTIxNDdjMTA0ZDZlY2JmNzc0ZDE2M2RiMGY1ZTUzMTNiN2UwZTc0MmQwZTZiZCcsXG4gICAgICAgICc1NmU3MDc5N2U5NjY0ZWY1YmZiMDE5YmM0ZGRhZjliNzI4MDVmNjNlYTI4NzNhZjYyNGYzYTJlOTZjMjhiMmEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1NjcyYzdkMmRlMGI3ZGEyYmQxNzcwZDg5NjY1ODY4NzQxYjNmOWFmNzY0MzM5NzcyMWQ3NGQyODEzNGFiODMnLFxuICAgICAgICAnN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAnNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MjYwY2U3ZjQ2MTgwMWMzNGYwNjdjZTBmMDI4NzNhOGYxYjBlNDRkZmM2OTc1MmFjY2VjZDgxOWYzOGZkOGU4JyxcbiAgICAgICAgJ2JjMmRhODJiNmZhNWI1NzFhN2YwOTA0OTc3NmExZWY3ZWNkMjkyMjM4MDUxYzE5OGMxYTg0ZTk1YjJiNGFlMTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTUwMzdkZTBhZmMxZDhkNDNkODM0ODQxNGJiZjQxMDMwNDNlYzhmNTc1YmZkYzQzMjk1M2NjOGQyMDM3ZmEyZCcsXG4gICAgICAgICc0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAnN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyMTNjN2E3MTVjZDVkNDUzNThkMGJiZjlkYzBjZTAyMjA0YjEwYmRkZTJhM2Y1ODU0MGFkNjkwOGQwNTU5NzU0JyxcbiAgICAgICAgJzRiNmRhZDBiNWFlNDYyNTA3MDEzYWQwNjI0NWJhMTkwYmI0ODUwZjVmMzZhN2VlZGRmZjJjMjc1MzRiNDU4ZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU3YzI3MmE3YWY0YjM0ZThkYmI5MzUyYTU0MTlhODdlMjgzOGM3MGFkYzYyY2RkZjBjYzNhM2IwOGZiZDUzYycsXG4gICAgICAgICcxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAnNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NmU2NDExM2Y2NzdjZjBlMTBhMjU3MGQ1OTk5NjhkMzE1NDRlMTc5Yjc2MDQzMjk1MmMwMmE0NDE3YmRkZTM5JyxcbiAgICAgICAgJ2M5MGRkZjhkZWU0ZTk1Y2Y1NzcwNjZkNzA2ODFmMGQzNWUyYTMzZDJiNTZkMjAzMmI0YjE3NTJkMTkwMWFjMDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzczOGM1NmIwM2IyYWJlMWU4MjgxYmFhNzQzZjhmOWE4ZjdjYzY0M2RmMjZjYmVlM2FiMTUwMjQyYmNiYjg5MScsXG4gICAgICAgICc4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAnZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiOGRhOTQwMzJhOTU3NTE4ZWIwZjY0MzM1NzFlODc2MWNlZmZjNzM2OTNlODRlZGQ0OTE1MGE1NjRmNjc2ZTAzJyxcbiAgICAgICAgJzI4MDRkZmE0NDgwNWExZTRkN2M5OWNjOTc2MjgwOGIwOTJjYzU4NGQ5NWZmM2I1MTE0ODhlNGU3NGVmZGY2ZTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTgwZmVhMTQ0NDFmYjMzYTdkOGFkYWI5NDc1ZDdmYWIyMDE5ZWZmYjUxNTZhNzkyZjFhMTE3NzhlM2MwZGY1ZCcsXG4gICAgICAgICdlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAnNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MGFkODViMzg5ZDZiOTM2NDYzZjlkMDUxMjY3OGRlMjA4Y2MzMzBiMTEzMDdmZmZhYjdhYzYzZTNmYjA0ZWQ0JyxcbiAgICAgICAgJ2U1MDdhMzYyMGEzODI2MWFmZmRjYmQ5NDI3MjIyYjgzOWFlZmFiZTE1ODI4OTRkOTkxZDRkNDhjYjZlZjE1MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZjY4YjlkMmY2M2I1ZjMzOTIzOWMxYWQ5ODFmMTYyZWU4OGM1Njc4NzIzZWEzMzUxYjdiNDQ0YzllYzRjMGRhJyxcbiAgICAgICAgJzY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICcxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMDBmYTliMThlYmYzMzFlYjk2MTUzN2E0NWE0MjY2YzcwMzRmMmYwZDRlMWQwNzE2ZmI2ZWFlMjBlYWUyOWUnLFxuICAgICAgICAnZWZhNDcyNjdmZWE1MjFhMWE5ZGMzNDNhMzczNmM5NzRjMmZhZGFmYTgxZTM2YzU0ZTdkMmE0YzY2NzAyNDE0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlN2EyNmNlNjlkZDQ4MjlmM2UxMGNlYzBhOWU5OGVkMzE0M2QwODRmMzA4YjkyYzA5OTdmZGRmYzYwY2IzZTQxJyxcbiAgICAgICAgJzJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICc2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDY4YTgwYzgyODBiYjg0MDc5MzIzNGFhMTE4ZjA2MjMxZDZmMWZjNjdlNzNjNWE1ZGVkYTBmNWI0OTY5NDNlOCcsXG4gICAgICAgICdkYjhiYTlmZmY0YjU4NmQwMGM0YjFmOTE3N2IwZTI4YjViMGU3YjhmNzg0NTI5NWEyOTRjODQyNjZiMTMzMTIwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyNGFlZDdkZjY1YzgwNDI1MmRjMDI3MDkwN2EzMGIwOTYxMmFlYjk3MzQ0OWNlYTQwOTU5ODBmYzI4ZDNkNWQnLFxuICAgICAgICAnNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgJzM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzljMzkxOWE4NGE0NzQ4NzBmYWVkOGE5YzFjYzY2MDIxNTIzNDg5MDU0ZDdmMDMwOGNiZmM5OWM4YWMxZjk4Y2QnLFxuICAgICAgICAnZGRiODRmMGY0YTRkZGQ1NzU4NGYwNDRiZjI2MGU2NDE5MDUzMjZmNzZjNjRjOGU2YmU3ZTVlMDNkNGZjNTk5ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDU3MTcwYjFkZDEyZmRmOGRlMDVmMjgxZDhlMDZiYjkxZTE0OTNhOGI5MWQ0Y2M1YTIxMzgyMTIwYTk1OWU1JyxcbiAgICAgICAgJzlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICc0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NzhhNzhjMjhkZWMzZTMwYTA1ZmU5NjI5ZGU4YzM4YmIzMGQxZjVjZjlhM2EyMDhmNzYzODg5YmU1OGFkNzEnLFxuICAgICAgICAnMzQ2MjZkOWFiNWE1YjIyZmY3MDk4ZTEyZjJmZjU4MDA4N2IzODQxMWZmMjRhYzU2M2I1MTNmYzFmZDlmNDNhYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5Mjg5NTVlZTYzN2E4NDQ2MzcyOWZkMzBlN2FmZDJlZDVmOTYyNzRlNWFkN2U1Y2IwOWVkYTljMDZkOTAzYWMnLFxuICAgICAgICAnYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgJzFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYyYjBkY2U5N2VlY2U5N2MxYzliNjA0MTc5OGI4NWRmZGZiNmQ4ODgyZGEyMDMwOGY1NDA0ODI0NTI2MDg3ZScsXG4gICAgICAgICc0OTNkMTNmZWY1MjRiYTE4OGFmNGM0ZGM1NGQwNzkzNmM3YjdlZDZmYjkwZTJjZWIyYzk1MWUwMWYwYzI5OTA3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyN2ZiYmU0YjFlODgwZWE5ZWQyYjJlNjMwMWIyMTJiNTdmMWVlMTQ4Y2Q2ZGQyODc4MGU1ZTJjZjg1NmUyNDEnLFxuICAgICAgICAnYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgJ2JlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRhNDJkNDNjNWNmMTY5ZDkzOTFkZjZkZWNmNDJlZTU0MWI2ZDhmMGM5YTEzNzQwMWUyMzYzMmRkYTM0ZDI0ZicsXG4gICAgICAgICc0ZDlmOTJlNzE2ZDFjNzM1MjZmYzk5Y2NmYjhhZDM0Y2U4ODZlZWRmYThkOGU0ZjEzYTdmNzEzMWRlYmE5NDE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlYzgwZmVmMzYwY2JkZDk1NDE2MGZhZGFiMzUyYjZiOTJiNTM1NzZhODhmZWE0OTQ3MTczYjlkNDMwMGJmMTknLFxuICAgICAgICAnYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgJ2IzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmE1MGMwZjYxZDIyZTVmMDdlM2FjZWJiMWFhMDdiMTI4ZDAwMTIyMDlhMjhiOTc3NmQ3NmE4NzkzMTgwZWVmOScsXG4gICAgICAgICc2Yjg0YzY5MjIzOTdlYmE5YjcyY2QyODcyMjgxYTY4YTVlNjgzMjkzYTU3YTIxM2IzOGNkOGQ3ZDNmNGYyODExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhMWQ2MWQwY2E3MjFhMTFiMWE1YmY2YjdkODhlODQyMWEyODhhYjVkNWJiYTUyMjBlNTNkMzJiNWYwNjdlYzInLFxuICAgICAgICAnODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgJzdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc0YTUzYjljOWEyODU4NzJkMzllNTZlNjkxM2NhYjE1ZDU5YjFmYTUxMjUwOGMwMjJmMzgyZGU4MzE5NDk3YycsXG4gICAgICAgICdjY2M5ZGMzN2FiZmM5YzE2NTdiNDE1NWYyYzQ3ZjllNjY0NmIzYTFkOGNiOTg1NDM4M2RhMTNhYzA3OWFmYTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk1OTM5Njk4MTk0Mzc4NWMzZDNlNTdlZGY1MDE4Y2RiZTAzOWU3MzBlNDkxOGIzZDg4NGZkZmYwOTQ3NWI3YmEnLFxuICAgICAgICAnMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgJ2U4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjQ1ODdlMjMzNTQ3MWViODkwZWU3ODk2ZDdjZmRjODY2YmFjYmRiZDM4MzkzMTdiMzQzNmY5YjQ1NjE3ZTA3MycsXG4gICAgICAgICdkOTlmY2RkNWJmNjkwMmUyYWU5NmRkNjQ0N2MyOTlhMTg1YjkwYTM5MTMzYWVhYjM1ODI5OWU1ZTlmYWY2NTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0ODFiZGUwZTRlNGQ4ODViM2E1NDZkM2U1NDlkZTA0MmYwYWE2Y2VhMjUwZTdmZDM1OGQ2Yzg2ZGQ0NWU0NTgnLFxuICAgICAgICAnMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgJzY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmM0YTlkZjViNzEzZmUyZTlhZWY0MzBiY2MxZGM5N2EwY2Q5Y2NlZGUyZjI4NTg4Y2FkYTNhMGQyZDgzZjM2NicsXG4gICAgICAgICdkM2E4MWNhNmU3ODVjMDYzODM5MzdhZGY0Yjc5OGNhYTZlOGE5ZmJmYTU0N2IxNmQ3NThkNjY2NTgxZjMzYzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMyOGE5N2JmODI5OGJjMGQyM2Q4Yzc0OTQ1MmEzMmU2OTRiNjVlMzBhOTQ3MmEzOTU0YWIzMGZlNTMyNGNhYScsXG4gICAgICAgICc0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICc2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RkMzYyNWZhZWY1YmEwNjA3NDY2OTcxNmJiZDM3ODhkODliZGRlODE1OTU5OTY4MDkyZjc2Y2M0ZWI5YTk3ODcnLFxuICAgICAgICAnN2ExODhmYTM1MjBlMzBkNDYxZGEyNTAxMDQ1NzMxY2E5NDE0NjE5ODI4ODMzOTU5MzdmNjhkMDBjNjQ0YTU3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmNzEwZDc5ZDllYjk2MjI5N2U0ZjYyMzJiNDBlOGY3ZmViMmJjNjM4MTQ2MTRkNjkyYzEyZGU3NTI0MDgyMjFlJyxcbiAgICAgICAgJ2VhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODInXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBuYWY6IHtcbiAgICB3bmQ6IDcsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyxcbiAgICAgICAgJzM4OGY3YjBmNjMyZGU4MTQwZmUzMzdlNjJhMzdmMzU2NjUwMGE5OTkzNGMyMjMxYjZjYjlmZDc1ODRiOGU2NzInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNCcsXG4gICAgICAgICdkOGFjMjIyNjM2ZTVlM2Q2ZDRkYmE5ZGRhNmM5YzQyNmY3ODgyNzFiYWIwZDY4NDBkY2E4N2QzYWE2YWM2MmQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVjYmRmMDY0NmU1ZGI0ZWFhMzk4ZjM2NWYyZWE3YTBlM2Q0MTliN2UwMzMwZTM5Y2U5MmJkZGVkY2FjNGY5YmMnLFxuICAgICAgICAnNmFlYmNhNDBiYTI1NTk2MGEzMTc4ZDZkODYxYTU0ZGJhODEzZDBiODEzZmRlN2I1YTUwODI2MjgwODcyNjRkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlJyxcbiAgICAgICAgJ2NjMzM4OTIxYjBhN2Q5ZmQ2NDM4MDk3MTc2M2I2MWU5YWRkODg4YTQzNzVmOGUwZjA1Y2MyNjJhYzY0ZjljMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYicsXG4gICAgICAgICdkOTg0YTAzMmViNmI1ZTE5MDI0M2RkNTZkN2I3YjM2NTM3MmRiMWUyZGZmOWQ2YTgzMDFkNzRjOWM5NTNjNjFiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyODc3M2MyZDk3NTI4OGJjN2QxZDIwNWMzNzQ4NjUxYjA3NWZiYzY2MTBlNThjZGRlZWRkZjhmMTk0MDVhYTgnLFxuICAgICAgICAnYWIwOTAyZThkODgwYTg5NzU4MjEyZWI2NWNkYWY0NzNhMWEwNmRhNTIxZmE5MWYyOWI1Y2I1MmRiMDNlZDgxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGUnLFxuICAgICAgICAnNTgxZTI4NzJhODZjNzJhNjgzODQyZWMyMjhjYzZkZWZlYTQwYWYyYmQ4OTZkM2E1YzUwNGRjOWZmNmEyNmI1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0JyxcbiAgICAgICAgJzQyMTFhYjA2OTQ2MzUxNjhlOTk3YjBlYWQyYTkzZGFlY2VkMWY0YTA0YTk1YzBmNmNmYjE5OWY2OWU1NmViNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmI0ZWEwYTc5N2E0NDNkMjkzZWY1Y2ZmNDQ0ZjQ5NzlmMDZhY2ZlYmQ3ZTg2ZDI3NzQ3NTY1NjEzODM4NWI2YycsXG4gICAgICAgICc4NWU4OWJjMDM3OTQ1ZDkzYjM0MzA4M2I1YTFjODYxMzFhMDFmNjBjNTAyNjk3NjNiNTcwYzg1NGU1YzA5YjdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDUnLFxuICAgICAgICAnMzIxZWI0MDc1MzQ4ZjUzNGQ1OWMxODI1OWRkYTNlMWY0YTFiM2IyZTcxYjEwMzljNjdiZDNkOGJjZjgxOTk4YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmJyxcbiAgICAgICAgJzJkZTEwNjgyOTVkZDg2NWI2NDU2OTMzNWJkNWRkODAxODFkNzBlY2ZjODgyNjQ4NDIzYmE3NmI1MzJiN2Q2NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MjQ4Mjc5YjA5YjRkNjhkYWIyMWE5YjA2NmVkZGE4MzI2M2MzZDg0ZTA5NTcyZTI2OWNhMGNkN2Y1NDUzNzE0JyxcbiAgICAgICAgJzczMDE2ZjdiZjIzNGFhZGU1ZDFhYTcxYmRlYTJiMWZmM2ZjMGRlMmE4ODc5MTJmZmU1NGEzMmNlOTdjYjM0MDInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOScsXG4gICAgICAgICdhNjlkY2U0YTdkNmM5OGU4ZDRhMWFjYTg3ZWY4ZDcwMDNmODNjMjMwZjNhZmE3MjZhYjQwZTUyMjkwYmUxYzU1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGInLFxuICAgICAgICAnMjExOWE0NjBjZTMyNmNkYzc2YzQ1OTI2Yzk4MmZkYWMwZTEwNmU4NjFlZGY2MWM1YTAzOTA2M2YwZTBlNjQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2YTI0NWJmNmRjNjk4NTA0Yzg5YTIwY2ZkZWQ2MDg1MzE1MmI2OTUzMzZjMjgwNjNiNjFjNjVjYmQyNjllNmI0JyxcbiAgICAgICAgJ2UwMjJjZjQyYzJiZDRhNzA4YjNmNTEyNmYxNmEyNGFkOGIzM2JhNDhkMDQyM2I2ZWZkNWU2MzQ4MTAwZDhhODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNScsXG4gICAgICAgICdiOWMzOThmMTg2ODA2ZjVkMjc1NjE1MDZlNDU1NzQzM2EyY2YxNTAwOWU0OThhZTdhZGVlOWQ2M2QwMWIyMzk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzknLFxuICAgICAgICAnMjk3MmQyZGU0ZjhkMjA2ODFhNzhkOTNlYzk2ZmUyM2MyNmJmYWU4NGZiMTRkYjQzYjAxZTFlOTA1NmI4YzQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyZDE0ZGFiNDE1MGJmNDk3NDAyZmRjNDVhMjE1ZTEwZGNiMDFjMzU0OTU5YjEwY2ZlMzFjN2U5ZDg3ZmYzM2QnLFxuICAgICAgICAnODBmYzA2YmQ4Y2M1YjAxMDk4MDg4YTE5NTBlZWQwZGIwMWFhMTMyOTY3YWI0NzIyMzVmNTY0MjQ4M2IyNWVhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmJyxcbiAgICAgICAgJzFjMzgzMDNmMWNjNWMzMGYyNmU2NmJhZDdmZTcyZjcwYTY1ZWVkNGNiZTcwMjRlYjFhYTAxZjU2NDMwYmQ1N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYicsXG4gICAgICAgICdkMGUzZmE5ZWNhODcyNjkwOTU1OWUwZDc5MjY5MDQ2YmRjNTllYTEwYzcwY2UyYjAyZDQ5OWVjMjI0ZGM3ZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDUyOGVjZDliNjk2YjU0YzkwN2E5ZWQwNDU0NDdhNzliYjQwOGVjMzliNjhkZjUwNGJiNTFmNDU5YmMzZmZjOScsXG4gICAgICAgICdlZWNmNDEyNTMxMzZlNWY5OTk2NmYyMTg4MWZkNjU2ZWJjNDM0NTQwNWM1MjBkYmMwNjM0NjViNTIxNDA5OTMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2MycsXG4gICAgICAgICc3NThmM2Y0MWFmZDZlZDQyOGIzMDgxYjA1MTJmZDYyYTU0YzNmM2FmYmI1YjY3NjRiNjUzMDUyYTEyOTQ5YzlhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzQnLFxuICAgICAgICAnOTU4ZWY0MmE3ODg2YjY0MDBhMDgyNjZlOWJhMWIzNzg5NmM5NTMzMGQ5NzA3N2NiYmU4ZWIzYzc2NzFjNjBkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMmRhYzk5MWNjNGNlNGI5ZWE0NDg4N2U1YzdjMGJjZTU4YzgwMDc0YWI5ZDRkYmFlYjI4NTMxYjc3MzlmNTMwJyxcbiAgICAgICAgJ2UwZGVkYzliM2IyZjhkYWQ0ZGExZjMyZGVjMjUzMWRmOWViNWZiZWIwNTk4ZTRmZDFhMTE3ZGJhNzAzYTNjMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YicsXG4gICAgICAgICc1ZWQ0MzBkNzhjMjk2YzM1NDMxMTQzMDZkZDg2MjJkN2M2MjJlMjdjOTcwYTFkZTMxY2IzNzdiMDFhZjczMDdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDcnLFxuICAgICAgICAnY2VkYWJkOWI4MjIwM2Y3ZTEzZDIwNmZjZGY0ZTMzZDkyYTZjNTNjMjZlNWNjZTI2ZDY1Nzk5NjJjNGUzMWRmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYWY3NTQyNzJkYzg0NTYzYjAzNTJiN2ExNDMxMWFmNTVkMjQ1MzE1YWNlMjdjNjUzNjllMTVmNzE1MWQ0MWQxJyxcbiAgICAgICAgJ2NiNDc0NjYwZWYzNWY1ZjJhNDFiNjQzZmE1ZTQ2MDU3NWY0ZmE5Yjc5NjIyMzJhNWMzMmY5MDgzMThhMDQ0NzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMCcsXG4gICAgICAgICc0MTE5Yjg4NzUzYzE1YmQ2YTY5M2IwM2ZjZGRiYjQ1ZDVhYzZiZTc0YWI1ZjBlZjQ0YjBiZTk0NzVhN2U0YjQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzUnLFxuICAgICAgICAnOTFiNjQ5NjA5NDg5ZDYxM2QxZDVlNTkwZjc4ZTZkNzRlY2ZjMDYxZDU3MDQ4YmFkOWU3NmYzMDJjNWI5YzYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1NGUzMjM5ZjMyNTU3MGNkYmJmNGE4N2RlZWU4YTY2YjdmMmIzMzQ3OWQ0NjhmYmMxYTUwNzQzYmY1NmNjMTgnLFxuICAgICAgICAnNjczZmI4NmU1YmRhMzBmYjNjZDBlZDMwNGVhNDlhMDIzZWUzM2QwMTk3YTY5NWQwYzVkOTgwOTNjNTM2NjgzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZTgnLFxuICAgICAgICAnNTljOWUwYmJhMzk0ZTc2ZjQwYzBhYTU4Mzc5YTNjYjZhNWEyMjgzOTkzZTkwYzQxNjcwMDJhZjQ5MjBlMzdmNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViJyxcbiAgICAgICAgJzNiOTUyZDMyYzY3Y2Y3N2UyZTE3NDQ2ZTIwNDE4MGFiMjFmYjgwOTA4OTUxMzhiNGE0YTc5N2Y4NmU4MDg4OGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGY5ZDcwYTZiOTg3NmNlNTQ0Yzk4NTYxZjRiZTRmNzI1NDQyZTZkMmI3MzdkOWM5MWE4MzIxNzI0Y2UwOTYzZicsXG4gICAgICAgICc1NWViMmRhZmQ4NGQ2Y2NkNWY4NjJiNzg1ZGMzOWQ0YWIxNTcyMjI3MjBlZjlkYTIxN2I4YzQ1Y2YyYmEyNDE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDMnLFxuICAgICAgICAnZWZhZTljOGRiYzE0MTMwNjYxZThjZWMwMzBjODlhZDBjMTNjNjZjMGQxN2EyOTA1Y2RjNzA2YWI3Mzk5YTg2OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhJyxcbiAgICAgICAgJ2UzOGRhNzZkY2Q0NDA2MjE5ODhkMDBiY2Y3OWFmMjVkNWIyOWMwOTRkYjJhMjMxNDZkMDAzYWZkNDE5NDNlN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWYzYzQyM2E5NWQ5ZjViMzA1NDc1NGVmYTE1MGFjMzljZDI5NTUyZmUzNjAyNTczNjJkZmRlY2VmNDA1M2I0NScsXG4gICAgICAgICdmOThhM2ZkODMxZWIyYjc0OWE5M2IwZTZmMzVjZmI0MGM4Y2Q1YWE2NjdhMTU1ODFiYzJmZWRlZDQ5OGZkOWM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWEnLFxuICAgICAgICAnNzQ0YjExNTJlYWNiZTVlMzhkY2M4ODc5ODBkYTM4Yjg5NzU4NGE2NWZhMDZjZWRkMmM5MjRmOTdjYmFjNTk5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlJyxcbiAgICAgICAgJ2M1MzRhZDQ0MTc1ZmJjMzAwZjRlYTZjZTY0ODMwOWEwNDJjZTczOWE3OTE5Nzk4Y2Q4NWUyMTZjNGEzMDdmNmUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjEzYWRhOTUxMDNjNDUzNzMwNWU2OTFlNzRlOWE0YThkZDY0N2U3MTFhOTVlNzNjYjYyZGM2MDE4Y2ZkODdiOCcsXG4gICAgICAgICdlMTM4MTdiNDRlZTE0ZGU2NjNiZjRiYzgwODM0MWYzMjY5NDllMjFhNmE3NWMyNTcwNzc4NDE5YmRhZjU3MzNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmMnLFxuICAgICAgICAnMzBlOTNlODY0ZTY2OWQ4MjIyNGI5NjdjMzAyMGI4ZmE4ZDFlNGUzNTBiNmNiY2M1MzdhNDhiNTc4NDExNjNhMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5JyxcbiAgICAgICAgJ2U0OTFhNDI1MzdmNmU1OTdkNWQyOGEzMjI0YjFiYzI1ZGY5MTU0ZWZiZDJlZjFkMmNiYmEyY2FlNTM0N2Q1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk2MjQxNDQ1MGM3NmMxNjg5YzdiNDhmODIwMmVjMzdmYjIyNGNmNWFjMGJmYTE1NzAzMjhhOGEzZDdjNzdhYicsXG4gICAgICAgICcxMDBiNjEwZWM0ZmZiNDc2MGQ1YzFmYzEzM2VmNmY2YjEyNTA3YTA1MWYwNGFjNTc2MGFmYTViMjlkYjgzNDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2EnLFxuICAgICAgICAnZWYwYWZiYjIwNTYyMDU0NDhlMTY1MmM0OGU4MTI3ZmM2MDM5ZTc3YzE1YzIzNzhiN2U3ZDE1YTBkZTI5MzMxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmJyxcbiAgICAgICAgJzhiMzc4YTIyZDgyNzI3OGQ4OWM1ZTliZThmOTUwOGFlM2MyYWQ0NjI5MDM1ODYzMGFmYjM0ZGIwNGVlZGUwYTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTYyNGQ4NDc4MDczMjg2MGNlMWM3OGZjYmZlZmUwOGIyYjI5ODIzZGI5MTNmNjQ5Mzk3NWJhMGZmNDg0NzYxMCcsXG4gICAgICAgICc2ODY1MWNmOWI2ZGE5MDNlMDkxNDQ0OGM2Y2Q5ZDRjYTg5Njg3OGY1MjgyYmU0YzhjYzA2ZTJhNDA0MDc4NTc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDQnLFxuICAgICAgICAnZjU0MzVhMmJkMmJhZGY3ZDQ4NWE0ZDhiOGRiOWZjY2UzZTFlZjhlMDIwMWU0NTc4YzU0NjczYmMxZGM1ZWExZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjJyxcbiAgICAgICAgJ2Q1NmViMzBiNjk0NjNlNzIzNGY1MTM3YjczYjg0MTc3NDM0ODAwYmFjZWJmYzY4NWZjMzdiYmU5ZWZlNDA3MGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTFkMGZjZjJlYzlkZTY3NWI2MTIxMzZlNWNlNzBkMjcxYzIxNDE3YzlkMmI4YWFhYWMxMzg1OTlkMDcxNzk0MCcsXG4gICAgICAgICdlZGQ3N2Y1MGJjYjVhM2NhYjJlOTA3MzczMDk2NjdmMjY0MTQ2MmE1NDA3MGYzZDUxOTIxMmQzOWMxOTdhNjI5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODAnLFxuICAgICAgICAnYTg1NWJhYmFkNWNkNjBjODhiNDMwYTY5ZjUzYTFhN2EzODI4OTE1NDk2NDc5OWJlNDNkMDZkNzdkMzFkYTA2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjMnLFxuICAgICAgICAnNjZkYjY1NmY4N2QxZjA0ZmZmZDFmMDQ3ODhjMDY4MzA4NzFlYzVhNjRmZWVlNjg1YmQ4MGYwYjEyODZkODM3NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNGMxZmQwNGQzMDFiZTg5YjMxYzA0NDJkM2U2YWMyNDg4MzkyOGI0NWE5MzQwNzgxODY3ZDQyMzJlYzJkYmRmJyxcbiAgICAgICAgJzk0MTQ2ODVlOTdiMWI1OTU0YmQ0NmY3MzAxNzQxMzZkNTdmMWNlZWI0ODc0NDNkYzUzMjE4NTdiYTczYWJlZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzJyxcbiAgICAgICAgJzRjYjk1OTU3ZTgzZDQwYjBmNzNhZjQ1NDRjY2NmNmIxZjRiMDhkM2MwN2IyN2ZiOGQ4YzI5NjJhNDAwNzY2ZDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OCcsXG4gICAgICAgICdmYTc3OTY4MTI4ZDljOTJlZTEwMTBmMzM3YWQ0NzE3ZWZmMTVkYjVlZDNjMDQ5YjM0MTFlMDMxNWVhYTQ1OTNiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyZDMxYzIyMmY4ZjZmMGVmODZmN2M5OGQzYTMzMzVlYWQ1YmNkMzJhYmRkOTQyODlmZTRkMzA5MWFhODI0YmYnLFxuICAgICAgICAnNWYzMDMyZjU4OTIxNTZlMzljY2QzZDc5MTViOWUxZGEyZTZkYWM5ZTZmMjZlOTYxMTE4ZDE0Yjg0NjJlMTY2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1JyxcbiAgICAgICAgJzhlYzBiYTIzOGI5NmJlYzBjYmRkZGNhZTBhYTQ0MjU0MmVlZTFmZjUwYzk4NmVhNmIzOTg0N2IzY2MwOTJmZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNicsXG4gICAgICAgICc4ZGMyNDEyYWFmZTNiZTVjNGM1ZjM3ZTBlY2M1ZjlmNmE0NDY5ODlhZjA0YzRlMjVlYmFhYzQ3OWVjMWM4YzFlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2ZWM5M2U0NDdlYzgzZjA0NjdiMTgzMDJlZTYyMGY3ZTY1ZGUzMzE4NzRjOWRjNzJiZmQ4NjE2YmE5ZGE2YjUnLFxuICAgICAgICAnNWU0NjMxMTUwZTYyZmI0MGQwZThjMmE3Y2E1ODA0YTM5ZDU4MTg2YTUwZTQ5NzEzOTYyNjc3OGUyNWIwNjc0ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5JyxcbiAgICAgICAgJ2Y2NWY1ZDNlMjkyYzJlMDgxOWE1MjgzOTFjOTk0NjI0ZDc4NDg2OWQ3ZTZlYTY3ZmIxODA0MTAyNGVkYzA3ZGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxJyxcbiAgICAgICAgJ2YzZTAzMTkxNjllYjliODVkNTQwNDc5NTUzOWE1ZTY4ZmExZmJkNTgzYzA2NGQyNDYyYjY3NWYxOTRhM2RkYjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDk0ZjRiZTIxOWExYTc3MDE2ZGNkODM4NDMxYWVhMDAwMWNkYzhhZTdhNmZjNjg4NzI2NTc4ZDk3MDI4NTdhNScsXG4gICAgICAgICc0MjI0MmE5NjkyODNhNWYzMzliYTdmMDc1ZTM2YmEyYWY5MjVjZTMwZDc2N2VkNmU1NWY0YjAzMTg4MGQ1NjJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjUnLFxuICAgICAgICAnMjA0YjVkNmY4NDgyMmMzMDdlNGI0YTcxNDA3MzdhZWMyM2ZjNjNiNjViMzVmODZhMTAwMjZkYmQyZDg2NGU2YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3JyxcbiAgICAgICAgJzRmMTQzNTFkMDA4N2VmYTQ5ZDI0NWIzMjg5ODQ5ODlkNWNhZjk0NTBmMzRiZmMwZWQxNmU5NmI1OGZhOTkxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDFkNjA2M2E1ODZmYTQ3NWE3MjQ2MDRkYTAzYmM1YjkyYTJlMGQyZTBhMzZhY2ZlNGM3M2E1NTE0NzQyODgxJyxcbiAgICAgICAgJzczODY3ZjU5YzA2NTllODE5MDRmOWExYzc1NDM2OThlNjI1NjJkNjc0NGMxNjljZTdhMzZkZTAxYThkNjE1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1JyxcbiAgICAgICAgJzM5ZjIzZjM2NjgwOTA4NWJlZWJmYzcxMTgxMzEzNzc1YTk5YzlhZWQ3ZDhiYTM4YjE2MTM4NGM3NDYwMTI4NjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NicsXG4gICAgICAgICdkMjQyNGIxYjFhYmU0ZWI4MTY0MjI3YjA4NWM5YWE5NDU2ZWExMzQ5M2ZkNTYzZTA2ZmQ1MWNmNTY5NGM3OGZjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzNjU4MWVhN2JmYmJiMjkwYzE5MWEyZjUwN2E0MWNmNTY0Mzg0MjE3MGU5MTRmYWVhYjI3YzJjNTc5ZjcyNicsXG4gICAgICAgICdlYWQxMjE2ODU5NWZlMWJlOTkyNTIxMjliNmU1NmIzMzkxZjdhYjE0MTBjZDFlMGVmM2RjZGNhYmQyZmRhMjI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGUnLFxuICAgICAgICAnNmZkY2VmMDlmMmY2ZDBhMDQ0ZTY1NGFlZjYyNDEzNmY1MDNkNDU5YzNlODk4NDU4NThhNDdhOTEyOWNkZDI0ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0JyxcbiAgICAgICAgJzYwNjYwMjU3ZGQxMWIzYWE5YzhlZDYxOGQyNGVkZmYyMzA2ZDMyMGYxZDAzMDEwZTMzYTdkMjA1N2YzYjNiNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWI3YzFkY2IzY2VjMWI3ZWU3ZjMwZGVkNzlkZDIwYTBlZDFmNGNjMThjYmNmY2ZhNDEwMzYxZmQ4ZjA4ZjMxJyxcbiAgICAgICAgJzNkOThhOWNkZDAyNmRkNDNmMzkwNDhmMjVhODg0N2Y0ZmNhZmFkMTg5NWQ3YTYzM2M2ZmVkM2MzNWU5OTk1MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MScsXG4gICAgICAgICdiNGM0ZmU5OWM3NzVhNjA2ZTJkODg2MjE3OTEzOWZmZGE2MWRjODYxYzAxOWU1NWNkMjg3NmViMmEyN2Q4NGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MicsXG4gICAgICAgICdhZTQzNDEwMmVkZGUwOTU4ZWM0YjE5ZDkxN2E2YTI4ZTZiNzJkYTE4MzRhZmYwZTY1MGYwNDk1MDNhMjk2Y2YyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlOGNlYWZiOWIzZTlhMTM2ZGM3ZmY2N2U4NDAyOTViNDk5ZGZiM2IyMTMzZTRiYTExM2YyZTRjMGUxMjFlNScsXG4gICAgICAgICdjZjIxNzQxMThjOGI2ZDdhNGI0OGY2ZDUzNGNlNWM3OTQyMmMwODZhNjM0NjA1MDJiODI3Y2U2MmEzMjY2ODNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2InLFxuICAgICAgICAnNmZiOGQ1NTkxYjQ2NmY4ZmM2M2RiNTBmMWMwZjFjNjkwMTNmOTk2ODg3YjgyNDRkMmNkZWM0MTdhZmVhOGZhMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0JyxcbiAgICAgICAgJzMyMmFmNDkwOGM3MzEyYjBjZmJmZTM2OWY3YTdiM2NkYjdkNDQ5NGJjMjgyMzcwMGNmZDY1MjE4OGEzZWE5OGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWY4YWRkYmYyYjY2MWM4YTZjNjMyODY1NWViOTY2NTEyNTIwMDdkOGM1ZWEzMWJlNGFkMTk2ZGU4Y2UyMTMxZicsXG4gICAgICAgICc2NzQ5ZTY3YzAyOWI4NWY1MmEwMzRlYWZkMDk2ODM2YjI1MjA4MTg2ODBlMjZhYzhmM2RmYmNkYjcxNzQ5NzAwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5JyxcbiAgICAgICAgJzJhZWFiZTdlNDUzMTUxMDExNjIxN2YwN2JmNGQwNzMwMGRlOTdlNDg3NGY4MWY1MzM0MjBhNzJlZWIwYmQ2YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NicsXG4gICAgICAgICdiMGVhNTU4YTExM2MzMGJlYTYwZmM0Nzc1NDYwYzc5MDFmZjBiMDUzZDI1Y2EyYmRlZWU5OGYxYTRiZTVkMTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzExMzk2ZDU1ZmRhNTRjNDlmMTlhYTk3MzE4ZDhkYTYxZmE4NTg0ZTQ3YjA4NDk0NTA3N2NmMDMyNTViNTI5ODQnLFxuICAgICAgICAnOTk4Yzc0YThjZDQ1YWMwMTI4OWQ1ODMzYTdiZWI0NzQ0ZmY1MzZiMDFiMjU3YmU0YzU3NjdiZWE5M2VhNTdhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhJyxcbiAgICAgICAgJ2IyMjg0Mjc5OTk1YTM0ZTJmOWQ0ZGU3Mzk2ZmMxOGI4MGY5YjhiOWZkZDI3MGY2NjYxZjc5Y2E0YzgxYmQyNTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMCcsXG4gICAgICAgICdiZGQ0NjAzOWZlZWQxNzg4MWQxZTA4NjJkYjM0N2Y4Y2YzOTViNzRmYzRiY2RjNGU5NDBiNzRlM2FjMWYxYjEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M1MzNlNGY3ZWE4NTU1YWFjZDk3NzdhYzVjYWQyOWI5N2RkNGRlZmNjYzUzZWU3ZWEyMDQxMTliMjg4OWIxOTcnLFxuICAgICAgICAnNmYwYTI1NmJjNWVmZGY0MjlhMmZiNjI0MmYxYTQzYTJkOWI5MjViYjRhNGIzYTI2YmI4ZTBmNDVlYjU5NjA5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTMnLFxuICAgICAgICAnYzM1OWQ2OTIzYmIzOThmN2ZkNDQ3M2UxNmZlMWMyODQ3NWI3NDBkZDA5ODA3NWU2YzBlODY0OTExM2RjM2EzOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmJyxcbiAgICAgICAgJzIxYWU3ZjQ2ODBlODg5YmIxMzA2MTllMmMwZjk1YTM2MGNlYjU3M2M3MDYwMzEzOTg2MmFmZDYxN2ZhOWI5ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNDdkNmQ5YTAyYzQ4OTI3ZWJmYjg2YzEzNTliMWNhZjEzMGEzYzAyNjdkMTFjZTYzNDRiMzlmOTlkNDNjYzM4JyxcbiAgICAgICAgJzYwZWE3ZjYxYTM1MzUyNGQxYzk4N2Y2ZWNlYzkyZjA4NmQ1NjVhYjY4Nzg3MGNiMTI2ODlmZjFlMzFjNzQ0NDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YScsXG4gICAgICAgICc0OWI5NjcxNWFiNjg3OGE3OWU3OGYwN2NlNTY4MGM1ZDY2NzMwNTFiNDkzNWJkODk3ZmVhODI0Yjc3ZGMyMDhhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTEnLFxuICAgICAgICAnNWNhNTYwNzUzYmUyYTEyZmM2ZGU2Y2FmMmNiNDg5NTY1ZGI5MzYxNTZiOTUxNGUxYmI1ZTgzMDM3ZTBmYTJkNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTQyYzhlYzgyYzk5Nzk4Y2NmM2E2MTBiZTg3MGU3ODMzOGM3ZjcxMzM0OGJkMzRjODIwM2VmNDAzN2YzNTAyJyxcbiAgICAgICAgJzc1NzFkNzRlZTVlMGZiOTJhN2E4YjMzYTA3NzgzMzQxYTU0OTIxNDRjYzU0YmNjNDBhOTQ0NzM2OTM2MDY0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYScsXG4gICAgICAgICdiZTUyZDEwN2JjZmEwOWQ4YmNiOTczNmE4MjhjZmE3ZmFjOGRiMTdiZjdhNzZhMmM0MmFkOTYxNDA5MDE4Y2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjYnLFxuICAgICAgICAnOGZkNjRhMTRjMDZiNTg5YzI2Yjk0N2FlMmJjZjZiZmEwMTQ5ZWYwYmUxNGVkNGQ4MGY0NDhhMDFjNDNiMWM2ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNGY5ZWFlYTA5YjY5MTc2MTlmNmVhNmE0ZWI1NDY0ZWZkZGI1OGZkNDViMWViZWZjZGMxYTAxZDA4YjQ3OTg2JyxcbiAgICAgICAgJzM5ZTVjOTkyNWI1YTU0YjA3NDMzYTRmMThjNjE3MjZmOGJiMTMxYzAxMmNhNTQyZWIyNGE4YWMwNzIwMDY4MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZScsXG4gICAgICAgICc2MmRmYWYwN2EwZjc4ZmViMzBlMzBkNjI5NTg1M2NlMTg5ZTEyNzc2MGFkNmNmN2ZhZTE2NGUxMjJhMjA4ZDU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzQnLFxuICAgICAgICAnMjVhNzQ4YWIzNjc5NzlkOTg3MzNjMzhhMWZhMWMyZTdkYzZjYzA3ZGIyZDYwYTlhZTdhNzZhYWE0OWJkMGY3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZmVlZWYxODgxMTAxZjJjYjExNjQ0ZjNhMmFmZGZjMjA0NWUxOTkxOTE1MjkyM2YzNjdhMTc2N2MxMWNjZWRhJyxcbiAgICAgICAgJ2VjZmI3MDU2Y2YxZGUwNDJmOTQyMGJhYjM5Njc5M2MwYzM5MGJkZTc0YjRiYmRmZjE2YTgzYWUwOWE5YTc1MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OScsXG4gICAgICAgICdjZDQ1MGVjMzM1NDM4OTg2ZGZlZmExMGM1N2ZlYTliY2M1MjFhMDk1OWIyZDgwYmJmNzRiMTkwZGNhNzEyZDEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWYnLFxuICAgICAgICAnZjVjNTQ3NTRhOGY3MWVlNTQwYjliNDg3Mjg0NzNlMzE0ZjcyOWFjNTMwOGIwNjkzODM2MDk5MGUyYmZhZDEyNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYjk4NjYwZjRjNGRmYWEwNmEyYmU0NTNkNTAyMGJjOTlhMGMyZTYwYWJlMzg4NDU3ZGQ0M2ZlZmIxZWQ2MjBjJyxcbiAgICAgICAgJzZjYjlhODg3NmQ5Y2I4NTIwNjA5YWYzYWRkMjZjZDIwYTBhN2NkOGE5NDExMTMxY2U4NWY0NDEwMDA5OTIyM2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MicsXG4gICAgICAgICdmZWY1YTNjNjgwNTlhNmRlYzVkNjI0MTE0YmYxZTkxYWFjMmI5ZGE1NjhkNmFiZWIyNTcwZDU1NjQ2YjhhZGYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGEnLFxuICAgICAgICAnMWFjYjI1MGYyNTVkZDYxYzQzZDk0Y2NjNjcwZDBmNThmNDlhZTNmYTE1Yjk2NjIzZTU0MzBkYTBhZDZjNjJiMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMjY4ZjVlZjlhZDUxZTRkNzhkZTNhNzUwYzJkYzg5YjFlNjI2ZDQzNTA1ODY3OTk5OTMyZTVkYjMzYWYzZDgwJyxcbiAgICAgICAgJzVmMzEwZDRiM2M5OWI5ZWJiMTlmNzdkNDFjMWRlZTAxOGNmMGQzNGZkNDE5MTYxNDAwM2U5NDVhMTIxNmU0MjMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZCcsXG4gICAgICAgICc0MzgxMzZkNjAzZTg1OGEzYTVjNDQwYzM4ZWNjYmFkZGMxZDI5NDIxMTRlMmVkZGQ0NzQwZDA5OGNlZDFmMGQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTEnLFxuICAgICAgICAnY2RiNTU5ZWVkYzJkNzlmOTI2YmFmNDRmYjg0ZWE0ZDQ0YmNmNTBmZWU1MWQ3Y2ViMzBlMmU3ZjQ2MzAzNjc1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MmRiMGI1Mzg0ZGZiZjA1YmZhOWQ0NzJkN2FlMjZkZmU0Yjg1MWNlY2E5MWIxZWJhNTQyNjMxODBkYTMyYjYzJyxcbiAgICAgICAgJ2MzYjk5N2QwNTBlZTVkNDIzZWJhZjY2YTZkYjlmNTdiMzE4MGM5MDI4NzU2NzlkZTkyNGI2OWQ4NGE3YjM3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyJyxcbiAgICAgICAgJzZkODlhZDdiYTQ4NzZiMGIyMmMyY2EyODBjNjgyODYyZjM0MmM4NTkxZjFkYWY1MTcwZTA3YmZkOWNjYWZhN2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5MycsXG4gICAgICAgICdjYTVlZjdkNGIyMzFjOTRjM2IxNTM4OWE1ZjYzMTFlOWRhZmY3YmI2N2IxMDNlOTg4MGVmNGJmZjYzN2FjYWVjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUwOThmZjFlMWQ5ZjE0ZmI0NmEyMTBmYWRhNmM5MDNmZWYwZmI3YjRhMWRkMWQ5YWM2MGEwMzYxODAwYjdhMDAnLFxuICAgICAgICAnOTczMTE0MWQ4MWZjOGY4MDg0ZDM3YzZlNzU0MjAwNmIzZWUxYjQwZDYwZGZlNTM2MmE1YjEzMmZkMTdkZGMwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNTgnLFxuICAgICAgICAnZWUxODQ5ZjUxM2RmNzFlMzJlZmMzODk2ZWUyODI2MGM3M2JiODA1NDdhZTIyNzViYTQ5NzIzNzc5NGM4NzUzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3JyxcbiAgICAgICAgJ2QzYWEyZWQ3MWM5ZGQyMjQ3YTYyZGYwNjI3MzZlYjBiYWRkZWE5ZTM2MTIyZDJiZTg2NDFhYmNiMDA1Y2M0YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQzODQ0NzU2NmQ0ZDdiZWRhZGMyOTk0OTZhYjM1NzQyNjAwOWEzNWYyMzVjYjE0MWJlMGQ5OWNkMTBhZTNhOCcsXG4gICAgICAgICdjNGUxMDIwOTE2OTgwYTRkYTVkMDFhYzVlNmFkMzMwNzM0ZWYwZDc5MDY2MzFjNGYyMzkwNDI2YjJlZGQ3OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2UnLFxuICAgICAgICAnNjcxNjNlOTAzMjM2Mjg5Zjc3NmYyMmMyNWZiOGEzYWZjMTczMmYyYjg0YjRlOTVkYmRhNDdhZTVhMDg1MjY0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkJyxcbiAgICAgICAgJ2NkMWJjN2NiNmNjNDA3YmIyZjBjYTY0N2M3MThhNzMwY2Y3MTg3MmU3ZDBkMmE1M2ZhMjBlZmNkZmU2MTgyNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NzRmMjYwMGEzMDA3YTAwNTY4YzFhN2NlMDVkMDgxNmMxZmI4NGJmMTM3MDc5OGYxYzY5NTMyZmFlYjFhODZiJyxcbiAgICAgICAgJzI5OWQyMWY5NDEzZjMzYjNlZGY0M2IyNTcwMDQ1ODBiNzBkYjU3ZGEwYjE4MjI1OWUwOWVlY2M2OWUwZDM4YTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZicsXG4gICAgICAgICdmOTQyOWU3MzhiOGU1M2I5NjhlOTkwMTZjMDU5NzA3NzgyZTE0ZjQ1MzUzNTlkNTgyZmM0MTY5MTBiM2VlYTg3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjYnLFxuICAgICAgICAnNDYyZjliY2U2MTk4OTg2Mzg0OTkzNTAxMTNiYmM5YjEwYTg3OGQzNWRhNzA3NDBkYzY5NWE1NTllYjg4ZGI3YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiZTIwNjIwMDNjNTFjYzMwMDQ2ODI5MDQzMzBlNGRlZTdmM2RjZDEwYjAxZTU4MGJmMTk3MWIwNGQ0Y2FkMjk3JyxcbiAgICAgICAgJzYyMTg4YmM0OWQ2MWU1NDI4NTczZDQ4YTc0ZTFjNjU1YjFjNjEwOTA5MDU2ODJhMGQ1NTU4ZWQ3MmRjY2I5YmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YScsXG4gICAgICAgICc3YzEwZGZiMTY0YzM0MjVmNWM3MWEzZjlkNzk5MjAzOGYxMDY1MjI0ZjcyYmI5ZDFkOTAyYTZkMTMwMzdiNDdjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmMnLFxuICAgICAgICAnYWI4YzFlMDg2ZDA0ZTgxMzc0NGE2NTViMmRmOGQ1ZjgzYjNjZGM2ZmFhMzA4OGMxZDNhZWExNDU0ZTNhMWQ1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNWU5ZTFkYTY0OWQ5N2Q4OWU0ODY4MTE3YTQ2NWEzYTRmOGExOGRlNTdhMTQwZDM2YjNmMmFmMzQxYTIxYjUyJyxcbiAgICAgICAgJzRjYjA0NDM3ZjM5MWVkNzMxMTFhMTNjYzFkNGRkMGRiMTY5MzQ2NWMyMjQwNDgwZDg5NTVlODU5MmYyNzQ0N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYicsXG4gICAgICAgICdiZDFhZWIyMWFkMjJlYmIyMmExMGYwMzAzNDE3YzZkOTY0ZjhjZGQ3ZGYwYWNhNjE0YjEwZGMxNGQxMjVhYzQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjUnLFxuICAgICAgICAnYmZlZmFjZGIwZTVkMGZkN2RmM2EzMTFhOTRkZTA2MmIyNmI4MGM2MWZiYzk3NTA4Yjc5OTkyNjcxZWY3Y2E3ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTg1ZmRmZDEyN2MwNTY3YzZmNTNlYzFiYjYzZWMzMTU4ZTU5N2M0MGJmZTc0N2M4M2NkZGZjOTEwNjQxOTE3JyxcbiAgICAgICAgJzYwM2MxMmRhZjNkOTg2MmVmMmIyNWZlMWRlMjg5YWVkMjRlZDI5MWUwZWM2NzA4NzAzYTViZDU2N2YzMmVkMDMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOScsXG4gICAgICAgICdjYzYxNTdlZjE4YzljNjNjZDYxOTNkODM2MzFiYmVhMDA5M2UwOTY4OTQyZThjMzNkNTczN2ZkNzkwZTBkYjA4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTMnLFxuICAgICAgICAnNTUzZTA0ZjZiMDE4YjRmYTZjOGYzOWU3ZjMxMWQzMTc2MjkwZDBlMGYxOWNhNzNmMTc3MTRkOTk3N2EyMmZmOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5ZTIxNThmMGQ3YzBkNWYyNmMzNzkxZWZlZmE3OTU5NzY1NGU3YTJiMjQ2NGY1MmIxZWU2YzEzNDc3NjllZjU3JyxcbiAgICAgICAgJzcxMmZjZGQxYjkwNTNmMDkwMDNhMzQ4MWZhNzc2MmU5ZmZkN2M4ZWYzNWEzODUwOWUyZmJmMjYyOTAwODM3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2JyxcbiAgICAgICAgJ2VkOGNjOWQwNGIyOWViODc3ZDI3MGI0ODc4ZGM0M2MxOWFlZmQzMWY0ZWVlMDllZTdiNDc4MzRjMWZhNGIxYzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOCcsXG4gICAgICAgICc5ODUyMzkwYTk5NTA3Njc5ZmQwYjg2ZmQyYjM5YTg2OGQ3ZWZjMjIxNTEzNDZlMWEzY2E0NzI2NTg2YTZiZWQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwOWEyMGM2N2Q2NDkwMGZmYjY5OGM0YzgyNWY2ZDVmMjMxMGZiMDQ1MWM4NjkzNDViNzMxOWY2NDU2MDU3MjEnLFxuICAgICAgICAnOWU5OTQ5ODBkOTkxN2UyMmI3NmIwNjE5MjdmYTA0MTQzZDA5NmNjYzU0OTYzZTZhNWViZmE1ZjNmOGUyODZjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwJyxcbiAgICAgICAgJzQwMzZlZGM5MzFhNjBhZTg4OTM1M2Y3N2ZkNTNkZTRhMjcwOGIyNmI2ZjVkYTcyYWQzMzk0MTE5ZGFmNDA4ZjknXG4gICAgICBdXG4gICAgXVxuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9wcmVjb21wdXRlZC9zZWNwMjU2azEuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIG1pbkFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBtaW5VdGlscyA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMnKTtcblxudXRpbHMuYXNzZXJ0ID0gbWluQXNzZXJ0O1xudXRpbHMudG9BcnJheSA9IG1pblV0aWxzLnRvQXJyYXk7XG51dGlscy56ZXJvMiA9IG1pblV0aWxzLnplcm8yO1xudXRpbHMudG9IZXggPSBtaW5VdGlscy50b0hleDtcbnV0aWxzLmVuY29kZSA9IG1pblV0aWxzLmVuY29kZTtcblxuLy8gUmVwcmVzZW50IG51bSBpbiBhIHctTkFGIGZvcm1cbmZ1bmN0aW9uIGdldE5BRihudW0sIHcpIHtcbiAgdmFyIG5hZiA9IFtdO1xuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG4gIHdoaWxlIChrLmNtcG4oMSkgPj0gMCkge1xuICAgIHZhciB6O1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIHZhciBtb2QgPSBrLmFuZGxuKHdzIC0gMSk7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cbiAgICBuYWYucHVzaCh6KTtcblxuICAgIC8vIE9wdGltaXphdGlvbiwgc2hpZnQgYnkgd29yZCBpZiBwb3NzaWJsZVxuICAgIHZhciBzaGlmdCA9IChrLmNtcG4oMCkgIT09IDAgJiYgay5hbmRsbih3cyAtIDEpID09PSAwKSA/ICh3ICsgMSkgOiAxO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hpZnQ7IGkrKylcbiAgICAgIG5hZi5wdXNoKDApO1xuICAgIGsuaXVzaHJuKHNoaWZ0KTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdXG4gIF07XG5cbiAgazEgPSBrMS5jbG9uZSgpO1xuICBrMiA9IGsyLmNsb25lKCk7XG4gIHZhciBkMSA9IDA7XG4gIHZhciBkMiA9IDA7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblxuICAgIC8vIEZpcnN0IHBoYXNlXG4gICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG4gICAgaWYgKG0xNCA9PT0gMylcbiAgICAgIG0xNCA9IC0xO1xuICAgIGlmIChtMjQgPT09IDMpXG4gICAgICBtMjQgPSAtMTtcbiAgICB2YXIgdTE7XG4gICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuICAgICAgdTEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiX2FyZ3NcIjogW1xuXHRcdFtcblx0XHRcdHtcblx0XHRcdFx0XCJyYXdcIjogXCJlbGxpcHRpY0BeNi4wLjBcIixcblx0XHRcdFx0XCJzY29wZVwiOiBudWxsLFxuXHRcdFx0XHRcImVzY2FwZWROYW1lXCI6IFwiZWxsaXB0aWNcIixcblx0XHRcdFx0XCJuYW1lXCI6IFwiZWxsaXB0aWNcIixcblx0XHRcdFx0XCJyYXdTcGVjXCI6IFwiXjYuMC4wXCIsXG5cdFx0XHRcdFwic3BlY1wiOiBcIj49Ni4wLjAgPDcuMC4wXCIsXG5cdFx0XHRcdFwidHlwZVwiOiBcInJhbmdlXCJcblx0XHRcdH0sXG5cdFx0XHRcIi9Vc2Vycy9kZXZpY2FsaW4vRGVza3RvcC93b3Jrc3BhY2UvanMtc3RsL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ25cIlxuXHRcdF1cblx0XSxcblx0XCJfZnJvbVwiOiBcImVsbGlwdGljQD49Ni4wLjAgPDcuMC4wXCIsXG5cdFwiX2lkXCI6IFwiZWxsaXB0aWNANi40LjBcIixcblx0XCJfaW5DYWNoZVwiOiB0cnVlLFxuXHRcIl9sb2NhdGlvblwiOiBcIi9lbGxpcHRpY1wiLFxuXHRcIl9ub2RlVmVyc2lvblwiOiBcIjcuMC4wXCIsXG5cdFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuXHRcdFwiaG9zdFwiOiBcInBhY2thZ2VzLTE4LWVhc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG5cdFx0XCJ0bXBcIjogXCJ0bXAvZWxsaXB0aWMtNi40LjAudGd6XzE0ODc3OTg4NjY0MjhfMC4zMDUxMDYyMDE5MDc2MTk4M1wiXG5cdH0sXG5cdFwiX25wbVVzZXJcIjoge1xuXHRcdFwibmFtZVwiOiBcImluZHV0bnlcIixcblx0XHRcImVtYWlsXCI6IFwiZmVkb3JAaW5kdXRueS5jb21cIlxuXHR9LFxuXHRcIl9ucG1WZXJzaW9uXCI6IFwiMy4xMC44XCIsXG5cdFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcblx0XCJfcmVxdWVzdGVkXCI6IHtcblx0XHRcInJhd1wiOiBcImVsbGlwdGljQF42LjAuMFwiLFxuXHRcdFwic2NvcGVcIjogbnVsbCxcblx0XHRcImVzY2FwZWROYW1lXCI6IFwiZWxsaXB0aWNcIixcblx0XHRcIm5hbWVcIjogXCJlbGxpcHRpY1wiLFxuXHRcdFwicmF3U3BlY1wiOiBcIl42LjAuMFwiLFxuXHRcdFwic3BlY1wiOiBcIj49Ni4wLjAgPDcuMC4wXCIsXG5cdFx0XCJ0eXBlXCI6IFwicmFuZ2VcIlxuXHR9LFxuXHRcIl9yZXF1aXJlZEJ5XCI6IFtcblx0XHRcIi9icm93c2VyaWZ5LXNpZ25cIixcblx0XHRcIi9jcmVhdGUtZWNkaFwiXG5cdF0sXG5cdFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZWxsaXB0aWMvLS9lbGxpcHRpYy02LjQuMC50Z3pcIixcblx0XCJfc2hhc3VtXCI6IFwiY2FjOWFmODc2MmM4NTgzNjE4NzAwM2M4ZGZlMTkzZTVlMmVhZTVkZlwiLFxuXHRcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG5cdFwiX3NwZWNcIjogXCJlbGxpcHRpY0BeNi4wLjBcIixcblx0XCJfd2hlcmVcIjogXCIvVXNlcnMvZGV2aWNhbGluL0Rlc2t0b3Avd29ya3NwYWNlL2pzLXN0bC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduXCIsXG5cdFwiYXV0aG9yXCI6IHtcblx0XHRcIm5hbWVcIjogXCJGZWRvciBJbmR1dG55XCIsXG5cdFx0XCJlbWFpbFwiOiBcImZlZG9yQGluZHV0bnkuY29tXCJcblx0fSxcblx0XCJidWdzXCI6IHtcblx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2lzc3Vlc1wiXG5cdH0sXG5cdFwiZGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImJuLmpzXCI6IFwiXjQuNC4wXCIsXG5cdFx0XCJicm9yYW5kXCI6IFwiXjEuMC4xXCIsXG5cdFx0XCJoYXNoLmpzXCI6IFwiXjEuMC4wXCIsXG5cdFx0XCJobWFjLWRyYmdcIjogXCJeMS4wLjBcIixcblx0XHRcImluaGVyaXRzXCI6IFwiXjIuMC4xXCIsXG5cdFx0XCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6IFwiXjEuMC4wXCIsXG5cdFx0XCJtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzXCI6IFwiXjEuMC4wXCJcblx0fSxcblx0XCJkZXNjcmlwdGlvblwiOiBcIkVDIGNyeXB0b2dyYXBoeVwiLFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJicmZzXCI6IFwiXjEuNC4zXCIsXG5cdFx0XCJjb3ZlcmFsbHNcIjogXCJeMi4xMS4zXCIsXG5cdFx0XCJncnVudFwiOiBcIl4wLjQuNVwiLFxuXHRcdFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl41LjAuMFwiLFxuXHRcdFwiZ3J1bnQtY2xpXCI6IFwiXjEuMi4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLWNvbm5lY3RcIjogXCJeMS4wLjBcIixcblx0XHRcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4xLjAuMFwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMS4wLjFcIixcblx0XHRcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjMuMC4xXCIsXG5cdFx0XCJncnVudC1zYXVjZWxhYnNcIjogXCJeOC42LjJcIixcblx0XHRcImlzdGFuYnVsXCI6IFwiXjAuNC4yXCIsXG5cdFx0XCJqc2NzXCI6IFwiXjIuOS4wXCIsXG5cdFx0XCJqc2hpbnRcIjogXCJeMi42LjBcIixcblx0XHRcIm1vY2hhXCI6IFwiXjIuMS4wXCJcblx0fSxcblx0XCJkaXJlY3Rvcmllc1wiOiB7fSxcblx0XCJkaXN0XCI6IHtcblx0XHRcInNoYXN1bVwiOiBcImNhYzlhZjg3NjJjODU4MzYxODcwMDNjOGRmZTE5M2U1ZTJlYWU1ZGZcIixcblx0XHRcInRhcmJhbGxcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuNC4wLnRnelwiXG5cdH0sXG5cdFwiZmlsZXNcIjogW1xuXHRcdFwibGliXCJcblx0XSxcblx0XCJnaXRIZWFkXCI6IFwiNmIwZDJiNzZjYWFlOTE0NzE2NDljOGUyMWYwYjFkM2JhMGY5NjA5MFwiLFxuXHRcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWNcIixcblx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XCJFQ1wiLFxuXHRcdFwiRWxsaXB0aWNcIixcblx0XHRcImN1cnZlXCIsXG5cdFx0XCJDcnlwdG9ncmFwaHlcIlxuXHRdLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJtYWluXCI6IFwibGliL2VsbGlwdGljLmpzXCIsXG5cdFwibWFpbnRhaW5lcnNcIjogW1xuXHRcdHtcblx0XHRcdFwibmFtZVwiOiBcImluZHV0bnlcIixcblx0XHRcdFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG5cdFx0fVxuXHRdLFxuXHRcIm5hbWVcIjogXCJlbGxpcHRpY1wiLFxuXHRcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuXHRcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljLmdpdFwiXG5cdH0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJqc2NzXCI6IFwianNjcyBiZW5jaG1hcmtzLyouanMgbGliLyouanMgbGliLyoqLyouanMgbGliLyoqLyoqLyouanMgdGVzdC9pbmRleC5qc1wiLFxuXHRcdFwianNoaW50XCI6IFwianNjcyBiZW5jaG1hcmtzLyouanMgbGliLyouanMgbGliLyoqLyouanMgbGliLyoqLyoqLyouanMgdGVzdC9pbmRleC5qc1wiLFxuXHRcdFwibGludFwiOiBcIm5wbSBydW4ganNjcyAmJiBucG0gcnVuIGpzaGludFwiLFxuXHRcdFwidGVzdFwiOiBcIm5wbSBydW4gbGludCAmJiBucG0gcnVuIHVuaXRcIixcblx0XHRcInVuaXRcIjogXCJpc3RhbmJ1bCB0ZXN0IF9tb2NoYSAtLXJlcG9ydGVyPXNwZWMgdGVzdC9pbmRleC5qc1wiLFxuXHRcdFwidmVyc2lvblwiOiBcImdydW50IGRpc3QgJiYgZ2l0IGFkZCBkaXN0L1wiXG5cdH0sXG5cdFwidmVyc2lvblwiOiBcIjYuNC4wXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoID0gcmVxdWlyZSgnLi4vaGFzaCcpO1xudmFyIHV0aWxzID0gaGFzaC51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEJsb2NrSGFzaCgpIHtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nVG90YWwgPSAwO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO1xuICB0aGlzLm91dFNpemUgPSB0aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7XG4gIHRoaXMuaG1hY1N0cmVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5obWFjU3RyZW5ndGg7XG4gIHRoaXMucGFkTGVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGggLyA4O1xuICB0aGlzLmVuZGlhbiA9ICdiaWcnO1xuXG4gIHRoaXMuX2RlbHRhOCA9IHRoaXMuYmxvY2tTaXplIC8gODtcbiAgdGhpcy5fZGVsdGEzMiA9IHRoaXMuYmxvY2tTaXplIC8gMzI7XG59XG5leHBvcnRzLkJsb2NrSGFzaCA9IEJsb2NrSGFzaDtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgLy8gQ29udmVydCBtZXNzYWdlIHRvIGFycmF5LCBwYWQgaXQsIGFuZCBqb2luIGludG8gMzJiaXQgYmxvY2tzXG4gIG1zZyA9IHV0aWxzLnRvQXJyYXkobXNnLCBlbmMpO1xuICBpZiAoIXRoaXMucGVuZGluZylcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG4gIGVsc2VcbiAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuY29uY2F0KG1zZyk7XG4gIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG5cbiAgLy8gRW5vdWdoIGRhdGEsIHRyeSB1cGRhdGluZ1xuICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+PSB0aGlzLl9kZWx0YTgpIHtcbiAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG5cbiAgICAvLyBQcm9jZXNzIHBlbmRpbmcgZGF0YSBpbiBibG9ja3NcbiAgICB2YXIgciA9IG1zZy5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG4gICAgdGhpcy5wZW5kaW5nID0gbXNnLnNsaWNlKG1zZy5sZW5ndGggLSByLCBtc2cubGVuZ3RoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG5cbiAgICBtc2cgPSB1dGlscy5qb2luMzIobXNnLCAwLCBtc2cubGVuZ3RoIC0gciwgdGhpcy5lbmRpYW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSB0aGlzLl9kZWx0YTMyKVxuICAgICAgdGhpcy5fdXBkYXRlKG1zZywgaSwgaSArIHRoaXMuX2RlbHRhMzIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpO1xuICBhc3NlcnQodGhpcy5wZW5kaW5nID09PSBudWxsKTtcblxuICByZXR1cm4gdGhpcy5fZGlnZXN0KGVuYyk7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG4gIHZhciBsZW4gPSB0aGlzLnBlbmRpbmdUb3RhbDtcbiAgdmFyIGJ5dGVzID0gdGhpcy5fZGVsdGE4O1xuICB2YXIgayA9IGJ5dGVzIC0gKChsZW4gKyB0aGlzLnBhZExlbmd0aCkgJSBieXRlcyk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcbiAgcmVzWzBdID0gMHg4MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBrOyBpKyspXG4gICAgcmVzW2ldID0gMDtcblxuICAvLyBBcHBlbmQgbGVuZ3RoXG4gIGxlbiA8PD0gMztcbiAgaWYgKHRoaXMuZW5kaWFuID09PSAnYmlnJykge1xuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcblxuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG5cbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBobWFjID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG4gICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcbiAgdGhpcy5IYXNoID0gaGFzaDtcbiAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG4gIHRoaXMuaW5uZXIgPSBudWxsO1xuICB0aGlzLm91dGVyID0gbnVsbDtcblxuICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG4gIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuICBhc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG4gIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICBrZXkucHVzaCgwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHgzNjtcbiAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblxuICAvLyAweDM2IF4gMHg1YyA9IDB4NmFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4NmE7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG59O1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG4gIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBoYXNoLmNvbW1vbi5CbG9ja0hhc2g7XG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG4gICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcblxuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcbn1cbnV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCwgQmxvY2tIYXNoKTtcbmV4cG9ydHMucmlwZW1kMTYwID0gUklQRU1EMTYwO1xuXG5SSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuUklQRU1EMTYwLm91dFNpemUgPSAxNjA7XG5SSVBFTUQxNjAuaG1hY1N0cmVuZ3RoID0gMTkyO1xuUklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgQSA9IHRoaXMuaFswXTtcbiAgdmFyIEIgPSB0aGlzLmhbMV07XG4gIHZhciBDID0gdGhpcy5oWzJdO1xuICB2YXIgRCA9IHRoaXMuaFszXTtcbiAgdmFyIEUgPSB0aGlzLmhbNF07XG4gIHZhciBBaCA9IEE7XG4gIHZhciBCaCA9IEI7XG4gIHZhciBDaCA9IEM7XG4gIHZhciBEaCA9IEQ7XG4gIHZhciBFaCA9IEU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgIHZhciBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuICAgICAgICBzW2pdKSxcbiAgICAgIEUpO1xuICAgIEEgPSBFO1xuICAgIEUgPSBEO1xuICAgIEQgPSByb3RsMzIoQywgMTApO1xuICAgIEMgPSBCO1xuICAgIEIgPSBUO1xuICAgIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcbiAgICAgICAgc2hbal0pLFxuICAgICAgRWgpO1xuICAgIEFoID0gRWg7XG4gICAgRWggPSBEaDtcbiAgICBEaCA9IHJvdGwzMihDaCwgMTApO1xuICAgIENoID0gQmg7XG4gICAgQmggPSBUO1xuICB9XG4gIFQgPSBzdW0zMl8zKHRoaXMuaFsxXSwgQywgRGgpO1xuICB0aGlzLmhbMV0gPSBzdW0zMl8zKHRoaXMuaFsyXSwgRCwgRWgpO1xuICB0aGlzLmhbMl0gPSBzdW0zMl8zKHRoaXMuaFszXSwgRSwgQWgpO1xuICB0aGlzLmhbM10gPSBzdW0zMl8zKHRoaXMuaFs0XSwgQSwgQmgpO1xuICB0aGlzLmhbNF0gPSBzdW0zMl8zKHRoaXMuaFswXSwgQiwgQ2gpO1xuICB0aGlzLmhbMF0gPSBUO1xufTtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdsaXR0bGUnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xufTtcblxuZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiB4IF4geSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gIGVsc2VcbiAgICByZXR1cm4geCBeICh5IHwgKH56KSk7XG59XG5cbmZ1bmN0aW9uIEsoaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YTgyNzk5OTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg4ZjFiYmNkYztcbiAgZWxzZVxuICAgIHJldHVybiAweGE5NTNmZDRlO1xufVxuXG5mdW5jdGlvbiBLaChqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDUwYTI4YmU2O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVjNGRkMTI0O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZkNzAzZWYzO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDdhNmQ3NmU5O1xuICBlbHNlXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG59XG5cbnZhciByID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dO1xuXG52YXIgcmggPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl07XG5cbnZhciBzID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXTtcblxudmFyIHNoID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoID0gcmVxdWlyZSgnLi4vaGFzaCcpO1xudmFyIHV0aWxzID0gaGFzaC51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciByb3RyMzIgPSB1dGlscy5yb3RyMzI7XG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgcm90cjY0X2hpID0gdXRpbHMucm90cjY0X2hpO1xudmFyIHJvdHI2NF9sbyA9IHV0aWxzLnJvdHI2NF9sbztcbnZhciBzaHI2NF9oaSA9IHV0aWxzLnNocjY0X2hpO1xudmFyIHNocjY0X2xvID0gdXRpbHMuc2hyNjRfbG87XG52YXIgc3VtNjQgPSB1dGlscy5zdW02NDtcbnZhciBzdW02NF9oaSA9IHV0aWxzLnN1bTY0X2hpO1xudmFyIHN1bTY0X2xvID0gdXRpbHMuc3VtNjRfbG87XG52YXIgc3VtNjRfNF9oaSA9IHV0aWxzLnN1bTY0XzRfaGk7XG52YXIgc3VtNjRfNF9sbyA9IHV0aWxzLnN1bTY0XzRfbG87XG52YXIgc3VtNjRfNV9oaSA9IHV0aWxzLnN1bTY0XzVfaGk7XG52YXIgc3VtNjRfNV9sbyA9IHV0aWxzLnN1bTY0XzVfbG87XG52YXIgQmxvY2tIYXNoID0gaGFzaC5jb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMjU2KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjU2KSlcbiAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgICAgICAgICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbmV4cG9ydHMuc2hhMjU2ID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIFQxID0gc3VtMzJfNShoLCBzMV8yNTYoZSksIGNoMzIoZSwgZiwgZyksIHRoaXMua1tpXSwgV1tpXSk7XG4gICAgdmFyIFQyID0gc3VtMzIoczBfMjU2KGEpLCBtYWozMihhLCBiLCBjKSk7XG4gICAgaCA9IGc7XG4gICAgZyA9IGY7XG4gICAgZiA9IGU7XG4gICAgZSA9IHN1bTMyKGQsIFQxKTtcbiAgICBkID0gYztcbiAgICBjID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gc3VtMzIoVDEsIFQyKTtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG4gIHRoaXMuaFs1XSA9IHN1bTMyKHRoaXMuaFs1XSwgZik7XG4gIHRoaXMuaFs2XSA9IHN1bTMyKHRoaXMuaFs2XSwgZyk7XG4gIHRoaXMuaFs3XSA9IHN1bTMyKHRoaXMuaFs3XSwgaCk7XG59O1xuXG5TSEEyNTYucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBTSEEyMjQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyMjQpKVxuICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cbiAgU0hBMjU2LmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcbiAgICAgICAgICAgICAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEyMjQsIFNIQTI1Nik7XG5leHBvcnRzLnNoYTIyNCA9IFNIQTIyNDtcblxuU0hBMjI0LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTIyNC5vdXRTaXplID0gMjI0O1xuU0hBMjI0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTIyNC5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjI0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICAvLyBKdXN0IHRydW5jYXRlIG91dHB1dFxuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsXG4gICAgICAgICAgICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcbiAgICAgICAgICAgICAweDNjNmVmMzcyLCAweGZlOTRmODJiLFxuICAgICAgICAgICAgIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgICAgICAgICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcbiAgICAgICAgICAgICAweDliMDU2ODhjLCAweDJiM2U2YzFmLFxuICAgICAgICAgICAgIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsXG4gICAgICAgICAgICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuICB0aGlzLmsgPSBzaGE1MTJfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDE2MCk7XG59XG51dGlscy5pbmhlcml0cyhTSEE1MTIsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTUxMiA9IFNIQTUxMjtcblxuU0hBNTEyLmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEE1MTIub3V0U2l6ZSA9IDUxMjtcblNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEE1MTIucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEE1MTIucHJvdG90eXBlLl9wcmVwYXJlQmxvY2sgPSBmdW5jdGlvbiBfcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgLy8gMzIgeCAzMmJpdCB3b3Jkc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBnMV81MTJfaGkoV1tpIC0gNF0sIFdbaSAtIDNdKTsgIC8vIGkgLSAyXG4gICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG4gICAgdmFyIGMxX2hpID0gV1tpIC0gMTRdOyAgLy8gaSAtIDdcbiAgICB2YXIgYzFfbG8gPSBXW2kgLSAxM107XG4gICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuICAgIHZhciBjMl9sbyA9IGcwXzUxMl9sbyhXW2kgLSAzMF0sIFdbaSAtIDI5XSk7XG4gICAgdmFyIGMzX2hpID0gV1tpIC0gMzJdOyAgLy8gaSAtIDE2XG4gICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG4gICAgV1tpXSA9IHN1bTY0XzRfaGkoYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvKTtcbiAgICBXW2kgKyAxXSA9IHN1bTY0XzRfbG8oYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0X2hpLCBjNF9sbyk7XG4gICAgdmFyIFQxX2xvID0gc3VtNjRfNV9sbyhjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjNF9oaSwgYzRfbG8pO1xuXG4gICAgdmFyIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgdmFyIGMwX2xvID0gczBfNTEyX2xvKGFoLCBhbCk7XG4gICAgdmFyIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG4gICAgdmFyIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMzg0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG4gIFNIQTUxMi5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsXG4gICAgICAgICAgICAgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyxcbiAgICAgICAgICAgICAweDkxNTkwMTVhLCAweDMwNzBkZDE3LFxuICAgICAgICAgICAgIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgICAgICAgICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSxcbiAgICAgICAgICAgICAweDhlYjQ0YTg3LCAweDY4NTgxNTExLFxuICAgICAgICAgICAgIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsXG4gICAgICAgICAgICAgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMzg0LCBTSEE1MTIpO1xuZXhwb3J0cy5zaGEzODQgPSBTSEEzODQ7XG5cblNIQTM4NC5ibG9ja1NpemUgPSAxMDI0O1xuU0hBMzg0Lm91dFNpemUgPSAzODQ7XG5TSEEzODQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMzg0LnBhZExlbmd0aCA9IDEyODtcblxuU0hBMzg0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBTSEExKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpXG4gICAgcmV0dXJuIG5ldyBTSEExKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAgICAgICAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTEgPSBTSEExO1xuXG5TSEExLmJsb2NrU2l6ZSA9IDUxMjtcblNIQTEub3V0U2l6ZSA9IDE2MDtcblNIQTEuaG1hY1N0cmVuZ3RoID0gODA7XG5TSEExLnBhZExlbmd0aCA9IDY0O1xuXG5TSEExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cbiAgZm9yKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHJvdGwzMihXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdLCAxKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSB+fihpIC8gMjApO1xuICAgIHZhciB0ID0gc3VtMzJfNShyb3RsMzIoYSwgNSksIGZ0XzEocywgYiwgYywgZCksIGUsIFdbaV0sIHNoYTFfS1tzXSk7XG4gICAgZSA9IGQ7XG4gICAgZCA9IGM7XG4gICAgYyA9IHJvdGwzMihiLCAzMCk7XG4gICAgYiA9IGE7XG4gICAgYSA9IHQ7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xufTtcblxuU0hBMS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5cbmZ1bmN0aW9uIG1hajMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KTtcbn1cblxuZnVuY3Rpb24gcDMyKHgsIHksIHopIHtcbiAgcmV0dXJuIHggXiB5IF4gejtcbn1cblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuXG5mdW5jdGlvbiBzMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDYpIF4gcm90cjMyKHgsIDExKSBeIHJvdHIzMih4LCAyNSk7XG59XG5cbmZ1bmN0aW9uIGcwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNykgXiByb3RyMzIoeCwgMTgpIF4gKHggPj4+IDMpO1xufVxuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuXG5mdW5jdGlvbiBmdF8xKHMsIHgsIHksIHopIHtcbiAgaWYgKHMgPT09IDApXG4gICAgcmV0dXJuIGNoMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAxIHx8IHMgPT09IDMpXG4gICAgcmV0dXJuIHAzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDIpXG4gICAgcmV0dXJuIG1hajMyKHgsIHksIHopO1xufVxuXG5mdW5jdGlvbiBjaDY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoeGggJiB6aCkgXiAoeWggJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICh4bCAmIHpsKSBeICh5bCAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlscyA9IGV4cG9ydHM7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFlbmMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICAgIGlmIChoaSlcbiAgICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbmZ1bmN0aW9uIGh0b25sKHcpIHtcbiAgdmFyIHJlcyA9ICh3ID4+PiAyNCkgfFxuICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAgICAgKCh3IDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgICAgICgodyAmIDB4ZmYpIDw8IDI0KTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn1cbnV0aWxzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4MzIgPSB0b0hleDMyO1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gemVybzgod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDcpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuICAgIHJldHVybiAnMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDUpXG4gICAgcmV0dXJuICcwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDQpXG4gICAgcmV0dXJuICcwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuICAgIHJldHVybiAnMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDIpXG4gICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLmpvaW4zMiA9IGpvaW4zMjtcblxuZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgbSA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNba10gPSBtICYgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnNwbGl0MzIgPSBzcGxpdDMyO1xuXG5mdW5jdGlvbiByb3RyMzIodywgYikge1xuICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xufVxudXRpbHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxudXRpbHMucm90bDMyID0gcm90bDMyO1xuXG5mdW5jdGlvbiBzdW0zMihhLCBiKSB7XG4gIHJldHVybiAoYSArIGIpID4+PiAwO1xufVxudXRpbHMuc3VtMzIgPSBzdW0zMjtcblxuZnVuY3Rpb24gc3VtMzJfMyhhLCBiLCBjKSB7XG4gIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyXzQgPSBzdW0zMl80O1xuXG5mdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG59XG51dGlscy5zdW0zMl81ID0gc3VtMzJfNTtcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxudXRpbHMuYXNzZXJ0ID0gYXNzZXJ0O1xuXG51dGlscy5pbmhlcml0cyA9IGluaGVyaXRzO1xuXG5mdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gIHZhciBiaCA9IGJ1Zltwb3NdO1xuICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gIGJ1Zltwb3MgKyAxXSA9IGxvO1xufVxuZXhwb3J0cy5zdW02NCA9IHN1bTY0O1xuXG5mdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgcmV0dXJuIGhpID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfaGkgPSBzdW02NF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gYWwgKyBibDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF80X2xvID0gc3VtNjRfNF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNV9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBlbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGVoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNV9sbyA9IHN1bTY0XzVfbG87XG5cbmZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59O1xuZXhwb3J0cy5yb3RyNjRfaGkgPSByb3RyNjRfaGk7XG5cbmZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59O1xuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufTtcbmV4cG9ydHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcblxuZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMuc2hyNjRfbG8gPSBzaHI2NF9sbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXNoLmpzL2xpYi9oYXNoL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBwZXJzID0gdXRpbHMudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjRFJCRztcblxuSG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cbiAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuS1tpXSA9IDB4MDA7XG4gICAgdGhpcy5WW2ldID0gMHgwMTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShzZWVkKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMgfHwgJ2hleCcpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMuX3Jlc2VlZCsrO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaG1hYy1kcmJnL2xpYi9obWFjLWRyYmcuanNcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pbmRleG9mL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMVwiOiBcImFlcy0xMjgtZWNiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMlwiOiBcImFlcy0xMjgtY2JjXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuM1wiOiBcImFlcy0xMjgtb2ZiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuNFwiOiBcImFlcy0xMjgtY2ZiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjFcIjogXCJhZXMtMTkyLWVjYlwiLFxuXHRcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIyXCI6IFwiYWVzLTE5Mi1jYmNcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yM1wiOiBcImFlcy0xOTItb2ZiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjRcIjogXCJhZXMtMTkyLWNmYlwiLFxuXHRcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQxXCI6IFwiYWVzLTI1Ni1lY2JcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40MlwiOiBcImFlcy0yNTYtY2JjXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDNcIjogXCJhZXMtMjU2LW9mYlwiLFxuXHRcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQ0XCI6IFwiYWVzLTI1Ni1jZmJcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2UtYXNuMS9hZXNpZC5qc29uXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9hc24xLmpzXG4vLyBGZWRvciwgeW91IGFyZSBhbWF6aW5nLlxuJ3VzZSBzdHJpY3QnXG5cbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMS5qcycpXG5cbmV4cG9ydHMuY2VydGlmaWNhdGUgPSByZXF1aXJlKCcuL2NlcnRpZmljYXRlJylcblxudmFyIFJTQVByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnUlNBUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlRXhwb25lbnQnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaW1lMicpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZXhwb25lbnQyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2NvZWZmaWNpZW50JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuUlNBUHJpdmF0ZUtleSA9IFJTQVByaXZhdGVLZXlcblxudmFyIFJTQVB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdSU0FQdWJsaWNLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuUlNBUHVibGljS2V5ID0gUlNBUHVibGljS2V5XG5cbnZhciBQdWJsaWNLZXkgPSBhc24xLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5QdWJsaWNLZXkgPSBQdWJsaWNLZXlcblxudmFyIEFsZ29yaXRobUlkZW50aWZpZXIgPSBhc24xLmRlZmluZSgnQWxnb3JpdGhtSWRlbnRpZmllcicsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ25vbmUnKS5udWxsXygpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2N1cnZlJykub2JqaWQoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdnJykuaW50KClcbiAgICApLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFByaXZhdGVLZXlJbmZvID0gYXNuMS5kZWZpbmUoJ1ByaXZhdGVLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQcml2YXRlS2V5Jykub2N0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuUHJpdmF0ZUtleSA9IFByaXZhdGVLZXlJbmZvXG52YXIgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgdGhpcy5rZXkoJ2RlY3J5cHQnKS5zZXEoKS5vYmooXG4gICAgICAgIHRoaXMua2V5KCdrZGUnKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2lkJykub2JqaWQoKSxcbiAgICAgICAgICB0aGlzLmtleSgna2RlcGFyYW1zJykuc2VxKCkub2JqKFxuICAgICAgICAgICAgdGhpcy5rZXkoJ3NhbHQnKS5vY3RzdHIoKSxcbiAgICAgICAgICAgIHRoaXMua2V5KCdpdGVycycpLmludCgpXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICB0aGlzLmtleSgnY2lwaGVyJykuc2VxKCkub2JqKFxuICAgICAgICAgIHRoaXMua2V5KCdhbGdvJykub2JqaWQoKSxcbiAgICAgICAgICB0aGlzLmtleSgnaXYnKS5vY3RzdHIoKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuXG5leHBvcnRzLkVuY3J5cHRlZFByaXZhdGVLZXkgPSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuXG52YXIgRFNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdEU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJfa2V5JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZfa2V5JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuRFNBUHJpdmF0ZUtleSA9IERTQVByaXZhdGVLZXlcblxuZXhwb3J0cy5EU0FwYXJhbSA9IGFzbjEuZGVmaW5lKCdEU0FwYXJhbScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbnQoKVxufSlcblxudmFyIEVDUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdFQ1ByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKCkuZXhwbGljaXQoMCkudXNlKEVDUGFyYW1ldGVycyksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLm9wdGlvbmFsKCkuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuRUNQcml2YXRlS2V5ID0gRUNQcml2YXRlS2V5XG5cbnZhciBFQ1BhcmFtZXRlcnMgPSBhc24xLmRlZmluZSgnRUNQYXJhbWV0ZXJzJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgbmFtZWRDdXJ2ZTogdGhpcy5vYmppZCgpXG4gIH0pXG59KVxuXG5leHBvcnRzLnNpZ25hdHVyZSA9IGFzbjEuZGVmaW5lKCdzaWduYXR1cmUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3MnKS5pbnQoKVxuICApXG59KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlLWFzbjEvYXNuMS5qc1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1JhbnRhbmVuL25vZGUtZHRscy9ibG9iLzI1YTdkYzg2MWJkYTM4Y2ZlYWM5M2E3MjM1MDBlZWE0ZjBhYzJlODYvQ2VydGlmaWNhdGUuanNcbi8vIHRoYW5rcyB0byBAUmFudGFuZW5cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBhc24gPSByZXF1aXJlKCdhc24xLmpzJylcblxudmFyIFRpbWUgPSBhc24uZGVmaW5lKCdUaW1lJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgdXRjVGltZTogdGhpcy51dGN0aW1lKCksXG4gICAgZ2VuZXJhbFRpbWU6IHRoaXMuZ2VudGltZSgpXG4gIH0pXG59KVxuXG52YXIgQXR0cmlidXRlVHlwZVZhbHVlID0gYXNuLmRlZmluZSgnQXR0cmlidXRlVHlwZVZhbHVlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndHlwZScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ3ZhbHVlJykuYW55KClcbiAgKVxufSlcblxudmFyIEFsZ29yaXRobUlkZW50aWZpZXIgPSBhc24uZGVmaW5lKCdBbGdvcml0aG1JZGVudGlmaWVyJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFN1YmplY3RQdWJsaWNLZXlJbmZvID0gYXNuLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuXG52YXIgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSA9IGFzbi5kZWZpbmUoJ1JlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0b2YoQXR0cmlidXRlVHlwZVZhbHVlKVxufSlcblxudmFyIFJETlNlcXVlbmNlID0gYXNuLmRlZmluZSgnUkROU2VxdWVuY2UnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2Vxb2YoUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSlcbn0pXG5cbnZhciBOYW1lID0gYXNuLmRlZmluZSgnTmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIHJkblNlcXVlbmNlOiB0aGlzLnVzZShSRE5TZXF1ZW5jZSlcbiAgfSlcbn0pXG5cbnZhciBWYWxpZGl0eSA9IGFzbi5kZWZpbmUoJ1ZhbGlkaXR5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnbm90QmVmb3JlJykudXNlKFRpbWUpLFxuICAgIHRoaXMua2V5KCdub3RBZnRlcicpLnVzZShUaW1lKVxuICApXG59KVxuXG52YXIgRXh0ZW5zaW9uID0gYXNuLmRlZmluZSgnRXh0ZW5zaW9uJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnZXh0bklEJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnY3JpdGljYWwnKS5ib29sKCkuZGVmKGZhbHNlKSxcbiAgICB0aGlzLmtleSgnZXh0blZhbHVlJykub2N0c3RyKClcbiAgKVxufSlcblxudmFyIFRCU0NlcnRpZmljYXRlID0gYXNuLmRlZmluZSgnVEJTQ2VydGlmaWNhdGUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuZXhwbGljaXQoMCkuaW50KCksXG4gICAgdGhpcy5rZXkoJ3NlcmlhbE51bWJlcicpLmludCgpLFxuICAgIHRoaXMua2V5KCdzaWduYXR1cmUnKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ2lzc3VlcicpLnVzZShOYW1lKSxcbiAgICB0aGlzLmtleSgndmFsaWRpdHknKS51c2UoVmFsaWRpdHkpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0JykudXNlKE5hbWUpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHVibGljS2V5SW5mbycpLnVzZShTdWJqZWN0UHVibGljS2V5SW5mbyksXG4gICAgdGhpcy5rZXkoJ2lzc3VlclVuaXF1ZUlEJykuaW1wbGljaXQoMSkuYml0c3RyKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFVuaXF1ZUlEJykuaW1wbGljaXQoMikuYml0c3RyKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnZXh0ZW5zaW9ucycpLmV4cGxpY2l0KDMpLnNlcW9mKEV4dGVuc2lvbikub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgWDUwOUNlcnRpZmljYXRlID0gYXNuLmRlZmluZSgnWDUwOUNlcnRpZmljYXRlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndGJzQ2VydGlmaWNhdGUnKS51c2UoVEJTQ2VydGlmaWNhdGUpLFxuICAgIHRoaXMua2V5KCdzaWduYXR1cmVBbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZVZhbHVlJykuYml0c3RyKClcbiAgKVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBYNTA5Q2VydGlmaWNhdGVcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1hc24xL2NlcnRpZmljYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGF0aWwvcGVtc3RyaXBcbnZhciBmaW5kUHJvYyA9IC9Qcm9jLVR5cGU6IDQsRU5DUllQVEVEXFxuXFxyP0RFSy1JbmZvOiBBRVMtKCg/OjEyOCl8KD86MTkyKXwoPzoyNTYpKS1DQkMsKFswLTlBLUhdKylcXG5cXHI/XFxuXFxyPyhbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxuXFxyPy9tXG52YXIgc3RhcnRSZWdleCA9IC9eLS0tLS1CRUdJTiAoKD86LiogS0VZKXxDRVJUSUZJQ0FURSktLS0tLVxcbi9tXG52YXIgZnVsbFJlZ2V4ID0gL14tLS0tLUJFR0lOICgoPzouKiBLRVkpfENFUlRJRklDQVRFKS0tLS0tXFxuXFxyPyhbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxuXFxyPy0tLS0tRU5EIFxcMS0tLS0tJC9tXG52YXIgZXZwID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChva2V5LCBwYXNzd29yZCkge1xuICB2YXIga2V5ID0gb2tleS50b1N0cmluZygpXG4gIHZhciBtYXRjaCA9IGtleS5tYXRjaChmaW5kUHJvYylcbiAgdmFyIGRlY3J5cHRlZFxuICBpZiAoIW1hdGNoKSB7XG4gICAgdmFyIG1hdGNoMiA9IGtleS5tYXRjaChmdWxsUmVnZXgpXG4gICAgZGVjcnlwdGVkID0gbmV3IEJ1ZmZlcihtYXRjaDJbMl0ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKVxuICB9IGVsc2Uge1xuICAgIHZhciBzdWl0ZSA9ICdhZXMnICsgbWF0Y2hbMV1cbiAgICB2YXIgaXYgPSBuZXcgQnVmZmVyKG1hdGNoWzJdLCAnaGV4JylcbiAgICB2YXIgY2lwaGVyVGV4dCA9IG5ldyBCdWZmZXIobWF0Y2hbM10ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKVxuICAgIHZhciBjaXBoZXJLZXkgPSBldnAocGFzc3dvcmQsIGl2LnNsaWNlKDAsIDgpLCBwYXJzZUludChtYXRjaFsxXSwgMTApKS5rZXlcbiAgICB2YXIgb3V0ID0gW11cbiAgICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBjaXBoZXJLZXksIGl2KVxuICAgIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gICAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gICAgZGVjcnlwdGVkID0gQnVmZmVyLmNvbmNhdChvdXQpXG4gIH1cbiAgdmFyIHRhZyA9IGtleS5tYXRjaChzdGFydFJlZ2V4KVsxXVxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIGRhdGE6IGRlY3J5cHRlZFxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2UtYXNuMS9maXhQcm9jLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BWF9BTExPQyA9IE1hdGgucG93KDIsIDMwKSAtIDEgLy8gZGVmYXVsdCBpbiBpb2pzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRpb25zLCBrZXlsZW4pIHtcbiAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpdGVyYXRpb25zIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5bGVuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChrZXlsZW4gPCAwIHx8IGtleWxlbiA+IE1BWF9BTExPQyB8fCBrZXlsZW4gIT09IGtleWxlbikgeyAvKiBlc2xpbnQgbm8tc2VsZi1jb21wYXJlOiAwICovXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGJrZGYyL3ByZWNvbmRpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMucHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJy4vcHVibGljRW5jcnlwdCcpO1xuZXhwb3J0cy5wcml2YXRlRGVjcnlwdCA9IHJlcXVpcmUoJy4vcHJpdmF0ZURlY3J5cHQnKTtcblxuZXhwb3J0cy5wcml2YXRlRW5jcnlwdCA9IGZ1bmN0aW9uIHByaXZhdGVFbmNyeXB0KGtleSwgYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY0VuY3J5cHQoa2V5LCBidWYsIHRydWUpO1xufTtcblxuZXhwb3J0cy5wdWJsaWNEZWNyeXB0ID0gZnVuY3Rpb24gcHVibGljRGVjcnlwdChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wcml2YXRlRGVjcnlwdChrZXksIGJ1ZiwgdHJ1ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wdWJsaWMtZW5jcnlwdC9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpO1xudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcml2YXRlRGVjcnlwdChwcml2YXRlX2tleSwgZW5jLCByZXZlcnNlKSB7XG4gIHZhciBwYWRkaW5nO1xuICBpZiAocHJpdmF0ZV9rZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwcml2YXRlX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICBcbiAgdmFyIGtleSA9IHBhcnNlS2V5cyhwcml2YXRlX2tleSk7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICBpZiAoZW5jLmxlbmd0aCA+IGsgfHwgbmV3IGJuKGVuYykuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgdmFyIG1zZztcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBtc2cgPSB3aXRoUHVibGljKG5ldyBibihlbmMpLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IGNydChlbmMsIGtleSk7XG4gIH1cbiAgdmFyIHpCdWZmZXIgPSBuZXcgQnVmZmVyKGsgLSBtc2cubGVuZ3RoKTtcbiAgekJ1ZmZlci5maWxsKDApO1xuICBtc2cgPSBCdWZmZXIuY29uY2F0KFt6QnVmZmVyLCBtc2ddLCBrKTtcbiAgaWYgKHBhZGRpbmcgPT09IDQpIHtcbiAgICByZXR1cm4gb2FlcChrZXksIG1zZyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHJldHVybiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHJldHVybiBtc2c7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBuID0ga2V5Lm1vZHVsdXM7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtc2dbMF0gIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgbWFza2VkU2VlZCA9IG1zZy5zbGljZSgxLCBoTGVuICsgMSk7XG4gIHZhciBtYXNrZWREYiA9ICBtc2cuc2xpY2UoaExlbiArIDEpO1xuICB2YXIgc2VlZCA9IHhvcihtYXNrZWRTZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKTtcbiAgdmFyIGRiID0geG9yKG1hc2tlZERiLCBtZ2Yoc2VlZCwgayAtIGhMZW4gLSAxKSk7XG4gIGlmIChjb21wYXJlKGlIYXNoLCBkYi5zbGljZSgwLCBoTGVuKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgaSA9IGhMZW47XG4gIHdoaWxlIChkYltpXSA9PT0gMCkge1xuICAgIGkrKztcbiAgfVxuICBpZiAoZGJbaSsrXSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHJldHVybiBkYi5zbGljZShpKTtcbn1cblxuZnVuY3Rpb24gcGtjczEoa2V5LCBtc2csIHJldmVyc2Upe1xuICB2YXIgcDEgPSBtc2cuc2xpY2UoMCwgMik7XG4gIHZhciBpID0gMjtcbiAgdmFyIHN0YXR1cyA9IDA7XG4gIHdoaWxlIChtc2dbaSsrXSAhPT0gMCkge1xuICAgIGlmIChpID49IG1zZy5sZW5ndGgpIHtcbiAgICAgIHN0YXR1cysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBwcyA9IG1zZy5zbGljZSgyLCBpIC0gMSk7XG4gIHZhciBwMiA9IG1zZy5zbGljZShpIC0gMSwgaSk7XG5cbiAgaWYgKChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAyJyAmJiAhcmV2ZXJzZSkgfHwgKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDEnICYmIHJldmVyc2UpKXtcbiAgICBzdGF0dXMrKztcbiAgfVxuICBpZiAocHMubGVuZ3RoIDwgOCkge1xuICAgIHN0YXR1cysrO1xuICB9XG4gIGlmIChzdGF0dXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICByZXR1cm4gIG1zZy5zbGljZShpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYil7XG4gIGEgPSBuZXcgQnVmZmVyKGEpO1xuICBiID0gbmV3IEJ1ZmZlcihiKTtcbiAgdmFyIGRpZiA9IDA7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIGRpZisrO1xuICAgIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIH1cbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGRpZiArPSAoYVtpXSBeIGJbaV0pO1xuICB9XG4gIHJldHVybiBkaWY7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1YmxpYy1lbmNyeXB0L3ByaXZhdGVEZWNyeXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKTtcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJyk7XG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKTtcblxudmFyIGNvbnN0YW50cyA9IHtcbiAgUlNBX1BLQ1MxX09BRVBfUEFERElORzogNCxcbiAgUlNBX1BLQ1MxX1BBRERJTjogMSxcbiAgUlNBX05PX1BBRERJTkc6IDNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVibGljRW5jcnlwdChwdWJsaWNfa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmc7XG4gIGlmIChwdWJsaWNfa2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHVibGljX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHB1YmxpY19rZXkpO1xuICB2YXIgcGFkZGVkTXNnO1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHBhZGRlZE1zZyA9IG9hZXAoa2V5LCBtc2cpO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICBwYWRkZWRNc2cgPSBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHBhZGRlZE1zZyA9IG5ldyBibihtc2cpO1xuICAgIGlmIChwYWRkZWRNc2cuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIGxvbmcgZm9yIG1vZHVsdXMnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHJldHVybiBjcnQocGFkZGVkTXNnLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtTGVuID4gayAtIGhMZW4yIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpO1xuICB9XG4gIHZhciBwcyA9IG5ldyBCdWZmZXIoayAtIG1MZW4gLSBoTGVuMiAtIDIpO1xuICBwcy5maWxsKDApO1xuICB2YXIgZGJsZW4gPSBrIC0gaExlbiAtIDE7XG4gIHZhciBzZWVkID0gcmFuZG9tQnl0ZXMoaExlbik7XG4gIHZhciBtYXNrZWREYiA9IHhvcihCdWZmZXIuY29uY2F0KFtpSGFzaCwgcHMsIG5ldyBCdWZmZXIoWzFdKSwgbXNnXSwgZGJsZW4pLCBtZ2Yoc2VlZCwgZGJsZW4pKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSB4b3Ioc2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSk7XG4gIHJldHVybiBuZXcgYm4oQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMF0pLCBtYXNrZWRTZWVkLCBtYXNrZWREYl0sIGspKTtcbn1cbmZ1bmN0aW9uIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKXtcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoO1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgaWYgKG1MZW4gPiBrIC0gMTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgcHM7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcHMgPSBuZXcgQnVmZmVyKGsgLSBtTGVuIC0gMyk7XG4gICAgcHMuZmlsbCgweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBwcyA9IG5vblplcm8oayAtIG1MZW4gLSAzKTtcbiAgfVxuICByZXR1cm4gbmV3IGJuKEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzAsIHJldmVyc2U/MToyXSksIHBzLCBuZXcgQnVmZmVyKFswXSksIG1zZ10sIGspKTtcbn1cbmZ1bmN0aW9uIG5vblplcm8obGVuLCBjcnlwdG8pIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gIHZhciBjdXIgPSAwO1xuICB2YXIgbnVtO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChjdXIgPT09IGNhY2hlLmxlbmd0aCkge1xuICAgICAgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gICAgICBjdXIgPSAwO1xuICAgIH1cbiAgICBudW0gPSBjYWNoZVtjdXIrK107XG4gICAgaWYgKG51bSkge1xuICAgICAgb3V0W2krK10gPSBudW07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanNcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKiBAcHJlc2VydmVcbihjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLy8gY29uc3RhbnRzIHRhYmxlXG52YXIgemwgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl1cblxudmFyIHpyID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dXG5cbnZhciBzbCA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl1cblxudmFyIHNyID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXVxuXG52YXIgaGwgPSBbMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV1cbnZhciBociA9IFsweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXVxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMgKGJ5dGVzKSB7XG4gIHZhciB3b3JkcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpIHtcbiAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpXG4gIH1cbiAgcmV0dXJuIHdvcmRzXG59XG5cbmZ1bmN0aW9uIHdvcmRzVG9CeXRlcyAod29yZHMpIHtcbiAgdmFyIGJ5dGVzID0gW11cbiAgZm9yICh2YXIgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KSB7XG4gICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrIChILCBNLCBvZmZzZXQpIHtcbiAgLy8gc3dhcCBlbmRpYW5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaVxuICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV1cblxuICAgIC8vIFN3YXBcbiAgICBNW29mZnNldF9pXSA9IChcbiAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gICAgKVxuICB9XG5cbiAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbFxuICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyXG5cbiAgYXIgPSBhbCA9IEhbMF1cbiAgYnIgPSBibCA9IEhbMV1cbiAgY3IgPSBjbCA9IEhbMl1cbiAgZHIgPSBkbCA9IEhbM11cbiAgZXIgPSBlbCA9IEhbNF1cblxuICAvLyBjb21wdXRhdGlvblxuICB2YXIgdFxuICBmb3IgKGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgIHQgPSAoYWwgKyBNW29mZnNldCArIHpsW2ldXSkgfCAwXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdCArPSBmMShibCwgY2wsIGRsKSArIGhsWzBdXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHQgKz0gZjIoYmwsIGNsLCBkbCkgKyBobFsxXVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0ICs9IGYzKGJsLCBjbCwgZGwpICsgaGxbMl1cbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdCArPSBmNChibCwgY2wsIGRsKSArIGhsWzNdXG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgdCArPSBmNShibCwgY2wsIGRsKSArIGhsWzRdXG4gICAgfVxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNsW2ldKVxuICAgIHQgPSAodCArIGVsKSB8IDBcbiAgICBhbCA9IGVsXG4gICAgZWwgPSBkbFxuICAgIGRsID0gcm90bChjbCwgMTApXG4gICAgY2wgPSBibFxuICAgIGJsID0gdFxuXG4gICAgdCA9IChhciArIE1bb2Zmc2V0ICsgenJbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGY1KGJyLCBjciwgZHIpICsgaHJbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmNChiciwgY3IsIGRyKSArIGhyWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYnIsIGNyLCBkcikgKyBoclsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGYyKGJyLCBjciwgZHIpICsgaHJbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGYxKGJyLCBjciwgZHIpICsgaHJbNF1cbiAgICB9XG5cbiAgICB0ID0gdCB8IDBcbiAgICB0ID0gcm90bCh0LCBzcltpXSlcbiAgICB0ID0gKHQgKyBlcikgfCAwXG4gICAgYXIgPSBlclxuICAgIGVyID0gZHJcbiAgICBkciA9IHJvdGwoY3IsIDEwKVxuICAgIGNyID0gYnJcbiAgICBiciA9IHRcbiAgfVxuXG4gIC8vIGludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG4gIHQgPSAoSFsxXSArIGNsICsgZHIpIHwgMFxuICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKSB8IDBcbiAgSFsyXSA9IChIWzNdICsgZWwgKyBhcikgfCAwXG4gIEhbM10gPSAoSFs0XSArIGFsICsgYnIpIHwgMFxuICBIWzRdID0gKEhbMF0gKyBibCArIGNyKSB8IDBcbiAgSFswXSA9IHRcbn1cblxuZnVuY3Rpb24gZjEgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoeSkgXiAoeikpXG59XG5cbmZ1bmN0aW9uIGYyICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh5KSkgfCAoKH54KSAmICh6KSkpXG59XG5cbmZ1bmN0aW9uIGYzICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpXG59XG5cbmZ1bmN0aW9uIGY0ICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpICYgKH4oeikpKSlcbn1cblxuZnVuY3Rpb24gZjUgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoKHkpIHwgKH4oeikpKSlcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MCAobWVzc2FnZSkge1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXVxuXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAndXRmOCcpXG4gIH1cblxuICB2YXIgbSA9IGJ5dGVzVG9Xb3JkcyhtZXNzYWdlKVxuXG4gIHZhciBuQml0c0xlZnQgPSBtZXNzYWdlLmxlbmd0aCAqIDhcbiAgdmFyIG5CaXRzVG90YWwgPSBtZXNzYWdlLmxlbmd0aCAqIDhcblxuICAvLyBBZGQgcGFkZGluZ1xuICBtW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMilcbiAgbVsoKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICgoKG5CaXRzVG90YWwgPDwgOCkgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIHByb2Nlc3NCbG9jayhILCBtLCBpKVxuICB9XG5cbiAgLy8gc3dhcCBlbmRpYW5cbiAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIC8vIHNob3J0Y3V0XG4gICAgdmFyIEhfaSA9IEhbaV1cblxuICAgIC8vIFN3YXBcbiAgICBIW2ldID0gKCgoSF9pIDw8IDgpIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICB9XG5cbiAgdmFyIGRpZ2VzdGJ5dGVzID0gd29yZHNUb0J5dGVzKEgpXG4gIHJldHVybiBuZXcgQnVmZmVyKGRpZ2VzdGJ5dGVzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpcGVtZDE2MFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMCwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgZGVyaXZlZCBmcm9tIHNoYTEuanMgb2YgdGhlIHNhbWUgcmVwb3NpdG9yeS5cbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gU0hBLTAgYW5kIFNIQS0xIGlzIGp1c3QgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0XG4gKiBvcGVyYXRpb24gd2FzIGFkZGVkLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL3NoYS5qc1xuLy8gbW9kdWxlIGlkID0gMjYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL3NoYTEuanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL3NoYTIyNC5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhMzg0ICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTM4NCwgU0hBNTEyKVxuXG5TaGEzODQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHhjYmJiOWQ1ZFxuICB0aGlzLl9iaCA9IDB4NjI5YTI5MmFcbiAgdGhpcy5fY2ggPSAweDkxNTkwMTVhXG4gIHRoaXMuX2RoID0gMHgxNTJmZWNkOFxuICB0aGlzLl9laCA9IDB4NjczMzI2NjdcbiAgdGhpcy5fZmggPSAweDhlYjQ0YTg3XG4gIHRoaXMuX2doID0gMHhkYjBjMmUwZFxuICB0aGlzLl9oaCA9IDB4NDdiNTQ4MWRcblxuICB0aGlzLl9hbCA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYmwgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kbCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZWwgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nbCA9IDB4NjRmOThmYTdcbiAgdGhpcy5faGwgPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMzg0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NoYS5qcy9zaGEzODQuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcblxudmFyIE9iamVjdF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ18nLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG5cbnZhciBnbG9iYWxzID0gWydBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRXJyb3InLCAnRXZhbEVycm9yJywgJ0Z1bmN0aW9uJyxcbidJbmZpbml0eScsICdKU09OJywgJ01hdGgnLCAnTmFOJywgJ051bWJlcicsICdPYmplY3QnLCAnUmFuZ2VFcnJvcicsXG4nUmVmZXJlbmNlRXJyb3InLCAnUmVnRXhwJywgJ1N0cmluZycsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InLFxuJ2RlY29kZVVSSScsICdkZWNvZGVVUklDb21wb25lbnQnLCAnZW5jb2RlVVJJJywgJ2VuY29kZVVSSUNvbXBvbmVudCcsICdlc2NhcGUnLFxuJ2V2YWwnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLCAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICd1bmRlZmluZWQnLCAndW5lc2NhcGUnXTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5Db250ZXh0LnByb3RvdHlwZSA9IHt9O1xuXG52YXIgU2NyaXB0ID0gZXhwb3J0cy5TY3JpcHQgPSBmdW5jdGlvbiBOb2RlU2NyaXB0IChjb2RlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHJldHVybiBuZXcgU2NyaXB0KGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZWVkcyBhICdjb250ZXh0JyBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgd0V2YWwgPSB3aW4uZXZhbCwgd0V4ZWNTY3JpcHQgPSB3aW4uZXhlY1NjcmlwdDtcblxuICAgIGlmICghd0V2YWwgJiYgd0V4ZWNTY3JpcHQpIHtcbiAgICAgICAgLy8gd2luLmV2YWwoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXZhbCh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb250ZXh0W2tleV0gPSBjdHhba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHQoY29kZSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBTY3JpcHQuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQ29udGV4dCgpO1xuICAgIGlmKHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdm0tYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRoMzI6IHJlcXVpcmUoXCIuL3h4aGFzaFwiKVxuLFx0aDY0OiByZXF1aXJlKFwiLi94eGhhc2g2NFwiKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3h4aGFzaGpzL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxueHhIYXNoIGltcGxlbWVudGF0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuTUlUIGxpY2Vuc2VcbiovXG52YXIgVUlOVDMyID0gcmVxdWlyZSgnY3VpbnQnKS5VSU5UMzJcblxuLypcblx0TWVyZ2VkIHRoaXMgc2VxdWVuY2Ugb2YgbWV0aG9kIGNhbGxzIGFzIGl0IHNwZWVkcyB1cFxuXHR0aGUgY2FsY3VsYXRpb25zIGJ5IGEgZmFjdG9yIG9mIDJcbiAqL1xuLy8gdGhpcy52MS5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FMzJfMikgKS5yb3RsKDEzKS5tdWx0aXBseShQUklNRTMyXzEpO1xuVUlOVDMyLnByb3RvdHlwZS54eGhfdXBkYXRlID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuXHR2YXIgYjAwID0gUFJJTUUzMl8yLl9sb3dcblx0dmFyIGIxNiA9IFBSSU1FMzJfMi5faGlnaFxuXG5cdHZhciBjMTYsIGMwMFxuXHRjMDAgPSBsb3cgKiBiMDBcblx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdGMxNiArPSBoaWdoICogYjAwXG5cdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRjMTYgKz0gbG93ICogYjE2XG5cblx0dmFyIGEwMCA9IHRoaXMuX2xvdyArIChjMDAgJiAweEZGRkYpXG5cdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cblx0YTE2ICs9IHRoaXMuX2hpZ2ggKyAoYzE2ICYgMHhGRkZGKVxuXG5cdHZhciB2ID0gKGExNiA8PCAxNikgfCAoYTAwICYgMHhGRkZGKVxuXHR2ID0gKHYgPDwgMTMpIHwgKHYgPj4+IDE5KVxuXG5cdGEwMCA9IHYgJiAweEZGRkZcblx0YTE2ID0gdiA+Pj4gMTZcblxuXHRiMDAgPSBQUklNRTMyXzEuX2xvd1xuXHRiMTYgPSBQUklNRTMyXzEuX2hpZ2hcblxuXHRjMDAgPSBhMDAgKiBiMDBcblx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdGMxNiArPSBhMTYgKiBiMDBcblx0YzE2ICY9IDB4RkZGRlx0XHQvLyBOb3QgcmVxdWlyZWQgYnV0IGltcHJvdmVzIHBlcmZvcm1hbmNlXG5cdGMxNiArPSBhMDAgKiBiMTZcblxuXHR0aGlzLl9sb3cgPSBjMDAgJiAweEZGRkZcblx0dGhpcy5faGlnaCA9IGMxNiAmIDB4RkZGRlxufVxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTMyXzEgPSBVSU5UMzIoICcyNjU0NDM1NzYxJyApXG52YXIgUFJJTUUzMl8yID0gVUlOVDMyKCAnMjI0NjgyMjUxOScgKVxudmFyIFBSSU1FMzJfMyA9IFVJTlQzMiggJzMyNjY0ODk5MTcnIClcbnZhciBQUklNRTMyXzQgPSBVSU5UMzIoICAnNjY4MjY1MjYzJyApXG52YXIgUFJJTUUzMl81ID0gVUlOVDMyKCAgJzM3NDc2MTM5MycgKVxuXG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gcHJvcGVyIFVURi04IGFycmF5XG4qIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtVaW50OEFycmF5fSBVVEY4IGFycmF5IGlzIHJldHVybmVkIGFzIHVpbnQ4IGFycmF5XG4qL1xuZnVuY3Rpb24gdG9VVEY4QXJyYXkgKHN0cikge1xuXHR2YXIgdXRmOCA9IFtdXG5cdGZvciAodmFyIGk9MCwgbj1zdHIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0dmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSlcblx0XHRpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpXG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0ZWxzZSB7XG5cdFx0XHRpKys7XG5cdFx0XHQvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG5cdFx0XHQvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG5cdFx0XHQvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuXHRcdFx0Y2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuXHRcdFx0fCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpXG5cdFx0XHR1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PjE4KSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgVWludDhBcnJheSh1dGY4KVxufVxuXG4vKipcbiAqIFhYSCBvYmplY3QgdXNlZCBhcyBhIGNvbnN0cnVjdG9yIG9yIGEgZnVuY3Rpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogb3JcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ8VUlOVDMyfSBzZWVkXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKiBvclxuICogQHJldHVybiB7VUlOVDMyfSB4eEhhc2hcbiAqL1xuZnVuY3Rpb24gWFhIICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSCggYXJndW1lbnRzWzFdICkudXBkYXRlKCBhcmd1bWVudHNbMF0gKS5kaWdlc3QoKVxuXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBYWEgpKVxuXHRcdHJldHVybiBuZXcgWFhIKCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhIIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBzZWVkIGFzIGEgbnVtYmVyIG9yIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG4gZnVuY3Rpb24gaW5pdCAoc2VlZCkge1xuXHR0aGlzLnNlZWQgPSBzZWVkIGluc3RhbmNlb2YgVUlOVDMyID8gc2VlZC5jbG9uZSgpIDogVUlOVDMyKHNlZWQpXG5cdHRoaXMudjEgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUUzMl8xKS5hZGQoUFJJTUUzMl8yKVxuXHR0aGlzLnYyID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FMzJfMilcblx0dGhpcy52MyA9IHRoaXMuc2VlZC5jbG9uZSgpXG5cdHRoaXMudjQgPSB0aGlzLnNlZWQuY2xvbmUoKS5zdWJ0cmFjdChQUklNRTMyXzEpXG5cdHRoaXMudG90YWxfbGVuID0gMFxuXHR0aGlzLm1lbXNpemUgPSAwXG5cdHRoaXMubWVtb3J5ID0gbnVsbFxuXG5cdHJldHVybiB0aGlzXG59XG5YWEgucHJvdG90eXBlLmluaXQgPSBpbml0XG5cbi8qKlxuICogQWRkIGRhdGEgdG8gYmUgY29tcHV0ZWQgZm9yIHRoZSBYWEggaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIGlzQXJyYXlCdWZmZXJcblxuXHQvLyBDb252ZXJ0IGFsbCBzdHJpbmdzIHRvIHV0Zi04IGZpcnN0IChpc3N1ZSAjNSlcblx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0aW5wdXQgPSB0b1VURjhBcnJheShpbnB1dClcblx0XHRpc1N0cmluZyA9IGZhbHNlXG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0fVxuXG5cdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0e1xuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdFx0aW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG5cdH1cblxuXHR2YXIgcCA9IDBcblx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aFxuXHR2YXIgYkVuZCA9IHAgKyBsZW5cblxuXHRpZiAobGVuID09IDApIHJldHVybiB0aGlzXG5cblx0dGhpcy50b3RhbF9sZW4gKz0gbGVuXG5cblx0aWYgKHRoaXMubWVtc2l6ZSA9PSAwKVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9ICcnXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDE2KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBCdWZmZXIoMTYpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSArIGxlbiA8IDE2KSAgIC8vIGZpbGwgaW4gdG1wIGJ1ZmZlclxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIGxlbilcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0XG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIGxlbiksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIDAsIGxlbiApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplICs9IGxlblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplID4gMCkgICAvLyBzb21lIGRhdGEgbGVmdCBmcm9tIHByZXZpb3VzIHVwZGF0ZVxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAxNiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMTYgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAxNiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHAzMiA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0fVxuXG5cdFx0cCArPSAxNiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAxNilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAxNlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdHAgKz0gNFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5LCBwLCBiRW5kLXApO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UocClcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkocCwgYkVuZCksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIHAsIGJFbmQgKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSA9IGJFbmQgLSBwXG5cdH1cblxuXHRyZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBYWEggY29tcHV0YXRpb24uIFRoZSBYWEggaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQzMn0geHhIYXNoXG4gKi9cblhYSC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLm1lbW9yeVxuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIHAgPSAwXG5cdHZhciBiRW5kID0gdGhpcy5tZW1zaXplXG5cdHZhciBoMzIsIGhcblx0dmFyIHUgPSBuZXcgVUlOVDMyXG5cblx0aWYgKHRoaXMudG90YWxfbGVuID49IDE2KVxuXHR7XG5cdFx0aDMyID0gdGhpcy52MS5yb3RsKDEpLmFkZCggdGhpcy52Mi5yb3RsKDcpLmFkZCggdGhpcy52My5yb3RsKDEyKS5hZGQoIHRoaXMudjQucm90bCgxOCkgKSApIClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoMzIgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTMyXzUgKVxuXHR9XG5cblx0aDMyLmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDQpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0KVxuXHRcdH1cblx0XHRoMzJcblx0XHRcdC5hZGQoIHUubXVsdGlwbHkoUFJJTUUzMl8zKSApXG5cdFx0XHQucm90bCgxNylcblx0XHRcdC5tdWx0aXBseSggUFJJTUUzMl80IClcblx0XHRwICs9IDRcblx0fVxuXG5cdHdoaWxlIChwIDwgYkVuZClcblx0e1xuXHRcdHUuZnJvbUJpdHMoIGlzU3RyaW5nID8gaW5wdXQuY2hhckNvZGVBdChwKyspIDogaW5wdXRbcCsrXSwgMCApXG5cdFx0aDMyXG5cdFx0XHQuYWRkKCB1Lm11bHRpcGx5KFBSSU1FMzJfNSkgKVxuXHRcdFx0LnJvdGwoMTEpXG5cdFx0XHQubXVsdGlwbHkoUFJJTUUzMl8xKVxuXHR9XG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTUpXG5cdGgzMi54b3IoaCkubXVsdGlwbHkoUFJJTUUzMl8yKVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDEzKVxuXHRoMzIueG9yKGgpLm11bHRpcGx5KFBSSU1FMzJfMylcblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxNilcblx0aDMyLnhvcihoKVxuXG5cdC8vIFJlc2V0IHRoZSBzdGF0ZVxuXHR0aGlzLmluaXQoIHRoaXMuc2VlZCApXG5cblx0cmV0dXJuIGgzMlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhYSFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3h4aGFzaGpzL2xpYi94eGhhc2guanNcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbnh4SGFzaDY0IGltcGxlbWVudGF0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKEMpIDIwMTYsIFBpZXJyZSBDdXJ0b1xuTUlUIGxpY2Vuc2VcbiovXG52YXIgVUlOVDY0ID0gcmVxdWlyZSgnY3VpbnQnKS5VSU5UNjRcblxuLypcbiAqIENvbnN0YW50c1xuICovXG52YXIgUFJJTUU2NF8xID0gVUlOVDY0KCAnMTE0MDA3MTQ3ODUwNzQ2OTQ3OTEnIClcbnZhciBQUklNRTY0XzIgPSBVSU5UNjQoICcxNDAyOTQ2NzM2Njg5NzAxOTcyNycgKVxudmFyIFBSSU1FNjRfMyA9IFVJTlQ2NCggICcxNjA5NTg3OTI5MzkyODM5MTYxJyApXG52YXIgUFJJTUU2NF80ID0gVUlOVDY0KCAgJzk2NTAwMjkyNDIyODc4Mjg1NzknIClcbnZhciBQUklNRTY0XzUgPSBVSU5UNjQoICAnMjg3MDE3NzQ1MDAxMjYwMDI2MScgKVxuXG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gcHJvcGVyIFVURi04IGFycmF5XG4qIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtVaW50OEFycmF5fSBVVEY4IGFycmF5IGlzIHJldHVybmVkIGFzIHVpbnQ4IGFycmF5XG4qL1xuZnVuY3Rpb24gdG9VVEY4QXJyYXkgKHN0cikge1xuXHR2YXIgdXRmOCA9IFtdXG5cdGZvciAodmFyIGk9MCwgbj1zdHIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0dmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSlcblx0XHRpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpXG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0ZWxzZSB7XG5cdFx0XHRpKys7XG5cdFx0XHQvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG5cdFx0XHQvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG5cdFx0XHQvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuXHRcdFx0Y2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuXHRcdFx0fCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpXG5cdFx0XHR1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PjE4KSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgVWludDhBcnJheSh1dGY4KVxufVxuXG4vKipcbiAqIFhYSDY0IG9iamVjdCB1c2VkIGFzIGEgY29uc3RydWN0b3Igb3IgYSBmdW5jdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcnxVSU5UNjR9IHNlZWRcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqIG9yXG4gKiBAcmV0dXJuIHtVSU5UNjR9IHh4SGFzaFxuICovXG5mdW5jdGlvbiBYWEg2NCAoKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXG5cdFx0cmV0dXJuIG5ldyBYWEg2NCggYXJndW1lbnRzWzFdICkudXBkYXRlKCBhcmd1bWVudHNbMF0gKS5kaWdlc3QoKVxuXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBYWEg2NCkpXG5cdFx0cmV0dXJuIG5ldyBYWEg2NCggYXJndW1lbnRzWzBdIClcblxuXHRpbml0LmNhbGwodGhpcywgYXJndW1lbnRzWzBdKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFhYSDY0IGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBzZWVkIGFzIGEgbnVtYmVyIG9yIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG4gZnVuY3Rpb24gaW5pdCAoc2VlZCkge1xuXHR0aGlzLnNlZWQgPSBzZWVkIGluc3RhbmNlb2YgVUlOVDY0ID8gc2VlZC5jbG9uZSgpIDogVUlOVDY0KHNlZWQpXG5cdHRoaXMudjEgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYyID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FNjRfMilcblx0dGhpcy52MyA9IHRoaXMuc2VlZC5jbG9uZSgpXG5cdHRoaXMudjQgPSB0aGlzLnNlZWQuY2xvbmUoKS5zdWJ0cmFjdChQUklNRTY0XzEpXG5cdHRoaXMudG90YWxfbGVuID0gMFxuXHR0aGlzLm1lbXNpemUgPSAwXG5cdHRoaXMubWVtb3J5ID0gbnVsbFxuXG5cdHJldHVybiB0aGlzXG59XG5YWEg2NC5wcm90b3R5cGUuaW5pdCA9IGluaXRcblxuLyoqXG4gKiBBZGQgZGF0YSB0byBiZSBjb21wdXRlZCBmb3IgdGhlIFhYSDY0IGhhc2hcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ9IGlucHV0IGFzIGEgc3RyaW5nIG9yIG5vZGVqcyBCdWZmZXIgb3IgQXJyYXlCdWZmZXJcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqL1xuWFhINjQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIGlzQXJyYXlCdWZmZXJcblxuXHQvLyBDb252ZXJ0IGFsbCBzdHJpbmdzIHRvIHV0Zi04IGZpcnN0IChpc3N1ZSAjNSlcblx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0aW5wdXQgPSB0b1VURjhBcnJheShpbnB1dClcblx0XHRpc1N0cmluZyA9IGZhbHNlXG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0fVxuXG5cdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0e1xuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdFx0aW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG5cdH1cblxuXHR2YXIgcCA9IDBcblx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aFxuXHR2YXIgYkVuZCA9IHAgKyBsZW5cblxuXHRpZiAobGVuID09IDApIHJldHVybiB0aGlzXG5cblx0dGhpcy50b3RhbF9sZW4gKz0gbGVuXG5cblx0aWYgKHRoaXMubWVtc2l6ZSA9PSAwKVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9ICcnXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDMyKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBCdWZmZXIoMzIpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSArIGxlbiA8IDMyKSAgIC8vIGZpbGwgaW4gdG1wIGJ1ZmZlclxuXHR7XG5cdFx0Ly8gWFhINjRfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgbGVuKVxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXRcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgbGVuKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgbGVuIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgKz0gbGVuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgPiAwKSAgIC8vIHNvbWUgZGF0YSBsZWZ0IGZyb20gcHJldmlvdXMgdXBkYXRlXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCAxNi10aGlzLm1lbXNpemUpO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UoMCwgMzIgLSB0aGlzLm1lbXNpemUpXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIDMyIC0gdGhpcy5tZW1zaXplKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgMzIgLSB0aGlzLm1lbXNpemUgKVxuXHRcdH1cblxuXHRcdHZhciBwNjQgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR2YXIgb3RoZXJcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52My5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52MS5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52NC5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdH1cblxuXHRcdHAgKz0gMzIgLSB0aGlzLm1lbXNpemVcblx0XHR0aGlzLm1lbXNpemUgPSAwXG5cdFx0aWYgKGlzU3RyaW5nKSB0aGlzLm1lbW9yeSA9ICcnXG5cdH1cblxuXHRpZiAocCA8PSBiRW5kIC0gMzIpXG5cdHtcblx0XHR2YXIgbGltaXQgPSBiRW5kIC0gMzJcblxuXHRcdGRvXG5cdFx0e1xuXHRcdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYyLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb3RoZXJcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52My5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHR9XG5cdFx0XHRwICs9IDhcblx0XHR9IHdoaWxlIChwIDw9IGxpbWl0KVxuXHR9XG5cblx0aWYgKHAgPCBiRW5kKVxuXHR7XG5cdFx0Ly8gWFhINjRfbWVtY3B5KHRoaXMubWVtb3J5LCBwLCBiRW5kLXApO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UocClcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkocCwgYkVuZCksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIHAsIGJFbmQgKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSA9IGJFbmQgLSBwXG5cdH1cblxuXHRyZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBYWEg2NCBjb21wdXRhdGlvbi4gVGhlIFhYSDY0IGluc3RhbmNlIGlzIHJlYWR5IGZvciByZXVzZSBmb3IgdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgZGlnZXN0XG4gKiBAcmV0dXJuIHtVSU5UNjR9IHh4SGFzaFxuICovXG5YWEg2NC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLm1lbW9yeVxuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIHAgPSAwXG5cdHZhciBiRW5kID0gdGhpcy5tZW1zaXplXG5cdHZhciBoNjQsIGhcblx0dmFyIHUgPSBuZXcgVUlOVDY0XG5cblx0aWYgKHRoaXMudG90YWxfbGVuID49IDMyKVxuXHR7XG5cdFx0aDY0ID0gdGhpcy52MS5jbG9uZSgpLnJvdGwoMSlcblx0XHRoNjQuYWRkKCB0aGlzLnYyLmNsb25lKCkucm90bCg3KSApXG5cdFx0aDY0LmFkZCggdGhpcy52My5jbG9uZSgpLnJvdGwoMTIpIClcblx0XHRoNjQuYWRkKCB0aGlzLnY0LmNsb25lKCkucm90bCgxOCkgKVxuXG5cdFx0aDY0LnhvciggdGhpcy52MS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnYyLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjMubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52NC5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0aDY0ICA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZCggUFJJTUU2NF81IClcblx0fVxuXG5cdGg2NC5hZGQoIHUuZnJvbU51bWJlcih0aGlzLnRvdGFsX2xlbikgKVxuXG5cdHdoaWxlIChwIDw9IGJFbmQgLSA4KVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs3KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs2KVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHQpXG5cdFx0fVxuXHRcdHUubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpXG5cdFx0aDY0XG5cdFx0XHQueG9yKHUpXG5cdFx0XHQucm90bCgyNylcblx0XHRcdC5tdWx0aXBseSggUFJJTUU2NF8xIClcblx0XHRcdC5hZGQoIFBSSU1FNjRfNCApXG5cdFx0cCArPSA4XG5cdH1cblxuXHRpZiAocCArIDQgPD0gYkVuZCkge1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHQsXHQwXG5cdFx0XHQsXHQwXG5cdFx0XHQpXG5cdFx0fVxuXHRcdGg2NFxuXHRcdFx0LnhvciggdS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRcdC5yb3RsKDIzKVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzIgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF8zIClcblx0XHRwICs9IDRcblx0fVxuXG5cdHdoaWxlIChwIDwgYkVuZClcblx0e1xuXHRcdHUuZnJvbUJpdHMoIGlzU3RyaW5nID8gaW5wdXQuY2hhckNvZGVBdChwKyspIDogaW5wdXRbcCsrXSwgMCwgMCwgMCApXG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfNSkgKVxuXHRcdFx0LnJvdGwoMTEpXG5cdFx0XHQubXVsdGlwbHkoUFJJTUU2NF8xKVxuXHR9XG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMzMpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8yKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDI5KVxuXHRoNjQueG9yKGgpLm11bHRpcGx5KFBSSU1FNjRfMylcblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMilcblx0aDY0LnhvcihoKVxuXG5cdC8vIFJlc2V0IHRoZSBzdGF0ZVxuXHR0aGlzLmluaXQoIHRoaXMuc2VlZCApXG5cblx0cmV0dXJuIGg2NFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhYSDY0XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHhoYXNoanMvbGliL3h4aGFzaDY0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gY3J5cHRvIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHV0aWwgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==