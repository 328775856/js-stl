(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DS"] = factory();
	else
		root["DS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Created by lukelin on 2016/4/30.
	 */
	
	if (!process.browser) {
	    __webpack_require__(97);
	}
	
	module.exports = {
	    Array: {
	        CrossList: __webpack_require__(68),
	        TSMatrix: __webpack_require__(69)
	    },
	
	    BinaryTree: {
	        // BinaryThreadTree: require('./BinaryTree/BinaryThreadTree'),
	        BinaryTree: __webpack_require__(15),
	        // EBTNode: require('./BinaryTree/EBTNode'),
	        huffManCoding: __webpack_require__(70)
	    },
	
	    // MFSet: require('./BinaryTree/MFSet'),
	    // PBTNode: require('./BinaryTree/PBTNode')
	    GeneralizedList: {
	        GList: __webpack_require__(71)
	    },
	
	    Graph: {
	        AdjacencyListGraph: __webpack_require__(73),
	        AdjacencyMatrixGraph: __webpack_require__(74),
	        AMLGraph: __webpack_require__(72),
	        OLGraph: __webpack_require__(75)
	    },
	
	    List: {
	        DoubleLinkedList: __webpack_require__(46),
	        LinearList: __webpack_require__(77),
	        StaticLinkedList: __webpack_require__(48),
	        LRUCache: __webpack_require__(76).default
	    },
	
	    Queue: {
	        CycleQueue: __webpack_require__(78),
	        PriorityQueue: __webpack_require__(79),
	        Queue: __webpack_require__(12)
	    },
	
	    Search: {
	        AVLTree: __webpack_require__(80),
	        binarySearch: __webpack_require__(83),
	        BinarySortedTree: __webpack_require__(49),
	        BPlusTree: __webpack_require__(81),
	        BTree: __webpack_require__(82),
	        DigitalSearchTree: __webpack_require__(84),
	        fibonacciSearch: __webpack_require__(88),
	        HashTable: __webpack_require__(85),
	        RedBlackTree: __webpack_require__(86),
	        sequentialSearch: __webpack_require__(89),
	        SOSTree: __webpack_require__(87)
	    },
	
	    Sort: {
	        distribution: __webpack_require__(90),
	        exchange: __webpack_require__(50),
	        insertion: __webpack_require__(91),
	        merging: __webpack_require__(92),
	        selection: __webpack_require__(93)
	    },
	
	    Stack: __webpack_require__(16),
	
	    String: {
	        HString: __webpack_require__(94),
	        LString: __webpack_require__(95),
	        SString: __webpack_require__(96)
	    }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(101);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 3 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(38)('wks')
	  , uid        = __webpack_require__(24)
	  , Symbol     = __webpack_require__(5).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 5 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(7)
	  , IE8_DOM_DEFINE = __webpack_require__(56)
	  , toPrimitive    = __webpack_require__(41)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(19);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(18)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(5)
	  , core      = __webpack_require__(3)
	  , ctx       = __webpack_require__(30)
	  , hide      = __webpack_require__(13)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 10 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(121)
	  , defined = __webpack_require__(31);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 队列Queue
	 *
	 * 队列是一种先进先出（first in first out, FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。
	 * 允许插入的一端叫队尾（rear），允许删除的一端叫队头（front）。
	 */
	
	// 链队列
	
	var Queue = function () {
	    function Queue() {
	        (0, _classCallCheck3.default)(this, Queue);
	
	        this.rear = this.front = null;
	        this.size = 0;
	    }
	
	    (0, _createClass3.default)(Queue, [{
	        key: "isEmpty",
	        value: function isEmpty() {
	            return this.rear === null;
	        }
	    }, {
	        key: "clear",
	        value: function clear() {
	            this.rear = this.front = null;
	            this.size = 0;
	        }
	    }, {
	        key: "getHead",
	        value: function getHead() {
	            return this.front ? this.front.data : null;
	        }
	    }, {
	        key: "enQueue",
	        value: function enQueue(elem) {
	            if (this.front === null) {
	                this.rear = this.front = { data: elem, next: null };
	            } else {
	                var p = { data: elem, next: null };
	                this.rear.next = p;
	                this.rear = p;
	            }
	            this.size++;
	        }
	    }, {
	        key: "deQueue",
	        value: function deQueue() {
	            if (this.front) {
	                var elem = this.front.data;
	                this.front = this.front.next;
	                if (this.front === null) {
	                    this.rear = null;
	                }
	                this.size--;
	                return elem;
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: "queueTraverse",
	        value: function queueTraverse(iterator) {
	            var current = this.front;
	            while (current) {
	                if (iterator(current.data)) break;
	                current = current.next;
	            }
	        }
	    }, {
	        key: "peekAt",
	        value: function peekAt() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	            if (index < this.size) {
	                var current = this.front;
	                for (var i = 0; i < index; i++) {
	                    current = current.next;
	                }
	                return current.data;
	            }
	
	            return null;
	        }
	    }, {
	        key: "toString",
	        value: function toString() {
	            if (this.front === null) {
	                return null;
	            }
	
	            var arr = [];
	            var current = this.front;
	
	            for (var i = 0, len = this.size; i < len; i++) {
	                arr[i] = current.data;
	                current = current.next;
	            }
	
	            return arr;
	        }
	    }]);
	    return Queue;
	}();
	
	exports.default = Queue;
	
	
	var queue = new Queue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));
	console.log(queue.peekAt(3));
	console.log(queue.toString().join());
	
	// 类似广度优先遍历
	function repaintColor(matrix, i, j, color) {
	    var old = matrix[i][j];
	    var queue = new Queue();
	    var m = matrix.length - 1;
	    var n = matrix[0].length - 1;
	
	    queue.enQueue({ x: i, y: j });
	
	    while (queue.rear) {
	        var a = queue.deQueue();
	        var x = a.x;
	        var y = a.y;
	
	        if (x >= 1) setColor(x - 1, y);
	        if (y >= 1) setColor(x, y - 1);
	        if (x < m) setColor(x + 1, y);
	        if (y < n) setColor(x, y + 1);
	    }
	
	    function setColor(x, y) {
	        if (matrix[x][y] === old) {
	            matrix[x][y] = color;
	            queue.enQueue({ x: x, y: y });
	        }
	    }
	}
	
	var matrix = [];
	
	for (var i = 0; i < 8; i++) {
	    matrix[i] = [];
	    for (var j = 0; j < 8; j++) {
	        matrix[i][j] = 0;
	    }
	}
	
	repaintColor(matrix, 4, 5, 1);
	console.log(matrix);

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(6)
	  , createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(8) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ChildSiblingTree = exports.ChildTree = exports.ParentTree = exports.BinaryTree = undefined;
	
	var _getIterator2 = __webpack_require__(22);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _regenerator = __webpack_require__(45);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator2 = __webpack_require__(17);
	
	var _iterator3 = _interopRequireDefault(_iterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _index = __webpack_require__(16);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 树的一些概念
	 *
	 * 树（Tree）是n（n>=0）个结点的有限集。在任意一棵非空树中：
	 * （1）有且仅有一个特定的称为根（Root）的结点；
	 * （2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,T3,...Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。
	 *
	 * 例如，（a）是只有一个根结点的树；
	 * （b）是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。
	 *
	 * 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。例如，（b）中A的度为3，C的度为1，F的度为0.度为0的结点称为叶子（Leaf）或者终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。（b）的树的度为3.结点的子树的根称为该结点的孩子（Child）。相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。
	 * 结点的层次（Level）从根开始定义起，根为第一层，跟的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。例如，结点G与E，F,H,I,J互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。（b）的树的深度为4。
	 *
	 * 如果将树中结点的各子树看成从左至右是有次序的（即不能交换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
	 * 森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
	 *
	 *
	 */
	
	/**
	 * 二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。）
	 *
	 * 二叉树的性质
	 * 1.在二叉树的第i层上至多有2的i-1次方个结点(i>=1)。
	 * 2.深度为k的二叉树至多有2的k次方-1个结点，(k>=1)。
	 * 3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1;
	 *      一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树。
	 *      深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。
	 * 下面是完全二叉树的两个特性
	 * 4.具有n个结点的完全二叉树的深度为Math.floor(log 2 n) + 1
	 * 5.如果对一棵有n个结点的完全二叉树（其深度为Math.floor(log 2 n) + 1）的结点按层序编号（从第1层到第Math.floor(2 n) + 1，每层从左到右），则对任一结点（1<=i<=n）有：
	 *     (1)如果i=1，则结点i、是二叉树的根，无双亲；如果i>1，则其双亲parent(i)是结点Math.floor(i/2)。
	 *     (2)如果2i > n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子LChild(i)是结点2i.
	 *     (3)如果2i + 1 > n，则结点i无右孩子；否则其右孩子RChild(i)是结点2i + 1;
	 */
	
	/*
	 二叉树的存储结构
	
	 1.顺序存储结构
	 用一组连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，即将二叉树上编号为i的结点元素存储在加上定义的一维数组中下标为i-1的分量中。“0”表示不存在此结点。这种顺序存储结构仅适用于完全二叉树。
	 因为，在最坏情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）却需要长度为2的n次方-1的一维数组。
	
	 2.链式存储结构
	 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左右指针域。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结构所得的二叉树的存储结构分别称之为二叉链表和三叉链表。
	 在含有n个结点的二叉链表中有n+1个空链域，我们可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构---线索链表。
	
	 先（根）序遍历：根左右
	 中（根）序遍历：左根右
	 后（根）序遍历：左右根
	
	 */
	
	// 顺序存储结构
	(function () {
	    // 顺序存储结构的遍历
	    var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	
	    console.log('preOrder:');
	    void function preOrderRecursive(x, visit) {
	        visit(tree[x]);
	        if (tree[2 * x + 1]) preOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) preOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('inOrder:');
	    void function inOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) inOrderRecursive(2 * x + 1, visit);
	        visit(tree[x]);
	        if (tree[2 * x + 2]) inOrderRecursive(2 * x + 2, visit);
	    }(0, function (value) {
	        console.log(value);
	    });
	
	    console.log('postOrder:');
	    void function postOrderRecursive(x, visit) {
	        if (tree[2 * x + 1]) postOrderRecursive(2 * x + 1, visit);
	        if (tree[2 * x + 2]) postOrderRecursive(2 * x + 2, visit);
	        visit(tree[x]);
	    }(0, function (value) {
	        console.log(value);
	    });
	})();
	
	// 链式存储结构
	
	var BinaryTree = exports.BinaryTree = function () {
	    function BinaryTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var leftChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var rightChild = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, BinaryTree);
	
	        this.data = data;
	        // 左右孩子结点
	        this.leftChild = leftChild;
	        this.rightChild = rightChild;
	    }
	
	    // 判断两棵树是否相似
	
	
	    (0, _createClass3.default)(BinaryTree, [{
	        key: 'isSimilar',
	        value: function isSimilar(tree) {
	            return !!(tree && (this.leftChild && this.leftChild.isSimilar(tree.leftChild) || !this.leftChild && !tree.leftChild) && (this.rightChild && this.rightChild.isSimilar(tree.rightChild) || !this.rightChild && !tree.rightChild));
	        }
	    }, {
	        key: 'createBinaryTree',
	        value: function createBinaryTree(tree) {
	            void function preOrderRecursive(node, x, visit) {
	                visit(node, tree[x]);
	
	                var p = void 0;
	                if (tree[2 * x + 1]) {
	                    p = node.leftChild = new BinaryTree();
	                    preOrderRecursive(p, 2 * x + 1, visit);
	                }
	                if (tree[2 * x + 2]) {
	                    p = node.rightChild = new BinaryTree();
	                    preOrderRecursive(p, 2 * x + 2, visit);
	                }
	
	                if (p) p.parentNode = node;
	            }(this, 0, function (node, value) {
	                node.data = value;
	            });
	        }
	
	        /** Prefix iteration */
	
	    }, {
	        key: _iterator3.default,
	        value: _regenerator2.default.mark(function value() {
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return this.data;
	
	                        case 2:
	                            if (!this.leftChild) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            return _context.delegateYield(this.leftChild, 't0', 4);
	
	                        case 4:
	                            if (!this.rightChild) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            return _context.delegateYield(this.rightChild, 't1', 6);
	
	                        case 6:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	
	        // 先序遍历二叉树的非递归算法
	
	    }, {
	        key: 'preOrderNonRecursive',
	        value: function preOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            var p = this;
	
	            while (p || stack.length) {
	                // 向左走到尽头
	                if (p) {
	                    stack.push(p);
	                    p.data && visit(p.data);
	                    p = p.leftChild;
	                } else {
	                    p = stack.pop();
	                    p = p.rightChild;
	                }
	            }
	        }
	
	        // 中序非递归遍历
	
	    }, {
	        key: 'inOrderNonRecursive',
	        value: function inOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            var p = this;
	
	            while (p || stack.length) {
	                if (p) {
	                    stack.push(p);
	                    p = p.leftChild;
	                } else {
	                    p = stack.pop();
	                    p.data && visit(p.data);
	                    p = p.rightChild;
	                }
	            }
	        }
	
	        // 为了区分两次过栈的不同处理方式，在堆栈中增加一个mark域，
	        // mark=0表示刚刚访问此结点，mark=1表示左子树处理结束返回，
	        // mark=2表示右子树处理结束返回。每次根据栈顶的mark域决定做何动作
	
	    }, {
	        key: 'postOrderNonRecursive',
	        value: function postOrderNonRecursive(visit) {
	            var stack = new _index2.default();
	            stack.push([this, 0]);
	
	            while (stack.length) {
	                var a = stack.pop();
	                var node = a[0];
	
	                switch (a[1]) {
	                    case 0:
	                        stack.push([node, 1]); // 修改mark域
	                        if (node.leftChild) stack.push([node.leftChild, 0]); // 访问左子树
	                        break;
	                    case 1:
	                        stack.push([node, 2]);
	                        if (node.rightChild) stack.push([node.rightChild, 0]);
	                        break;
	                    case 2:
	                        node.data && visit(node.data);
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	    }, {
	        key: 'preOrderRecursive',
	        value: function preOrderRecursive(visit) {
	            visit(this.data);
	            if (this.leftChild) this.leftChild.preOrderRecursive(visit);
	            if (this.rightChild) this.rightChild.preOrderRecursive(visit);
	        }
	    }, {
	        key: 'inOrderRecursive',
	        value: function inOrderRecursive(visit) {
	            if (this.leftChild) this.leftChild.inOrderRecursive(visit);
	            visit(this.data);
	            if (this.rightChild) this.rightChild.inOrderRecursive(visit);
	        }
	    }, {
	        key: 'postOrderRecursive',
	        value: function postOrderRecursive(visit) {
	            if (this.leftChild) this.leftChild.postOrderRecursive(visit);
	            if (this.rightChild) this.rightChild.postOrderRecursive(visit);
	            visit(this.data);
	        }
	    }, {
	        key: 'levelOrderTraverse',
	        value: function levelOrderTraverse(visit) {
	            var queue = new _Queue2.default();
	            queue.enQueue(this);
	
	            while (queue.rear) {
	                var p = queue.deQueue();
	                p.data && visit(p.data);
	                p.leftChild && queue.enQueue(p.leftChild);
	                p.rightChild && queue.enQueue(p.rightChild);
	            }
	        }
	
	        // 求先序序列为k的结点的值
	
	    }, {
	        key: 'getPreSequence',
	        value: function getPreSequence(k) {
	            var count = 0;
	            var data = null;
	
	            void function recurse(node) {
	                if (node) {
	                    if (++count === k) data = node.data;else {
	                        recurse(node.leftChild);
	                        recurse(node.rightChild);
	                    }
	                }
	            }(this);
	
	            return data;
	        }
	
	        // 求二叉树中叶子结点的数目
	
	    }, {
	        key: 'countLeaves',
	        value: function countLeaves() {
	            return function recurse(node) {
	                if (!node) return 0;else if (!node.leftChild && !node.rightChild) return 1;else return recurse(node.leftChild) + recurse(node.rightChild);
	            }(this);
	        }
	
	        // 交换所有结点的左右子树
	
	    }, {
	        key: 'revoluteBinaryTree',
	        value: function revoluteBinaryTree() {
	            var _ref = [this.rightChild, this.leftChild];
	            this.leftChild = _ref[0];
	            this.rightChild = _ref[1];
	
	
	            if (this.leftChild) this.leftChild.revoluteBinaryTree();
	            if (this.rightChild) this.rightChild.revoluteBinaryTree();
	        }
	    }, {
	        key: 'revoluteNonRecursive',
	        value: function revoluteNonRecursive() {
	            var stack = [];
	            stack.push(this);
	
	            while (stack.length) {
	                var node = stack.pop();
	                var _ref2 = [node.rightChild, node.leftChild];
	                node.leftChild = _ref2[0];
	                node.rightChild = _ref2[1];
	
	
	                if (node.leftChild) stack.push(node.leftChild);
	                if (node.rightChild) stack.push(node.rightChild);
	            }
	        }
	
	        // 求二叉树中以值为x的结点为根的子树深度
	
	    }, {
	        key: 'getSubDepth',
	        value: function getSubDepth(x) {
	            var count = 0;
	            var stack = new _index2.default();
	            stack.push(this);
	
	            while (stack.length) {
	                var node = stack.pop();
	
	                if (node.data === x) {
	                    count = node.getDepth();
	                    break;
	                } else {
	                    if (node.leftChild) stack.push(node.leftChild);
	                    if (node.rightChild) stack.push(node.rightChild);
	                }
	            }
	
	            return count;
	        }
	    }, {
	        key: 'getDepth',
	        value: function getDepth() {
	            var m = this.leftChild && this.leftChild.getDepth() || 0;
	            var n = this.rightChild && this.rightChild.getDepth() || 0;
	            return (m > n ? m : n) + 1;
	        }
	
	        // 删除所有以元素x为根的子树
	
	    }, {
	        key: 'delSubX',
	        value: function delSubX(x) {
	            if (this.data === x) {
	                this.leftChild = null;
	                this.rightChild = null;
	            } else {
	                if (this.leftChild) this.leftChild.delSubX(x);
	                if (this.rightChild) this.rightChild.delSubX(x);
	            }
	        }
	
	        /**
	         * 非递归复制二叉树
	         * @param {Function} cb 拷贝过程中会执行的回调，可以用来拷贝其它自定义属性
	         * @returns {Cstr} 返回新的实例
	         */
	
	    }, {
	        key: 'copy',
	        value: function copy() {
	            var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
	
	            // 用来存放本体结点的栈
	            var stack1 = new _index2.default();
	            // 用来存放新二叉树结点的栈
	            var stack2 = new _index2.default();
	            stack1.push(this);
	            var Cstr = this.constructor;
	            var newTree = new Cstr();
	            var q = newTree;
	            stack2.push(newTree);
	            var p = void 0;
	
	            while (stack1.length) {
	                // 向左走到尽头
	                while (p = stack1.peek()) {
	                    if (p.leftChild) q.leftChild = new Cstr();
	                    q = q.leftChild;
	                    stack1.push(p.leftChild);
	                    stack2.push(q);
	                }
	
	                p = stack1.pop();
	                q = stack2.pop();
	
	                if (stack1.length) {
	                    p = stack1.pop();
	                    q = stack2.pop();
	                    if (p.rightChild) q.rightChild = new Cstr();
	                    q.data = p.data;
	                    cb(q, p);
	                    q = q.rightChild;
	                    stack1.push(p.rightChild); // 向右一步
	                    stack2.push(q);
	                }
	            }
	
	            return newTree;
	        }
	
	        // 求二叉树中结点p和q的最近祖先
	
	    }, {
	        key: 'findNearAncient',
	        value: function findNearAncient(pNode, qNode) {
	            var pathP = findPath(this, pNode, 0);
	            var pathQ = findPath(this, qNode, 0);
	
	            for (var i = 0; pathP[i] == pathQ[i] && pathP[i]; i++) {}
	            return pathP[--i];
	        }
	
	        // todo
	
	    }, {
	        key: 'toString',
	        value: function toString() {}
	
	        // 求一棵二叉树的繁茂度
	
	    }, {
	        key: 'lushDegree',
	        value: function lushDegree() {
	            var countArr = [];
	            var queue = new _Queue2.default();
	            queue.enQueue({
	                node: this,
	                layer: 0
	            });
	            // 利用层序遍历来统计各层的结点数
	            var r = void 0;
	            while (queue.rear) {
	                r = queue.deQueue();
	                countArr[r.layer] = (countArr[r.layer] || 0) + 1;
	
	                if (r.node.leftChild) queue.enQueue({
	                    node: r.node.leftChild,
	                    layer: r.layer + 1
	                });
	                if (r.node.rightChild) queue.enQueue({
	                    node: r.node.rightChild,
	                    layer: r.layer + 1
	                });
	            }
	
	            // 最后一个队列元素所在层就是树的高度
	            var height = r.layer;
	            var max = countArr[0];
	            for (var i = 1; countArr[i]; i++) {
	                // 求层最大结点数
	                if (countArr[i] > max) max = countArr[i];
	            }return height * max;
	        }
	
	        // 求树结点的子孙总数填入descNum域中，并返回
	
	    }, {
	        key: 'descNum',
	        value: function descNum() {
	            return function recurse(node) {
	                var d = void 0;
	                if (!node) return -1;else d = recurse(node.leftChild) + recurse(node.rightChild) + 2;
	
	                node.descNum = d;
	
	                return d;
	            }(this);
	        }
	
	        // 判断二叉树是否完全二叉树
	
	    }], [{
	        key: 'isFullBinaryTree',
	        value: function isFullBinaryTree(tree) {
	            var queue = new _Queue2.default();
	            var flag = 0;
	            queue.enQueue(tree);
	
	            while (queue.rear) {
	                var p = queue.deQueue();
	
	                if (!p) flag = 1;else if (flag) return false;else {
	                    queue.enQueue(p.leftChild);
	                    queue.enQueue(p.rightChild);
	                }
	            }
	
	            return true;
	        }
	    }]);
	    return BinaryTree;
	}();
	
	// 求从tree到node结点路径的递归算法
	
	
	function findPath(tree, node) {
	    var i = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	    var path = [];
	    var found = false;
	
	    void function recurse(tree, i) {
	        if (tree == node) {
	            found = true;
	            return;
	        }
	
	        path[i] = tree;
	        if (tree.leftChild) recurse(tree.leftChild, i + 1);
	        if (tree.rightChild && !found) recurse(tree.rightChild, i + 1);
	        if (!found) path[i] = null;
	    }(tree, i);
	
	    return path;
	}
	
	var global = Function('return this;')();
	
	// 求深度等于树的高度减一的最靠左的结点
	function printPath_maxDepthS1(tree) {
	    var maxh = tree.getDepth();
	    var path = [];
	
	    if (maxh < 2) return false;
	    find_h(tree, 1);
	
	    function find_h(tree, h) {
	        path[h] = tree;
	
	        if (h == maxh - 1) {
	            var s = ' ';
	            for (var i = 1; path[i]; i++) {
	                s += path[i].data + (path[i + 1] ? ' -> ' : '');
	            }console.log(s);
	            return;
	        } else {
	            if (tree.leftChild) find_h(tree.leftChild, h + 1);
	            if (tree.rightChild) find_h(tree.rightChild, h + 1);
	        }
	
	        path[h] = null;
	    }
	}
	
	var tree = [1, 2, 3, 4, 5,, 6,,, 7];
	var test = new BinaryTree();
	test.createBinaryTree(tree);
	
	console.log('iterator: ');
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;
	
	try {
	    for (var _iterator = (0, _getIterator3.default)(test), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var x = _step.value;
	
	        console.log(x);
	    }
	
	    /**
	     * 树的3种常用链表结构
	     */
	
	    // 1.双亲表示法
	    // 优点：parent(tree, x)操作可以在常量时间内实现
	    // 缺点：求结点的孩子时需要遍历整个结构
	} catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	        }
	    } finally {
	        if (_didIteratorError) {
	            throw _iteratorError;
	        }
	    }
	}
	
	var ParentTree = exports.ParentTree = function () {
	    function ParentTree() {
	        (0, _classCallCheck3.default)(this, ParentTree);
	
	        this.nodes = [];
	    }
	
	    (0, _createClass3.default)(ParentTree, [{
	        key: 'getDepth',
	        value: function getDepth() {
	            var maxDepth = 0;
	
	            for (var i = 0; i < this.nodes.length; i++) {
	                var dep = 0;
	                for (var j = i; j >= 0; j = this.nodes[i].parent) {
	                    dep++;
	                }if (dep > maxDepth) maxDepth = dep;
	            }
	
	            return maxDepth;
	        }
	    }]);
	    return ParentTree;
	}();
	
	var ParentTreeNode = function ParentTreeNode() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var parent = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    (0, _classCallCheck3.default)(this, ParentTreeNode);
	
	    // type: ParentTree
	    this.data = data;
	    // 双亲位置域 {Number}
	    this.parent = parent;
	};
	
	var pt = new ParentTree();
	pt.nodes.push(new ParentTreeNode('R', -1));
	pt.nodes.push(new ParentTreeNode('A', 0));
	pt.nodes.push(new ParentTreeNode('B', 0));
	pt.nodes.push(new ParentTreeNode('C', 0));
	pt.nodes.push(new ParentTreeNode('D', 1));
	pt.nodes.push(new ParentTreeNode('E', 1));
	pt.nodes.push(new ParentTreeNode('F', 3));
	pt.nodes.push(new ParentTreeNode('G', 6));
	pt.nodes.push(new ParentTreeNode('H', 6));
	pt.nodes.push(new ParentTreeNode('I', 6));
	
	// 孩子表示法
	
	var ChildTree = exports.ChildTree = function () {
	    function ChildTree() {
	        (0, _classCallCheck3.default)(this, ChildTree);
	
	        this.nodes = [];
	    }
	
	    (0, _createClass3.default)(ChildTree, [{
	        key: 'getDepth',
	        value: function getDepth() {
	            var self = this;
	            return function subDepth(rootIndex) {
	                if (!self.nodes[rootIndex]) return 1;
	
	                var sd = 1;
	                for (var p = self.nodes[rootIndex]; p; p = p.next) {
	                    var d = subDepth(p.child);
	                    if (d > sd) sd = d;
	                }
	
	                return sd + 1;
	            }(this.data[0]);
	        }
	    }]);
	    return ChildTree;
	}();
	/**
	 *
	 * @param {*} data
	 * @param {ChildTreeNode} firstChild 孩子链表头指针
	 * @constructor
	 */
	
	
	var ChildTreeBox = function ChildTreeBox() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeBox);
	
	    this.data = data;
	    this.firstChild = firstChild;
	};
	
	/**
	 * 孩子结点
	 *
	 * @param {Number} child
	 * @param {ChildTreeNode} next
	 * @constructor
	 */
	
	
	var ChildTreeNode = function ChildTreeNode() {
	    var child = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ChildTreeNode);
	
	    this.child = child;
	    this.next = next;
	};
	
	/*
	 孩子表示法便于涉及孩子的操作的实现，但不适用于parent操作。
	 我们可以把双亲表示法和孩子表示法结合起来。
	 */
	
	// 孩子兄弟表示法(二叉树表示法)
	// 可增设一个parent域实现parent操作
	
	
	var ChildSiblingTree = exports.ChildSiblingTree = function () {
	    function ChildSiblingTree() {
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var firstChild = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var nextSibling = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, ChildSiblingTree);
	
	        this.data = data;
	        this.firstChild = firstChild;
	        this.nextSibling = nextSibling;
	    }
	
	    // 输出孩子兄弟链表表示的树的各边
	
	
	    (0, _createClass3.default)(ChildSiblingTree, [{
	        key: 'print',
	        value: function print() {
	            for (var child = this.firstChild; child; child = child.nextSibling) {
	                console.log('%c %c', this.data, child.data);
	                child.print();
	            }
	        }
	
	        // 求孩子兄弟链表表示的树的叶子数目
	
	    }, {
	        key: 'leafCount',
	        value: function leafCount() {
	            if (!this.firstChild) return 1;else {
	                var count = 0;
	                for (var child = this.firstChild; child; child = child.nextSibling) {
	                    count += child.leafCount();
	                }
	                return count;
	            }
	        }
	
	        // 求树的度
	
	    }, {
	        key: 'getDegree',
	        value: function getDegree() {
	            if (!this.firstChild) return 0;else {
	                var degree = 0;
	                for (var p = this.firstChild; p; p = p.nextSibling) {
	                    degree++;
	                }for (var _p = this.firstChild; _p; _p = _p.nextSibling) {
	                    var d = _p.getDegree();
	                    if (d > degree) degree = d;
	                }
	
	                return degree;
	            }
	        }
	    }, {
	        key: 'getDepth',
	        value: function getDepth() {
	            if (this === global) return 0;else {
	                var maxd = 0;
	                for (var p = this.firstChild; p; p = p.nextSibling) {
	                    var d = p.getDepth();
	                    if (d > maxd) maxd = d;
	                }
	
	                return maxd + 1;
	            }
	        }
	    }]);
	    return ChildSiblingTree;
	}();

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 栈
	 *
	 * 是限定仅在表尾进行插入或删除操作的线性表。表尾为栈顶（top），表头为栈底（bottom），不含元素的空表为空栈。
	 * 栈又称为后进先出（last in first out）的线性表。
	 */
	
	/**
	 * 顺序栈
	 * 栈的顺序存储结构是利用一组地址连续的存储单元依次存放至栈底到栈顶的元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
	 *
	 */
	
	// 栈的链式表示
	
	var Stack = function () {
	    function Stack() {
	        (0, _classCallCheck3.default)(this, Stack);
	
	        this.top = null;
	        this.length = 0;
	    }
	
	    (0, _createClass3.default)(Stack, [{
	        key: 'isEmpty',
	        value: function isEmpty() {
	            return this.length === 0;
	        }
	    }, {
	        key: 'push',
	        value: function push(data) {
	            var node = {
	                data: data,
	                next: null
	            };
	
	            node.next = this.top;
	            this.top = node;
	            this.length++;
	        }
	    }, {
	        key: 'peek',
	        value: function peek() {
	            return this.top === null ? null : this.top.data;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            if (this.top === null) return null;
	
	            var out = this.top;
	            this.top = this.top.next;
	
	            if (this.length > 0) this.length--;
	
	            return out.data;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.top = null;
	            this.length = 0;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            if (this.top === null) return null;
	
	            var arr = [];
	            var current = this.top;
	
	            for (var i = 0, len = this.size; i < len; i++) {
	                arr[i] = current.data;
	                current = current.next;
	            }
	
	            return arr;
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.length;
	        }
	    }]);
	    return Stack;
	}();
	
	exports.default = Stack;
	
	
	var stack = new Stack();
	
	stack.push(1);
	stack.push('asd');
	
	stack.pop();
	stack.push({ a: 1 });
	console.log(stack);
	
	/**
	 * 这里用字符串train表示火车，H表示硬席，S表示软席
	 * @param {String} train
	 */
	function trainArrange(train) {
	    var stack = new Stack();
	    var q = [];
	    var i = 0;
	    var j = 0;
	
	    while (train[i]) {
	        if (train[i] === 'H') stack.push(train[i]);else q[j++] = train[i];
	        i++;
	    }
	
	    while (stack.length) {
	        var c = stack.pop();
	        q[j++] = c;
	    }
	
	    return q + '';
	}
	
	console.log('trainArrange: ' + trainArrange('HSSHSSSHHHHHS')); // trainArrange: S,S,S,S,S,S,H,H,H,H,H,H,H
	
	// 判断字符串中“&”前和“&”后部分是否为逆串，"@"表示结束符，是则返回true，否则返回false
	function isReverse(str) {
	    var stack = new Stack();
	    var i = 0;
	
	    while (str[i] !== '&') {
	        if (str[i] === '@') return false;
	        stack.push(str[i]);
	        i++;
	    }
	
	    i++;
	
	    while (str[i] !== '@') {
	        if (!stack.length) return false;
	
	        var s = stack.pop();
	        if (s !== str[i]) return false;
	        i++;
	    }
	
	    return !stack.length;
	}
	
	console.log('isReverse: ' + isReverse('abcd&dcba@a')); // true
	
	// 数值进制转换
	// 公式： N = (N / d) * d + N % d
	// N：十进制数值， d：需要转换的进制数
	function numTransform(number, rad) {
	    var s = new Stack();
	
	    while (number) {
	        s.push(number % rad);
	        number = parseInt(number / 8, 10);
	    }
	
	    var arr = [];
	    while (s.top) {
	        arr.push(s.pop());
	    }
	    console.log(arr.join(''));
	}
	
	numTransform(1348, 8);
	numTransform(1348, 2);
	
	// 括号匹配检查
	function bracketsMatch(str) {
	    var stack = new Stack();
	    var text = '';
	
	    for (var i = 0, len = str.length; i < len; i++) {
	        var c = str[i];
	        if (c === '[') {
	            stack.push(c);
	        } else if (c === ']') {
	            if (!stack.length || stack.pop() !== '[') throw new Error('unexpected brackets:' + c);
	        } else {
	            text += c;
	        }
	    }
	    console.log(text);
	}
	
	console.log(bracketsMatch('[asd]'));
	
	function Matcher(left, right) {
	    this.left = left;
	    this.right = right;
	    this.stack = new Stack();
	}
	Matcher.prototype = {
	    match: function match(str) {
	        var text = '';
	
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            if (c === this.left) {
	                this.stack.push(c);
	            } else if (c === this.right) {
	                if (!this.stack.length || this.stack.pop() !== this.left) {
	                    throw new Error('unexpected brackets:' + c);
	                } else {
	                    text += ',';
	                }
	            } else {
	                text += c;
	            }
	        }
	        console.log(text);
	        return text;
	    }
	};
	var m = new Matcher('{', '}');
	m.match('[{123}123');
	
	function LineEditor(str) {
	    this.stack = new Stack();
	    this.str = str || '';
	}
	LineEditor.prototype = {
	    getResult: function getResult() {
	        var stack = this.stack;
	        var str = this.str;
	        for (var i = 0, len = str.length; i < len; i++) {
	            var c = str[i];
	            switch (c) {
	                case '#':
	                    stack.pop();
	                    break;
	                case '@':
	                    stack.clear();
	                    break;
	                default:
	                    stack.push(c);
	                    break;
	            }
	        }
	
	        var result = '';
	        var current = stack.length;
	        while (current) {
	            result = current.data + result;
	            current = current.next;
	        }
	
	        return result;
	    }
	};
	
	var le = new LineEditor('whli##ilr#e(s#*s)\
	    \noutcha@putchar(*s=#++)');
	console.log(le.getResult());
	
	var prioty = {
	    "+": 1,
	    "-": 1,
	    "%": 2,
	    "*": 2,
	    "/": 2,
	    "^": 3,
	    "(": 0,
	    ")": 0,
	    "`": -1
	};
	
	function doop(op, opn1, opn2) {
	    switch (op) {
	        case "+":
	            return opn1 + opn2;
	        case "-":
	            return opn1 - opn2;
	        case "*":
	            return opn1 * opn2;
	        case "/":
	            return opn1 / opn2;
	        case "%":
	            return opn1 % opn2;
	        case "^":
	            return Math.pow(opn1, opn2);
	        default:
	            return 0;
	    }
	}
	
	function opcomp(a, b) {
	    return prioty[a] - prioty[b];
	}
	
	function calInfixExpression(exp) {
	    var cs = [];
	    var ns = [];
	    exp = exp.replace(/\s/g, "");
	    exp += '`';
	    if (exp[0] === '-') {
	        exp = "0" + exp;
	    }
	    var c = void 0;
	    var op = void 0;
	    var opn1 = void 0;
	    var opn2 = void 0;
	    for (var i = 0; i < exp.length; ++i) {
	        c = exp[i];
	        // 如果是操作符
	        if (c in prioty) {
	            // 如果右边不是左括号且操作符栈的栈顶元素优先权比右边大
	            // 循环遍历进行连续运算
	            while (c != '(' && cs.length && opcomp(cs[cs.length - 1], c) >= 0) {
	                // 出栈的操作符
	                op = cs.pop();
	                // 如果不是左括号或者右括号，说明是运算符
	                if (op != '(' && op != ')') {
	                    // 出栈保存数字的栈的两个元素
	                    opn2 = ns.pop();
	                    opn1 = ns.pop();
	                    // 将与操作符运算后的结果保存到栈顶
	                    ns.push(doop(op, opn1, opn2));
	                }
	            }
	            // 如果右边不是右括号，保存到操作符栈中
	            if (c != ')') cs.push(c);
	        } else {
	            // 多位数的数字的情况
	            while (!(exp[i] in prioty)) {
	                i++;
	                c += exp[i];
	            }
	            ns.push(parseFloat(c));
	            i--;
	        }
	    }
	    return ns.length ? ns[0] : NaN;
	}
	
	var exp1 = calInfixExpression('5+3*4/2-2^3+5%2');
	console.log(exp1);

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(114), __esModule: true };

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Created by ldp on 2015/4/12.
	 */
	
	module.exports = function defaultCompare(a, b) {
	  return a - b;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(106), __esModule: true };

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(62)
	  , enumBugKeys = __webpack_require__(32);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(134)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(57)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(111), __esModule: true };

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(102);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(51);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(53);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(53);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(115);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 32 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(7)
	  , dPs         = __webpack_require__(130)
	  , enumBugKeys = __webpack_require__(32)
	  , IE_PROTO    = __webpack_require__(37)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(55)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(120).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(6).f
	  , has = __webpack_require__(10)
	  , TAG = __webpack_require__(4)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(38)('keys')
	  , uid    = __webpack_require__(24);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(31);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(19);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(5)
	  , core           = __webpack_require__(3)
	  , LIBRARY        = __webpack_require__(33)
	  , wksExt         = __webpack_require__(43)
	  , defineProperty = __webpack_require__(6).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(4);

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(139);
	var global        = __webpack_require__(5)
	  , hide          = __webpack_require__(13)
	  , Iterators     = __webpack_require__(14)
	  , TO_STRING_TAG = __webpack_require__(4)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(148);


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _regenerator = __webpack_require__(45);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator3 = __webpack_require__(17);
	
	var _iterator4 = _interopRequireDefault(_iterator3);
	
	var _getIterator2 = __webpack_require__(22);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 循环链表（circular linked list）
	 * 是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个表形成一个环。
	 * 循环链表的操作和线性链表基本一致，仅有细微差别。
	 */
	
	/**
	 * 双向链表
	 *
	 * 双向链表是为了克服单链表这种单向性的缺点。
	 * 双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋。
	 *
	 * 双向链表也可以有循环表。
	 */
	
	var Node = function Node(data) {
	    var prev = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var next = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.prev = prev;
	    this.next = next;
	};
	
	function defaultCompare(a, b) {
	    return a === b;
	}
	
	var DoubleLinkedList = function () {
	    function DoubleLinkedList(sqList) {
	        var compare = arguments.length <= 1 || arguments[1] === undefined ? defaultCompare : arguments[1];
	        (0, _classCallCheck3.default)(this, DoubleLinkedList);
	
	        this.head = null;
	        this.tail = null;
	        this.size = 0;
	        this.compare = compare;
	
	        if (sqList && sqList.length) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = (0, _getIterator3.default)(sqList), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var item = _step.value;
	
	                    this.push(item);
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        }
	    }
	
	    (0, _createClass3.default)(DoubleLinkedList, [{
	        key: _iterator4.default,
	        value: _regenerator2.default.mark(function value() {
	            var current;
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            current = this.head;
	
	                        case 1:
	                            if (!current) {
	                                _context.next = 7;
	                                break;
	                            }
	
	                            _context.next = 4;
	                            return current.data;
	
	                        case 4:
	
	                            current = current.next;
	                            _context.next = 1;
	                            break;
	
	                        case 7:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.head = null;
	            this.tail = null;
	            this.size = 0;
	
	            return true;
	        }
	    }, {
	        key: 'push',
	        value: function push(data) {
	            if (typeof data === 'undefined') throw new Error('data argument required');
	
	            ++this.size;
	
	            if (!this.head) {
	                this.head = this.tail = new Node(data);
	            } else {
	                var node = new Node(data, this.tail, null);
	                this.tail.next = node;
	                this.tail = node;
	            }
	
	            return data;
	        }
	    }, {
	        key: 'unshift',
	        value: function unshift(data) {
	            if (typeof data === 'undefined') throw new Error('data argument required');
	
	            ++this.size;
	
	            if (!this.head) {
	                this.head = this.tail = new Node(data);
	            } else {
	                var node = new Node(data, null, this.head);
	                this.head.prev = node;
	                this.head = node;
	            }
	
	            return data;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            if (!this.tail) {
	                this.head = this.tail = null;
	                return;
	            }
	
	            --this.size;
	
	            this.tail.prev.next = null;
	            this.tail = this.tail.prev;
	        }
	    }, {
	        key: 'shift',
	        value: function shift() {
	            if (!this.head) {
	                this.head = this.tail = null;
	                return;
	            }
	
	            --this.size;
	
	            this.head.next.prev = null;
	            this.head = this.head.next;
	        }
	    }, {
	        key: 'update',
	        value: function update(index, data) {
	            var node = this.findByIndex(index, true);
	            node.data = data;
	            return this;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(data) {
	            if (typeof data === 'function') throw new Error('data argument required');
	
	            var current = this.head;
	
	            while (current) {
	                if (this.compare(data, current.data)) {
	                    --this.size;
	
	                    if (current === this.head) {
	                        this.head = this.head.next;
	
	                        if (this.head) {
	                            this.head.prev = null;
	                        } else {
	                            this.head = this.tail = null;
	                        }
	                    } else if (current === this.tail) {
	                        this.tail = this.tail.prev;
	
	                        if (this.tail) {
	                            this.tail.prev.next = null;
	                        } else {
	                            this.head = this.tail = null;
	                        }
	                    } else {
	                        current.prev.next = current.next;
	                        current.next.prev = current.prev;
	                    }
	
	                    return current.data;
	                }
	
	                current = current.next;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(data) {
	            var current = this.head;
	            var index = -1;
	
	            while (current) {
	                ++index;
	                if (this.compare(data, current.data)) return index;
	
	                current = current.next;
	            }
	
	            return -1;
	        }
	    }, {
	        key: 'findByIndex',
	        value: function findByIndex() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            var returnNode = arguments[1];
	
	            var current = this.head;
	            var j = 0;
	
	            while (current) {
	                if (j++ === index) break;
	
	                current = current.next;
	            }
	
	            return returnNode ? current : current.data;
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach() {
	            var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	            if (typeof cb !== 'function') throw new Error('argument should be a function');
	
	            var current = this.head;
	
	            while (current) {
	                cb(current.data);
	
	                current = current.next;
	            }
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            var list = [];
	            var current = this.head;
	
	            while (current) {
	                list.push(current.data);
	
	                current = current.next;
	            }
	
	            return list;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.toJSON() + '';
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this.size;
	        }
	    }]);
	    return DoubleLinkedList;
	}();
	
	exports.default = DoubleLinkedList;
	
	
	var a = new DoubleLinkedList([2, 3]);
	a.unshift(1);
	a.push(4);
	console.log(a.indexOf(4));
	console.log(a.findByIndex(2));
	
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;
	
	try {
	    for (var _iterator2 = (0, _getIterator3.default)(a), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var item = _step2.value;
	
	        console.log(item);
	    }
	} catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	        }
	    } finally {
	        if (_didIteratorError2) {
	            throw _iteratorError2;
	        }
	    }
	}
	
	a.pop();
	a.shift();
	a.remove(2);
	a.remove(32);
	a.remove(3);

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(100);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _regenerator = __webpack_require__(45);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _iterator = __webpack_require__(17);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 由于链表在空间的合理利用上和插入，删除时不需要移动等的有点，因此在很多场合下，它是线性表的首选存储结构。然而，它也存在着实现某些基本操作，如求线性表长度时不如顺序存储结构的缺点；另一方面，由于在链表中，结点之间的关系使用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际出发重新定义线性链表及其基本操作
	 */
	
	var Node = function Node() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var next = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, Node);
	
	    this.data = data;
	    this.next = next;
	};
	
	var LinkedList = function () {
	    function LinkedList(sqList) {
	        (0, _classCallCheck3.default)(this, LinkedList);
	
	        this.head = null;
	        this.tail = null;
	
	        if (sqList) {
	            for (var i = 0, len = sqList.length; i < len; ++i) {
	                this.push(sqList[i]);
	            }
	        }
	    }
	
	    (0, _createClass3.default)(LinkedList, [{
	        key: 'shift',
	
	
	        // delete first element and return it
	        value: function shift() {
	            var head = this.head;
	            this.head = this.head.next;
	            head.next = null;
	
	            if (this.head === null) this.tail = null;
	            return head;
	        }
	    }, {
	        key: 'pop',
	        value: function pop() {
	            var current = this.head;
	            var previous = this.head;
	            var elem = void 0;
	
	            while (current !== null) {
	                if (this.tail === current) {
	                    if (current === this.head) {
	                        elem = this.tail.data;
	                        this.head = null;
	                        break;
	                    }
	
	                    this.tail = previous;
	
	                    previous.next = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                previous = current;
	                current = current.next;
	            }
	
	            if (this.head === null) this.tail = null;
	
	            return elem ? elem : false;
	        }
	
	        // append node
	
	    }, {
	        key: 'append',
	        value: function append(node) {
	            if (this.head !== null) {
	                this.tail.next = node;
	                this.tail = this.tail.next;
	            } else {
	                this.head = node;
	                this.tail = node;
	            }
	        }
	
	        // add data
	
	    }, {
	        key: 'push',
	        value: function push(data) {
	            if (this.head === null) {
	                this.head = new Node(data);
	                this.tail = this.head;
	            } else {
	                this.tail.next = new Node(data);
	                this.tail = this.tail.next;
	            }
	
	            this.tail.data = data;
	        }
	
	        // remove data
	
	    }, {
	        key: 'remove',
	        value: function remove(data) {
	            var current = this.head;
	            var previous = this.head;
	            var elem = void 0;
	
	            while (current !== null) {
	                if (data === current.data) {
	                    if (current === this.head) {
	                        this.head = current.next;
	                        elem = current.data;
	                        break;
	                    }
	
	                    if (current === this.tail) this.tail = previous;
	
	                    previous.next = current.next;
	                    elem = current.data;
	                    break;
	                }
	
	                previous = current;
	                current = current.next;
	            }
	
	            if (this.head === null) this.tail = null;
	
	            return elem ? elem : false;
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(data) {
	            var current = this.head;
	            var index = -1;
	            while (current !== null) {
	                ++index;
	                if (current.data === data) {
	                    return index;
	                }
	
	                current = current.next;
	            }
	
	            return index;
	        }
	    }, {
	        key: 'unshift',
	        value: function unshift(data) {
	            var temp = new Node(data);
	            temp.next = this.head;
	            this.head = temp;
	        }
	    }, {
	        key: 'insertAfter',
	        value: function insertAfter(target, data) {
	            var current = this.head;
	            while (current !== null) {
	                if (current.data === target) {
	                    var temp = new Node(data);
	                    temp.next = current.next;
	
	                    if (current === this.tail) this.tail = temp;
	
	                    current.next = temp;
	                    return;
	                }
	
	                current = current.next;
	            }
	        }
	    }, {
	        key: 'item',
	        value: function item(index) {
	            var current = this.head;
	
	            while (current !== null) {
	                if (--index === 0) return current;
	
	                current = current.next;
	            }
	
	            return null;
	        }
	    }, {
	        key: 'each',
	        value: function each(callback) {
	            if (typeof callback !== 'function') return;
	
	            for (var current = this.head; current; current = current.next) {
	                if (callback(current)) break;
	            }
	        }
	    }, {
	        key: _iterator2.default,
	        value: _regenerator2.default.mark(function value() {
	            var current;
	            return _regenerator2.default.wrap(function value$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            current = this.head;
	
	                        case 1:
	                            if (!current) {
	                                _context.next = 7;
	                                break;
	                            }
	
	                            _context.next = 4;
	                            return current.data;
	
	                        case 4:
	                            current = current.next;
	                            _context.next = 1;
	                            break;
	
	                        case 7:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, value, this);
	        })
	    }, {
	        key: 'size',
	        value: function size() {
	            var current = this.head;
	            var size = 0;
	
	            while (current !== null) {
	                ++size;
	                current = current.next;
	            }
	
	            return size;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	
	            this.each(function (node) {
	                str += node.data + (node.next ? ',' : '');
	            });
	
	            return str;
	        }
	    }, {
	        key: 'orderInsert',
	        value: function orderInsert(data, cmp) {
	            cmp = typeof cmp === 'function' ? cmp : function (a, b) {
	                if (a > b) return 1;else if (a === b) return 0;else return -1;
	            };
	            var previous = this.head;
	            var current = this.head;
	
	            if (current === null) {
	                this.head = this.tail = new Node(data);
	                return;
	            }
	
	            var me = this;
	            while (current) {
	                var ret = cmp(data, current.data);
	                // 如果插入元素大于当前元素，准备下次遍历
	                if (ret > 0) {
	                    previous = current;
	                    current = current.next;
	
	                    // 如果等于，直接插入到后面
	                } else if (ret === 0) {
	                        return insertBetween(data, previous, current);
	
	                        // 如果小于则插入到前节点和当前节点中
	                        // 因为已经是排序了，所以不需要多余判断了
	                    } else {
	                            if (this.head === previous && previous === current) return this.unshift(data);else return insertBetween(data, previous, current);
	                        }
	            }
	
	            // 插入到最后一个结点
	            previous.next = new Node(data);
	            this.tail = previous.next;
	
	            function insertBetween(data, a, b) {
	                if (a == b) {
	                    if (a == me.head) return me.unshift(data);
	                } else {
	                    var temp = new Node(data);
	                    temp.next = b;
	                    a.next = temp;
	                    return true;
	                }
	            }
	        }
	
	        // 删除元素递增排列的链表中值大于min，且小于max的所有元素
	
	    }, {
	        key: 'delete_between',
	        value: function delete_between(min, max) {
	            var p = this.head;
	
	            // p是最后一个不大于min的元素
	            while (p.next && p.next.data <= min) {
	                p = p.next;
	            } // 如果还有比min更大的元素
	            var q = void 0;
	            if (p.next) {
	                q = p.next;
	                // q是第一个不小于max的元素
	                while (q && q.data < max) {
	                    q = q.next;
	                }p.next = q;
	            }
	
	            var last = q || p;
	            while (last.next) {
	                last = last.next;
	            }this.tail = last;
	        }
	
	        // 删除元素递增排列的链表的重复元素
	
	    }, {
	        key: 'delete_equal',
	        value: function delete_equal() {
	            var p = this.head;
	            var q = p.next;
	
	            while (p.next) {
	                // 当相邻两元素不相等时，p,q都向后移
	                if (p.data !== q.data) {
	                    p = p.next;
	                    q = p.next;
	                } else {
	                    while (q.data === p.data) {
	                        q = q.next;
	                    } // 删除
	                    p.next = q;
	                    p = q;
	                    q = p.next;
	                }
	            }
	        }
	    }, {
	        key: 'reverse',
	        value: function reverse() {
	            var p = this.head;
	            var q = p.next;
	            var s = q.next;
	            p.next = null;
	
	            while (s.next) {
	                q.next = p;
	                p = q;
	                q = s;
	                s = s.next;
	            }
	
	            q.next = p;
	            s.next = q;
	            this.head = s;
	        }
	    }], [{
	        key: 'mergeList',
	        value: function mergeList(a, b) {
	            var compare = arguments.length <= 2 || arguments[2] === undefined ? compFn : arguments[2];
	
	            var ha = a.head;
	            var hb = b.head;
	            var pa = ha;
	            var pb = hb;
	            var c = new LinkedList();
	            var q = void 0;
	
	            while (pa && pb) {
	                var data1 = pa.data;
	                var data2 = pb.data;
	
	                if (!compare(data1, data2)) {
	                    // delete head node
	                    q = a.shift();
	                    // append the node to c linkedList
	                    c.append(q);
	                    pa = a.head;
	                } else {
	                    q = b.shift();
	                    c.append(q);
	                    pb = b.head;
	                }
	            }
	
	            if (pa) c.append(pa);else c.append(pb);
	
	            return c;
	        }
	    }]);
	    return LinkedList;
	}();
	
	exports.default = LinkedList;
	
	
	function compFn(a, b) {
	    return a - b;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(list, bList) {
	    var cList = new LinkedList();
	
	    var p = list.head;
	    var q = bList.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (q.data > q.data) q = q.next;else {
	            cList.push(q.data);
	            p = p.next;
	            q = q.next;
	        }
	    }
	
	    return cList;
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(list, bList) {
	    var p = list.head;
	    var q = bList.head;
	    var pc = list.head;
	
	    while (p && q) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            pc.data = p.data;
	            p = p.next;
	            q = q.next;
	
	            if (!p || !q) {
	                pc.next = null;
	                list.tail = pc;
	            } else pc = pc.next;
	        }
	    }
	
	    pc.next = null;
	    list.tail = pc;
	}
	
	// a，b，c的元素均是非递减排列
	// 求a链表中非b链表和c链表的交集的元素。
	function intersect_delete(list, b, c) {
	    var p = b.head;
	    var q = c.head;
	    var r = list.head;
	
	    while (p && q && r) {
	        if (p.data < q.data) p = p.next;else if (p.data > q.data) q = q.next;else {
	            // 确定待删除元素
	            var elem = p.data;
	
	            if (r.data === elem && r === list.head) {
	                list.head = list.head.next;
	            } else {
	                // 确定最后一个小于elem的元素指针
	                while (r.next && r.next.data < elem) {
	                    r = r.next;
	                }if (r.next.data === elem) {
	                    var s = r.next;
	
	                    // 确定第一个大于elem的元素指针
	                    while (s && s.data === elem) {
	                        s = s.next;
	                    } // 删除r和s之间的元素
	                    r.next = s;
	                }
	            }
	
	            while (p && p.data === elem) {
	                p = p.next;
	            }while (q && q.data === elem) {
	                q = q.next;
	            }
	        }
	    }
	
	    list.tail = r;
	}
	
	var list = new LinkedList();
	list.push('b');
	list.unshift('a');
	list.insertAfter('b', 'c');
	console.log(list.item(2));
	console.log((0, _stringify2.default)(list));
	list.each(function (node) {
	    if (node.data === 'b') {
	        console.log('get b in each');
	    }
	});
	list.remove('c');
	list.remove('a');
	console.log(list);
	
	var list2 = new LinkedList();
	list2.push('c');
	list2.unshift('d');
	list2.insertAfter('d', 'b');
	console.log((0, _stringify2.default)(list2));
	
	var list3 = LinkedList.mergeList(list, list2);
	console.log(list3);
	
	var list = new LinkedList();
	
	list.orderInsert(5);
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	list.orderInsert(4);
	list.orderInsert(4);
	list.orderInsert(6);
	list.orderInsert(6);
	list.orderInsert(7);
	
	list.delete_between(5, 8);
	console.log('delete-between:  ');
	console.log(list);
	
	list.orderInsert(2);
	list.orderInsert(3);
	list.orderInsert(1);
	
	list.delete_equal();
	console.log(list);
	
	list.reverse();
	console.log(list);
	
	var a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var b = new LinkedList();
	b.orderInsert(1);
	b.orderInsert(5);
	b.orderInsert(9);
	b.orderInsert(13);
	b.orderInsert(17);
	console.log(intersect(a, b));
	
	console.log(intersect_true(a, b));
	
	a = new LinkedList();
	a.orderInsert(1);
	a.orderInsert(3);
	a.orderInsert(5);
	a.orderInsert(7);
	a.orderInsert(9);
	
	var test = new LinkedList();
	test.orderInsert(1);
	test.orderInsert(2);
	test.orderInsert(3);
	test.orderInsert(4);
	test.orderInsert(5);
	test.orderInsert(6);
	test.orderInsert(9);
	
	intersect_delete(test, a, b);
	console.log(test);
	
	var popTest = new LinkedList();
	popTest.push(1);
	popTest.push(2);
	popTest.pop();
	popTest.pop();

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 静态单链表
	/*
	 有时可借用一维数组来描述线性链表，这就是线性表的静态单链表存储结构。
	 在静态链表中，数组的一个分量表示一个结点，同时用游标（cur）代替指针指示结点在数组中的相对位置。
	 数组的第0分量可看成头结点，其指针域指示链表的第一个结点。
	 这种存储结构需要预先分配一个较大的空间，但在线性表的插入和删除操作时不需移动元素，
	 仅需要修改指针，故仍具有链式存储结构的主要优点
	 */
	
	var StaticLinkedList = function () {
	    function StaticLinkedList(MAXSIZE) {
	        (0, _classCallCheck3.default)(this, StaticLinkedList);
	
	        this[-1] = { cur: 0 };
	        this.length = 0;
	        this.MAXSIZE = MAXSIZE + 1 || 1000;
	    }
	
	    /**
	     * 在静态单链线性表L中查找第1个值为e的元素，
	     * 若找到，则返回它在L中的位序
	     * @param data
	     */
	
	
	    (0, _createClass3.default)(StaticLinkedList, [{
	        key: 'find',
	        value: function find(data) {
	            var i = this[0].cur;
	            while (i && this[i].data !== data) {
	                i = this[i].cur;
	            }
	            return i;
	        }
	        /**
	         * 将一维数组中各分量链成一个备用链表
	         * this[0].cur为头指针
	         */
	
	    }, {
	        key: 'init',
	        value: function init(len) {
	            len = len ? len + 1 : this.MAXSIZE;
	            for (var i = 0; i < len - 1; ++i) {
	                this[i] = this[i] || { data: null, cur: null };
	                this[i].cur = i + 1;
	            }
	
	            this[len - 1] = this[len - 1] || {};
	            this[len - 1].cur = 0;
	        }
	        /**
	         * 若备用链表非空，则返回分配的结点下标，反则返回0
	         * @returns {*}
	         */
	
	    }, {
	        key: 'malloc',
	        value: function malloc() {
	            var i = this[-1].cur;
	            if (typeof this[-1].cur !== 'undefined') this[-1].cur = this[i].cur;
	            return i;
	        }
	        /**
	         * 将下标为k的空闲结点回收到备用链表
	         * @param k
	         */
	
	    }, {
	        key: 'free',
	        value: function free(k) {
	            this[k].cur = this[0].cur;
	            this[0].cur = k;
	        }
	    }, {
	        key: 'create',
	        value: function create(sqList) {
	            // 初始化备用空间
	            this.init(sqList.length);
	            // 生成s的头结点
	            var s = this.malloc();
	            // r指向s的当前最后结点
	            var r = s;
	            var m = sqList.length;
	
	            // 建立集合A的链表
	            for (var j = 0; j < m; ++j) {
	                //分配结点
	                var i = this.malloc();
	                // 输入A元素的值
	                this[i].data = sqList[j];
	                // 插入到表尾
	                this[r].cur = i;
	                ++this.length;
	                r = i;
	            }
	            // 尾结点的指针为空
	            this[r].cur = 0;
	        }
	
	        // todo
	
	    }, {
	        key: 'add',
	        value: function add(index, elem) {}
	    }, {
	        key: 'remove',
	        value: function remove(index) {}
	    }]);
	    return StaticLinkedList;
	}();
	
	/**
	 * 在一维数组中建立表示集合(A-B)U(B-A)
	 * 的静态链表，s为其头指针。
	 * @returns {*}
	 */
	
	
	exports.default = StaticLinkedList;
	function difference(sllist, arr1, arr2) {
	    // 初始化备用空间
	    sllist.init();
	    // 生成s的头结点
	    var s = sllist.malloc();
	    // r指向s的当前最后结点
	    var r = s;
	    // 删除A和B的元素个数
	    var m = arr1.length;
	    var n = arr2.length;
	
	    // 建立集合A的链表
	    for (var j = 0; j < m; ++j) {
	        //分配结点
	        var i = sllist.malloc();
	        // 输入A元素的值
	        sllist[i].data = arr1[j];
	        // 插入到表尾
	        sllist[r].cur = i;
	        r = i;
	    }
	    // 尾结点的指针为空
	    sllist[r].cur = 0;
	
	    // 依次输入B的元素，若不在当前表中，则插入，
	    // 否则删除
	    for (var _j = 0; _j < n; ++_j) {
	        var b = arr2[_j];
	        var p = s;
	        // k指向集合中的第一个结点
	        var k = sllist[s].cur;
	        // 在当前表中查找
	        while (k !== sllist[r].cur && sllist[k].data !== b) {
	            p = k;
	            k = sllist[k].cur;
	        }
	        // 当前表中不存在该元素，插入在r所指结点之后，且r的位置不变
	        if (k === sllist[r].cur) {
	            var _i = sllist.malloc();
	            sllist[_i].data = b;
	            sllist[_i].cur = sllist[r].cur;
	            sllist[r].cur = _i;
	
	            // 该元素已在表中，删除之
	        } else {
	                sllist[p].cur = sllist[k].cur;
	                sllist.free(k);
	                // 若删除的是r所指结点，则需修改尾指针
	                if (r === k) r = p;
	            }
	    }
	}
	
	var sl = new StaticLinkedList(10);
	var ret = difference(sl, [1, 2, 3], [3, 4, 5]);
	console.log(sl);
	
	var test = new StaticLinkedList(10);
	test.create([49, 38, 65, 97, 76, 13, 27, 49]);
	console.log(test);

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(26);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(28);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(27);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinaryTree2 = __webpack_require__(15);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BSTNode = function (_BinaryTree) {
	    (0, _inherits3.default)(BSTNode, _BinaryTree);
	
	    function BSTNode() {
	        var _Object$getPrototypeO;
	
	        (0, _classCallCheck3.default)(this, BSTNode);
	
	        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
	            arg[_key] = arguments[_key];
	        }
	
	        return (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(BSTNode)).call.apply(_Object$getPrototypeO, [this].concat(arg)));
	    }
	
	    /**
	     * BST树的查找（递归）
	     * @param {*} key
	     * @returns {*}
	     */
	
	
	    (0, _createClass3.default)(BSTNode, [{
	        key: 'search',
	        value: function search(key) {
	            if (this.data != null) {
	                if (this.data === key) return this;else if (key < this.data) {
	                    if (this.leftChild) return this.leftChild.search(key);
	                } else {
	                    if (this.rightChild) return this.rightChild.search(key);
	                }
	            }
	
	            return null;
	        }
	
	        /**
	         * BST树的查找（非递归）
	         * @param {*} key
	         * @returns {*}
	         */
	
	    }, {
	        key: 'searchNonRecursive',
	        value: function searchNonRecursive(key) {
	            if (this.data == null) return null;
	
	            var p = this;
	            while (p && p.data !== key) {
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            if (!p || key !== p.data) return null;else return p;
	        }
	
	        /**
	         * BST树的插入（递归）
	         * @param {*} key
	         */
	
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            if (this.data == null) {
	                this.data = key;
	                return;
	            }
	            if (key === this.data) return;
	
	            var node = new BSTNode(key);
	            if (key < this.data) {
	                if (!this.leftChild) this.leftChild = node;
	                this.leftChild.insert(key);
	            } else {
	                if (!this.rightChild) this.rightChild = node;
	                this.rightChild.insert(key);
	            }
	        }
	
	        /**
	         * BST树的插入（非递归）
	         * @param {*} key
	         */
	
	    }, {
	        key: 'insertNonRecursive',
	        value: function insertNonRecursive(key) {
	            if (this.data == null) {
	                this.data = key;
	                return;
	            }
	
	            var p = this;
	            var q = void 0;
	            while (p) {
	                if (p.data === key) return;
	                // q作为p的父节点
	                q = p;
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            var node = new BSTNode(key);
	            if (key < q.data) q.leftChild = node;else q.rightChild = node;
	        }
	
	        /**
	         * 利用BST树的插入操作建立一棵BST树
	         * @param {Array} arr
	         * @param {Boolean|undefined} useNonRecursive 是否使用非递归
	         */
	
	    }, {
	        key: 'createBST',
	        value: function createBST(arr, useNonRecursive) {
	            var i = void 0;
	            if (useNonRecursive) {
	                for (i = 0; i < arr.length; ++i) {
	                    this.insertNonRecursive(arr[i]);
	                }
	            } else {
	                for (i = 0; i < arr.length; ++i) {
	                    this.insert(arr[i]);
	                }
	            }
	
	            return this;
	        }
	
	        /**
	         * 使用递归的方法删除与关键字符合的结点
	         * @param {*} key 需要查找的关键字
	         * @param {BSTNode} parent 父节点，内部调用需要用到
	         * @returns {Boolean}
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key, parent) {
	            // 空结点的情况
	            if (this.data == null) return false;
	
	            // 找到关键字
	            if (this.data === key) return deleteNode(this, parent);
	            // 查找左子树，如果有的话
	            else if (key < this.data) {
	                    if (this.leftChild) return this.leftChild.remove(key, this);
	                }
	                // 查找右子树，如果有的话
	                else {
	                        if (this.rightChild) return this.rightChild.remove(key, this);
	                    }
	
	            // 未找到
	            return false;
	        }
	
	        /**
	         * 非递归删除与关键字符合的结点
	         * @param {*} key 需要查找的关键字
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'removeNonRecursive',
	        value: function removeNonRecursive(key) {
	            var p = this;
	            var f = void 0;
	
	            while (p && p.data !== key) {
	                f = p;
	                if (key < p.data) p = p.leftChild;else p = p.rightChild;
	            }
	
	            // 没有要删除的结点
	            if (!p) return false;
	
	            // 找到了要删除的结点p
	            var s = p;
	            var q = void 0;
	            // 如果有左右子树
	            if (p.leftChild && p.rightChild) {
	                f = p;
	                s = p.leftChild;
	
	                // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                while (s.rightChild) {
	                    f = s;
	                    s = s.rightChild;
	                }
	
	                p.data = s.data;
	            }
	
	            // 若s有左子树，右子树为空
	            if (s.leftChild) q = s.leftChild;else q = s.rightChild;
	
	            // 只有一个根结点的情况
	            if (!f) this.data = null;else if (f.leftChild == s) f.leftChild = q;else f.rightChild = q;
	
	            return true;
	        }
	
	        /**
	         * 找到小于x的最大元素和大于x的最小元素
	         * @param {String|Number} x
	         * @returns {Array} [min, max]
	         */
	
	    }, {
	        key: 'findNeighborElem',
	        value: function findNeighborElem(x) {
	            var last = typeof this.data === 'number' ? -Infinity : 'a';
	            var ret = [];
	
	            void function recurse(tree, x) {
	                if (tree.leftChild) recurse(tree.leftChild, x);
	                if (last < x && tree.data >= x) ret[0] = last;
	                if (last <= x && tree.data > x) ret[1] = tree.data;
	                last = tree.data;
	                if (tree.rightChild) recurse(tree.rightChild, x);
	            }(this, x);
	
	            return ret;
	        }
	
	        /**
	         * 把二叉排序树bst合并到该树中
	         * @param {BSTNode} bst
	         */
	
	    }, {
	        key: 'merge',
	        value: function merge(bst) {
	            if (bst.leftChild) this.merge(bst.leftChild);
	            if (bst.rightChild) this.merge(bst.rightChild);
	            this.insert(bst.data);
	        }
	
	        /**
	         * 把结点插入到合适位置
	         * @param {BSTNode} node 待插入的结点
	         */
	
	    }, {
	        key: 'insertNode',
	        value: function insertNode(node) {
	            if (this.data == null) {
	                this.data = node.data;
	            } else {
	                if (node.data > this.data) {
	                    if (!this.rightChild) this.rightChild = node;else this.rightChild.insertNode(node);
	                } else if (node.data < this.data) {
	                    if (!this.leftChild) this.leftChild = node;else this.leftChild.insertNode(node);
	                }
	            }
	
	            node.leftChild = node.rightChild = null;
	        }
	
	        /**
	         * 分裂为两棵二叉排序树
	         * @param {*} x
	         * @returns {BSTNode[a, b]} a的元素全部小于等于x，b的元素全部大于x
	         */
	
	    }, {
	        key: 'split',
	        value: function split(x) {
	            var a = new BSTNode();
	            var b = new BSTNode();
	
	            void function split(tree, x) {
	                if (tree.leftChild) split(tree.leftChild, x);
	                if (tree.rightChild) split(tree.rightChild, x);
	                if (tree.data <= x) a.insertNode(tree);else b.insertNode(tree);
	            }(this, x);
	
	            return [a, b];
	        }
	
	        /**
	         * 判断tree是否是二叉排序树
	         * @param tree
	         */
	
	    }], [{
	        key: 'isBSTTree',
	        value: function isBSTTree(tree) {
	            var last = typeof tree.data === 'number' ? -Infinity : 'a';
	            var flag = true;
	
	            void function isBSTTree(tree) {
	                if (tree.leftChild && flag) isBSTTree(tree.leftChild);
	                if (tree.data < last) flag = false;
	                last = tree.data;
	                if (tree.rightChild && flag) isBSTTree(tree.rightChild);
	            }(tree);
	
	            return flag;
	        }
	    }]);
	    return BSTNode;
	}(_BinaryTree2.BinaryTree);
	
	/**
	 * 删除结点
	 * @param {BSTNode} p 要删除的结点
	 * @param {BSTNode} parent 要删除的结点的父节点
	 * @returns {boolean} 返回删除成功
	 */
	/*
	 动态查找
	
	 当查找表以线性表的形式组织时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。
	 利用树的形式组织查找表，可以对查找表进行动态高效的查找。
	
	
	 二叉排序树(BST)的定义
	
	 二叉排序树(Binary Sort Tree或Binary Search Tree) 的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。
	 (1) ：若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；
	 (2) ：若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；
	 (3) ：左、右子树都分别是二叉排序树。
	 结论：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。
	
	
	 BST树的查找
	 1  查找思想
	 首先将给定的K值与二叉排序树的根结点的关键字进行比较：若相等： 则查找成功；
	 ① 给定的K值小于BST的根结点的关键字：继续在该结点的左子树上进行查找；
	 ② 给定的K值大于BST的根结点的关键字：继续在该结点的右子树上进行查找。
	
	 在随机情况下，二叉排序树的平均查找长度ASL和㏒(n)(树的深度)是等数量级的。
	
	
	 BST树的插入
	
	 在BST树中插入一个新结点，要保证插入后仍满足BST的性质。
	
	 1 插入思想
	 在BST树中插入一个新结点x时，若BST树为空，则令新结点x为插入后BST树的根结点；否则，将结点x的关键字与根结点T的关键字进行比较：
	 ① 若相等： 不需要插入；
	 ②  若x.key<T->key：结点x插入到T的左子树中；
	 ③  若x.key>T->key：结点x插入到T的右子树中。
	
	 由结论知，对于一个无序序列可以通过构造一棵BST树而变成一个有序序列。
	 由算法知，每次插入的新结点都是BST树的叶子结点，即在插入时不必移动其它结点，仅需修改某个结点的指针。
	
	
	 BST树的删除
	
	 1  删除操作过程分析
	 从BST树上删除一个结点，仍然要保证删除后满足BST的性质。设被删除结点为p，其父结点为f ，删除情况如下：
	 ①  若p是叶子结点： 直接删除p。
	 ②  若p只有一棵子树(左子树或右子树)：直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树。
	 ③ 若p既有左子树又有右子树 ：处理方法有以下两种，可以任选其中一种。
	 ◆  用p的直接前驱结点代替p。即从p的左子树中选择值最大的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的左子树中的最右边的结点且没有右子树，对s的删除同②。
	 ◆ 用p的直接后继结点代替p。即从p的右子树中选择值最小的结点s放在p的位置(用结点s的内容替换结点p内容)，然后删除结点s。s是p的右子树中的最左边的结点且没有左子树，对s的删除同②。
	
	 */
	
	exports.default = BSTNode;
	function deleteNode(p, parent) {
	    // 叶子结点或只有一个结点
	    if (!p.leftChild && !p.rightChild) {
	        // 当前结点是其父结点的左子树还是右子树
	        var pos = parent && parent.leftChild == p ? 'leftChild' : 'rightChild';
	        if (parent) parent[pos] = null;
	        // 只有一个结点的情况
	        else p.data = null;
	    }
	    // 只有左子树
	    else if (!p.rightChild) {
	            p.data = p.leftChild.data;
	            p.leftChild = p.leftChild.leftChild;
	        }
	        // 只有右子树
	        else if (!p.leftChild) {
	                p.data = p.rightChild.data;
	                p.rightChild = p.rightChild.rightChild;
	            }
	            // 左右子树都有
	            else {
	                    var s = p.leftChild;
	                    // q为父结点
	                    var q = p;
	                    // 找到左子树的最大右子树，即仅小于左子树的值的结点
	                    while (s.rightChild) {
	                        q = s;
	                        s = s.rightChild;
	                    }
	
	                    p.data = s.data;
	                    if (q != p) q.rightChild = s.leftChild;else q.leftChild = s.leftChild;
	                }
	
	    return true;
	}
	
	var bst = new BSTNode();
	bst.createBST([45, 24, 53, 12, 24, 90]);
	console.log(bst.search(12));
	console.log(bst.search(13));
	
	var bst2 = new BSTNode();
	bst2.createBST([45, 24, 53, 12, 24, 90], true);
	console.log(bst2.searchNonRecursive(12));
	console.log(bst2.searchNonRecursive(13));
	
	console.log('\nfindSiblingElem: ');
	console.log(bst.findNeighborElem(12) + '');
	console.log(bst.findNeighborElem(90) + '');
	console.log(bst.findNeighborElem(45) + '');
	
	console.log(bst.remove(45));
	console.log(bst.remove(1));
	console.log(bst.remove(53));
	console.log(bst.remove(12));
	console.log(bst.remove(90));
	console.log(bst.remove(24));
	console.log(bst.remove(2));
	
	//console.log(bst2.removeNonRecursive(45));
	//console.log(bst2.removeNonRecursive(1));
	//console.log(bst2.removeNonRecursive(53));
	//console.log(bst2.removeNonRecursive(12));
	//console.log(bst2.removeNonRecursive(90));
	//console.log(bst2.removeNonRecursive(24));
	//console.log(bst2.removeNonRecursive(2));
	
	console.log('\nisBSTTree: ');
	console.log(BSTNode.isBSTTree(bst));
	//console.log(BSTNode.isBSTTree(sosTree));
	
	/**
	 * 从大到小输出二叉排序树中所有不小于x的元素
	 * @param bst
	 * @param x
	 */
	function printNotLessThan(bst, x) {
	    if (bst.rightChild) printNotLessThan(bst.rightChild, x);
	    if (bst.data < x) return;
	    console.log(bst.data);
	    if (bst.leftChild) printNotLessThan(bst.leftChild, x);
	}
	
	console.log('\nprintNotLessThan: ');
	printNotLessThan(bst2, 90);
	console.log('\n');
	printNotLessThan(bst2, 12);
	
	bst.merge(bst2);
	
	var a1 = new BSTNode(5);
	var a2 = new BSTNode(91);
	bst2.insertNode(a1);
	bst2.insertNode(a2);
	
	bst2.split(45);

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Created by Luke on 2015/2/2.
	 */
	
	var defaultCompare = __webpack_require__(21);
	
	/*
	 交换排序
	
	 是一类基于交换的排序，系统地交换反序的记录的偶对，直到不再有这样的偶对为止。其中最基本的是冒泡排序(Bubble Sort)。
	
	 冒泡排序
	 1  排序思想
	 依次比较相邻的两个记录的关键字，若两个记录是反序的(即前一个记录的关键字大于后前一个记录的关键字)，则进行交换，直到没有反序的记录为止。
	     ① 首先将L->R[1]与L->R[2]的关键字进行比较，若为反序(L->R[1]的关键字大于L->R[2]的关键字)，则交换两个记录；然后比较L->R[2]与L->R[3]的关键字，依此类推，直到L->R[n-1]与L->R[n]的关键字比较后为止，称为一趟冒泡排序，L->R[n]为关键字最大的记录。
	     ②  然后进行第二趟冒泡排序，对前n-1个记录进行同样的操作。
	 一般地，第i趟冒泡排序是对L->R[1 … n-i+1]中的记录进行的，因此，若待排序的记录有n个，则要经过n-1趟冒泡排序才能使所有的记录有序。
	
	 2  排序示例
	 设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41
	
	 初始关键字序列:  23    38     22     45     23     67     31     15    41
	 第一趟排序后:    23    22     38     23     45     31     15     41    67
	 第二趟排序后:    22    23     23     38     31     15     41     45    67
	 第三趟排序后:    22    23     23     31     15     38     41     45    67
	 第四趟排序后:    22    23     23     15     31     38     41     45    67
	 第五趟排序后:    22    23     15     23     31     38     41     45    67
	 第六趟排序后:    22    15     23     23     31     38     41     45    67
	 第七趟排序后:    15    22     23     23     31     38     41     45    67
	
	3.算法分析
	 时间复杂度
	 ◆  最好情况(正序)：比较次数：n-1；移动次数：0；
	 ◆  最坏情况(逆序)：
	 比较次数： n * (n - 1) / 2
	 移动次数： 3*n*(n - 1) / 2
	
	 故时间复杂度：T(n)=O(n²)
	 空间复杂度：S(n)=O(1)
	
	 */
	
	function bubbleSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var change = 0;
	
	        for (var j = 0; j <= len - i; ++j) {
	            if (comp(sqList[j + 1], sqList[j]) < 0) {
	                change = 1;
	                var temp = sqList[j];
	                sqList[j] = sqList[j + 1];
	                sqList[j + 1] = temp;
	            }
	        }
	
	        if (!change) break;
	    }
	}
	exports.bubbleSort = bubbleSort;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort(arr);
	console.log('bubbleSort:\n' + arr + '');
	
	// 冒泡改进1
	function bubbleSort2(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var len = sqList.length;
	    var change = len - 1;
	
	    while (change) {
	        for (var c = 0, i = 0; i < change; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                // c指示这一趟冒泡中发生交换的元素
	                c = i + 1;
	            }
	        }
	
	        change = c;
	    }
	}
	exports.bubbleSort2 = bubbleSort2;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	bubbleSort2(arr);
	console.log('bubbleSort2:\n' + arr + '');
	
	// 相邻两趟反方向起泡的冒泡排序算法
	function cockTailSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var len = sqList.length;
	    // 冒泡上下界
	    var low = 0,
	        high = len - 1;
	    var change = 1;
	    var temp;
	
	    while (low < high && change) {
	        change = 0;
	
	        // 从上向下起泡
	        for (var i = low; i < high; ++i) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改上界
	        --high;
	
	        // 从下向上起泡
	        for (i = high; i > low; --i) {
	            if (comp(sqList[i], sqList[i - 1]) < 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i - 1];
	                sqList[i - 1] = temp;
	                change = 1;
	            }
	        }
	        // 修改下界
	        ++low;
	    }
	}
	exports.cockTailSort = cockTailSort;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort(arr);
	console.log('cockTailSort:\n' + arr + '');
	
	// 改进3
	function cockTailSort2(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var b = {};
	    var len = sqList.length;
	    // d为冒泡方向标识， 1为向上，-1为向下
	    var d = 1;
	    // b[0]为冒泡上界，b[2]为冒泡上界，b[1]无用
	    b[0] = 0;
	    b[2] = len - 1;
	    var change = 1;
	
	    while (b[0] < b[2] && change) {
	        change = 0;
	
	        // 统一的冒泡算法
	        for (var i = b[1 - d]; i !== b[1 + d]; i += d) {
	            // 注意这个交换条件
	            if (comp(sqList[i], sqList[i + d]) * d > 0) {
	                var temp = sqList[i];
	                sqList[i] = sqList[i + d];
	                sqList[i + d] = temp;
	                change = 1;
	            }
	        }
	
	        // 修改边界
	        b[1 + d] -= d;
	        // 换个方向
	        d *= -1;
	    }
	}
	exports.cockTailSort2 = cockTailSort2;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	cockTailSort2(arr);
	console.log('cockTailSort2:\n' + arr + '');
	
	/*
	 快速排序
	
	 1  排序思想
	 通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录进行下一趟排序，以达到整个序列有序。
	
	 2  排序过程
	 设待排序的记录序列是R[s…t] ，在记录序列中任取一个记录(一般取R[s])作为参照(又称为基准或枢轴)，以R[s].key为基准重新排列其余的所有记录，方法是：
	     ◆ 所有关键字比基准小的放R[s]之前；
	     ◆ 所有关键字比基准大的放R[s]之后。
	 以R[s].key最后所在位置i作为分界，将序列R[s…t]分割成两个子序列，称为一趟快速排序。
	
	 3  一趟快速排序方法
	 从序列的两端交替扫描各个记录，将关键字小于基准关键字的记录依次放置到序列的前边；而将关键字大于基准关键字的记录从序列的最后端起，依次放置到序列的后边，直到扫描完所有的记录。
	
	 设置指针low，high，初值为第1个和最后一个记录的位置。
	 设两个变量i，j，初始时令i=low，j=high，以R[low].key作为基准(将R[low]保存在temp中) 。
	 ① 从j所指位置向前搜索：将temp与R[j].key进行比较：
	    ◆ 若temp≤R[j].key ：令j=j-1，然后继续进行比较， 直到i=j或temp>R[j].key为止；
	    ◆ 若temp>R[j].key ：R[j]R[i]，腾空R[j]的位置， 且令i=i+1；
	 ② 从i所指位置起向后搜索：将temp与R[i].key进行比较：
	    ◆ 若temp≥R[i].key ：令i=i+1，然后继续进行比较， 直到i=j或temp<R[i].key为止；
	    ◆ 若temp<R[i].key ：R[i]R[j]，腾空R[i]的位置， 且令j=j-1；
	 ③ 重复①、②，直至i=j为止，i就是temp(基准)所应放置的位置。
	
	 算法分析
	 快速排序的主要时间是花费在划分上，对长度为k的记录序列进行划分时关键字的比较次数是k-1 。设长度为n的记录序列进行排序的比较次数为C(n)，则C(n)=n-1+C(k)+C(n-k-1) 。
	 ◆  最好情况：每次划分得到的子序列大致相等，则
	 C(n)<=h×n+2h×C(n/2h) ，当n/2h=1时排序结束。
	 即C(n)≤O(n×㏒2n) ；
	 ◆  最坏情况：每次划分得到的子序列中有一个为空，另一个子序列的长度为n-1。即每次划分所选择的基准是当前待排序序列中的最小(或最大)关键字。
	 比较次数：:  即C(n)=O(n2)
	 ◆  一般情况： 对n个记录进行快速排序所需的时间T(n)组成是：
	     ① 对n个记录进行一趟划分所需的时间是：n×C ，C是常数；
	     ② 对所得到的两个子序列进行快速排序的时间：
	        Tavg(n)=C(n)+Tavg(k-1)+Tavg(n-k)          ……
	
	 快速排序的平均时间复杂度是：T(n)=O(n㏒2n)
	 从所需要的附加空间来看，快速排序算法是递归调用，系统内用堆栈保存递归参数，当每次划分比较均匀时，栈的最大深度为[㏒2n]+1 。
	
	 快速排序的空间复杂度是：S(n)=O(㏒2n)
	 从排序的稳定性来看，快速排序是不稳定的。
	
	 */
	
	function partition1(sqList, low, high) {
	    var temp = sqList[low];
	
	    while (low < high) {
	        while (low < high && sqList[high] >= temp) {
	            --high;
	        }sqList[low] = sqList[high];
	        while (low < high && sqList[low] <= temp) {
	            ++low;
	        }sqList[high] = sqList[low];
	    }
	
	    sqList[low] = temp;
	
	    return low;
	}
	
	// 优化一趟快速排序方法： 随机化partition
	// 最坏情况效率大幅提升，时间复杂度T(n)=O(n㏒2n)
	function partition2(sqList, low, high) {
	    var temp;
	    var n = high - low + 1;
	    var rand = Math.floor(Math.random() * n) + low;
	
	    //var rand = (low + high) >> 1;
	    temp = sqList[high];
	    sqList[high] = sqList[rand];
	    sqList[rand] = temp;
	
	    var i = low - 1;
	    var pivot = sqList[high];
	
	    for (var j = low; j < high; ++j) {
	        if (sqList[j] <= pivot) {
	            ++i;
	            temp = sqList[i];
	            sqList[i] = sqList[j];
	            sqList[j] = temp;
	        }
	    }
	
	    ++i;
	    sqList[high] = sqList[i];
	    sqList[i] = pivot;
	
	    return i;
	}
	
	function partition(sqList, low, high, comp) {
	    var temp;
	    var i = low;
	    var j = high + 1;
	    var rand = Math.floor(Math.random() * (high - low)) + low + 1;
	    //var rand = (low + high) >> 1;
	
	    temp = sqList[low];
	    sqList[low] = sqList[rand];
	    sqList[rand] = temp;
	
	    var x = sqList[low];
	
	    while (1) {
	        while (comp(sqList[++i], x) < 0 && i < high) {}
	        while (comp(sqList[--j], x) > 0) {}
	        if (i >= j) break;
	        temp = sqList[i];
	        sqList[i] = sqList[j];
	        sqList[j] = temp;
	    }
	
	    sqList[low] = sqList[j];
	    sqList[j] = x;
	
	    return j;
	}
	
	function quickSortRecursive(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	
	    if (low >= high) return;
	
	    var k = partition(sqList, low, high, comp);
	    quickSortRecursive(sqList, low, k - 1, comp);
	    quickSortRecursive(sqList, k + 1, high, comp);
	}
	exports.quickSortRecursive = quickSortRecursive;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive(arr);
	console.log('quickSortRecursive:\n' + arr + '');
	
	/*
	快排递归算法优化，在最坏情况下堆栈深度为O(logn)
	 */
	function quickSortRecursive2(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	
	    while (low < high) {
	        var k = partition(sqList, low, high, comp);
	
	        // 对两个子数组中较小的一个子数组进行递归调用。
	        // 较小子数组的大小最多为原数组大小一半，
	        // 由于每次递归调用的数组大小至少减少一半，所以递归调用的次数
	        // 最多为O(logn)
	        if (k - low + 1 < high - k) {
	            quickSortRecursive2(sqList, low, k - 1, comp);
	            low = k + 1;
	        } else {
	            quickSortRecursive2(sqList, k + 1, high, comp);
	            high = k - 1;
	        }
	    }
	}
	exports.quickSortRecursive2 = quickSortRecursive2;
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortRecursive2(arr);
	console.log('quickSortRecursive2:\n' + arr + '');
	
	function quickSortNonRecursive(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	    var stack = [];
	    var k;
	
	    do {
	        while (low < high) {
	            k = partition(sqList, low, high, comp);
	            // 第二个子序列的上,下界分别入栈
	            stack.push(high, k + 1);
	            //stack.push(k + 1);
	            high = k - 1;
	        }
	
	        if (!stack.length) return;
	
	        low = stack.pop();
	        high = stack.pop();
	    } while (1);
	}
	exports.quickSortNonRecursive = quickSortNonRecursive;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSortNonRecursive(arr);
	console.log('quickSortNonRecursive:\n' + arr + '');
	
	// 优化版本
	function quickSort(sqList, low, high, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (low == null) low = 0;
	    if (high == null) high = sqList.length - 1;
	    var stack = [];
	    var pivot;
	
	    do {
	        // 如果当前子序列长度大于3且尚未排好序
	        if (high - low > 2) {
	            // 进行一趟划分
	            pivot = partition(sqList, low, high, comp);
	
	            // 吧长的子序列边界入栈，
	            // 短的子序列留待下次排序
	            if (high - pivot > pivot - low) {
	                stack.push(high, pivot + 1);
	                //stack.push();
	                high = pivot - 1;
	            } else {
	                stack.push(pivot - 1, low);
	                //stack.push();
	                low = pivot + 1;
	            }
	        }
	        // 如果当前子序列长度小于3，且尚未排好序，
	        // 直接进行比较排序买当前子序列标志为已排好序
	        else if (low < high && high - low < 3) {
	                easySort(sqList, low, high, comp);
	                low = high;
	            }
	            // 如果当前子序列已排好序但栈中还有未排序的子序列
	            // 从栈中取出一个子序列
	            else {
	                    if (!stack.length) return;
	
	                    low = stack.pop();
	                    high = stack.pop();
	                }
	    } while (1);
	}
	exports.quickSort = quickSort;
	
	function easySort(sqList, low, high, comp) {
	    var temp;
	
	    if (high - low === 1) {
	        if (comp(sqList[low], sqList[high]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[high];
	            sqList[high] = temp;
	        }
	    } else {
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	        if (comp(sqList[low + 1], sqList[high]) > 0) {
	            temp = sqList[low + 1];
	            sqList[low + 1] = sqList[high];
	            sqList[high] = temp;
	        }
	        if (comp(sqList[low], sqList[low + 1]) > 0) {
	            temp = sqList[low];
	            sqList[low] = sqList[low + 1];
	            sqList[low + 1] = temp;
	        }
	    }
	}
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	quickSort(arr);
	console.log('quickSort:\n' + arr + '');
	
	// 奇偶交换排序
	function oddEvenSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var change = 1;
	    var temp;
	    var len = sqList.length;
	
	    while (change) {
	        change = 0;
	        // 对所有奇数进行一趟比较
	        for (var i = 1; i < len - 1; i += 2) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	
	                change = 1;
	            }
	        }
	
	        // 对所有偶数进行一趟比较
	        for (i = 0; i < len - 1; i += 2) {
	            if (comp(sqList[i], sqList[i + 1]) > 0) {
	                temp = sqList[i];
	                sqList[i] = sqList[i + 1];
	                sqList[i + 1] = temp;
	
	                change = 1;
	            }
	        }
	    }
	}
	exports.oddEvenSort = oddEvenSort;
	
	var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
	oddEvenSort(arr);
	console.log('oddEvenSort:\n' + arr + '');
	
	/*
	把由三种颜色组成的序列重排为按照红白蓝的顺序排列，
	思路：
	设立三个指针，其中j表示当前元素；i以前的元素全部为红色；k以后的颜色全为蓝色。这样就可以根据j的颜色把其交换到序列的前面或者后面。
	 */
	var RED = 0;
	var WHITE = 1;
	var BLUE = 2;
	
	function flagArrange(colors) {
	    var i = 0;
	    var j = 0;
	    var k = colors.length - 1;
	    var temp;
	
	    while (j <= k) {
	        switch (colors[j]) {
	            case RED:
	                temp = colors[i];
	                colors[i] = colors[j];
	                colors[j] = temp;
	                ++i;
	                ++j;
	                break;
	            case WHITE:
	                ++j;
	                break;
	            case BLUE:
	                temp = colors[j];
	                colors[j] = colors[k];
	                colors[k] = temp;
	                --k;
	                break;
	            default:
	                break;
	        }
	    }
	}
	
	var arr = [2, 1, 0, 2, 1, 1, 0, 2, 0, 2, 1];
	flagArrange(arr);
	console.log(arr + '');

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(109), __esModule: true };

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(113), __esModule: true };

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(17);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(52);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(29)
	  , TAG = __webpack_require__(4)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(19)
	  , document = __webpack_require__(5).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(8) && !__webpack_require__(18)(function(){
	  return Object.defineProperty(__webpack_require__(55)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(33)
	  , $export        = __webpack_require__(9)
	  , redefine       = __webpack_require__(63)
	  , hide           = __webpack_require__(13)
	  , has            = __webpack_require__(10)
	  , Iterators      = __webpack_require__(14)
	  , $iterCreate    = __webpack_require__(125)
	  , setToStringTag = __webpack_require__(36)
	  , getPrototypeOf = __webpack_require__(61)
	  , ITERATOR       = __webpack_require__(4)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(35)
	  , createDesc     = __webpack_require__(20)
	  , toIObject      = __webpack_require__(11)
	  , toPrimitive    = __webpack_require__(41)
	  , has            = __webpack_require__(10)
	  , IE8_DOM_DEFINE = __webpack_require__(56)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(62)
	  , hiddenKeys = __webpack_require__(32).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 60 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(10)
	  , toObject    = __webpack_require__(40)
	  , IE_PROTO    = __webpack_require__(37)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(10)
	  , toIObject    = __webpack_require__(11)
	  , arrayIndexOf = __webpack_require__(117)(false)
	  , IE_PROTO     = __webpack_require__(37)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(13);

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(39)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(54)
	  , ITERATOR  = __webpack_require__(4)('iterator')
	  , Iterators = __webpack_require__(14);
	module.exports = __webpack_require__(3).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 66 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it don't break things.
	var cachedSetTimeout = setTimeout;
	var cachedClearTimeout = clearTimeout;
	
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _slicedToArray2 = __webpack_require__(103);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _toConsumableArray2 = __webpack_require__(104);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 十字链表
	 *
	 * 当矩阵的非零个数和位置在操作过程中变化大时，就不宜采用顺序存储结构来表示三元组的线性表。例如，在作“将矩阵B加到矩阵A上”的操作时，由于非零元的插入或删除将会引起A.data中元素的移动。为此，对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。
	 *
	 * 在链表中，每个非零元可用一个含5个域的结点表示，其中i，j和e这3个域分别表示该非零元所在的行，列和非零元的值，向右域right用以链接同一行中下一个非零元，向下域down用以链接同一列中下一个非零元。同一行的非零元通过right域链接成一个线性表，同一列中的非零元通常down域链接成一个线性链表，每一个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表。
	 *
	 * 可用两个分别存储行链表的头指针和列链表的头指针的一维数组来表示。
	 */
	
	// 稀疏矩阵的十字链表存储表示
	
	var OLNode = function OLNode() {
	    var i = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var j = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var e = arguments[2];
	    (0, _classCallCheck3.default)(this, OLNode);
	
	    // 该非零元的行和列下标
	    this.i = i;
	    this.j = j;
	    this.e = e;
	    // 该非零元所在行表和列表的后继链域
	    this.right = null; // type: OLNode
	    this.down = null; // type: OLNode
	};
	
	var CrossList = function () {
	    function CrossList() {
	        (0, _classCallCheck3.default)(this, CrossList);
	
	        // 行和列链表头指针向量基址由CreateSMatrix分配
	        this.rhead = [];
	        this.chead = [];
	        // 稀疏矩阵的行数，列数
	        this.mu = 0;
	        this.nu = 0;
	        this.tu = 0;
	    }
	
	    /**
	     * 矩阵初始化
	     * @param m
	     * @param n
	     * @param t
	     * @param {Array} list 二维数组，每行的元素分别是[i, j, e]
	     */
	
	
	    (0, _createClass3.default)(CrossList, [{
	        key: "createSMatrix",
	        value: function createSMatrix(m, n, t, list) {
	            this.mu = m;
	            this.nu = n;
	            this.tu = t;
	
	            for (var row = 0; row < list.length; row++) {
	                var p = new (Function.prototype.bind.apply(OLNode, [null].concat((0, _toConsumableArray3.default)(list[row]))))();
	
	                var _list$row = (0, _slicedToArray3.default)(list[row], 2);
	
	                var i = _list$row[0];
	                var j = _list$row[1];
	
	                var q = void 0;
	
	                if (this.rhead[i] == null || this.rhead[i].j > j) {
	                    p.right = this.rhead[i];
	                    this.rhead[i] = p;
	                } else {
	                    // 查询在行表中的插入位置
	                    for (q = this.rhead[i]; q.right && q.right.j < j; q = q.right) {}
	                    p.right = q.right;
	                    q.right = p;
	                }
	
	                if (this.chead[j] == null || this.chead[j].i > i) {
	                    p.down = this.chead[j];
	                    this.chead[j] = p;
	                } else {
	                    for (q = this.chead[j]; q.down && q.down.i < i; q = q.down) {}
	                    p.down = q.down;
	                    q.down = p;
	                }
	            }
	        }
	
	        // 矩阵相加
	
	    }, {
	        key: "addMatrix",
	        value: function addMatrix(crossList) {
	            var hl = [];
	            //hl初始化
	            for (var j = 0; j <= this.nu; j++) {
	                hl[j] = this.chead[j];
	            }for (var i = 0; i <= this.mu; i++) {
	                //pa和pb指向每一行的第一个非0元结点，直至最后一行
	                var pa = this.rhead[i];
	                var pb = crossList.rhead[i];
	                var pre = null;
	
	                //处理B的一行，直至本行中无非0元素的结点
	                while (pb) {
	                    var p = void 0,
	                        q = void 0;
	                    // 新插入一个结点到pa的左侧
	                    if (!pa || pa.j > pb.j) {
	                        p = new OLNode(pb.i, pb.j, pb.e);
	
	                        //行表的指针变化
	                        if (!pre) this.rhead[p.i] = p;else pre.right = p;
	
	                        p.right = pa;
	                        pre = p;
	
	                        //列表的指针变化
	                        if (hl[p.j]) {
	                            // 从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                            for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                hl[p.j] = q;
	                            }
	                        }
	
	                        //在列表中插入新结点，根据行数判断插入前面还是后面
	                        if (!this.chead[p.j] || this.chead[p.j].i > p.i) {
	                            p.down = this.chead[p.j];
	                            this.chead[p.j] = p;
	                        } else {
	                            p.down = hl[p.j].down;
	                            hl[p.j].down = p;
	                        }
	
	                        hl[p.j] = p;
	                        pb = pb.right;
	                    } else if (pa.j < pb.j) {
	                        pre = pa;
	                        pa = pa.right;
	                    } else {
	                        //当pa.j === pb.j时，将B中当前结点的值加到A中当前结点上
	                        pa.e += pb.e;
	
	                        //当pa.e === 0时，删除该结点
	                        if (pa.e === 0) {
	                            // 若无前驱结点，将第一个非0元结点置为当前结点的后继结点，
	                            // 否则前驱结点的后继结点为当前结点的后继结点
	                            if (!pre) this.rhead[pa.i] = pa.right;else pre.right = pa.right;
	
	                            p = pa;
	                            pa = pa.right;
	
	                            //列表的指针变化
	                            if (hl[p.j]) {
	                                //从hl[p.j]开始找到新结点在同一列中的前驱结点，并让hl[p.j]指向它
	                                for (q = hl[p.j]; q && q.i < p.i; q = q.down) {
	                                    hl[p.j] = q;
	                                }
	                            }
	
	                            if (this.chead[p.j] == p) this.chead[p.j] = hl[p.j] = p.down;else hl[p.j].down = p.down;
	                        }
	
	                        pb = pb.right;
	                    }
	                }
	            }
	        }
	    }]);
	    return CrossList;
	}();
	
	exports.default = CrossList;
	
	
	var lists = [[1, 4, 5], [2, 2, -1], [1, 1, 3], [3, 1, 2]];
	var a = new CrossList();
	a.createSMatrix(4, 4, 4, lists);
	console.log(a);
	
	var lists2 = [[1, 4, -5], [2, 3, 1], [1, 1, 3], [3, 2, 2]];
	var b = new CrossList();
	b.createSMatrix(4, 4, 4, lists2);
	console.log(b);
	
	a.addMatrix(b);
	console.log(a);

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.RLSMatrix = exports.TSMatrix = undefined;
	
	var _getPrototypeOf = __webpack_require__(26);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(28);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(27);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 系数矩阵的三元组顺序表存储表示
	 */
	
	var Triple = function Triple(i, j, elem) {
	    (0, _classCallCheck3.default)(this, Triple);
	
	    // 该非零元的行下标和列下标
	    this.i = i || 0;
	    this.j = j || 0;
	    this.e = elem || null;
	};
	
	var TSMatrix = exports.TSMatrix = function () {
	    function TSMatrix(mu, nu) {
	        (0, _classCallCheck3.default)(this, TSMatrix);
	
	        // 非零元三元组表
	        this.data = [];
	        // 矩阵的行数，列数
	        this.mu = mu || 0;
	        this.nu = nu || 0;
	    }
	
	    (0, _createClass3.default)(TSMatrix, [{
	        key: 'addTriple',
	        value: function addTriple(triple) {
	            if (triple instanceof Triple) {
	                if (triple.i >= this.mu) this.mu = triple.i + 1;
	                if (triple.j >= this.nu) this.nu = triple.j + 1;
	
	                this.data.push(triple);
	                return true;
	            }
	            return false;
	        }
	        // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	        // 按照b.data中三元组的次序依次在a.data中找到相应的三元组进行转置
	
	    }, {
	        key: 'transposeSMatrix',
	        value: function transposeSMatrix() {
	            var t = new TSMatrix();
	            t.mu = this.nu;
	            t.nu = this.mu;
	
	            if (this.data.length) {
	                var q = 0;
	                for (var col = 0; col < this.nu; col++) {
	                    for (var p = 0; p < this.data.length; p++) {
	                        if (this.data[p].j === col) t.data[q++] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                    }
	                }
	            }
	
	            return t;
	        }
	        // 采用三元组表存储表示，求稀疏矩阵的转置矩阵t
	        /*
	         按照a.data中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置。
	         如果能预先确定矩阵M中每一列（即T中每一行）的第一个非零元在b.data中应有的位置，
	         那么在对a.data中的三元组依次做转置时，便可直接放到b.data中恰当的位置上去。
	         为了其额定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在b.data中应有的位置。
	         在此，需要设num和cpot两个变量。num[col]表示矩阵M中第col列中非零元的个数，
	         cpot[col]指示M中第col列的第一个非零元在b.data中的恰当位置。显然有：
	         cpot[0] = 1;
	         cpot[col] = cpot[col - 1] + num[col - 1]    2 <= col <= a.nu
	         */
	
	    }, {
	        key: 'fastTransposeSMatrix',
	        value: function fastTransposeSMatrix() {
	            var t = new TSMatrix();
	            t.mu = this.nu;
	            t.nu = this.mu;
	
	            if (this.data.length) {
	                var num = [];
	                for (var col = 0; col < this.nu; col++) {
	                    num[col] = 0;
	                }for (var i = 0; i < this.data.length; i++) {
	                    ++num[this.data[i].j];
	                } // 求矩阵中每一列含非零元个数
	                // 求第col列中第一个非零元在b.data中的序号
	                var cpot = [0];
	                for (var _col = 1; _col < this.nu; _col++) {
	                    // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                    cpot[_col] = cpot[_col - 1] + num[_col - 1];
	                }for (var p = 0; p < this.data.length; p++) {
	                    var _col2 = this.data[p].j;
	                    var q = cpot[_col2];
	                    t.data[q] = new Triple(this.data[p].j, this.data[p].i, this.data[p].e);
	                    // 给该列的序号+1，用作相同列数的情况
	                    ++cpot[_col2];
	                }
	            }
	
	            return t;
	        }
	    }]);
	    return TSMatrix;
	}();
	
	var a1 = new Triple(1, 2, 12);
	var a2 = new Triple(1, 3, 9);
	var a3 = new Triple(3, 1, -3);
	var a4 = new Triple(3, 6, 14);
	var a5 = new Triple(4, 3, 24);
	var a6 = new Triple(5, 2, 18);
	var a7 = new Triple(6, 1, 15);
	var a8 = new Triple(6, 4, -7);
	
	var matrix = new TSMatrix();
	matrix.addTriple(a1);
	matrix.addTriple(a2);
	matrix.addTriple(a3);
	matrix.addTriple(a4);
	matrix.addTriple(a5);
	matrix.addTriple(a6);
	matrix.addTriple(a7);
	matrix.addTriple(a8);
	
	console.log(matrix.transposeSMatrix());
	console.log(matrix.fastTransposeSMatrix());
	
	/*
	 三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。
	 然而，若需按行号存取某一行的非零元，则从头开始进行查找。
	 */
	
	/**
	 * 行逻辑链接的顺序表
	 *
	 * 为了便于随机存取任意一行的非零元，则需知道每一行的第一个非零元在三元组表中的位置。
	 * 为此可将快速转置矩阵的算法中创建的，指示“行”信息的辅助数组cpot固定在稀疏矩阵的存储结构中。
	 * 称这种“带行链接信息”的三元组表为行逻辑链接的顺序表
	 */
	
	var RLSMatrix = exports.RLSMatrix = function (_TSMatrix) {
	    (0, _inherits3.default)(RLSMatrix, _TSMatrix);
	
	    function RLSMatrix() {
	        (0, _classCallCheck3.default)(this, RLSMatrix);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RLSMatrix).apply(this, arguments));
	
	        _this.rpos = [0];
	        return _this;
	    }
	    /**
	     * 求矩阵乘积Q = M * N，采用行逻辑链接存储表示
	     * @param nMatrix
	     * @returns {RLSMatrix}
	     */
	
	
	    (0, _createClass3.default)(RLSMatrix, [{
	        key: 'multSMatrix',
	        value: function multSMatrix(nMatrix) {
	            if (this.nu !== nMatrix.mu) throw Error('nu is not equivalent to mu');
	
	            // 初始化Q
	            var qMatrix = new RLSMatrix(this.mu, nMatrix.nu);
	            // Q是非零矩阵
	            if (this.data.length * nMatrix.data.length !== 0) {
	                // 处理M的每一行
	                for (var arow = 0; arow < this.mu; arow++) {
	                    // 当前行各元素累加器清零
	                    var ctemp = [];
	                    qMatrix.rpos[arow] = qMatrix.data.length + 1;
	                    var tp = void 0,
	                        ccol = void 0;
	
	                    if (arow < this.mu) tp = this.rpos[arow + 1];else tp = this.data.length + 1;
	
	                    //对当前行中每一个非零元找到对应元在N中的行号
	                    for (var p = this.rpos[arow]; p < tp; p++) {
	                        var brow = this.data[p].j;
	                        var t = void 0;
	                        if (brow < nMatrix.mu) t = nMatrix.rpos[brow + 1];else t = nMatrix.data.length + 1;
	
	                        for (var q = nMatrix.rpos[brow]; q < t; q++) {
	                            // 乘积元素在Q中的序号
	                            ccol = nMatrix.data[q].j;
	                            ctemp[ccol] = (ctemp[ccol] || 0) + this.data[p].e * nMatrix.data[q].e;
	                        }
	                    }
	
	                    // 压缩存储该行非零元
	                    for (ccol = 1; ccol < qMatrix.nu; ccol++) {
	                        if (ctemp[ccol]) {
	                            if (++qMatrix.data.length > RLSMatrix.MAXSIZE) throw Error('overflow');
	                            qMatrix.data[qMatrix.data.length - 1] = new Triple(arow, ccol, ctemp[ccol]);
	                        }
	                    }
	                }
	            }
	
	            return qMatrix;
	        }
	    }, {
	        key: '_calcPos',
	        value: function _calcPos() {
	            var num = [];
	            for (var col = 0; col < this.nu; col++) {
	                num[col] = 0;
	            }for (var i = 0; i < this.data.length; i++) {
	                ++num[this.data[i].j];
	            } // 求矩阵中每一列含非零元个数
	            // 求第col列中第一个非零元在b.data中的序号
	            for (var _col3 = 1; _col3 < this.nu; _col3++) {
	                // 上一列之前的序号+上一列的非零元个数 = 该列的序号
	                this.rpos[_col3] = this.rpos[_col3 - 1] + num[_col3 - 1];
	            }
	        }
	    }]);
	    return RLSMatrix;
	}(TSMatrix);
	
	RLSMatrix.MAXSIZE = 100;
	
	var b1 = new Triple(1, 1, 3);
	var b2 = new Triple(1, 3, 5);
	var b3 = new Triple(2, 2, -1);
	var b4 = new Triple(3, 1, 2);
	
	var t1 = new RLSMatrix();
	t1.addTriple(b1);
	t1.addTriple(b2);
	t1.addTriple(b3);
	t1.addTriple(b4);
	t1._calcPos();
	
	var c1 = new Triple(1, 2, 2);
	var c2 = new Triple(2, 1, 1);
	var c3 = new Triple(3, 1, -2);
	var c4 = new Triple(3, 2, 4);
	
	var t2 = new RLSMatrix();
	t2.addTriple(c1);
	t2.addTriple(c2);
	t2.addTriple(c3);
	t2.addTriple(c4);
	t2._calcPos();
	
	t1.multSMatrix(t2);

/***/ },
/* 70 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.huffManCoding = huffManCoding;
	/**
	 * 赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树，有着广泛应用。
	 *
	 * 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
	 * 树的路径长度是从树根到每一个结点的路径之和。
	 * 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。
	 *
	 * 构造赫夫曼树的步骤：
	 * （1）根据给定的n个权值{w1,w2,...wn}构成n棵二叉树的集合F = {T1,T2,...Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
	 * （2）在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
	 * （3）在F中删除这两棵树，同时将新得到的二叉树加入F中。
	 * （4）重复（2）和（3），直到F只含一棵树为止。这棵树便是赫夫曼树。
	 */
	/*
	赫夫曼编码
	http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81
	
	假设电报需传送的电文为“A B A C C D A”，它只有4种字符只需两个字符串便可分辨。假设A,B,C,D的编码分别为00,01,10和11，则上述7个字符的电文便为“00010010101100”，对方接收时，可按二位一分进行译码。
	在传送电文时，希望总长尽可能地短。如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便可减少。
	如果涉及A,B,C,D的编码分别为0,00,1和01，则上述7个字符的电文可转换成总长为9的字符串“000011010”。但是，这样的电文无法翻译，因为可有多种译法。
	因此，若要设计长短不等的编码，则必须是任意个字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码。
	可利用二叉树来设计二进制的前缀编码。假设有一棵二叉树，其4个叶子结点分别表示A,B,C,D这4个字符，且约定左分支表示字符“0”，右分支表示字符“1”，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。所得二进制前缀编码分别为0,10,110,111.
	设计电文总长最短的二进制前缀编码即以n种字符出现的频率作权。
	 */
	
	// 赫夫曼树和赫夫曼编码的存储结构
	function HuffmanNode(weight, parent, leftChild, rightChild) {
	    this.weight = weight || 0;
	    this.parent = parent || 0;
	    this.leftChild = leftChild || 0;
	    this.rightChild = rightChild || 0;
	}
	function huffManCoding(weights) {
	    var n = weights.length;
	    if (n < 1) return;
	
	    var huffmanTree = buildHuffmanTree(weights, n);
	
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = calcHuffmanCode(huffmanTree, n);
	
	    return [huffmanTree, hc];
	}
	
	function calcHuffmanCode(huffmanTree, n) {
	    // 从叶子到根逆向求每个字符的赫夫曼编码
	    var hc = [];
	    var cd = [];
	    for (var i = 0; i < n; i++) {
	        var start = n - 1;
	        for (var c = i, f = huffmanTree[i].parent; f != 0; c = f, f = huffmanTree[f].parent) {
	            if (huffmanTree[f].leftChild == c) cd[--start] = '0';else cd[--start] = '1';
	        }
	
	        hc[i] = strCopy(cd, start);
	    }
	
	    return hc;
	}
	
	// 创建一棵叶子结点数为n的Huffman树
	function buildHuffmanTree(weights, n) {
	    n = n || weights.length;
	    var m = 2 * n - 1;
	    var huffmanTree = [];
	
	    // 初始化
	    var i = void 0;
	    for (i = 0; i < n; i++) {
	        huffmanTree[i] = new HuffmanNode(weights[i], 0, 0, 0);
	    }for (; i < m; i++) {
	        huffmanTree[i] = new HuffmanNode(0, 0, 0, 0);
	    }for (var _i = n; _i < m; _i++) {
	        // 在HT[1..i-1]选择parent为0且weight最小的两个结点，返回其序号为[s1, s2]
	        var ret = select(huffmanTree, _i);
	        var s1 = ret[0];
	        var s2 = ret[1];
	        huffmanTree[s1].parent = _i;
	        huffmanTree[s2].parent = _i;
	        huffmanTree[_i].leftChild = s1;
	        huffmanTree[_i].rightChild = s2;
	        huffmanTree[_i].weight = huffmanTree[s1].weight + huffmanTree[s2].weight;
	    }
	
	    return huffmanTree;
	}
	
	function strCopy(str, start) {
	    var s = '';
	    for (; str[start]; start++) {
	        s += str[start];
	    }
	    return s;
	}
	
	function select(huffmanTree, len) {
	    var ret = [];
	    for (var i = 0; i < len; i++) {
	        var node = huffmanTree[i];
	        if (node.parent !== 0) continue;
	
	        if (ret.length < 2) {
	            ret.push(i);
	        } else {
	            var index = huffmanTree[ret[0]].weight > huffmanTree[ret[1]].weight ? 0 : 1;
	
	            if (node.weight < huffmanTree[ret[index]].weight) ret[index] = i;
	        }
	    }
	
	    if (ret[0] > ret[1]) {
	        var temp = ret[0];
	        ret[0] = ret[1];
	        ret[1] = temp;
	    }
	
	    return ret;
	}
	
	console.log('-------huffman coding 1:------');
	console.log(huffManCoding([5, 29, 7, 8, 14, 23, 3, 11]));

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(52);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 广义表
	 *
	 * 广义表是线性表的推广。广泛用于人工智能的表处理语言Lisp，把广义表作为基本的数据结构。
	 * 广义表一般记作：
	 *      LS = (a1, a2, ..., an)
	 * LS是广义表的名称，n是它的长度，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头，称其余元素组成的表(a2, a3, ..., an)是LS的表尾。
	 *
	 * 下面列举一些广义表的例子：
	 * 1.A = () ---- A是一个空表，它的长度为0。
	 * 2.B = (e) ---- 列表B只有一个原子e，B的长度为1。
	 * 3.C = (a, (b, c, d)) ---- 列表C的长度为2，两个元素分别为原子a和子表(b, c, d)。
	 * 4.D = (A, B, C) ---- 列表D的长度为3,3个元素都是列表。显示，将子表的值代入后，则有D = ((), (e), (a, (b, c, d)))。
	 * 5.E = (a, E) ---- 这是一个递归的表，它的长度为2.E相当于一个无限的列表E = (a, (a, (a, ...)))。
	 *
	 * 1）列表的元素可以是子表，而子表的元素还可以是子表。由此，列表是一个多层次的结构，可以用图形象地表示。
	 * 2)列表可为其它列表所共享。列表A，B和C为D的子表，则在D中可以不必列出子表的值。
	 * 3）列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如列表E。
	 *
	 * 任何一个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。
	 *
	 */
	
	/*
	 广义表的递归算法
	
	 递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。
	
	 由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，应注意：
	 （1）首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的字问题，只要接口一致，便可进行递归调用。
	 （2）对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。
	 */
	
	/*
	 求广义表的深度
	
	 广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。
	 设非空广义表为:
	 LS = (a1, a2, ..., an)
	
	 其中ai(i = 1, 2, ..., n)或为原子或为LS的子表，则求LS的深度可分解为n个子问题，每个子问题为求ai的深度，若ai是原子，则由定义其深度为零，若ai是广义表，则递归处理，而LS的深度为各ai(i = 1, 2, ..., n)的深度最大值加1.空表也是广义表，且深度为1.
	
	 广义表的深度DEPTH(LS)的递归定义为：
	 基本项：    DEPTH(LS) = 1   当LS为空表时
	 DEPTH(LS) = 0   当LS为原子时
	 归纳项：    DEPTH(LS) = 1 + MAX{DEPTH(ai)}  1 <= i <= n
	 */
	
	var ATOM = (0, _symbol2.default)();
	var LIST = (0, _symbol2.default)();
	
	var global = Function('return this')();
	// 使用链队列
	
	
	// 广义表的头尾链表存储表示
	
	var GLNode = function () {
	    function GLNode() {
	        (0, _classCallCheck3.default)(this, GLNode);
	
	        // 公共部分，用于区分原子结点和表结点
	        this.tag = undefined;
	
	        // atom是原子结点的值域
	        this.atom = null;
	        // ptr是表结点的指针域
	        this.ptr = {
	            // ptr.hp和ptr.tp分别指向表头和表尾
	            hp: null,
	            tp: null
	        };
	    }
	
	    // 采用头尾链表存储结构，求广义表的深度
	
	
	    (0, _createClass3.default)(GLNode, [{
	        key: 'depth',
	        value: function depth() {
	            return getDepth(this);
	        }
	
	        // 复制广义表
	
	    }, {
	        key: 'copyList',
	        value: function copyList(gList) {
	            gList.tag = this.tag;
	
	            if (this.tag === ATOM) {
	                gList.atom = this.atom;
	            } else {
	                if (this.ptr.hp) {
	                    gList.ptr.hp = new GLNode();
	                    this.ptr.hp.copyList(gList.ptr.hp);
	                }
	                if (this.ptr.tp) {
	                    gList.ptr.tp = new GLNode();
	                    this.ptr.tp.copyList(gList.ptr.tp);
	                }
	            }
	        }
	
	        // 采用头尾链表存储结构，由广义表的书写形式串创建广义表
	
	    }, {
	        key: 'createGList',
	        value: function createGList(string) {
	            string = string.trim();
	
	            // 创建单原子广义表
	            var q = void 0;
	            if (isWord(string)) {
	                this.tag = ATOM;
	                this.atom = string;
	            } else {
	                this.tag = LIST;
	                var p = this;
	
	                // 脱外层括号
	                var sub = string.substr(1, string.length - 2);
	
	                do {
	                    var hsub = void 0;
	                    var n = sub.length;
	                    var i = 0;
	                    var k = 0;
	                    var ch = void 0;
	
	                    do {
	                        ch = sub[i++];
	                        if (ch == '(') ++k;else if (ch == ')') --k;
	                    } while (i < n && (ch != ',' || k != 0));
	
	                    // i为第一个逗号分隔索引
	                    if (i < n) {
	                        hsub = sub.substr(0, i - 1);
	                        sub = sub.substr(i, n - i);
	
	                        // 最后一组
	                    } else {
	                            hsub = sub;
	                            sub = '';
	                        }
	
	                    if (hsub === '()') p.ptr.hp = null;
	                    // 创建表头结点
	                    else {
	                            p.ptr.hp = new GLNode();
	                            p.ptr.hp.createGList(hsub);
	                        }
	
	                    q = p;
	
	                    // 创建表尾结点
	                    if (sub) {
	                        p = new GLNode();
	                        p.tag = LIST;
	                        q.ptr.tp = p;
	                    }
	                } while (sub);
	
	                q.ptr.tp = null;
	            }
	        }
	    }, {
	        key: 'reverse',
	
	
	        // 递归逆转广义表
	        value: function reverse() {
	            var ptr = [];
	            // 当A不为原子且表尾非空时才需逆转
	            if (this.tag === LIST && this.ptr.tp) {
	                var i = 0;
	                for (var p = this; p; p = p.ptr.tp, i++) {
	                    // 逆转各子表
	                    if (p.ptr.hp) p.ptr.hp.reverse();
	
	                    ptr[i] = p.ptr.hp;
	                }
	
	                // 重新按逆序排列各子表的顺序
	                for (var _p = this; _p; _p = _p.ptr.tp) {
	                    _p.ptr.hp = ptr[--i];
	                }
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	            if (this == global || this == null) str = '()';else if (this.tag === ATOM) str = this.atom; // 原子
	            else {
	                    str += '(';
	
	                    for (var p = this; p; p = p.ptr.tp) {
	                        str += this.toString.call(p.ptr.hp);
	                        if (p.ptr.tp) str += ', ';
	                    }
	                    str += ')';
	                }
	
	            return str;
	        }
	
	        // 按层序输出广义表
	        // 层序遍历的问题，一般都是借助队列来完成的，每次从队头
	        // 取出一个元素的同时把它下一层的孩子插入队尾，这是层序遍历的基本思想
	
	    }, {
	        key: 'orderPrint',
	        value: function orderPrint() {
	            var queue = [];
	            for (var p = this; p; p = p.ptr.tp) {
	                queue.push(p);
	            }while (queue.length) {
	                var r = queue.shift();
	                if (r.tag === ATOM) console.log(r.atom);else {
	                    for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                        queue.push(r);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'orderPrint2',
	        value: function orderPrint2() {
	            var queue = new _Queue2.default();
	
	            for (var p = this; p; p = p.ptr.tp) {
	                queue.enQueue(p);
	            }while (queue.size) {
	                var r = queue.deQueue();
	                if (r.tag === ATOM) console.log(r.atom);else {
	                    for (r = r.ptr.hp; r; r = r.ptr.tp) {
	                        queue.enQueue(r);
	                    }
	                }
	            }
	        }
	    }], [{
	        key: 'equal',
	        value: function equal(gList1, gList2) {
	            // 空表时相等的
	            if (!gList1 && !gList2) return true;
	            if (gList1.tag === ATOM && gList2.tag === ATOM && gList1.atom === gList2.atom) return true;
	
	            if (gList1.tag === LIST && gList2.tag === LIST) {
	                // 表头表尾都相等
	                if (this.equal(gList1.ptr.hp, gList2.ptr.hp) && this.equal(gList1.ptr.tp, gList2.ptr.tp)) return true;
	            }
	
	            return false;
	        }
	    }]);
	    return GLNode;
	}();
	
	// 广义表的扩展线性链表存储表示
	
	
	exports.default = GLNode;
	
	var GLNode2 = function GLNode2() {
	    (0, _classCallCheck3.default)(this, GLNode2);
	
	    // 公共部分，用于区分原子结点和表结点
	    this.tag = undefined;
	
	    // 原子结点的值域
	    this.atom = null;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性链表的next，指向下一个元素结点
	    this.tp = null;
	};
	
	function getDepth(gList) {
	    if (!gList) return 1;else if (gList.tag === ATOM) return 0;
	
	    var m = getDepth(gList.ptr.hp) + 1;
	    var n = getDepth(gList.ptr.tp);
	
	    return m > n ? m : n;
	}
	
	function isWord(str) {
	    return (/^[\w-]+$/.test(str)
	    );
	}
	
	/*
	 m元多项式表示
	
	 如果用线性表来表示,则每个数据元素需要m+1个数据项，以存储一个系数和m个指数值，这将产生两个问题。
	 一是无论多项式中各项的变元数是多是少，若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便。二是对m值不同的多项式，线性表中的结点大小也不同，这同样引起存储管理的不便。
	 故不适于用线性表表示。
	
	 例如三元多项式：
	 P(x, y, z) = x(10)y(3)z(2) + 2x(6)y(3)z(2) + 3x(5)y(2)z(2) + x(4)y(4)z + 2yz + 15
	
	 如若改写为：
	 P(x, y, z) = ((x(10) + 2x(6))y(3) + 3x(5)y(2))z(2) + ((x(4) + 6x(3))y(4) + 2y)z + 15
	
	 用广义表表示：
	 P = z((A, 2), (B, 1), (15, 0))
	 A = y((C, 3), (D, 2))
	 B = y((E, 4), (F, 1))
	 C = x((1, 10), (2, 6))
	 D = x((3, 5))
	 E = x((1, 4), (6, 3))
	 F = x((2, 0))
	
	
	 */
	
	function MPNode() {
	    // 区分原子结点和表结点
	    this.tag = undefined;
	    // 指数域
	    this.exp = 0;
	
	    // 系数域
	    this.coef = 0;
	    // 表结点的表头指针
	    this.hp = null;
	
	    // 相当于线性表的next，指向下一个元素结点
	    this.tp = null;
	}

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 邻接多重表
	
	 邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。
	
	 邻接表是无向图的一种有效的存储结构，在无向图的邻接表中，一条边(v,w)的两个表结点分别初选在以v和w为头结点的链表中，很容易求得顶点和边的信息，但在涉及到边的操作会带来不便。
	
	 邻接多重表的结构和十字链表类似，每条边用一个结点表示；邻接多重表中的顶点结点结构与邻接表中的完全相同，而表结点包括六个域。
	
	 ◆  Data域：存储和顶点相关的信息；
	 ◆ 指针域firstedge：指向依附于该顶点的第一条边所对应的表结点；
	 ◆ 标志域mark：用以标识该条边是否被访问过；
	 ◆ ivex和jvex域：分别保存该边所依附的两个顶点在图中的位置；
	 ◆ info域：保存该边的相关信息；
	 ◆ 指针域ilink：指向下一条依附于顶点ivex的边；
	 ◆ 指针域jlink：指向下一条依附于顶点jvex的边；
	
	 邻接多重表与邻接表的区别：
	 后者的同一条边用两个表结点表示，而前者只用一个表结点表示；除标志域外，邻接多重表与邻接表表达的信息是相同的，因此，操作的实现也基本相似。
	
	 */
	
	var UNVISITED = 0;
	var VISITED = 1;
	
	var EBox =
	/**
	 * 边的结点表示
	 * @param {Number} mark 访问标记 0 -- 未访问  1 == 已访问
	 * @param {Number} ivex 该边依附的两个顶点的位置
	 * @param {Number} jvex 该边依附的两个顶点的位置
	 * @param {EBox} ilink 分别指向依附这两个顶点的下一条边
	 * @param {EBox} jlink 分别指向依附这两个顶点的下一条边
	 * @param {*} info 该边信息
	 * @constructor
	 */
	function EBox(mark, ivex, jvex, ilink, jlink, info) {
	    (0, _classCallCheck3.default)(this, EBox);
	
	    this.mark = mark || UNVISITED;
	    this.ivex = ivex || 0;
	    this.jvex = jvex || 0;
	    this.ilink = ilink || null;
	    this.jlink = jlink || null;
	    this.info = info || null;
	};
	
	var AMLVexBox =
	/**
	 * 顶点的结点表示
	 * @param {*} data
	 * @param {EBox} firstEdge 指向第一条依附该顶点的边
	 * @constructor
	 */
	function AMLVexBox(data, firstEdge) {
	    (0, _classCallCheck3.default)(this, AMLVexBox);
	
	    this.data = data || null;
	    this.firstEdge = firstEdge || null;
	};
	
	var AMLGraph = function () {
	    /**
	     *
	     * @param {Array | AMLVexBox} adjMulist
	     * @param {Number} vexnum
	     * @param {Number} edgenum
	     * @constructor
	     */
	
	    function AMLGraph(adjMulist, vexnum, edgenum) {
	        (0, _classCallCheck3.default)(this, AMLGraph);
	
	        this.adjMulist = adjMulist || [];
	        this.vexnum = vexnum || 0;
	        this.edgenum = edgenum || 0;
	    }
	
	    (0, _createClass3.default)(AMLGraph, [{
	        key: 'locateVex',
	        value: function locateVex(v) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.adjMulist[i].data === v) return i;
	            }
	            return -1;
	        }
	    }, {
	        key: 'deleteArc',
	        value: function deleteArc(v, w) {
	            var i = this.locateVex(v);
	            var j = this.locateVex(w);
	
	            if (i < 0 || j < 0) throw new Error('Vertex not found!');
	
	            var p;
	            // 在i链表中删除该边
	            if (this.adjMulist[i].firstEdge.jvex === j) {
	                this.adjMulist[i].firstEdge = this.adjMulist[i].firstEdge.ilink;
	            } else {
	                for (p = this.adjMulist[i].firstEdge; p && p.ilink.jvex !== j; p = p.ilink) {}
	                if (!p) throw new Error('edge not found!');
	                p.ilink = p.ilink.ilink;
	            }
	
	            // 在j链表中删除该边
	            if (this.adjMulist[j].firstEdge.ivex === i) {
	                this.adjMulist[j].firstEdge = this.adjMulist[j].firstEdge.jlink;
	            } else {
	                for (p = this.adjMulist[j].firstEdge; p && p.jlink.ivex !== i; p = p.jlink) {}
	                if (!p) throw new Error('edge not found!');
	                p.jlink = p.jlink.jlink;
	            }
	
	            this.edgenum--;
	            return true;
	        }
	    }, {
	        key: 'createGraph',
	        value: function createGraph() {
	            var vexnum = +prompt('vexnum: ');
	            this.vexnum = vexnum;
	            var edgenum = +prompt('edgenum: ');
	            this.edgenum = edgenum;
	
	            for (var m = 0; m < vexnum; ++m) {
	                this.adjMulist[m] = new AMLVexBox(prompt('data: '), null);
	            }
	
	            for (m = 0; m < edgenum; ++m) {
	                var t = prompt('tailVex: ');
	                var h = prompt('headVex: ');
	                var i = this.locateVex(t);
	                var j = this.locateVex(h);
	
	                if (i < 0 || j < 0) {
	                    console.error('vertex not found! Try again:');
	                    m--;
	                    continue;
	                }
	
	                var p = new EBox(0, i, j, null, null);
	                var q, r;
	
	                // 插入i链表尾部
	                if (!this.adjMulist[i].firstEdge) {
	                    this.adjMulist[i].firstEdge = p;
	                } else {
	                    q = this.adjMulist[i].firstEdge;
	                    while (q) {
	                        r = q;
	                        if (q.ivex === i) q = q.ilink;else q = q.jlink;
	                    }
	                    if (r.ivex === i) r.ilink = p;else r.jlink = p;
	                }
	
	                // 插入j链表尾部
	                if (!this.adjMulist[j].firstEdge) {
	                    this.adjMulist[j].firstEdge = p;
	                } else {
	                    q = this.adjMulist[j].firstEdge;
	                    while (q) {
	                        r = q;
	                        if (q.jvex === j) q = q.jlink;else q = q.ilink;
	                    }
	                    if (r.jvex === j) r.jlink = p;else r.ilink = p;
	                }
	            }
	        }
	    }]);
	    return AMLGraph;
	}();
	
	//var g = new AMLGraph();
	//g.createGraph();
	//console.log(g);
	
	
	exports.default = AMLGraph;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(16);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(15);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* Create By Luke */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	/*
	 邻接链表法
	
	 基本思想：对图的每个顶点建立一个单链表，存储该顶点所有邻接顶点及其相关信息。每一个单链表设一个表头结点。
	
	 第i个单链表表示依附于顶点Vi的边(对有向图是以顶点Vi为头或尾的弧)。
	
	 1  结点结构与邻接链表示例
	
	 链表中的结点称为表结点，每个结点由三个域组成。其中邻接点域(adjvex)指示与顶点Vi邻接的顶点在图中的位置(顶点编号)，链域(nextarc)指向下一个与顶点Vi邻接的表结点，数据域(info)存储和边或弧相关的信息，如权值等。对于无权图，如果没有与边相关的其他信息，可省略此域。
	
	 每个链表设一个表头结点(称为顶点结点)，由两个域组成。链域(firstarc)指向链表中的第一个结点，数据域(data) 存储顶点名或其他信息。
	
	 在图的邻接链表表示中，所有顶点结点用一个向量 以顺序结构形式存储，可以随机访问任意顶点的链表，该向量称为表头向量，向量的下标指示顶点的序号。
	
	 用邻接链表存储图时，对无向图，其邻接链表是唯一的；对有向图，其邻接链表有两种形式。
	
	
	 2  邻接表法的特点
	
	 ◆ 表头向量中每个分量就是一个单链表的头结点，分量个数就是图中的顶点数目；
	 ◆ 在边或弧稀疏的条件下，用邻接表表示比用邻接矩阵表示节省存储空间；
	 ◆ 在无向图，顶点Vi的度是第i个链表的结点数；
	 ◆ 对有向图可以建立正邻接表或逆邻接表。正邻接表是以顶点Vi为出度(即为弧的起点)而建立的邻接表；逆邻接表是以顶点Vi为入度(即为弧的终点)而建立的邻接表；
	 ◆ 在有向图中，第i个链表中的结点数是顶点Vi的出 (或入)度；求入 (或出)度，须遍历整个邻接表；
	 ◆ 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点；
	
	 */
	
	var ArcNode =
	/**
	 *
	 * @param {Number} adjVex
	 * @param {ArcNode} nextArc
	 * @param {*} info
	 * @constructor
	 */
	function ArcNode() {
	    var adjVex = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var nextArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	    (0, _classCallCheck3.default)(this, ArcNode);
	
	    // 该弧所指向的顶点的位置
	    this.adjVex = adjVex;
	    // 指向下一条弧的指针
	    this.nextArc = nextArc;
	    // 该弧相关信息的指针
	    this.info = info;
	};
	
	var VexNode =
	/**
	 *
	 * @param {*} data
	 * @param {ArcNode} firstArc
	 * @param {Number} indegree
	 * @constructor
	 */
	function VexNode(data) {
	    var firstArc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var indegree = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    (0, _classCallCheck3.default)(this, VexNode);
	
	    // 顶点信息
	    this.data = data;
	    // 指向第一条依附该顶点的弧的指针
	    this.firstArc = firstArc;
	    //  顶点的度, 有向图是入度或出度或没有
	    this.indegree = indegree;
	};
	
	var AdjacencyListGraph = function () {
	    /**
	     *
	     * @param {Array | VexNode} vertices
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	
	    function AdjacencyListGraph() {
	        var vertices = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var vexnum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var arcnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var kind = arguments.length <= 3 || arguments[3] === undefined ? DG : arguments[3];
	        (0, _classCallCheck3.default)(this, AdjacencyListGraph);
	
	        this.vertices = vertices;
	        // 图的当前顶点数和弧数
	        this.vexnum = vexnum;
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    // 查找顶点位置
	
	
	    (0, _createClass3.default)(AdjacencyListGraph, [{
	        key: 'locateVex',
	        value: function locateVex(vp) {
	            for (var _i = 0; _i < this.vexnum; ++_i) {
	                if (this.vertices[_i].data === vp) return _i;
	            }
	
	            return -1;
	        }
	
	        // 添加顶点
	
	    }, {
	        key: 'addVertex',
	        value: function addVertex(vp) {
	            if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	            this.vertices[this.vexnum++] = new VexNode(vp, null, 0);
	            return this.vexnum;
	        }
	
	        /**
	         * 添加弧
	         * 如果是无向图或者无向网,arc1和arc2无顺序要求
	         * 如果是有向图或者有向网，只会添加arc1，因此正邻接表和逆邻接表的顺序需要注意
	         * @param {String} arc1
	         * @param {String} arc2
	         * @param {*} info
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'addArc',
	        value: function addArc(arc1, arc2, info) {
	            var k = this.locateVex(arc1);
	            var j = this.locateVex(arc2);
	
	            if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	            // 边的起始表结点赋值
	            var p = new ArcNode(k, null, info);
	            // 边的末尾表结点赋值
	            var q = new ArcNode(j, null, info);
	
	            // 是无向图，用头插入法插入到两个单链表
	            if (this.kind === UDG || this.kind === UDN) {
	                q.nextArc = this.vertices[k].firstArc;
	                this.vertices[k].firstArc = q;
	                p.nextArc = this.vertices[j].firstArc;
	                this.vertices[j].firstArc = p;
	            }
	            // 建立有向图的邻接链表，用头插入法
	            else {
	                    p.nextArc = this.vertices[j].firstArc;
	                    this.vertices[j].firstArc = p;
	                }
	
	            ++this.arcnum;
	
	            return true;
	        }
	
	        // TODO 其他图类型的创建暂时没弄
	
	    }, {
	        key: 'createGraph',
	        value: function createGraph() {
	            this.vexnum = +prompt('vexnum: ');
	            this.arcnum = +prompt('arcnum: ');
	            // incInfo为0则各弧不含其他信息
	            var incInfo = +prompt('incInfo: ');
	
	            for (var _m = 0; _m < this.vexnum; ++_m) {
	                this.vertices[_m] = new VexNode();
	                this.vertices[_m].data = prompt('vertex: ');
	            }
	
	            for (m = 0; m < this.arcnum; ++m) {
	                var h = prompt('弧头: ');
	                var t = prompt('弧尾: ');
	                var _i2 = this.locateVex(t);
	                var j = this.locateVex(h);
	
	                if (_i2 < 0 || j < 0) {
	                    alert('顶点为找到，请重新输入！');
	                    m--;
	                    continue;
	                }
	
	                var p = new ArcNode(j, null, incInfo && prompt('info: '));
	
	                if (!this.vertices[_i2].firstArc) this.vertices[_i2].firstArc = p;else {
	                    for (var _q = this.vertices[_i2].firstArc; _q.nextArc; _q = _q.nextArc) {}
	                    q.nextArc = p;
	                }
	            }
	        }
	
	        // 判断一个邻接表存储的有向图是否可传递
	
	    }, {
	        key: 'isPass',
	        value: function isPass() {
	            if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	            for (var x = 0; x < this.vexnum; ++x) {
	                for (var p = this.vertices[x].firstArc; p; p = p.nextArc) {
	                    var y = p.adjVex;
	                    for (var _q2 = this.vertices[y].firstArc; _q2; _q2 = _q2.nextArc) {
	                        var z = _q2.adjVex;
	                        if (z !== x && this.isAdj(x, z)) return false;
	                    }
	                }
	            }
	
	            return true;
	        }
	
	        // 判断有向图是否存在边(m,n)
	
	    }, {
	        key: 'isAdj',
	        value: function isAdj(m, n) {
	            for (var p = this.vertices[m].firstArc; p; p = p.nextArc) {
	                if (p.adjVex === n) return true;
	            }
	            return false;
	        }
	
	        /**
	         * 深度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	         * @param {String} i
	         * @param {String} j
	         */
	
	    }, {
	        key: 'exist_path_DFS',
	        value: function exist_path_DFS(i, j) {
	            var visited = [];
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	
	            if (i < 0 || j < 0) throw new Error('vertex not found!');
	
	            return exist_path(this, i, j);
	
	            function exist_path(graph, i, j) {
	                if (i === j) return true;
	
	                visited[i] = true;
	                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (!visited[k] && exist_path(graph, k, j)) return true;
	                }
	
	                return false;
	            }
	        }
	
	        /**
	         * 广度优先判断<b>有向图<b>的顶点i到顶点j是否有路径，实则返回true，否则返回false
	         * @param {String} i
	         * @param {String} j
	         */
	
	    }, {
	        key: 'exist_path_BFS',
	        value: function exist_path_BFS(i, j) {
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	            var visited = [];
	            var queue = new _Queue2.default();
	            queue.enQueue(i);
	
	            while (queue.rear) {
	                var u = queue.deQueue();
	                visited[u] = 1;
	
	                for (var p = this.vertices[i].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (k === j) return true;
	                    if (!visited[k]) queue.enQueue(k);
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * 判断邻接表方式存储的有向图的顶点i到j是否存在长度为k的简单路径
	         * @param {String} i
	         * @param {String} j
	         * @param {Number} k
	         */
	
	    }, {
	        key: 'exist_path_len',
	        value: function exist_path_len(i, j, k) {
	            i = this.locateVex(i);
	            j = this.locateVex(j);
	            var visited = [];
	
	            return function recurse(graph, i, j, k) {
	                // 找到了一条路径，且长度符合
	                if (i === j && k === 0) return true;else if (k > 0) {
	                    visited[i] = 1;
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        if (!visited[l]) {
	                            // 剩余路径长度减一
	                            if (recurse(graph, l, j, k - 1)) return true;
	                        }
	                    }
	                    // 允许曾经被访问过的结点出现在另一条路径上
	                    visited[i] = 0;
	                }
	
	                return false;
	            }(this, i, j, k);
	        }
	
	        /**
	         * 求有向图中顶点u到v之间的所有简单路径，k为当前路径长度
	         * @param {String} u
	         * @param {String} v
	         * @param {Number} k
	         *
	         * @example
	         *  graph.find_all_path('v1', 'v2', 0);
	         */
	
	    }, {
	        key: 'find_all_path',
	        value: function find_all_path(u, v, k) {
	            u = this.locateVex(u);
	            v = this.locateVex(v);
	            var path = [];
	            var visited = [];
	
	            findPath(this, u, v, k);
	
	            function findPath(graph, u, v, k) {
	                // 加入当前路径中
	                path[k] = u;
	                visited[u] = 1;
	
	                // 找到一条简单路径
	                if (u === v) {
	                    console.log('Found one path!');
	                    for (var _i3 = 0; path[_i3]; ++_i3) {
	                        console.log(path[_i3]);
	                    }
	                } else {
	                    for (var p = graph.vertices[u].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        // 继续寻找
	                        if (!visited[l]) findPath(graph, l, v, k + 1);
	                    }
	                }
	
	                visited[u] = 0;
	                // 回溯
	                path[k] = 0;
	            }
	        }
	
	        /**
	         * 求有向图的顶点之间长度为len的简单路径条数
	         * @param {String} i
	         * @param {String} j
	         * @param {Number} len
	         */
	
	    }, {
	        key: 'getPathNum_len',
	        value: function getPathNum_len(i, j, len) {
	            var visited = [];
	
	            return function recurse(graph, i, j, len) {
	                if (i === j && len === 0) return 1;else if (len > 0) {
	                    var sum = 0;
	                    visited[i] = 1;
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var l = p.adjVex;
	                        if (!visited[l]) sum += recurse(l, j, len - 1);
	                    }
	                    visited[i] = 0;
	                    return sum;
	                }
	            }(this, i, j, len);
	        }
	
	        /**
	         * 求有向无环图的根
	         */
	
	    }, {
	        key: 'getRoot',
	        value: function getRoot() {
	            var visited = [];
	
	            for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                // 每次都要将访问数组清零
	                for (var _w = 0; _w < this.vexnum; ++_w) {
	                    visited[_w] = false;
	                } // 从顶点i出发进行深度优先遍历
	                dfs(this, _i4);
	
	                var flag = true;
	                for (w = 0; w < this.vexnum; ++w) {
	                    // 如果i是根，则深度优先遍历可以访问到所有结点
	                    if (!visited[w]) flag = false;
	                }
	
	                if (flag) console.log('Found a root vertex: %d', _i4);
	            }
	
	            function dfs(graph, v) {
	                visited[v] = true;
	
	                for (var p = graph.vertices[v].firstArc; p; p = p.nextArc) {
	                    var _w2 = p.adjVex;
	                    if (!visited[_w2]) dfs(graph, _w2);
	                }
	            }
	        }
	
	        /**
	         * 求一个有向无环图中最长的路径
	         */
	
	    }, {
	        key: 'getLongestPath',
	        value: function getLongestPath() {
	            var mlp = [];
	            var path = [];
	            var visited = [];
	            var maxLen = 0;
	
	            this.countIndegree();
	
	            for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                for (var j = 0; j < this.vexnum; ++j) {
	                    visited[j] = false;
	                } // 从每一个零入度结点开始深度优先遍历
	                if (this.vertices[_i5].indegree === 0) dfs(this, _i5, 0);
	            }
	
	            console.log('Longest Path:');
	            // 输出最长路径
	            for (i = 0; mlp[i]; ++i) {
	                console.log(mlp.join(','));
	            }function dfs(graph, i, len) {
	                visited[i] = true;
	                path[len] = i;
	
	                // 新的最长路径
	                if (len > maxLen && !graph.vertices[i].firstArc) {
	                    // 保存下来
	                    for (var _j = 0; _j <= len; ++_j) {
	                        mlp[_j] = path[_j];
	                    }maxLen = len;
	                } else {
	                    for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
	                        var _w3 = p.adjVex;
	                        if (!visited[_w3]) dfs(graph, _w3, len + 1);
	                    }
	                }
	
	                path[i] = 0;
	                visited[i] = false;
	            }
	        }
	
	        // 邻接表的递归式深度优先遍历
	
	    }, {
	        key: 'DFSTraverse',
	        value: function DFSTraverse(visitFn) {
	            var visited = [];
	            for (var _i6 = 0; _i6 < this.vexnum; ++_i6) {
	                visited[_i6] = false;
	            }for (var _i7 = 0; _i7 < this.vexnum; ++_i7) {
	                if (!visited[_i7]) dfs(this, _i7);
	            }
	
	            function dfs(graph, v) {
	                visited[v] = true;
	                visitFn.call(graph, v);
	
	                var p = graph.vertices[v].firstArc;
	                while (p) {
	                    if (!visited[p.adjVex]) dfs(graph, p.adjVex);
	
	                    p = p.nextArc;
	                }
	            }
	        }
	
	        // 邻接表的非递归深度优先搜索
	
	    }, {
	        key: 'DFSTraverse_NonRecurse',
	        value: function DFSTraverse_NonRecurse(visitFn) {
	            var visited = [];
	            var stack = new _index2.default();
	            for (var _i8 = 0; _i8 < this.vexnum; ++_i8) {
	                visited[_i8] = false;
	            }for (var _i9 = 0; _i9 < this.vexnum; ++_i9) {
	                if (!visited[_i9]) {
	                    stack.push(_i9);
	                    visited[_i9] = true;
	                    visitFn.call(this, _i9);
	
	                    var v = void 0;
	                    while ((v = stack.peek()) != null) {
	                        var p = this.vertices[v].firstArc;
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                visitFn.call(this, p.adjVex);
	                                stack.push(p.adjVex);
	                            } else stack.pop();
	
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	        }
	
	        // 邻接表的广度优先搜索
	
	    }, {
	        key: 'BFSTraverse',
	        value: function BFSTraverse(visitFn) {
	            var queue = new _Queue2.default();
	            var visited = [];
	            for (var _i10 = 0; _i10 < this.vexnum; ++_i10) {
	                visited[_i10] = false;
	            }for (var _i11 = 0; _i11 < this.vexnum; ++_i11) {
	                if (!visited[_i11]) {
	                    queue.enQueue(_i11);
	                    visited[_i11] = true;
	                    visitFn.call(this, _i11);
	
	                    while (queue.rear) {
	                        var _w4 = queue.deQueue();
	                        var p = this.vertices[_w4].firstArc;
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                visitFn.call(this, p.adjVex);
	                                queue.enQueue(p.adjVex);
	                            }
	
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	        }
	
	        // 建立无向图的深度优先生成森林的孩子兄弟链表树
	
	    }, {
	        key: 'createDFSForest',
	        value: function createDFSForest() {
	            var tree = null;
	            var visited = [];
	            for (var _i12 = 0; _i12 < this.vexnum; ++_i12) {
	                visited[_i12] = false;
	            }var q = void 0;
	            for (var _i13 = 0; _i13 < this.vexnum; ++_i13) {
	                if (!visited[_i13]) {
	                    // 新的生成树的根结点
	                    var p = new _BinaryTree.ChildSiblingTree(this.vertices[_i13].data);
	
	                    // 第一棵生成树的根
	                    if (!tree) tree = p;
	                    // 其它生成树的根
	                    else q.nextSibling = p;
	
	                    // q为当前生成树的根
	                    q = p;
	                    // 建立以p为根的生成树
	                    DFSTree(this, _i13, p);
	                }
	            }
	
	            return tree;
	
	            // 以第v个顶点触发深度优先遍历图，建立以tree为根的生成树
	            function DFSTree(graph, v, tree) {
	                visited[v] = true;
	                var first = true;
	                var w = graph.vertices[v].firstArc;
	                var q = void 0;
	
	                while (w) {
	                    if (!visited[w.adjVex]) {
	                        visited[w.adjVex] = true;
	                        var _p = new _BinaryTree.ChildSiblingTree(graph.vertices[w.adjVex].data);
	
	                        // w是v的第一个未被访问的邻接结点
	                        if (first) {
	                            tree.firstChild = _p;
	                            first = false;
	                        }
	                        // w是v的其它未被访问的邻接顶点
	                        else q.nextSibling = _p;
	
	                        q = _p;
	
	                        DFSTree(graph, w.adjVex, q);
	                    }
	
	                    w = w.nextArc;
	                }
	            }
	        }
	    }, {
	        key: 'createBFSForest',
	        value: function createBFSForest() {
	            var tree = null;
	            var visited = [];
	            var queue = new _Queue2.default();
	            for (var _i14 = 0; _i14 < this.vexnum; ++_i14) {
	                visited[_i14] = false;
	            }var q = void 0;
	            for (var _i15 = 0; _i15 < this.vexnum; ++_i15) {
	                if (!visited[_i15]) {
	                    visited[_i15] = true;
	                    queue.enQueue(_i15);
	
	                    var node = new _BinaryTree.ChildSiblingTree(this.vertices[_i15].data);
	                    if (!tree) tree = node;else q.nextSibling = node;
	
	                    q = node;
	
	                    while (queue.rear) {
	                        var _w5 = queue.deQueue();
	                        var p = this.vertices[_w5].firstArc;
	                        var first = true;
	                        var pre = void 0;
	
	                        while (p) {
	                            if (!visited[p.adjVex]) {
	                                visited[p.adjVex] = true;
	                                queue.enQueue(p.adjVex);
	
	                                var node2 = new _BinaryTree.ChildSiblingTree(this.vertices[p.adjVex].data);
	
	                                if (first) {
	                                    node.firstChild = node2;
	                                    first = false;
	                                } else pre.nextSibling = node2;
	
	                                pre = node2;
	                            }
	                            p = p.nextArc;
	                        }
	                    }
	                }
	            }
	
	            return tree;
	        }
	    }, {
	        key: 'findArticul',
	        value: function findArticul() {
	            var visited = [];
	            var count = 1;
	            var low = [];
	            low[0] = count;
	            visited[0] = 1;
	            for (var _i16 = 1; _i16 < this.vexnum; ++_i16) {
	                visited[_i16] = 0;
	            }var p = this.vertices[0].firstArc;
	            var v = p.adjVex;
	
	            DFSArticul(this, v);
	            if (count < this.vexnum) {
	                console.log(0 + '  ' + this.vertices[0].data);
	                while (p.nextArc) {
	                    p = p.nextArc;
	                    v = p.adjVex;
	                    if (visited[v] === 0) DFSArticul(this, v);
	                }
	            }
	
	            function DFSArticul(graph, v0) {
	                var min = visited[v0] = ++count;
	                for (var _p2 = graph.vertices[v0].firstArc; _p2; _p2 = _p2.nextArc) {
	                    var _w6 = _p2.adjVex;
	                    if (visited[_w6] === 0) {
	                        DFSArticul(graph, _w6);
	                        if (low[_w6] < min) min = low[_w6];
	                        if (low[_w6] >= visited[v0]) console.log(v0 + '  ' + graph.vertices[v0].data);
	                    } else if (visited[_w6] < min) min = visited[_w6];
	                }
	                low[v0] = min;
	            }
	        }
	
	        // 统计各顶点入度的函数
	
	    }, {
	        key: 'countIndegree',
	        value: function countIndegree() {
	            for (var k = 0; k < this.vexnum; ++k) {
	                this.vertices[k].indegree = 0;
	            }for (var _k = 0; _k < this.vexnum; ++_k) {
	                for (var p = this.vertices[_k].firstArc; p; p = p.nextArc) {
	                    ++this.vertices[p.adjVex].indegree;
	                }
	            }
	        }
	
	        // 拓扑排序算法
	
	    }, {
	        key: 'topologicSort',
	        value: function topologicSort() {
	            var stack = new _index2.default();
	            this.topologicalOrder = [];
	            this.countIndegree();
	
	            for (var _i17 = 0; _i17 < this.vexnum; ++_i17) {
	                if (this.vertices[_i17].indegree === 0) stack.push(_i17);
	            }
	
	            var count = 0;
	            while (stack.length) {
	                var _i18 = stack.pop();
	                this.topologicalOrder.push(_i18);
	                console.log(this.vertices[_i18].data);
	                ++count;
	                for (var p = this.vertices[_i18].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (--this.vertices[k].indegree === 0) stack.push(k);
	                }
	            }
	
	            return count >= this.vexnum;
	        }
	
	        // 输出有向图的各项关键活动
	
	    }, {
	        key: 'criticalPath',
	        value: function criticalPath() {
	            if (!this.topologicSort()) throw new Error('AOE网中存在回路！');
	
	            var ve = [];
	            // 事件最早发生时间初始化
	            for (var j = 0; j < this.vexnum; ++j) {
	                ve[j] = 0;
	            } // 计算每个事件的最早发生时间ve值
	            for (var _m2 = 0; _m2 < this.vexnum; ++_m2) {
	                var _j2 = this.topologicalOrder[_m2];
	                for (var p = this.vertices[_j2].firstArc; p; p = p.nextArc) {
	                    var k = p.adjVex;
	                    if (ve[_j2] + p.info > ve[k]) ve[k] = ve[_j2] + p.info;
	                }
	            }
	            var vl = [];
	            // 事件最晚发生时间初始化
	            for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	                vl[_j3] = ve[this.vexnum - 1];
	            } // 计算每个事件的最晚发生时间vl的值
	            for (var _m3 = this.vexnum - 1; _m3 >= 0; --_m3) {
	                var _j4 = this.topologicalOrder[_m3];
	                for (var _p3 = this.vertices[_j4].firstArc; _p3; _p3 = _p3.nextArc) {
	                    var _k2 = _p3.adjVex;
	                    if (vl[_k2] - _p3.info < vl[_j4]) vl[_j4] = vl[_k2] - _p3.info;
	                }
	            }
	            // 输出所有关键活动
	            for (var _m4 = 0; _m4 < this.vexnum; ++_m4) {
	                for (var _p4 = this.vertices[_m4].firstArc; _p4; _p4 = _p4.nextArc) {
	                    var _k3 = _p4.adjVex;
	                    if (ve[_m4] + _p4.info === vl[_k3]) console.log('<%d, %d>', _m4, _k3);
	                }
	            }
	        }
	    }, {
	        key: 'shortestPath_Dijkstra',
	        value: function shortestPath_Dijkstra(v0) {
	            var dist = [];
	            var pre = [];
	            var final = [];
	            var w = void 0;
	
	            for (var _v = 0; _v < this.vexnum; ++_v) {
	                dist[_v] = Infinity;
	            }for (var p = this.vertices[v0].firstArc; p; p = p.nextArc) {
	                dist[p.adjVex] = p.info;
	            }var v = void 0;
	            for (v = 0; v < this.vexnum; ++v) {
	                final[v] = false;
	                pre[v] = pre[v] || [];
	                for (w = 0; w < this.vexnum; ++w) {
	                    pre[v][w] = false;
	                }if (dist[v] < Infinity) {
	                    pre[v][v0] = true;
	                    pre[v][v] = true;
	                }
	            }
	
	            dist[v0] = 0;
	            final[v0] = true;
	
	            for (var _i19 = 1; _i19 < this.vexnum; ++_i19) {
	                var min = Infinity;
	                for (w = 0; w < this.vexnum; ++w) {
	                    if (!final[w] && dist[w] < min) {
	                        v = w;
	                        min = dist[w];
	                    }
	                }
	
	                final[v] = true;
	
	                for (var _p5 = this.vertices[v].firstArc; _p5; _p5 = _p5.nextArc) {
	                    w = _p5.adjVex;
	                    if (!final[w] && min + _p5.info < dist[w]) {
	                        dist[w] = min + _p5.info;
	                        pre[w] = pre[v];
	                        pre[w][w] = true;
	                    }
	                }
	            }
	
	            console.log(final);
	            console.log(pre);
	            console.log(dist);
	
	            return {
	                final: final,
	                pre: pre,
	                dist: dist
	            };
	        }
	    }]);
	    return AdjacencyListGraph;
	}();
	
	// 无向图的邻接表
	
	
	exports.default = AdjacencyListGraph;
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v1', 'v2');
	adjListGraph.addArc('v1', 'v3');
	adjListGraph.addArc('v1', 'v4');
	adjListGraph.addArc('v2', 'v3');
	adjListGraph.addArc('v3', 'v4');
	adjListGraph.addArc('v3', 'v5');
	adjListGraph.addArc('v4', 'v5');
	
	console.log(adjListGraph);
	
	// 有向图的逆邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v1', 'v2');
	g.addArc('v1', 'v4');
	g.addArc('v3', 'v2');
	g.addArc('v3', 'v1');
	g.addArc('v4', 'v3');
	g.addArc('v3', 'v5');
	g.addArc('v5', 'v4');
	
	console.log(g);
	
	// 有向图的正邻接表
	var g = new AdjacencyListGraph([], 0, 0, DG);
	g.addVertex('v1');
	g.addVertex('v2');
	g.addVertex('v3');
	g.addVertex('v4');
	g.addVertex('v5');
	
	g.addArc('v2', 'v1');
	g.addArc('v4', 'v1');
	g.addArc('v2', 'v3');
	g.addArc('v1', 'v3');
	g.addArc('v3', 'v4');
	g.addArc('v5', 'v3');
	g.addArc('v4', 'v5');
	
	console.log(g);
	
	console.log('adjListGraph DFSTraverse: ');
	var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
	adjListGraph.addVertex('v1');
	adjListGraph.addVertex('v2');
	adjListGraph.addVertex('v3');
	adjListGraph.addVertex('v4');
	adjListGraph.addVertex('v5');
	
	adjListGraph.addArc('v5', 'v4');
	adjListGraph.addArc('v3', 'v2');
	adjListGraph.addArc('v2', 'v1');
	adjListGraph.addArc('v3', 'v1');
	
	adjListGraph.DFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph DFSTraverse_NonRecurse: ');
	adjListGraph.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('adjListGraph BFSTraverse: ');
	var g2 = new AdjacencyListGraph([], 0, 0, DG);
	g2.addVertex('v1');
	g2.addVertex('v2');
	g2.addVertex('v3');
	g2.addVertex('v4');
	g2.addVertex('v5');
	
	g2.addArc('v4', 'v1');
	g2.addArc('v2', 'v1');
	g2.addArc('v5', 'v3');
	g2.addArc('v2', 'v3');
	g2.addArc('v1', 'v3');
	g2.addArc('v3', 'v4');
	g2.addArc('v4', 'v5');
	
	g2.BFSTraverse(function (v) {
	    console.log(this.vertices[v].data);
	});
	
	console.log('DFS: expect false: ' + adjListGraph.exist_path_DFS('v1', 'v4'));
	console.log('DFS: expect true: ' + adjListGraph.exist_path_DFS('v1', 'v2'));
	
	console.log('BFS : expect false: ' + adjListGraph.exist_path_BFS('v1', 'v4'));
	console.log('BFS :expect true: ' + adjListGraph.exist_path_BFS('v1', 'v2'));
	
	/*
	 图的连通性问题
	
	 无向图的连通分量与生成树
	
	 1 无向图的连通分量和生成树
	 对于无向图，对其进行遍历时：
	 ◆ 若是连通图：仅需从图中任一顶点出发，就能访问图中的所有顶点；
	 ◆ 若是非连通图：需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集；
	
	 ⑴ 若G=(V,E)是无向连通图， 顶点集和边集分别是V(G) ，E(G) 。若从G中任意点出发遍历时， E(G)被分成两个互不相交的集合：
	 T(G) ：遍历过程中所经过的边的集合；
	 B(G) ：遍历过程中未经过的边的集合；
	 显然： E(G)=T(G)∪B(G) ，T(G)∩B(G)=Ø
	 显然，图G’=(V, T(G))是G的极小连通子图，且G’是一棵树。G’称为图G的一棵生成树。
	 从任意点出发按DFS算法得到生成树G’称为深度优先生成树；按BFS算法得到的G’称为广度优先生成树。
	
	 ⑵  若G=(V,E)是无向非连通图，对图进行遍历时得到若干个连通分量的顶点集：V1(G) ,V2(G) ,…,Vn(G)和相应所经过的边集：T1(G) ,T2(G) , …,Tn(G) 。
	 则对应的顶点集和边集的二元组：Gi=(Vi(G),Ti(G))
	 (1≦i≦n)是对应分量的生成树，所有这些生成树构成了原来非连通图的生成森林。
	
	 说明：当给定无向图要求画出其对应的生成树或生成森林时，必须先给出相应的邻接表，然后才能根据邻接表画出其对应的生成树或生成森林。
	
	
	 2  图的生成树和生成森林算法
	
	 对图的深度优先搜索遍历DFS(或BFS)算法稍作修改，就可得到构造图的DFS生成树算法。
	 在算法中，树的存储结构采用孩子—兄弟表示法。首先建立从某个顶点V出发，建立一个树结点，然后再分别以V的邻接点为起始点，建立相应的子生成树，并将其作为V 结点的子树链接到V结点上。显然，算法是一个递归算法。
	
	 */
	
	console.log(adjListGraph.createDFSForest());
	
	console.log(adjListGraph.createBFSForest());
	
	/*
	 在某图中，若删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。一个没有关节点的连通图称为重连通图。
	 在重连通图中，任意一对顶点之间至少存在两条路径，则再删去某个顶点即相关各边后也不破坏图的连通性。若在图的连通图上删去k个节点才能破坏图的连通性，则称K为此图的连通度。
	 他们常常在通信网络的图或航空网中应用，K越大，系统越稳定，反之，战争中若要摧毁敌方的运输线，只须破坏其运输网中的关节点即可。
	 */
	
	var articulTest = new AdjacencyListGraph([], 0, 0, UDG);
	articulTest.addVertex('A');
	articulTest.addVertex('B');
	articulTest.addVertex('C');
	articulTest.addVertex('D');
	articulTest.addVertex('E');
	articulTest.addVertex('F');
	articulTest.addVertex('G');
	articulTest.addVertex('H');
	articulTest.addVertex('I');
	articulTest.addVertex('J');
	articulTest.addVertex('K');
	articulTest.addVertex('L');
	articulTest.addVertex('M');
	
	articulTest.addArc('A', 'B');
	articulTest.addArc('A', 'C');
	articulTest.addArc('A', 'F');
	articulTest.addArc('A', 'L');
	articulTest.addArc('C', 'B');
	articulTest.addArc('D', 'B');
	articulTest.addArc('G', 'B');
	articulTest.addArc('H', 'B');
	articulTest.addArc('M', 'B');
	articulTest.addArc('D', 'E');
	articulTest.addArc('G', 'H');
	articulTest.addArc('G', 'I');
	articulTest.addArc('G', 'K');
	articulTest.addArc('H', 'K');
	articulTest.addArc('J', 'L');
	articulTest.addArc('J', 'M');
	articulTest.addArc('L', 'M');
	
	articulTest.findArticul();
	
	/*
	 有向无环图及其应用
	
	 有向无环图(Directed Acycling Graph)：是图中没有回路(环)的有向图。是一类具有代表性的图，主要用于研究工程项目的工序问题、工程时间进度问题等。
	
	 一个工程(project)都可分为若干个称为活动(active)的子工程(或工序)，各个子工程受到一定的条件约束：某个子工程必须开始于另一个子工程完成之后；整个工程有一个开始点(起点)和一个终点。人们关心：
	 ◆ 工程能否顺利完成?影响工程的关键活动是什么?
	 ◆ 估算整个工程完成所必须的最短时间是多少?
	
	 对工程的活动加以抽象：图中顶点表示活动，有向边表示活动之间的优先关系，这样的有向图称为顶点表示活动的网(Activity On Vertex Network ，AOV网) 。
	
	
	 拓扑排序
	
	 1 定义
	 拓扑排序(Topological Sort) ：由某个集合上的一个偏序得到该集合上的一个全序的操作。
	
	 ◆ 集合上的关系：集合A上的关系是从A到A的关系(AA) 。
	 ◆ 关系的自反性：若a∈A有(a，a)∈R，称集合A上的关系R是自反的。
	 ◆ 关系的对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。
	 ◆ 关系的对称性与反对称性：如果对于a，b∈A ，只要有(a，b)∈R就有(b，a)∈R ，称集合A上的关系R是对称的。如果对于a，b∈A ，仅当a=b时有(a，b)∈R和(b，a)∈R ，称集合A上的关系R是反对称的。
	 ◆ 关系的传递性：若a，b，c∈A，若(a，b)∈R，并且(b，c)∈R ，则(a，c)∈R ，称集合A上的关系R是传递的。
	 ◆ 偏序：若集合A上的关系R是自反的，反对称的和传递的，则称R是集合A上的偏序关系。
	 ◆ 全序：设R是集合A上的偏序关系，a，b∈A，必有aRb或bRa， 则称R是集合A上的全序关系。
	
	 即偏序是指集合中仅有部分元素之间可以比较，而全序是指集合中任意两个元素之间都可以比较。
	 在AOV网中，若有有向边<i, j>，则i是j的直接前驱，j是i的直接后继；推而广之，若从顶点i到顶点j有有向路径，则i是j的前驱，j是i的后继。
	 在AOV网中，不能有环，否则，某项活动能否进行是以自身的完成作为前提条件。
	 检查方法：对有向图的顶点进行拓扑排序，若所有顶点都在其拓扑有序序列中，则无环。
	 有向图的拓扑排序：构造AOV网中顶点的一个拓扑线性序列(v’1,v’2, ⋯,v’n)，使得该线性序列不仅保持原来有向图中顶点之间的优先关系，而且对原图中没有优先关系的顶点之间也建立一种(人为的)优先关系。
	
	 2 拓扑排序算法
	 算法思想
	
	 ① 在AOV网中选择一个没有前驱的顶点且输出；
	 ② 在AOV网中删除该顶点以及从该顶点出发的(以该顶点为尾的弧)所有有向弧(边) ；
	 ③ 重复①、②，直到图中全部顶点都已输出(图中无环)或图中不存在无前驱的顶点(图中必有环)。
	
	 3  算法实现说明
	 ◆ 采用正邻接链作为AOV网的存储结构；
	 ◆ 设立堆栈，用来暂存入度为0的顶点；
	 ◆ 删除顶点以它为尾的弧：弧头顶点的入度减1。
	
	 整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var topologicTest = new AdjacencyListGraph([], 0, 0, DG);
	topologicTest.addVertex('v1');
	topologicTest.addVertex('v2');
	topologicTest.addVertex('v3');
	topologicTest.addVertex('v4');
	topologicTest.addVertex('v5');
	topologicTest.addVertex('v6');
	
	topologicTest.addArc('v2', 'v1');
	topologicTest.addArc('v4', 'v1');
	topologicTest.addArc('v3', 'v1');
	topologicTest.addArc('v2', 'v3');
	topologicTest.addArc('v5', 'v3');
	topologicTest.addArc('v4', 'v6');
	topologicTest.addArc('v5', 'v4');
	topologicTest.addArc('v5', 'v6');
	
	console.log('topologicSort: ');
	console.log(topologicTest.topologicSort());
	
	/*
	 关键路径(Critical Path)
	
	 与AOV网相对应的是AOE(Activity On Edge) ，是边表示活动的有向无环图，如图7-24所示。图中顶点表示事件(Event)，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的时间或费用。
	
	 1 与AOE有关的研究问题
	 ◆ 完成整个工程至少需要多少时间?
	 ◆ 哪些活动是影响工程进度(费用)的关键?
	 工程完成最短时间：从起点到终点的最长路径长度(路径上各活动持续时间之和) 。长度最长的路径称为关键路径，关键路径上的活动称为关键活动。关键活动是影响整个工程的关键。
	 设v0是起点，从v0到vi的最长路径长度称为事件vi的最早发生时间，即是以vi为尾的所有活动的最早发生时间。
	 若活动ai是弧<j, k>，持续时间是dut(<j, k>)，设：
	 ◆ e(i)：表示活动ai的最早开始时间；
	 ◆ l(i)：在不影响进度的前提下，表示活动ai的最晚开始时间； 则l(i)-e(i)表示活动ai的时间余量，若l(i)-e(i)=0，表示活动ai是关键活动。
	 ◆ ve(i)：表示事件vi的最早发生时间，即从起点到顶点vi的最长路径长度；
	 ◆ vl(i)：表示事件vi的最晚发生时间。则有以下关系：
	 e(i)=ve(j)
	 l(i)= vl(k)-dut(<j, k>)
	 0    j=0，表示vj是起点
	 ve(j)=
	 Max{ve(i)+dut(<i, j>)|<vi, vj>是网中的弧}
	
	 含义是：源点事件的最早发生时间设为0；除源点外，只有进入顶点vj的所有弧所代表的活动全部结束后，事件vj才能发生。即只有vj的所有前驱事件vi的最早发生时间ve(i)计算出来后，才能计算ve(j) 。
	 方法是：对所有事件进行拓扑排序，然后依次按拓扑顺序计算每个事件的最早发生时间。
	 ve(n-1)    j=n-1，表示vj是终点
	 vl(j)=
	 Min{vl(k)-dut(<j, k>)|<vj, vk>是网中的弧}
	 含义是：只有vj的所有后继事件vk的最晚发生时间vl(k)计算出来后，才能计算vl(j) 。
	 方法是：按拓扑排序的逆顺序，依次计算每个事件的最晚发生时间。
	
	
	 2 求AOE中关键路径和关键活动
	 ⑴ 算法思想
	 ① 利用拓扑排序求出AOE网的一个拓扑序列；
	 ②  从拓扑排序的序列的第一个顶点(源点)开始，按拓扑顺序依次计算每个事件的最早发生时间ve(i) ；
	 ③  从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i) ；
	
	 设AOE网有n个事件，e个活动，则算法的主要执行是：
	 ◆ 进行拓扑排序：时间复杂度是O(n+e) ；
	 ◆ 求每个事件的ve值和vl值：时间复杂度是O(n+e) ；
	 ◆ 根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；
	 因此，整个算法的时间复杂度是O(n+e) 。
	
	 */
	
	var criticalPathTest = new AdjacencyListGraph([], 0, 0, DG);
	criticalPathTest.addVertex('v0');
	criticalPathTest.addVertex('v1');
	criticalPathTest.addVertex('v2');
	criticalPathTest.addVertex('v3');
	criticalPathTest.addVertex('v4');
	criticalPathTest.addVertex('v5');
	criticalPathTest.addVertex('v6');
	criticalPathTest.addVertex('v7');
	criticalPathTest.addVertex('v8');
	
	criticalPathTest.addArc('v1', 'v0', 3);
	criticalPathTest.addArc('v2', 'v0', 10);
	criticalPathTest.addArc('v4', 'v1', 13);
	criticalPathTest.addArc('v4', 'v2', 12);
	criticalPathTest.addArc('v3', 'v1', 9);
	criticalPathTest.addArc('v5', 'v2', 7);
	criticalPathTest.addArc('v7', 'v4', 6);
	criticalPathTest.addArc('v7', 'v3', 4);
	criticalPathTest.addArc('v7', 'v5', 11);
	criticalPathTest.addArc('v6', 'v3', 8);
	criticalPathTest.addArc('v8', 'v7', 5);
	criticalPathTest.addArc('v8', 'v6', 2);
	
	criticalPathTest.criticalPath();
	
	var dijTest = new AdjacencyListGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('1', '0', 20);
	dijTest.addArc('4', '0', 10);
	dijTest.addArc('2', '0', 60);
	dijTest.addArc('5', '0', 65);
	dijTest.addArc('2', '1', 30);
	dijTest.addArc('3', '2', 40);
	dijTest.addArc('2', '5', 15);
	dijTest.addArc('5', '4', 20);
	dijTest.addArc('4', '3', 35);
	dijTest.addArc('3', '1', 70);
	
	dijTest.shortestPath_Dijkstra(0);
	
	(function () {
	    /**
	     * 输出有向无环图形式表示的逆波兰式
	     */
	    function niBoLan_DAG(graph) {
	        graph.countIndegree();
	        for (var _i20 = 0; _i20 < graph.vexnum; ++_i20) {
	            // 找到有向无环图的根
	            if (graph.vertices[_i20].indegree === 0) {
	                printNiBoLan(graph, _i20);
	                break;
	            }
	        }
	
	        return false;
	    }
	
	    function printNiBoLan(graph, i) {
	        var c = graph.vertices[i].data;
	        var p = graph.vertices[i].firstArc;
	
	        // 子表达式
	        if (p) {
	            printNiBoLan(graph, p.adjVex);
	            printNiBoLan(graph, p.nextArc.adjVex);
	        }
	
	        console.log(c + '');
	    }
	
	    /**
	     * 给有向无环图表示的表达式求值
	     */
	    function evaluate_DAG(graph) {
	        graph.countIndegree();
	        for (var _i21 = 0; _i21 < graph.vexnum; ++_i21) {
	            if (!graph.vertices[_i21].indegree) return evaluate_imp(graph, _i21);
	        }
	    }
	
	    function evaluate_imp(g, i) {
	        if (/^\d+$/.test(g.vertices[i].data)) return g.vertices[i].data;else {
	            var p = g.vertices[i].firstArc;
	            var v1 = evaluate_imp(g, p.adjVex);
	            var v2 = evaluate_imp(g, p.nextArc.adjVex);
	            return calculate(v1, g.vertices[i].data, v2);
	        }
	    }
	
	    function calculate(a, operation, b) {
	        // 偷一下懒..
	        return eval(a + operation + b);
	    }
	
	    // ((1 + 2) * (2 * (3 + 4)) + (3 + 4) * 5) * ((3 + 4) * 5)
	    var dag = new AdjacencyListGraph([], 0, 0, DG);
	
	    var a1 = new String('*');
	    var a2 = new String('+');
	    var a3 = new String('*');
	    var a4 = new String('*');
	    var a5 = new String('+');
	    var a6 = new String('*');
	    var a7 = new String('+');
	
	    // 12
	    dag.addVertex(a1);
	    dag.addVertex(a2);
	    dag.addVertex(a3);
	    dag.addVertex(a4);
	    dag.addVertex(a5);
	    dag.addVertex(a6);
	    dag.addVertex(a7);
	    dag.addVertex(1);
	    dag.addVertex(2);
	    dag.addVertex(3);
	    dag.addVertex(4);
	    dag.addVertex(5);
	
	    // 14
	    dag.addArc(a2, a1);
	    dag.addArc(a4, a1);
	    dag.addArc(a3, a2);
	    dag.addArc(a4, a2);
	    dag.addArc(a5, a3);
	    dag.addArc(a6, a3);
	    dag.addArc(a7, a6);
	    dag.addArc(a7, a4);
	    dag.addArc(5, a4);
	    dag.addArc(1, a5);
	    dag.addArc(2, a5);
	    dag.addArc(2, a6);
	    dag.addArc(3, a7);
	    dag.addArc(4, a7);
	
	    console.log('niBoLan_DAG: ');
	    niBoLan_DAG(dag);
	    console.log('evaluate_DAG: ' + evaluate_DAG(dag)); // 2695
	})();

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(16);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	var _BinaryTree = __webpack_require__(15);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// 图的数组（邻接矩阵）存储表示
	var DG = 1; // 有向图
	/* create by Luke */
	/**
	 * 图(Graph)
	 *
	 * 图(Graph)是一种比线性表和树更为复杂的数据结构。
	 *
	 * 线性结构：是研究数据元素之间的一对一关系。在这种结构中，除第一个和最后一个元素外，任何一个元素都有唯一的一个直接前驱和直接后继。
	 *
	 * 树结构：是研究数据元素之间的一对多的关系。在这种结构中，每个元素对下(层)可以有0个或多个元素相联系，对上(层)只有唯一的一个元素相关，数据元素之间有明显的层次关系。
	 *
	 * 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。
	 *
	 * 图的应用极为广泛，已渗入到诸如语言学、逻辑学、物理、化学、电讯、计算机科学以及数学的其它分支。
	 *
	 * 图的基本概念
	 *
	 * 一个图(G)定义为一个偶对(V,E) ，记为G=(V,E) 。其中： V是顶点(Vertex)的非空有限集合，记为V(G)；E是无序集V&V的一个子集，记为E(G) ，其元素是图的弧(Arc)。
	 * 将顶点集合为空的图称为空图。其形式化定义为：
	 G=(V ，E)
	 V={v|v∈data object}
	 E={<v,w>| v,w∈V∧p(v,w)}
	 P(v,w)表示从顶点v到顶点w有一条直接通路。
	 *
	 * 弧(Arc) ：表示两个顶点v和w之间存在一个关系，用顶点偶对<v,w>表示。通常根据图的顶点偶对将图分为有向图和无向图。
	 * 有向图(Digraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是有序的，称图G是有向图。
	 *   在有向图中，若 <v,w>∈E(G) ，表示从顶点v到顶点w有一条弧。 其中：v称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) 。
	 * 无向图(Undigraph)： 若图G的关系集合E(G)中，顶点偶对<v,w>的v和w之间是无序的，称图G是无向图。
	 *   在无向图中，若<v,w>∈E(G) ，有<w,v>∈E(G) ，即E(G)是对称，则用无序对(v,w) 表示v和w之间的一条边(Edge)，因此(v,w) 和(w,v)代表的是同一条边。
	 *
	 * 例1：设有有向图G1和无向图G2，形式化定义分别是：
	 G1=(V1 ，E1)
	 V1={a,b,c,d,e}
	 E1={<a,b>,<a,c>, <a,e>,<c,d>,<c,e> ,<d,a>,<d,b>,<e,d>}
	 G2=(V2 ，E2)
	 V2={a,b,c,d}
	 E2={(a,b), (a,c), (a,d), (b,d), (b,c), (c,d)}
	 *
	 * 完全无向图：对于无向图，若图中顶点数为n ，用e表示边的数目，则e ∈[0，n(n-1)/2] 。具有n(n-1)/2条边的无向图称为完全无向图。
	 完全无向图另外的定义是：
	 * 对于无向图G=(V，E)，若vi，vj ∈V ，当vi≠vj时，有(vi ,vj)∈E，即图中任意两个不同的顶点间都有一条无向边，这样的无向图称为完全无向图。
	 *
	 * 完全有向图：对于有向图，若图中顶点数为n ，用e表示弧的数目，则e∈[0，n(n-1)] 。具有n(n-1)条边的有向图称为完全有向图。
	 完全有向图另外的定义是：
	 * 对于有向图G=(V，E)，若vi，vj∈V ，当vi ≠vj时，有<vi ,vj>∈E∧<vj , vi >∈E ，即图中任意两个不同的顶点间都有一条弧，这样的有向图称为完全有向图。
	 *
	 * 有很少边或弧的图（e<n㏒n）的图称为稀疏图，反之称为稠密图。
	 * 权(Weight)：与图的边和弧相关的数。权可以表示从一个顶点到另一个顶点的距离或耗费。
	 *
	 * 子图和生成子图：设有图G=(V，E)和G’=(V’，E’)，若V’∈V且E’∈E ，则称图G’是G的子图；若V’=V且E’∈E，则称图G’是G的一个生成子图。
	 * 顶点的邻接(Adjacent)：对于无向图G=(V，E)，若边(v,w)∈E，则称顶点v和w 互为邻接点，即v和w相邻接。边(v,w)依附(incident)与顶点v和w 。
	 * 对于有向图G=(V ，E)，若有向弧<v,w>∈E，则称顶点v “邻接到”顶点w，顶点w “邻接自”顶点v ，弧<v,w> 与顶点v和w “相关联” 。
	 *
	 * 顶点的度、入度、出度：对于无向图G=(V，E)， vi∈V，图G中依附于vi的边的数目称为顶点vi的度(degree)，记为TD(vi)。
	 显然，在无向图中，所有顶点度的和是图中边的2倍。 即   ∑TD(vi)=2e      i=1, 2, …, n ，e为图的边数。
	 对有向图G=(V，E)，若vi ∈V ，图G中以vi作为起点的有向边(弧)的数目称为顶点vi的出度(Outdegree)，记为OD(vi) ；以vi作为终点的有向边(弧)的数目称为顶点vi的入度(Indegree)，记为ID(vi) 。顶点vi的出度与入度之和称为vi的度，记为TD(vi) 。即
	 TD(vi)=OD(vi)+ID(vi)
	 *
	 * 路径(Path)、路径长度、回路(Cycle) ：对无向图G=(V，E)，若从顶点vi经过若干条边能到达vj，称顶点vi和vj是连通的，又称顶点vi到vj有路径。
	 对有向图G=(V，E)，从顶点vi到vj有有向路径，指的是从顶点vi经过若干条有向边(弧)能到达vj。
	 或路径是图G中连接两顶点之间所经过的顶点序列。即
	 Path=vi0vi1…vim ，vij∈V且(vij-1, vij)∈E   j=1,2, …,m
	 或
	 Path=vi0vi1 …vim ，vij∈V且<vij-1, vij>∈E  j=1,2, …,m
	 路径上边或有向边(弧)的数目称为该路径的长度。
	 在一条路径中，若没有重复相同的顶点，该路径称为简单路径；第一个顶点和最后一个顶点相同的路径称为回路(环)；在一个回路中，若除第一个与最后一个顶点外，其余顶点不重复出现的回路称为简单回路(简单环)。
	 *
	 * 连通图、图的连通分量：对无向图G=(V，E)，若vi ，vj ∈V，vi和vj都是连通的，则称图G是连通图，否则称为非连通图。若G是非连通图，则极大的连通子图称为G的连通分量。
	 对有向图G=(V，E)，若vi ，vj ∈V，都有以vi为起点， vj 为终点以及以vj为起点，vi为终点的有向路径，称图G是强连通图，否则称为非强连通图。若G是非强连通图，则极大的强连通子图称为G的强连通分量。
	 “极大”的含义：指的是对子图再增加图G中的其它顶点，子图就不再连通。
	 生成树、生成森林：一个连通图(无向图)的生成树是一个极小连通子图，它含有图中全部n个顶点和只有足以构成一棵树的n-1条边，称为图的生成树。
	 关于无向图的生成树的几个结论：
	 ◆ 一棵有n个顶点的生成树有且仅有n-1条边；
	 ◆ 如果一个图有n个顶点和小于n-1条边，则是非连通图；
	 ◆ 如果多于n-1条边，则一定有环；
	 ◆ 有n-1条边的图不一定是生成树。
	
	 有向图的生成森林是这样一个子图，由若干棵有向树组成，含有图中全部顶点。
	 有向树是只有一个顶点的入度为0 ，其余顶点的入度均为1的有向图。
	
	 *
	 * 网：每个边(或弧)都附加一个权值的图，称为带权图。带权的连通图(包括弱连通的有向图)称为网或网络。网络是工程上常用的一个概念，用来表示一个工程或某种流程
	 */
	
	/**
	 * 图的存储结构
	 *
	 图的存储结构比较复杂，其复杂性主要表现在：
	 ◆ 任意顶点之间可能存在联系，无法以数据元素在存储区中的物理位置来表示元素之间的关系。
	 ◆ 图中顶点的度不一样，有的可能相差很大，若按度数最大的顶点设计结构，则会浪费很多存储单元，反之按每个顶点自己的度设计不同的结构，又会影响操作。
	 图的常用的存储结构有：邻接矩阵、邻接链表、十字链表、邻接多重表和边表。
	 */
	
	/*
	 邻接矩阵(数组)表示法
	
	 基本思想：对于有n个顶点的图，用一维数组vexs[n]存储顶点信息，用二维数组A[n][n]存储顶点之间关系的信息。该二维数组称为邻接矩阵。在邻接矩阵中，以顶点在vexs数组中的下标代表顶点，邻接矩阵中的元素A[i][j]存放的是顶点i到顶点j之间关系的信息。
	
	 1  无向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 无向无权图G=(V，E)有n(n≧1)个顶点，其邻接矩阵是n阶对称方阵。其元素的定义如下：
	            -- 1   若(vi , vj)∈E，即vi , vj邻接
	 A[i][j]=
	             -- 0   若(vi , vj)∉E，即vi , vj不邻接
	
	 (2)  带权图的邻接矩阵
	 无向带权图G=(V，E) 的邻接矩阵。其元素的定义如下：
	            -- Wij    若(vi , vj)∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	
	            -- ∞   若(vi , vj)∉E，即vi , vj不邻接时
	
	 (3)  无向图邻接矩阵的特性
	 ◆ 邻接矩阵是对称方阵
	 ◆ 对于顶点vi，其度数是第i行的非0元素的个数；
	 ◆ 无向图的边数是上(或下)三角形矩阵中非0元素个数。
	
	 2  有向图的数组表示
	
	 (1)  无权图的邻接矩阵
	 若有向无权图G=(V，E)有n(n≧1)个顶点，则其邻接矩阵是n阶对称方阵。元素定义如下：
	            -- 1   若<vi, vj>∈E，从vi到vj有弧
	 A[i][j]=
	            -- 0   若<vi , vj>∉E  从vi到vj 没有弧
	
	 (2)  带权图的邻接矩阵
	 有向带权图G=(V，E)的邻接矩阵。其元素的定义如下：
	            -- wij    若<vi,vj>∈E，即vi , vj邻接，权值为wij
	 A[i][j]=
	            ∞   若<vi,vj>∉E，即vi , vj不邻接时
	
	 ⑶ 有向图邻接矩阵的特性
	 ◆ 对于顶点vi，第i行的非0元素的个数是其出度OD(vi)；第i列的非0元素的个数是其入度ID(vi) 。
	 ◆ 邻接矩阵中非0元素的个数就是图的弧的数目。
	
	 3  图的邻接矩阵的操作
	
	 图的邻接矩阵的实现比较容易，定义两个数组分别存储顶点信息(数据元素)和边或弧的信息(数据元素之间的关系) 。
	
	 */
	
	var DN = 2; // 有向网
	var UDG = 3; // 无向图
	var UDN = 4; // 无向网
	
	var ArcCell =
	/**
	 *
	 * @param {Number} adj
	 * @param {*} info
	 * @constructor
	 */
	function ArcCell(adj) {
	    var info = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    (0, _classCallCheck3.default)(this, ArcCell);
	
	    // 顶点类型。对于无权图，用1或0表示相邻否；对带权图，则为权值类型
	    this.adj = typeof adj === 'number' ? adj : Infinity;
	    // 该弧相关信息
	    this.info = info;
	};
	
	var AdjacencyMatrixGraph = function () {
	    /**
	     *
	     * @param {Array} vexs 顶点向量
	     * @param {Array | ArcCell} arcs 邻接矩阵
	     * @param {Number} vexnum
	     * @param {Number} arcnum
	     * @param {Number} kind
	     * @constructor
	     */
	
	    function AdjacencyMatrixGraph() {
	        var vexs = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var arcs = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	        var vexnum = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	        var arcnum = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	        var kind = arguments.length <= 4 || arguments[4] === undefined ? DG : arguments[4];
	        (0, _classCallCheck3.default)(this, AdjacencyMatrixGraph);
	
	        // 顶点向量
	        this.vexs = vexs;
	        // 邻接矩阵
	        this.arcs = arcs;
	        // 图的当前顶点数
	        this.vexnum = vexnum;
	        // 图的当前弧数
	        this.arcnum = arcnum;
	        // 图的种类标志
	        this.kind = kind;
	    }
	
	    (0, _createClass3.default)(AdjacencyMatrixGraph, [{
	        key: 'createGraph',
	        value: function createGraph() {
	            switch (this.kind) {
	                case DG:
	                    return createDG(this); // 构造有向图
	                case DN:
	                    return createDN(this); // 构造有向网
	                case UDG:
	                    return createUDG(this); // 构造无向图
	                case UDN:
	                    return createUDN(this); // 构造无向网
	                default:
	                    throw new Error('非有效的图类型');
	            }
	        }
	
	        /**
	         * 查找顶点
	         * @param {*} vp 顶点向量
	         * @returns {number}
	         */
	
	    }, {
	        key: 'locateVex',
	        value: function locateVex(vp) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.vexs[i] === vp) return i;
	            }
	
	            return -1;
	        }
	
	        /**
	         * 向图中增加顶点
	         * @param {*} vp 顶点向量
	         */
	
	    }, {
	        key: 'addVertex',
	        value: function addVertex(vp) {
	            if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');
	
	            var k = this.vexnum;
	            this.vexs[this.vexnum++] = vp;
	
	            var value = this.kind === DG || this.kind === UDG ? 0 : Infinity;
	            for (var j = 0; j < this.vexnum; ++j) {
	                this.arcs[j] = this.arcs[j] || [];
	                this.arcs[k] = this.arcs[k] || [];
	                this.arcs[j][k] = this.arcs[j][k] || new ArcCell();
	                this.arcs[k][j] = this.arcs[k][j] || new ArcCell();
	                this.arcs[j][k].adj = this.arcs[k][j].adj = value;
	            }
	        }
	
	        /**
	         * 向图中增加一条弧
	         * @param {*} vex1 顶点1向量
	         * @param {*} vex2 顶点2向量
	         * @param {ArcCell} arc
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'addArc',
	        value: function addArc(vex1, vex2, arc) {
	            arc = arc || new ArcCell(this.kind === DG || this.kind === UDG ? 1 : 'weight');
	            var k = this.locateVex(vex1);
	            var j = this.locateVex(vex2);
	
	            if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');
	
	            this.arcs[k][j].adj = arc.adj;
	            this.arcs[k][j].info = arc.info;
	            // 无向图或无向网
	            if (this.kind === UDG || this.kind === UDN) {
	                this.arcs[j][k].adj = arc.adj;
	                this.arcs[j][k].info = arc.info;
	            }
	
	            ++this.arcnum;
	
	            return true;
	        }
	
	        /**
	         * 删除顶点
	         * @param {String} vex 要删除的顶点
	         */
	
	    }, {
	        key: 'deleteVex',
	        value: function deleteVex(vex) {
	            var n = this.vexnum - 1;
	            var m = this.locateVex(vex);
	
	            if (m < 0) return false;
	
	            // 将待删除顶点交换到最后一个顶点
	            var temp = this.vexs[m];
	            this.vexs[m] = this.vexs[n];
	            this.vexs[n] = temp;
	
	            // 将边的关系随之交换
	            for (var i = 0; i <= n; ++i) {
	                this.arcs[i][m] = this.arcs[i][n];
	                this.arcs[m][i] = this.arcs[n][i];
	            }
	
	            this.arcs[m][m].adj = 0;
	            this.vexs.length = --this.vexnum;
	            return true;
	        }
	
	        /**
	         * 删除边(v, w)
	         * @param {String} v
	         * @param {String} w
	         * @returns {boolean}
	         */
	
	    }, {
	        key: 'deleteArc',
	        value: function deleteArc(v, w) {
	            var i = this.locateVex(v);
	            var j = this.locateVex(w);
	
	            if (i < 0 || j < 0) return false;
	
	            if (this.arcs[i][j].adj) {
	                this.arcs[i][j].adj = 0;
	                this.arcnum--;
	            }
	
	            return true;
	        }
	
	        // 判断一个邻接矩阵存储的有向图是否可传递
	
	    }, {
	        key: 'isPass',
	        value: function isPass() {
	            if (this.kind !== DG) throw new Error('graph kind should be DG');
	
	            for (var x = 0; x < this.vexnum; ++x) {
	                for (var y = 0; y < this.vexnum; ++y) {
	                    if (this.arcs[x][y]) {
	                        for (var z = 0; z < this.vexnum; ++z) {
	                            if (z !== x && this.arcs[y][z] && !this.arcs[x][z]) return false;
	                        }
	                    }
	                }
	            }
	
	            return true;
	        }
	    }, {
	        key: 'firstAdjVex',
	        value: function firstAdjVex(v) {
	            for (var i = 0; i < this.vexnum; ++i) {
	                if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	            }
	
	            return -1;
	        }
	    }, {
	        key: 'nextAdjVex',
	        value: function nextAdjVex(v, w) {
	            for (var i = w + 1; i < this.vexnum; ++i) {
	                if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
	            }
	
	            return -1;
	        }
	
	        // 对邻接矩阵图作递归式深度优先遍历
	
	    }, {
	        key: 'DFSTraverse',
	        value: function DFSTraverse(visitFn) {
	            var visited = [];
	            // 访问标志数组初始化
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i = 0; _i < this.vexnum; ++_i) {
	                if (!visited[_i]) dfs(this, _i);
	            }
	
	            function dfs(graph, vertex) {
	                visited[vertex] = true;
	                visitFn.call(graph, vertex);
	
	                for (var j = 0; j < graph.vexnum; ++j) {
	                    if (graph.arcs[vertex][j].adj !== 0 && graph.arcs[vertex][j].adj !== Infinity && !visited[j]) dfs(graph, j);
	                }
	            }
	        }
	
	        // 非递归
	
	    }, {
	        key: 'DFSTraverse_NonRecurse',
	        value: function DFSTraverse_NonRecurse(visitFn) {
	            var visited = [];
	            var stack = new _index2.default();
	            var me = this;
	            // 访问标志数组初始化
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i2 = 0; _i2 < this.vexnum; ++_i2) {
	                if (!visited[_i2]) {
	                    stack.push(_i2);
	                    visited[_i2] = true;
	                    visitFn.call(me, _i2);
	
	                    var vertex = void 0;
	                    while ((vertex = stack.peek()) != null) {
	                        for (var j = 0; j < this.vexnum; ++j) {
	                            if (this.arcs[vertex][j].adj !== 0 && this.arcs[vertex][j].adj !== Infinity && !visited[j]) {
	                                visitFn.call(me, j);
	                                visited[j] = true;
	                                stack.push(j);
	                            } else stack.pop();
	                        }
	                    }
	                }
	            }
	        }
	
	        // 对邻接矩阵图作广度优先遍历
	
	    }, {
	        key: 'BFSTraverse',
	        value: function BFSTraverse(visitFn) {
	            var visited = [];
	            var queue = new _Queue2.default();
	
	            for (var i = 0; i < this.vexnum; ++i) {
	                visited[i] = false;
	            }for (var _i3 = 0; _i3 < this.vexnum; ++_i3) {
	                if (!visited[_i3]) {
	                    visited[_i3] = true;
	                    visitFn.call(this, _i3);
	                    queue.enQueue(_i3);
	
	                    while (queue.rear) {
	                        var u = queue.deQueue();
	
	                        for (var j = 0; j < this.vexnum; ++j) {
	                            if (this.arcs[u][j].adj !== 0 && this.arcs[u][j].adj !== Infinity && !visited[j]) {
	                                visited[j] = true;
	                                visitFn.call(this, j);
	                                queue.enQueue(j);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'minSpanTree_PRIM',
	        value: function minSpanTree_PRIM(u) {
	            var closedge = [];
	
	            // 初始化
	            for (var j = 0; j < this.vexnum; ++j) {
	                closedge[j] = { adjvex: u, lowcost: +this.arcs[j][u].adj };
	            }
	            closedge[u].lowcost = 0;
	
	            var te = [];
	            // 选择其余this.vexnum - 1个顶点
	            for (var _j = 0; _j < this.vexnum - 1; ++_j) {
	                var min = Infinity;
	                var k = void 0;
	                for (var v = 0; v < this.vexnum; ++v) {
	                    if (closedge[v].lowcost !== 0 && closedge[v].lowcost < min) {
	                        min = closedge[v].lowcost;
	                        k = v;
	                    }
	                }
	
	                te[_j] = {
	                    vex1: closedge[k].adjvex,
	                    vex2: k,
	                    weight: closedge[k].lowcost
	                };
	                closedge[k].lowcost = 0;
	                for (var _v = 0; _v < this.vexnum; ++_v) {
	                    if (this.arcs[_v][k].adj < closedge[_v].lowcost) {
	                        closedge[_v].lowcost = this.arcs[_v][k].adj;
	                        closedge[_v].adjvex = k;
	                    }
	                }
	            }
	
	            return te;
	        }
	    }, {
	        key: 'minSpanTree_Kruskal',
	        value: function minSpanTree_Kruskal() {
	            var set = [];
	            var te = [];
	
	            for (var i = 0; i < this.vexnum; ++i) {
	                set[i] = i;
	            }var k = 0;
	            var min = Infinity;
	            var a = 0;
	            var b = 0;
	            while (k < this.vexnum - 1) {
	                for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
	                    for (var j = _i4 + 1; j < this.vexnum; ++j) {
	                        if (this.arcs[_i4][j].adj < min) {
	                            min = this.arcs[_i4][j].adj;
	                            a = _i4;
	                            b = j;
	                        }
	                    }
	                }
	
	                if (set[a] !== set[b]) {
	                    te[k++] = {
	                        vex1: a,
	                        vex2: b,
	                        weight: this.arcs[a][b].adj
	                    };
	
	                    for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
	                        if (set[_i5] === set[b] && _i5 !== b) set[_i5] = set[a];
	                    }
	                    set[b] = set[a];
	                }
	
	                min = this.arcs[a][b].adj = Infinity;
	            }
	
	            return te;
	        }
	
	        /**
	         * 用Dijkstra算法求有向网的v0顶点到其余顶点v的最短路径pre[v]及其带权长度dist[v]。
	         * 若pre[v][w]为true，则w是从v0到v当前求得最短路径上的顶点。
	         * final[v]为true当且仅当v∈S，即已经求得v0到v的最短路径
	         * @param v0
	         */
	
	    }, {
	        key: 'shortestPath_Dijkstra',
	        value: function shortestPath_Dijkstra(v0) {
	            var pre = [];
	            var dist = [];
	            var final = [];
	            var w = void 0,
	                v = void 0;
	
	            for (var _v2 = 0; _v2 < this.vexnum; ++_v2) {
	                final[_v2] = false;
	                dist[_v2] = this.arcs[v0][_v2].adj;
	                pre[_v2] = pre[_v2] || [];
	                // 设空路径
	                for (w = 0; w < this.vexnum; ++w) {
	                    pre[_v2][w] = false;
	                }if (dist[_v2] < Infinity) {
	                    pre[_v2][v0] = true;
	                    pre[_v2][_v2] = true;
	                }
	            }
	
	            // 初始化，v0顶点属于S集
	            dist[v0] = 0;
	            final[v0] = true;
	
	            // 开始主循环，每次求得v0到某个v顶点的最短路径，并加v到S集
	
	            // 其余的顶点
	            for (var i = 1; i < this.vexnum; ++i) {
	                var min = Infinity;
	                // 当前所指离v0顶点的最近距离
	                for (w = 0; w < this.vexnum; ++w) {
	                    // w顶点在V - S中
	                    // 且w顶点离v0顶点更近
	                    if (!final[w] && dist[w] < min) {
	                        v = w;
	                        min = dist[w];
	                    }
	                }
	
	                // 离v0顶点最近的v加入S集
	                final[v] = true;
	                // 更新当前最短路径及距离
	                for (w = 0; w < this.vexnum; ++w) {
	                    if (!final[w] && min + this.arcs[v][w].adj < dist[w]) {
	                        dist[w] = min + this.arcs[v][w].adj;
	                        pre[w] = pre[v];
	                        pre[w][w] = true;
	                    }
	                }
	            }
	
	            console.log(final);
	            console.log(pre);
	            console.log(dist);
	
	            return {
	                final: final,
	                pre: pre,
	                dist: dist
	            };
	        }
	    }, {
	        key: 'shortestPath_FLOYD',
	        value: function shortestPath_FLOYD() {
	            var a = [];
	            var path = [];
	
	            for (var j = 0; j < this.vexnum; ++j) {
	                a[j] = a[j] || [];
	                path[j] = path[j] || [];
	                for (var k = 0; k < this.vexnum; ++k) {
	                    if (j === k) a[j][k] = 0;else a[j][k] = this.arcs[j][k].adj;
	                    path[j][k] = -1;
	                }
	            }
	
	            for (var m = 0; m < this.vexnum; ++m) {
	                for (var _j2 = 0; _j2 < this.vexnum; ++_j2) {
	                    for (var _k = 0; _k < this.vexnum; ++_k) {
	                        if (a[_j2][m] + a[m][_k] < a[_j2][_k]) {
	                            a[_j2][_k] = a[_j2][m] + a[m][_k];
	                            path[_j2][_k] = m;
	                        }
	                    }
	                }
	            }
	
	            for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
	                for (var _k2 = 0; _k2 < this.vexnum; ++_k2) {
	                    if (_j3 !== _k2) {
	                        console.log('%d到%d的最短路径为：', _j3, _k2);
	                        console.log('%d ', _j3);prn_pass(_j3, _k2);
	                        console.log('%d ', _k2);
	                        console.log('最短路径长度为： %d', a[_j3][_k2]);
	                    }
	                }
	            }
	
	            function prn_pass(j, k) {
	                if (path[j][k] !== -1) {
	                    prn_pass(j, path[j][k]);
	                    console.log(', %d', path[j][k]);
	                    prn_pass(path[j][k], k);
	                }
	            }
	        }
	    }]);
	    return AdjacencyMatrixGraph;
	}();
	
	exports.default = AdjacencyMatrixGraph;
	
	
	var createDG = createGraph(DG);
	var createDN = createGraph(DN);
	var createUDG = createGraph(UDG);
	var createUDN = createGraph(UDN);
	
	function createGraph(kind) {
	    var adj = void 0;
	    var setMatrixValue = void 0;
	
	    if (kind === 2 || kind === 4) {
	        adj = Infinity;
	        setMatrixValue = function setMatrixValue() {
	            return prompt('weight: ');
	        };
	    } else {
	        adj = 0;
	        setMatrixValue = function setMatrixValue() {
	            return 1;
	        };
	    }
	
	    return function (AdjacencyMatrixGraph) {
	        AdjacencyMatrixGraph.vexnum = parseInt(prompt('vexnum: '), 10);
	        AdjacencyMatrixGraph.arcnum = parseInt(prompt('arcnum: '), 10);
	        // incInfo为0则各弧不含其他信息
	        var incInfo = parseInt(prompt('incInfo: '), 10);
	
	        // 构造顶点向量
	        var i = void 0,
	            j = void 0;
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            AdjacencyMatrixGraph.vexs[i] = prompt('顶点向量vex: ');
	        } // 初始化邻接矩阵
	        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
	            for (j = 0; j < AdjacencyMatrixGraph.vexnum; ++j) {
	                AdjacencyMatrixGraph.arcs[i] = AdjacencyMatrixGraph.arcs[i] || [];
	                AdjacencyMatrixGraph.arcs[i][j] = new ArcCell(adj, null);
	            }
	        }
	
	        // 构造邻接矩阵
	        for (var k = 0; k < AdjacencyMatrixGraph.arcnum; ++k) {
	            // 输入一条边依附的顶点及权值
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            // 确定v1，v2在G中的位置
	            i = AdjacencyMatrixGraph.locateVex(v1);
	            j = AdjacencyMatrixGraph.locateVex(v2);
	
	            var w = setMatrixValue();
	            // 弧<v1, v2>的权值
	            AdjacencyMatrixGraph.arcs[i][j].adj = w;
	            if (incInfo) AdjacencyMatrixGraph.arcs[i][j].info = prompt('info: ');
	            if (kind === 3 || kind === 4) AdjacencyMatrixGraph.arcs[j][i] = AdjacencyMatrixGraph.arcs[i][j];
	        }
	    };
	}
	
	// 第一种创建图方法
	var vexs = ['a', 'b', 'c', 'd', 'e'];
	var arcs = [[{ "adj": Infinity, "info": null }, { "adj": "6", "info": null }, { "adj": "2", "info": null }, { "adj": Infinity, "info": null }, { "adj": Infinity, "info": null }], [{ "adj": "6", "info": null }, { "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": "4", "info": null }, { "adj": "3", "info": null }], [{ "adj": "2", "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "4", "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }, { "adj": Infinity, "info": null }]];
	var udn = new AdjacencyMatrixGraph(vexs, arcs, 5, 7, 4);
	
	// 第二种创建图方法
	var dn = new AdjacencyMatrixGraph([], [], 0, 0, 2);
	dn.addVertex('a');
	dn.addVertex('b');
	dn.addVertex('c');
	dn.addVertex('d');
	dn.addVertex('e');
	
	dn.addArc('a', 'b', {
	    adj: 6
	});
	dn.addArc('a', 'c', {
	    adj: 2
	});
	dn.addArc('c', 'b', {
	    adj: 3
	});
	dn.addArc('c', 'd', {
	    adj: 1
	});
	dn.addArc('d', 'b', {
	    adj: 4
	});
	dn.addArc('b', 'e', {
	    adj: 3
	});
	dn.addArc('d', 'e', {
	    adj: 5
	});
	
	console.log(dn);
	
	/*
	
	 // 第三种创建图方法
	 let g = new AdjacencyMatrixGraph();
	 g.kind = DN;
	 g.createGraph();
	 console.log(g);
	
	 */
	
	/*
	 图的遍历
	
	 图的遍历(Travering Graph)：从图的某一顶点出发，访遍图中的其余顶点，且每个顶点仅被访问一次。图的遍历算法是各种图的操作的基础。
	
	 ◆ 复杂性：图的任意顶点可能和其余的顶点相邻接，可能在访问了某个顶点后，沿某条路径搜索后又回到原顶点。
	 ◆ 解决办法：在遍历过程中记下已被访问过的顶点。设置一个辅助向量Visited[1…n](n为顶点数)，其初值为0，一旦访问了顶点vi后，使Visited[i]为1或为访问的次序号。
	 图的遍历算法有深度优先搜索算法和广度优先搜索算法。
	
	 深度优先搜索(Depth First Search--DFS)遍历类似树的先序遍历，是树的先序遍历的推广。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；然后找到vi的一个邻接顶点vi1 ；
	 ⑵：从vi1出发，深度优先搜索访问和vi1相邻接且未被访问的所有顶点；
	 ⑶：转⑴ ，直到和vi相邻接的所有顶点都被访问为止
	 ⑷ ：继续选取图中未被访问顶点vj作为起始顶点，转(1)，直到图中所有顶点都被访问为止。
	
	
	 广度优先搜索(Breadth First Search--BFS)遍历类似树的按层次遍历的过程。
	
	 算法思想
	 设初始状态时图中的所有顶点未被访问，则：
	 ⑴ ：从图中某个顶点vi出发，访问vi；
	 ⑵：访问vi的所有相邻接且未被访问的所有顶点vi1，vi2，…，vim；
	 ⑶：以vi1，vi2， …，vim的次序，以vij(1≦j≦m)依此作为vi ，转⑴；
	 ⑷ ：继续选取图中未被访问顶点vk作为起始顶点，转⑴，直到图中所有顶点都被访问为止。
	
	 用广度优先搜索算法遍历图与深度优先搜索算法遍历图的唯一区别是邻接点搜索次序不同.
	 */
	
	console.log('DFSTraverse: udn');
	
	var g1 = new AdjacencyMatrixGraph([], [], 0, 0, UDG);
	g1.addVertex('v1');
	g1.addVertex('v3');
	g1.addVertex('v2');
	g1.addVertex('v4');
	g1.addVertex('v5');
	
	g1.addArc('v5', 'v4');
	g1.addArc('v3', 'v1');
	g1.addArc('v2', 'v1');
	g1.addArc('v3', 'v2');
	
	g1.DFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('DFSTraverse_NonRecurse: udn');
	g1.DFSTraverse_NonRecurse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	console.log('BFSTraverse: ');
	var bsfG = new AdjacencyMatrixGraph([], [], 0, 0, DG);
	bsfG.addVertex('v1');
	bsfG.addVertex('v2');
	bsfG.addVertex('v3');
	bsfG.addVertex('v4');
	bsfG.addVertex('v5');
	
	bsfG.addArc('v1', 'v4');
	bsfG.addArc('v1', 'v2');
	bsfG.addArc('v3', 'v5');
	bsfG.addArc('v3', 'v2');
	bsfG.addArc('v3', 'v1');
	bsfG.addArc('v4', 'v3');
	bsfG.addArc('v5', 'v4');
	
	bsfG.BFSTraverse(function (v) {
	    console.log(this.vexs[v]);
	});
	
	/*
	 最小生成树
	
	 如果连通图是一个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。
	
	 最小生成树(Minimum Spanning Tree) ：带权连通图中代价最小的生成树称为最小生成树。
	
	 最小生成树在实际中具有重要用途，如设计通信网。设图的顶点表示城市，边表示两个城市之间的通信线路，边的权值表示建造通信线路的费用。n个城市之间最多可以建n(n-1)/2条线路，如何选择其中的n-1条，使总的建造费用最低?
	
	 构造最小生成树的算法有许多，基本原则是：
	 ◆ 尽可能选取权值最小的边，但不能构成回路；
	 ◆ 选择n-1条边构成最小生成树。
	 以上的基本原则是基于MST的如下性质：
	 设G=(V，E)是一个带权连通图，U是顶点集V的一个非空子集。若u∈U ，v∈V-U，且(u, v)是U中顶点到V-U中顶点之间权值最小的边，则必存在一棵包含边(u, v)的最小生成树。
	
	 证明： 用反证法证明。
	 设图G的任何一棵最小生成树都不包含边(u,v)。设T是G的一棵生成树，则T是连通的，从u到v必有一条路径(u,…,v)，当将边(u,v)加入到T中时就构成了回路。则路径(u, …,v)中必有一条边(u’,v’) ，满足u’∈U ，v’∈V-U 。删去边(u’,v’) 便可消除回路，同时得到另一棵生成树T’。
	 由于(u,v)是U中顶点到V-U中顶点之间权值最小的边，故(u,v)的权值不会高于(u’,v’)的权值，T’的代价也不会高于T， T’是包含(u,v) 的一棵最小生成树，与假设矛盾。
	
	 */
	
	/*
	 普里姆(Prim)算法
	
	 适合边稠密的网
	
	 从连通网N=(U，E)中找最小生成树T=(U，TE) 。
	
	 1 算法思想
	 ⑴  若从顶点v0出发构造，U={v0}，TE={}；
	 ⑵ 先找权值最小的边(u，v)，其中u∈U且v∈V-U，并且子图不构成环，则U= U∪{v}，TE=TE∪{(u，v)} ；
	 ⑶ 重复⑵ ，直到U=V为止。则TE中必有n-1条边， T=(U，TE)就是最小生成树。
	
	 2.算法实现说明
	 为便于算法实现，设置一个一维数组closedge[n]，用来保存V- U中各顶点到U中顶点具有权值最小的边。
	 closedge[j].adjvex=k，表明边(vj, vk)是V-U中顶点vj到U中权值最小的边，而顶点vk是该边所依附的U中的顶点。 closedge[j].lowcost存放该边的权值。
	 假设从顶点vs开始构造最小生成树。初始时令：
	 Closedge[s].lowcost=0 ：表明顶点vs首先加入到U中；
	 Closedge[k].adjvex=s ，Closedge[k].lowcost=cost(k, s)
	 表示V-U中的各顶点到U中权值最小的边(k≠s) ，cost(k, s)表示边(vk, vs) 权值。
	
	 3.算法步骤
	 ⑴  从closedge中选择一条权值(不为0)最小的边(vk, vj) ，然后做：
	 ① 置closedge[k].lowcost为0 ，表示vk已加入到U中。
	 ②  根据新加入vk的更新closedge中每个元素：
	 vi∈V-U ，若cost(i, k)≦colsedge[i].lowcost，表明在U中新加入顶点vk后， (vi, vk)成为vi到U中权值最小的边，置：
	 Closedge[i].lowcost=cost(i, k)
	 Closedge[i].adjvex=k
	 ⑵  重复⑴n-1次就得到最小生成树。
	
	 算法分析：
	 设带权连通图有n个顶点，则算法的主要执行是二重循环： 求closedge中权值最小的边，频度为n-1； 修改closedge数组，频度为n 。因此，整个算法的时间复杂度是O(n2)，与边的数目无关。
	
	 */
	
	udn = new AdjacencyMatrixGraph([], [], 0, 0, 4);
	udn.addVertex('v1');
	udn.addVertex('v2');
	udn.addVertex('v3');
	udn.addVertex('v4');
	udn.addVertex('v5');
	udn.addVertex('v6');
	
	udn.addArc('v1', 'v2', { adj: 6 });
	udn.addArc('v1', 'v3', { adj: 1 });
	udn.addArc('v1', 'v4', { adj: 5 });
	udn.addArc('v2', 'v3', { adj: 5 });
	udn.addArc('v2', 'v5', { adj: 3 });
	udn.addArc('v3', 'v4', { adj: 5 });
	udn.addArc('v3', 'v5', { adj: 6 });
	udn.addArc('v3', 'v6', { adj: 4 });
	udn.addArc('v4', 'v6', { adj: 2 });
	udn.addArc('v5', 'v6', { adj: 6 });
	
	console.log('minSpanTree_PRIM: ');
	console.log(udn.minSpanTree_PRIM(0));
	
	/*
	 克鲁斯卡尔(Kruskal)算法
	
	 适合边稀疏的网
	
	 1 算法思想
	 设G=(V, E)是具有n个顶点的连通网，T=(U, TE)是其最小生成树。初值：U=V，TE={} 。
	 对G中的边按权值大小从小到大依次选取。
	 ⑴   选取权值最小的边(vi，vj)，若边(vi，vj)加入到TE后形成回路，则舍弃该边(边(vi，vj) ；否则，将该边并入到TE中，即TE=TE∪{(vi，vj)} 。
	 ⑵ 重复⑴ ，直到TE中包含有n-1条边为止。
	 如图7-22所提示。
	
	 2 算法实现说明
	 Kruskal算法实现的关键是：当一条边加入到TE的集合后，如何判断是否构成回路?
	 简单的解决方法是：定义一个一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。
	 ◆ 初值：Vset[i]=i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。
	 ◆ 当往T中增加一条边(vi，vj) 时，先检查Vset[i]和Vset[j]值：
	 ☆ 若Vset[i]=Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路；
	 ☆ 若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。
	 ◆ 加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号。
	
	 */
	
	console.log('minSpanTree_Kruskal: ');
	console.log(udn.minSpanTree_Kruskal());
	
	/*
	 最短路径
	
	 若用带权图表示交通网，图中顶点表示地点，边代表两地之间有直接道路，边上的权值表示路程(或所花费用或时间) 。从一个地方到另一个地方的路径长度表示该路径上各边的权值之和。问题：
	 ◆ 两地之间是否有通路?
	 ◆ 在有多条通路的情况下，哪条最短?
	 考虑到交通网的有向性，直接讨论的是带权有向图的最短路径问题，但解决问题的算法也适用于无向图。
	 将一个路径的起始顶点称为源点，最后一个顶点称为终点。
	
	
	 单源点最短路径
	
	 对于给定的有向图G=(V，E)及单个源点Vs，求Vs到G的其余各顶点的最短路径。
	 针对单源点的最短路径问题，Dijkstra提出了一种按路径长度递增次序产生最短路径的算法，即迪杰斯特拉(Dijkstra)算法。
	
	 1 基本思想
	 从图的给定源点到其它各个顶点之间客观上应存在一条最短路径，在这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。
	 即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，依此类推，直到求出长度最长的最短路径。
	
	 2 算法思想说明
	 设给定源点为Vs，S为已求得最短路径的终点集，开始时令S={Vs} 。当求得第一条最短路径(Vs ，Vi)后，S为{Vs，Vi} 。根据以下结论可求下一条最短路径。
	 设下一条最短路径终点为Vj ，则Vj只有：
	 ◆  源点到终点有直接的弧<Vs，Vj>；
	 ◆ 从Vs 出发到Vj 的这条最短路径所经过的所有中间顶点必定在S中。即只有这条最短路径的最后一条弧才是从S内某个顶点连接到S外的顶点Vj 。
	 若定义一个数组dist[n]，其每个dist[i]分量保存从Vs 出发中间只经过集合S中的顶点而到达Vi的所有路径中长度最小的路径长度值，则下一条最短路径的终点Vj必定是不在S中且值最小的顶点，即：
	 dist[i]=Min{ dist[k]| Vk∈V-S }
	 利用上述公式就可以依次找出下一条最短路径。
	
	 3  算法步骤
	 ① 令S={Vs} ，用带权的邻接矩阵表示有向图，对图中每个顶点Vi按以下原则置初值：
	 0    i =s
	 dist[i] =   Wsi     i≠s且<vs,vi>∈E， wsi为弧上的权值
	 ∞   i≠s且<vs,vi>不属于E
	 ② 选择一个顶点Vj ，使得：
	 dist[j]=Min{ dist[k]| Vk∈V-S }
	 Vj就是求得的下一条最短路径终点，将Vj 并入到S中，即S=S∪{Vj} 。
	 ③ 对V-S中的每个顶点Vk ，修改dist[k]，方法是：
	 若dist[j]+Wjk<dist[k]，则修改为：
	 dist[k]=dist[j]+Wjk (Vk∈V-S )
	 ④ 重复②，③，直到S=V为止。
	
	 4 算法实现
	 用带权的邻接矩阵表示有向图， 对Prim算法略加改动就成了Dijkstra算法，将Prim算法中求每个顶点Vk的lowcost值用dist[k]代替即可。
	 ◆  设数组pre[n]保存从Vs到其它顶点的最短路径。若pre[i]=k，表示从Vs 到Vi的最短路径中，Vi的前一个顶点是Vk，即最短路径序列是(Vs , …, Vk  , Vi) 。
	 ◆ 设数组final[n]，标识一个顶点是否已加入S中。
	
	 5  算法分析
	 Dijkstra算法的主要执行是：
	 ◆ 数组变量的初始化：时间复杂度是O(n) ；
	 ◆ 求最短路径的二重循环：时间复杂度是O(n2) ；
	 因此，整个算法的时间复杂度是O(n2) 。
	
	 */
	
	var dijTest = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	
	dijTest.addVertex('0');
	dijTest.addVertex('1');
	dijTest.addVertex('2');
	dijTest.addVertex('3');
	dijTest.addVertex('4');
	dijTest.addVertex('5');
	
	dijTest.addArc('0', '1', { adj: 20 });
	dijTest.addArc('0', '4', { adj: 10 });
	dijTest.addArc('0', '2', { adj: 60 });
	dijTest.addArc('0', '5', { adj: 65 });
	dijTest.addArc('1', '2', { adj: 30 });
	dijTest.addArc('2', '3', { adj: 40 });
	dijTest.addArc('5', '2', { adj: 15 });
	dijTest.addArc('4', '5', { adj: 20 });
	dijTest.addArc('3', '4', { adj: 35 });
	dijTest.addArc('1', '3', { adj: 70 });
	
	dijTest.shortestPath_Dijkstra(0);
	
	/*
	 每一对顶点间的最短路径
	
	 用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。方法是：每次以一个不同的顶点为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，时间复杂度是O(n3) 。
	
	 弗罗伊德(Floyd)提出了另一个算法，其时间复杂度仍是O(n3) ， 但算法形式更为简明。
	
	 1 算法思想
	
	 设顶点集S(初值为空)，用数组A的每个元素A[i][j]保存从Vi只经过S中的顶点到达Vj的最短路径长度，其思想是：
	 ① 初始时令S={ } ， A[i][j]的赋初值方式是：
	 0    i =j时
	 A[i][j]=    Wij     i≠j且<vi,vj>∈E， wij为弧上的权值
	 ∞   i≠j且<vi,vj>不属于E
	 ② 将图中一个顶点Vk 加入到S中，修改A[i][j]的值，修改方法是：
	 A[i][j]=Min{A[i][j] , (A[i][k]+A[k][j]) }
	 原因： 从Vj只经过S中的顶点(Vk)到达Vj的路径长度可能比原来不经过Vk的路径更短。
	 ③ 重复②，直到G的所有顶点都加入到S中为止。
	
	 2 算法实现
	
	 ◆  定义二维数组Path[n][n](n为图的顶点数) ，元素Path[i][j]保存从Vi到Vj的最短路径所经过的顶点。
	 ◆ 若Path[i][j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径子序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i][k]和Path[k][j]的值再找到该路径上所经过的其它顶点，…依此类推。
	 ◆ 初始化为Path[i][j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i][j]变小时，令Path[i][j]=k。
	
	
	 */
	
	var floyd = new AdjacencyMatrixGraph([], [], 0, 0, DN);
	floyd.addVertex('v0');
	floyd.addVertex('v1');
	floyd.addVertex('v2');
	floyd.addArc('v0', 'v2', { adj: 8 });
	floyd.addArc('v0', 'v1', { adj: 2 });
	floyd.addArc('v1', 'v2', { adj: 4 });
	floyd.addArc('v2', 'v0', { adj: 5 });
	
	floyd.shortestPath_FLOYD();
	
	// http://blog.csdn.net/hguisu/article/details/7719428
	// 添加《图的应用详解-数据结构》

/***/ },
/* 75 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 十字链表法
	
	 十字链表(Orthogonal List)是有向图的另一种链式存储结构，是将有向图的正邻接表和逆邻接表结合起来得到的一种链表。
	
	 在这种结构中，每条弧的弧头结点和弧尾结点都存放在链表中，并将弧结点分别组织到以弧尾结点为头(顶点)结点和以弧头结点为头(顶点)结点的链表中。
	
	 ◆  data域：存储和顶点相关的信息；
	 ◆ 指针域firstin：指向以该顶点为弧头的第一条弧所对应的弧结点；
	 ◆ 指针域firstout：指向以该顶点为弧尾的第一条弧所对应的弧结点；
	 ◆ 尾域tailvex：指示弧尾顶点在图中的位置；
	 ◆ 头域headvex：指示弧头顶点在图中的位置；
	 ◆ 指针域hlink：指向弧头相同的下一条弧；
	 ◆ 指针域tlink：指向弧尾相同的下一条弧；
	 ◆ Info域：指向该弧的相关信息；
	
	 从这种存储结构图可以看出，从一个顶点结点的firstout出发，沿表结点的tlink指针构成了正邻接表的链表结构，而从一个顶点结点的firstin出发，沿表结点的hlink指针构成了逆邻接表的链表结构。
	
	 */
	
	/**
	 *
	 * @param {Number} headVex 弧的头顶点的位置
	 * @param {Number} tailVex 弧的尾顶点位置
	 * @param {ArcBox} hLink 弧头相同的弧的链域
	 * @param {ArcBox} tLink 弧尾相同的弧的链域
	 * @param {*} info
	 * @constructor
	 */
	function ArcBox(tailVex, headVex, hLink, tLink, info) {
	    this.headVex = headVex || 0;
	    this.tailVex = tailVex || 0;
	    this.hLink = hLink || null;
	    this.tLink = tLink || null;
	    this.info = info || null;
	}
	
	/**
	 *
	 * @param {*} data
	 * @param {ArcBox} firstIn 该顶点第一条入弧
	 * @param {ArcBox} firstOut 该顶点第一条出弧
	 * @constructor
	 */
	function OLVexNode(data, firstIn, firstOut) {
	    this.data = data || null;
	    this.firstIn = firstIn || null;
	    this.firstOut = firstOut || null;
	}
	
	/**
	 *
	 * @param {Array | OLVexNode} xList 表头向量
	 * @param {Number} vexnum 有向图的当前顶点数
	 * @param {Number} arcnum 有向图的当前弧数
	 * @constructor
	 */
	function OLGraph(xList, vexnum, arcnum) {
	    this.xList = xList || [];
	    this.vexnum = vexnum || 0;
	    this.arcnum = arcnum || 0;
	}
	exports.OLGraph = OLGraph;
	OLGraph.prototype = {
	    constructor: OLGraph,
	
	    locateVex: function locateVex(vp) {
	        for (var i = 0; i < this.vexnum; ++i) {
	            if (this.xList[i].data === vp) return i;
	        }
	
	        return -1;
	    },
	
	    // 删除顶点
	    deleteVertex: function deleteVertex(v) {
	        var m = this.locateVex(v);
	
	        if (m < 0) throw new Error('vertex not found!');
	
	        var n = this.vexnum;
	        var q, i, p;
	        // 删除所有以v为头的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是头链上的第一个结点
	            if (this.xList[i].firstIn.tailVex === m) {
	                q = this.xList[i].firstIn;
	                this.xList[i].firstIn = q.hLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstIn; p && p.hLink.tailVex !== m; p = p.hLink) {}
	                if (p) {
	                    q = p.hLink;
	                    p.hLink = q.hLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 删除所有以v为尾的边
	        for (i = 0; i < n; ++i) {
	            // 如果待删除的边是尾链上的第一个结点
	            if (this.xList[i].firstOut.headVex === m) {
	                q = this.xList[i].firstOut;
	                this.xList[i].firstOut = q.tLink;
	                this.arcnum--;
	            } else {
	                for (p = this.xList[i].firstOut; p && p.tLink.headVex !== m; p = p.tLink) {}
	                if (p) {
	                    q = p.tLink;
	                    p.tLink = q.tLink;
	                    this.arcnum--;
	                }
	            }
	        }
	
	        // 顺次用结点m之后的顶点取代前一个顶点
	        for (i = m; i < n; ++i) {
	            // 修改表头向量
	            this.xList[i] = this.xList[i + 1];
	            for (p = this.xList[i].firstIn; p; p = p.hLink) {
	                p.headVex--;
	            }for (p = this.xList[i].firstOut; p; p = p.tLink) {
	                p.tailVex--;
	            }
	        }
	
	        this.vexnum--;
	        return true;
	    },
	
	    createDG: function createDG() {
	        this.vexnum = prompt('Vexnum: ');
	        this.arcnum = prompt('Arcnum: ');
	        // IncInfo为0则各弧不含其他信息
	        var incInfo = +prompt('IncInfo: ');
	
	        // 输入顶点值
	        for (var i = 0; i < this.vexnum; ++i) {
	            this.xList[i] = new OLVexNode(prompt('data: '), null, null);
	        }
	
	        for (var k = 0; k < this.arcnum; ++k) {
	            var v1 = prompt('v1: ');
	            var v2 = prompt('v2: ');
	
	            i = this.locateVex(v1);
	            var j = this.locateVex(v2);
	
	            if (i === -1 || j === -1) {
	                alert('无此顶点，请重新输入!');
	                k--;
	                continue;
	            }
	
	            var p = new ArcBox(i, j, this.xList[j].firstIn, this.xList[i].firstOut, incInfo && prompt('info: '));
	            this.xList[j].firstIn = this.xList[i].firstOut = p;
	        }
	    },
	
	    /**
	     * 求有向图的强连通分量
	     */
	    getSGraph: function getSGraph() {
	        var visited = [];
	        var finished = [];
	        var count = 0;
	
	        for (var i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第一次深度优先遍历建立finished数组
	        for (i = 0; i < this.vexnum; ++i) {
	            if (!visited[i]) dfs1(this, i);
	        }
	        // 清空visited数组
	        for (i = 0; i < this.vexnum; ++i) {
	            visited[i] = false;
	        } // 第二次逆向的深度优先遍历
	        for (var len = this.vexnum - 1; len >= 0; --len) {
	            i = finished[i];
	            if (!visited[i]) dfs2(this, i);
	        }
	
	        function dfs1(graph, v) {
	            visited[v] = true;
	            for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	                var w = p.headVex;
	                if (!visited[w]) dfs1(graph, w);
	            }
	            finished[++count] = v;
	        }
	
	        function dfs2(graph, v) {
	            visited[v] = true;
	            console.log('%d', v);
	            for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	                var w = p.tailVex;
	                if (!visited[w]) dfs2(graph, w);
	            }
	        }
	    }
	};
	
	//var g = new OLGraph();
	//g.createDG();
	//console.log(g);
	
	/*
	 有向图的强连通分量
	
	 对于有向图，在其每一个强连通分量中，任何两个顶点都是可达的。 V∈G，与V可相互到达的所有顶点就是包含V的强连通分量的所有顶点。
	
	 设从V可到达 (以V为起点的所有有向路径的终点)的顶点集合为T1(G)，而到达V (以V为终点的所有有向路径的起点)的顶点集合为T2(G)，则包含V的强连通分量的顶点集合是： T1(G)∩T2(G) 。
	
	 求有向图G的强连通分量的基本步骤是：
	 ⑴ 对G进行深度优先遍历，生成G的深度优先生成森林T。
	 ⑵  对森林T的顶点按中序遍历顺序进行编号。
	 ⑶  改变G中每一条弧的方向，构成一个新的有向图G’。
	 ⑷  按⑵中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度优先生成树。若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。在该步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。
	 ⑸  重复步骤⑷ ，直到G’中的所有顶点都被访问。
	
	 在算法实现时，建立一个数组in_order[n]存放深度优先生成森林的中序遍历序列。对每个顶点v，在调用DFS函数结束时，将顶点依次存放在数组in_order[n]中。图采用十字链表作为存储结构最合适。
	
	 */
	
	// todo to be tested
	OLGraph.prototype.connected_DG = function () {
	    var visited = [];
	    var in_order = [];
	    var count = 0;
	
	    for (var i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图正向遍历
	    for (i = 0; i < this.vexnum; ++i) {
	        if (!visited[i]) {
	            dfs(this, i, in_order);
	        }
	    }
	
	    for (i = 0; i < this.vexnum; ++i) {
	        visited[i] = false;
	    } // 对图逆向遍历
	    var k = 1;
	    for (var j = this.vexnum - 1; j >= 0; --j) {
	        var v = in_order[j];
	        if (!visited[v]) {
	            console.log('第' + k++ + '个连通分量顶点');
	            rev_dfs(this, v);
	        }
	    }
	
	    function dfs(graph, v) {
	        visited[v] = true;
	
	        for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
	            if (!visited[p.headVex]) {
	                dfs(graph, p.headVex);
	            }
	        }
	
	        in_order[count++] = v;
	    }
	
	    function rev_dfs(graph, v) {
	        visited[v] = true;
	        console.log('顶点：' + v);
	
	        for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
	            if (!visited[p.tailVex]) {
	                rev_dfs(graph, p.tailVex);
	            }
	        }
	    }
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(22);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _iterator2 = __webpack_require__(17);
	
	var _iterator3 = _interopRequireDefault(_iterator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _DoubleLinkedList = __webpack_require__(46);
	
	var _DoubleLinkedList2 = _interopRequireDefault(_DoubleLinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIMIT = 20; /**
	                 * LRU( Least recently used )
	                 */
	
	var LRUCache = function () {
	    function LRUCache(sqList) {
	        var limit = arguments.length <= 1 || arguments[1] === undefined ? LIMIT : arguments[1];
	        (0, _classCallCheck3.default)(this, LRUCache);
	
	        this.limit = limit;
	        sqList = sqList && sqList.length ? sqList && sqList.length.slice(0, this.limit) : [];
	        this.__cache = new _DoubleLinkedList2.default(sqList, function (a, b) {
	            return a.key === b.key;
	        });
	    }
	
	    (0, _createClass3.default)(LRUCache, [{
	        key: _iterator3.default,
	        value: function value() {
	            return (0, _getIterator3.default)(this.__cache);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            return this.__cache.remove({ key: key });
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            return this.___cache.clear();
	        }
	    }, {
	        key: 'get',
	        value: function get(key) {
	            var index = this.__cache.indexOf({ key: key });
	
	            if (index >= 0) {
	                var data = this.__cache.findByIndex(index);
	                this.__cache.remove(data);
	                this.__cache.unshift(data);
	
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'add',
	        value: function add(key, value) {
	            var data = this.get(key);
	            if (data) {
	                data.value = value;
	            } else {
	                if (this.size === this.limit) {
	                    this.__cache.pop();
	                }
	
	                this.__cache.unshift({
	                    key: key,
	                    value: value
	                });
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var arr = [];
	            this.__cache.forEach(function (data) {
	                arr.push(data.key + ':' + data.value);
	            });
	
	            return arr.join(' > ');
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            return this.__cache.toJSON();
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.__cache.size;
	        }
	    }]);
	    return LRUCache;
	}();
	
	exports.default = LRUCache;
	
	
	console.log('LRUCache');
	
	var a = new LRUCache([], 3);
	a.add('adam', 29);
	a.add('john', 26);
	a.add('angela', 24);
	console.log(a + '');
	a.get('john');
	console.log(a + '');
	a.add('zorro', 141);
	console.log(a + '');
	console.log(a.toJSON());
	
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;
	
	try {
	    for (var _iterator = (0, _getIterator3.default)(a), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var item = _step.value;
	
	        console.log(item);
	    }
	} catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	} finally {
	    try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	        }
	    } finally {
	        if (_didIteratorError) {
	            throw _iteratorError;
	        }
	    }
	}
	
	a.remove('zorro');
	a.remove('john');
	a.remove('angela');
	console.log(a + '');
	
	console.log('LRUCacheEnd');

/***/ },
/* 77 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.union = union;
	exports.mergeList = mergeList;
	exports.insert = insert;
	exports.del = del;
	exports.listComp = listComp;
	exports.reverse = reverse;
	exports.intersect = intersect;
	exports.intersect_true = intersect_true;
	exports.intersect_delete = intersect_delete;
	/**
	 * 线性表
	 */
	
	// 线性表的类型定义
	// 将所有在数组b中但不在数组a的数据元素插入到a中
	
	var a = [1, 2, 3, 4, 5];
	var b = [1, 3, 5, 7, 9];
	
	function union(a, b) {
	    var elem, equal;
	
	    for (var i = 0, bLen = b.length; i < bLen; i++) {
	        elem = b[i];
	        equal = false;
	
	        for (var j = 0, aLen = a.length; j < aLen; j++) {
	            if (elem === a[j]) {
	                equal = true;
	                break;
	            }
	        }
	
	        if (!equal) a.push(elem);
	    }
	}
	
	union(a, b);
	console.log(a);
	// [1, 2, 3, 4, 5, 7, 9]
	
	// 时间复杂度：O(aLen * bLen)
	
	// 已知数组a和数组b中的数据元素按值非递减排列
	// 归并a和b得到新的数组c，c的数据元素也按值非递减排列
	var a = [3, 5, 8, 11];
	var b = [2, 6, 8, 9, 11, 15, 20];
	
	function mergeList(a, b) {
	    var c = [],
	        aElem,
	        bElem;
	    var i = 0,
	        j = 0,
	        k = 0;
	    var aLen = a.length;
	    var bLen = b.length;
	
	    while (i < aLen && j < bLen) {
	        aElem = a[i];
	        bElem = b[j];
	
	        if (aElem < bElem) {
	            c[k++] = aElem;
	            i++;
	        } else {
	            c[k++] = bElem;
	            j++;
	        }
	    }
	
	    while (i < aLen) {
	        c[k++] = a[i++];
	    }
	
	    while (j < bLen) {
	        c[k++] = b[j++];
	    }
	
	    return c;
	}
	
	var c = mergeList(a, b);
	console.log(c);
	// [2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20]
	
	// 时间复杂度： O(aLen + bLen)
	
	// 线性表的顺序表示和实现
	// 使用伪数组模拟线性表插入操作的前后数据元素在存储空间中的位置变化
	var a = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 };
	a.length = 6;
	
	function insert(a, i, elem) {
	    if (!elem) return;
	
	    var len = a.length;
	    if (i >= len) {
	        while (len < i) {
	            a[len++] = undefined;
	            a.length++;
	        }
	        a[i] = elem;
	    } else {
	        while (len > i) {
	            a[len--] = a[len];
	        }
	        a[i] = elem;
	    }
	    a.length++;
	}
	
	insert(a, 3, 8);
	insert(a, 10, 10);
	console.log(a);
	
	// 使用伪数组模拟线性表删除操作的前后数据元素在存储空间中的位置变化
	
	function del(a, i) {
	    var temp = a[i];
	    var j = i + 1;
	    var len = a.length;
	
	    while (j < len) {
	        a[j - 1] = a[j++];
	    }
	    a.length--;
	    delete a[len - 1];
	
	    return temp;
	}
	
	del(a, 3);
	console.log(a);
	del(a, 10);
	console.log(a);
	
	// 时间复杂度： O(a.length)
	
	// 比较字符表A和B，并用返回值表示结果，值为1，表示A>B，值为-1，表示A<B，值为0，表示A=B
	function listComp(aList, bList) {
	    for (var i = 0; i < aList.length && i < bList.length; i++) {
	        if (aList[i] !== bList[i]) return aList[i] > bList[i] ? 1 : -1;
	    }
	
	    if (aList.length == bList.length) return 0;
	
	    return aList.length > bList.length ? 1 : -1;
	}
	
	function reverse(list) {
	    for (var i = 0, j = list.length - 1; i <= j; i++, j--) {
	        var temp = list[i];
	        list[i] = list[j];
	        list[j] = temp;
	    }
	}
	
	// 求元素递增排列的线性表A和B的元素的交集并存入C
	function intersect(aList, bList) {
	    var cList = [];
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (aList[i] && bList[j]) {
	        if (aList[i] < bList[j]) i++;else if (aList[i] > bList[j]) j++;else {
	            cList[k++] = aList[i];
	            i++;
	            j++;
	        }
	    }
	
	    return cList;
	}
	
	console.log(intersect([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// 求元素递增排列的线性表A和B的元素的交集并存入回a
	function intersect_true(a, b) {
	    var i = 0,
	        j = 0,
	        k = 0;
	
	    while (a[i] && b[j]) {
	        if (a[i] < b[j]) i++;else if (a[i] > b[j]) j++;else {
	            a[k++] = a[i];
	            i++;
	            j++;
	        }
	    }
	
	    while (a[k]) {
	        a.splice(k, 1);
	    }return a;
	}
	
	console.log(intersect_true([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');
	
	// a，b，c的元素均是非递减排列
	// 求a数组中非b数组和c数组的交集的元素。
	function intersect_delete(a, b, c) {
	    var i = 0,
	        j = 0,
	        k = 0,
	        m = 0;
	
	    while (i < a.length && j < b.length && k < c.length) {
	        if (b[j] < c[k]) j++;else if (b[j] > c[k]) k++;else {
	            // 找到了相同元素same
	            var same = b[j];
	
	            // j，k后移到新的元素
	            while (b[j] === same) {
	                j++;
	            }while (c[k] === same) {
	                k++;
	            } // 需保留的元素移动到新位置
	            while (i < a.length && a[i] < same) {
	                a[m++] = a[i++];
	            } // 跳过相同的元素
	            while (i < a.length && a[i] === same) {
	                i++;
	            }
	        }
	    }
	
	    // a的剩余元素重新存储
	    while (i < a.length) {
	        a[m++] = a[i++];
	    }a.length = m;
	
	    return a;
	}
	
	console.log(intersect_delete([1, 2, 3, 4, 5, 6, 9], [1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by ldp on 2015/1/19.
	 */
	
	// 循环队列
	
	var CycleQueue = function () {
	    function CycleQueue() {
	        var maxsize = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
	        (0, _classCallCheck3.default)(this, CycleQueue);
	
	        this.base = {};
	        this.front = this.rear = 0;
	        this.MAXQSIZE = maxsize;
	    }
	
	    (0, _createClass3.default)(CycleQueue, [{
	        key: 'enQueue',
	        value: function enQueue(data) {
	            if ((this.rear + 1) % this.MAXQSIZE === 0) throw new Error('cycleQueue is already full!');
	
	            this.base[this.rear] = data;
	            this.rear = (this.rear + 1) % this.MAXQSIZE;
	        }
	    }, {
	        key: 'deQueue',
	        value: function deQueue() {
	            if (this.front === this.rear) throw new Error('cycleQueue is already empty');
	
	            var elem = this.base[this.front];
	            this.front = (this.front + 1) % this.MAXQSIZE;
	
	            return elem;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.base = {};
	            this.front = this.rear = 0;
	        }
	    }, {
	        key: 'peekAt',
	        value: function peekAt() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	            index = (index + this.MAXQSIZE) % this.MAXQSIZE;
	
	            return this.base[index + this.front] || null;
	        }
	    }, {
	        key: 'getHead',
	        value: function getHead() {
	            var elem = this.base[this.front];
	            return elem ? elem : null;
	        }
	    }, {
	        key: 'queueTraverse',
	        value: function queueTraverse(iterator) {
	            for (var i = this.front, len = this.rear = this.front; i < len; i++) {
	                if (iterator(this.base[i], i)) break;
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var base = [].slice.call(this.base);
	
	            return base.slice(this.front, this.rear - this.front);
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return (this.rear - this.front + this.MAXQSIZE) % this.MAXQSIZE;
	        }
	    }]);
	    return CycleQueue;
	}();
	
	exports.default = CycleQueue;
	
	
	var queue = new CycleQueue();
	queue.enQueue(1);
	queue.deQueue();
	queue.enQueue(2);
	queue.enQueue(3);
	console.log(queue.peekAt(0));
	console.log(queue.peekAt(1));
	console.log(queue.peekAt(2));

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/2/26.
	 */
	
	/*
	优先队列(priority queue)
	
	普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。
	
	优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.
	
	
	入队操作
	①：完全二叉树的构建操作是“从上到下，从左到右”的形式，所以入队的节点是放在数组的最后，也就是树中叶子层的有序最右边空位。
	②：当节点插入到最后时，有可能破坏了堆的性质，此时我们要进行“上滤操作”，当然时间复杂度为O(lgN)。
	
	出队操作
	出队操作时，我们采取的方案是：弹出堆顶元素，然后将叶子层中的最右子节点赋给堆顶，同样这时也会可能存在破坏堆的性质，最后我们要被迫进行下滤操作。
	 */
	
	// 用堆实现优先队列
	
	var PriorityQueue = function () {
	    function PriorityQueue() {
	        (0, _classCallCheck3.default)(this, PriorityQueue);
	
	        this.heap = [];
	    }
	
	    (0, _createClass3.default)(PriorityQueue, [{
	        key: 'enQueue',
	        value: function enQueue(value) {
	            var priority = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	            if (typeof value === 'undefined') throw new Error('argument required');
	
	            // 将当前节点追加到堆尾
	            this.heap.push({
	                value: value,
	                priority: priority
	            });
	
	            // 如果只有一个节点，则不需要进行筛选操作
	            if (this.heap.length === 1) return;
	
	            // 获取最后一个非叶子节点，并进行堆调整
	            upHeapAdjust(this.heap, (this.heap.length >> 1) - 1);
	        }
	    }, {
	        key: 'deQueue',
	        value: function deQueue() {
	            if (!this.heap.length) return null;
	
	            var heap = this.heap;
	            // 出队列操作，弹出数据头元素
	            var data = heap[0];
	            // 用尾元素填充头元素
	            heap[0] = heap[heap.length - 1];
	            // 删除尾节点
	            heap.pop();
	
	            //然后从根节点下滤堆
	            downHeapAdjust(heap, 0);
	
	            return data;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.heap = [];
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this.heap.length;
	        }
	    }]);
	    return PriorityQueue;
	}();
	
	// 对堆进行上滤操作，使得满足堆性质
	
	
	exports.default = PriorityQueue;
	function upHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (parent >= 0) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        // 如果parent节点小于它的某个子节点的话，此时筛选操作
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            // 继续进行更上一层的过滤
	            parent = Math.ceil(parent / 2) - 1;
	        } else break;
	    }
	}
	
	// 对堆进行下滤操作，使得满足堆性质
	function downHeapAdjust(heap, parent) {
	    var len = heap.length;
	
	    while (2 * parent + 1 < len) {
	        var leftChild = 2 * parent + 1;
	        var rightChild = leftChild + 1;
	        var max = leftChild;
	
	        if (rightChild < len) {
	            max = heap[leftChild].priority < heap[rightChild].priority ? rightChild : leftChild;
	        }
	
	        if (heap[parent].priority < heap[max].priority) {
	            var temp = heap[parent];
	            heap[parent] = heap[max];
	            heap[max] = temp;
	
	            parent = max;
	        } else break;
	    }
	}
	
	var test = new PriorityQueue();
	test.enQueue(8, 5);
	test.enQueue(7, 2);
	test.enQueue(6, 1);
	test.enQueue(5, 4);
	test.enQueue(4, 7);
	test.enQueue(3, 3);
	test.enQueue(2, 8);
	test.enQueue(1, 10);
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());
	console.log(test.deQueue());

/***/ },
/* 80 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * AVL TREE Class
	 *
	 * @author Brice Chevalier
	 *
	 *
	 * @desc
	 *
	 *    Method                Time Complexity
	 *    ___________________________________
	 *
	 *    add                    O(log2(n))
	 *    remove                O(log2(n))
	 *    getFirst            O(1)
	 *    getLast                O(1)
	 *    getCount            O(1)
	 *    apply                O(n)
	 *    clear                O(n)
	 *
	 *    Memory Complexity in O(n)
	 */
	
	function Node(obj) {
	    this.object = obj;
	    this.height = 1;
	    this.left = null;
	    this.right = null;
	    this.previous = null;
	    this.next = null;
	    this.parent = null;
	}
	
	function AvlTree() {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	}
	AvlTree.cmp = function (a, b) {
	    if (a > b) return 1;else if (a < b) return -1;else return 0;
	};
	
	AvlTree.prototype._addLeft = function (node, parent) {
	    node.previous = parent.previous;
	    node.next = parent;
	    node.parent = parent;
	
	    parent.left = node;
	    parent.previous = node;
	
	    if (node.previous) {
	        node.previous.next = node;
	    }
	
	    if (parent === this.first) {
	        this.first = node;
	    }
	};
	
	AvlTree.prototype._addRight = function (node, parent) {
	    node.previous = parent;
	    node.next = parent.next;
	    node.parent = parent;
	
	    parent.right = node;
	    parent.next = node;
	
	    if (node.next) {
	        node.next.previous = node;
	    }
	
	    if (parent === this.last) {
	        this.last = node;
	    }
	};
	
	AvlTree.prototype.add = function (obj) {
	    this.count += 1;
	    var newNode = new Node(obj);
	
	    if (this.root === null) {
	        this.root = newNode;
	        this.first = this.root;
	        this.last = this.root;
	        return newNode;
	    }
	
	    var current = this.root;
	
	    while (true) {
	
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            // Adding to the left
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else {
	                current = current.left;
	            }
	        } else if (cmp > 0) {
	            // Adding to the right
	            if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                current = current.right;
	            }
	        } else {
	            if (current.left === null) {
	                this._addLeft(newNode, current);
	                break;
	            } else if (current.right === null) {
	                this._addRight(newNode, current);
	                break;
	            } else {
	                if (current.right.height < current.left.height) {
	                    current = current.right;
	                } else {
	                    current = current.left;
	                }
	            }
	        }
	    }
	
	    this._balance(newNode.parent);
	
	    return newNode;
	};
	
	AvlTree.prototype._balanceLeftRight = function (node) {
	    var left = node.left;
	    var a = left.left;
	    var b = left.right.left;
	
	    left.right.left = left;
	    node.left = left.right;
	    left = node.left;
	    left.parent = node;
	
	    var leftLeft = left.left;
	    leftLeft.parent = left;
	    leftLeft.left = a;
	    leftLeft.right = b;
	    if (a !== null) {
	        a.parent = leftLeft;
	    }
	    if (b !== null) {
	        b.parent = leftLeft;
	    }
	
	    left.height = leftLeft.height + 1;
	};
	
	AvlTree.prototype._balanceLeftLeft = function (node) {
	    var left = node.left;
	    var c = left.right;
	
	    if (node === this.root) {
	        this.root = left;
	    } else {
	        if (node.parent.right === node) {
	            node.parent.right = left;
	        } else {
	            node.parent.left = left;
	        }
	    }
	
	    left.right = node;
	    left.parent = node.parent;
	    node.parent = left;
	    node.left = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balanceRightLeft = function (node) {
	    var right = node.right;
	    var a = right.right;
	    var b = right.left.right;
	
	    right.left.right = right;
	    node.right = right.left;
	    right = node.right;
	    right.parent = node;
	
	    var rightRight = right.right;
	    rightRight.parent = right;
	    rightRight.right = a;
	    rightRight.left = b;
	    if (a !== null) {
	        a.parent = rightRight;
	    }
	    if (b !== null) {
	        b.parent = rightRight;
	    }
	
	    node.right.height = rightRight.height + 1;
	};
	
	AvlTree.prototype._balanceRightRight = function (node) {
	    var right = node.right;
	    var c = right.left;
	
	    if (node === this.root) {
	        this.root = right;
	    } else {
	        if (node.parent.left === node) {
	            node.parent.left = right;
	        } else {
	            node.parent.right = right;
	        }
	    }
	
	    right.left = node;
	    right.parent = node.parent;
	    node.parent = right;
	    node.right = c;
	    if (c !== null) {
	        c.parent = node;
	    }
	
	    node.height = node.height - 1;
	};
	
	AvlTree.prototype._balance = function (node) {
	    // Balancing the tree
	    var current = node;
	    while (current !== null) {
	        var leftHeight = current.left === null ? 0 : current.left.height;
	        var rightHeight = current.right === null ? 0 : current.right.height;
	        var newHeight = 1 + Math.max(leftHeight, rightHeight);
	
	        if (newHeight > current.height) {
	            current.height = newHeight;
	            if (leftHeight - rightHeight > 1) {
	
	                // Left case
	                if (current.left.right !== null && (current.left.left === null || current.left.left.height < current.left.right.height)) {
	                    // Left Right Case
	                    this._balanceLeftRight(current);
	                }
	
	                // Left Left Case
	                this._balanceLeftLeft(current);
	
	                // The tree has been balanced
	                break;
	            } else if (rightHeight - leftHeight > 1) {
	
	                // Right case
	                if (current.right.left !== null && (current.right.right === null || current.right.right.height < current.right.left.height)) {
	                    // Right Left Case
	                    this._balanceRightLeft(current);
	                }
	
	                // Right Right Case
	                this._balanceRightRight(current);
	
	                // The tree has been balanced
	                break;
	            } else {
	                // Node is balanced
	                current = current.parent;
	            }
	        } else {
	            break;
	        }
	    }
	};
	
	AvlTree.prototype.remove = function (obj) {
	    this._remove(obj, this.root);
	};
	
	AvlTree.prototype._remove = function (obj, node) {
	    var current = node;
	
	    while (current !== null) {
	        var cmp = AvlTree.cmp(obj, current.object);
	        if (cmp < 0) {
	            current = current.left;
	        } else if (cmp > 0) {
	            current = current.right;
	        } else {
	            if (obj === current.object) {
	
	                // Node removal
	                this.count -= 1;
	
	                if (current.previous === null) {
	                    this.first = current.next;
	                } else {
	                    current.previous.next = current.next;
	                }
	                if (current.next === null) {
	                    this.last = current.previous;
	                } else {
	                    current.next.previous = current.previous;
	                }
	
	                // Replacing the node by the smallest element greater than it
	                var parent = current.parent;
	                var left = current.left;
	                var right = current.right;
	
	                if (current.right === null) {
	                    if (parent === null) {
	                        this.root = left;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = left;
	                        } else {
	                            parent.left = left;
	                        }
	                    }
	
	                    if (left !== null) {
	                        left.parent = parent;
	                    }
	
	                    this._balance(parent);
	                    return 1;
	                }
	
	                var replacement = current.right;
	                var balanceFrom;
	
	                if (replacement.left === null) {
	                    balanceFrom = replacement;
	
	                    if (left !== null) {
	                        left.parent = replacement;
	                    }
	                    replacement.left = left;
	
	                    if (parent === null) {
	                        this.root = replacement;
	                    } else {
	                        if (parent.right === current) {
	                            parent.right = replacement;
	                        } else {
	                            parent.left = replacement;
	                        }
	                    }
	                    replacement.parent = parent;
	
	                    this._balance(balanceFrom);
	
	                    return 1;
	                }
	
	                replacement = replacement.left;
	                while (replacement.left !== null) {
	                    replacement = replacement.left;
	                }
	
	                if (replacement.right !== null) {
	                    replacement.right.parent = replacement.parent;
	                }
	                replacement.parent.left = replacement.right;
	
	                if (right !== null) {
	                    right.parent = replacement;
	                }
	                replacement.right = right;
	
	                balanceFrom = replacement.parent;
	
	                if (left !== null) {
	                    left.parent = replacement;
	                }
	                replacement.left = left;
	
	                if (parent === null) {
	                    this.root = replacement;
	                } else {
	                    if (parent.right === current) {
	                        parent.right = replacement;
	                    } else {
	                        parent.left = replacement;
	                    }
	                }
	                replacement.parent = parent;
	
	                this._balance(balanceFrom);
	
	                return 1;
	            } else {
	                if (!this._remove(obj, current.left)) {
	                    this._remove(obj, current.right);
	                }
	            }
	        }
	    }
	
	    return 0;
	};
	
	AvlTree.prototype.removeByRef = function (node) {
	    // Node removal
	    this.count -= 1;
	
	    if (node.previous === null) {
	        this.first = node.next;
	    } else {
	        node.previous.next = node.next;
	    }
	    if (node.next === null) {
	        this.last = node.previous;
	    } else {
	        node.next.previous = node.previous;
	    }
	
	    // Replacing the node by the smallest element greater than it
	    var parent = node.parent;
	    var left = node.left;
	    var right = node.right;
	
	    if (node.right === null) {
	        if (parent === null) {
	            this.root = left;
	        } else {
	            if (parent.right === node) {
	                parent.right = left;
	            } else {
	                parent.left = left;
	            }
	        }
	
	        if (left !== null) {
	            left.parent = parent;
	        }
	
	        this._balance(parent);
	        return 1;
	    }
	
	    var replacement = node.right;
	    var balanceFrom;
	
	    if (replacement.left === null) {
	        balanceFrom = replacement;
	
	        if (left !== null) {
	            left.parent = replacement;
	        }
	        replacement.left = left;
	
	        if (parent === null) {
	            this.root = replacement;
	        } else {
	            if (parent.right === node) {
	                parent.right = replacement;
	            } else {
	                parent.left = replacement;
	            }
	        }
	        replacement.parent = parent;
	
	        this._balance(balanceFrom);
	
	        return 1;
	    }
	
	    replacement = replacement.left;
	    while (replacement.left !== null) {
	        replacement = replacement.left;
	    }
	
	    if (replacement.right !== null) {
	        replacement.right.parent = replacement.parent;
	    }
	    replacement.parent.left = replacement.right;
	
	    if (right !== null) {
	        right.parent = replacement;
	    }
	    replacement.right = right;
	
	    balanceFrom = replacement.parent;
	
	    if (left !== null) {
	        left.parent = replacement;
	    }
	    replacement.left = left;
	
	    if (parent === null) {
	        this.root = replacement;
	    } else {
	        if (parent.right === node) {
	            parent.right = replacement;
	        } else {
	            parent.left = replacement;
	        }
	    }
	    replacement.parent = parent;
	
	    this._balance(balanceFrom);
	
	    return 1;
	};
	
	AvlTree.prototype.getFirst = function () {
	    return this.first;
	};
	
	AvlTree.prototype.getLast = function () {
	    return this.last;
	};
	
	AvlTree.prototype.getHeight = function () {
	    return this.root.height;
	};
	
	AvlTree.prototype.getRoot = function () {
	    return this.root;
	};
	
	AvlTree.prototype.getCount = function () {
	    return this.count;
	};
	
	AvlTree.prototype.forEach = function (processingFunc, params) {
	    for (var current = this.first; current; current = current.next) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.forEachReverse = function (processingFunc, params) {
	    for (var current = this.last; current; current = current.previous) {
	        processingFunc(current.object, params);
	    }
	};
	
	AvlTree.prototype.clear = function () {
	    this.count = 0;
	    this.root = null;
	    this.first = null;
	    this.last = null;
	};
	
	module.exports = AvlTree;
	
	console.log('\nAVL tree insert2: ');
	var test = new AvlTree();
	test.add(3);
	test.add(14);
	test.add(25);
	test.add(81);
	test.add(44);
	
	/*
	 14
	 /    \
	 3       44
	 /   \
	 25     81
	 */
	
	console.log('remove_Recursive 2:');
	
	test.remove(81);
	test.remove(3);
	test.remove(14);
	test.remove(25);
	test.remove(44);
	
	var str = 'cknobfjtlpqaegrmdhs';
	//var str = 'ckbfjlaegmdh';
	
	test = new AvlTree();
	for (var i = 0; i < str.length; ++i) {
	    test.add(str[i]);
	}
	
	test.remove('e');
	test.remove('h');
	test.remove('b');
	test.remove('l');
	test.remove('f');
	test.remove('j');
	test.remove('g');
	test.remove('d');
	test.remove('k');
	test.remove('a');
	test.remove('m');
	test.remove('n');
	test.remove('o');
	test.remove('p');
	test.remove('q');
	test.remove('r');
	test.remove('s');
	test.remove('t');
	test.remove('c');

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	var _create = __webpack_require__(51);
	
	var _create2 = _interopRequireDefault(_create);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 MIT License
	 Copyright (c) 2012 Santanu Basu
	 Copyright (c) 2013 Daniel Wirtz
	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:
	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.
	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	// Based on Santanu Basu's BPlusJS
	// https://github.com/santanubasu/BPlusJS
	// Modified for stand-alone use
	
	/**
	 * @license BTree.js
	 * Released under the MIT License
	 * see: https://github.com/dcodeIO/BTree.js for details
	 */
	(function (global) {
	
	    function isDefined(v) {
	        return typeof v != 'undefined';
	    }
	
	    var Node = function Node(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.data = [];
	    };
	
	    Node.prototype.getLeftPeer = function () {
	        return this.leftPeer;
	    };
	
	    Node.prototype.setLeftPeer = function (leftPeer) {
	        this.leftPeer = leftPeer;
	    };
	
	    Node.prototype.getRightPeer = function () {
	        return this.rightPeer;
	    };
	
	    Node.prototype.setRightPeer = function (rightPeer) {
	        this.rightPeer = rightPeer;
	    };
	
	    Node.prototype.getData = function () {
	        return this.data;
	    };
	
	    Node.prototype.getSurplus = function () {
	        return Math.max(0, Math.floor((this.data.length - this.mergeThreshold) / 2));
	    };
	
	    Node.prototype.getRightSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(this.data.length - surplus);
	    };
	
	    Node.prototype.getLeftSurplusData = function () {
	        var surplus = this.getSurplus();
	        return this.data.splice(0, surplus);
	    };
	
	    var InternalNode = function InternalNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    InternalNode.prototype = (0, _create2.default)(Node.prototype);
	
	    InternalNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        var left = 0;
	        var right = data.length - 1;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left < right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return right;
	        }
	    };
	
	    InternalNode.prototype.findChild = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        if (element.key <= key) {
	            child = element.right;
	        } else {
	            child = element.left;
	        }
	        return child;
	    };
	
	    InternalNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var child;
	        var newNodes, leftElement, rightElement;
	        if (element.key <= key) {
	            child = element.right;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: element.key,
	                    left: element.left,
	                    right: newNodes[0]
	                };
	                rightElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        } else {
	            child = element.left;
	            newNodes = child.insert(key, value, clobber);
	            if (newNodes.length == 3) {
	                leftElement = {
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                };
	                rightElement = {
	                    key: element.key,
	                    left: newNodes[2],
	                    right: element.right
	                };
	                this.data.splice(index, 1, leftElement, rightElement);
	                return this.split();
	            }
	        }
	        return newNodes;
	    };
	
	    InternalNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new InternalNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new InternalNode({
	            data: this.data.slice(splitIndex + 1, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    InternalNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        var mergeIndex = -1;
	        var child;
	        var retval;
	        if (element.key <= key) {
	            child = element.right;
	            retval = child.remove(key, element.left, index < this.data.length - 1 ? child.getRightPeer() : undefined);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index + 1;
	                } else {
	                    mergeIndex = index;
	                }
	            }
	        } else {
	            child = element.left;
	            retval = child.remove(key, index > 0 ? child.getLeftPeer() : undefined, element.right);
	            if (this.data.length == 1 && retval.length == 4) {
	                return [retval[0], retval[3]];
	            }
	            if (retval.length > 1) {
	                if (retval[1] == 1) {
	                    mergeIndex = index;
	                } else {
	                    mergeIndex = index - 1;
	                }
	            }
	        }
	        if (mergeIndex >= 0) {
	            var mergeElement = this.data[mergeIndex];
	            if (retval.length == 5) {
	                mergeElement.key = retval[3];
	                return [retval[0]];
	            } else {
	                if (mergeIndex > 0) {
	                    this.data[mergeIndex - 1].right = retval[3];
	                }
	                if (mergeIndex < this.data.length - 1) {
	                    this.data[mergeIndex + 1].left = retval[3];
	                }
	                this.data.splice(mergeIndex, 1);
	                return [retval[0]].concat(this.merge(leftMergeOption, rightMergeOption));
	            }
	        } else {
	            return [retval[0]];
	        }
	    };
	
	    InternalNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.slice(1).concat([{
	                key: this.data[0].left.getData()[0].key,
	                left: leftSurplusData[leftSurplusData.length - 1].right,
	                right: this.data[0].left
	            }], this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = leftSurplusData[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat([{
	                key: rightSurplusData[0].left.getData()[0].key,
	                left: this.data[this.data.length - 1].right,
	                right: rightSurplusData[0].left
	            }], rightSurplusData.slice(0, rightSurplusData.length - 1));
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightSurplusData[rightSurplusData.length - 1].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedInternalNode;
	            if (!isDefined(leftData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat([{
	                        key: rightData[0].left.getData()[0].key,
	                        left: this.data[this.data.length - 1].right,
	                        right: rightData[0].left
	                    }], rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedInternalNode = new InternalNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat([{
	                        key: this.data[0].left.getData()[0].key,
	                        left: leftData[leftData.length - 1].right,
	                        right: this.data[0].left
	                    }], this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedInternalNode.getData()[0].key;
	                retval[2] = mergedInternalNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
	                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedInternalNode);
	                    mergedInternalNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    InternalNode.prototype.find = function (key) {
	        return this.findChild(key).find(key);
	    };
	
	    InternalNode.prototype.range = function (start, end) {
	        return this.findChild(start).range(start, end);
	    };
	
	    InternalNode.prototype.toString = function (indent) {
	        return this.data.map(function (element) {
	            return [indent + "[key=" + element.key, "\n" + indent + "    LEFT\n" + element.left.toString(indent + "    "), "\n" + indent + "    RIGHT\n" + element.right.toString(indent + "    ") + "\n" + indent + "]"];
	        }).join(",\n");
	    };
	
	    var LeafNode = function LeafNode(options) {
	        Node.call(this, options);
	        this.data = options.data;
	        this.leftPeer = options.leftPeer;
	        this.rightPeer = options.rightPeer;
	    };
	
	    LeafNode.prototype = (0, _create2.default)(Node.prototype);
	
	    LeafNode.prototype.findIndex = function (key) {
	        var data = this.data;
	        if (data.length == 0) {
	            return 0;
	        }
	        var left = 0;
	        var right = data.length;
	        var mid = left + Math.floor((right - left) / 2);
	        var found = false;
	        do {
	            mid = left + Math.floor((right - left) / 2);
	            if (data[mid].key < key) {
	                left = mid + 1;
	            } else if (data[mid].key > key) {
	                right = mid;
	            } else {
	                found = true;
	            }
	        } while (left !== right && !found);
	        if (found) {
	            return mid;
	        } else {
	            return left;
	        }
	    };
	
	    LeafNode.prototype.insert = function (key, value, clobber) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index == this.data.length) {
	            this.data.push({
	                key: key,
	                value: value
	            });
	        } else if (element.key === key) {
	            if (clobber) {
	                element.value = value;
	            } else {
	                return [element.value];
	            }
	            // This condition may never occur, given the way findIndex is written
	        } else if (element.key < key) {
	                this.data.splice(index + 1, 0, {
	                    key: key,
	                    value: value
	                });
	            } else {
	                this.data.splice(index, 0, {
	                    key: key,
	                    value: value
	                });
	            }
	        return this.split();
	    };
	
	    LeafNode.prototype.split = function () {
	        if (this.data.length < this.order) {
	            return [];
	        }
	        var splitIndex = Math.floor(this.data.length / 2);
	        var leftNode = new LeafNode({
	            data: this.data.slice(0, splitIndex),
	            leftPeer: this.leftPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        var rightNode = new LeafNode({
	            data: this.data.slice(splitIndex, this.data.length),
	            rightPeer: this.rightPeer,
	            order: this.order,
	            mergeThreshold: this.mergeThreshold
	        });
	        leftNode.setRightPeer(rightNode);
	        rightNode.setLeftPeer(leftNode);
	        if (isDefined(this.leftPeer)) {
	            this.leftPeer.setRightPeer(leftNode);
	        }
	        if (isDefined(this.rightPeer)) {
	            this.rightPeer.setLeftPeer(rightNode);
	        }
	        return [leftNode, this.data[splitIndex].key, rightNode];
	    };
	
	    LeafNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            this.data.splice(index, 1);
	            return [element.value].concat(this.merge(leftMergeOption, rightMergeOption));
	        } else {
	            return [undefined];
	        }
	    };
	
	    LeafNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
	        if (this.data.length > this.mergeThreshold) {
	            return [];
	        }
	        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
	            return [];
	        }
	        var retval = [];
	        // var deficit = true;
	        var leftSurplus = 0;
	        var leftData;
	        var rightSurplus = 0;
	        var rightData;
	        var leftPeer = this.leftPeer;
	        var rightPeer = this.rightPeer;
	        if (isDefined(leftMergeOption)) {
	            leftData = leftMergeOption.getData();
	            leftSurplus = leftMergeOption.getSurplus();
	        }
	        if (isDefined(rightMergeOption)) {
	            rightData = rightMergeOption.getData();
	            rightSurplus = rightMergeOption.getSurplus();
	        }
	        if (leftSurplus > rightSurplus) {
	            var leftSurplusData = leftMergeOption.getRightSurplusData();
	            this.data = leftSurplusData.concat(this.data);
	            retval[0] = -1;
	            retval[1] = leftMergeOption;
	            retval[2] = this.data[0].key;
	            retval[3] = this;
	        } else if (rightSurplus > leftSurplus) {
	            var rightSurplusData = rightMergeOption.getLeftSurplusData();
	            this.data = this.data.concat(rightSurplusData);
	            retval[0] = 1;
	            retval[1] = this;
	            retval[2] = rightMergeOption.getData()[0].key;
	            retval[3] = rightMergeOption;
	        } else {
	            var mergedLeafNode;
	            if (!isDefined(leftData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else if (!isDefined(rightData)) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            } else if (rightData.length < leftData.length) {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: this.data.concat(rightData)
	                });
	                retval[0] = 1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
	                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
	                }
	                if (isDefined(leftPeer)) {
	                    leftPeer.setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer);
	                }
	            } else {
	                mergedLeafNode = new LeafNode({
	                    order: this.order,
	                    mergeThreshold: this.mergeThreshold,
	                    data: leftData.concat(this.data)
	                });
	                retval[0] = -1;
	                retval[1] = mergedLeafNode.getData()[0].key;
	                retval[2] = mergedLeafNode;
	                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
	                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
	                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
	                }
	                if (isDefined(rightPeer)) {
	                    rightPeer.setLeftPeer(mergedLeafNode);
	                    mergedLeafNode.setRightPeer(rightPeer);
	                }
	            }
	        }
	        return retval;
	    };
	
	    LeafNode.prototype.find = function (key) {
	        var index = this.findIndex(key);
	        var element = this.data[index];
	        if (index < this.data.length && element.key === key) {
	            return element.value;
	        }
	    };
	
	    LeafNode.prototype.range = function (start, end) {
	        var node = this;
	        var range = [];
	        while (isDefined(node)) {
	            var startIndex = node.findIndex(start);
	            var endIndex = node.findIndex(end);
	            var nodeData = node.getData();
	            if (startIndex < nodeData.length) {
	                for (var i = startIndex; i < endIndex; i++) {
	                    range.push(nodeData[i].value);
	                }
	            }
	            if (endIndex == nodeData.length) {
	                node = node.getRightPeer();
	            } else {
	                break;
	            }
	        }
	        return range;
	    };
	
	    LeafNode.prototype.toString = function (indent) {
	        return indent + "[" + this.data.map(function (element) {
	            return element.key;
	        }).toString() + "]";
	    };
	
	    var Tree = function Tree(options) {
	        options = options || {};
	        this.order = options.order || 100;
	        this.mergeThreshold = options.mergeThreshold || 40;
	        this.root = new LeafNode({
	            order: this.order,
	            mergeThreshold: this.mergeThreshold,
	            data: []
	        });
	    };
	
	    Tree.prototype.toString = function () {
	        return this.root.toString("");
	    };
	
	    Tree.prototype.insert = function (key, value, clobber) {
	        var newNodes = this.root.insert(key, value, clobber);
	        if (newNodes.length == 3) {
	            this.root = new InternalNode({
	                order: this.order,
	                mergeThreshold: this.mergeThreshold,
	                data: [{
	                    key: newNodes[1],
	                    left: newNodes[0],
	                    right: newNodes[2]
	                }]
	            });
	        } else if (newNodes.length == 1) {
	            return newNodes[0];
	        }
	        return value;
	    };
	
	    Tree.prototype.remove = function (key) {
	        var retval = this.root.remove(key);
	        if (retval.length == 2) {
	            this.root = retval[1];
	        }
	        return retval[0];
	    };
	
	    Tree.prototype.find = function (key) {
	        return this.root.find(key);
	    };
	
	    Tree.prototype.range = function (start, end) {
	        return this.root.range(start, end);
	    };
	
	    // Expose all types on top
	    Tree.Node = Node;
	    Tree.InternalNode = InternalNode;
	    Tree.LeafNode = LeafNode;
	
	    // Enable module loading if available
	    if (typeof module != 'undefined' && module["exports"]) {
	        // CommonJS
	        module["exports"] = Tree;
	    } else if ("function" != 'undefined' && __webpack_require__(150)["amd"]) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Tree;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Shim
	        if (!global["dcodeIO"]) {
	            global["dcodeIO"] = {};
	        }
	        global["dcodeIO"]["BPlusTree"] = Tree;
	    }
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)(module)))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	/*
	 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
	 Licensed under the Apache License, Version 2.0 (the "License");
	 you may not use this file except in compliance with the License.
	 You may obtain a copy of the License at
	 http://www.apache.org/licenses/LICENSE-2.0
	 Unless required by applicable law or agreed to in writing, software
	 distributed under the License is distributed on an "AS IS" BASIS,
	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 See the License for the specific language governing permissions and
	 limitations under the License.
	 */
	
	/**
	 * @license btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: http://github.com/dcodeIO/btree.js for details
	 */
	(function (module, console) {
	    'use strict';
	
	    /**
	     * Concatenates multiple arrays into a new one.
	     * @param {...[Array]} var_args
	     * @returns {Array}
	     * @private
	     */
	
	    function concat(var_args) {
	        // Array#concat behaves strangely for empty arrays, so...
	        var a = [];
	        for (var i = 0; i < arguments.length; i++) {
	            Array.prototype.push.apply(a, arguments[i]);
	        }
	        return a;
	    }
	
	    /**
	     * Searches an array for the specified value.
	     * @param {Array} a
	     * @param {*} v
	     * @returns {number} Index or -1 if not found
	     * @private
	     */
	    function asearch(a, v) {
	        // This is faster than Array#indexOf because it's raw. However, we
	        // cannot use binary search because nodes do not have a comparable
	        // key. If the compiler is smart, it will inline this.
	        for (var i = 0; i < a.length; i++) {
	            if (a[i] === v) return i;
	        }
	        return -i;
	    }
	
	    /**
	     * btree namespace.
	     * @type {Object.<string,*>}
	     */
	    var btree = {};
	
	    /**
	     * Strictly compares two strings, character by character. No locales, no number extension.
	     * @param {string} a
	     * @param {string} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.strcmp = function strcmp(a, b) {
	        /** @type {number} */
	        var ac;
	        /** @type {number} */
	        var bc;
	        for (var i = 0; i < a.length; i++) {
	            if (i >= b.length) {
	                return 1;
	            }
	            if ((ac = a.charCodeAt(i)) < (bc = b.charCodeAt(i))) {
	                return -1;
	            } else if (ac > bc) {
	                return 1;
	            }
	            // If same, continue
	        }
	        return a.length == b.length ? 0 : -1;
	    };
	
	    /**
	     * Compares two numbers.
	     * @param {number} a
	     * @param {number} b
	     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
	     * @expose
	     */
	    btree.numcmp = function intcmp(a, b) {
	        return a < b ? -1 : a > b ? 1 : 0;
	    };
	
	    /**
	     * Creates a BTree class using the given order.
	     * Note that this method returns a class, not an instance.
	     * @param {number=} order Defaults to 2
	     * @param {function(?, ?):number=} compare Compare implementation to use on keys
	     * @returns {Function}
	     * @expose
	     */
	    btree.create = function (order, compare) {
	
	        // Validate order
	        if (typeof order == 'undefined') {
	            order = 52; // Benchmarks proofed that this is close to the optimum
	        } else if (typeof order == 'number') {
	                order = Math.floor(order);
	            } else {
	                order = parseInt(order, 10);
	            }
	        if (order < 1) order = 1;
	        var minOrder = order > 1 ? Math.floor(order / 2) : 1;
	
	        // Use numcmp by default
	        if (typeof compare != 'function') {
	            compare = btree.numcmp;
	        }
	
	        /**
	         * Validates a node and prints debugging info if something went wrong.
	         * @param {!TreeNode|!Tree} node
	         * @private
	         */
	        function validate(node) {
	            // This function will be stripped by the compiler
	            if (node instanceof Tree) return;
	            if (node.leaves.length + 1 != node.nodes.length) {
	                console.log("ERROR: Illegal leaf/node count in " + node + ": " + node.leaves.length + "/" + node.nodes.length);
	            }
	            for (var i = 0; i < node.leaves.length; i++) {
	                if (!node.leaves[i]) {
	                    console.log("ERROR: Illegal leaf in " + node + " at " + i + ": " + node.leaves[i]);
	                }
	            }
	            for (i = 0; i < node.nodes.length; i++) {
	                if (typeof node.nodes[i] == 'undefined') {
	                    console.log("ERROR: Illegal node in " + node + " at " + i + ": undefined");
	                }
	            }
	        }
	
	        /**
	         * Constructs a new TreeNode.
	         * @class A TreeNode.
	         * @param {!(TreeNode|Tree)} parent Parent node
	         * @param {Array.<!Leaf>=} leaves Leaf nodes
	         * @param {Array.<TreeNode>=} nodes Child nodes
	         * @constructor
	         */
	        var TreeNode = function TreeNode(parent, leaves, nodes) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode|!Tree}
	             */
	            this.parent = parent;
	
	            /**
	             * Leaf nodes (max. order).
	             * @type {!Array.<!Leaf>}
	             */
	            this.leaves = leaves || [];
	            this.leaves.forEach(function (leaf) {
	                leaf.parent = this;
	            }, this);
	
	            /**
	             * Child nodes (max. order+1).
	             * @type {!Array.<TreeNode>}
	             */
	            this.nodes = nodes || [null];
	            this.nodes.forEach(function (node) {
	                if (node !== null) node.parent = this;
	            }, this);
	        };
	
	        /**
	         * Searches for the node that would contain the specified key.
	         * @param {!*} key
	         * @returns {{leaf: !Leaf, index: number}|{node: !TreeNode, index: number}} Leaf if the key exists, else the insertion node
	         */
	        TreeNode.prototype.search = function (key) {
	            if (this.leaves.length > 0) {
	                var a = this.leaves[0];
	                if (compare(a.key, key) == 0) return { leaf: a, index: 0 };
	                if (compare(key, a.key) < 0) {
	                    if (this.nodes[0] !== null) {
	                        return this.nodes[0].search(key); // Left
	                    }
	                    return { node: this, index: 0 };
	                }
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(b.key, key) == 0) return { leaf: b, index: i };
	                    if (compare(key, b.key) < 0) {
	                        if (this.nodes[i] !== null) {
	                            return this.nodes[i].search(key); // Inner
	                        }
	                        return { node: this, index: i };
	                    }
	                    a = b;
	                }
	                if (this.nodes[i] !== null) {
	                    return this.nodes[i].search(key); // Right
	                }
	                return { node: this, index: i };
	            }
	            return { node: this, index: 0 };
	        };
	
	        /**
	         * Gets the value for the given key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         */
	        TreeNode.prototype.get = function (key) {
	            var result = this.search(key);
	            if (result.leaf) return result.leaf.value;
	            return undefined;
	        };
	
	        /**
	         * Inserts a key/value pair into this node.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if successfully set, false if already present and overwrite is `false`
	         */
	        TreeNode.prototype.put = function (key, value, overwrite) {
	            var result = this.search(key);
	            if (result.leaf) {
	                if (typeof overwrite !== 'undefined' && !overwrite) {
	                    return false;
	                }
	                result.leaf.value = value;
	                return true;
	            } // Key already exists
	            var node = result.node,
	                index = result.index;
	            node.leaves.splice(index, 0, new Leaf(node, key, value));
	            node.nodes.splice(index + 1, 0, null);
	            if (node.leaves.length > order) {
	                // Rebalance
	                node.split();
	            }
	            return true;
	        };
	
	        /**
	         * Deletes a key from this node.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         */
	        TreeNode.prototype.del = function (key) {
	            var result = this.search(key);
	            if (!result.leaf) return false;
	            var leaf = result.leaf,
	                node = leaf.parent,
	                index = result.index,
	                left = node.nodes[index];
	            if (left === null) {
	                node.leaves.splice(index, 1);
	                node.nodes.splice(index, 1);
	                node.balance();
	            } else {
	                var max = left.leaves[left.leaves.length - 1];
	                left.del(max.key);
	                max.parent = node;
	                node.leaves.splice(index, 1, max);
	            }
	            return true;
	        };
	
	        /**
	         * Balances this node to fulfill all conditions.
	         */
	        TreeNode.prototype.balance = function () {
	            if (this.parent instanceof Tree) {
	                // Special case: Root has just a single child and no leaves
	                if (this.leaves.length == 0 && this.nodes[0] !== null) {
	                    this.parent.root = this.nodes[0];
	                    this.parent.root.parent = this.parent;
	                }
	                return;
	            }
	            if (this.leaves.length >= minOrder) {
	                return;
	            }
	            var index = asearch(this.parent.nodes, this),
	                left = index > 0 ? this.parent.nodes[index - 1] : null,
	                right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null;
	            var sep, leaf, rest;
	            if (right !== null && right.leaves.length > minOrder) {
	                // Append the seperator from parent to this
	                sep = this.parent.leaves[index];
	                sep.parent = this;
	                this.leaves.push(sep);
	                // Replace the blank with the first right leaf
	                leaf = right.leaves.shift();
	                leaf.parent = this.parent;
	                this.parent.leaves[index] = leaf;
	                // Append the right rest to this
	                rest = right.nodes.shift();
	                if (rest !== null) rest.parent = this;
	                this.nodes.push(rest);
	            } else if (left !== null && left.leaves.length > minOrder) {
	                // Prepend the seperator from parent to this
	                sep = this.parent.leaves[index - 1];
	                sep.parent = this;
	                this.leaves.unshift(sep);
	                // Replace the blank with the last left leaf
	                leaf = left.leaves.pop();
	                leaf.parent = this.parent;
	                this.parent.leaves[index - 1] = leaf;
	                // Prepend the left rest to this
	                rest = left.nodes.pop();
	                if (rest !== null) rest.parent = this;
	                this.nodes.unshift(rest);
	            } else {
	                var subst;
	                if (right !== null) {
	                    // Combine this + seperator from the parent + right
	                    sep = this.parent.leaves[index];
	                    subst = new TreeNode(this.parent, concat(this.leaves, [sep], right.leaves), concat(this.nodes, right.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index, 2, subst);
	                } else if (left !== null) {
	                    // Combine left + seperator from parent + this
	                    sep = this.parent.leaves[index - 1];
	                    subst = new TreeNode(this.parent, concat(left.leaves, [sep], this.leaves), concat(left.nodes, this.nodes));
	                    // Remove the seperator from the parent
	                    this.parent.leaves.splice(index - 1, 1);
	                    // And replace the nodes it seperated with subst
	                    this.parent.nodes.splice(index - 1, 2, subst);
	                } else {
	                    // We should never end here
	                    throw new Error("Internal error: " + this.toString(true) + " has neither a left nor a right sibling");
	                }
	                this.parent.balance();
	            }
	            // validate(this);
	            // validate(this.parent);
	        };
	
	        /**
	         * Unsplits a child.
	         * @param {!Leaf} leaf
	         * @param {!TreeNode} rest
	         */
	        TreeNode.prototype.unsplit = function (leaf, rest) {
	            leaf.parent = this;
	            rest.parent = this;
	            var a = this.leaves[0];
	            if (compare(leaf.key, a.key) < 0) {
	                this.leaves.unshift(leaf);
	                this.nodes.splice(1, 0, rest);
	            } else {
	                for (var i = 1; i < this.leaves.length; i++) {
	                    var b = this.leaves[i];
	                    if (compare(leaf.key, b.key) < 0) {
	                        this.leaves.splice(i, 0, leaf);
	                        this.nodes.splice(i + 1, 0, rest);
	                        break;
	                    }
	                }
	                if (i == this.leaves.length) {
	                    this.leaves.push(leaf);
	                    this.nodes.push(rest);
	                }
	            }
	            if (this.leaves.length > order) {
	                this.split();
	            }
	        };
	
	        /**
	         * Splits this node.
	         */
	        TreeNode.prototype.split = function () {
	            var index = Math.floor(this.leaves.length / 2);
	            if (this.parent instanceof Tree) {
	                this.nodes = [new TreeNode(this, this.leaves.slice(0, index), this.nodes.slice(0, index + 1)), new TreeNode(this, this.leaves.slice(index + 1), this.nodes.slice(index + 1))];
	                this.leaves = [this.leaves[index]];
	            } else {
	                var leaf = this.leaves[index];
	                var rest = new TreeNode(this.parent, this.leaves.slice(index + 1), this.nodes.slice(index + 1));
	                this.leaves = this.leaves.slice(0, index);
	                this.nodes = this.nodes.slice(0, index + 1);
	                this.parent.unsplit(leaf, rest);
	            }
	        };
	
	        /**
	         * Returns a string representation of this node.
	         * @param {boolean=} includeNodes Whether to include sub-nodes or not
	         * @returns {string}
	         */
	        TreeNode.prototype.toString = function (includeNodes) {
	            var val = [];
	            for (var i = 0; i < this.leaves.length; i++) {
	                val.push(this.leaves[i].key);
	            }
	            var s = "[" + val.toString() + "]" + (this.parent instanceof Tree ? ":*" : ":" + this.parent);
	            if (includeNodes) {
	                for (i = 0; i < this.nodes.length; i++) {
	                    s += " -> " + this.nodes[i];
	                }
	            }
	            return s;
	        };
	
	        /**
	         * Prints out the nodes leaves and nodes.
	         * @param {number} indent
	         */
	        TreeNode.prototype.print = function (indent) {
	            var space = "";
	            for (var i = 0; i < indent; i++) {
	                space += " ";
	            }for (i = this.leaves.length - 1; i >= 0; i--) {
	                if (this.nodes[i + 1] !== null) this.nodes[i + 1].print(indent + 2);
	                console.log(space + this.leaves[i].key + (this.parent instanceof Tree ? "*" : ""));
	            }
	            if (this.nodes[0] !== null) this.nodes[0].print(indent + 2);
	        };
	
	        /**
	         * Constructs a new Leaf containing a value.
	         * @class A Leaf.
	         * @param {!TreeNode} parent
	         * @param {!*} key
	         * @param {*} value
	         * @constructor
	         */
	        var Leaf = function Leaf(parent, key, value) {
	
	            /**
	             * Parent node.
	             * @type {!TreeNode}
	             */
	            this.parent = parent;
	
	            /**
	             * Key.
	             * @type {!*}
	             */
	            this.key = key;
	
	            /**
	             * Value.
	             * @type {*}
	             */
	            this.value = value;
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Leaf.prototype.toString = function () {
	            return "" + this.key;
	        };
	
	        /**
	         * Constructs a new Tree.
	         * @class A Tree.
	         * @constructor
	         */
	        function Tree() {
	            this.root = new TreeNode(this);
	        }
	
	        /**
	         * Inserts a key/value pair into the tree.
	         * @param {!*} key
	         * @param {*} value
	         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
	         * @returns {boolean} true if set, false if already present and overwrite is `false`
	         * @throws {Error} If the key is undefined or null or the value is undefined
	         * @expose
	         */
	        Tree.prototype.put = function (key, value, overwrite) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            if (typeof value === 'undefined') throw new Error("Illegal value: " + value);
	            return this.root.put(key, value, overwrite);
	        };
	
	        /**
	         * Gets the value of the specified key.
	         * @param {!*} key
	         * @returns {*|undefined} If there is no such key, undefined is returned
	         * @throws {Error} If the key is undefined or null
	         * @expose
	         */
	        Tree.prototype.get = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.get(key);
	        };
	
	        /**
	         * Deletes a key from the tree.
	         * @param {!*} key
	         * @returns {boolean} true if the key has been deleted, false if the key does not exist
	         * @expose
	         */
	        Tree.prototype.del = function (key) {
	            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
	            return this.root.del(key);
	        };
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in ascending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkAsc = function (minKey, maxKey, callback) {
	            if (this.root.leaves.length == 0) {
	                return;
	            }
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (minKey === null) {
	                // If there is no minimum limit
	                ptr = this.root; // set ptr to the outer left node
	                while (ptr.nodes[0] !== null) {
	                    ptr = ptr.nodes[0];
	                }
	                index = 0; // and start at its first leaf
	            } else {
	                    // Else lookup
	                    var result = this.root.search(minKey);
	                    if (result.leaf) {
	                        // If the minimum key itself exists
	                        ptr = result.leaf.parent; // set ptr to the containing node
	                        index = asearch(ptr.leaves, result.leaf); // and start at its index
	                    } else {
	                            // If the key does not exist
	                            ptr = result.node; // set ptr to the insertion node
	                            index = result.index; // and start at the insertion index (key > minKey)
	                            if (index >= ptr.leaves.length) {
	                                // on overrun, begin at the separator in the parent
	                                if (ptr.parent instanceof Tree) {
	                                    return; // empty range
	                                }
	                                index = asearch(ptr.parent.nodes, ptr);
	                                if (index >= ptr.parent.leaves.length) {
	                                    return; // empty range
	                                }
	                                ptr = ptr.parent;
	                            }
	                        }
	                }
	            // ptr/index now points at our first result
	            while (true) {
	                if (maxKey !== null && compare(ptr.leaves[index].key, maxKey) > 0) {
	                    break; // if there are no more keys less than maxKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index + 1] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index + 1];
	                    index = 0;
	                    while (ptr.nodes[0] !== null) {
	                        ptr = ptr.nodes[0];
	                    }
	                } else if (ptr.leaves.length > index + 1) {
	                    // Next
	                    index++;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr);
	                        ptr = ptr.parent;
	                    } while (index >= ptr.leaves.length);
	                }
	            }
	        };
	
	        /**
	         * Alias of {@link Tree#walkAsc}.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
	         * @param {(*|(function(*, *):(boolean|undefined)))=} maxKey If omitted or NULL, walks till the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walk = Tree.prototype.walkAsc;
	
	        /**
	         * Walks through all keys [minKey, ..., maxKey] in descending order.
	         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or null, walks till the beginning
	         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or null, starts at the end
	         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
	         *  parameters. May explicitly return true to stop the loop.
	         * @expose
	         */
	        Tree.prototype.walkDesc = function (minKey, maxKey, callback) {
	            if (typeof minKey == 'function') {
	                callback = minKey;
	                minKey = maxKey = null;
	            } else if (typeof maxKey == 'function') {
	                callback = maxKey;
	                maxKey = null;
	            }
	            minKey = typeof minKey != 'undefined' ? minKey : null;
	            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
	            var ptr, index;
	            if (maxKey === null) {
	                // If there is no maximum limit
	                ptr = this.root; // set ptr to the outer right node
	                while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                    ptr = ptr.nodes[ptr.nodes.length - 1];
	                }
	                index = ptr.leaves.length - 1; // and start at its last leaf
	            } else {
	                    // Else lookup
	                    var result = this.root.search(maxKey);
	                    if (result.leaf) {
	                        // If the maximum key itself exists
	                        ptr = result.leaf.parent; // set ptr to the containing node
	                        index = asearch(ptr.leaves, result.leaf); // and start at its index
	                    } else {
	                            // If the key does not exist
	                            ptr = result.node; // set ptr to the insertion node
	                            index = result.index - 1; // and start at the insertion index-1 (key < maxKey)
	                            while (index < 0) {
	                                // on underrun, begin at the separator in the parent
	                                if (ptr.parent instanceof Tree) {
	                                    return; // empty range
	                                }
	                                index = asearch(ptr.parent.nodes, ptr) - 1;
	                                if (index < 0) {
	                                    return; // empty range
	                                }
	                                ptr = ptr.parent;
	                            }
	                        }
	                }
	            // ptr/index now points at our first result
	            while (true) {
	                if (minKey !== null && compare(ptr.leaves[index].key, minKey) < 0) {
	                    break; // if there are no more keys bigger than minKey
	                }
	                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
	                    break; // if the user explicitly breaks the loop by returning true
	                }
	                if (ptr.nodes[index] !== null) {
	                    // Descend
	                    ptr = ptr.nodes[index];
	                    while (ptr.nodes[ptr.nodes.length - 1] !== null) {
	                        ptr = ptr.nodes[ptr.nodes.length - 1];
	                    }
	                    index = ptr.leaves.length - 1;
	                } else if (index > 0) {
	                    // Next
	                    index--;
	                } else {
	                    // Ascend
	                    do {
	                        if (ptr.parent instanceof Tree) {
	                            return;
	                        }
	                        index = asearch(ptr.parent.nodes, ptr) - 1;
	                        ptr = ptr.parent;
	                    } while (index < 0);
	                }
	            }
	        };
	
	        /**
	         * Counts the number of keys between minKey and maxKey (both inclusive).
	         * @param {*=} minKey If omitted, counts from the start
	         * @param {*=} maxKey If omitted, counts till the end
	         * @returns {number}
	         * @expose
	         */
	        Tree.prototype.count = function (minKey, maxKey) {
	            var n = 0;
	            this.walk(typeof minKey != 'undefined' ? minKey : null, typeof maxKey != 'undefined' ? maxKey : null, function (key, value) {
	                n++;
	            });
	            return n;
	        };
	
	        /**
	         * Prints out all nodes in the tree.
	         * @expose
	         */
	        Tree.prototype.print = function () {
	            this.root.print(0);
	        };
	
	        /**
	         * Returns a string representation of this instance.
	         * @returns {string}
	         */
	        Tree.prototype.toString = function () {
	            return "Tree(" + order + ") " + this.root.toString();
	        };
	
	        return Tree;
	    };
	
	    module.exports = btree;
	})(module, console);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)(module)))

/***/ },
/* 83 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 折半查找(Binary Search)
	
	 折半查找又称为二分查找，是一种效率较高的查找方法。
	 前提条件：查找表中的所有记录是按关键字有序(升序或降序) 。
	 查找过程中，先确定待查找记录在表中的范围，然后逐步缩小范围(每次将待查记录所在区间缩小一半)，直到找到或找不到记录为止。
	
	 1  查找思想
	 用Low、High和Mid表示待查找区间的下界、上界和中间位置指针，初值为Low=0，High=n - 1。
	 ⑴  取中间位置Mid：Mid=Math.floor((Low+High)/2)；
	 ⑵  比较中间位置记录的关键字与给定的K值：
	 ①  相等： 查找成功；
	 ②  大于：待查记录在区间的前半段，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段，修改下界指针：Low=Mid+1，转⑴ ；
	 直到越界(Low>High)，查找失败。
	
	 2  算法分析
	 ①  查找时每经过一次比较，查找范围就缩小一半，该过程可用一棵二叉树表示：
	 ◆ 根结点就是第一次进行比较的中间位置的记录；
	 ◆ 排在中间位置前面的作为左子树的结点；
	 ◆ 排在中间位置后面的作为右子树的结点；
	 对各子树来说都是相同的。这样所得到的二叉树称为判定树(Decision Tree)。
	 ②  将二叉判定树的第Math.floor(Math.log(2, n))+1层上的结点补齐就成为一棵满二叉树，深度不变，h= Math.floor(Math.log(2, n + 1)) 。
	 ③  由满二叉树性质知，第i 层上的结点数为Math.pow(2, i-1)(i<=h) ，设表中每个记录的查找概率相等，即Pi=1/n，查找成功时的平均查找长度ASL：
	 (n+1)/n*Math.log(2,n+1)-1
	 当n很大 (n>50)时， ASL≈ Math.log(2,n+1)-1。
	
	
	 时间复杂度O(logn)
	 */
	
	// 非递归式
	function binarySearch(sTable, key) {
	    var low = 0;
	    var high = sTable.length - 1;
	
	    while (low <= high) {
	        var mid = low + high >> 1;
	        var elem = sTable[mid];
	
	        if (elem === key) return mid;else if (elem < key) low = mid + 1;else high = mid - 1;
	    }
	
	    return -1;
	}
	
	console.log('binarySearch: ');
	console.log(binarySearch([1, 2, 3, 4, 5], 1)); // 0
	
	// 递归式
	function binarySearchRecursive(sTable, key) {
	    var low = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var high = arguments.length <= 3 || arguments[3] === undefined ? sTable.length - 1 : arguments[3];
	
	    if (low > high) return -1;
	
	    var mid = low + high >> 1;
	    var elem = sTable[mid];
	
	    if (elem === key) return mid;else if (elem < key) return binarySearchRecursive(sTable, key, mid + 1, high);else return binarySearchRecursive(sTable, key, low, mid - 1);
	}
	
	console.log('binarySearchRecursive: ');
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 1)); // 0
	console.log(binarySearchRecursive([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TrieTree = exports.DoubleLinkedTree = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by Luke on 2015/1/11.
	 */
	
	/*
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，也叫字典树，来表示这样的字符串的集合。
	
	 概念
	
	 如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。键树又称为数字查找树（Digital Search Tree)或Trie树(trie为retrieve中间4个字符)，其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A,B,C,....Z的单词所在页,再对各部分标出第二字母为A,B,C,...Z的单词所在的页, ....等等。
	
	 键树是一种特殊的查找树，它的某个节点不是包含一个或多个关键字，而是只包含组成关键字的一部分（字符或数字），比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。
	
	 根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。事实上，还可以赋予“字符串”更广泛的含义，它可以是任何类型的对象组成的串。
	
	
	 键树的存储
	 1）双链树表示
	 2) 多重链表表示
	
	
	 键树的应用场景
	
	 Trie是一种非常简单高效的数据结构，但有大量的应用实例。
	 （1） 字符串检索
	 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
	 举例：
	 @  给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
	 @  给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。
	
	 （2）字符串最长公共前缀
	 Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
	 举例：
	 @ 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？
	 解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
	 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
	 1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
	 2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；
	 （关于并查集，Tarjan算法，RMQ问题，网上有很多资料。）
	
	 （3）排序
	 Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
	 举例：
	 @ 给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。
	
	 （4） 作为其他数据结构和算法的辅助结构
	 如后缀树，AC自动机等
	 */
	
	/*
	 双链树表示
	
	 以树的孩子兄弟链表来表示键树，则每个分支结点包括三个域：
	 symbol域：存储关键字的一个字符；
	 first域：存储指向第一棵子树根的指针；
	 next域：存储指向右兄弟的指针。
	
	 同时，叶子结点不含first域，它的infoptr域存储指向该关键字记录的指针。
	 此时的键树又称双链树。
	 在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。
	 结点的结构中可以设置一个枚举变量表示结点的类型，叶子结点和分支结点。
	 叶子结点和分支结点都有symbol域和next域。不同的一个域可以用联合表示，叶子结点包含infoptr指向记录，而分支结点是first域指向其第一棵子树。
	
	
	 双链树的查找
	
	 假设给定值为K.ch(0..num-1), 其中K.ch[0]至 K.ch[num-2]表示待查关键字中num-1个字符， K.ch[num-1]为结束符$。
	 从双链树的根指针出发，顺first指针找到第一棵子树的根结点，以K.ch[0]和此结点的symbol域比较，若相等，则顺first域再比较下一字符，否则沿next域顺序查找。
	 若直至空仍比较不等，则查找不成功。
	
	 // 相关资料
	 http://www.cnblogs.com/rollenholt/archive/2012/04/24/2468932.html
	 http://blog.csdn.net/v_july_v/article/details/6897097
	 http://www.raychase.net/1783
	 */
	
	var LEAF = 'leaf';
	var BRANCH = 'branch';
	var TERMINAL = new String('$');
	
	var DoubleLinkedTree = exports.DoubleLinkedTree = function () {
	    function DoubleLinkedTree() {
	        var symbol = arguments.length <= 0 || arguments[0] === undefined ? 'root' : arguments[0];
	        var kind = arguments.length <= 1 || arguments[1] === undefined ? BRANCH : arguments[1];
	        var info = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        (0, _classCallCheck3.default)(this, DoubleLinkedTree);
	
	        this.symbol = symbol;
	        this.next = null;
	        this.kind = kind;
	        this.info = info;
	        this.first = null;
	    }
	
	    (0, _createClass3.default)(DoubleLinkedTree, [{
	        key: 'synoSearch',
	        value: function synoSearch(key) {
	            var p = this.first;
	
	            for (var i = 0; p && i < key.length; ++i) {
	                if (p && p.kind === LEAF) break;
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) p = p.first;else p = null;
	            }
	
	            return p && p.kind === LEAF ? p.info : null;
	        }
	    }, {
	        key: 'search',
	        value: function search(key) {
	            var p = this.first;
	
	            for (var i = 0; p && i < key.length; ++i) {
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) p = p.first;else p = null;
	            }
	
	            return p && p.kind === LEAF ? p.info : null;
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key, value) {
	            key += '';
	            var cur = this;
	
	            for (var i = 0; i < key.length; ++i) {
	                var c = key[i];
	                var p = cur;
	                cur = cur.first;
	                var node = new DoubleLinkedTree(c, BRANCH);
	
	                // 如果没有子结点则将新结点作为子结点
	                if (!cur) {
	                    p.first = node;
	                    node.parent = p;
	                    cur = node;
	                } else {
	                    // 在兄弟结点中找到对应结点
	                    if (c < cur.symbol) {
	                        node.parent = cur.parent;
	                        node.next = cur;
	                        node.parent.first = node;
	                        cur = node;
	                    } else if (c > cur.symbol) {
	                        var b = void 0;
	                        while (cur) {
	                            // 如果相等，退出该循环查找下一字符
	                            if (c === cur.symbol) break;
	                            // 如果小于当前字符，则插入到当前结点前面
	                            else if (c < cur.symbol) {
	                                    node.parent = cur.parent;
	                                    node.next = cur;
	                                    b.next = node;
	                                    cur = node;
	                                    break;
	                                } else {
	                                    b = cur;
	                                    cur = cur.next;
	                                }
	                        }
	
	                        // 如果没有兄弟结点则插入到兄弟结点
	                        if (!cur) {
	                            b.next = node;
	                            node.parent = b.parent;
	                            cur = node;
	                        }
	                    }
	                }
	            }
	
	            // 生成叶子结点
	            var success = false;
	            if (cur.kind === BRANCH) {
	                var child = cur.first;
	
	                // 如果不存在关键字则说明插入成功，否则插入失败
	                if (!(child && child.symbol === TERMINAL)) {
	                    cur.first = new DoubleLinkedTree(TERMINAL, LEAF, value != null ? value : key);
	                    cur.first.parent = cur;
	                    cur.first.next = child;
	                    success = true;
	                }
	            }
	
	            return success;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            var p = this.first;
	            var i = 0;
	
	            while (p && i < key.length) {
	                while (p && p.symbol < key[i]) {
	                    p = p.next;
	                }if (p && p.symbol === key[i]) {
	                    p = p.first;
	                    ++i;
	                } else return false;
	            }
	
	            var data = p.info;
	            while (!p.next && p.parent) {
	                p = p.parent;
	            }var top = p;
	
	            if (top == this) {
	                this.first = null;
	                return data;
	            }
	
	            p = top.parent;
	            if (p) {
	                p = p.first;
	                while (p) {
	                    var pre = void 0;
	                    if (p == top) {
	                        // 删除在first域上的子树结点
	                        if (!pre) top.parent.first = top.parent.first.next;
	                        // 删除在next域的兄弟结点
	                        else pre.next = pre.next.next;
	
	                        return data;
	                    } else {
	                        pre = p;
	                        p = p.next;
	                    }
	                }
	            }
	
	            return false;
	        }
	    }]);
	    return DoubleLinkedTree;
	}();
	
	var test = new DoubleLinkedTree();
	test.insert('CAI');
	test.insert('LAN');
	test.insert('CAO');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CHAO');
	test.insert('CHEN');
	test.insert('LI');
	test.insert('LIU');
	test.insert('ZHAO');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('CAI'));
	console.log(test.search('CHA'));
	console.log(test.search('CHANG'));
	console.log(test.search('ZHAOx'));
	
	console.log('\nremove:');
	console.log(test.remove('CAI'));
	console.log(test.remove('CAI'));
	console.log(test.remove('LAN'));
	console.log(test.remove('CAO'));
	console.log(test.remove('CHA'));
	console.log(test.remove('CHANG'));
	console.log(test.remove('CHAO'));
	console.log(test.remove('CHEN'));
	console.log(test.remove('LI'));
	console.log(test.remove('LIU'));
	console.log(test.remove('ZHAO'));
	
	/*
	 多重链表表示
	
	 若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树。
	 （Trie是从检索retrieve中取中间四个字符的，读音同try）。
	 若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。
	 在Trie树中有两种结点：
	 分支结点：含有d个指针域和一个指示该结点中非空指针域的个数的整数域。在分支结点中不设数据域，每个分支结点所表示的字符均有其父结点中指向该结点的指针所在位置决定。
	 叶子结点：含有关键字域和指向记录的指针域。
	
	
	 在Trie树上进行查找
	
	 从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功，若分支结点中和给定值相应的指针为空，或叶子结点中的关键字和给定值不相等，则查找不成功。
	
	
	 优化Trie树的深度
	
	 我们可对关键字集选择一种合适的分割。先按首字符不通分成多个子集之后，然后按最后一个字符不同分割每个子集，再按第二个字符。。。前后交叉分割。一缩减Trie树的深度
	 */
	// 求字符在字母表中的序号
	function order(c) {
	    return c ? c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1 : 0;
	}
	
	// 通过回溯法清理Trie树的函数
	function removeNode(trieNode, order, clear) {
	    trieNode.branch.nodes[order] = null;
	    --trieNode.branch.num;
	
	    if (!clear) return;
	
	    var nodes = trieNode.branch.nodes;
	    var parent = trieNode.parent;
	    var pre = trieNode;
	
	    while (parent) {
	        for (var i in nodes) {
	            if (nodes.hasOwnProperty(i) && nodes[i]) return;
	        }
	
	        var index = void 0;
	        var parentNodes = parent.branch.nodes;
	        for (var _i in parentNodes) {
	            if (parentNodes.hasOwnProperty(_i) && parentNodes[_i] && parentNodes[_i] == pre) index = _i;
	        }
	        parent.branch.nodes[index] = null;
	        --parent.branch.num;
	
	        pre = parent;
	        nodes = parent.branch.nodes;
	        parent = parent.parent;
	    }
	}
	
	var TrieTree = exports.TrieTree = function () {
	    function TrieTree(kind) {
	        (0, _classCallCheck3.default)(this, TrieTree);
	
	        this.kind = kind || BRANCH;
	        this.parent = null;
	
	        if (kind === LEAF) {
	            this.leaf = {
	                key: null,
	                info: null
	            };
	        } else {
	            this.branch = {
	                // “$”为第一个字符，后续为26个字母
	                nodes: new Array(27),
	                num: 0
	            };
	        }
	    }
	
	    (0, _createClass3.default)(TrieTree, [{
	        key: 'search',
	        value: function search(key) {
	            var p = this,
	                i = 0;
	            for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {}
	
	            if (p) {
	                if (p.kind === LEAF && p.leaf.key === key) return p.leaf.info;
	                // 同义词
	                else if (p.kind === BRANCH) {
	                        p = p.branch.nodes[0];
	                        if (p && p.leaf.key === key) return p.leaf.info;
	                    }
	            }
	
	            return null;
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key, value) {
	            // 建叶子结点
	            var q = new TrieTree(LEAF);
	            q.leaf.key = key;
	            q.leaf.info = value;
	
	            // 自上而下查找
	            var last = void 0;
	            var p = this,
	                i = 0;
	            for (; p && p.kind === BRANCH && i < key.length && p.branch.nodes[order(key[i])]; p = p.branch.nodes[order(key[i])], ++i) {
	                last = p;
	            } // 如果最后落到分支结点（无同义词）
	            // 直接连上叶子
	            if (p.kind === BRANCH) {
	                p.branch.nodes[order(key[i])] = q;
	                q.parent = p;
	                ++p.branch.num;
	            }
	            // 如果最后落到叶子结点（有同义词）
	            else {
	                    if (p.leaf.key === key) return false;
	
	                    // 建立新的分支结点
	                    var r = new TrieTree(BRANCH);
	                    // 用新的分支结点取代老叶子结点和上一层的联系
	                    last.branch.nodes[order(key[i - 1])] = r;
	                    r.parent = last;
	                    r.branch.num = 2;
	                    r.branch.nodes[order(key[i])] = q;
	                    q.parent = r;
	                    // 新分支结点与新老两个叶子结点相连
	                    r.branch.nodes[order(p.leaf.key[i])] = p;
	                    p.parent = r;
	                }
	
	            return true;
	        }
	
	        /**
	         *
	         * @param key
	         * @param {Boolean} clear 是否需要清理结点
	         * @returns {*} 如果删除成功返回info数据否则返回false
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key, clear) {
	            var last = void 0;
	            var p = this,
	                i = 0;
	            // 查找待删除元素
	            for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {
	                last = p;
	            }if (!p) return false;
	
	            clear = typeof clear !== 'undefined' ? clear : true;
	            var data = null;
	
	            if (p.kind === LEAF && p.leaf.key === key) {
	                data = p.leaf.info;
	                removeNode(last, order(key[i - 1]), clear);
	                return data;
	            } else if (p.kind === BRANCH) {
	                p = p.branch.nodes[0];
	                if (p && p.leaf.key === key) {
	                    data = p.leaf.info;
	                    removeNode(p.parent, 0, clear);
	                    return data;
	                }
	            }
	
	            return false;
	        }
	    }]);
	    return TrieTree;
	}();
	
	var test = new TrieTree();
	
	test.insert('CHA');
	test.insert('CHA');
	test.insert('CHANG');
	test.insert('CAI');
	test.insert('CHEN');
	test.insert('CAO');
	test.insert('CHAO');
	test.insert('LONG');
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');
	test.insert('WANG');
	test.insert('WEN');
	test.insert('WU');
	test.insert('YANG');
	test.insert('YUN');
	test.insert('ZHAO');
	
	console.log('\nsearch: ');
	console.log(test.search('YUN'));
	console.log(test.search('ZHAO'));
	console.log(test.search('CHA'));
	
	test.remove('LAN');
	test.remove('LIU');
	test.remove('WANG');
	test.remove('WEN');
	test.remove('WU');
	test.remove('YANG');
	test.remove('YUN');
	test.remove('ZHAO');
	test.remove('CHA');
	test.remove('CHANG');
	test.remove('CAI');
	test.remove('CHEN');
	test.remove('CAO');
	test.remove('CHAO');
	test.remove('LONG');
	test.remove('LI');
	
	test.insert('LI');
	test.insert('LAN');
	test.insert('LIU');
	
	/*
	 关于字典树的优化的数据结构有Patricia Tree，Suffix Tree
	 todo 有空再实现

	 相关资料：
	 http://blog.csdn.net/ljsspace/article/details/6571414
	 */

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LinkedListHashTable = exports.HashTable = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LinkedList = __webpack_require__(47);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hashSize = buildHashSize(977, 20); /**
	                                        * HashTable
	                                        * Created by Luke on 2014/12/30.
	                                        */
	
	/**
	哈希(散列)查找
	
	基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。
	
	基本概念
	
	哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数。
	哈希函数是一种映象，是从关键字空间到存储地址空间的一种映象。可写成：addr(ai)=H(ki) ，其中i是表中一个元素，addr(ai)是ai的地址， ki是ai的关键字。
	
	哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表。
	
	哈希查找(又叫散列查找)：利用哈希函数进行查找的过程叫哈希查找。
	
	冲突：对于不同的关键字ki、kj，若kikj，但H(ki)=H(kj)的现象叫冲突(collision) 。
	
	同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。
	哈希函数通常是一种压缩映象，所以冲突不可避免，只能尽量减少；当冲突发生时，应该有处理冲突的方法。设计一个散列表应包括：
	①  散列表的空间范围，即确定散列函数的值域；
	②  构造合适的散列函数，使得对于所有可能的元素(记录的关键字)，函数值均在散列表的地址空间范围内，且出现冲突的可能尽量小；
	③  处理冲突的方法。即当冲突出现时如何解决。
	
	
	哈希函数的构造
	
	哈希函数是一种映象，其设定很灵活，只要使任何关键字的哈希函数值都落在表长允许的范围之内即可。哈希函数“好坏”的主要评价因素有：
	◆ 散列函数的构造简单；
	◆ 能“均匀”地将散列表中的关键字映射到地址空间。所谓“均匀”(uniform)是指发生冲突的可能性尽可能最少。
	
	1  直接定址法
	取关键字或关键字的某个线性函数作哈希地址，即H(key)=key    或   H(key)=a·key+b(a,b为常数)
	特点：直接定址法所得地址集合与关键字集合大小相等，不会发生冲突，但实际中很少使用。
	
	2  数字分析法
	对关键字进行分析，取关键字的若干位或组合作为哈希地址。
	适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。
	例： 设有80个记录，关键字为8位十进制数，哈希地址为2位十进制数。
	           
	8  1  3  4  6  5  3  2
	8  1  3  7  2  2  4  2
	8  1  3  8  7  4  2  2
	8  1  3  0  1  3  6  7
	8  1  3  2  2  8  1  7
	8  1  3  3  8  9  6  7
	8  1  3  6  8  5  3  7
	8  1  4  1  9  3  5  5
	分析：  只取8
	       只取1
	       只取3、4
	       只取2、7、5
	      数字分布近乎随机
	所以：取任意两位或两位与另两位的叠加作哈希地址
	
	3  平方取中法
	将关键字平方后取中间几位作为哈希地址。
	一个数平方后中间几位和数的每一位都有关，则由随机分布的关键字得到的散列地址也是随机的。散列函数所取的位数由散列表的长度决定。这种方法适于不知道全部关键字情况，是一种较为常用的方法。
	
	4  折叠法
	将关键字分割成位数相同的几部分(最后一部分可以不同)，然后取这几部分的叠加和作为哈希地址。
	数位叠加有移位叠加和间界叠加两种。
	◆ 移位叠加：将分割后的几部分低位对齐相加。
	◆ 间界叠加：从一端到另一端沿分割界来回折迭，然后对齐相加。
	适于关键字位数很多，且每一位上数字分布大致均匀情况。
	例： 设关键字为0442205864，哈希地址位数为4 。两种不同的地址计算方法如下：
	    5864                        5864
	    4220                        0224
	      04       移位叠加            04           间界叠加
	 ---------                  -------------
	   10088                        6091
	
	5  除留余数法
	取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p     (p<=m)
	是一种简单、常用的哈希函数构造方法。
	利用这种方法的关键是p的选取，p选的不好，容易产生同义词。p的选取的分析：
	◆  选取p=2i(p<=m)：运算便于用移位来实现，但等于将关键字的高位忽略而仅留下低位二进制数。高位不同而低位相同的关键字是同义词。
	◆ 选取p=q*f(q、f都是质因数，p<=m)：则所有含有q或f因子的关键字的散列地址均是q或f的倍数。
	◆ 选取p为素数或p=q*f(q、f是质数且均大于20，p<=m)：常用的选取方法，能减少冲突出现的可能性。
	
	6  随机数法
	取关键字的随机函数值作哈希地址，即H(key)=random(key)
	当散列表中关键字长度不等时，该方法比较合适。
	
	
	
	选取哈希函数，考虑以下因素
	◆ 计算哈希函数所需时间；
	◆ 关键字的长度；
	◆ 哈希表长度（哈希地址范围）；
	◆ 关键字分布情况；
	◆ 记录的查找频率。
	
	
	
	冲突处理的方法
	冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。
	
	1  开放定址法
	基本方法：当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。散列地址的计算公式是：
	Hi(key)=(H(key)+di)  MOD m，i=1, 2, …, k(k<=m-1)
	
	其中：H(key)：哈希函数；m：散列表长度；
	di：第i次探测时的增量序列；
	Hi(key) ：经第i次探测后得到的散列地址。
	
	⑴  线性探测法
	将散列表T[0 …m-1]看成循环向量。当发生冲突时，从初次发生冲突的位置依次向后探测其他的地址。
	增量序列为：di=1, 2, 3, …, m-1
	设初次发生冲突的地址是h，则依次探测T[h+1]，T[h+2]…，直到T[m-1]时又循环到表头，再次探测T[0]，T[1]…，直到T[h-1]。探测过程终止的情况是：
	◆ 探测到的地址为空：表中没有记录。若是查找则失败；若是插入则将记录写入到该地址；
	◆ 探测到的地址有给定的关键字：若是查找则成功；若是插入则失败；
	◆ 直到T[h]：仍未探测到空地址或给定的关键字，散列表满。
	
	例1 ：设散列表长为7，记录关键字组为：15, 14, 28, 26, 56, 23，散列函数：H(key)=key   MOD  7，冲突处理采用线性探测法。
	H(15)=15  MOD 7=1
	H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0  冲突   H1(28)=1  又冲突
	H2(28)=2           H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=2   又冲突    H3(56)=3
	H(23)=23  MOD 7=2     冲突      H1(23)=3     又冲突
	H3(23)=4
	
	0     1      2      3      4       5     6
	14    15     28     56     23      26
	
	线性探测法的特点
	◆ 优点：只要散列表未满，总能找到一个不冲突的散列地址；
	◆ 缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而又增加了更多的冲突机会(这种现象称为冲突的“聚集”)。
	
	⑵  二次探测法
	增量序列为：di=1²,-1²,2²,-2²,3²,……±k²  (k<=⌊m/2⌋)
	
	上述例题若采用二次探测法进行冲突处理，则：
	H(15)=15  MOD 7=1         H(14)=14  MOD 7=0
	H(28)=28  MOD 7=0     冲突      H1(28)=1     又冲突
	H2(28)=4
	H(26)=26  MOD 7=5
	H(56)=56  MOD 7=0     冲突      H1(56)=1     又冲突
	H2(56)=0   又冲突    H3(56)=4    又冲突
	H4(56)=2
	H(23)=23  MOD 7=2      冲突
	H1(23)=3
	
	二次探测法的特点
	◆ 优点：探测序列跳跃式地散列到整个表中，不易产生冲突的“聚集”现象；
	◆ 缺点：不能保证探测到散列表的所有地址。
	
	⑶   伪随机探测法
	增量序列使用一个伪随机函数来产生一个落在闭区间[1，m-1]的随机序列。
	
	例2 ： 表长为11的哈希表中已填有关键字为17，60，29的记录，散列函数为H(key)=key  MOD  11 。 现有第4个记录，其关键字为38，按三种处理冲突的方法，将它填入表中。
	
	(1)  H(38)=38 MOD 11=5    冲突
	     H1=(5+1) MOD 11=6    冲突
	     H2=(5+2) MOD 11=7    冲突
	     H3=(5+3) MOD 11=8    不冲突
	(2)  H(38)=38 MOD 11=5      冲突
	     H1=(5+1²) MOD 11=6    冲突
	     H2=(5-1²) MOD 11=4     不冲突
	(3)  H(38)=38 MOD 11=5    冲突
	     设伪随机数序列为9，则H1=(5+9) MOD 11=3 不冲突
	
	
	2  再哈希法
	构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即：Hi=RHi(key)     i=1, 2, …, k
	RHi ：一组不同的哈希函数。第一次发生冲突时，用RH1计算，第二次发生冲突时，用RH2计算…依此类推知道得到某个Hi不再冲突为止。
	◆  优点：不易产生冲突的“聚集”现象；
	◆  缺点：计算时间增加。
	
	
	3  链地址法
	方法：将所有关键字为同义词(散列地址相同)的记录存储在一个单链表中，并用一维数组存放链表的头指针。
	设散列表长为m，定义一个一维指针数组：
	RecNode *linkhash[m]，其中RecNode是结点类型，每个分量的初值为空。凡散列地址为k的记录都插入到以linkhash[k]为头指针的链表中，插入位置可以在表头或表尾或按关键字排序插入。
	
	例： 已知一组关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79) ，哈希函数为：H(key)=key MOD 13，用链地址法处理冲突:
	
	 0
	 1  --> 14 -> 1 -> 27 -> 79
	 2
	 3  --> 68 -> 55
	 4
	 5
	 6  --> 19 -> 84
	 7  --> 20
	 8
	 9
	 10 --> 23 -> 10
	 11 --> 11
	 12
	
	 优点：不易产生冲突的“聚集”；删除记录也很简单。
	
	
	 4  建立公共溢出区
	 方法：在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。
	 设散列表长为m，设立基本散列表hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。
	
	 例： 已知一组关键字(15, 4, 18, 7, 37, 47) ，散列表长度为7 ，哈希函数为：H(key)=key MOD 7，用建立公共溢出区法处理冲突。得到的基本表和溢出表如下：
	                    散列地址    0     1     2     3     4     5     6
	 Hashtable表：
	                    关键字     7     15    37          4     47
	
	                    溢出地址    0     1     2     3     4     5     6
	 overtable表：
	                     关键字    18
	
	
	
	
	 哈希查找过程及分析
	
	 1   哈希查找过程
	 哈希表的主要目的是用于快速查找，且插入和删除操作都要用到查找。由于散列表的特殊组织形式，其查找有特殊的方法。
	
	 给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定关键字相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直到哈希表中某个位置为空或者表中所填记录的关键字等于给定值时为止。
	
	
	
	 哈希查找分析
	
	 从哈希查找过程可见：尽管散列表在关键字与记录的存储地址之间建立了直接映象，但由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用ASL。
	 哈希查找时关键字与给定值比较的次数取决于：
	 ◆ 哈希函数；
	 ◆ 处理冲突的方法；
	 ◆ 哈希表的填满因子α 。填满因子α的定义是：
	
	 α = 表中填入的记录数 / 哈希表长度
	
	
	 各种散列函数所构造的散列表的ASL如下：
	
	 ⑴   线性探测法的平均查找长度是：
	 S成功 约等于 1 / 2 * (1 + 1 / (1 - α))
	 S失败 约等于 1 / 2 * (1 + 1 / (1 - α) * (1 - α))
	
	 ⑵   二次探测、伪随机探测、再哈希法的平均查找长度是：
	 S成功 约等于 -1 / α * ln(1 - α)
	 S失败 约等于 1 / (1 - α)
	
	 ⑶   用链地址法解决冲突的平均查找长度是：
	 S成功 约等于 1 + α / 2
	 S失败 约等于 α + e的-α次幂
	
	
	 */
	
	var HashTable = exports.HashTable = function () {
	    function HashTable() {
	        (0, _classCallCheck3.default)(this, HashTable);
	
	        this.data = [];
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	    }
	
	    // 使用线性探测法解决冲突
	
	
	    (0, _createClass3.default)(HashTable, [{
	        key: 'search',
	        value: function search(key) {
	            var max = hashSize[this.sizeIndex];
	            var p = hash(key, max);
	            var c = 0;
	
	            while (p < max && this.data[p] != null && key !== this.data[p]) {
	                p = collision(key, ++c, max);
	            }
	
	            return {
	                success: key === this.data[p],
	                collisionTimes: c,
	                index: p
	            };
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            var max = hashSize[this.sizeIndex];
	            if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	            var ret = this.search(key);
	            var p = ret.index;
	            var c = ret.collisionTimes;
	
	            if (ret.success) return false;else if (c < hashSize[this.sizeIndex] / 2) {
	                this.data[p] = key;
	                ++this.count;
	                return true;
	            } else {
	                this.recreateHashTable();
	                return false;
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            if (!this.count) return false;
	
	            var max = hashSize[this.sizeIndex];
	            var p = hash(key, max);
	            var c = 0;
	
	            while (key !== this.data[p]) {
	                p = collision(key, ++c, max);
	            }if (key === this.data[p]) {
	                var data = this.data[p];
	                this.data.splice(p, 1);
	                --this.count;
	
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'recreateHashTable',
	        value: function recreateHashTable() {
	            return ++this.sizeIndex < hashSize.length;
	        }
	    }]);
	    return HashTable;
	}();
	
	;
	
	// ELFhash字符串散列函数
	function hash(str, max) {
	    var hash = 0;
	    for (var i = 0; i < str.length; i++) {
	        hash = (hash << 5) + hash + str.charCodeAt(i);
	        hash = hash & hash; // Convert to 32bit integer
	        hash = Math.abs(hash);
	    }
	    return hash % max;
	}
	
	function collision(key, times, max) {
	    // 线性探测法
	    return (hash(key, max) + times) % max;
	}
	
	function isPrime(n) {
	    if (n <= 3) return n > 1;
	    if (n % 2 === 0 || n % 3 === 0) return false;
	    for (var i = 5; i * i <= n; i += 6) {
	        if (n % i === 0 || n % (i + 2) === 0) return false;
	    }
	
	    return true;
	}
	
	function buildHashSize(begin, length) {
	    var hashSize = [];
	
	    while (1) {
	        if (hashSize.length >= length) break;
	        if (isPrime(begin)) hashSize.push(begin);
	        ++begin;
	    }
	
	    return hashSize;
	}
	
	// 开放定址法
	//hashSize = [5, 7]; // for test. will be deleted
	var test = new HashTable();
	test.insert('17');
	test.insert('60');
	test.insert('29');
	test.insert('38');
	test.insert('39');
	test.insert('40');
	
	test.remove('17');
	test.remove('60');
	test.remove('29');
	test.remove('38');
	test.remove('39');
	test.remove('40');
	
	// 使用链地址法解决冲突的哈希表
	
	var LinkedListHashTable = exports.LinkedListHashTable = function () {
	    function LinkedListHashTable() {
	        (0, _classCallCheck3.default)(this, LinkedListHashTable);
	
	        // 当前数据元素个数;
	        this.count = 0;
	        // 当前容量
	        this.sizeIndex = 0;
	        this.hNodes = [];
	    }
	
	    (0, _createClass3.default)(LinkedListHashTable, [{
	        key: 'search',
	        value: function search(key) {
	            var max = hashSize[this.sizeIndex];
	            var i = hash(key, max);
	            var t = this.hNodes;
	
	            if (t[i] == null) return { success: false, index: i };
	
	            var p = t[i];
	            var data = null;
	
	            p.each(function (node) {
	                if (node.data === key) {
	                    data = node.data;
	                    return true;
	                }
	            });
	
	            return { success: data === key, index: i };
	        }
	    }, {
	        key: 'insert',
	        value: function insert(key) {
	            var max = hashSize[this.sizeIndex];
	            if (this.count >= max) return { success: false, errormsg: 'table overflowed' };
	
	            var ret = this.search(key);
	            var index = ret.index;
	
	            if (ret.success) return false;
	
	            if (!this.hNodes[index]) this.hNodes[index] = new _LinkedList2.default();
	
	            if (this.hNodes[index].size() < hashSize[this.sizeIndex] / 2) {
	                this.hNodes[index].orderInsert(key);
	                ++this.count;
	                return true;
	            } else {
	                this.recreateHashTable();
	                return false;
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            if (!this.count) return false;
	
	            var ret = this.search(key);
	
	            if (ret.success) {
	                var index = ret.index;
	                var data = ret.data;
	                this.hNodes[index]['remove'](key);
	                --this.count;
	                return data;
	            }
	
	            return false;
	        }
	    }, {
	        key: 'recreateHashTable',
	        value: function recreateHashTable() {
	            return ++this.sizeIndex < hashSize.length;
	        }
	    }]);
	    return LinkedListHashTable;
	}();
	
	;
	
	var test2 = new LinkedListHashTable();
	test2.insert('17');
	test2.insert('60');
	test2.insert('29');
	test2.insert('38');
	test2.insert('39');
	test2.insert('40');
	
	test2.remove('17');
	test2.remove('60');
	test2.remove('29');
	test2.remove('38');
	test2.remove('39');
	test2.remove('40');

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.RedBlackNode = undefined;
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _getPrototypeOf = __webpack_require__(26);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(28);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(27);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BinarySortedTree = __webpack_require__(49);
	
	var _BinarySortedTree2 = _interopRequireDefault(_BinarySortedTree);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RED = 'red'; /**
	                  * Red Black Tree
	                  * Created by Luke on 2014/12/30.
	                  */
	/*
	 http://blog.csdn.net/v_july_v/article/details/6105630
	
	 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
	 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
	
	 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。
	
	 红黑树的5个性质：
	 1.每个结点要么是红的要么是黑的。
	 2.根结点是黑的。
	 3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
	 4.如果一个结点是红的，那么它的两个儿子都是黑的。
	 5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。
	
	 正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。
	
	
	 树的旋转
	
	当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。
	
	树的旋转分为左旋和右旋
	
	树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。
	
	
	红黑树的插入
	
	如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。
	但当遇到下述3种情况时又该如何调整呢？
	● 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况
	对此，我们的解决策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	于是，插入修复情况1转换成了插入修复情况2
	
	● 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	从而插入修复情况2转换成了插入修复情况3。
	
	● 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。
	
	经过上面情况3、情况4、情况5等3种插入修复情况的操作示意图，读者自会发现，后面的情况4、情况5都是针对情况3插入节点4以后，进行的一系列插入修复情况操作，不过，指向当前节点N指针一直在变化。所以，你可以想当然的认为：整个下来，情况3、4、5就是一个完整的插入修复情况的操作流程
	
	
	红黑树的删除
	
	在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。
	
	上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。
	
	 如果是以下情况，恢复比较简单：
	 a)当前节点是红+黑色
	 解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
	 b)当前节点是黑+黑且是根节点， 解法：什么都不做，结束。
	
	 但如果是以下情况呢？：
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
	 此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。
	
	 下面，咱们便来分别处理这4种删除修复情况。
	
	 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。
	
	 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变）
	
	 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持
	
	 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	
	
	 最后值得一提的是上述删除修复的情况1~4都只是树的局部，并非树的整体全部，且删除修复情况3、4在经过上面的调整后，调整还没结束,还得继续调整直至重新恢复平衡
	*/
	
	var BLACK = 'black';
	
	var RedBlackNode = exports.RedBlackNode = function (_BSTNode) {
	    (0, _inherits3.default)(RedBlackNode, _BSTNode);
	
	    function RedBlackNode() {
	        var _Object$getPrototypeO;
	
	        var data = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        (0, _classCallCheck3.default)(this, RedBlackNode);
	
	        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            rest[_key - 1] = arguments[_key];
	        }
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (_Object$getPrototypeO = (0, _getPrototypeOf2.default)(RedBlackNode)).call.apply(_Object$getPrototypeO, [this, data].concat(rest)));
	
	        _this.leftChild = null;
	        _this.rightChild = null;
	        _this.parent = null;
	
	        _this.color = RED;
	        _this.data = data;
	        return _this;
	    }
	
	    return RedBlackNode;
	}(_BinarySortedTree2.default);
	
	var RedBlackLeaf = function RedBlackLeaf() {
	    (0, _classCallCheck3.default)(this, RedBlackLeaf);
	
	    this.color = BLACK;
	    this.leftChild = this;
	    this.rightChild = this;
	};
	
	var RedBlackTree = function () {
	    function RedBlackTree() {
	        (0, _classCallCheck3.default)(this, RedBlackTree);
	
	        // 哨兵
	        this.nil = new RedBlackLeaf();
	        this.root = this.nil;
	    }
	
	    /**
	     * 红黑树的递归查找算法
	     * @param data
	     */
	
	
	    (0, _createClass3.default)(RedBlackTree, [{
	        key: 'find',
	        value: function find(data) {
	            var z = this.root;
	            var me = this;
	
	            return function find(z, data) {
	                if (z == me.nil || data === z.data) return z;
	
	                if (data < z.data) return find(z.leftChild, data);else return find(z.rightChild, data);
	            }(z, data);
	        }
	
	        /**
	         * 红黑树的插入
	         * @param {*} data
	         */
	
	    }, {
	        key: 'add',
	        value: function add(data) {
	            var z = new RedBlackNode(data);
	            z.leftChild = this.nil;
	            z.rightChild = this.nil;
	            var y = this.nil;
	            var x = this.root;
	
	            // 找到要插入位置的结点y
	            while (x != this.nil) {
	                y = x;
	
	                if (z.data < x.data) x = x.leftChild;else x = x.rightChild;
	            }
	
	            z.parent = y;
	
	            // 如果y不是根结点，根据大小插入到左或右子树
	            if (y != this.nil) {
	                if (z.data < y.data) y.leftChild = z;else y.rightChild = z;
	            }
	            // 否则插入到根结点
	            else this.root = z == this.nil ? null : z;
	
	            // 插入修复操作
	            this._addFixup(z);
	        }
	
	        /**
	         * 插入算法修复
	         * @param {RedBlackNode} z 待插入的结点
	         * @private
	         */
	
	    }, {
	        key: '_addFixup',
	        value: function _addFixup(z) {
	
	            while (z != this.root && z.parent.color === RED) {
	                if (z.parent == z.parent.parent.leftChild) leftAddFixup(this, z);else rightAddFixup(this, z);
	            }
	
	            // 最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡
	            this.root.color = BLACK;
	        }
	
	        /**
	         * 红黑树的删除算法
	         * @param {RedBlackNode} z 待删除结点
	         */
	
	    }, {
	        key: 'removeNode',
	        value: function removeNode(z) {
	            var x = void 0,
	                y = void 0;
	
	            // 找到待删除结点的父结点或相邻待替换结点
	            if (z.leftChild == this.nil || z.rightChild == this.nil) y = z;else y = this.successor(z);
	
	            if (y.leftChild != this.nil) x = y.leftChild;else x = y.rightChild;
	
	            x.parent = y.parent;
	
	            // 删除操作
	            if (y.parent == this.nil) this.root = x;else if (y == y.parent.leftChild) y.parent.leftChild = x;else y.parent.rightChild = x;
	
	            if (y != z) z.data = y.data;
	
	            // 删除修复
	            if (y.color === BLACK) this._removeFixup(x);
	        }
	
	        // 算法导论上的删除结点
	
	    }, {
	        key: 'removeNode2',
	        value: function removeNode2(z) {
	            var y = z;
	            var originalYColor = y.color;
	            var x = void 0;
	
	            if (z.leftChild == this.nil) {
	                x = z.rightChild;
	                this._transplant(z, z.rightChild);
	            } else if (z.rightChild == this.nil) {
	                x = z.leftChild;
	                this._transplant(z, z.leftChild);
	            } else {
	                y = this.min(z.rightChild);
	                originalYColor = y.color;
	                x = y.rightChild;
	
	                if (y.parent == z) x.parent = y;else {
	                    this._transplant(y, y.rightChild);
	                    y.rightChild = z.rightChild;
	                    y.rightChild.parent = y;
	                }
	
	                this._transplant(z, y);
	                y.leftChild = z.leftChild;
	                y.leftChild.parent = y;
	                y.color = z.color;
	            }
	
	            if (originalYColor === BLACK) this._removeFixup(x);
	        }
	    }, {
	        key: '_transplant',
	        value: function _transplant(u, v) {
	            if (u.parent == this.nil) this.root = v;else if (u == u.parent.leftChild) u.parent.leftChild = v;else u.parent.rightChild = v;
	
	            v.parent = u.parent;
	        }
	
	        /**
	         * 删除修复
	         * @param {RedBlackNode} z
	         * @private
	         */
	
	    }, {
	        key: '_removeFixup',
	        value: function _removeFixup(z) {
	            while (z !== this.root && z.color === BLACK) {
	                if (z == z.parent.leftChild) leftRemoveFixup(this, z);else rightRemoveFixup(this, z);
	            }
	
	            z.color = BLACK;
	        }
	    }, {
	        key: 'successor',
	        value: function successor(z) {
	            if (z.rightChild != this.nil) return this.min(z.rightChild);
	
	            var y = z.parent;
	
	            while (y != this.nil && z == y.rightChild) {
	                z = y;
	                y = y.parent;
	            }
	
	            return y;
	        }
	    }, {
	        key: 'min',
	        value: function min(z) {
	            while (z.leftChild != this.nil) {
	                z = z.leftChild;
	            }
	
	            return z;
	        }
	
	        /**
	         * 根据key值删除结点
	         * @param {*} key
	         * @returns {*}
	         */
	
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            var z = this.find(key);
	
	            if (z == this.nil) return false;
	
	            return this.removeNode(z);
	        }
	    }]);
	    return RedBlackTree;
	}();
	
	RedBlackTree.prototype._rotateLeft = rotate('left');
	RedBlackTree.prototype._rotateRight = rotate('right');
	
	function rotate(dir) {
	    var c1 = void 0,
	        c2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	    }
	
	    return function (x) {
	        var y = x[c1];
	        x[c1] = y[c2];
	
	        if (y[c2] != this.nil) y[c2].parent = x;
	        y.parent = x.parent;
	
	        if (x.parent == this.nil) this.root = y;else if (x == x.parent[c2]) x.parent[c2] = y;else x.parent[c1] = y;
	
	        y[c2] = x;
	        x.parent = y;
	    };
	}
	
	function addFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        rotate1 = void 0,
	        rotate2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        rotate1 = '_rotateLeft';
	        rotate2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        rotate1 = '_rotateRight';
	        rotate2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var y = z.parent.parent[c1];
	
	        // 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔结点）是红色
	        // 将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。
	        if (y.color === RED) {
	            z.parent.color = BLACK;
	            y.color = BLACK;
	            z.parent.parent.color = RED;
	            z = z.parent.parent;
	        } else {
	            // 插入修复情况2：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的右子
	            // 解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
	            // 从而插入修复情况2转换成了插入修复情况3。
	            if (z === z.parent[c1]) {
	                z = z.parent;
	                tree[rotate1](z);
	            }
	
	            // 插入修复情况3：当前节点的父节点是红色,叔节点是黑色，当前节点是其父节点的左子
	            // 解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，
	            z.parent.color = BLACK;
	            z.parent.parent.color = RED;
	            tree[rotate2](z.parent.parent);
	        }
	    };
	}
	
	var leftAddFixup = addFixup('left');
	var rightAddFixup = addFixup('right');
	var leftRemoveFixup = removeFixup('left');
	var rightRemoveFixup = removeFixup('right');
	
	function removeFixup(dir) {
	    var c1 = void 0,
	        c2 = void 0,
	        r1 = void 0,
	        r2 = void 0;
	    if (dir === 'left') {
	        c1 = 'rightChild';
	        c2 = 'leftChild';
	        r1 = '_rotateLeft';
	        r2 = '_rotateRight';
	    } else {
	        c1 = 'leftChild';
	        c2 = 'rightChild';
	        r1 = '_rotateRight';
	        r2 = '_rotateLeft';
	    }
	
	    return function (tree, z) {
	        // note: 注释以左边为情况
	
	        // 叔结点
	        var w = z.parent[c1];
	
	        // 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。
	        // 解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法
	        if (w.color === RED) {
	            w.color = BLACK;
	            z.parent.color = RED;
	            tree[r1](z.parent);
	            w = z.parent[c1];
	        }
	
	        // 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。
	        // 解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。
	        if (w[c2].color === BLACK && w[c1].color === BLACK) {
	            w.color = RED;
	            z = z.parent;
	        } else {
	            // 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。
	            // 解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。
	            if (w[c1].color === BLACK) {
	                w[c2].color = BLACK;
	                w.color = RED;
	                tree[r2](w);
	                w = z.parent[c1];
	            }
	
	            // 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。
	            // 解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确
	            w.color = z.parent.color;
	            z.parent.color = BLACK;
	            w[c1].color = BLACK;
	            tree[r1](z.parent);
	            z = tree.root;
	        }
	    };
	}
	
	var test = new RedBlackTree();
	test.add(13);
	test.add(8);
	test.add(17);
	test.add(1);
	test.add(6);
	test.add(11);
	test.add(15);
	test.add(22);
	test.add(25);
	test.add(27);
	
	test.remove(13);
	test.remove(8);
	test.remove(17);
	test.remove(1);
	test.remove(6);
	test.remove(11);
	test.remove(15);
	test.remove(22);
	test.remove(25);
	test.remove(27);

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _BinaryTree = __webpack_require__(15);
	
	/**
	 * 由有序表sTable[low..high]及其累计权值表weights递归构造次优查找树
	 * @param {BinaryTree} tree
	 * @param {Array} sTable
	 * @param {Array} sWeights
	 * @param {Number} low
	 * @param {Number} high
	 */
	function secondOptimal(tree, sTable, sWeights, low, high) {
	    var i = low;
	    var min = Math.abs(sWeights[high] - sWeights[low]);
	    var dw = sWeights[high] + (sWeights[low - 1] || 0);
	
	    // 选择最小的△Pi值
	    for (var j = low + 1; j <= high; ++j) {
	        var t = Math.abs(dw - sWeights[j] - sWeights[j - 1]);
	        if (t < min) {
	            i = j;
	            min = t;
	        }
	    }
	
	    // 调整树根权，选择邻近权值较大的关键字
	    var a = 0,
	        b = void 0,
	        c = 0;
	    if (i - 1 >= low) b = sWeights[i] - sWeights[i - 1];
	    if (i - 2 >= low) a = sWeights[i - 1] - sWeights[i - 2];
	    if (i + 1 < high) c = sWeights[i + 1] - sWeights[i];
	    if (typeof b === 'number') {
	        if (a > c && a > b) --i;else if (a < c && c > b) ++i;
	    }
	
	    tree.data = sTable[i];
	    //左子树
	    if (i === low) tree.leftChild = null;else {
	        tree.leftChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.leftChild, sTable, sWeights, low, i - 1);
	    }
	    // 右子树
	    if (i === high) tree.rightChild = null;else {
	        tree.rightChild = new _BinaryTree.BinaryTree();
	        secondOptimal(tree.rightChild, sTable, sWeights, i + 1, high);
	    }
	} /*
	   静态次优查找树
	  
	   适合各记录的查找概率不等的情况
	  
	   查找效率最高即平均查找长度最小，我们可以给出有序表在非等概率情况下应遵循的两个原则：
	   1、最先访问的结点应是访问概率最大的结点；
	   2、每次访问应使结点两边尚未访问的结点的被访概率之和尽可能相等。
	  
	  
	   这两个原则可用一句话来表示，即判定树为带权内路径长度之和最小的二叉树，亦即：PH = ∑wihi  最小，其中 n 为有序表长度，hi 为第 i 个结点在判定树上的层次数，wi = cpi，c 为某个常数，pi 为第 i 个结点的查找概率。
	  
	  
	   这样的树称为静态最优查找树（static optimal search tree），构造这样一棵树的时间代价太大，亦即时间复杂度很大，因此我们通常是构造次优查找树（nearly optimal search tree），构造它的时间代价远远低于构造最优查找树，但查找性能只比最优查找树差1%~2%，很少差3%以上。
	  
	   次优查找树的构造：
	  
	   设有序表每个记录的权值为 wl,wl+1,…,wh，第一个应访问的结点号为 i ，则有：
	   Δpi =   ∑wj - ∑wj   最小，即 Δpi = Min {Δpj }
	   再分别对 {rl,rl+1,…,ri-1} 和 {ri+1,ri+2,…,rh} 分别构造次优查找树
	   */
	
	
	var tree = new _BinaryTree.BinaryTree();
	secondOptimal(tree, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'], [1, 2, 4, 9, 12, 16, 20, 23, 28], 0, 8);
	console.log(tree);
	
	/**
	 * 由有序表构造一棵次优查找树
	 * @param {Object} obj 有序表，数据元素含有权域weight
	 */
	function createSOSTree(obj) {
	    var tree = void 0;
	    if (obj.elems.length === 0) tree = null;else {
	        // 求累计权值表
	        var sw = findSW(obj.weights);
	        tree = new _BinaryTree.BinaryTree();
	        secondOptimal(tree, obj.elems, sw, 0, obj.elems.length - 1);
	    }
	
	    return tree;
	}
	
	function findSW(sTable) {
	    var sw = [sTable[0]];
	
	    for (var i = 1; i < sTable.length; ++i) {
	        sw[i] = sw[i - 1] + sTable[i];
	    }
	
	    return sw;
	}
	
	var sosTree = createSOSTree({
	    elems: ['A', 'B', 'C', 'D', 'E'],
	    weights: [1, 30, 2, 29, 3]
	});
	sosTree.inOrderRecursive(function (value) {
	    console.log('inOrder: ' + value);
	});

/***/ },
/* 88 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 Fibonacci查找
	
	 Fibonacci查找方法是根据Fibonacci数列的特点对查找表进行分割。Fibonacci数列的定义是：
	 F(0)=0，F(1)=1，F(j)=F(j-1)+F(j-2) 。
	
	 1  查找思想
	 设查找表中的记录数比某个Fibonacci数小1，即设n=F(j)-1。用Low、High和Mid表示待查找区间的下界、上界和分割位置，初值为Low=0，High=n - 1。
	 ⑴   取分割位置Mid：Mid=F(j-1) ；
	 ⑵   比较分割位置记录的关键字与给定的K值：
	 ① 相等： 查找成功；
	 ②  大于：待查记录在区间的前半段(区间长度为F(j-1)-1)，修改上界指针： High=Mid-1，转⑴ ；
	 ③  小于：待查记录在区间的后半段(区间长度为F(j-2)-1)，修改下界指针：Low=Mid+1，转⑴ ；直到越界(Low>High)，查找失败。
	
	 2  算法实现
	 在算法实现时，为了避免频繁计算Fibonacci数，可用两个变量f1和f2保存当前相邻的两个Fibonacci数，这样在以后的计算中可以依次递推计算出。
	
	 3  算法分析
	 由算法知，Fibonacci查找在最坏情况下性能比折半查找差，但平均搜索次数少于折半查找，而且折半查找要求记录按关键字有序；Fibonacci查找的优点是分割时只需进行加、减运算。
	
	 */
	
	function fib(n) {
	    if (n === 0) return 0;
	    if (n === 1) return 1;
	    var f = void 0;
	    var f0 = 0;
	    var f1 = 1;
	    for (var i = 2; i <= n; ++i) {
	        f = f0 + f1;
	        f0 = f1;
	        f1 = f;
	    }
	    return f;
	}
	
	/**
	 * 在有序表ST中用Fibonacci方法查找关键字为key的记录
	 * @param sTable
	 * @param key
	 * @param n
	 */
	function fibonacciSearch(sTable, key) {
	    var n = arguments.length <= 2 || arguments[2] === undefined ? sTable.length : arguments[2];
	
	    var low = 0;
	    var high = n - 1;
	    var f1 = fib(n);
	    var f2 = fib(n - 1);
	
	    while (low <= high) {
	        var mid = low + f1 - 1;
	        if (sTable[mid] === key) return mid;else if (key < sTable[mid]) {
	            high = mid - 1;
	            f2 = f1 - f2;
	            f1 = f1 - f2;
	        } else {
	            low = mid + 1;
	            f1 = f1 - f2;
	            f2 = f2 - f1;
	        }
	    }
	    return -1;
	}
	
	console.log('fibonacciSearch: ');
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 5)); // 4
	console.log(fibonacciSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 89 */
/***/ function(module, exports) {

	"use strict";
	
	/*
	 静态查找
	
	 线性表是查找表最简单的一种组织方式
	
	 顺序查找(Sequential Search)
	 1  查找思想
	 从表的一端开始逐个将记录的关键字和给定K值进行比较，若某个记录的关键字和给定K值相等，查找成功；否则，若扫描完整个表，仍然没有找到相应的记录，则查找失败。
	
	 2  算法分析
	 不失一般性，设查找每个记录成功的概率相等，即Pi=1/n；查找第i个元素成功的比较次数Ci=n-i；
	 ◆ 查找成功时的平均查找长度ASL：(n+1)/2
	 ◆ 包含查找不成功时：查找失败的比较次数为n，若成功与不成功的概率相等，对每个记录的查找概率为Pi=1/(2n)，则平均查找长度ASL：3（n+1）/4
	 */
	
	function sequentialSearch(sTable, key) {
	  for (var i = sTable.length - 1; i >= 0 && sTable[i] !== key; --i) {}
	  return i;
	}
	
	console.log(sequentialSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Created by ldp on 2015/2/18.
	 */
	
	/*
	 计数排序
	
	 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。
	
	 计数排序的特征
	
	 当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
	 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
	 通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：
	 1.找出待排序的数组中最大和最小的元素
	 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项
	 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
	 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
	 
	 简要分析：
	 1.计数排序仅适合于小范围的数据进行排序
	 2.不能对浮点数进行排序
	 3.时间复杂度为 O(n)
	 4.计数排序是稳定的（排序后值相同的元素相对于原先的位置是不会发生变化的）
	 */
	
	function maxElem(arr) {
	    var max = arr[0];
	
	    for (var i = 1, len = arr.length; i < len; ++i) {
	        if (max < arr[i]) max = arr[i];
	    }return max;
	}
	
	/**
	 *
	 * @param {Array} sqList 要排序的数组
	 * @param {Number} k 数组中最大的元素值
	 * @returns {Array}
	 */
	function countSort(sqList, k) {
	    if (k == null) k = maxElem(sqList);
	    var len = sqList.length;
	    var c = [];
	    var b = [];
	
	    // 初始化辅助数组
	    for (var i = 0; i <= k; ++i) {
	        c[i] = 0;
	    } // 计数数组A中值等于C数组下标的个数
	    for (i = 0; i < len; ++i) {
	        c[sqList[i]]++;
	    } // 计数数组A中值小于等于C数组下标的个数
	    for (i = 1; i <= k; ++i) {
	        c[i] += c[i - 1];
	    }for (i = len - 1; i >= 0; --i) {
	        b[c[sqList[i]] - 1] = sqList[i];
	        --c[sqList[i]];
	    }
	
	    for (i = 0; i < len; ++i) {
	        sqList[i] = b[i];
	    }
	}
	exports.countSort = countSort;
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	countSort(arr, 100);
	console.log(arr + '');
	
	/*
	 基数排序
	
	 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。
	 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
	 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。
	
	 效率
	
	 基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·log(n))，k的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。
	 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k = logB(N)，N是待排序数据类型全集的势。虽然有B个不同的数字，需要B个不同的桶，但在每一轮处理中，判断每个待排序数据项只需要一次计算确定对应数位的值，因此在每一轮处理的时候都需要平均n次操作来把整数放到合适的桶中去，所以就有：
	 k约等于logB(N)
	 所以，基数排序的平均时间T就是：
	 T～= logB(N)·n
	 其中前一项是一个与输入数据无关的常数，当然该项不一定小于logn
	 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且在适当选择的B之下，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。
	
	 假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。
	
	 基数排序的简单描述就是将数字拆分为个位十位百位，每个位依次排序。因为这对算法稳定要求高，所以我们对数位排序用到上一个排序方法计数排序。因为基数排序要经过d (数据长度)次排序， 每次使用计数排序， 计数排序的复杂度为 On),  d 相当于常量和N无关，所以基数排序也是 O(n)。基数排序虽然是线性复杂度， 即对n个数字处理了n次，但是每一次代价都比较高， 而且使用计数排序的基数排序不能进行原地排序，需要更多的内存， 并且快速排序可能更好地利用硬件的缓存， 所以比较起来，像快速排序这些原地排序算法更可取。对于一个位数有限的十进制数，我们可以把它看作一个多元组，从高位到低位关键字重要程度依次递减。可以使用基数排序对一些位数有限的十进制数排序。
	 */
	
	// 求数据的最大位数
	function maxBit(arr) {
	    var d = 1;
	    var p = 10;
	
	    for (var i = 0, n = arr.length; i < n; ++i) {
	        while (arr[i] >= p) {
	            p *= 10;
	            ++d;
	        }
	    }
	
	    return d;
	}
	
	function radixSort(arr, d) {
	    d = d || maxBit(arr);
	    var n = arr.length;
	    var temp = [];
	    // 计数器
	    var count = [];
	    var radix = 1;
	
	    // 进行d次排序
	    for (var i = 1; i <= d; ++i) {
	        // 每次分配前清空计数器
	        for (var j = 0; j < 10; ++j) {
	            count[j] = 0;
	        } // 统计每个桶中的记录数
	        for (j = 0; j < n; ++j) {
	            var k = Math.floor(arr[j] / radix) % 10;
	            ++count[k];
	        }
	        for (j = 1; j < 10; ++j) {
	            count[j] += count[j - 1];
	        } // 将所有桶中记录依次收集到tmp中
	        for (j = n - 1; j >= 0; --j) {
	            k = Math.floor(arr[j] / radix) % 10;
	            temp[--count[k]] = arr[j];
	        }
	        //将临时数组的内容复制到arr中
	        for (j = 0; j < n; ++j) {
	            arr[j] = temp[j];
	        }radix *= 10;
	    }
	}
	exports.radixSort = radixSort;
	
	var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
	radixSort(arr, 100);
	console.log(arr + '');
	
	/*
	 桶排序
	
	 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。
	
	 基本思想
	
	 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
	 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。
	
	 分析
	
	 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
	 对N个关键字进行桶排序的时间复杂度分为两个部分：
	     (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
	     (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。
	 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
	     (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
	     (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。
	
	 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
	 O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
	 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。
	
	 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
	 */
	
	var BUCKETSNUM = 10;
	var quickSort = __webpack_require__(50).quickSort;
	
	function bucketSort(sqList) {
	    var n = sqList.length;
	    var bucketA = [];
	    var b = [];
	
	    // 初始化桶
	    for (var i = 0; i < BUCKETSNUM; ++i) {
	        b[i] = [];
	        bucketA[i] = 0;
	
	        for (var j = 0; j < n; ++j) {
	            b[i][j] = Infinity;
	        }
	    }
	
	    // 给桶填装数据
	    for (i = 0; i < n; ++i) {
	        var data = sqList[i];
	        // noto: 这里的映射函数是针对1-100之间的实数
	        var bucket = Math.floor(data / BUCKETSNUM);
	        b[bucket][bucketA[bucket]] = data;
	        ++bucketA[bucket];
	    }
	
	    // 针对每个桶进行快速排序
	    for (i = 0; i < BUCKETSNUM; ++i) {
	        if (bucketA[i] !== 0) {
	            quickSort(b[i], 0, bucketA[i] - 1);
	            //for(j = 1; j < bucketA[i]; ++j){
	            //    var p = b[i][j];
	            //    for(var k = j - 1; k >= 0 && p < b[i][k]; --k){
	            //        b[i][k + 1] = b[i][k];
	            //    }
	            //    b[i][k + 1] = p;
	            //}
	        }
	    }
	
	    //console.log(b);
	    //console.log(bucketA);
	
	    // 复制回去
	    var num = 0;
	    for (i = 0; i < BUCKETSNUM; ++i) {
	        if (bucketA[i] !== 0) {
	            for (j = 0; j < bucketA[i]; ++j) {
	                sqList[num++] = b[i][j];
	            }
	        }
	    }
	}
	exports.bucketSort = bucketSort;
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95];
	bucketSort(arr);
	console.log(arr + '');
	
	var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95, Infinity, Infinity, Infinity];
	quickSort(arr);
	console.log(arr + '');
	
	/*
	 性能分析
	 很明显，基数排序的性能比桶排序要略差。每一次关键字的桶分配都需要O(N)的时间复杂度，而且分配之后得到新的关键字序列又需要O(N)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2N) ，当然d要远远小于N，因此基本上还是线性级别的。基数排序的空间复杂度为O(N+M)，其中M为桶的数量。一般来说N>>M，因此额外空间需要大概N个左右。
	 但是，对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，基数排序的应用范围更加广泛。
	 */

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _StaticLinkedList = __webpack_require__(48);
	
	var _StaticLinkedList2 = _interopRequireDefault(_StaticLinkedList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultCompare = __webpack_require__(21);
	
	/*
	 插入排序
	
	 采用的是以 “玩桥牌者”的方法为基础的。即在考察记录Ri之前，设以前的所有记录R1, R2 ,…., Ri-1已排好序，然后将Ri插入到已排好序的诸记录的适当位置
	
	 最基本的插入排序是直接插入排序(Straight Insertion Sort) 。
	
	
	 直接插入排序
	
	 1  排序思想
	 将待排序的记录Ri，插入到已排好序的记录表R1, R2 ,…., Ri-1中，得到一个新的、记录数增加1的有序表。 直到所有的记录都插入完为止。
	 设待排序的记录顺序存放在数组R[1…n]中，在排序的某一时刻，将记录序列分成两部分：
	 ◆ R[1…i-1]：已排好序的有序部分；
	 ◆ R[i…n]：未排好序的无序部分。
	 显然，在刚开始排序时，R[1]是已经排好序的。
	
	 2.算法实现
	
	 3.算法分析
	 ⑴ 最好情况：若待排序记录按关键字从小到大排列(正序)，算法中的内循环无须执行，则一趟排序时：关键字比较次数1次，记录移动次数2次(R[i]→R[0], R[0]→R[j+1])。
	 则整个排序的关键字比较次数和记录移动次数分别是：
	 比较次数：n - 1          移动次数： 2 * (n - 1)
	
	 ⑵ 最坏情况：若待排序记录按关键字从大到小排列(逆序)，则一趟排序时：算法中的内循环体执行i-1，关键字比较次数i次，记录移动次数i+1。
	 则就整个排序而言：
	 比较次数： (n - 1) * (n + 1) / 2     移动次数: (n - 1) * (n + 4) / 2
	
	 一般地，认为待排序的记录可能出现的各种排列的概率相同，则取以上两种情况的平均值，作为排序的关键字比较次数和记录移动次数，约为n2/4，则复杂度为O(n2) 。
	
	
	 */
	
	/**
	 * Created by Luke on 2015/2/2.
	 */
	
	function straightInsertSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        // 设置哨兵, 当设置sqList[-1] = sqList[i]时，经测试效率更慢
	        // 因为js里面的变量作用域在函数内的
	        var temp = sqList[i];
	        // 查找插入位置，并将记录后移
	        for (var j = i - 1; j >= 0 && comp(temp, sqList[j]) < 0; --j) {
	            sqList[j + 1] = sqList[j];
	        } // 插入到正确位置
	        sqList[j + 1] = temp;
	    }
	}
	exports.straightInsertSort = straightInsertSort;
	
	var a = [7, 4, -2, 19, 13, 6];
	straightInsertSort(a);
	console.log(a + '');
	
	/*
	 其它插入排序
	
	 1  折半插入排序
	 当将待排序的记录R[i] 插入到已排好序的记录子表R[1…i-1]中时，由于R1, R2 ,…, Ri-1已排好序，则查找插入位置可以用“折半查找”实现，则直接插入排序就变成为折半插入排序。
	
	 从时间上比较，折半插入排序仅仅减少了关键字的比较次数，却没有减少记录的移动次数，故时间复杂度仍然为O(n2) 。
	
	
	 */
	
	function binaryInsertSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        var low = 0;
	        var high = i - 1;
	
	        while (low <= high) {
	            var mid = low + high >> 1;
	
	            if (comp(temp, sqList[mid]) < 0) high = mid - 1;else low = mid + 1;
	        }
	
	        for (var j = i - 1; j >= high + 1; --j) {
	            sqList[j + 1] = sqList[j];
	        }
	
	        sqList[high + 1] = temp;
	    }
	}
	exports.binaryInsertSort = binaryInsertSort;
	
	var b = [30, 13, 70, 85, 39, 42, 6, 20];
	binaryInsertSort(b);
	console.log(b + '');
	
	/*
	 2-路插入排序
	
	 是对折半插入排序的改进，以减少排序过程中移动记录的次数。附加n个记录的辅助空间，方法是：
	 ①  另设一个数组d，L[1]赋给d[1]，将d[1]看成是排好序的序列中中间位置的记录；
	 ②  分别将L[ ]中的第i个记录依次插入到d[1]之前或之后的有序序列中，具体方法：
	 ◆  L[i].key<d[1].key： L[i]插入到d[1]之前的有序表中；
	 ◆ L[i].key≥d[1].key： L[i]插入到d[1]之后的有序表中；
	 关键点：实现时将向量d看成是循环向量，并设两个指针first和final分别指示排序过程中得到的有序序列中的第一个和最后一个记录。
	
	 在2-路插入排序中，移动记录的次数约为n2/8 。但当L[1]是待排序记录中关键字最大或最小的记录时，2-路插入排序就完全失去了优越性。
	 */
	
	function path2InsertSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var d = [sqList[0]];
	    // first、final分别指示d中排好序的记录的第1个和最后1个记录的位置。
	    var first = 0;
	    var final = 0;
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        var item = sqList[i];
	
	        // 待插入记录小于d中最小值，插入到d[first]之前（不需移动d数组的元素）。
	        if (comp(item, d[first]) < 0) {
	            first = (first - 1) % len;
	            d[first] = item;
	        }
	        // 待插入记录大于d中最小值，插入到d[final]之后（不需移动d数组的元素）。
	        else if (comp(item, d[final]) > 0) {
	                d[++final] = item;
	            }
	            // 待插入记录大于d中最小值，小于d中最大值，插入到d的中间（需要移动d数组的元素）。
	            else {
	                    // 移动d尾部元素以便按序插入记录。
	                    var j = final++;
	                    while (comp(item, d[j]) < 0) {
	                        d[(j + 1) % len] = d[j];
	                        j = (j - 1) % len;
	                    }
	                    d[(j + 1) % len] = item;
	                }
	    }
	
	    // 循环把d赋给sqList
	    for (i = 0; i < len; ++i) {
	        sqList[i] = d[(i + first) % len];
	    }
	}
	exports.path2InsertSort = path2InsertSort;
	
	var c = [49, 38, 65, 13, 97, 27, 76, 5, 100, 78, 15, 15, 20];
	path2InsertSort(c);
	console.log(c + '');
	
	/*
	表插入排序
	
	前面的插入排序不可避免地要移动记录，若不移动记录就需要改变数据结构。
	初始化：下标值为0的分量作为表头结点，关键字取为最大值，各分量的指针值为空；
	①  将静态链表中数组下标值为1的分量(结点)与表头结点构成一个循环链表；
	② i=2 ，将分量R[i]按关键字递减插入到循环链表；
	③  增加i ，重复②，直到全部分量插入到循环链表。
	
	和直接插入排序相比，不同的是修改2n次指针值以代替移动记录，而关键字的比较次数相同，故时间复杂度为O(n2)。
	
	表插入排序得到一个有序链表，对其可以方便地进行顺序查找，但不能实现随机查找。为了能实现有序表的折半查找根据需要，可以对记录进行重排.
	
	重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。
	
	例子中，链表中第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记录应移至数组的第一个分量，则将list[1]和list[6]互换，并为了不中断静态链表中的链，即在继续顺链表扫描时仍能找到互换之前在list[1]中的结点，令互换之后的list[1]中的游标改为6
	
	推广至一般情况，若第i个最小关键字的结点是数组中下标为p且p > i的分量，则互换list[i]和list[p]，且令list[i]中的游标改为p；
	由于此时数组中所有小于i的分量中已是到位记录，则当p<i时，应顺链继续查找直到p>=i为止。
	 */
	
	// 表插入排序
	function staticLinkedListInsertSort(sllist, comp) {
	    if (comp == null) comp = defaultCompare;
	    // 构成循环链表
	    sllist[0].cur = 1;
	    sllist[1].cur = 0;
	
	    var p, q;
	    for (var i = 2, len = sllist.length; i <= len; ++i) {
	        p = 0;
	        var x = sllist[i].data;
	
	        while (sllist[p].cur && comp(sllist[sllist[p].cur].data, x) < 0) {
	            p = sllist[p].cur;
	        } // 当遇到大于当前关键字的下标时，插入到其前驱和后继的中间
	        q = sllist[p].cur;
	        sllist[p].cur = i;
	        sllist[i].cur = q;
	    }
	}
	exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
	
	// 重排静态链表，静态链表下标已排好序
	function arrange(sllist) {
	    var p = sllist[0].cur;
	
	    for (var i = 1, len = sllist.length; i < len; ++i) {
	        // 第i个记录在list中的当前位置应不小于i
	        // 找到第i个记录，并用p指示其在list中当前位置
	        while (p < i) {
	            p = sllist[p].cur;
	        } // q指向尚未调整的表尾
	        var q = sllist[p].cur;
	
	        if (p !== i) {
	            // 交换记录，使第i个记录到位
	            var temp = sllist[p];
	            sllist[p] = sllist[i];
	            sllist[i] = temp;
	            // 指向被移走的记录，使得以后可有while循环找到
	            sllist[i].cur = p;
	        }
	
	        // p指向尚未调整的表尾
	        p = q;
	    }
	}
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 52];
	var d = new _StaticLinkedList2.default();
	d.create(arr);
	staticLinkedListInsertSort(d);
	console.log(d);
	arrange(d);
	console.log(d);
	
	/*
	希尔排序
	
	希尔排序(Shell Sort，又称缩小增量法)是一种分组插入排序方法。
	
	1  排序思想
	①   先取一个正整数d1(d1<n)作为第一个增量，将全部n个记录分成d1组，把所有相隔d1的记录放在一组中，即对于每个k(k=1, 2,  … d1)，R[k], R[d1+k], R[2d1+k] , …分在同一组中，在各组内进行直接插入排序。这样一次分组和排序过程称为一趟希尔排序；
	②   取新的增量d2<d1，重复①的分组和排序操作；直至所取的增量di=1为止，即所有记录放进一个组中排序为止。
	
	2  排序示例
	设有10个待排序的记录，关键字分别为9, 13, 8, 2, 5, 13, 7, 1, 15, 11，增量序列是5, 3, 1，希尔排序的过程:
	初始关键字序列:    9     13     8      2      5      13      7      1      15      11
	第一趟排序后:      9     7      1      2      5      13      13     8      15      11
	第二趟排序后:      2     5      1      9      7      13      11     8      15      13
	第三趟排序后:      1     2      5      7      8      9      11     13      13      15
	
	
	希尔排序的分析比较复杂，涉及一些数学上的问题，其时间是所取的“增量”序列的函数。
	
	希尔排序特点
	子序列的构成不是简单的“逐段分割”，而是将相隔某个增量的记录组成一个子序列。
	希尔排序可提高排序速度，原因是：
	◆ 分组后n值减小，n²更小，而T(n)=O(n²),所以T(n)从总体上看是减小了；
	◆ 关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序。
	
	增量序列取法
	◆ 无除1以外的公因子；
	◆ 最后一个增量值必须为1。
	
	相关资料： http://wenku.baidu.com/link?url=q7kzOxXqc0BLaGUVDY43FQOh2aX1UqBHkkYd3VMwJhJo6rv4SiU686RW3kQCSqGEKytl12S8fBOpwhq-runhX_pbZcg6BeD-miYMPgDhXxK
	 */
	
	function shellInsert(sqList, dk, comp) {
	    for (var i = dk, len = sqList.length; i < len; ++i) {
	        var temp = sqList[i];
	        if (comp(temp, sqList[i - dk]) < 0) {
	            for (var j = i - dk; j >= 0 && comp(temp, sqList[j]) < 0; j -= dk) {
	                sqList[j + dk] = sqList[j];
	            }sqList[j + dk] = temp;
	        }
	    }
	}
	
	function shellSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var delta = createDelta(sqList.length);
	    //console.log(delta);
	    for (var k = 0, t = delta.length; k < t; ++k) {
	        shellInsert(sqList, delta[k], comp);
	    }
	}
	exports.shellSort = shellSort;
	
	function createDelta(n) {
	    var arr = [];
	    var t = Math.log(n - 1) / Math.log(2) | 0; // Math.log(n - 1) / Math.log(2), Math.log(n + 1) / Math.log(2)
	    for (var k = 0; k <= t; ++k) {
	        arr[k] = Math.pow(2, t - k) + 1;
	    } // Math.pow(2, t - i + 1) - 1, Math.pow(2, t - i) + 1
	
	    arr[arr.length] = 1;
	
	    return arr;
	}
	
	console.log('\n\nShell Sort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	shellSort(arr);
	console.log(arr + '');

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _LinkedList = __webpack_require__(47);
	
	var _LinkedList2 = _interopRequireDefault(_LinkedList);
	
	var _Queue = __webpack_require__(12);
	
	var _Queue2 = _interopRequireDefault(_Queue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by ldp on 2015/2/7.
	 */
	
	var defaultCompare = __webpack_require__(21);
	
	/*
	 归并排序
	
	 归并(Merging) ：是指将两个或两个以上的有序序列合并成一个有序序列。若采用线性表(无论是那种存储结构)易于实现，其时间复杂度为O(m+n) 。
	 归并思想实例：两堆扑克牌，都已从小到大排好序，要将两堆合并为一堆且要求从小到大排序。
	 ◆  将两堆最上面的抽出(设为C1，C2)比较大小，将小者置于一边作为新的一堆(不妨设C1<C2)；再从第一堆中抽出一张继续与C2进行比较，将较小的放置在新堆的最下面；
	 ◆ 重复上述过程，直到某一堆已抽完，然后将剩下一堆中的所有牌转移到新堆中。
	
	 1   排序思想
	 ①  初始时，将每个记录看成一个单独的有序序列，则n个待排序记录就是n个长度为1的有序子序列；
	 ②  对所有有序子序列进行两两归并，得到n/2个长度为2或1的有序子序列——一趟归并；
	 ③  重复② ，直到得到长度为n的有序序列为止。
	
	 上述排序过程中，子序列总是两两归并，称为2-路归并排序。其核心是如何将相邻的两个子序列归并成一个子序列。设相邻的两个子序列分别为：
	 {R[k], R[k+1], …, R[m]}和{R[m+1], R[m+2],…, R[h]}，将它们归并为一个有序的子序列：
	 {DR[l], DR[l+1], …, DR[m], DR[m+1], …, DR[h] }
	
	 例：设有9个待排序的记录，关键字分别为23, 38, 22, 45, 23, 67, 31, 15, 41，归并排序的过程。
	 初始关键字: [23]   [38]   [22]   [45]   [23]   [67]   [31]   [15]   [41]
	              |      |      |      |      |      |      |      |
	              --------      --------      --------      --------
	 一趟归并后: [23    38]    [22     45]    [23     67]    [15     31]   [41]
	                 |              |             |              |
	                 ---------------               ---------------
	 二趟归并后: [22     23      38     45]    [15     23     31     67]    [41]
	                        |                              |
	                        --------------------------------
	 三趟归并后: [15     22      23     23     31     38     45     67]    [41]
	                                       |                                |
	                                       ----------------------------------
	 四趟归并后: [15     22      23     23     31     38     41     45     67
	
	
	 2  一趟归并排序
	 一趟归并排序都是从前到后，依次将相邻的两个有序子序列归并为一个，且除最后一个子序列外，其余每个子序列的长度都相同。设这些子序列的长度为d，则一趟归并排序的过程是：
	 从j=0开始，依次将相邻的两个有序子序列
	 R[j…j+d-1]和R[j+d…j+2d-1]进行归并；每次归并两个子序列后，j后移动2d个位置，即
	 j=j+2d；若剩下的元素不足两个子序列时，分以下两种情况处理：
	 ①  剩下的元素个数>d：再调用一次上述过程，将一个长度为d的子序列和不足d的子序列进行归并；
	 ②  剩下的元素个数≤d：将剩下的元素依次复制到归并后的序列中。
	
	
	 3.算法分析
	具有n个待排序记录的归并次数是㏒2n，而一趟归并的时间复杂度为O(n)，则整个归并排序的时间复杂度无论是最好还是最坏情况均为O(n㏒2n)。在排序过程中，使用了辅助向量DR，大小与待排序记录空间相同，则空间复杂度为O(n)。归并排序是稳定的。
	
	 */
	
	var nCount = 0;
	var nonRecursiveCount = 0;
	var recursiveCount = 0;
	
	/**
	 * 将有序的sr[s1..e1]和sr[s2..e2]归并为有序的tr[s1..e2]
	 * @param sr
	 * @param s1
	 * @param e1
	 * @param e2
	 */
	function merge(sr, s1, e1, e2, comp) {
	    var temp = [];
	    var i = s1;
	    var j = e1 + 1;
	    var k = 0;
	
	    while (i <= e1 && j <= e2) {
	        if (comp(sr[i], sr[j]) < 0) temp[k++] = sr[i++];else temp[k++] = sr[j++];
	    }
	    while (i <= e1) {
	        temp[k++] = sr[i++];
	    }while (j <= e2) {
	        temp[k++] = sr[j++];
	    } // 复制回去
	    for (i = s1, k = 0; i <= e2; ++i, ++k) {
	        sr[i] = temp[k];
	    }
	}
	
	/**
	 * 2-路归并排序递归算法
	 * @param {Array} sr
	 * @param {Number} s
	 * @param {Number} t
	 */
	function mergeSortRecursive(sr, s, t, comp) {
	    if (comp == null) comp = defaultCompare;
	    if (s == null) s = 0;
	    if (t == null) t = sr.length - 1;
	
	    if (s >= t) return;
	
	    // 将sr[s..t]平分为sr[s..m]和sr[m+1..t]
	    var m = s + t >> 1;
	    // 递归地将sr[s..m]归并为有序的sr[s..m]
	    mergeSortRecursive(sr, s, m, comp);
	    // 递归地将sr[m+1..t]归并为有序的sr[m+1..t]
	    mergeSortRecursive(sr, m + 1, t, comp);
	    // 将sr[s..m]和sr[m+1..t]归并到sr[s..t];
	    merge(sr, s, m, t, comp);
	}
	exports.mergeSortRecursive = mergeSortRecursive;
	
	console.log('\n\nmergeSortRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortRecursive(arr);
	console.log(arr + '');
	
	function mergeSortNonRecursive(sr, comp) {
	    if (comp == null) comp = defaultCompare;
	    var j, k;
	    for (var d = 1, n = sr.length - 1; d < n; d *= 2) {
	        // 一趟归并排序算法
	        j = 0;
	
	        // 子序列两两归并
	        while ((k = j + 2 * d - 1) < n) {
	            merge(sr, j, j + d - 1, k, comp);
	            j = k + 1;
	        }
	
	        // 剩余元素个数超过一个子序列长度
	        if (j + d - 1 < n) merge(sr, j, j + d - 1, n, comp);
	        // 剩余子序列复制
	        else merge(sr, j, n, n, comp);
	    }
	}
	exports.mergeSortNonRecursive = mergeSortNonRecursive;
	
	console.log('\nmergeSortNonRecursive:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	mergeSortNonRecursive(arr);
	console.log(arr + '');
	
	// 自然合并排序
	// http://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html
	// http://www.cnblogs.com/lanke/archive/2013/01/15/2860487.html
	/*
	自然归并是归并排序的一个变形，效率更高一些，可以在归并排序非递归实现的基础上进行修改.对于已经一个已经给定数组a,通常存在多个长度大于1的已经自然排好的子数组段,因此用一次对数组a的线性扫描就可以找出所有这些排好序的子数组段,然后再对这些子数组段俩俩合并.
	 */
	
	// 扫描得到子串的函数
	function pass(sqList, rec, comp) {
	    var num = 0;
	    rec[num++] = 0;
	
	    for (var i = 1, len = sqList.length; i < len; ++i) {
	        if (comp(sqList[i], sqList[i + 1]) > 0) rec[num++] = i + 1;
	    }
	    rec[num++] = len;
	
	    return num;
	}
	
	function natureMergeSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var rec = [];
	
	    //num=2说明已经排好序了
	    //每循环一次，进行一次pass()操作
	    for (var num = pass(sqList, rec, comp); num !== 2; num = pass(sqList, rec, comp)) {
	        for (var i = 0; i + 2 < num; i += 2) {
	            merge(sqList, rec[i], rec[i + 1] - 1, rec[i + 2] - 1, comp);
	        }
	    }
	}
	
	exports.natureMergeSort = natureMergeSort;
	
	console.log('\nnatureMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	natureMergeSort(arr);
	console.log(arr + '');
	
	console.log(recursiveCount);
	console.log(nonRecursiveCount);
	console.log(nCount);
	
	// 双向自然合并排序算法
	/*
	双向自然合并排序是根据欲排序数据局部不是升序就是降序的自然有序特点,先线性扫描出自然有序的子数组段,再进行合并排序.扫描时的有序数段长度越长,段数越少,对应合并树的层数就会越少,算法的效率越高.
	 */
	var naturalMergeSort = function () {
	    return naturalMergeSort;
	
	    function naturalMergeSort(a, comp) {
	        if (comp == null) comp = defaultCompare;
	        var b = [];
	        var n = a.length;
	        while (!mergeRuns(a, b, n, comp)) {}
	    }
	
	    function mergeRuns(a, b, n, comp) {
	        var i = 0;
	        var k = 0;
	        var asc = true;
	        var x;
	
	        while (i < n) {
	            k = i;
	            // 找到最后一个递增序列元素
	            do {
	                x = a[i++];
	            } while (i < n && comp(x, a[i]) <= 0);
	            // 找到最后一个递减序列元素
	            while (i < n && comp(x, a[i]) >= 0) {
	                x = a[i++];
	            } // 归并递增序列和递减序列，结果可能递增或递减
	            merge(a, b, k, i - 1, asc, comp);
	            asc = !asc;
	        }
	
	        // 当k等于0时代表a已经排好序了
	        return k === 0;
	    }
	
	    function merge(a, b, low, high, asc, comp) {
	        var k = asc ? low : high;
	        var c = asc ? 1 : -1;
	        var i = low;
	        var j = high;
	
	        while (i <= j) {
	            if (comp(a[i], a[j]) <= 0) b[k] = a[i++];else b[k] = a[j--];
	            k += c;
	        }
	        for (i = k = low, j = high; i <= j; ++i, ++k) {
	            a[i] = b[k];
	        }
	    }
	}();
	
	exports.naturalMergeSort = naturalMergeSort;
	
	console.log('\nnaturalMergeSort:');
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	naturalMergeSort(arr);
	console.log(arr + '');
	
	// 链表存储结构的自然合并排序
	var linkedListNaturalMergeSort = function () {
	    return mergeSort;
	
	    function mergeSort(linkedlist, needReplace, comp) {
	        if (comp == null) comp = defaultCompare;
	        if (!linkedlist) return linkedlist;
	
	        var queue = new _Queue2.default();
	        var list = linkedlist.head;
	
	        if (!list || !list.next) return linkedlist;
	
	        needReplace = needReplace == null ? true : needReplace;
	        var u = list;
	        var t = list;
	        var v;
	        // 将递增的结点放入到队列中（会被切断）
	        for (; t; t = u) {
	            while (u && u.next && comp(u.data, u.next.data) <= 0) {
	                u = u.next;
	            }v = u;
	            u = u.next;
	            v.next = null;
	            queue.enQueue(t);
	        }
	
	        t = queue.deQueue();
	        // 合并结点
	        while (queue.size) {
	            queue.enQueue(t);
	            var a = queue.deQueue();
	            var b = queue.deQueue();
	            t = merge(a, b, comp);
	        }
	
	        if (needReplace) linkedlist.head = t;
	
	        return t;
	    }
	
	    function merge(a, b, comp) {
	        var c = new _LinkedList2.default();
	        var head = { data: null, next: null };
	        c.head = head;
	        c = c.head;
	
	        while (a && b) {
	            if (comp(a.data, b.data) < 0) {
	                c.next = a;
	                c = a;
	                a = a.next;
	            } else {
	                c.next = b;
	                c = b;
	                b = b.next;
	            }
	        }
	
	        c.next = a ? a : b;
	
	        return head.next;
	    }
	}();
	exports.linkedListNaturalMergeSort = linkedListNaturalMergeSort;
	
	var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
	var linkedList = new _LinkedList2.default(arr);
	linkedListNaturalMergeSort(linkedList);
	console.log(linkedList + '');

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Created by luke on 2015/2/2.
	 */
	
	var defaultCompare = __webpack_require__(21);
	
	/*
	选择排序
	
	选择排序(Selection Sort)的基本思想是：每次从当前待排序的记录中选取关键字最小的记录表，然后与待排序的记录序列中的第一个记录进行交换，直到整个记录序列有序为止。
	
	
	简单选择排序
	
	简单选择排序(Simple Selection Sort ，又称为直接选择排序)的基本操作是：通过n-i次关键字间的比较，从n-i+1个记录中选取关键字最小的记录，然后和第i个记录进行交换，i=1, 2, … n-1 。
	1  排序示例
	例：设有关键字序列为：7, 4, -2, 19, 13, 6，直接选择排序的过程：
	初始记录的关键字：  7     4    -2     19    13    6
	    第一趟排序：  -2     4     7     19    13    6
	    第二趟排序：  -2     4     7     19    13    6
	    第三趟排序：  -2     4     6     19    13    7
	    第四趟排序：  -2     4     6     7     13    19
	    第五趟排序：  -2     4     6     7     13    19
	    第六趟排序：  -2     4     6     7     13    19
	
	2.算法分析
	整个算法是二重循环：外循环控制排序的趟数，对n个记录进行排序的趟数为n-1趟；内循环控制每一趟的排序。
	进行第i趟排序时，关键字的比较次数为n-i，则：
	比较次数： n*(n - 1) / 2
	时间复杂度是：T(n)=O(n2)
	空间复杂度是：S(n)=O(1)
	从排序的稳定性来看，直接选择排序是不稳定的。
	
	 */
	
	function simpleSelectionSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    for (var i = 0, len = sqList.length; i < len; ++i) {
	        for (var k = i, j = k + 1; j < len; ++j) {
	            if (comp(sqList[j], sqList[k]) < 0) k = j;
	        }if (k !== i) {
	            var temp = sqList[k];
	            sqList[k] = sqList[i];
	            sqList[i] = temp;
	        }
	    }
	}
	exports.simpleSelectionSort = simpleSelectionSort;
	
	var arr = [7, 4, -2, 19, 13, 6];
	simpleSelectionSort(arr);
	console.log(arr + '');
	
	/*
	树形选择排序
	
	首先对n个记录的关键字两两进行比较，选取n/2个较小者；然后这n/2个较小者两两进行比较，选取n/4个较小者… 如此重复，直到只剩1个关键字为止。
	该过程可用一棵有n个叶子结点的完全二叉树表示，每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点的关键字就是最小的关键字。
	输出最小关键字后，根据关系的可传递性，欲选取次小关键字，只需将叶子结点中的最小关键字改为“最大值” ，然后重复上述步骤即可。
	含有n个叶子结点的完全二叉树的深度为㏒2n+1，则总的时间复杂度为O(n㏒2n) 。
	
	但这种排序方法尚有辅助存储空间较多,和最大值进行多余比较等缺点。为了弥补这些缺陷，出现了另一种选择排序---堆排序
	 */
	
	/*
	堆排序
	
	1  堆的定义
	是n个元素的序列H={k1, k2 , … kn} ，满足：
	    ki≤k2i       当2i≤n时
	    ki≤k2i+1   当2i+1≤n时
	
	由堆的定义知，堆是一棵以k1为根的完全二叉树。若对该二叉树的结点进行编号(从上到下，从左到右)，得到的序列就是将二叉树的结点以顺序结构存放，堆的结构正好和该序列结构完全一致。
	
	2  堆的性质
	    1)  堆是一棵采用顺序存储结构的完全二叉树， k1是根结点；
	    2)  堆的根结点是关键字序列中的最小(或最大)值，分别称为小(或大)根堆；
	    3)  从根结点到每一叶子结点路径上的元素组成的序列都是按元素值(或关键字值)非递减(或非递增)的；
	    4)  堆中的任一子树也是堆。
	
	利用堆顶记录的关键字值最小(或最大)的性质，从当前待排序的记录中依次选取关键字最小(或最大)的记录，就可以实现对数据记录的排序，这种排序方法称为堆排序。
	
	3  堆排序思想
	
	①  对一组待排序的记录，按堆的定义建立堆；
	②  将堆顶记录和最后一个记录交换位置，则前n-1个记录是无序的，而最后一个记录是有序的；
	③  堆顶记录被交换后，前n-1个记录不再是堆，需将前n-1个待排序记录重新组织成为一个堆，然后将堆顶记录和倒数第二个记录交换位置，即将整个序列中次小关键字值的记录调整(排除)出无序区；
	④  重复上述步骤，直到全部记录排好序为止。
	
	结论：排序过程中，若采用小根堆，排序后得到的是非递减序列；若采用大根堆，排序后得到的是非递增序列。
	
	堆排序的关键
	①  如何由一个无序序列建成一个堆？
	②  如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？
	
	4  堆的调整——筛选
	⑴ 堆的调整思想
	输出堆顶元素之后，以堆中最后一个元素替代之；然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；重复上述操作，直到是叶子结点或其关键字值小于等于左、右子树的关键字的值，将得到新的堆。称这个从堆顶至叶子的调整过程为“筛选”。
	
	注意：筛选过程中，根结点的左、右子树都是堆，因此，筛选是从根结点到某个叶子结点的一次调整过程。
	
	5  堆的建立
	利用筛选算法，可以将任意无序的记录序列建成一个堆，设R[1],R[2], …,R[n]是待排序的记录序列。
	将二叉树的每棵子树都筛选成为堆。只有根结点的树是堆。第⌊n/2⌋个结点之后的所有结点都没有子树，即以第⌊n/2⌋个结点之后的结点为根的子树都是堆。因此，以这些结点为左、右孩子的结点，其左、右子树都是堆，则进行一次筛选就可以成为堆。同理，只要将这些结点的直接父结点进行一次筛选就可以成为堆…。
	只需从第⌊n/2⌋个记录到第1个记录依次进行筛选就可以建立堆。
	
	6   堆排序算法实现
	堆的根结点是关键字最小的记录，输出根结点后，是以序列的最后一个记录作为根结点，而原来堆的左、右子树都是堆，则进行一次筛选就可以成为堆。
	
	7  算法分析
	主要过程：初始建堆和重新调整成堆。设记录数为n，所对应的完全二叉树深度为h 。
	◆  初始建堆：每个非叶子结点都要从上到下做“筛选” 。第i层结点数≤2i-1，结点下移的最大深度是h-i，而每下移一层要比较2次，则比较次数C1(n)为：
	C1(n)≤4(n-㏒2n-1)
	◆  筛选调整：每次筛选要将根结点“下沉”到一个合适位置。第i次筛选时：堆中元素个数为n-i+1；堆的深度是㏒2(n-i+1)+1，则进行n-1次“筛选”的比较次数C2(n)为：
	C2(n)<2n㏒2n
	堆排序的比较次数的数量级为： T(n)=O(n㏒2n)；而附加空间就是交换时所用的临时空间，故空间复杂度为： S(n)=O(1) 。
	
	堆排序适合记录数较大的情况
	
	
	http://blog.csdn.net/zz198808/article/details/7678055
	 */
	
	/**
	 * 已知sqList[s..m]中记录的关键字除sqList[s]之外均满足堆的定义，
	 * 本函数调整sqList[s]的关键字，使sqList[s..m]成为一个大堆顶（对其中关键字而言）
	 * @param {Array} sqList
	 * @param {Number} s
	 * @param {Number} m
	 */
	function heapAdjust(sqList, s, m, comp) {
	    var rc = sqList[s];
	
	    // 沿关键字较大的孩子结点向下筛选
	    for (var j = 2 * s + 1; j <= m; j = j * 2 + 1) {
	        // j为关键字较大的记录下标
	        if (j < m && comp(sqList[j], sqList[j + 1]) < 0) ++j;
	        // rc应插入在位置s上
	        if (comp(rc, sqList[j]) >= 0) break;
	        sqList[s] = sqList[j];
	        s = j;
	    }
	
	    sqList[s] = rc;
	}
	
	function heapSort(sqList, comp) {
	    if (comp == null) comp = defaultCompare;
	    var len = sqList.length;
	    // 建立大堆顶
	    for (var i = (len >> 1) - 1; i >= 0; --i) {
	        heapAdjust(sqList, i, len - 1, comp);
	    }for (i = len - 1; i > 0; --i) {
	        // 将堆顶记录和当前未经排序子序列sqList[0..i]中
	        // 最后一个记录相互交换
	        var temp = sqList[i];
	        sqList[i] = sqList[0];
	        sqList[0] = temp;
	
	        // 将sqList[0..i - 1]重新调整为大堆顶
	        heapAdjust(sqList, 0, i - 1, comp);
	    }
	}
	exports.heapSort = heapSort;
	
	var arr = [1, 3, 4, 5, 7, 2, 6, 8, 0];
	heapSort(arr);
	console.log(arr + '');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 堆分配存储表示
	 *
	 * 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在c语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间。
	 */
	
	var HString = function () {
	    function HString() {
	        (0, _classCallCheck3.default)(this, HString);
	
	        this.ch = {};
	        this.length = 0;
	    }
	
	    // 1 <= position <= this.length.在串的第position个字符之前插入串tHString
	
	
	    (0, _createClass3.default)(HString, [{
	        key: 'strInsert',
	        value: function strInsert(position, tHString) {
	            if (position < 1 || position > this.length + 1) throw new Error('unexpected position');
	
	            if (tHString.length) {
	                // 为插入t而腾出位置
	                var i = this.length - 1;
	                for (var len = position - 1; i >= len; --i) {
	                    this.ch[i + tHString.length] = this.ch[i];
	                }stringCopy(this.ch, tHString.ch, position - 1, tHString.length - 1, 0);
	
	                this.length += tHString.length;
	            }
	        }
	    }, {
	        key: 'strAssign',
	        value: function strAssign(chars) {
	            stringCopy(this.ch, chars, 0, chars.length - 1, 0);
	            this.length = chars.length;
	        }
	    }, {
	        key: 'strLength',
	        value: function strLength() {
	            return this.length;
	        }
	    }, {
	        key: 'strCompare',
	        value: function strCompare(tHString) {
	            for (var i = 0, len = this.length; i < len && i < tHString.length; i++) {
	                if (this.ch[i] !== tHString.ch[i]) return this.ch[i] - tHString.ch[i];
	            }return this.length - tHString.length;
	        }
	    }, {
	        key: 'clearString',
	        value: function clearString() {
	            this.ch = {};
	            this.length = 0;
	        }
	    }, {
	        key: 'concat',
	        value: function concat(s) {
	            var t = new HString();
	
	            // t.ch[0..this.length - 1] = this.ch[0..this.length - 1]
	            stringCopy(t.ch, this.ch, 0, this.length - 1, 0);
	            t.length = this.length + s.length;
	            // t.ch[this.length..t.length - 1] = s.ch[0..s.length - 1]
	            stringCopy(t.ch, s.ch, this.length, s.length - 1, 0);
	
	            return t;
	        }
	    }, {
	        key: 'substring',
	        value: function substring(position, len) {
	            position = ~ ~position || 0;
	            len = ~ ~len || this.length;
	            if (position < 0 || position > this.length - 1 || len < 0 || len > this.length - position) throw new Error('unexpected parameter');
	
	            var sub = new HString();
	            stringCopy(sub.ch, this.ch, 0, len - 1, position);
	            sub.length = len;
	
	            return sub;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var s = '';
	            for (var i = 0, len = this.length; i < len; i++) {
	                s += this.ch[i];
	            }
	            return s;
	        }
	    }]);
	    return HString;
	}();
	
	exports.default = HString;
	
	
	function stringCopy(destination, target, destStart, length, targetStart) {
	    destStart = destStart || 0;
	    length = length || target.length;
	    targetStart = targetStart || 0;
	
	    for (var i = 0; i <= length; i++) {
	        destination[destStart + i] = target[targetStart + i];
	    }
	}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _index = __webpack_require__(16);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Chunk = function Chunk() {
	    var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	    (0, _classCallCheck3.default)(this, Chunk);
	
	    this.chunkSize = chunkSize;
	    this.ch = [];
	    for (var i = 0; i < this.chunkSize; i++) {
	        this.ch[i] = '#';
	    }
	    // type: Chunk
	    this.next = null;
	}; /**
	    * 串的块链存储表示
	    *
	    * 和线性表的链式存储结构相类似，也可采用链式方式存储串值。由于串结构的特殊性--结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。
	    * 下面是结点大小为4（即每个结点存放4个字符）的链表
	    * head --> (a,b,c,d) --> (e,f,g,h) --> (i###)
	    * 下面是结点大小为1的链表
	    * head --> (a) --> (b) --> (c) --> ... --> (i)
	    *
	    * 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其它非串值字符。
	    * 为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度，称如此定义的串存储结构为块链结构。
	    *
	    * 由于一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行连接操作，但应注意连接时需处理第一个串尾的无效字符。
	    * 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响到串处理的效率。如果串很长，这要求我们考虑串值的存储密度：
	    * 存储密度 = 串值所占的存储位 / 实际分配的存储位
	    *
	    * 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。
	    */
	
	
	var LString = function () {
	    function LString() {
	        var chunkSize = arguments.length <= 0 || arguments[0] === undefined ? 4 : arguments[0];
	        (0, _classCallCheck3.default)(this, LString);
	
	        // type Chunk
	        this.head = null;
	        // type: chunk
	        this.tail = null;
	        // 串的当前长度
	        this.length = 0;
	        this.chunkSize = chunkSize;
	    }
	
	    // 将字符串转换成LString类型
	
	
	    (0, _createClass3.default)(LString, [{
	        key: 'strAssign',
	        value: function strAssign(chars) {
	            this.head = this.tail = new Chunk(this.chunkSize);
	            this.length = chars.length;
	
	            var current = this.head;
	            for (var i = 0, len = chars.length; i < len; i++) {
	                current.ch[i % this.chunkSize] = chars[i];
	                if (i + 1 < len && (i + 1) % this.chunkSize === 0) {
	                    current.next = new Chunk();
	                    current = current.next;
	                }
	            }
	
	            this.tail = current;
	        }
	        // 字符串对比
	        // TODO 是否去掉chunkSize的对比
	
	    }, {
	        key: 'strCompare',
	        value: function strCompare(tLString) {
	            var current = this.head;
	            var curT = tLString.head;
	
	            if (this.length !== tLString.length) return false;
	
	            while (current) {
	                for (var i = 0; i < this.chunkSize; i++) {
	                    if (current.ch[i] !== curT.ch[i]) return false;
	                }
	
	                current = current.next;
	                curT = curT.next;
	            }
	
	            return true;
	        }
	    }, {
	        key: 'clearString',
	        value: function clearString() {
	            this.head = this.tail = null;
	            this.length = 0;
	        }
	    }, {
	        key: 'concat',
	        value: function concat(tLSting) {
	            if (!tLSting.length) return;
	
	            var ret = new LString(this.chunkSize);
	
	            if (this.head === null) {
	                copyString(ret, tLSting);
	            } else {
	                ret.head = ret.tail = new Chunk(this.chunkSize);
	                copyString(ret, this);
	
	                var index = ret.tail.ch.indexOf('#');
	                if (index === -1) {
	                    copyString(ret, tLSting);
	                } else {
	                    copyString(ret, tLSting, ret.tail, tLSting.head, index);
	                }
	            }
	
	            return ret;
	        }
	    }, {
	        key: 'substring',
	        value: function substring(pos, len) {
	            pos = ~ ~pos || 0;
	            len = ~ ~len || this.length;
	            if (pos < 0 || pos > this.length - 1 || len < 0 || len > this.length - pos) throw new Error('unexpected parameter');
	
	            var sub = new LString(this.chunkSize);
	            var current = findPosChunk(this, pos);
	            var curS = sub.head = new Chunk(this.chunkSize);
	            var i = 0;
	            sub.length = len;
	
	            outerloop: while (current) {
	                for (var j = 0, size = this.chunkSize; j < size; j++) {
	                    if (i === len) {
	                        break outerloop;
	                    } else {
	                        curS.ch[j] = current.ch[(i + pos) % this.chunkSize];
	                        i++;
	                        if ((i + pos) % this.chunkSize === 0) {
	                            current = current.next;
	                        }
	                        if (i % this.chunkSize === 0 && (current.ch[i] || current.next)) {
	                            curS.next = new Chunk(this.chunkSize);
	                            curS = curS.next;
	                        }
	                    }
	                }
	            }
	
	            return sub;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var current = this.head;
	
	            if (current === null) return '';
	
	            var str = '';
	            while (current) {
	                for (var i = 0, len = this.chunkSize; i < len; i++) {
	                    var ch = current.ch[i];
	                    if (ch === '#') {
	                        return str;
	                    } else {
	                        str += current.ch[i];
	                    }
	                }
	                current = current.next;
	            }
	
	            return str;
	        }
	    }]);
	    return LString;
	}();
	
	exports.default = LString;
	
	
	function findPosChunk(lString, pos) {
	    var current = lString.head;
	    while (current) {
	        for (var i = 0, len = lString.chunkSize; i < len; i++) {
	            if (pos-- === 0) return current;
	        }
	        current = current.next;
	    }
	}
	
	function copyString(destination, target, curD, currT, offset) {
	    offset = offset || 0;
	    currT = currT || target.head;
	    curD = curD || destination.head;
	    var k = 0;
	
	    while (currT) {
	        for (var i = 0, len = target.chunkSize; i < len; i++, k++) {
	            var j = k % curD.chunkSize + offset;
	            curD.ch[j % curD.chunkSize] = currT.ch[i];
	
	            if ((j + 1) % curD.chunkSize === 0 && (currT.ch[i + 1] || currT.next)) {
	                curD.next = new Chunk(destination.chunkSize);
	                curD = curD.next;
	            }
	        }
	
	        currT = currT.next;
	    }
	
	    destination.tail = curD;
	    destination.length += target.length;
	}
	
	var a = new LString();
	var b = new LString();
	var c = new LString();
	
	a.strAssign('abcdefg');
	console.log(a + '');
	b.strAssign('hijklmno');
	console.log(b + '');
	c.strAssign('abcdefg');
	console.log(a.strCompare(b));
	console.log(a.strCompare(c));
	var t = a.concat(b);
	console.log(t + '');
	t = t.substring(2, 5);
	console.log(t + '');
	
	// 判断是否为回文字符串
	function palindrome(lStr) {
	    var stack = new _index2.default();
	    var p = lStr.head;
	    var i = 0;
	
	    for (var k = 1; k <= lStr.length; ++k) {
	        if (k <= lStr.length / 2) stack.push(p.ch[i]);else if (k > (lStr.length + 1) / 2) {
	            var _c = stack.pop();
	            if (p.ch[i] !== _c) return false;
	        }
	
	        if (++i === lStr.chunkSize) {
	            p = p.next;
	            i = 0;
	        }
	    }
	
	    return true;
	}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * 串（string）（或字符串）是由零个或多个字符组成的有限序列。串中字符的数目称为串的长度。零个字符的串称为空串（null string），它的长度为零。
	 * 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。
	 * 只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。
	 *
	 * 串有3种机内表示方法：
	 * 1.定长顺序存储表示
	 * 2.堆分配存储表示
	 * 3.串的块链存储表示
	 */
	
	/**
	 * 定长顺序存储表示
	 * 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值得字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组来描述。
	 * 以下标为0的数组分量存放串的实际长度。
	 */
	
	var SString = function () {
	    function SString(str) {
	        (0, _classCallCheck3.default)(this, SString);
	
	        this.MAXSTRLEN = 10;
	        if (str) {
	            this[0] = str.length;
	            for (var i = 1; i <= str.length; ++i) {
	                this[i] = str[i - 1];
	            }
	        }
	    }
	
	    // 返回由s1和s2连接而成的新串
	
	
	    (0, _createClass3.default)(SString, [{
	        key: 'concat',
	        value: function concat(s2) {
	            var t = new SString();
	            // 未截断
	            if (this[0] + s2[0] <= this.MAXSTRLEN) {
	                copyStr2T(this);
	                copyStr2T(s2, this[0]);
	                t[0] = this[0] + s2[0];
	
	                // 截断
	            } else if (this[0] < this.MAXSTRLEN) {
	                    copyStr2T(this);
	                    copyStr2T(s2, this[0], this.MAXSTRLEN - this[0]);
	                    t[0] = this.MAXSTRLEN;
	
	                    // 截断（仅取s1）
	                } else {
	                        copyStr2T(this, 0, this.MAXSTRLEN);
	                        t[0] = this[0] = this.MAXSTRLEN;
	                    }
	
	            return t;
	
	            function copyStr2T(str) {
	                var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	                var end = arguments.length <= 2 || arguments[2] === undefined ? str[0] : arguments[2];
	
	                for (var i = 1, len = end || str[0]; i <= len; i++) {
	                    t[start + i] = str[i];
	                }
	            }
	        }
	    }, {
	        key: 'substring',
	        value: function substring() {
	            var position = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            var len = arguments.length <= 1 || arguments[1] === undefined ? this[0] : arguments[1];
	
	            position = ~ ~position;
	            len = ~ ~len;
	            if (position < 0 || position > this[0] - 1 || len < 0 || len > this[0] - position) throw new Error('unexpected parameter');
	
	            var sub = new SString();
	            for (var i = 1; i <= len; i++) {
	                sub[i] = this[position + i - 1];
	            }
	            sub[0] = len;
	
	            return sub;
	        }
	
	        /**
	         * 将串s中的子串t替换为v，返回替换次数
	         * todo to be tested
	         * @param {SString} t
	         * @param {SString} v
	         * @returns {number} 替换次数
	         */
	
	    }, {
	        key: 'replace',
	        value: function replace(t, v) {
	            for (var _n = 0, i = 1; i <= this[0] - t[0] + 1; i++) {
	                for (var j = i, _k = 1; t[_k] && this[j] === t[_k]; ++j, ++_k) {}
	
	                // 找到了与t匹配的字串：分三种情况处理
	                if (k > t[0]) {
	                    var l = void 0;
	                    // 新字串的长度与原子串相同时，直接替换
	                    if (t[0] === v[0]) {
	                        for (l = 1; l <= t[0]; ++l) {
	                            this[i + l - 1] = v[l];
	                        }
	                    }
	                    // 新子串长度大于原子串时，先将后部右移
	                    else if (t[0] < v[0]) {
	                            for (l = this[0]; l >= i + t[0]; --l) {
	                                this[l + v[0] - t[0]] = this[l];
	                            }for (l = 1; l <= v[0]; ++l) {
	                                this[i + l - 1] = v[l];
	                            }
	                        }
	                        // 新子串长度小于原子串时，先将后部左移
	                        else {
	                                for (l = i + v[0]; l <= this[0] + v[0] - t[0]; ++l) {
	                                    this[l] = this[l - v[0] + t[0]];
	                                }for (l = 1; l <= v[0]; ++l) {
	                                    this[i + l - 1] = v[l];
	                                }
	                            }
	
	                    this[0] = this[0] - t[0] + v[0];
	                    i += v[0];
	                    ++_n;
	                }
	            }
	
	            return n;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var str = '';
	            for (var i = 1; this[i]; i++) {
	                str += this[i];
	            }
	            return str;
	        }
	        // 返回子串sstring在主串中的第position个字符之后的位置
	
	    }, {
	        key: 'index',
	        value: function index(sstring, position) {
	            var i = position || 1;
	            var j = 1;
	
	            while (i <= this[0] && j <= sstring[0]) {
	                if (this[i] === sstring[j]) {
	                    i++;
	                    j++;
	                } else {
	                    i = i - j + 2;
	                    j = 1;
	                }
	            }
	
	            return j > sstring[0] ? i - sstring[0] : -1;
	        }
	    }, {
	        key: 'kmpIndex',
	        value: function kmpIndex(sstring, position) {
	            var i = position || 1;
	            var j = 1;
	            var next = getNext(sstring);
	
	            while (i <= this[0] && j <= sstring[0]) {
	                if (j === 0 || this[i] === sstring[j]) {
	                    ++i;
	                    ++j;
	                } else {
	                    j = next[j];
	                }
	            }
	
	            return j > sstring[0] ? i - sstring[0] : -1;
	        }
	
	        // 求包含在字符串中而str没有的字符串
	
	    }, {
	        key: 'subtract',
	        value: function subtract(str) {
	            var r = new SString();
	            r[0] = 0;
	
	            for (var i = 1; i <= this[0]; ++i) {
	                var _c = this[i];
	                // 判断当前字符c是否第一次出现
	                var j = 1;
	                for (; j < i && this[j] !== _c; ++j) {}
	                if (i === j) {
	                    // 判断当前字符是否包含在str中
	                    var _k2 = 1;
	                    for (; _k2 <= str[0] && str[_k2] !== _c; ++_k2) {}
	                    if (_k2 > str[0]) r[++r[0]] = _c;
	                }
	            }
	
	            return r;
	        }
	
	        // todo bug exists
	
	    }, {
	        key: 'delete_substring',
	        value: function delete_substring(str) {
	            var n = 0;
	            for (var i = 1; i <= this[0] - str[0] + 1; ++i) {
	                var j = 1;
	                for (; j <= str[0] && this[i + j - 1] === str[j]; ++j) {}
	                if (j > str[0] - 1) {
	                    for (var _k3 = i; _k3 <= this[0] - str[0]; ++_k3) {
	                        this[_k3] = this[_k3 + str[0]];
	                    }this[0] -= str[0];
	                    ++n;
	                }
	            }
	
	            return n;
	        }
	    }]);
	    return SString;
	}();
	
	exports.default = SString;
	
	
	function getNext(sstring) {
	    var i = 1;
	    var next = { 1: 0 };
	    var j = 0;
	
	    while (i < sstring[0]) {
	        if (j === 0 || sstring[i] === sstring[j]) {
	            if (sstring[++i] !== sstring[++j]) {
	                next[i] = j;
	            } else {
	                next[i] = next[j];
	            }
	            //                next[++i] = ++j;
	        } else {
	                j = next[j];
	            }
	    }
	
	    return next;
	}
	
	var a = new SString();
	var b = new SString();
	for (var i = 0; i < 4; i++) {
	    a[i + 1] = i + '';
	    b[i + 1] = i + '';
	}
	a[0] = b[0] = 4;
	var t = a.concat(b);
	console.log(t + ''); // 01230123
	
	var d = new SString('acabaabaabcacaabc');
	var c = new SString('abaabc');
	
	console.log('index: ' + d.index(c));
	console.log('kmpIndex: ' + d.kmpIndex(c));
	
	a = new SString('abcdefg');
	b = new SString('asdfg');
	console.log(a.subtract(b) + '');
	
	a = new SString('abcdefgh');
	b = new SString('cdef');
	console.log(a.delete_substring(b) + '');
	console.log(a + '');
	
	/*
	 在顺序存储结构中，实现串操作的原操作为“字符串序列的复制”，操作时间复杂度基于复制的字符串序列的长度。
	 另一操作特点是，如果在操作中出现串值序列的长度超过MAXSTRLEN时，约定用截尾法处理，这种情况不仅在求连接串时可能发生，在串的其他操作中，如插入，置换等也可能发生，克服这个弊病唯有不限定串长的最大长度，即动态分配串值的存储空间。
	 */

/***/ },
/* 97 */
/***/ function(module, exports) {

	/*istanbul ignore next*/"use strict";
	
	exports.__esModule = true;
	
	exports.default = function () {};
	
	/*istanbul ignore next*/module.exports = exports["default"]; // required to safely use babel/register within a browserify codebase

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(105), __esModule: true };

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(107), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(108), __esModule: true };

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(110), __esModule: true };

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(112), __esModule: true };

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(99);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(22);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(98);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(25);
	__webpack_require__(138);
	module.exports = __webpack_require__(3).Array.from;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(44);
	__webpack_require__(25);
	module.exports = __webpack_require__(136);

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(44);
	__webpack_require__(25);
	module.exports = __webpack_require__(137);

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(3)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(140);
	var $Object = __webpack_require__(3).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(141);
	var $Object = __webpack_require__(3).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(142);
	module.exports = __webpack_require__(3).Object.getPrototypeOf;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(143);
	module.exports = __webpack_require__(3).Object.setPrototypeOf;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(145);
	__webpack_require__(144);
	__webpack_require__(146);
	__webpack_require__(147);
	module.exports = __webpack_require__(3).Symbol;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(25);
	__webpack_require__(44);
	module.exports = __webpack_require__(43).f('iterator');

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 116 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(11)
	  , toLength  = __webpack_require__(64)
	  , toIndex   = __webpack_require__(135);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(6)
	  , createDesc      = __webpack_require__(20);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(23)
	  , gOPS    = __webpack_require__(60)
	  , pIE     = __webpack_require__(35);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5).document && document.documentElement;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(29);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(14)
	  , ITERATOR   = __webpack_require__(4)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(29);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(7);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(34)
	  , descriptor     = __webpack_require__(20)
	  , setToStringTag = __webpack_require__(36)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(13)(IteratorPrototype, __webpack_require__(4)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(4)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(23)
	  , toIObject = __webpack_require__(11);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(24)('meta')
	  , isObject = __webpack_require__(19)
	  , has      = __webpack_require__(10)
	  , setDesc  = __webpack_require__(6).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(18)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(6)
	  , anObject = __webpack_require__(7)
	  , getKeys  = __webpack_require__(23);
	
	module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(11)
	  , gOPN      = __webpack_require__(59).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(9)
	  , core    = __webpack_require__(3)
	  , fails   = __webpack_require__(18);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(19)
	  , anObject = __webpack_require__(7);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(30)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(39)
	  , defined   = __webpack_require__(31);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(39)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(7)
	  , get      = __webpack_require__(65);
	module.exports = __webpack_require__(3).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(54)
	  , ITERATOR  = __webpack_require__(4)('iterator')
	  , Iterators = __webpack_require__(14);
	module.exports = __webpack_require__(3).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(30)
	  , $export        = __webpack_require__(9)
	  , toObject       = __webpack_require__(40)
	  , call           = __webpack_require__(124)
	  , isArrayIter    = __webpack_require__(122)
	  , toLength       = __webpack_require__(64)
	  , createProperty = __webpack_require__(118)
	  , getIterFn      = __webpack_require__(65);
	
	$export($export.S + $export.F * !__webpack_require__(126)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(116)
	  , step             = __webpack_require__(127)
	  , Iterators        = __webpack_require__(14)
	  , toIObject        = __webpack_require__(11);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(57)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(34)});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperty: __webpack_require__(6).f});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(40)
	  , $getPrototypeOf = __webpack_require__(61);
	
	__webpack_require__(132)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(133).set});

/***/ },
/* 144 */
/***/ function(module, exports) {



/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(5)
	  , has            = __webpack_require__(10)
	  , DESCRIPTORS    = __webpack_require__(8)
	  , $export        = __webpack_require__(9)
	  , redefine       = __webpack_require__(63)
	  , META           = __webpack_require__(129).KEY
	  , $fails         = __webpack_require__(18)
	  , shared         = __webpack_require__(38)
	  , setToStringTag = __webpack_require__(36)
	  , uid            = __webpack_require__(24)
	  , wks            = __webpack_require__(4)
	  , wksExt         = __webpack_require__(43)
	  , wksDefine      = __webpack_require__(42)
	  , keyOf          = __webpack_require__(128)
	  , enumKeys       = __webpack_require__(119)
	  , isArray        = __webpack_require__(123)
	  , anObject       = __webpack_require__(7)
	  , toIObject      = __webpack_require__(11)
	  , toPrimitive    = __webpack_require__(41)
	  , createDesc     = __webpack_require__(20)
	  , _create        = __webpack_require__(34)
	  , gOPNExt        = __webpack_require__(131)
	  , $GOPD          = __webpack_require__(58)
	  , $DP            = __webpack_require__(6)
	  , $keys          = __webpack_require__(23)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(59).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(35).f  = $propertyIsEnumerable;
	  __webpack_require__(60).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(33)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(13)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42)('asyncIterator');

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42)('observable');

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(149);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(66)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAzZDNiNWIyYmI4ZGVhM2RiN2ZhZiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9RdWV1ZS9RdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL3NyYy9CaW5hcnlUcmVlL0JpbmFyeVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0YWNrL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0RvdWJsZUxpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9TdGF0aWNMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQmluYXJ5U29ydGVkVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9leGNoYW5nZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FycmF5L0Nyb3NzTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXJyYXkvVFNNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR2VuZXJhbGl6ZWRMaXN0L0dMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BTUxHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQWRqYWNlbmN5TGlzdEdyYXBoLmpzIiwid2VicGFjazovLy8uL3NyYy9HcmFwaC9BZGphY2VuY3lNYXRyaXhHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvT0xHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTGluZWFyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVldWUvQ3ljbGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVldWUvUHJpb3JpdHlRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0FWTFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0JpbmFyeVNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0RpZ2l0YWxTZWFyY2hUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvSGFzaFRhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvUmVkQmxhY2tUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvU09TVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL3NlcXVlbnRpYWxTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvZGlzdHJpYnV0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2luc2VydGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9tZXJnaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RyaW5nL0hTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0cmluZy9MU3RyaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9TdHJpbmcvU1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJlZ2lzdGVyL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQ0EsS0FBRyxDQUFDLFFBQVEsT0FBWixFQUFvQjtBQUNoQix5QkFBUSxFQUFSO0FBQ0g7O0FBRUQsUUFBTyxPQUFQLEdBQWlCO0FBQ2IsWUFBTztBQUNILG9CQUFXLG9CQUFRLEVBQVIsQ0FEUjtBQUVILG1CQUFVLG9CQUFRLEVBQVI7QUFGUCxNQURNOztBQU1iLGlCQUFZOztBQUVSLHFCQUFZLG9CQUFRLEVBQVIsQ0FGSjs7QUFJUix3QkFBZSxvQkFBUSxFQUFSO0FBSlAsTUFOQzs7OztBQWViLHNCQUFpQjtBQUNiLGdCQUFPLG9CQUFRLEVBQVI7QUFETSxNQWZKOztBQW1CYixZQUFPO0FBQ0gsNkJBQW9CLG9CQUFRLEVBQVIsQ0FEakI7QUFFSCwr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LENBQXNCLEdBQXRCO0FBQ0EsYUFBWSxTQUFaLENBQXNCLEdBQXRCO0FBQ0EsYUFBWSxTQUFaLENBQXNCLEdBQXRCO0FBQ0EsYUFBWSxTQUFaLENBQXNCLEdBQXRCO0FBQ0EsYUFBWSxTQUFaLENBQXNCLEdBQXRCO0FBQ0EsYUFBWSxTQUFaLENBQXNCLEdBQXRCOztBQUVBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4QjtBQUNBLGFBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixHQUF4Qjs7QUFFQSxhQUFZLFdBQVo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrREEsS0FBSSxnQkFBZ0IsSUFBSSxr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QUdMLEtBQUksT0FBTyxJQUFJLGdCQUFKLEVBQVg7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksS0FBWjtBQUNBLE1BQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksT0FBWjtBQUNBLE1BQUssTUFBTCxDQUFZLE1BQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxNQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksSUFBWjtBQUNBLE1BQUssTUFBTCxDQUFZLEtBQVo7QUFDQSxNQUFLLE1BQUwsQ0FBWSxNQUFaO0FBQ0EsTUFBSyxNQUFMLENBQVksTUFBWjs7QUFFQSxTQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksS0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksT0FBWixDQUFaO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxNQUFMLENBQVksT0FBWixDQUFaOztBQUVBLFNBQVEsR0FBUixDQUFZLFdBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQVo7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQVo7QUFD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QUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzcEJBLDhCQUE2QixtREFBbUQiLCJmaWxlIjoiLi9EUy1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRTXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRTXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAzZDNiNWIyYmI4ZGVhM2RiN2ZhZlxuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGx1a2VsaW4gb24gMjAxNi80LzMwLlxyXG4gKi9cclxuXHJcbmlmKCFwcm9jZXNzLmJyb3dzZXIpe1xyXG4gICAgcmVxdWlyZSgnYmFiZWwtcmVnaXN0ZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBcnJheToge1xyXG4gICAgICAgIENyb3NzTGlzdDogcmVxdWlyZSgnLi9BcnJheS9Dcm9zc0xpc3QnKSxcclxuICAgICAgICBUU01hdHJpeDogcmVxdWlyZSgnLi9BcnJheS9UU01hdHJpeCcpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBCaW5hcnlUcmVlOiB7XHJcbiAgICAgICAgLy8gQmluYXJ5VGhyZWFkVHJlZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRocmVhZFRyZWUnKSxcclxuICAgICAgICBCaW5hcnlUcmVlOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvQmluYXJ5VHJlZScpLFxyXG4gICAgICAgIC8vIEVCVE5vZGU6IHJlcXVpcmUoJy4vQmluYXJ5VHJlZS9FQlROb2RlJyksXHJcbiAgICAgICAgaHVmZk1hbkNvZGluZzogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcnKSxcclxuICAgICAgICAvLyBNRlNldDogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL01GU2V0JyksXHJcbiAgICAgICAgLy8gUEJUTm9kZTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL1BCVE5vZGUnKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgR2VuZXJhbGl6ZWRMaXN0OiB7XHJcbiAgICAgICAgR0xpc3Q6IHJlcXVpcmUoJy4vR2VuZXJhbGl6ZWRMaXN0L0dMaXN0JylcclxuICAgIH0sXHJcbiAgICBcclxuICAgIEdyYXBoOiB7XHJcbiAgICAgICAgQWRqYWNlbmN5TGlzdEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL0FkamFjZW5jeUxpc3RHcmFwaCcpLFxyXG4gICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoJyksXHJcbiAgICAgICAgQU1MR3JhcGg6IHJlcXVpcmUoJy4vR3JhcGgvQU1MR3JhcGgnKSxcclxuICAgICAgICBPTEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL09MR3JhcGgnKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgTGlzdDoge1xyXG4gICAgICAgIERvdWJsZUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vTGlzdC9Eb3VibGVMaW5rZWRMaXN0JyksXHJcbiAgICAgICAgTGluZWFyTGlzdDogcmVxdWlyZSgnLi9MaXN0L0xpbmVhckxpc3QnKSxcclxuICAgICAgICBTdGF0aWNMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0xpc3QvU3RhdGljTGlua2VkTGlzdCcpLFxyXG4gICAgICAgIExSVUNhY2hlOiByZXF1aXJlKCcuL0xpc3QvTFJVJykuZGVmYXVsdFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgUXVldWU6IHtcclxuICAgICAgICBDeWNsZVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL0N5Y2xlUXVldWUnKSxcclxuICAgICAgICBQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL1ByaW9yaXR5UXVldWUnKSxcclxuICAgICAgICBRdWV1ZTogcmVxdWlyZSgnLi9RdWV1ZS9RdWV1ZScpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBTZWFyY2g6IHtcclxuICAgICAgICBBVkxUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9BVkxUcmVlJyksXHJcbiAgICAgICAgYmluYXJ5U2VhcmNoOiByZXF1aXJlKCcuL1NlYXJjaC9CaW5hcnlTZWFyY2gnKSxcclxuICAgICAgICBCaW5hcnlTb3J0ZWRUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlJyksXHJcbiAgICAgICAgQlBsdXNUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9CUGx1c1RyZWUnKSxcclxuICAgICAgICBCVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQlRyZWUnKSxcclxuICAgICAgICBEaWdpdGFsU2VhcmNoVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUnKSxcclxuICAgICAgICBmaWJvbmFjY2lTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaCcpLFxyXG4gICAgICAgIEhhc2hUYWJsZTogcmVxdWlyZSgnLi9TZWFyY2gvSGFzaFRhYmxlJyksXHJcbiAgICAgICAgUmVkQmxhY2tUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9SZWRCbGFja1RyZWUnKSxcclxuICAgICAgICBzZXF1ZW50aWFsU2VhcmNoOiByZXF1aXJlKCcuL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoJyksXHJcbiAgICAgICAgU09TVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvU09TVHJlZScpXHJcbiAgICB9LFxyXG5cclxuICAgIFNvcnQ6IHtcclxuICAgICAgICBkaXN0cmlidXRpb246IHJlcXVpcmUoJy4vU29ydC9kaXN0cmlidXRpb24vaW5kZXgnKSxcclxuICAgICAgICBleGNoYW5nZTogcmVxdWlyZSgnLi9Tb3J0L2V4Y2hhbmdlL2luZGV4JyksXHJcbiAgICAgICAgaW5zZXJ0aW9uOiByZXF1aXJlKCcuL1NvcnQvaW5zZXJ0aW9uL2luZGV4JyksXHJcbiAgICAgICAgbWVyZ2luZzogcmVxdWlyZSgnLi9Tb3J0L21lcmdpbmcvaW5kZXgnKSxcclxuICAgICAgICBzZWxlY3Rpb246IHJlcXVpcmUoJy4vU29ydC9zZWxlY3Rpb24vaW5kZXgnKVxyXG4gICAgfSxcclxuXHJcbiAgICBTdGFjazogcmVxdWlyZSgnLi9TdGFjay9pbmRleCcpLFxyXG5cclxuICAgIFN0cmluZzoge1xyXG4gICAgICAgIEhTdHJpbmc6IHJlcXVpcmUoJy4vU3RyaW5nL0hTdHJpbmcnKSxcclxuICAgICAgICBMU3RyaW5nOiByZXF1aXJlKCcuL1N0cmluZy9MU3RyaW5nJyksXHJcbiAgICAgICAgU1N0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvU1N0cmluZycpXHJcbiAgICB9XHJcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvaW5kZXguanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6Zif5YiXUXVldWVcclxuICpcclxuICog6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye677yIZmlyc3QgaW4gZmlyc3Qgb3V0LCBGSUZP77yJ55qE57q/5oCn6KGo44CC5a6D5Y+q5YWB6K645Zyo6KGo55qE5LiA56uv6L+b6KGM5o+S5YWl77yM6ICM5Zyo5Y+m5LiA56uv5Yig6Zmk5YWD57Sg44CCXHJcbiAqIOWFgeiuuOaPkuWFpeeahOS4gOerr+WPq+mYn+Wwvu+8iHJlYXLvvInvvIzlhYHorrjliKDpmaTnmoTkuIDnq6/lj6vpmJ/lpLTvvIhmcm9udO+8ieOAglxyXG4gKi9cclxuXHJcbi8vIOmTvumYn+WIl1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlYXIgPSB0aGlzLmZyb250ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYXIgPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBjbGVhciAoKSB7XHJcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuICAgIGdldEhlYWQgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb250ID8gdGhpcy5mcm9udC5kYXRhIDogbnVsbDtcclxuICAgIH1cclxuICAgIGVuUXVldWUgKGVsZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlYXIgPSB0aGlzLmZyb250ID0ge2RhdGE6IGVsZW0sIG5leHQ6IG51bGx9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBwID0ge2RhdGE6IGVsZW0sIG5leHQ6IG51bGx9O1xyXG4gICAgICAgICAgICB0aGlzLnJlYXIubmV4dCA9IHA7XHJcbiAgICAgICAgICAgIHRoaXMucmVhciA9IHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgZGVRdWV1ZSAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQpIHtcclxuICAgICAgICAgICAgbGV0IGVsZW0gPSB0aGlzLmZyb250LmRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLmZyb250Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZVRyYXZlcnNlIChpdGVyYXRvcikge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5mcm9udDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoY3VycmVudC5kYXRhKSkgYnJlYWs7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGVla0F0IChpbmRleCA9IDApIHtcclxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5mcm9udDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc2l6ZTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltpXSA9IGN1cnJlbnQuZGF0YTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG5xdWV1ZS5lblF1ZXVlKDEpO1xyXG5xdWV1ZS5kZVF1ZXVlKCk7XHJcbnF1ZXVlLmVuUXVldWUoMik7XHJcbnF1ZXVlLmVuUXVldWUoMyk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgwKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgxKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgyKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnBlZWtBdCgzKSk7XHJcbmNvbnNvbGUubG9nKHF1ZXVlLnRvU3RyaW5nKCkuam9pbigpKTtcclxuXHJcblxyXG5cclxuLy8g57G75Ly85bm/5bqm5LyY5YWI6YGN5Y6GXHJcbmZ1bmN0aW9uIHJlcGFpbnRDb2xvcihtYXRyaXgsIGksIGosIGNvbG9yKXtcclxuICAgIGxldCBvbGQgPSBtYXRyaXhbaV1bal07XHJcbiAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgIGxldCBtID0gbWF0cml4Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgbiA9IG1hdHJpeFswXS5sZW5ndGggLSAxO1xyXG5cclxuICAgIHF1ZXVlLmVuUXVldWUoe3g6IGksIHk6IGp9KTtcclxuXHJcbiAgICB3aGlsZShxdWV1ZS5yZWFyKXtcclxuICAgICAgICBsZXQgYSA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICBsZXQgeCA9IGEueDtcclxuICAgICAgICBsZXQgeSA9IGEueTtcclxuXHJcbiAgICAgICAgaWYoeCA+PSAxKSBzZXRDb2xvcih4IC0gMSwgeSk7XHJcbiAgICAgICAgaWYoeSA+PSAxKSBzZXRDb2xvcih4LCB5IC0gMSk7XHJcbiAgICAgICAgaWYoeCA8IG0pIHNldENvbG9yKHggKyAxLCB5KTtcclxuICAgICAgICBpZih5IDwgbikgc2V0Q29sb3IoeCwgeSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldENvbG9yKHgsIHkpe1xyXG4gICAgICAgIGlmKG1hdHJpeFt4XVt5XSA9PT0gb2xkKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeFt4XVt5XSA9IGNvbG9yO1xyXG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHt4OiB4LCB5OiB5fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgbWF0cml4ID0gW107XHJcblxyXG5mb3IobGV0IGkgPSAwOyBpIDwgODsgaSsrKXtcclxuICAgIG1hdHJpeFtpXSA9IFtdO1xyXG4gICAgZm9yKGxldCBqID0gMDsgaiA8IDg7IGorKyl7XHJcbiAgICAgICAgbWF0cml4W2ldW2pdID0gMDtcclxuICAgIH1cclxufVxyXG5cclxucmVwYWludENvbG9yKG1hdHJpeCwgNCwgNSwgMSk7XHJcbmNvbnNvbGUubG9nKG1hdHJpeCk7XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9RdWV1ZS9RdWV1ZS5qc1xuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog5qCR55qE5LiA5Lqb5qaC5b+1XHJcbiAqXHJcbiAqIOagke+8iFRyZWXvvInmmK9u77yIbj49MO+8ieS4que7k+eCueeahOaciemZkOmbhuOAguWcqOS7u+aEj+S4gOajtemdnuepuuagkeS4re+8mlxyXG4gKiDvvIgx77yJ5pyJ5LiU5LuF5pyJ5LiA5Liq54m55a6a55qE56ew5Li65qC577yIUm9vdO+8ieeahOe7k+eCue+8m1xyXG4gKiDvvIgy77yJ5b2Tbj4x5pe277yM5YW25L2Z57uT54K55Y+v5YiG5Li6bShtPjAp5Liq5LqS5LiN55u45Lqk55qE5pyJ6ZmQ6ZuGVDEsVDIsVDMsLi4uVG3vvIzlhbbkuK3mr4/kuIDkuKrpm4blkIjmnKzouqvlj4jmmK/kuIDmo7XmoJHvvIzlubbkuJTnp7DkuLrmoLnnmoTlrZDmoJHvvIhTdWJ0cmVl77yJ44CCXHJcbiAqXHJcbiAqIOS+i+Wmgu+8jO+8iGHvvInmmK/lj6rmnInkuIDkuKrmoLnnu5PngrnnmoTmoJHvvJtcclxuICog77yIYu+8ieaYr+aciTEz5Liq57uT54K555qE5qCR77yM5YW25LitQeaYr+ague+8jOWFtuS9mee7k+eCueWIhuaIkDPkuKrkupLkuI3nm7jkuqTnmoTlrZDpm4bvvJpUMT17QixFLEYsSyxMfSx0Mj17RCxILEksSixNfTtUMSxUMuWSjFQz6YO95piv5qC5QeeahOWtkOagke+8jOS4lOacrOi6q+S5n+aYr+S4gOajteagkeOAglxyXG4gKlxyXG4gKiDmoJHnmoTnu5PngrnljIXlkKvkuIDkuKrmlbDmja7lhYPntKDlj4roi6XlubLmjIflkJHlhbblrZDmoJHnmoTliIbmlK/jgILnu5Pngrnmi6XmnInnmoTlrZDmoJHmlbDnp7DkuLrnu5PngrnnmoTluqbvvIhEZWdyZWXvvInjgILkvovlpoLvvIzvvIhi77yJ5LitQeeahOW6puS4ujPvvIxD55qE5bqm5Li6Me+8jEbnmoTluqbkuLowLuW6puS4ujDnmoTnu5Pngrnnp7DkuLrlj7blrZDvvIhMZWFm77yJ5oiW6ICF57uI56uv57uT54K544CC5bqm5LiN5Li6MOeahOe7k+eCueensOS4uumdnue7iOerr+e7k+eCueaIluWIhuaUr+e7k+eCueOAguagkeeahOW6puaYr+agkeWGheWQhOe7k+eCueeahOW6pueahOacgOWkp+WAvOOAgu+8iGLvvInnmoTmoJHnmoTluqbkuLozLue7k+eCueeahOWtkOagkeeahOagueensOS4uuivpee7k+eCueeahOWtqeWtkO+8iENoaWxk77yJ44CC55u45bqU55qE77yM6K+l57uT54K556ew5Li65a2p5a2Q55qE5Y+M5Lqy77yIUGFyZW5077yJ44CC5ZCM5LiA5Liq5Y+M5Lqy55qE5a2p5a2Q5LmL6Ze05LqS56ew5YWE5byf77yIU2libGluZ++8ieOAgue7k+eCueeahOelluWFiOaYr+S7juagueWIsOivpee7k+eCueaJgOe7j+WIhuaUr+S4iueahOaJgOaciee7k+eCueOAguWPjeS5i++8jOS7peafkOe7k+eCueS4uuagueeahOWtkOagkeS4reeahOS7u+S4gOe7k+eCuemDveensOS4uuivpee7k+eCueeahOWtkOWtmeOAglxyXG4gKiDnu5PngrnnmoTlsYLmrKHvvIhMZXZlbO+8ieS7juagueW8gOWni+WumuS5iei1t++8jOagueS4uuesrOS4gOWxgu+8jOi3n+eahOWtqeWtkOS4uuesrOS6jOWxguOAguiLpeafkOe7k+eCueWcqOesrGzlsYLvvIzliJnlhbblrZDmoJHnmoTmoLnlsLHlnKjnrKxsKzHlsYLjgILlhbblj4zkurLlnKjlkIzkuIDlsYLnmoTnu5PngrnkupLkuLrloILlhYTlvJ/jgILkvovlpoLvvIznu5PngrlH5LiORe+8jEYsSCxJLErkupLkuLrloILlhYTlvJ/jgILmoJHkuK3nu5PngrnnmoTmnIDlpKflsYLmrKHnp7DkuLrmoJHnmoTmt7HluqbvvIhEZXB0aO+8ieaIlumrmOW6puOAgu+8iGLvvInnmoTmoJHnmoTmt7HluqbkuLo044CCXHJcbiAqXHJcbiAqIOWmguaenOWwhuagkeS4ree7k+eCueeahOWQhOWtkOagkeeci+aIkOS7juW3puiHs+WPs+aYr+acieasoeW6j+eahO+8iOWNs+S4jeiDveS6pOaNou+8ie+8jOWImeensOivpeagkeS4uuacieW6j+agke+8jOWQpuWImeensOS4uuaXoOW6j+agkeOAguWcqOacieW6j+agkeS4reacgOW3pui+ueeahOWtkOagkeeahOagueensOS4uuesrOS4gOS4quWtqeWtkO+8jOacgOWPs+i+ueeahOensOS4uuacgOWQjuS4gOS4quWtqeWtkOOAglxyXG4gKiDmo67mnpfvvIhGb3Jlc3TvvInmmK9t77yIbT49MO+8ieajteS6kuS4jeebuOS6pOeahOagkeeahOmbhuWQiOOAguWvueagkeS4reavj+S4que7k+eCueiAjOiogO+8jOWFtuWtkOagkeeahOmbhuWQiOWNs+S4uuajruael+OAglxyXG4gKlxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDkuozlj4nmoJHvvIhCaW5hcnkgVHJlZe+8ieaYr+WPpuS4gOenjeagkeWei+e7k+aehO+8jOWug+eahOeJueeCueaYr+avj+S4que7k+eCueiHs+WkmuWPquacieS4pOajteWtkOagke+8iOWNs+S6jOWPieagkeS4reS4jeWtmOWcqOW6puWkp+S6jjLnmoTnu5PngrnvvInvvIzlubbkuJTvvIzkuozlj4nmoJHnmoTlrZDmoJHmnInlt6blj7PkuYvliIbvvIjlhbbmrKHluo/kuI3og73ku7vmhI/poqDlgJLjgILvvIlcclxuICpcclxuICog5LqM5Y+J5qCR55qE5oCn6LSoXHJcbiAqIDEu5Zyo5LqM5Y+J5qCR55qE56ysaeWxguS4iuiHs+WkmuaciTLnmoRpLTHmrKHmlrnkuKrnu5PngrkoaT49MSnjgIJcclxuICogMi7mt7HluqbkuLpr55qE5LqM5Y+J5qCR6Iez5aSa5pyJMueahGvmrKHmlrktMeS4que7k+eCue+8jChrPj0xKeOAglxyXG4gKiAzLuWvueS7u+S9leS4gOajteS6jOWPieagkVTvvIzlpoLmnpzlhbbnu4jnq6/nu5PngrnmlbDkuLpuMO+8jOW6puS4ujLnmoTnu5PngrnmlbDkuLpuMu+8jOWImW4wID0gbjIgKyAxO1xyXG4gKiAgICAgIOS4gOajtea3seW6puS4umvkuJTmnIky55qEa+asoeaWuS0x5Liq57uT54K555qE5LqM5Y+J5qCR56ew5Li65ruh5LqM5Y+J5qCR44CCXHJcbiAqICAgICAg5rex5bqm5Li6a+eahO+8jOaciW7kuKrnu5PngrnnmoTkuozlj4nmoJHvvIzlvZPkuJTku4XlvZPlhbbmr4/kuIDkuKrnu5Pngrnpg73kuI7mt7HluqbkuLpr55qE5ruh5LqM5Y+J5qCR5Lit57yW5Y+35LuOMeiHs27nmoTnu5PngrnkuIDkuIDlr7nlupTml7bvvIznp7DkuYvkuLrlrozlhajkuozlj4nmoJHjgIJcclxuICog5LiL6Z2i5piv5a6M5YWo5LqM5Y+J5qCR55qE5Lik5Liq54m55oCnXHJcbiAqIDQu5YW35pyJbuS4que7k+eCueeahOWujOWFqOS6jOWPieagkeeahOa3seW6puS4uk1hdGguZmxvb3IobG9nIDIgbikgKyAxXHJcbiAqIDUu5aaC5p6c5a+55LiA5qO15pyJbuS4que7k+eCueeahOWujOWFqOS6jOWPieagke+8iOWFtua3seW6puS4uk1hdGguZmxvb3IobG9nIDIgbikgKyAx77yJ55qE57uT54K55oyJ5bGC5bqP57yW5Y+377yI5LuO56ysMeWxguWIsOesrE1hdGguZmxvb3IoMiBuKSArIDHvvIzmr4/lsYLku47lt6bliLDlj7PvvInvvIzliJnlr7nku7vkuIDnu5PngrnvvIgxPD1pPD1u77yJ5pyJ77yaXHJcbiAqICAgICAoMSnlpoLmnpxpPTHvvIzliJnnu5Pngrlp44CB5piv5LqM5Y+J5qCR55qE5qC577yM5peg5Y+M5Lqy77yb5aaC5p6caT4x77yM5YiZ5YW25Y+M5LqycGFyZW50KGkp5piv57uT54K5TWF0aC5mbG9vcihpLzIp44CCXHJcbiAqICAgICAoMinlpoLmnpwyaSA+IG7vvIzliJnnu5Pngrlp5peg5bem5a2p5a2Q77yI57uT54K5aeS4uuWPtuWtkOe7k+eCue+8ie+8m+WQpuWImeWFtuW3puWtqeWtkExDaGlsZChpKeaYr+e7k+eCuTJpLlxyXG4gKiAgICAgKDMp5aaC5p6cMmkgKyAxID4gbu+8jOWImee7k+eCuWnml6Dlj7PlranlrZDvvJvlkKbliJnlhbblj7PlranlrZBSQ2hpbGQoaSnmmK/nu5PngrkyaSArIDE7XHJcbiAqL1xyXG5cclxuLypcclxuIOS6jOWPieagkeeahOWtmOWCqOe7k+aehFxyXG5cclxuIDEu6aG65bqP5a2Y5YKo57uT5p6EXHJcbiDnlKjkuIDnu4Tov57nu63nmoTlrZjlgqjljZXlhYPkvp3mrKHoh6rkuIrogIzkuIvvvIzoh6rlt6boh7Plj7PlrZjlgqjlrozlhajkuozlj4nmoJHkuIrnmoTnu5PngrnlhYPntKDvvIzljbPlsIbkuozlj4nmoJHkuIrnvJblj7fkuLpp55qE57uT54K55YWD57Sg5a2Y5YKo5Zyo5Yqg5LiK5a6a5LmJ55qE5LiA57u05pWw57uE5Lit5LiL5qCH5Li6aS0x55qE5YiG6YeP5Lit44CC4oCcMOKAneihqOekuuS4jeWtmOWcqOatpOe7k+eCueOAgui/meenjemhuuW6j+WtmOWCqOe7k+aehOS7hemAgueUqOS6juWujOWFqOS6jOWPieagkeOAglxyXG4g5Zug5Li677yM5Zyo5pyA5Z2P5oOF5Ya15LiL77yM5LiA5Liq5rex5bqm5Li6a+S4lOWPquaciWvkuKrnu5PngrnnmoTljZXmlK/moJHvvIjmoJHkuK3kuI3lrZjlnKjluqbkuLoy55qE57uT54K577yJ5Y206ZyA6KaB6ZW/5bqm5Li6MueahG7mrKHmlrktMeeahOS4gOe7tOaVsOe7hOOAglxyXG5cclxuIDIu6ZO+5byP5a2Y5YKo57uT5p6EXHJcbiDkuozlj4nmoJHnmoTnu5PngrnnlLHkuIDkuKrmlbDmja7lhYPntKDlkozliIbliKvmjIflkJHlhbblt6blj7PlrZDmoJHnmoTkuKTkuKrliIbmlK/mnoTmiJDvvIzliJnooajnpLrkuozlj4nmoJHnmoTpk77ooajkuK3nmoTnu5Pngrnoh7PlsJHljIXlkKvkuInkuKrln5/vvJrmlbDmja7ln5/lkozlt6blj7PmjIfpkojln5/jgILmnInml7bvvIzkuLrkuobkvr/kuo7mib7liLDnu5PngrnnmoTlj4zkurLvvIzliJnov5jlj6/lnKjnu5Pngrnnu5PmnoTkuK3lop7liqDkuIDkuKrmjIflkJHlhbblj4zkurLnu5PngrnnmoTmjIfpkojln5/jgILliKnnlKjov5nkuKTnp43nu5PmnoTmiYDlvpfnmoTkuozlj4nmoJHnmoTlrZjlgqjnu5PmnoTliIbliKvnp7DkuYvkuLrkuozlj4npk77ooajlkozkuInlj4npk77ooajjgIJcclxuIOWcqOWQq+aciW7kuKrnu5PngrnnmoTkuozlj4npk77ooajkuK3mnIluKzHkuKrnqbrpk77ln5/vvIzmiJHku6zlj6/ku6XliKnnlKjov5nkupvnqbrpk77ln5/lrZjlgqjlhbbku5bmnInnlKjkv6Hmga/vvIzku47ogIzlvpfliLDlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoQtLS3nur/ntKLpk77ooajjgIJcclxuXHJcbiDlhYjvvIjmoLnvvInluo/pgY3ljobvvJrmoLnlt6blj7NcclxuIOS4re+8iOague+8ieW6j+mBjeWOhu+8muW3puagueWPs1xyXG4g5ZCO77yI5qC577yJ5bqP6YGN5Y6G77ya5bem5Y+z5qC5XHJcblxyXG4gKi9cclxuXHJcblxyXG4vLyDpobrluo/lrZjlgqjnu5PmnoRcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIOmhuuW6j+WtmOWCqOe7k+aehOeahOmBjeWOhlxyXG4gICAgbGV0IHRyZWUgPSBbMSwgMiwgMywgNCwgNSwgLCA2LCAsICwgN107XHJcblxyXG4gICAgY29uc29sZS5sb2coJ3ByZU9yZGVyOicpO1xyXG4gICAgdm9pZCBmdW5jdGlvbiBwcmVPcmRlclJlY3Vyc2l2ZSh4LCB2aXNpdCkge1xyXG4gICAgICAgIHZpc2l0KHRyZWVbeF0pO1xyXG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMV0pIHByZU9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMSwgdmlzaXQpO1xyXG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMl0pIHByZU9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMiwgdmlzaXQpO1xyXG4gICAgfSgwLCAodmFsdWUpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnaW5PcmRlcjonKTtcclxuICAgIHZvaWQgZnVuY3Rpb24gaW5PcmRlclJlY3Vyc2l2ZSh4LCB2aXNpdCkge1xyXG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMV0pIGluT3JkZXJSZWN1cnNpdmUoMiAqIHggKyAxLCB2aXNpdCk7XHJcbiAgICAgICAgdmlzaXQodHJlZVt4XSk7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkgaW5PcmRlclJlY3Vyc2l2ZSgyICogeCArIDIsIHZpc2l0KTtcclxuICAgIH0oMCwgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2codmFsdWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ3Bvc3RPcmRlcjonKTtcclxuICAgIHZvaWQgZnVuY3Rpb24gcG9zdE9yZGVyUmVjdXJzaXZlKHgsIHZpc2l0KSB7XHJcbiAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgcG9zdE9yZGVyUmVjdXJzaXZlKDIgKiB4ICsgMSwgdmlzaXQpO1xyXG4gICAgICAgIGlmICh0cmVlWzIgKiB4ICsgMl0pIHBvc3RPcmRlclJlY3Vyc2l2ZSgyICogeCArIDIsIHZpc2l0KTtcclxuICAgICAgICB2aXNpdCh0cmVlW3hdKTtcclxuICAgIH0oMCwgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2codmFsdWUpO1xyXG4gICAgfSk7XHJcbn0oKSk7XHJcblxyXG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vU3RhY2svaW5kZXgnO1xyXG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vUXVldWUvUXVldWUnO1xyXG5cclxuLy8g6ZO+5byP5a2Y5YKo57uT5p6EXHJcbmV4cG9ydCBjbGFzcyBCaW5hcnlUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBsZWZ0Q2hpbGQgPSBudWxsLCByaWdodENoaWxkID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgLy8g5bem5Y+z5a2p5a2Q57uT54K5XHJcbiAgICAgICAgdGhpcy5sZWZ0Q2hpbGQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5yaWdodENoaWxkID0gcmlnaHRDaGlsZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyDliKTmlq3kuKTmo7XmoJHmmK/lkKbnm7jkvLxcclxuICAgIGlzU2ltaWxhcih0cmVlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRyZWUgJiZcclxuICAgICAgICAoKHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmlzU2ltaWxhcih0cmVlLmxlZnRDaGlsZCkpIHx8ICghdGhpcy5sZWZ0Q2hpbGQgJiYgIXRyZWUubGVmdENoaWxkKSkgJiZcclxuICAgICAgICAoKHRoaXMucmlnaHRDaGlsZCAmJiB0aGlzLnJpZ2h0Q2hpbGQuaXNTaW1pbGFyKHRyZWUucmlnaHRDaGlsZCkpIHx8ICghdGhpcy5yaWdodENoaWxkICYmICF0cmVlLnJpZ2h0Q2hpbGQpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQmluYXJ5VHJlZSh0cmVlKSB7XHJcbiAgICAgICAgdm9pZCBmdW5jdGlvbiBwcmVPcmRlclJlY3Vyc2l2ZShub2RlLCB4LCB2aXNpdCkge1xyXG4gICAgICAgICAgICB2aXNpdChub2RlLCB0cmVlW3hdKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwO1xyXG4gICAgICAgICAgICBpZiAodHJlZVsyICogeCArIDFdKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gbm9kZS5sZWZ0Q2hpbGQgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJlT3JkZXJSZWN1cnNpdmUocCwgMiAqIHggKyAxLCB2aXNpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAyXSkge1xyXG4gICAgICAgICAgICAgICAgcCA9IG5vZGUucmlnaHRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XHJcbiAgICAgICAgICAgICAgICBwcmVPcmRlclJlY3Vyc2l2ZShwLCAyICogeCArIDIsIHZpc2l0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHApIHAucGFyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfSh0aGlzLCAwLCAobm9kZSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFByZWZpeCBpdGVyYXRpb24gKi9cclxuICAgICogW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5kYXRhO1xyXG4gICAgICAgIGlmKHRoaXMubGVmdENoaWxkKSB5aWVsZCogdGhpcy5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgaWYodGhpcy5yaWdodENoaWxkKSB5aWVsZCogdGhpcy5yaWdodENoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWFiOW6j+mBjeWOhuS6jOWPieagkeeahOmdnumAkuW9kueul+azlVxyXG4gICAgcHJlT3JkZXJOb25SZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBsZXQgcCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHdoaWxlIChwIHx8IHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyDlkJHlt6botbDliLDlsL3lpLRcclxuICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHAgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Lit5bqP6Z2e6YCS5b2S6YGN5Y6GXHJcbiAgICBpbk9yZGVyTm9uUmVjdXJzaXZlKHZpc2l0KSB7XHJcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xyXG5cclxuICAgICAgICB3aGlsZSAocCB8fCBzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Li65LqG5Yy65YiG5Lik5qyh6L+H5qCI55qE5LiN5ZCM5aSE55CG5pa55byP77yM5Zyo5aCG5qCI5Lit5aKe5Yqg5LiA5LiqbWFya+Wfn++8jFxyXG4gICAgLy8gbWFyaz0w6KGo56S65Yia5Yia6K6/6Zeu5q2k57uT54K577yMbWFyaz0x6KGo56S65bem5a2Q5qCR5aSE55CG57uT5p2f6L+U5Zue77yMXHJcbiAgICAvLyBtYXJrPTLooajnpLrlj7PlrZDmoJHlpITnkIbnu5PmnZ/ov5Tlm57jgILmr4/mrKHmoLnmja7moIjpobbnmoRtYXJr5Z+f5Yaz5a6a5YGa5L2V5Yqo5L2cXHJcbiAgICBwb3N0T3JkZXJOb25SZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBzdGFjay5wdXNoKFt0aGlzLCAwXSk7XHJcblxyXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IGEgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBhWzBdO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChhWzFdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChbbm9kZSwgMV0pOyAgLy8g5L+u5pS5bWFya+Wfn1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChbbm9kZS5sZWZ0Q2hpbGQsIDBdKTsgIC8vIOiuv+mXruW3puWtkOagkVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goW25vZGUsIDJdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKFtub2RlLnJpZ2h0Q2hpbGQsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgJiYgdmlzaXQobm9kZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpIHtcclxuICAgICAgICB2aXNpdCh0aGlzLmRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQucHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5wcmVPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5PcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQuaW5PcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQuaW5PcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcG9zdE9yZGVyUmVjdXJzaXZlKHZpc2l0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5wb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpO1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5wb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpO1xyXG4gICAgICAgIHZpc2l0KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV2ZWxPcmRlclRyYXZlcnNlKHZpc2l0KSB7XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh0aGlzKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xyXG4gICAgICAgICAgICBwLmxlZnRDaGlsZCAmJiBxdWV1ZS5lblF1ZXVlKHAubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgcC5yaWdodENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5yaWdodENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5YWI5bqP5bqP5YiX5Li6a+eahOe7k+eCueeahOWAvFxyXG4gICAgZ2V0UHJlU2VxdWVuY2Uoaykge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xyXG5cclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGspXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICBub2RlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKG5vZGUubGVmdENoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKG5vZGUucmlnaHRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KHRoaXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLkuozlj4nmoJHkuK3lj7blrZDnu5PngrnnmoTmlbDnm65cclxuICAgIGNvdW50TGVhdmVzKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gMDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIW5vZGUubGVmdENoaWxkICYmICFub2RlLnJpZ2h0Q2hpbGQpIHJldHVybiAxO1xyXG4gICAgICAgICAgICBlbHNlIHJldHVybiByZWN1cnNlKG5vZGUubGVmdENoaWxkKSArIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcclxuICAgICAgICB9KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOS6pOaNouaJgOaciee7k+eCueeahOW3puWPs+WtkOagkVxyXG4gICAgcmV2b2x1dGVCaW5hcnlUcmVlKCkge1xyXG4gICAgICAgIFt0aGlzLmxlZnRDaGlsZCwgdGhpcy5yaWdodENoaWxkXSA9IFt0aGlzLnJpZ2h0Q2hpbGQsIHRoaXMubGVmdENoaWxkXTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5yZXZvbHV0ZUJpbmFyeVRyZWUoKTtcclxuICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQucmV2b2x1dGVCaW5hcnlUcmVlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV2b2x1dGVOb25SZWN1cnNpdmUoKXtcclxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xyXG5cclxuICAgICAgICB3aGlsZShzdGFjay5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBbbm9kZS5sZWZ0Q2hpbGQsIG5vZGUucmlnaHRDaGlsZF0gPSBbbm9kZS5yaWdodENoaWxkLCBub2RlLmxlZnRDaGlsZF07XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHRDaGlsZCkgc3RhY2sucHVzaChub2RlLnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLkuozlj4nmoJHkuK3ku6XlgLzkuLp455qE57uT54K55Li65qC555qE5a2Q5qCR5rex5bqmXHJcbiAgICBnZXRTdWJEZXB0aCh4KSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xyXG5cclxuICAgICAgICB3aGlsZShzdGFjay5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHN0YWNrLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5kYXRhID09PSB4KSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IG5vZGUuZ2V0RGVwdGgoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZS5sZWZ0Q2hpbGQpIHN0YWNrLnB1c2gobm9kZS5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKG5vZGUucmlnaHRDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBnZXREZXB0aCgpIHtcclxuICAgICAgICBsZXQgbSA9IHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmdldERlcHRoKCkgfHwgMDtcclxuICAgICAgICBsZXQgbiA9IHRoaXMucmlnaHRDaGlsZCAmJiB0aGlzLnJpZ2h0Q2hpbGQuZ2V0RGVwdGgoKSB8fCAwO1xyXG4gICAgICAgIHJldHVybiAobSA+IG4gPyBtIDogbikgKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWIoOmZpOaJgOacieS7peWFg+e0oHjkuLrmoLnnmoTlrZDmoJFcclxuICAgIGRlbFN1YlgoeCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT09IHgpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0Q2hpbGQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQuZGVsU3ViWCh4KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLmRlbFN1YlgoeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6Z2e6YCS5b2S5aSN5Yi25LqM5Y+J5qCRXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiDmi7fotJ3ov4fnqIvkuK3kvJrmiafooYznmoTlm57osIPvvIzlj6/ku6XnlKjmnaXmi7fotJ3lhbblroPoh6rlrprkuYnlsZ7mgKdcclxuICAgICAqIEByZXR1cm5zIHtDc3RyfSDov5Tlm57mlrDnmoTlrp7kvotcclxuICAgICAqL1xyXG4gICAgY29weShjYiA9IGZ1bmN0aW9uKCl7fSkge1xyXG4gICAgICAgIC8vIOeUqOadpeWtmOaUvuacrOS9k+e7k+eCueeahOagiFxyXG4gICAgICAgIGxldCBzdGFjazEgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICAvLyDnlKjmnaXlrZjmlL7mlrDkuozlj4nmoJHnu5PngrnnmoTmoIhcclxuICAgICAgICBsZXQgc3RhY2syID0gbmV3IFN0YWNrKCk7XHJcbiAgICAgICAgc3RhY2sxLnB1c2godGhpcyk7XHJcbiAgICAgICAgbGV0IENzdHIgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIGxldCBuZXdUcmVlID0gbmV3IENzdHIoKTtcclxuICAgICAgICBsZXQgcSA9IG5ld1RyZWU7XHJcbiAgICAgICAgc3RhY2syLnB1c2gobmV3VHJlZSk7XHJcbiAgICAgICAgbGV0IHA7XHJcblxyXG4gICAgICAgIHdoaWxlIChzdGFjazEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIOWQkeW3pui1sOWIsOWwveWktFxyXG4gICAgICAgICAgICB3aGlsZSAoKHAgPSBzdGFjazEucGVlaygpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubGVmdENoaWxkKSBxLmxlZnRDaGlsZCA9IG5ldyBDc3RyKCk7XHJcbiAgICAgICAgICAgICAgICBxID0gcS5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBzdGFjazEucHVzaChwLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBzdGFjazIucHVzaChxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcCA9IHN0YWNrMS5wb3AoKTtcclxuICAgICAgICAgICAgcSA9IHN0YWNrMi5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGFjazEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gc3RhY2sxLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcSA9IHN0YWNrMi5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwLnJpZ2h0Q2hpbGQpIHEucmlnaHRDaGlsZCA9IG5ldyBDc3RyKCk7XHJcbiAgICAgICAgICAgICAgICBxLmRhdGEgPSBwLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjYihxLCBwKTtcclxuICAgICAgICAgICAgICAgIHEgPSBxLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBzdGFjazEucHVzaChwLnJpZ2h0Q2hpbGQpOyAgLy8g5ZCR5Y+z5LiA5q2lXHJcbiAgICAgICAgICAgICAgICBzdGFjazIucHVzaChxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1RyZWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5LqM5Y+J5qCR5Lit57uT54K5cOWSjHHnmoTmnIDov5HnpZblhYhcclxuICAgIGZpbmROZWFyQW5jaWVudChwTm9kZSwgcU5vZGUpIHtcclxuICAgICAgICBsZXQgcGF0aFAgPSBmaW5kUGF0aCh0aGlzLCBwTm9kZSwgMCk7XHJcbiAgICAgICAgbGV0IHBhdGhRID0gZmluZFBhdGgodGhpcywgcU5vZGUsIDApO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgcGF0aFBbaV0gPT0gcGF0aFFbaV0gJiYgcGF0aFBbaV07IGkrKyk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhQWy0taV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdG9kb1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5rGC5LiA5qO15LqM5Y+J5qCR55qE57mB6IyC5bqmXHJcbiAgICBsdXNoRGVncmVlKCkge1xyXG4gICAgICAgIGxldCBjb3VudEFyciA9IFtdO1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHF1ZXVlLmVuUXVldWUoe1xyXG4gICAgICAgICAgICBub2RlOiB0aGlzLFxyXG4gICAgICAgICAgICBsYXllcjogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIOWIqeeUqOWxguW6j+mBjeWOhuadpee7n+iuoeWQhOWxgueahOe7k+eCueaVsFxyXG4gICAgICAgIGxldCByO1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XHJcbiAgICAgICAgICAgIHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIGNvdW50QXJyW3IubGF5ZXJdID0gKGNvdW50QXJyW3IubGF5ZXJdIHx8IDApICsgMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyLm5vZGUubGVmdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogci5ub2RlLmxlZnRDaGlsZCxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogci5sYXllciArIDFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoci5ub2RlLnJpZ2h0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiByLm5vZGUucmlnaHRDaGlsZCxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogci5sYXllciArIDFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pyA5ZCO5LiA5Liq6Zif5YiX5YWD57Sg5omA5Zyo5bGC5bCx5piv5qCR55qE6auY5bqmXHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHIubGF5ZXI7XHJcbiAgICAgICAgbGV0IG1heCA9IGNvdW50QXJyWzBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBjb3VudEFycltpXTsgaSsrKVxyXG4gICAgICAgICAgICAvLyDmsYLlsYLmnIDlpKfnu5PngrnmlbBcclxuICAgICAgICAgICAgaWYgKGNvdW50QXJyW2ldID4gbWF4KSBtYXggPSBjb3VudEFycltpXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhlaWdodCAqIG1heDtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLmoJHnu5PngrnnmoTlrZDlrZnmgLvmlbDloavlhaVkZXNjTnVt5Z+f5Lit77yM5bm26L+U5ZueXHJcbiAgICBkZXNjTnVtKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcclxuICAgICAgICAgICAgbGV0IGQ7XHJcbiAgICAgICAgICAgIGlmICghbm9kZSkgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBlbHNlIGQgPSByZWN1cnNlKG5vZGUubGVmdENoaWxkKSArIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKSArIDI7XHJcblxyXG4gICAgICAgICAgICBub2RlLmRlc2NOdW0gPSBkO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgfSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDliKTmlq3kuozlj4nmoJHmmK/lkKblrozlhajkuozlj4nmoJFcclxuICAgIHN0YXRpYyBpc0Z1bGxCaW5hcnlUcmVlKHRyZWUpIHtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICBsZXQgZmxhZyA9IDA7XHJcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh0cmVlKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXApIGZsYWcgPSAxO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChmbGFnKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShwLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAucmlnaHRDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyDmsYLku450cmVl5Yiwbm9kZee7k+eCuei3r+W+hOeahOmAkuW9kueul+azlVxyXG5mdW5jdGlvbiBmaW5kUGF0aCh0cmVlLCBub2RlLCBpID0gMCkge1xyXG4gICAgbGV0IHBhdGggPSBbXTtcclxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZSh0cmVlLCBpKSB7XHJcbiAgICAgICAgaWYgKHRyZWUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhdGhbaV0gPSB0cmVlO1xyXG4gICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgcmVjdXJzZSh0cmVlLmxlZnRDaGlsZCwgaSArIDEpO1xyXG4gICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQgJiYgIWZvdW5kKSByZWN1cnNlKHRyZWUucmlnaHRDaGlsZCwgaSArIDEpO1xyXG4gICAgICAgIGlmICghZm91bmQpIHBhdGhbaV0gPSBudWxsO1xyXG4gICAgfSh0cmVlLCBpKTtcclxuXHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5cclxubGV0IGdsb2JhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpczsnKSgpO1xyXG5cclxuLy8g5rGC5rex5bqm562J5LqO5qCR55qE6auY5bqm5YeP5LiA55qE5pyA6Z2g5bem55qE57uT54K5XHJcbmZ1bmN0aW9uIHByaW50UGF0aF9tYXhEZXB0aFMxKHRyZWUpe1xyXG4gICAgbGV0IG1heGggPSB0cmVlLmdldERlcHRoKCk7XHJcbiAgICBsZXQgcGF0aCA9IFtdO1xyXG5cclxuICAgIGlmIChtYXhoIDwgMikgcmV0dXJuIGZhbHNlO1xyXG4gICAgZmluZF9oKHRyZWUsIDEpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRfaCh0cmVlLCBoKSB7XHJcbiAgICAgICAgcGF0aFtoXSA9IHRyZWU7XHJcblxyXG4gICAgICAgIGlmIChoID09IG1heGggLSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBzID0gJyAnO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgcGF0aFtpXTsgaSsrKSBzICs9IHBhdGhbaV0uZGF0YSArIChwYXRoW2kgKyAxXSA/ICcgLT4gJyA6ICcnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHJlZS5sZWZ0Q2hpbGQpIGZpbmRfaCh0cmVlLmxlZnRDaGlsZCwgaCArIDEpO1xyXG4gICAgICAgICAgICBpZiAodHJlZS5yaWdodENoaWxkKSBmaW5kX2godHJlZS5yaWdodENoaWxkLCBoICsgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXRoW2hdID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHRyZWUgPSBbMSwgMiwgMywgNCwgNSwgLCA2LCAsICwgN107XHJcbnZhciB0ZXN0ID0gbmV3IEJpbmFyeVRyZWUoKTtcclxudGVzdC5jcmVhdGVCaW5hcnlUcmVlKHRyZWUpO1xyXG5cclxuY29uc29sZS5sb2coJ2l0ZXJhdG9yOiAnKTtcclxuZm9yKGxldCB4IG9mIHRlc3Qpe1xyXG4gICAgY29uc29sZS5sb2coeCk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICog5qCR55qEM+enjeW4uOeUqOmTvuihqOe7k+aehFxyXG4gKi9cclxuXHJcbi8vIDEu5Y+M5Lqy6KGo56S65rOVXHJcbi8vIOS8mOeCue+8mnBhcmVudCh0cmVlLCB4KeaTjeS9nOWPr+S7peWcqOW4uOmHj+aXtumXtOWGheWunueOsFxyXG4vLyDnvLrngrnvvJrmsYLnu5PngrnnmoTlranlrZDml7bpnIDopoHpgY3ljobmlbTkuKrnu5PmnoRcclxuZXhwb3J0IGNsYXNzIFBhcmVudFRyZWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERlcHRoKCkge1xyXG4gICAgICAgIGxldCBtYXhEZXB0aCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZGVwID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPj0gMDsgaiA9IHRoaXMubm9kZXNbaV0ucGFyZW50KSBkZXArKztcclxuICAgICAgICAgICAgaWYgKGRlcCA+IG1heERlcHRoKSBtYXhEZXB0aCA9IGRlcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtYXhEZXB0aDtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgUGFyZW50VHJlZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIHBhcmVudCA9IDApIHtcclxuICAgICAgICAvLyB0eXBlOiBQYXJlbnRUcmVlXHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvLyDlj4zkurLkvY3nva7ln58ge051bWJlcn1cclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIH1cclxufVxyXG5cclxubGV0IHB0ID0gbmV3IFBhcmVudFRyZWUoKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ1InLCAtMSkpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnQScsIDApKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0InLCAwKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdDJywgMCkpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRCcsIDEpKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0UnLCAxKSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdGJywgMykpO1xyXG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRycsIDYpKTtcclxucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0gnLCA2KSk7XHJcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdJJywgNikpO1xyXG5cclxuXHJcbi8vIOWtqeWtkOihqOekuuazlVxyXG5cclxuZXhwb3J0IGNsYXNzIENoaWxkVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVwdGgoKSB7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdWJEZXB0aChyb290SW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKCFzZWxmLm5vZGVzW3Jvb3RJbmRleF0pIHJldHVybiAxO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNkID0gMTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHNlbGYubm9kZXNbcm9vdEluZGV4XTsgcDsgcCA9IHAubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGQgPSBzdWJEZXB0aChwLmNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGlmIChkID4gc2QpIHNkID0gZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNkICsgMTtcclxuICAgICAgICB9KHRoaXMuZGF0YVswXSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gKiBAcGFyYW0ge0NoaWxkVHJlZU5vZGV9IGZpcnN0Q2hpbGQg5a2p5a2Q6ZO+6KGo5aS05oyH6ZKIXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgQ2hpbGRUcmVlQm94IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBmaXJzdENoaWxkID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gZmlyc3RDaGlsZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOWtqeWtkOe7k+eCuVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gY2hpbGRcclxuICogQHBhcmFtIHtDaGlsZFRyZWVOb2RlfSBuZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgQ2hpbGRUcmVlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCA9IG51bGwsIG5leHQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qXHJcbiDlranlrZDooajnpLrms5Xkvr/kuo7mtonlj4rlranlrZDnmoTmk43kvZznmoTlrp7njrDvvIzkvYbkuI3pgILnlKjkuo5wYXJlbnTmk43kvZzjgIJcclxuIOaIkeS7rOWPr+S7peaKiuWPjOS6suihqOekuuazleWSjOWtqeWtkOihqOekuuazlee7k+WQiOi1t+adpeOAglxyXG4gKi9cclxuXHJcblxyXG4vLyDlranlrZDlhYTlvJ/ooajnpLrms5Uo5LqM5Y+J5qCR6KGo56S65rOVKVxyXG4vLyDlj6/lop7orr7kuIDkuKpwYXJlbnTln5/lrp7njrBwYXJlbnTmk43kvZxcclxuZXhwb3J0IGNsYXNzIENoaWxkU2libGluZ1RyZWUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIGZpcnN0Q2hpbGQgPSBudWxsLCBuZXh0U2libGluZyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOi+k+WHuuWtqeWtkOWFhOW8n+mTvuihqOihqOekuueahOagkeeahOWQhOi+uVxyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSB0aGlzLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCclYyAlYycsIHRoaXMuZGF0YSwgY2hpbGQuZGF0YSk7XHJcbiAgICAgICAgICAgIGNoaWxkLnByaW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguWtqeWtkOWFhOW8n+mTvuihqOihqOekuueahOagkeeahOWPtuWtkOaVsOebrlxyXG4gICAgbGVhZkNvdW50KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSB0aGlzLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSBjaGlsZC5sZWFmQ291bnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOaxguagkeeahOW6plxyXG4gICAgZ2V0RGVncmVlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGRlZ3JlZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLmZpcnN0Q2hpbGQ7IHA7IHAgPSBwLm5leHRTaWJsaW5nKSBkZWdyZWUrKztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLmZpcnN0Q2hpbGQ7IHA7IHAgPSBwLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHAuZ2V0RGVncmVlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IGRlZ3JlZSkgZGVncmVlID0gZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRlZ3JlZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVwdGgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IGdsb2JhbCkgcmV0dXJuIDA7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBtYXhkID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkID0gcC5nZXREZXB0aCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPiBtYXhkKSBtYXhkID0gZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1heGQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9CaW5hcnlUcmVlL0JpbmFyeVRyZWUuanNcbiAqKi8iLCIvKipcclxuICog5qCIXHJcbiAqXHJcbiAqIOaYr+mZkOWumuS7heWcqOihqOWwvui/m+ihjOaPkuWFpeaIluWIoOmZpOaTjeS9nOeahOe6v+aAp+ihqOOAguihqOWwvuS4uuagiOmhtu+8iHRvcO+8ie+8jOihqOWktOS4uuagiOW6le+8iGJvdHRvbe+8ie+8jOS4jeWQq+WFg+e0oOeahOepuuihqOS4uuepuuagiOOAglxyXG4gKiDmoIjlj4jnp7DkuLrlkI7ov5vlhYjlh7rvvIhsYXN0IGluIGZpcnN0IG91dO+8ieeahOe6v+aAp+ihqOOAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDpobrluo/moIhcclxuICog5qCI55qE6aG65bqP5a2Y5YKo57uT5p6E5piv5Yip55So5LiA57uE5Zyw5Z2A6L+e57ut55qE5a2Y5YKo5Y2V5YWD5L6d5qyh5a2Y5pS+6Iez5qCI5bqV5Yiw5qCI6aG255qE5YWD57Sg77yM5ZCM5pe26ZmE6K6+5oyH6ZKIdG9w5oyH56S65qCI6aG25YWD57Sg5Zyo6aG65bqP5qCI5Lit55qE5L2N572u44CCXHJcbiAqXHJcbiAqL1xyXG5cclxuLy8g5qCI55qE6ZO+5byP6KGo56S6XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudG9wID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNpemUoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIHB1c2ggKGRhdGEpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHtcclxuICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgbmV4dDogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5vZGUubmV4dCA9IHRoaXMudG9wO1xyXG4gICAgICAgIHRoaXMudG9wID0gbm9kZTtcclxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgfVxyXG4gICAgcGVlayAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSBudWxsID9cclxuICAgICAgICAgICAgbnVsbCA6XHJcbiAgICAgICAgICAgIHRoaXMudG9wLmRhdGE7XHJcbiAgICB9XHJcbiAgICBwb3AgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRvcCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGxldCBvdXQgPSB0aGlzLnRvcDtcclxuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wLm5leHQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMubGVuZ3RoLS07XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHJldHVybiBvdXQuZGF0YTtcclxuICAgIH1cclxuICAgIGNsZWFyICgpIHtcclxuICAgICAgICB0aGlzLnRvcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRvcCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGxldCBhcnIgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudG9wO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5zaXplOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyW2ldID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxufVxyXG5cclxubGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcblxyXG5zdGFjay5wdXNoKDEpO1xyXG5zdGFjay5wdXNoKCdhc2QnKTtcclxuXHJcbnN0YWNrLnBvcCgpO1xyXG5zdGFjay5wdXNoKHthOiAxfSk7XHJcbmNvbnNvbGUubG9nKHN0YWNrKTtcclxuXHJcbi8qKlxyXG4gKiDov5nph4znlKjlrZfnrKbkuLJ0cmFpbuihqOekuueBq+i9pu+8jEjooajnpLrnoazluK3vvIxT6KGo56S66L2v5bitXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFpblxyXG4gKi9cclxuZnVuY3Rpb24gdHJhaW5BcnJhbmdlKHRyYWluKXtcclxuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgbGV0IHEgPSBbXTtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGxldCBqID0gMDtcclxuXHJcbiAgICB3aGlsZSh0cmFpbltpXSl7XHJcbiAgICAgICAgaWYodHJhaW5baV0gPT09ICdIJykgc3RhY2sucHVzaCh0cmFpbltpXSk7XHJcbiAgICAgICAgZWxzZSBxW2orK10gPSB0cmFpbltpXTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUoc3RhY2subGVuZ3RoKXtcclxuICAgICAgICBsZXQgYyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHFbaisrXSA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHEgKyAnJztcclxufVxyXG5cclxuY29uc29sZS5sb2coJ3RyYWluQXJyYW5nZTogJyArIHRyYWluQXJyYW5nZSgnSFNTSFNTU0hISEhIUycpKTsgIC8vIHRyYWluQXJyYW5nZTogUyxTLFMsUyxTLFMsSCxILEgsSCxILEgsSFxyXG5cclxuXHJcbi8vIOWIpOaWreWtl+espuS4suS4reKAnCbigJ3liY3lkozigJwm4oCd5ZCO6YOo5YiG5piv5ZCm5Li66YCG5Liy77yMXCJAXCLooajnpLrnu5PmnZ/nrKbvvIzmmK/liJnov5Tlm550cnVl77yM5ZCm5YiZ6L+U5ZueZmFsc2VcclxuZnVuY3Rpb24gaXNSZXZlcnNlKHN0cil7XHJcbiAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgIGxldCBpID0gMDtcclxuXHJcbiAgICB3aGlsZShzdHJbaV0gIT09ICcmJyl7XHJcbiAgICAgICAgaWYoc3RyW2ldID09PSAnQCcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBzdGFjay5wdXNoKHN0cltpXSk7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIGkrKztcclxuXHJcbiAgICB3aGlsZShzdHJbaV0gIT09ICdAJykge1xyXG4gICAgICAgIGlmKCFzdGFjay5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IHMgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICBpZihzICE9PSBzdHJbaV0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICFzdGFjay5sZW5ndGg7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCdpc1JldmVyc2U6ICcgKyBpc1JldmVyc2UoJ2FiY2QmZGNiYUBhJykpOyAgLy8gdHJ1ZVxyXG5cclxuXHJcbi8vIOaVsOWAvOi/m+WItui9rOaNolxyXG4vLyDlhazlvI/vvJogTiA9IChOIC8gZCkgKiBkICsgTiAlIGRcclxuLy8gTu+8muWNgei/m+WItuaVsOWAvO+8jCBk77ya6ZyA6KaB6L2s5o2i55qE6L+b5Yi25pWwXHJcbmZ1bmN0aW9uIG51bVRyYW5zZm9ybShudW1iZXIsIHJhZCkge1xyXG4gICAgbGV0IHMgPSBuZXcgU3RhY2soKTtcclxuXHJcbiAgICB3aGlsZSAobnVtYmVyKSB7XHJcbiAgICAgICAgcy5wdXNoKG51bWJlciAlIHJhZCk7XHJcbiAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQobnVtYmVyIC8gOCwgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBhcnIgPSBbXTtcclxuICAgIHdoaWxlIChzLnRvcCkge1xyXG4gICAgICAgIGFyci5wdXNoKHMucG9wKCkpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coYXJyLmpvaW4oJycpKTtcclxufVxyXG5cclxubnVtVHJhbnNmb3JtKDEzNDgsIDgpO1xyXG5udW1UcmFuc2Zvcm0oMTM0OCwgMik7XHJcblxyXG5cclxuLy8g5ous5Y+35Yy56YWN5qOA5p+lXHJcbmZ1bmN0aW9uIGJyYWNrZXRzTWF0Y2goc3RyKSB7XHJcbiAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgIGxldCB0ZXh0ID0gJyc7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyW2ldO1xyXG4gICAgICAgIGlmIChjID09PSAnWycpIHtcclxuICAgICAgICAgICAgc3RhY2sucHVzaChjKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICddJykge1xyXG4gICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCB8fCBzdGFjay5wb3AoKSAhPT0gJ1snKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJhY2tldHM6JyArIGMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQgKz0gYztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyh0ZXh0KTtcclxufVxyXG5cclxuY29uc29sZS5sb2coYnJhY2tldHNNYXRjaCgnW2FzZF0nKSk7XHJcblxyXG5mdW5jdGlvbiBNYXRjaGVyKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xyXG59XHJcbk1hdGNoZXIucHJvdG90eXBlID0ge1xyXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICBsZXQgdGV4dCA9ICcnO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjID0gc3RyW2ldO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gdGhpcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gdGhpcy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLnN0YWNrLnBvcCgpICE9PSB0aGlzLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJhY2tldHM6JyArIGMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9ICcsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyh0ZXh0KTtcclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxufTtcclxubGV0IG0gPSBuZXcgTWF0Y2hlcigneycsICd9Jyk7XHJcbm0ubWF0Y2goJ1t7MTIzfTEyMycpO1xyXG5cclxuZnVuY3Rpb24gTGluZUVkaXRvcihzdHIpIHtcclxuICAgIHRoaXMuc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgIHRoaXMuc3RyID0gc3RyIHx8ICcnO1xyXG59XHJcbkxpbmVFZGl0b3IucHJvdG90eXBlID0ge1xyXG4gICAgZ2V0UmVzdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zdGFjaztcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy5zdHI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYyA9IHN0cltpXTtcclxuICAgICAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcjJzpcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgICAgICBsZXQgY3VycmVudCA9IHN0YWNrLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjdXJyZW50LmRhdGEgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59O1xyXG5cclxubGV0IGxlID0gbmV3IExpbmVFZGl0b3IoJ3dobGkjI2lsciNlKHMjKnMpXFxcclxuICAgIFxcbm91dGNoYUBwdXRjaGFyKCpzPSMrKyknKTtcclxuY29uc29sZS5sb2cobGUuZ2V0UmVzdWx0KCkpO1xyXG5cclxuXHJcbmxldCBwcmlvdHkgPSB7XHJcbiAgICBcIitcIjogMSxcclxuICAgIFwiLVwiOiAxLFxyXG4gICAgXCIlXCI6IDIsXHJcbiAgICBcIipcIjogMixcclxuICAgIFwiL1wiOiAyLFxyXG4gICAgXCJeXCI6IDMsXHJcbiAgICBcIihcIjogMCxcclxuICAgIFwiKVwiOiAwLFxyXG4gICAgXCJgXCI6IC0xXHJcbn07XHJcblxyXG5mdW5jdGlvbiBkb29wKG9wLCBvcG4xLCBvcG4yKSB7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSBcIitcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgKyBvcG4yO1xyXG4gICAgICAgIGNhc2UgXCItXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBvcG4xIC0gb3BuMjtcclxuICAgICAgICBjYXNlIFwiKlwiOlxyXG4gICAgICAgICAgICByZXR1cm4gb3BuMSAqIG9wbjI7XHJcbiAgICAgICAgY2FzZSBcIi9cIjpcclxuICAgICAgICAgICAgcmV0dXJuIG9wbjEgLyBvcG4yO1xyXG4gICAgICAgIGNhc2UgXCIlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBvcG4xICUgb3BuMjtcclxuICAgICAgICBjYXNlIFwiXlwiOlxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3cob3BuMSwgb3BuMik7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wY29tcChhLCBiKSB7XHJcbiAgICByZXR1cm4gcHJpb3R5W2FdIC0gcHJpb3R5W2JdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxJbmZpeEV4cHJlc3Npb24oZXhwKSB7XHJcbiAgICBsZXQgY3MgPSBbXTtcclxuICAgIGxldCBucyA9IFtdO1xyXG4gICAgZXhwID0gZXhwLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcclxuICAgIGV4cCArPSAnYCc7XHJcbiAgICBpZiAoZXhwWzBdID09PSAnLScpIHtcclxuICAgICAgICBleHAgPSBcIjBcIiArIGV4cDtcclxuICAgIH1cclxuICAgIGxldCBjO1xyXG4gICAgbGV0IG9wO1xyXG4gICAgbGV0IG9wbjE7XHJcbiAgICBsZXQgb3BuMjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IGV4cFtpXTtcclxuICAgICAgICAvLyDlpoLmnpzmmK/mk43kvZznrKZcclxuICAgICAgICBpZiAoYyBpbiBwcmlvdHkpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5Y+z6L655LiN5piv5bem5ous5Y+35LiU5pON5L2c56ym5qCI55qE5qCI6aG25YWD57Sg5LyY5YWI5p2D5q+U5Y+z6L655aSnXHJcbiAgICAgICAgICAgIC8vIOW+queOr+mBjeWOhui/m+ihjOi/nue7rei/kOeul1xyXG4gICAgICAgICAgICB3aGlsZSAoYyAhPSAnKCcgJiYgY3MubGVuZ3RoICYmIG9wY29tcChjc1tjcy5sZW5ndGggLSAxXSwgYykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8g5Ye65qCI55qE5pON5L2c56ymXHJcbiAgICAgICAgICAgICAgICBvcCA9IGNzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5LiN5piv5bem5ous5Y+35oiW6ICF5Y+z5ous5Y+377yM6K+05piO5piv6L+Q566X56ymXHJcbiAgICAgICAgICAgICAgICBpZiAob3AgIT0gJygnICYmIG9wICE9ICcpJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWHuuagiOS/neWtmOaVsOWtl+eahOagiOeahOS4pOS4quWFg+e0oFxyXG4gICAgICAgICAgICAgICAgICAgIG9wbjIgPSBucy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBvcG4xID0gbnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5bCG5LiO5pON5L2c56ym6L+Q566X5ZCO55qE57uT5p6c5L+d5a2Y5Yiw5qCI6aG2XHJcbiAgICAgICAgICAgICAgICAgICAgbnMucHVzaChkb29wKG9wLCBvcG4xLCBvcG4yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5aaC5p6c5Y+z6L655LiN5piv5Y+z5ous5Y+377yM5L+d5a2Y5Yiw5pON5L2c56ym5qCI5LitXHJcbiAgICAgICAgICAgIGlmIChjICE9ICcpJykgY3MucHVzaChjKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDlpJrkvY3mlbDnmoTmlbDlrZfnmoTmg4XlhrVcclxuICAgICAgICAgICAgd2hpbGUgKCEoZXhwW2ldIGluIHByaW90eSkpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGMgKz0gZXhwW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5zLnB1c2gocGFyc2VGbG9hdChjKSk7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnMubGVuZ3RoID8gbnNbMF0gOiBOYU47XHJcbn1cclxuXHJcbmxldCBleHAxID0gY2FsSW5maXhFeHByZXNzaW9uKCc1KzMqNC8yLTJeMys1JTInKTtcclxuY29uc29sZS5sb2coZXhwMSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1N0YWNrL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS80LzEyLlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvZGVmYXVsdENvbXBhcmlzaW9uLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXHJcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxyXG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcclxuXHJcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcclxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xyXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXHJcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcclxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXHJcbiAgICAsIGd0ICAgICA9ICc+J1xyXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcclxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcclxuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBpZihPICE9PSBudWxsKXtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxyXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XHJcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcclxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog5b6q546v6ZO+6KGo77yIY2lyY3VsYXIgbGlua2VkIGxpc3TvvIlcclxuICog5piv5Y+m5LiA56eN5b2i5byP55qE6ZO+5byP5a2Y5YKo57uT5p6E44CC5a6D55qE54m554K55piv6KGo5Lit5pyA5ZCO5LiA5Liq57uT54K555qE5oyH6ZKI5Z+f5oyH5ZCR5aS057uT54K577yM5pW05Liq6KGo5b2i5oiQ5LiA5Liq546v44CCXHJcbiAqIOW+queOr+mTvuihqOeahOaTjeS9nOWSjOe6v+aAp+mTvuihqOWfuuacrOS4gOiHtO+8jOS7heaciee7huW+ruW3ruWIq+OAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDlj4zlkJHpk77ooahcclxuICpcclxuICog5Y+M5ZCR6ZO+6KGo5piv5Li65LqG5YWL5pyN5Y2V6ZO+6KGo6L+Z56eN5Y2V5ZCR5oCn55qE57y654K544CCXHJcbiAqIOWPjOWQkemTvuihqOeahOe7k+eCueS4reacieS4pOS4quaMh+mSiOWfn++8jOWFtuS4gOaMh+WQkeebtOaOpeWQjue7p++8jOWPpuS4gOaMh+WQkeebtOaOpeWJjei2i+OAglxyXG4gKlxyXG4gKiDlj4zlkJHpk77ooajkuZ/lj6/ku6XmnInlvqrnjq/ooajjgIJcclxuICovXHJcblxyXG5jbGFzcyBOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHByZXYgPSBudWxsLCBuZXh0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcclxuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYjtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG91YmxlTGlua2VkTGlzdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcUxpc3QsIGNvbXBhcmUgPSBkZWZhdWx0Q29tcGFyZSkge1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XHJcblxyXG4gICAgICAgIGlmKHNxTGlzdCAmJiBzcUxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygc3FMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCl7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGN1cnJlbnQuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKXtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVzaChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGFyZ3VtZW50IHJlcXVpcmVkJyk7XHJcblxyXG4gICAgICAgICsrdGhpcy5zaXplO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBOb2RlKGRhdGEsIHRoaXMudGFpbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHVuc2hpZnQoZGF0YSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZGF0YSBhcmd1bWVudCByZXF1aXJlZCcpO1xyXG5cclxuICAgICAgICArK3RoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgTm9kZShkYXRhLCBudWxsLCB0aGlzLmhlYWQpO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQucHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLS10aGlzLnNpemU7XHJcblxyXG4gICAgICAgIHRoaXMudGFpbC5wcmV2Lm5leHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xyXG4gICAgfVxyXG5cclxuICAgIHNoaWZ0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC0tdGhpcy5zaXplO1xyXG5cclxuICAgICAgICB0aGlzLmhlYWQubmV4dC5wcmV2ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdXBkYXRlKGluZGV4LCBkYXRhKXtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZmluZEJ5SW5kZXgoaW5kZXgsIHRydWUpO1xyXG4gICAgICAgIG5vZGUuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignZGF0YSBhcmd1bWVudCByZXF1aXJlZCcpO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZShkYXRhLCBjdXJyZW50LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAtLXRoaXMuc2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gdGhpcy50YWlsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhaWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsLnByZXYubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnByZXYubmV4dCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldiA9IGN1cnJlbnQucHJldjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGluZGV4T2YoZGF0YSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG5cclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlKGRhdGEsIGN1cnJlbnQuZGF0YSkpIHJldHVybiBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgZmluZEJ5SW5kZXgoaW5kZXggPSAwLCByZXR1cm5Ob2RlKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGogPSAwO1xyXG5cclxuICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgIGlmIChqKysgPT09IGluZGV4KSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXR1cm5Ob2RlID8gY3VycmVudCA6IGN1cnJlbnQuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBmb3JFYWNoKGNiID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGNiKGN1cnJlbnQuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgbGlzdC5wdXNoKGN1cnJlbnQuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCkgKyAnJztcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmxldCBhID0gbmV3IERvdWJsZUxpbmtlZExpc3QoWzIsIDNdKTtcclxuYS51bnNoaWZ0KDEpO1xyXG5hLnB1c2goNCk7XHJcbmNvbnNvbGUubG9nKGEuaW5kZXhPZig0KSk7XHJcbmNvbnNvbGUubG9nKGEuZmluZEJ5SW5kZXgoMikpO1xyXG5cclxuZm9yKGxldCBpdGVtIG9mIGEpe1xyXG4gICAgY29uc29sZS5sb2coaXRlbSk7XHJcbn1cclxuXHJcbmEucG9wKCk7XHJcbmEuc2hpZnQoKTtcclxuYS5yZW1vdmUoMik7XHJcbmEucmVtb3ZlKDMyKTtcclxuYS5yZW1vdmUoMyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9Eb3VibGVMaW5rZWRMaXN0LmpzXG4gKiovIiwiLyoqXHJcbiAqIOeUseS6jumTvuihqOWcqOepuumXtOeahOWQiOeQhuWIqeeUqOS4iuWSjOaPkuWFpe+8jOWIoOmZpOaXtuS4jemcgOimgeenu+WKqOetieeahOacieeCue+8jOWboOatpOWcqOW+iOWkmuWcuuWQiOS4i++8jOWug+aYr+e6v+aAp+ihqOeahOmmlumAieWtmOWCqOe7k+aehOOAgueEtuiAjO+8jOWug+S5n+WtmOWcqOedgOWunueOsOafkOS6m+WfuuacrOaTjeS9nO+8jOWmguaxgue6v+aAp+ihqOmVv+W6puaXtuS4jeWmgumhuuW6j+WtmOWCqOe7k+aehOeahOe8uueCue+8m+WPpuS4gOaWuemdou+8jOeUseS6juWcqOmTvuihqOS4re+8jOe7k+eCueS5i+mXtOeahOWFs+ezu+S9v+eUqOaMh+mSiOadpeihqOekuu+8jOWImeaVsOaNruWFg+e0oOWcqOe6v+aAp+ihqOS4reeahOKAnOS9jeW6j+KAneeahOamguW/teW3sua3oeWMlu+8jOiAjOiiq+aVsOaNruWFg+e0oOWcqOe6v+aAp+mTvuihqOS4reeahOKAnOS9jee9ruKAneaJgOS7o+abv+OAguS4uuatpO+8jOS7juWunumZheWHuuWPkemHjeaWsOWumuS5iee6v+aAp+mTvuihqOWPiuWFtuWfuuacrOaTjeS9nFxyXG4gKi9cclxuXHJcbmNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIG5leHQgPSBudWxsKXtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3Ioc3FMaXN0KXtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChzcUxpc3QpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSlcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaChzcUxpc3RbaV0pO1xyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRpYyBtZXJnZUxpc3QgKGEsIGIsIGNvbXBhcmUgPSBjb21wRm4pIHtcclxuICAgICAgICBsZXQgaGEgPSBhLmhlYWQ7XHJcbiAgICAgICAgbGV0IGhiID0gYi5oZWFkO1xyXG4gICAgICAgIGxldCBwYSA9IGhhO1xyXG4gICAgICAgIGxldCBwYiA9IGhiO1xyXG4gICAgICAgIGxldCBjID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgICAgICBsZXQgcTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHBhICYmIHBiKSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhMSA9IHBhLmRhdGE7XHJcbiAgICAgICAgICAgIGxldCBkYXRhMiA9IHBiLmRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmUoZGF0YTEsIGRhdGEyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGhlYWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgcSA9IGEuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgbm9kZSB0byBjIGxpbmtlZExpc3RcclxuICAgICAgICAgICAgICAgIGMuYXBwZW5kKHEpO1xyXG4gICAgICAgICAgICAgICAgcGEgPSBhLmhlYWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxID0gYi5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XHJcbiAgICAgICAgICAgICAgICBwYiA9IGIuaGVhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhKSBjLmFwcGVuZChwYSk7XHJcbiAgICAgICAgZWxzZSBjLmFwcGVuZChwYik7XHJcblxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRlbGV0ZSBmaXJzdCBlbGVtZW50IGFuZCByZXR1cm4gaXRcclxuICAgIHNoaWZ0ICgpIHtcclxuICAgICAgICBsZXQgaGVhZCA9IHRoaXMuaGVhZDtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcclxuICAgICAgICBoZWFkLm5leHQgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgfVxyXG5cclxuICAgIHBvcCgpe1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgZWxlbTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFpbCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzLnRhaWwuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHByZXZpb3VzO1xyXG5cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICBlbGVtID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHRoaXMudGFpbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFwcGVuZCBub2RlXHJcbiAgICBhcHBlbmQgKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGRhdGFcclxuICAgIHB1c2ggKGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRhaWwuZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlIGRhdGFcclxuICAgIHJlbW92ZSAoZGF0YSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgZWxlbTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGN1cnJlbnQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLnRhaWwpIHRoaXMudGFpbCA9IHByZXZpb3VzO1xyXG5cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICBlbGVtID0gY3VycmVudC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHRoaXMudGFpbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGluZGV4T2YoZGF0YSl7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YSA9PT0gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHVuc2hpZnQgKGRhdGEpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgIHRlbXAubmV4dCA9IHRoaXMuaGVhZDtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgaW5zZXJ0QWZ0ZXIgKHRhcmdldCwgZGF0YSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEgPT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIHRlbXAubmV4dCA9IGN1cnJlbnQubmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy50YWlsKSB0aGlzLnRhaWwgPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXRlbSAoaW5kZXgpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKC0taW5kZXggPT09IDApIHJldHVybiBjdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWFjaCAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XHJcblxyXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50Lm5leHQpXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjdXJyZW50KSkgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCl7XHJcbiAgICAgICAgZm9yKGxldCBjdXJyZW50ID0gdGhpcy5oZWFkOyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5uZXh0KXtcclxuICAgICAgICAgICAgeWllbGQgY3VycmVudC5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaXplICgpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgc2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICsrc2l6ZTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBsZXQgc3RyID0gJyc7XHJcblxyXG4gICAgICAgIHRoaXMuZWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBzdHIgKz0gbm9kZS5kYXRhICsgKG5vZGUubmV4dCA/ICcsJyA6ICcnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICBvcmRlckluc2VydCAoZGF0YSwgY21wKSB7XHJcbiAgICAgICAgY21wID0gdHlwZW9mIGNtcCA9PT0gJ2Z1bmN0aW9uJyA/IGNtcCA6IChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhID4gYilcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChhID09PSBiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHJldCA9IGNtcChkYXRhLCBjdXJyZW50LmRhdGEpO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzmj5LlhaXlhYPntKDlpKfkuo7lvZPliY3lhYPntKDvvIzlh4blpIfkuIvmrKHpgY3ljoZcclxuICAgICAgICAgICAgaWYgKHJldCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c562J5LqO77yM55u05o6l5o+S5YWl5Yiw5ZCO6Z2iXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5bCP5LqO5YiZ5o+S5YWl5Yiw5YmN6IqC54K55ZKM5b2T5YmN6IqC54K55LitXHJcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrlt7Lnu4/mmK/mjpLluo/kuobvvIzmiYDku6XkuI3pnIDopoHlpJrkvZnliKTmlq3kuoZcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWQgPT09IHByZXZpb3VzICYmIHByZXZpb3VzID09PSBjdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2hpZnQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEJldHdlZW4oZGF0YSwgcHJldmlvdXMsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmj5LlhaXliLDmnIDlkI7kuIDkuKrnu5PngrlcclxuICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV3IE5vZGUoZGF0YSk7XHJcbiAgICAgICAgdGhpcy50YWlsID0gcHJldmlvdXMubmV4dDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QmV0d2VlbihkYXRhLCBhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmIChhID09IGIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhID09IG1lLmhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLnVuc2hpZnQoZGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGVtcC5uZXh0ID0gYjtcclxuICAgICAgICAgICAgICAgIGEubmV4dCA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDliKDpmaTlhYPntKDpgJLlop7mjpLliJfnmoTpk77ooajkuK3lgLzlpKfkuo5taW7vvIzkuJTlsI/kuo5tYXjnmoTmiYDmnInlhYPntKBcclxuICAgIGRlbGV0ZV9iZXR3ZWVuIChtaW4sIG1heCkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICAvLyBw5piv5pyA5ZCO5LiA5Liq5LiN5aSn5LqObWlu55qE5YWD57SgXHJcbiAgICAgICAgd2hpbGUgKHAubmV4dCAmJiBwLm5leHQuZGF0YSA8PSBtaW4pIHAgPSBwLm5leHQ7XHJcblxyXG4gICAgICAgIC8vIOWmguaenOi/mOacieavlG1pbuabtOWkp+eahOWFg+e0oFxyXG4gICAgICAgIGxldCBxO1xyXG4gICAgICAgIGlmIChwLm5leHQpIHtcclxuICAgICAgICAgICAgcSA9IHAubmV4dDtcclxuICAgICAgICAgICAgLy8gceaYr+esrOS4gOS4quS4jeWwj+S6jm1heOeahOWFg+e0oFxyXG4gICAgICAgICAgICB3aGlsZSAocSAmJiBxLmRhdGEgPCBtYXgpIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgICAgIHAubmV4dCA9IHE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGFzdCA9IHEgfHwgcDtcclxuICAgICAgICB3aGlsZSAobGFzdC5uZXh0KSBsYXN0ID0gbGFzdC5uZXh0O1xyXG4gICAgICAgIHRoaXMudGFpbCA9IGxhc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5Yig6Zmk5YWD57Sg6YCS5aKe5o6S5YiX55qE6ZO+6KGo55qE6YeN5aSN5YWD57SgXHJcbiAgICBkZWxldGVfZXF1YWwgKCkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBxID0gcC5uZXh0O1xyXG5cclxuICAgICAgICB3aGlsZSAocC5uZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIOW9k+ebuOmCu+S4pOWFg+e0oOS4jeebuOetieaXtu+8jHAscemDveWQkeWQjuenu1xyXG4gICAgICAgICAgICBpZiAocC5kYXRhICE9PSBxLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgICAgICBxID0gcC5uZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHEuZGF0YSA9PT0gcC5kYXRhKSBxID0gcS5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIOWIoOmZpFxyXG4gICAgICAgICAgICAgICAgcC5uZXh0ID0gcTtcclxuICAgICAgICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgICAgICAgICAgcSA9IHAubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXZlcnNlICgpIHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgcSA9IHAubmV4dDtcclxuICAgICAgICBsZXQgcyA9IHEubmV4dDtcclxuICAgICAgICBwLm5leHQgPSBudWxsO1xyXG5cclxuICAgICAgICB3aGlsZSAocy5uZXh0KSB7XHJcbiAgICAgICAgICAgIHEubmV4dCA9IHA7XHJcbiAgICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgICAgICBxID0gcztcclxuICAgICAgICAgICAgcyA9IHMubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEubmV4dCA9IHA7XHJcbiAgICAgICAgcy5uZXh0ID0gcTtcclxuICAgICAgICB0aGlzLmhlYWQgPSBzO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wRm4oYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcblxyXG5cclxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXHJcbmZ1bmN0aW9uIGludGVyc2VjdChsaXN0LCBiTGlzdCkge1xyXG4gICAgbGV0IGNMaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxuXHJcbiAgICBsZXQgcCA9IGxpc3QuaGVhZDtcclxuICAgIGxldCBxID0gYkxpc3QuaGVhZDtcclxuXHJcbiAgICB3aGlsZSAocCAmJiBxKSB7XHJcbiAgICAgICAgaWYgKHAuZGF0YSA8IHEuZGF0YSkgcCA9IHAubmV4dDtcclxuICAgICAgICBlbHNlIGlmIChxLmRhdGEgPiBxLmRhdGEpIHEgPSBxLm5leHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNMaXN0LnB1c2gocS5kYXRhKTtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgcSA9IHEubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNMaXN0O1xyXG59XHJcblxyXG4vLyDmsYLlhYPntKDpgJLlop7mjpLliJfnmoTnur/mgKfooahB5ZKMQueahOWFg+e0oOeahOS6pOmbhuW5tuWtmOWFpeWbnmFcclxuZnVuY3Rpb24gaW50ZXJzZWN0X3RydWUobGlzdCwgYkxpc3QpIHtcclxuICAgIGxldCBwID0gbGlzdC5oZWFkO1xyXG4gICAgbGV0IHEgPSBiTGlzdC5oZWFkO1xyXG4gICAgbGV0IHBjID0gbGlzdC5oZWFkO1xyXG5cclxuICAgIHdoaWxlIChwICYmIHEpIHtcclxuICAgICAgICBpZiAocC5kYXRhIDwgcS5kYXRhKSBwID0gcC5uZXh0O1xyXG4gICAgICAgIGVsc2UgaWYgKHAuZGF0YSA+IHEuZGF0YSkgcSA9IHEubmV4dDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGMuZGF0YSA9IHAuZGF0YTtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgcSA9IHEubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmICghcCB8fCAhcSkge1xyXG4gICAgICAgICAgICAgICAgcGMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnRhaWwgPSBwYztcclxuICAgICAgICAgICAgfSBlbHNlIHBjID0gcGMubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGMubmV4dCA9IG51bGw7XHJcbiAgICBsaXN0LnRhaWwgPSBwYztcclxufVxyXG5cclxuLy8gYe+8jGLvvIxj55qE5YWD57Sg5Z2H5piv6Z2e6YCS5YeP5o6S5YiXXHJcbi8vIOaxgmHpk77ooajkuK3pnZ5i6ZO+6KGo5ZKMY+mTvuihqOeahOS6pOmbhueahOWFg+e0oOOAglxyXG5mdW5jdGlvbiBpbnRlcnNlY3RfZGVsZXRlKGxpc3QsIGIsIGMpIHtcclxuICAgIGxldCBwID0gYi5oZWFkO1xyXG4gICAgbGV0IHEgPSBjLmhlYWQ7XHJcbiAgICBsZXQgciA9IGxpc3QuaGVhZDtcclxuXHJcbiAgICB3aGlsZSAocCAmJiBxICYmIHIpIHtcclxuICAgICAgICBpZiAocC5kYXRhIDwgcS5kYXRhKSBwID0gcC5uZXh0O1xyXG4gICAgICAgIGVsc2UgaWYgKHAuZGF0YSA+IHEuZGF0YSkgcSA9IHEubmV4dDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g56Gu5a6a5b6F5Yig6Zmk5YWD57SgXHJcbiAgICAgICAgICAgIGxldCBlbGVtID0gcC5kYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIuZGF0YSA9PT0gZWxlbSAmJiByID09PSBsaXN0LmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g56Gu5a6a5pyA5ZCO5LiA5Liq5bCP5LqOZWxlbeeahOWFg+e0oOaMh+mSiFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHIubmV4dCAmJiByLm5leHQuZGF0YSA8IGVsZW0pIHIgPSByLm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHIubmV4dC5kYXRhID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSByLm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOehruWumuesrOS4gOS4quWkp+S6jmVsZW3nmoTlhYPntKDmjIfpkohcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocyAmJiBzLmRhdGEgPT09IGVsZW0pIHMgPSBzLm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6ZmkcuWSjHPkuYvpl7TnmoTlhYPntKBcclxuICAgICAgICAgICAgICAgICAgICByLm5leHQgPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgPT09IGVsZW0pIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChxICYmIHEuZGF0YSA9PT0gZWxlbSkgcSA9IHEubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdC50YWlsID0gcjtcclxufVxyXG5cclxudmFyIGxpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5saXN0LnB1c2goJ2InKTtcclxubGlzdC51bnNoaWZ0KCdhJyk7XHJcbmxpc3QuaW5zZXJ0QWZ0ZXIoJ2InLCAnYycpO1xyXG5jb25zb2xlLmxvZyhsaXN0Lml0ZW0oMikpO1xyXG5jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShsaXN0KSk7XHJcbmxpc3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgaWYgKG5vZGUuZGF0YSA9PT0gJ2InKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2dldCBiIGluIGVhY2gnKTtcclxuICAgIH1cclxufSk7XHJcbmxpc3QucmVtb3ZlKCdjJyk7XHJcbmxpc3QucmVtb3ZlKCdhJyk7XHJcbmNvbnNvbGUubG9nKGxpc3QpO1xyXG5cclxubGV0IGxpc3QyID0gbmV3IExpbmtlZExpc3QoKTtcclxubGlzdDIucHVzaCgnYycpO1xyXG5saXN0Mi51bnNoaWZ0KCdkJyk7XHJcbmxpc3QyLmluc2VydEFmdGVyKCdkJywgJ2InKTtcclxuY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobGlzdDIpKTtcclxuXHJcbmxldCBsaXN0MyA9IExpbmtlZExpc3QubWVyZ2VMaXN0KGxpc3QsIGxpc3QyKTtcclxuY29uc29sZS5sb2cobGlzdDMpO1xyXG5cclxuXHJcbnZhciBsaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxuXHJcbmxpc3Qub3JkZXJJbnNlcnQoNSk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoMik7XHJcbmxpc3Qub3JkZXJJbnNlcnQoMyk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoMSk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNCk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNCk7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNik7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNik7XHJcbmxpc3Qub3JkZXJJbnNlcnQoNyk7XHJcblxyXG5saXN0LmRlbGV0ZV9iZXR3ZWVuKDUsIDgpO1xyXG5jb25zb2xlLmxvZygnZGVsZXRlLWJldHdlZW46ICAnKTtcclxuY29uc29sZS5sb2cobGlzdCk7XHJcblxyXG5saXN0Lm9yZGVySW5zZXJ0KDIpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDMpO1xyXG5saXN0Lm9yZGVySW5zZXJ0KDEpO1xyXG5cclxubGlzdC5kZWxldGVfZXF1YWwoKTtcclxuY29uc29sZS5sb2cobGlzdCk7XHJcblxyXG5saXN0LnJldmVyc2UoKTtcclxuY29uc29sZS5sb2cobGlzdCk7XHJcblxyXG5sZXQgYSA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbmEub3JkZXJJbnNlcnQoMSk7XHJcbmEub3JkZXJJbnNlcnQoMyk7XHJcbmEub3JkZXJJbnNlcnQoNSk7XHJcbmEub3JkZXJJbnNlcnQoNyk7XHJcbmEub3JkZXJJbnNlcnQoOSk7XHJcblxyXG5sZXQgYiA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbmIub3JkZXJJbnNlcnQoMSk7XHJcbmIub3JkZXJJbnNlcnQoNSk7XHJcbmIub3JkZXJJbnNlcnQoOSk7XHJcbmIub3JkZXJJbnNlcnQoMTMpO1xyXG5iLm9yZGVySW5zZXJ0KDE3KTtcclxuY29uc29sZS5sb2coaW50ZXJzZWN0KGEsIGIpKTtcclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdF90cnVlKGEsIGIpKTtcclxuXHJcbmEgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG5hLm9yZGVySW5zZXJ0KDEpO1xyXG5hLm9yZGVySW5zZXJ0KDMpO1xyXG5hLm9yZGVySW5zZXJ0KDUpO1xyXG5hLm9yZGVySW5zZXJ0KDcpO1xyXG5hLm9yZGVySW5zZXJ0KDkpO1xyXG5cclxubGV0IHRlc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDEpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDIpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDMpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDQpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDUpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDYpO1xyXG50ZXN0Lm9yZGVySW5zZXJ0KDkpO1xyXG5cclxuaW50ZXJzZWN0X2RlbGV0ZSh0ZXN0LCBhLCBiKTtcclxuY29uc29sZS5sb2codGVzdCk7XHJcblxyXG52YXIgcG9wVGVzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbnBvcFRlc3QucHVzaCgxKTtcclxucG9wVGVzdC5wdXNoKDIpO1xyXG5wb3BUZXN0LnBvcCgpO1xyXG5wb3BUZXN0LnBvcCgpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9MaXN0L0xpbmtlZExpc3QuanNcbiAqKi8iLCIvLyDpnZnmgIHljZXpk77ooahcclxuLypcclxuIOacieaXtuWPr+WAn+eUqOS4gOe7tOaVsOe7hOadpeaPj+i/sOe6v+aAp+mTvuihqO+8jOi/meWwseaYr+e6v+aAp+ihqOeahOmdmeaAgeWNlemTvuihqOWtmOWCqOe7k+aehOOAglxyXG4g5Zyo6Z2Z5oCB6ZO+6KGo5Lit77yM5pWw57uE55qE5LiA5Liq5YiG6YeP6KGo56S65LiA5Liq57uT54K577yM5ZCM5pe255So5ri45qCH77yIY3Vy77yJ5Luj5pu/5oyH6ZKI5oyH56S657uT54K55Zyo5pWw57uE5Lit55qE55u45a+55L2N572u44CCXHJcbiDmlbDnu4TnmoTnrKww5YiG6YeP5Y+v55yL5oiQ5aS057uT54K577yM5YW25oyH6ZKI5Z+f5oyH56S66ZO+6KGo55qE56ys5LiA5Liq57uT54K544CCXHJcbiDov5nnp43lrZjlgqjnu5PmnoTpnIDopoHpooTlhYjliIbphY3kuIDkuKrovoPlpKfnmoTnqbrpl7TvvIzkvYblnKjnur/mgKfooajnmoTmj5LlhaXlkozliKDpmaTmk43kvZzml7bkuI3pnIDnp7vliqjlhYPntKDvvIxcclxuIOS7hemcgOimgeS/ruaUueaMh+mSiO+8jOaVheS7jeWFt+aciemTvuW8j+WtmOWCqOe7k+aehOeahOS4u+imgeS8mOeCuVxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY0xpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoTUFYU0laRSkge1xyXG4gICAgICAgIHRoaXNbLTFdID0ge2N1cjogMH07XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuTUFYU0laRSA9IE1BWFNJWkUgKyAxIHx8IDEwMDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjpnZnmgIHljZXpk77nur/mgKfooahM5Lit5p+l5om+56ysMeS4quWAvOS4umXnmoTlhYPntKDvvIxcclxuICAgICAqIOiLpeaJvuWIsO+8jOWImei/lOWbnuWug+WcqEzkuK3nmoTkvY3luo9cclxuICAgICAqIEBwYXJhbSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGZpbmQgKGRhdGEpIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXNbMF0uY3VyO1xyXG4gICAgICAgIHdoaWxlIChpICYmIHRoaXNbaV0uZGF0YSAhPT0gZGF0YSkge1xyXG4gICAgICAgICAgICBpID0gdGhpc1tpXS5jdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIbkuIDnu7TmlbDnu4TkuK3lkITliIbph4/pk77miJDkuIDkuKrlpIfnlKjpk77ooahcclxuICAgICAqIHRoaXNbMF0uY3Vy5Li65aS05oyH6ZKIXHJcbiAgICAgKi9cclxuICAgIGluaXQgKGxlbikge1xyXG4gICAgICAgIGxlbiA9IGxlbiA/IGxlbiArIDEgOiB0aGlzLk1BWFNJWkU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpc1tpXSA9IHRoaXNbaV0gfHwge2RhdGE6IG51bGwsIGN1cjogbnVsbH07XHJcbiAgICAgICAgICAgIHRoaXNbaV0uY3VyID0gaSArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzW2xlbiAtIDFdID0gdGhpc1tsZW4gLSAxXSB8fCB7fTtcclxuICAgICAgICB0aGlzW2xlbiAtIDFdLmN1ciA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOiLpeWkh+eUqOmTvuihqOmdnuepuu+8jOWImei/lOWbnuWIhumFjeeahOe7k+eCueS4i+agh++8jOWPjeWImei/lOWbnjBcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBtYWxsb2MgKCkge1xyXG4gICAgICAgIGxldCBpID0gdGhpc1stMV0uY3VyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1stMV0uY3VyICE9PSAndW5kZWZpbmVkJykgdGhpc1stMV0uY3VyID0gdGhpc1tpXS5jdXI7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWwhuS4i+agh+S4umvnmoTnqbrpl7Lnu5Pngrnlm57mlLbliLDlpIfnlKjpk77ooahcclxuICAgICAqIEBwYXJhbSBrXHJcbiAgICAgKi9cclxuICAgIGZyZWUgKGspIHtcclxuICAgICAgICB0aGlzW2tdLmN1ciA9IHRoaXNbMF0uY3VyO1xyXG4gICAgICAgIHRoaXNbMF0uY3VyID0gaztcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGUgKHNxTGlzdCkge1xyXG4gICAgICAgIC8vIOWIneWni+WMluWkh+eUqOepuumXtFxyXG4gICAgICAgIHRoaXMuaW5pdChzcUxpc3QubGVuZ3RoKTtcclxuICAgICAgICAvLyDnlJ/miJBz55qE5aS057uT54K5XHJcbiAgICAgICAgbGV0IHMgPSB0aGlzLm1hbGxvYygpO1xyXG4gICAgICAgIC8vIHLmjIflkJFz55qE5b2T5YmN5pyA5ZCO57uT54K5XHJcbiAgICAgICAgbGV0IHIgPSBzO1xyXG4gICAgICAgIGxldCBtID0gc3FMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8g5bu656uL6ZuG5ZCIQeeahOmTvuihqFxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgICAgICAgIC8v5YiG6YWN57uT54K5XHJcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5tYWxsb2MoKTtcclxuICAgICAgICAgICAgLy8g6L6T5YWlQeWFg+e0oOeahOWAvFxyXG4gICAgICAgICAgICB0aGlzW2ldLmRhdGEgPSBzcUxpc3Rbal07XHJcbiAgICAgICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxyXG4gICAgICAgICAgICB0aGlzW3JdLmN1ciA9IGk7XHJcbiAgICAgICAgICAgICsrdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHIgPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlsL7nu5PngrnnmoTmjIfpkojkuLrnqbpcclxuICAgICAgICB0aGlzW3JdLmN1ciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdG9kb1xyXG4gICAgYWRkIChpbmRleCwgZWxlbSkge1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZSAoaW5kZXgpIHtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOWcqOS4gOe7tOaVsOe7hOS4reW7uueri+ihqOekuumbhuWQiChBLUIpVShCLUEpXHJcbiAqIOeahOmdmeaAgemTvuihqO+8jHPkuLrlhbblpLTmjIfpkojjgIJcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5mdW5jdGlvbiBkaWZmZXJlbmNlKHNsbGlzdCwgYXJyMSwgYXJyMikge1xyXG4gICAgLy8g5Yid5aeL5YyW5aSH55So56m66Ze0XHJcbiAgICBzbGxpc3QuaW5pdCgpO1xyXG4gICAgLy8g55Sf5oiQc+eahOWktOe7k+eCuVxyXG4gICAgbGV0IHMgPSBzbGxpc3QubWFsbG9jKCk7XHJcbiAgICAvLyBy5oyH5ZCRc+eahOW9k+WJjeacgOWQjue7k+eCuVxyXG4gICAgbGV0IHIgPSBzO1xyXG4gICAgLy8g5Yig6ZmkQeWSjELnmoTlhYPntKDkuKrmlbBcclxuICAgIGxldCBtID0gYXJyMS5sZW5ndGg7XHJcbiAgICBsZXQgbiA9IGFycjIubGVuZ3RoO1xyXG5cclxuICAgIC8vIOW7uueri+mbhuWQiEHnmoTpk77ooahcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgICAgLy/liIbphY3nu5PngrlcclxuICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcclxuICAgICAgICAvLyDovpPlhaVB5YWD57Sg55qE5YC8XHJcbiAgICAgICAgc2xsaXN0W2ldLmRhdGEgPSBhcnIxW2pdO1xyXG4gICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxyXG4gICAgICAgIHNsbGlzdFtyXS5jdXIgPSBpO1xyXG4gICAgICAgIHIgPSBpO1xyXG4gICAgfVxyXG4gICAgLy8g5bC+57uT54K555qE5oyH6ZKI5Li656m6XHJcbiAgICBzbGxpc3Rbcl0uY3VyID0gMDtcclxuXHJcbiAgICAvLyDkvp3mrKHovpPlhaVC55qE5YWD57Sg77yM6Iul5LiN5Zyo5b2T5YmN6KGo5Lit77yM5YiZ5o+S5YWl77yMXHJcbiAgICAvLyDlkKbliJnliKDpmaRcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XHJcbiAgICAgICAgbGV0IGIgPSBhcnIyW2pdO1xyXG4gICAgICAgIGxldCBwID0gcztcclxuICAgICAgICAvLyBr5oyH5ZCR6ZuG5ZCI5Lit55qE56ys5LiA5Liq57uT54K5XHJcbiAgICAgICAgbGV0IGsgPSBzbGxpc3Rbc10uY3VyO1xyXG4gICAgICAgIC8vIOWcqOW9k+WJjeihqOS4reafpeaJvlxyXG4gICAgICAgIHdoaWxlIChrICE9PSBzbGxpc3Rbcl0uY3VyICYmIHNsbGlzdFtrXS5kYXRhICE9PSBiKSB7XHJcbiAgICAgICAgICAgIHAgPSBrO1xyXG4gICAgICAgICAgICBrID0gc2xsaXN0W2tdLmN1cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5b2T5YmN6KGo5Lit5LiN5a2Y5Zyo6K+l5YWD57Sg77yM5o+S5YWl5ZyocuaJgOaMh+e7k+eCueS5i+WQju+8jOS4lHLnmoTkvY3nva7kuI3lj5hcclxuICAgICAgICBpZiAoayA9PT0gc2xsaXN0W3JdLmN1cikge1xyXG4gICAgICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcclxuICAgICAgICAgICAgc2xsaXN0W2ldLmRhdGEgPSBiO1xyXG4gICAgICAgICAgICBzbGxpc3RbaV0uY3VyID0gc2xsaXN0W3JdLmN1cjtcclxuICAgICAgICAgICAgc2xsaXN0W3JdLmN1ciA9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyDor6XlhYPntKDlt7LlnKjooajkuK3vvIzliKDpmaTkuYtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzbGxpc3RbcF0uY3VyID0gc2xsaXN0W2tdLmN1cjtcclxuICAgICAgICAgICAgc2xsaXN0LmZyZWUoayk7XHJcbiAgICAgICAgICAgIC8vIOiLpeWIoOmZpOeahOaYr3LmiYDmjIfnu5PngrnvvIzliJnpnIDkv67mlLnlsL7mjIfpkohcclxuICAgICAgICAgICAgaWYgKHIgPT09IGspIHIgPSBwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubGV0IHNsID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoMTApO1xyXG5sZXQgcmV0ID0gZGlmZmVyZW5jZShzbCwgWzEsIDIsIDNdLCBbMywgNCwgNV0pO1xyXG5jb25zb2xlLmxvZyhzbCk7XHJcblxyXG5cclxubGV0IHRlc3QgPSBuZXcgU3RhdGljTGlua2VkTGlzdCgxMCk7XHJcbnRlc3QuY3JlYXRlKFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDldKTtcclxuY29uc29sZS5sb2codGVzdCk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvTGlzdC9TdGF0aWNMaW5rZWRMaXN0LmpzXG4gKiovIiwiLypcclxuIOWKqOaAgeafpeaJvlxyXG5cclxuIOW9k+afpeaJvuihqOS7pee6v+aAp+ihqOeahOW9ouW8j+e7hOe7h+aXtu+8jOiLpeWvueafpeaJvuihqOi/m+ihjOaPkuWFpeOAgeWIoOmZpOaIluaOkuW6j+aTjeS9nO+8jOWwseW/hemhu+enu+WKqOWkp+mHj+eahOiusOW9le+8jOW9k+iusOW9leaVsOW+iOWkmuaXtu+8jOi/meenjeenu+WKqOeahOS7o+S7t+W+iOWkp+OAglxyXG4g5Yip55So5qCR55qE5b2i5byP57uE57uH5p+l5om+6KGo77yM5Y+v5Lul5a+55p+l5om+6KGo6L+b6KGM5Yqo5oCB6auY5pWI55qE5p+l5om+44CCXHJcblxyXG5cclxuIOS6jOWPieaOkuW6j+agkShCU1Qp55qE5a6a5LmJXHJcblxyXG4g5LqM5Y+J5o6S5bqP5qCRKEJpbmFyeSBTb3J0IFRyZWXmiJZCaW5hcnkgU2VhcmNoIFRyZWUpIOeahOWumuS5ieS4uu+8muS6jOWPieaOkuW6j+agkeaIluiAheaYr+epuuagke+8jOaIluiAheaYr+a7oei2s+S4i+WIl+aAp+i0qOeahOS6jOWPieagkeOAglxyXG4gKDEpIO+8muiLpeW3puWtkOagkeS4jeS4uuepuu+8jOWImeW3puWtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95bCP5LqO5qC557uT54K555qE5YC877ybXHJcbiAoMikg77ya6Iul5Y+z5a2Q5qCR5LiN5Li656m677yM5YiZ5Y+z5a2Q5qCR5LiK5omA5pyJ57uT54K555qE5YC8KOWFs+mUruWtlynpg73lpKfkuo7moLnnu5PngrnnmoTlgLzvvJtcclxuICgzKSDvvJrlt6bjgIHlj7PlrZDmoJHpg73liIbliKvmmK/kuozlj4nmjpLluo/moJHjgIJcclxuIOe7k+iuuu+8muiLpeaMieS4reW6j+mBjeWOhuS4gOajteS6jOWPieaOkuW6j+agke+8jOaJgOW+l+WIsOeahOe7k+eCueW6j+WIl+aYr+S4gOS4qumAkuWinuW6j+WIl+OAglxyXG5cclxuXHJcbiBCU1TmoJHnmoTmn6Xmib5cclxuIDEgIOafpeaJvuaAneaDs1xyXG4g6aaW5YWI5bCG57uZ5a6a55qES+WAvOS4juS6jOWPieaOkuW6j+agkeeahOaguee7k+eCueeahOWFs+mUruWtl+i/m+ihjOavlOi+g++8muiLpeebuOetie+8miDliJnmn6Xmib7miJDlip/vvJtcclxuIOKRoCDnu5nlrprnmoRL5YC85bCP5LqOQlNU55qE5qC557uT54K555qE5YWz6ZSu5a2X77ya57un57ut5Zyo6K+l57uT54K555qE5bem5a2Q5qCR5LiK6L+b6KGM5p+l5om+77ybXHJcbiDikaEg57uZ5a6a55qES+WAvOWkp+S6jkJTVOeahOaguee7k+eCueeahOWFs+mUruWtl++8mue7p+e7reWcqOivpee7k+eCueeahOWPs+WtkOagkeS4iui/m+ihjOafpeaJvuOAglxyXG5cclxuIOWcqOmaj+acuuaDheWGteS4i++8jOS6jOWPieaOkuW6j+agkeeahOW5s+Wdh+afpeaJvumVv+W6pkFTTOWSjOOPkihuKSjmoJHnmoTmt7HluqYp5piv562J5pWw6YeP57qn55qE44CCXHJcblxyXG5cclxuIEJTVOagkeeahOaPkuWFpVxyXG5cclxuIOWcqEJTVOagkeS4reaPkuWFpeS4gOS4quaWsOe7k+eCue+8jOimgeS/neivgeaPkuWFpeWQjuS7jea7oei2s0JTVOeahOaAp+i0qOOAglxyXG5cclxuIDEg5o+S5YWl5oCd5oOzXHJcbiDlnKhCU1TmoJHkuK3mj5LlhaXkuIDkuKrmlrDnu5Pngrl45pe277yM6IulQlNU5qCR5Li656m677yM5YiZ5Luk5paw57uT54K5eOS4uuaPkuWFpeWQjkJTVOagkeeahOaguee7k+eCue+8m+WQpuWIme+8jOWwhue7k+eCuXjnmoTlhbPplK7lrZfkuI7moLnnu5PngrlU55qE5YWz6ZSu5a2X6L+b6KGM5q+U6L6D77yaXHJcbiDikaAg6Iul55u4562J77yaIOS4jemcgOimgeaPkuWFpe+8m1xyXG4g4pGhICDoi6V4LmtleTxULT5rZXnvvJrnu5Pngrl45o+S5YWl5YiwVOeahOW3puWtkOagkeS4re+8m1xyXG4g4pGiICDoi6V4LmtleT5ULT5rZXnvvJrnu5Pngrl45o+S5YWl5YiwVOeahOWPs+WtkOagkeS4reOAglxyXG5cclxuIOeUsee7k+iuuuefpe+8jOWvueS6juS4gOS4quaXoOW6j+W6j+WIl+WPr+S7pemAmui/h+aehOmAoOS4gOajtUJTVOagkeiAjOWPmOaIkOS4gOS4quacieW6j+W6j+WIl+OAglxyXG4g55Sx566X5rOV55+l77yM5q+P5qyh5o+S5YWl55qE5paw57uT54K56YO95pivQlNU5qCR55qE5Y+25a2Q57uT54K577yM5Y2z5Zyo5o+S5YWl5pe25LiN5b+F56e75Yqo5YW25a6D57uT54K577yM5LuF6ZyA5L+u5pS55p+Q5Liq57uT54K555qE5oyH6ZKI44CCXHJcblxyXG5cclxuIEJTVOagkeeahOWIoOmZpFxyXG5cclxuIDEgIOWIoOmZpOaTjeS9nOi/h+eoi+WIhuaekFxyXG4g5LuOQlNU5qCR5LiK5Yig6Zmk5LiA5Liq57uT54K577yM5LuN54S26KaB5L+d6K+B5Yig6Zmk5ZCO5ruh6LazQlNU55qE5oCn6LSo44CC6K6+6KKr5Yig6Zmk57uT54K55Li6cO+8jOWFtueItue7k+eCueS4umYg77yM5Yig6Zmk5oOF5Ya15aaC5LiL77yaXHJcbiDikaAgIOiLpXDmmK/lj7blrZDnu5PngrnvvJog55u05o6l5Yig6ZmkcOOAglxyXG4g4pGhICDoi6Vw5Y+q5pyJ5LiA5qO15a2Q5qCRKOW3puWtkOagkeaIluWPs+WtkOagkSnvvJrnm7TmjqXnlKhw55qE5bem5a2Q5qCRKOaIluWPs+WtkOagkSnlj5bku6Nw55qE5L2N572u6ICM5oiQ5Li6ZueahOS4gOajteWtkOagkeOAguWNs+WOn+adpXDmmK9m55qE5bem5a2Q5qCR77yM5YiZcOeahOWtkOagkeaIkOS4umbnmoTlt6blrZDmoJHvvJvljp/mnaVw5pivZueahOWPs+WtkOagke+8jOWImXDnmoTlrZDmoJHmiJDkuLpm55qE5Y+z5a2Q5qCR44CCXHJcbiDikaIg6IulcOaXouacieW3puWtkOagkeWPiOacieWPs+WtkOagkSDvvJrlpITnkIbmlrnms5XmnInku6XkuIvkuKTnp43vvIzlj6/ku6Xku7vpgInlhbbkuK3kuIDnp43jgIJcclxuIOKXhiAg55SocOeahOebtOaOpeWJjempsee7k+eCueS7o+abv3DjgILljbPku45w55qE5bem5a2Q5qCR5Lit6YCJ5oup5YC85pyA5aSn55qE57uT54K5c+aUvuWcqHDnmoTkvY3nva4o55So57uT54K5c+eahOWGheWuueabv+aNoue7k+eCuXDlhoXlrrkp77yM54S25ZCO5Yig6Zmk57uT54K5c+OAgnPmmK9w55qE5bem5a2Q5qCR5Lit55qE5pyA5Y+z6L6555qE57uT54K55LiU5rKh5pyJ5Y+z5a2Q5qCR77yM5a+5c+eahOWIoOmZpOWQjOKRoeOAglxyXG4g4peGIOeUqHDnmoTnm7TmjqXlkI7nu6fnu5Pngrnku6Pmm79w44CC5Y2z5LuOcOeahOWPs+WtkOagkeS4remAieaLqeWAvOacgOWwj+eahOe7k+eCuXPmlL7lnKhw55qE5L2N572uKOeUqOe7k+eCuXPnmoTlhoXlrrnmm7/mjaLnu5Pngrlw5YaF5a65Ke+8jOeEtuWQjuWIoOmZpOe7k+eCuXPjgIJz5pivcOeahOWPs+WtkOagkeS4reeahOacgOW3pui+ueeahOe7k+eCueS4lOayoeacieW3puWtkOagke+8jOWvuXPnmoTliKDpmaTlkIzikaHjgIJcclxuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQmluYXJ5VHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCU1ROb2RlIGV4dGVuZHMgQmluYXJ5VHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvciguLi5hcmcpIHtcclxuICAgICAgICBzdXBlciguLi5hcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQlNU5qCR55qE5p+l5om+77yI6YCS5b2S77yJXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHNlYXJjaChrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSA9PT0ga2V5KSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IDwgdGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdENoaWxkLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodENoaWxkLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJTVOagkeeahOafpeaJvu+8iOmdnumAkuW9ku+8iVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBzZWFyY2hOb25SZWN1cnNpdmUoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChwICYmIHAuZGF0YSAhPT0ga2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgZWxzZSBwID0gcC5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFwIHx8IGtleSAhPT0gcC5kYXRhKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBlbHNlIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQlNU5qCR55qE5o+S5YWl77yI6YCS5b2S77yJXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGtleTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLmRhdGEpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgQlNUTm9kZShrZXkpO1xyXG4gICAgICAgIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZC5pbnNlcnQoa2V5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5yaWdodENoaWxkLmluc2VydChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmdnumAkuW9ku+8iVxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0Tm9uUmVjdXJzaXZlKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwID0gdGhpcztcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICBpZiAocC5kYXRhID09PSBrZXkpIHJldHVybjtcclxuICAgICAgICAgICAgLy8gceS9nOS4unDnmoTniLboioLngrlcclxuICAgICAgICAgICAgcSA9IHA7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgZWxzZSBwID0gcC5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgQlNUTm9kZShrZXkpO1xyXG4gICAgICAgIGlmIChrZXkgPCBxLmRhdGEpIHEubGVmdENoaWxkID0gbm9kZTtcclxuICAgICAgICBlbHNlIHEucmlnaHRDaGlsZCA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKnnlKhCU1TmoJHnmoTmj5LlhaXmk43kvZzlu7rnq4vkuIDmo7VCU1TmoJFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufHVuZGVmaW5lZH0gdXNlTm9uUmVjdXJzaXZlIOaYr+WQpuS9v+eUqOmdnumAkuW9klxyXG4gICAgICovXHJcbiAgICBjcmVhdGVCU1QoYXJyLCB1c2VOb25SZWN1cnNpdmUpIHtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBpZiAodXNlTm9uUmVjdXJzaXZlKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vblJlY3Vyc2l2ZShhcnJbaV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChhcnJbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDkvb/nlKjpgJLlvZLnmoTmlrnms5XliKDpmaTkuI7lhbPplK7lrZfnrKblkIjnmoTnu5PngrlcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IOmcgOimgeafpeaJvueahOWFs+mUruWtl1xyXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg54i26IqC54K577yM5YaF6YOo6LCD55So6ZyA6KaB55So5YiwXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgcGFyZW50KSB7XHJcbiAgICAgICAgLy8g56m657uT54K555qE5oOF5Ya1XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIOaJvuWIsOWFs+mUruWtl1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIGRlbGV0ZU5vZGUodGhpcywgcGFyZW50KTtcclxuICAgICAgICAvLyDmn6Xmib7lt6blrZDmoJHvvIzlpoLmnpzmnInnmoTor51cclxuICAgICAgICBlbHNlIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSByZXR1cm4gdGhpcy5sZWZ0Q2hpbGQucmVtb3ZlKGtleSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOafpeaJvuWPs+WtkOagke+8jOWmguaenOacieeahOivnVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSByZXR1cm4gdGhpcy5yaWdodENoaWxkLnJlbW92ZShrZXksIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pyq5om+5YiwXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6Z2e6YCS5b2S5Yig6Zmk5LiO5YWz6ZSu5a2X56ym5ZCI55qE57uT54K5XHJcbiAgICAgKiBAcGFyYW0geyp9IGtleSDpnIDopoHmn6Xmib7nmoTlhbPplK7lrZdcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICByZW1vdmVOb25SZWN1cnNpdmUoa2V5KSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xyXG4gICAgICAgIGxldCBmO1xyXG5cclxuICAgICAgICB3aGlsZSAocCAmJiBwLmRhdGEgIT09IGtleSkge1xyXG4gICAgICAgICAgICBmID0gcDtcclxuICAgICAgICAgICAgaWYgKGtleSA8IHAuZGF0YSkgcCA9IHAubGVmdENoaWxkO1xyXG4gICAgICAgICAgICBlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDmsqHmnInopoHliKDpmaTnmoTnu5PngrlcclxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8g5om+5Yiw5LqG6KaB5Yig6Zmk55qE57uT54K5cFxyXG4gICAgICAgIGxldCBzID0gcDtcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICAvLyDlpoLmnpzmnInlt6blj7PlrZDmoJFcclxuICAgICAgICBpZiAocC5sZWZ0Q2hpbGQgJiYgcC5yaWdodENoaWxkKSB7XHJcbiAgICAgICAgICAgIGYgPSBwO1xyXG4gICAgICAgICAgICBzID0gcC5sZWZ0Q2hpbGQ7XHJcblxyXG4gICAgICAgICAgICAvLyDmib7liLDlt6blrZDmoJHnmoTmnIDlpKflj7PlrZDmoJHvvIzljbPku4XlsI/kuo7lt6blrZDmoJHnmoTlgLznmoTnu5PngrlcclxuICAgICAgICAgICAgd2hpbGUgKHMucmlnaHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgZiA9IHM7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDoi6Vz5pyJ5bem5a2Q5qCR77yM5Y+z5a2Q5qCR5Li656m6XHJcbiAgICAgICAgaWYgKHMubGVmdENoaWxkKSBxID0gcy5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgZWxzZSBxID0gcy5yaWdodENoaWxkO1xyXG5cclxuICAgICAgICAvLyDlj6rmnInkuIDkuKrmoLnnu5PngrnnmoTmg4XlhrVcclxuICAgICAgICBpZiAoIWYpIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZWxzZSBpZiAoZi5sZWZ0Q2hpbGQgPT0gcykgZi5sZWZ0Q2hpbGQgPSBxO1xyXG4gICAgICAgIGVsc2UgZi5yaWdodENoaWxkID0gcTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmib7liLDlsI/kuo5455qE5pyA5aSn5YWD57Sg5ZKM5aSn5LqOeOeahOacgOWwj+WFg+e0oFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFttaW4sIG1heF1cclxuICAgICAqL1xyXG4gICAgZmluZE5laWdoYm9yRWxlbSh4KSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0eXBlb2YgdGhpcy5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcclxuICAgICAgICBsZXQgcmV0ID0gW107XHJcblxyXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gcmVjdXJzZSh0cmVlLCB4KSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgcmVjdXJzZSh0cmVlLmxlZnRDaGlsZCwgeCk7XHJcbiAgICAgICAgICAgIGlmIChsYXN0IDwgeCAmJiB0cmVlLmRhdGEgPj0geCkgcmV0WzBdID0gbGFzdDtcclxuICAgICAgICAgICAgaWYgKGxhc3QgPD0geCAmJiB0cmVlLmRhdGEgPiB4KSByZXRbMV0gPSB0cmVlLmRhdGE7XHJcbiAgICAgICAgICAgIGxhc3QgPSB0cmVlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCB4KTtcclxuICAgICAgICB9KHRoaXMsIHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5oqK5LqM5Y+J5o6S5bqP5qCRYnN05ZCI5bm25Yiw6K+l5qCR5LitXHJcbiAgICAgKiBAcGFyYW0ge0JTVE5vZGV9IGJzdFxyXG4gICAgICovXHJcbiAgICBtZXJnZShic3QpIHtcclxuICAgICAgICBpZiAoYnN0LmxlZnRDaGlsZCkgdGhpcy5tZXJnZShic3QubGVmdENoaWxkKTtcclxuICAgICAgICBpZiAoYnN0LnJpZ2h0Q2hpbGQpIHRoaXMubWVyZ2UoYnN0LnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0KGJzdC5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaKiue7k+eCueaPkuWFpeWIsOWQiOmAguS9jee9rlxyXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBub2RlIOW+heaPkuWFpeeahOe7k+eCuVxyXG4gICAgICovXHJcbiAgICBpbnNlcnROb2RlKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZS5kYXRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPiB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLnJpZ2h0Q2hpbGQuaW5zZXJ0Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmRhdGEgPCB0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5sZWZ0Q2hpbGQuaW5zZXJ0Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbm9kZS5sZWZ0Q2hpbGQgPSBub2RlLnJpZ2h0Q2hpbGQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YiG6KOC5Li65Lik5qO15LqM5Y+J5o6S5bqP5qCRXHJcbiAgICAgKiBAcGFyYW0geyp9IHhcclxuICAgICAqIEByZXR1cm5zIHtCU1ROb2RlW2EsIGJdfSBh55qE5YWD57Sg5YWo6YOo5bCP5LqO562J5LqOeO+8jGLnmoTlhYPntKDlhajpg6jlpKfkuo54XHJcbiAgICAgKi9cclxuICAgIHNwbGl0KHgpIHtcclxuICAgICAgICBsZXQgYSA9IG5ldyBCU1ROb2RlKCk7XHJcbiAgICAgICAgbGV0IGIgPSBuZXcgQlNUTm9kZSgpO1xyXG5cclxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHNwbGl0KHRyZWUsIHgpIHtcclxuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSBzcGxpdCh0cmVlLmxlZnRDaGlsZCwgeCk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHNwbGl0KHRyZWUucmlnaHRDaGlsZCwgeCk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmRhdGEgPD0geCkgYS5pbnNlcnROb2RlKHRyZWUpO1xyXG4gICAgICAgICAgICBlbHNlIGIuaW5zZXJ0Tm9kZSh0cmVlKTtcclxuICAgICAgICB9KHRoaXMsIHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gW2EsIGJdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patdHJlZeaYr+WQpuaYr+S6jOWPieaOkuW6j+agkVxyXG4gICAgICogQHBhcmFtIHRyZWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQlNUVHJlZSh0cmVlKSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0eXBlb2YgdHJlZS5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcclxuICAgICAgICBsZXQgZmxhZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gaXNCU1RUcmVlKHRyZWUpIHtcclxuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkICYmIGZsYWcpIGlzQlNUVHJlZSh0cmVlLmxlZnRDaGlsZCk7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLmRhdGEgPCBsYXN0KSBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxhc3QgPSB0cmVlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQgJiYgZmxhZykgaXNCU1RUcmVlKHRyZWUucmlnaHRDaGlsZCk7XHJcblxyXG4gICAgICAgIH0odHJlZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmbGFnO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICog5Yig6Zmk57uT54K5XHJcbiAqIEBwYXJhbSB7QlNUTm9kZX0gcCDopoHliKDpmaTnmoTnu5PngrlcclxuICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg6KaB5Yig6Zmk55qE57uT54K555qE54i26IqC54K5XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSDov5Tlm57liKDpmaTmiJDlip9cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZU5vZGUocCwgcGFyZW50KSB7XHJcbiAgICAvLyDlj7blrZDnu5PngrnmiJblj6rmnInkuIDkuKrnu5PngrlcclxuICAgIGlmICghcC5sZWZ0Q2hpbGQgJiYgIXAucmlnaHRDaGlsZCkge1xyXG4gICAgICAgIC8vIOW9k+WJjee7k+eCueaYr+WFtueItue7k+eCueeahOW3puWtkOagkei/mOaYr+WPs+WtkOagkVxyXG4gICAgICAgIGxldCBwb3MgPSBwYXJlbnQgJiYgcGFyZW50LmxlZnRDaGlsZCA9PSBwID8gJ2xlZnRDaGlsZCcgOiAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50W3Bvc10gPSBudWxsO1xyXG4gICAgICAgIC8vIOWPquacieS4gOS4que7k+eCueeahOaDheWGtVxyXG4gICAgICAgIGVsc2UgIHAuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyDlj6rmnInlt6blrZDmoJFcclxuICAgIGVsc2UgaWYgKCFwLnJpZ2h0Q2hpbGQpIHtcclxuICAgICAgICBwLmRhdGEgPSBwLmxlZnRDaGlsZC5kYXRhO1xyXG4gICAgICAgIHAubGVmdENoaWxkID0gcC5sZWZ0Q2hpbGQubGVmdENoaWxkO1xyXG4gICAgfVxyXG4gICAgLy8g5Y+q5pyJ5Y+z5a2Q5qCRXHJcbiAgICBlbHNlIGlmICghcC5sZWZ0Q2hpbGQpIHtcclxuICAgICAgICBwLmRhdGEgPSBwLnJpZ2h0Q2hpbGQuZGF0YTtcclxuICAgICAgICBwLnJpZ2h0Q2hpbGQgPSBwLnJpZ2h0Q2hpbGQucmlnaHRDaGlsZDtcclxuICAgIH1cclxuICAgIC8vIOW3puWPs+WtkOagkemDveaciVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHMgPSBwLmxlZnRDaGlsZDtcclxuICAgICAgICAvLyBx5Li654i257uT54K5XHJcbiAgICAgICAgbGV0IHEgPSBwO1xyXG4gICAgICAgIC8vIOaJvuWIsOW3puWtkOagkeeahOacgOWkp+WPs+WtkOagke+8jOWNs+S7heWwj+S6juW3puWtkOagkeeahOWAvOeahOe7k+eCuVxyXG4gICAgICAgIHdoaWxlIChzLnJpZ2h0Q2hpbGQpIHtcclxuICAgICAgICAgICAgcSA9IHM7XHJcbiAgICAgICAgICAgIHMgPSBzLnJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XHJcbiAgICAgICAgaWYgKHEgIT0gcCkgcS5yaWdodENoaWxkID0gcy5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgZWxzZSBxLmxlZnRDaGlsZCA9IHMubGVmdENoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5sZXQgYnN0ID0gbmV3IEJTVE5vZGUoKTtcclxuYnN0LmNyZWF0ZUJTVChbNDUsIDI0LCA1MywgMTIsIDI0LCA5MF0pO1xyXG5jb25zb2xlLmxvZyhic3Quc2VhcmNoKDEyKSk7XHJcbmNvbnNvbGUubG9nKGJzdC5zZWFyY2goMTMpKTtcclxuXHJcbmxldCBic3QyID0gbmV3IEJTVE5vZGUoKTtcclxuYnN0Mi5jcmVhdGVCU1QoWzQ1LCAyNCwgNTMsIDEyLCAyNCwgOTBdLCB0cnVlKTtcclxuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTIpKTtcclxuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTMpKTtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5maW5kU2libGluZ0VsZW06ICcpO1xyXG5jb25zb2xlLmxvZyhic3QuZmluZE5laWdoYm9yRWxlbSgxMikgKyAnJyk7XHJcbmNvbnNvbGUubG9nKGJzdC5maW5kTmVpZ2hib3JFbGVtKDkwKSArICcnKTtcclxuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oNDUpICsgJycpO1xyXG5cclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSg0NSkpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDEpKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSg1MykpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDEyKSk7XHJcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoOTApKTtcclxuY29uc29sZS5sb2coYnN0LnJlbW92ZSgyNCkpO1xyXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDIpKTtcclxuXHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNDUpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgxKSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNTMpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgxMikpO1xyXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDkwKSk7XHJcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMjQpKTtcclxuLy9jb25zb2xlLmxvZyhic3QyLnJlbW92ZU5vblJlY3Vyc2l2ZSgyKSk7XHJcblxyXG5jb25zb2xlLmxvZygnXFxuaXNCU1RUcmVlOiAnKTtcclxuY29uc29sZS5sb2coQlNUTm9kZS5pc0JTVFRyZWUoYnN0KSk7XHJcbi8vY29uc29sZS5sb2coQlNUTm9kZS5pc0JTVFRyZWUoc29zVHJlZSkpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiDku47lpKfliLDlsI/ovpPlh7rkuozlj4nmjpLluo/moJHkuK3miYDmnInkuI3lsI/kuo5455qE5YWD57SgXHJcbiAqIEBwYXJhbSBic3RcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIHByaW50Tm90TGVzc1RoYW4oYnN0LCB4KSB7XHJcbiAgICBpZiAoYnN0LnJpZ2h0Q2hpbGQpIHByaW50Tm90TGVzc1RoYW4oYnN0LnJpZ2h0Q2hpbGQsIHgpO1xyXG4gICAgaWYgKGJzdC5kYXRhIDwgeCkgcmV0dXJuO1xyXG4gICAgY29uc29sZS5sb2coYnN0LmRhdGEpO1xyXG4gICAgaWYgKGJzdC5sZWZ0Q2hpbGQpIHByaW50Tm90TGVzc1RoYW4oYnN0LmxlZnRDaGlsZCwgeCk7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCdcXG5wcmludE5vdExlc3NUaGFuOiAnKTtcclxucHJpbnROb3RMZXNzVGhhbihic3QyLCA5MCk7XHJcbmNvbnNvbGUubG9nKCdcXG4nKTtcclxucHJpbnROb3RMZXNzVGhhbihic3QyLCAxMik7XHJcblxyXG5cclxuYnN0Lm1lcmdlKGJzdDIpO1xyXG5cclxubGV0IGExID0gbmV3IEJTVE5vZGUoNSk7XHJcbmxldCBhMiA9IG5ldyBCU1ROb2RlKDkxKTtcclxuYnN0Mi5pbnNlcnROb2RlKGExKTtcclxuYnN0Mi5pbnNlcnROb2RlKGEyKTtcclxuXHJcbmJzdDIuc3BsaXQoNDUpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TZWFyY2gvQmluYXJ5U29ydGVkVHJlZS5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8yLzIuXHJcbiAqL1xyXG5cclxudmFyIGRlZmF1bHRDb21wYXJlID0gcmVxdWlyZSgnLi4vZGVmYXVsdENvbXBhcmlzaW9uJyk7XHJcblxyXG4vKlxyXG4g5Lqk5o2i5o6S5bqPXHJcblxyXG4g5piv5LiA57G75Z+65LqO5Lqk5o2i55qE5o6S5bqP77yM57O757uf5Zyw5Lqk5o2i5Y+N5bqP55qE6K6w5b2V55qE5YG25a+577yM55u05Yiw5LiN5YaN5pyJ6L+Z5qC355qE5YG25a+55Li65q2i44CC5YW25Lit5pyA5Z+65pys55qE5piv5YaS5rOh5o6S5bqPKEJ1YmJsZSBTb3J0KeOAglxyXG5cclxuIOWGkuazoeaOkuW6j1xyXG4gMSAg5o6S5bqP5oCd5oOzXHJcbiDkvp3mrKHmr5TovoPnm7jpgrvnmoTkuKTkuKrorrDlvZXnmoTlhbPplK7lrZfvvIzoi6XkuKTkuKrorrDlvZXmmK/lj43luo/nmoQo5Y2z5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2X5aSn5LqO5ZCO5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2XKe+8jOWImei/m+ihjOS6pOaNou+8jOebtOWIsOayoeacieWPjeW6j+eahOiusOW9leS4uuatouOAglxyXG4gICAgIOKRoCDpppblhYjlsIZMLT5SWzFd5LiOTC0+UlsyXeeahOWFs+mUruWtl+i/m+ihjOavlOi+g++8jOiLpeS4uuWPjeW6jyhMLT5SWzFd55qE5YWz6ZSu5a2X5aSn5LqOTC0+UlsyXeeahOWFs+mUruWtlynvvIzliJnkuqTmjaLkuKTkuKrorrDlvZXvvJvnhLblkI7mr5TovoNMLT5SWzJd5LiOTC0+UlszXeeahOWFs+mUruWtl++8jOS+neatpOexu+aOqO+8jOebtOWIsEwtPlJbbi0xXeS4jkwtPlJbbl3nmoTlhbPplK7lrZfmr5TovoPlkI7kuLrmraLvvIznp7DkuLrkuIDotp/lhpLms6HmjpLluo/vvIxMLT5SW25d5Li65YWz6ZSu5a2X5pyA5aSn55qE6K6w5b2V44CCXHJcbiAgICAg4pGhICDnhLblkI7ov5vooYznrKzkuozotp/lhpLms6HmjpLluo/vvIzlr7nliY1uLTHkuKrorrDlvZXov5vooYzlkIzmoLfnmoTmk43kvZzjgIJcclxuIOS4gOiIrOWcsO+8jOesrGnotp/lhpLms6HmjpLluo/mmK/lr7lMLT5SWzEg4oCmIG4taSsxXeS4reeahOiusOW9lei/m+ihjOeahO+8jOWboOatpO+8jOiLpeW+heaOkuW6j+eahOiusOW9leaciW7kuKrvvIzliJnopoHnu4/ov4duLTHotp/lhpLms6HmjpLluo/miY3og73kvb/miYDmnInnmoTorrDlvZXmnInluo/jgIJcclxuXHJcbiAyICDmjpLluo/npLrkvotcclxuIOiuvuaciTnkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLoyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXHJcblxyXG4g5Yid5aeL5YWz6ZSu5a2X5bqP5YiXOiAgMjMgICAgMzggICAgIDIyICAgICA0NSAgICAgMjMgICAgIDY3ICAgICAzMSAgICAgMTUgICAgNDFcclxuIOesrOS4gOi2n+aOkuW6j+WQjjogICAgMjMgICAgMjIgICAgIDM4ICAgICAyMyAgICAgNDUgICAgIDMxICAgICAxNSAgICAgNDEgICAgNjdcclxuIOesrOS6jOi2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAzOCAgICAgMzEgICAgIDE1ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOS4iei2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAzMSAgICAgMTUgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOWbm+i2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAxNSAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOS6lOi2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDE1ICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOWFrei2n+aOkuW6j+WQjjogICAgMjIgICAgMTUgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuIOesrOS4g+i2n+aOkuW6j+WQjjogICAgMTUgICAgMjIgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcclxuXHJcbjMu566X5rOV5YiG5p6QXHJcbiDml7bpl7TlpI3mnYLluqZcclxuIOKXhiAg5pyA5aW95oOF5Ya1KOato+W6jynvvJrmr5TovoPmrKHmlbDvvJpuLTHvvJvnp7vliqjmrKHmlbDvvJow77ybXHJcbiDil4YgIOacgOWdj+aDheWGtSjpgIbluo8p77yaXHJcbiDmr5TovoPmrKHmlbDvvJogbiAqIChuIC0gMSkgLyAyXHJcbiDnp7vliqjmrKHmlbDvvJogMypuKihuIC0gMSkgLyAyXHJcblxyXG4g5pWF5pe26Ze05aSN5p2C5bqm77yaVChuKT1PKG7CsilcclxuIOepuumXtOWkjeadguW6pu+8mlMobik9TygxKVxyXG5cclxuICovXHJcblxyXG5mdW5jdGlvbiBidWJibGVTb3J0KHNxTGlzdCwgY29tcCl7XHJcbiAgICBpZihjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIGZvcih2YXIgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSl7XHJcbiAgICAgICAgdmFyIGNoYW5nZSA9IDA7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPD0gbGVuIC0gaTsgKytqKXtcclxuICAgICAgICAgICAgaWYoY29tcChzcUxpc3RbaiArIDFdLCBzcUxpc3Rbal0pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2pdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2pdID0gc3FMaXN0W2ogKyAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighY2hhbmdlKSBicmVhaztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmJ1YmJsZVNvcnQgPSBidWJibGVTb3J0O1xyXG5cclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbmJ1YmJsZVNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coJ2J1YmJsZVNvcnQ6XFxuJyArIGFyciArICcnKTtcclxuXHJcblxyXG4vLyDlhpLms6HmlLnov5sxXHJcbmZ1bmN0aW9uIGJ1YmJsZVNvcnQyKHNxTGlzdCwgY29tcCl7XHJcbiAgICBpZihjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xyXG4gICAgdmFyIGNoYW5nZSA9IGxlbiAtIDE7XHJcblxyXG4gICAgd2hpbGUoY2hhbmdlKXtcclxuICAgICAgICBmb3IodmFyIGMgPSAwLCBpID0gMDsgaSA8IGNoYW5nZTsgKytpKXtcclxuICAgICAgICAgICAgaWYoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICAvLyBj5oyH56S66L+Z5LiA6Laf5YaS5rOh5Lit5Y+R55Sf5Lqk5o2i55qE5YWD57SgXHJcbiAgICAgICAgICAgICAgICBjID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZSA9IGM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5idWJibGVTb3J0MiA9IGJ1YmJsZVNvcnQyO1xyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxuYnViYmxlU29ydDIoYXJyKTtcclxuY29uc29sZS5sb2coJ2J1YmJsZVNvcnQyOlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuLy8g55u46YK75Lik6Laf5Y+N5pa55ZCR6LW35rOh55qE5YaS5rOh5o6S5bqP566X5rOVXHJcbmZ1bmN0aW9uIGNvY2tUYWlsU29ydChzcUxpc3QsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIC8vIOWGkuazoeS4iuS4i+eVjFxyXG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsZW4gLSAxO1xyXG4gICAgdmFyIGNoYW5nZSA9IDE7XHJcbiAgICB2YXIgdGVtcDtcclxuXHJcbiAgICB3aGlsZShsb3cgPCBoaWdoICYmIGNoYW5nZSl7XHJcbiAgICAgICAgY2hhbmdlID0gMDtcclxuXHJcbiAgICAgICAgLy8g5LuO5LiK5ZCR5LiL6LW35rOhXHJcbiAgICAgICAgZm9yKHZhciBpID0gbG93OyBpIDwgaGlnaDsgKytpKXtcclxuICAgICAgICAgICAgaWYoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5L+u5pS55LiK55WMXHJcbiAgICAgICAgLS1oaWdoO1xyXG5cclxuICAgICAgICAvLyDku47kuIvlkJHkuIrotbfms6FcclxuICAgICAgICBmb3IoaSA9IGhpZ2g7IGkgPiBsb3c7IC0taSl7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSAtIDFdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgLSAxXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOS/ruaUueS4i+eVjFxyXG4gICAgICAgICsrbG93O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29ja1RhaWxTb3J0ID0gY29ja1RhaWxTb3J0O1xyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxuY29ja1RhaWxTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKCdjb2NrVGFpbFNvcnQ6XFxuJyArIGFyciArICcnKTtcclxuXHJcblxyXG4vLyDmlLnov5szXHJcbmZ1bmN0aW9uIGNvY2tUYWlsU29ydDIoc3FMaXN0LCBjb21wKXtcclxuICAgIGlmKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgdmFyIGIgPSB7fTtcclxuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xyXG4gICAgLy8gZOS4uuWGkuazoeaWueWQkeagh+ivhu+8jCAx5Li65ZCR5LiK77yMLTHkuLrlkJHkuItcclxuICAgIHZhciBkID0gMTtcclxuICAgIC8vIGJbMF3kuLrlhpLms6HkuIrnlYzvvIxiWzJd5Li65YaS5rOh5LiK55WM77yMYlsxXeaXoOeUqFxyXG4gICAgYlswXSA9IDA7XHJcbiAgICBiWzJdID0gbGVuIC0gMTtcclxuICAgIHZhciBjaGFuZ2UgPSAxO1xyXG5cclxuICAgIHdoaWxlKGJbMF0gPCBiWzJdICYmIGNoYW5nZSl7XHJcbiAgICAgICAgY2hhbmdlID0gMDtcclxuXHJcbiAgICAgICAgLy8g57uf5LiA55qE5YaS5rOh566X5rOVXHJcbiAgICAgICAgZm9yKHZhciBpID0gYlsxIC0gZF07IGkgIT09IGJbMSArIGRdOyBpICs9IGQpe1xyXG4gICAgICAgICAgICAvLyDms6jmhI/ov5nkuKrkuqTmjaLmnaHku7ZcclxuICAgICAgICAgICAgaWYoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgZF0pICogZCA+IDApe1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSArIGRdO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyBkXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDkv67mlLnovrnnlYxcclxuICAgICAgICBiWzEgKyBkXSAtPSBkO1xyXG4gICAgICAgIC8vIOaNouS4quaWueWQkVxyXG4gICAgICAgIGQgKj0gLTE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb2NrVGFpbFNvcnQyID0gY29ja1RhaWxTb3J0MjtcclxuXHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbmNvY2tUYWlsU29ydDIoYXJyKTtcclxuY29uc29sZS5sb2coJ2NvY2tUYWlsU29ydDI6XFxuJyArIGFyciArICcnKTtcclxuXHJcblxyXG5cclxuLypcclxuIOW/q+mAn+aOkuW6j1xyXG5cclxuIDEgIOaOkuW6j+aAneaDs1xyXG4g6YCa6L+H5LiA6Laf5o6S5bqP77yM5bCG5b6F5o6S5bqP6K6w5b2V5YiG5Ymy5oiQ54us56uL55qE5Lik6YOo5YiG77yM5YW25Lit5LiA6YOo5YiG6K6w5b2V55qE5YWz6ZSu5a2X5Z2H5q+U5Y+m5LiA6YOo5YiG6K6w5b2V55qE5YWz6ZSu5a2X5bCP77yM5YaN5YiG5Yir5a+56L+Z5Lik6YOo5YiG6K6w5b2V6L+b6KGM5LiL5LiA6Laf5o6S5bqP77yM5Lul6L6+5Yiw5pW05Liq5bqP5YiX5pyJ5bqP44CCXHJcblxyXG4gMiAg5o6S5bqP6L+H56iLXHJcbiDorr7lvoXmjpLluo/nmoTorrDlvZXluo/liJfmmK9SW3PigKZ0XSDvvIzlnKjorrDlvZXluo/liJfkuK3ku7vlj5bkuIDkuKrorrDlvZUo5LiA6Iis5Y+WUltzXSnkvZzkuLrlj4Lnhaco5Y+I56ew5Li65Z+65YeG5oiW5p6i6L20Ke+8jOS7pVJbc10ua2V55Li65Z+65YeG6YeN5paw5o6S5YiX5YW25L2Z55qE5omA5pyJ6K6w5b2V77yM5pa55rOV5piv77yaXHJcbiAgICAg4peGIOaJgOacieWFs+mUruWtl+avlOWfuuWHhuWwj+eahOaUvlJbc13kuYvliY3vvJtcclxuICAgICDil4Yg5omA5pyJ5YWz6ZSu5a2X5q+U5Z+65YeG5aSn55qE5pS+UltzXeS5i+WQjuOAglxyXG4g5LulUltzXS5rZXnmnIDlkI7miYDlnKjkvY3nva5p5L2c5Li65YiG55WM77yM5bCG5bqP5YiXUltz4oCmdF3liIblibLmiJDkuKTkuKrlrZDluo/liJfvvIznp7DkuLrkuIDotp/lv6vpgJ/mjpLluo/jgIJcclxuXHJcbiAzICDkuIDotp/lv6vpgJ/mjpLluo/mlrnms5VcclxuIOS7juW6j+WIl+eahOS4pOerr+S6pOabv+aJq+aPj+WQhOS4quiusOW9le+8jOWwhuWFs+mUruWtl+Wwj+S6juWfuuWHhuWFs+mUruWtl+eahOiusOW9leS+neasoeaUvue9ruWIsOW6j+WIl+eahOWJjei+ue+8m+iAjOWwhuWFs+mUruWtl+Wkp+S6juWfuuWHhuWFs+mUruWtl+eahOiusOW9leS7juW6j+WIl+eahOacgOWQjuerr+i1t++8jOS+neasoeaUvue9ruWIsOW6j+WIl+eahOWQjui+ue+8jOebtOWIsOaJq+aPj+WujOaJgOacieeahOiusOW9leOAglxyXG5cclxuIOiuvue9ruaMh+mSiGxvd++8jGhpZ2jvvIzliJ3lgLzkuLrnrKwx5Liq5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V55qE5L2N572u44CCXHJcbiDorr7kuKTkuKrlj5jph49p77yMau+8jOWIneWni+aXtuS7pGk9bG9377yMaj1oaWdo77yM5LulUltsb3ddLmtleeS9nOS4uuWfuuWHhijlsIZSW2xvd13kv53lrZjlnKh0ZW1w5LitKSDjgIJcclxuIOKRoCDku45q5omA5oyH5L2N572u5ZCR5YmN5pCc57Si77ya5bCGdGVtcOS4jlJbal0ua2V56L+b6KGM5q+U6L6D77yaXHJcbiAgICDil4Yg6IuldGVtcOKJpFJbal0ua2V5IO+8muS7pGo9ai0x77yM54S25ZCO57un57ut6L+b6KGM5q+U6L6D77yMIOebtOWIsGk9auaIlnRlbXA+UltqXS5rZXnkuLrmraLvvJtcclxuICAgIOKXhiDoi6V0ZW1wPlJbal0ua2V5IO+8mlJbal3vg55SW2ld77yM6IW+56m6UltqXeeahOS9jee9ru+8jCDkuJTku6RpPWkrMe+8m1xyXG4g4pGhIOS7jmnmiYDmjIfkvY3nva7otbflkJHlkI7mkJzntKLvvJrlsIZ0ZW1w5LiOUltpXS5rZXnov5vooYzmr5TovoPvvJpcclxuICAgIOKXhiDoi6V0ZW1w4omlUltpXS5rZXkg77ya5LukaT1pKzHvvIznhLblkI7nu6fnu63ov5vooYzmr5TovoPvvIwg55u05YiwaT1q5oiWdGVtcDxSW2ldLmtleeS4uuatou+8m1xyXG4gICAg4peGIOiLpXRlbXA8UltpXS5rZXkg77yaUltpXe+DnlJbal3vvIzohb7nqbpSW2ld55qE5L2N572u77yMIOS4lOS7pGo9ai0x77ybXHJcbiDikaIg6YeN5aSN4pGg44CB4pGh77yM55u06IezaT1q5Li65q2i77yMaeWwseaYr3RlbXAo5Z+65YeGKeaJgOW6lOaUvue9rueahOS9jee9ruOAglxyXG5cclxuIOeul+azleWIhuaekFxyXG4g5b+r6YCf5o6S5bqP55qE5Li76KaB5pe26Ze05piv6Iqx6LS55Zyo5YiS5YiG5LiK77yM5a+56ZW/5bqm5Li6a+eahOiusOW9leW6j+WIl+i/m+ihjOWIkuWIhuaXtuWFs+mUruWtl+eahOavlOi+g+asoeaVsOaYr2stMSDjgILorr7plb/luqbkuLpu55qE6K6w5b2V5bqP5YiX6L+b6KGM5o6S5bqP55qE5q+U6L6D5qyh5pWw5Li6QyhuKe+8jOWImUMobik9bi0xK0MoaykrQyhuLWstMSkg44CCXHJcbiDil4YgIOacgOWlveaDheWGte+8muavj+asoeWIkuWIhuW+l+WIsOeahOWtkOW6j+WIl+Wkp+iHtOebuOetie+8jOWImVxyXG4gQyhuKTw9aMOXbisyaMOXQyhuLzJoKSDvvIzlvZNuLzJoPTHml7bmjpLluo/nu5PmnZ/jgIJcclxuIOWNs0MobiniiaRPKG7Dl+OPkjJuKSDvvJtcclxuIOKXhiAg5pyA5Z2P5oOF5Ya177ya5q+P5qyh5YiS5YiG5b6X5Yiw55qE5a2Q5bqP5YiX5Lit5pyJ5LiA5Liq5Li656m677yM5Y+m5LiA5Liq5a2Q5bqP5YiX55qE6ZW/5bqm5Li6bi0x44CC5Y2z5q+P5qyh5YiS5YiG5omA6YCJ5oup55qE5Z+65YeG5piv5b2T5YmN5b6F5o6S5bqP5bqP5YiX5Lit55qE5pyA5bCPKOaIluacgOWkpynlhbPplK7lrZfjgIJcclxuIOavlOi+g+asoeaVsO+8mjogIOWNs0Mobik9TyhuMilcclxuIOKXhiAg5LiA6Iis5oOF5Ya177yaIOWvuW7kuKrorrDlvZXov5vooYzlv6vpgJ/mjpLluo/miYDpnIDnmoTml7bpl7RUKG4p57uE5oiQ5piv77yaXHJcbiAgICAg4pGgIOWvuW7kuKrorrDlvZXov5vooYzkuIDotp/liJLliIbmiYDpnIDnmoTml7bpl7TmmK/vvJpuw5dDIO+8jEPmmK/luLjmlbDvvJtcclxuICAgICDikaEg5a+55omA5b6X5Yiw55qE5Lik5Liq5a2Q5bqP5YiX6L+b6KGM5b+r6YCf5o6S5bqP55qE5pe26Ze077yaXHJcbiAgICAgICAgVGF2ZyhuKT1DKG4pK1Rhdmcoay0xKStUYXZnKG4taykgICAgICAgICAg4oCm4oCmXHJcblxyXG4g5b+r6YCf5o6S5bqP55qE5bmz5Z2H5pe26Ze05aSN5p2C5bqm5piv77yaVChuKT1PKG7jj5IybilcclxuIOS7juaJgOmcgOimgeeahOmZhOWKoOepuumXtOadpeeci++8jOW/q+mAn+aOkuW6j+eul+azleaYr+mAkuW9kuiwg+eUqO+8jOezu+e7n+WGheeUqOWghuagiOS/neWtmOmAkuW9kuWPguaVsO+8jOW9k+avj+asoeWIkuWIhuavlOi+g+Wdh+WMgOaXtu+8jOagiOeahOacgOWkp+a3seW6puS4ulvjj5Iybl0rMSDjgIJcclxuXHJcbiDlv6vpgJ/mjpLluo/nmoTnqbrpl7TlpI3mnYLluqbmmK/vvJpTKG4pPU8o44+SMm4pXHJcbiDku47mjpLluo/nmoTnqLPlrprmgKfmnaXnnIvvvIzlv6vpgJ/mjpLluo/mmK/kuI3nqLPlrprnmoTjgIJcclxuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcGFydGl0aW9uMShzcUxpc3QsIGxvdywgaGlnaCl7XHJcbiAgICB2YXIgdGVtcCA9IHNxTGlzdFtsb3ddO1xyXG5cclxuICAgIHdoaWxlKGxvdyA8IGhpZ2gpe1xyXG4gICAgICAgIHdoaWxlKGxvdyA8IGhpZ2ggJiYgc3FMaXN0W2hpZ2hdID49IHRlbXApIC0taGlnaDtcclxuICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtoaWdoXTtcclxuICAgICAgICB3aGlsZShsb3cgPCBoaWdoICYmIHNxTGlzdFtsb3ddIDw9IHRlbXApICsrbG93O1xyXG4gICAgICAgIHNxTGlzdFtoaWdoXSA9IHNxTGlzdFtsb3ddO1xyXG4gICAgfVxyXG5cclxuICAgIHNxTGlzdFtsb3ddID0gdGVtcDtcclxuXHJcbiAgICByZXR1cm4gbG93O1xyXG59XHJcblxyXG4vLyDkvJjljJbkuIDotp/lv6vpgJ/mjpLluo/mlrnms5XvvJog6ZqP5py65YyWcGFydGl0aW9uXHJcbi8vIOacgOWdj+aDheWGteaViOeOh+Wkp+W5heaPkOWNh++8jOaXtumXtOWkjeadguW6plQobik9Tyhu44+SMm4pXHJcbmZ1bmN0aW9uIHBhcnRpdGlvbjIoc3FMaXN0LCBsb3csIGhpZ2gpe1xyXG4gICAgdmFyIHRlbXA7XHJcbiAgICB2YXIgbiA9IGhpZ2ggLSBsb3cgKyAxO1xyXG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuKSArIGxvdztcclxuXHJcbiAgICAvL3ZhciByYW5kID0gKGxvdyArIGhpZ2gpID4+IDE7XHJcbiAgICB0ZW1wID0gc3FMaXN0W2hpZ2hdO1xyXG4gICAgc3FMaXN0W2hpZ2hdID0gc3FMaXN0W3JhbmRdO1xyXG4gICAgc3FMaXN0W3JhbmRdID0gdGVtcDtcclxuXHJcbiAgICB2YXIgaSA9IGxvdyAtIDE7XHJcbiAgICB2YXIgcGl2b3QgPSBzcUxpc3RbaGlnaF07XHJcblxyXG4gICAgZm9yKHZhciBqID0gbG93OyBqIDwgaGlnaDsgKytqKXtcclxuICAgICAgICBpZihzcUxpc3Rbal0gPD0gcGl2b3QpIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3Rbal07XHJcbiAgICAgICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICsraTtcclxuICAgIHNxTGlzdFtoaWdoXSA9IHNxTGlzdFtpXTtcclxuICAgIHNxTGlzdFtpXSA9IHBpdm90O1xyXG5cclxuICAgIHJldHVybiBpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApe1xyXG4gICAgdmFyIHRlbXA7XHJcbiAgICB2YXIgaSA9IGxvdztcclxuICAgIHZhciBqID0gaGlnaCArIDE7XHJcbiAgICB2YXIgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkgKyBsb3cgKyAxO1xyXG4gICAgLy92YXIgcmFuZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xyXG5cclxuICAgIHRlbXAgPSBzcUxpc3RbbG93XTtcclxuICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W3JhbmRdO1xyXG4gICAgc3FMaXN0W3JhbmRdID0gdGVtcDtcclxuXHJcbiAgICB2YXIgeCA9IHNxTGlzdFtsb3ddO1xyXG5cclxuICAgIHdoaWxlKDEpe1xyXG4gICAgICAgIHdoaWxlKGNvbXAoc3FMaXN0WysraV0sIHgpIDwgMCAmJiBpIDwgaGlnaCk7XHJcbiAgICAgICAgd2hpbGUoY29tcChzcUxpc3RbLS1qXSwgeCkgPiAwKTtcclxuICAgICAgICBpZihpID49IGopIGJyZWFrO1xyXG4gICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2pdO1xyXG4gICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgc3FMaXN0W2xvd10gPSBzcUxpc3Rbal07XHJcbiAgICBzcUxpc3Rbal0gPSB4O1xyXG5cclxuICAgIHJldHVybiBqO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWlja1NvcnRSZWN1cnNpdmUoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBpZihsb3cgPT0gbnVsbCkgbG93ID0gMDtcclxuICAgIGlmKGhpZ2ggPT0gbnVsbCkgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxO1xyXG5cclxuICAgIGlmKGxvdyA+PSBoaWdoKSByZXR1cm47XHJcblxyXG4gICAgdmFyIGsgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xyXG4gICAgcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgbG93LCBrIC0gMSwgY29tcCk7XHJcbiAgICBxdWlja1NvcnRSZWN1cnNpdmUoc3FMaXN0LCBrICsgMSwgaGlnaCwgY29tcCk7XHJcbn1cclxuZXhwb3J0cy5xdWlja1NvcnRSZWN1cnNpdmUgPSBxdWlja1NvcnRSZWN1cnNpdmU7XHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5xdWlja1NvcnRSZWN1cnNpdmUoYXJyKTtcclxuY29uc29sZS5sb2coJ3F1aWNrU29ydFJlY3Vyc2l2ZTpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbuW/q+aOkumAkuW9kueul+azleS8mOWMlu+8jOWcqOacgOWdj+aDheWGteS4i+WghuagiOa3seW6puS4uk8obG9nbilcclxuICovXHJcbmZ1bmN0aW9uIHF1aWNrU29ydFJlY3Vyc2l2ZTIoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBpZihsb3cgPT0gbnVsbCkgbG93ID0gMDtcclxuICAgIGlmKGhpZ2ggPT0gbnVsbCkgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxO1xyXG5cclxuICAgIHdoaWxlKGxvdyA8IGhpZ2gpe1xyXG4gICAgICAgIHZhciBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcclxuXHJcbiAgICAgICAgLy8g5a+55Lik5Liq5a2Q5pWw57uE5Lit6L6D5bCP55qE5LiA5Liq5a2Q5pWw57uE6L+b6KGM6YCS5b2S6LCD55So44CCXHJcbiAgICAgICAgLy8g6L6D5bCP5a2Q5pWw57uE55qE5aSn5bCP5pyA5aSa5Li65Y6f5pWw57uE5aSn5bCP5LiA5Y2K77yMXHJcbiAgICAgICAgLy8g55Sx5LqO5q+P5qyh6YCS5b2S6LCD55So55qE5pWw57uE5aSn5bCP6Iez5bCR5YeP5bCR5LiA5Y2K77yM5omA5Lul6YCS5b2S6LCD55So55qE5qyh5pWwXHJcbiAgICAgICAgLy8g5pyA5aSa5Li6Tyhsb2duKVxyXG4gICAgICAgIGlmKGsgLSBsb3cgKyAxIDwgaGlnaCAtIGspIHtcclxuICAgICAgICAgICAgcXVpY2tTb3J0UmVjdXJzaXZlMihzcUxpc3QsIGxvdywgayAtIDEsIGNvbXApO1xyXG4gICAgICAgICAgICBsb3cgPSBrICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBxdWlja1NvcnRSZWN1cnNpdmUyKHNxTGlzdCwgayArIDEsIGhpZ2gsIGNvbXApO1xyXG4gICAgICAgICAgICBoaWdoID0gayAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucXVpY2tTb3J0UmVjdXJzaXZlMiA9IHF1aWNrU29ydFJlY3Vyc2l2ZTI7XHJcbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XHJcbnF1aWNrU29ydFJlY3Vyc2l2ZTIoYXJyKTtcclxuY29uc29sZS5sb2coJ3F1aWNrU29ydFJlY3Vyc2l2ZTI6XFxuJyArIGFyciArICcnKTtcclxuXHJcblxyXG5mdW5jdGlvbiBxdWlja1NvcnROb25SZWN1cnNpdmUoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApe1xyXG4gICAgaWYoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBpZihsb3cgPT0gbnVsbCkgbG93ID0gMDtcclxuICAgIGlmKGhpZ2ggPT0gbnVsbCkgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxO1xyXG4gICAgdmFyIHN0YWNrID0gW107XHJcbiAgICB2YXIgaztcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgd2hpbGUobG93IDwgaGlnaCl7XHJcbiAgICAgICAgICAgIGsgPSBwYXJ0aXRpb24oc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xyXG4gICAgICAgICAgICAvLyDnrKzkuozkuKrlrZDluo/liJfnmoTkuIos5LiL55WM5YiG5Yir5YWl5qCIXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaGlnaCwgayArIDEpO1xyXG4gICAgICAgICAgICAvL3N0YWNrLnB1c2goayArIDEpO1xyXG4gICAgICAgICAgICBoaWdoID0gayAtIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighc3RhY2subGVuZ3RoKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxvdyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGhpZ2ggPSBzdGFjay5wb3AoKTtcclxuICAgIH0gd2hpbGUoMSk7XHJcbn1cclxuZXhwb3J0cy5xdWlja1NvcnROb25SZWN1cnNpdmUgPSBxdWlja1NvcnROb25SZWN1cnNpdmU7XHJcblxyXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xyXG5xdWlja1NvcnROb25SZWN1cnNpdmUoYXJyKTtcclxuY29uc29sZS5sb2coJ3F1aWNrU29ydE5vblJlY3Vyc2l2ZTpcXG4nICsgYXJyICsgJycpO1xyXG5cclxuLy8g5LyY5YyW54mI5pysXHJcbmZ1bmN0aW9uIHF1aWNrU29ydChzcUxpc3QsIGxvdywgaGlnaCwgY29tcCl7XHJcbiAgICBpZihjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIGlmKGxvdyA9PSBudWxsKSBsb3cgPSAwO1xyXG4gICAgaWYoaGlnaCA9PSBudWxsKSBoaWdoID0gc3FMaXN0Lmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgc3RhY2sgPSBbXTtcclxuICAgIHZhciBwaXZvdDtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgLy8g5aaC5p6c5b2T5YmN5a2Q5bqP5YiX6ZW/5bqm5aSn5LqOM+S4lOWwmuacquaOkuWlveW6j1xyXG4gICAgICAgIGlmKGhpZ2ggLSBsb3cgPiAyKSB7XHJcbiAgICAgICAgICAgIC8vIOi/m+ihjOS4gOi2n+WIkuWIhlxyXG4gICAgICAgICAgICBwaXZvdCA9IHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCk7XHJcblxyXG4gICAgICAgICAgICAvLyDlkKfplb/nmoTlrZDluo/liJfovrnnlYzlhaXmoIjvvIxcclxuICAgICAgICAgICAgLy8g55+t55qE5a2Q5bqP5YiX55WZ5b6F5LiL5qyh5o6S5bqPXHJcbiAgICAgICAgICAgIGlmKGhpZ2ggLSBwaXZvdCA+IHBpdm90IC0gbG93KSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGhpZ2gsIHBpdm90ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBwaXZvdCAtIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBpdm90IC0gMSwgbG93KTtcclxuICAgICAgICAgICAgICAgIC8vc3RhY2sucHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgbG93ID0gcGl2b3QgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWmguaenOW9k+WJjeWtkOW6j+WIl+mVv+W6puWwj+S6jjPvvIzkuJTlsJrmnKrmjpLlpb3luo/vvIxcclxuICAgICAgICAvLyDnm7TmjqXov5vooYzmr5TovoPmjpLluo/kubDlvZPliY3lrZDluo/liJfmoIflv5fkuLrlt7LmjpLlpb3luo9cclxuICAgICAgICBlbHNlIGlmKGxvdyA8IGhpZ2ggJiYgaGlnaCAtIGxvdyA8IDMpIHtcclxuICAgICAgICAgICAgZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xyXG4gICAgICAgICAgICBsb3cgPSBoaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlpoLmnpzlvZPliY3lrZDluo/liJflt7LmjpLlpb3luo/kvYbmoIjkuK3ov5jmnInmnKrmjpLluo/nmoTlrZDluo/liJdcclxuICAgICAgICAvLyDku47moIjkuK3lj5blh7rkuIDkuKrlrZDluo/liJdcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbG93ID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIGhpZ2ggPSBzdGFjay5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlKDEpO1xyXG59XHJcbmV4cG9ydHMucXVpY2tTb3J0ID0gcXVpY2tTb3J0O1xyXG5cclxuZnVuY3Rpb24gZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApe1xyXG4gICAgdmFyIHRlbXA7XHJcblxyXG4gICAgaWYoaGlnaCAtIGxvdyA9PT0gMSkge1xyXG4gICAgICAgIGlmKGNvbXAoc3FMaXN0W2xvd10sIHNxTGlzdFtoaWdoXSkgPiAwKSB7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbbG93XTtcclxuICAgICAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbaGlnaF07XHJcbiAgICAgICAgICAgIHNxTGlzdFtoaWdoXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZihjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbbG93ICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2xvdyArIDFdO1xyXG4gICAgICAgICAgICBzcUxpc3RbbG93ICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihjb21wKHNxTGlzdFtsb3cgKyAxXSwgc3FMaXN0W2hpZ2hdKSA+IDApIHtcclxuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3cgKyAxXTtcclxuICAgICAgICAgICAgc3FMaXN0W2xvdyArIDFdID0gc3FMaXN0W2hpZ2hdO1xyXG4gICAgICAgICAgICBzcUxpc3RbaGlnaF0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbbG93ICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XHJcbiAgICAgICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2xvdyArIDFdO1xyXG4gICAgICAgICAgICBzcUxpc3RbbG93ICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxucXVpY2tTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKCdxdWlja1NvcnQ6XFxuJyArIGFyciArICcnKTtcclxuXHJcblxyXG4vLyDlpYflgbbkuqTmjaLmjpLluo9cclxuZnVuY3Rpb24gb2RkRXZlblNvcnQoc3FMaXN0LCBjb21wKXtcclxuICAgIGlmKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgdmFyIGNoYW5nZSA9IDE7XHJcbiAgICB2YXIgdGVtcDtcclxuICAgIHZhciBsZW4gPSBzcUxpc3QubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlKGNoYW5nZSl7XHJcbiAgICAgICAgY2hhbmdlID0gMDtcclxuICAgICAgICAvLyDlr7nmiYDmnInlpYfmlbDov5vooYzkuIDotp/mr5TovoNcclxuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgbGVuIC0gMTsgaSArPSAyKXtcclxuICAgICAgICAgICAgaWYoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XHJcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcclxuXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDlr7nmiYDmnInlgbbmlbDov5vooYzkuIDotp/mr5TovoNcclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDIpe1xyXG4gICAgICAgICAgICBpZihjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyAxXSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtpICsgMV0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5vZGRFdmVuU29ydCA9IG9kZEV2ZW5Tb3J0O1xyXG5cclxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcclxub2RkRXZlblNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coJ29kZEV2ZW5Tb3J0OlxcbicgKyBhcnIgKyAnJyk7XHJcblxyXG5cclxuLypcclxu5oqK55Sx5LiJ56eN6aKc6Imy57uE5oiQ55qE5bqP5YiX6YeN5o6S5Li65oyJ54Wn57qi55m96JOd55qE6aG65bqP5o6S5YiX77yMXHJcbuaAnei3r++8mlxyXG7orr7nq4vkuInkuKrmjIfpkojvvIzlhbbkuK1q6KGo56S65b2T5YmN5YWD57Sg77ybaeS7peWJjeeahOWFg+e0oOWFqOmDqOS4uue6ouiJsu+8m2vku6XlkI7nmoTpopzoibLlhajkuLrok53oibLjgILov5nmoLflsLHlj6/ku6XmoLnmja5q55qE6aKc6Imy5oqK5YW25Lqk5o2i5Yiw5bqP5YiX55qE5YmN6Z2i5oiW6ICF5ZCO6Z2i44CCXHJcbiAqL1xyXG52YXIgUkVEID0gMDtcclxudmFyIFdISVRFID0gMTtcclxudmFyIEJMVUUgPSAyO1xyXG5cclxuZnVuY3Rpb24gZmxhZ0FycmFuZ2UoY29sb3JzKXtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBqID0gMDtcclxuICAgIHZhciBrID0gY29sb3JzLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgdGVtcDtcclxuXHJcbiAgICB3aGlsZShqIDw9IGspe1xyXG4gICAgICAgIHN3aXRjaChjb2xvcnNbal0pe1xyXG4gICAgICAgICAgICBjYXNlIFJFRDpcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBjb2xvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSBjb2xvcnNbal07XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbal0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgKytqO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV0hJVEU6XHJcbiAgICAgICAgICAgICAgICArK2o7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCTFVFOlxyXG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbG9yc1tqXTtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tqXSA9IGNvbG9yc1trXTtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1trXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICAtLWs7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudmFyIGFyciA9IFsyLCAxLCAwLCAyLCAxLCAxLCAwLCAyLCAwLCAyLCAxXTtcclxuZmxhZ0FycmFuZ2UoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvZXhjaGFuZ2UvaW5kZXguanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XHJcblxyXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxyXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xyXG4gIE8gPSB0b09iamVjdChPKTtcclxuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcclxuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcclxuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcclxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XHJcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXHJcbiAgICAsIGkgICAgICA9IDBcclxuICAgICwgcmVzdWx0ID0gW11cclxuICAgICwga2V5O1xyXG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcclxuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXHJcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xyXG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXQgZG9uJ3QgYnJlYWsgdGhpbmdzLlxudmFyIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDljYHlrZfpk77ooahcclxuICpcclxuICog5b2T55+p6Zi155qE6Z2e6Zu25Liq5pWw5ZKM5L2N572u5Zyo5pON5L2c6L+H56iL5Lit5Y+Y5YyW5aSn5pe277yM5bCx5LiN5a6c6YeH55So6aG65bqP5a2Y5YKo57uT5p6E5p2l6KGo56S65LiJ5YWD57uE55qE57q/5oCn6KGo44CC5L6L5aaC77yM5Zyo5L2c4oCc5bCG55+p6Zi1QuWKoOWIsOefqemYtUHkuIrigJ3nmoTmk43kvZzml7bvvIznlLHkuo7pnZ7pm7blhYPnmoTmj5LlhaXmiJbliKDpmaTlsIbkvJrlvJXotbdBLmRhdGHkuK3lhYPntKDnmoTnp7vliqjjgILkuLrmraTvvIzlr7nov5nnp43nsbvlnovnmoTnn6npmLXvvIzph4fnlKjpk77lvI/lrZjlgqjnu5PmnoTooajnpLrkuInlhYPnu4TnmoTnur/mgKfooajmm7TkuLrmgbDlvZPjgIJcclxuICpcclxuICog5Zyo6ZO+6KGo5Lit77yM5q+P5Liq6Z2e6Zu25YWD5Y+v55So5LiA5Liq5ZCrNeS4quWfn+eahOe7k+eCueihqOekuu+8jOWFtuS4rWnvvIxq5ZKMZei/mTPkuKrln5/liIbliKvooajnpLror6XpnZ7pm7blhYPmiYDlnKjnmoTooYzvvIzliJflkozpnZ7pm7blhYPnmoTlgLzvvIzlkJHlj7Pln59yaWdodOeUqOS7pemTvuaOpeWQjOS4gOihjOS4reS4i+S4gOS4qumdnumbtuWFg++8jOWQkeS4i+Wfn2Rvd27nlKjku6Xpk77mjqXlkIzkuIDliJfkuK3kuIvkuIDkuKrpnZ7pm7blhYPjgILlkIzkuIDooYznmoTpnZ7pm7blhYPpgJrov4dyaWdodOWfn+mTvuaOpeaIkOS4gOS4que6v+aAp+ihqO+8jOWQjOS4gOWIl+S4reeahOmdnumbtuWFg+mAmuW4uGRvd27ln5/pk77mjqXmiJDkuIDkuKrnur/mgKfpk77ooajvvIzmr4/kuIDkuKrpnZ7pm7blhYPml6LmmK/mn5DkuKrooYzpk77ooajkuK3nmoTkuIDkuKrnu5PngrnvvIzlj4jmmK/mn5DkuKrliJfpk77ooajkuK3nmoTkuIDkuKrnu5PngrnvvIzmlbTkuKrnn6npmLXmnoTmiJDkuobkuIDkuKrljYHlrZfkuqTlj4nnmoTpk77ooajjgIJcclxuICpcclxuICog5Y+v55So5Lik5Liq5YiG5Yir5a2Y5YKo6KGM6ZO+6KGo55qE5aS05oyH6ZKI5ZKM5YiX6ZO+6KGo55qE5aS05oyH6ZKI55qE5LiA57u05pWw57uE5p2l6KGo56S644CCXHJcbiAqL1xyXG5cclxuLy8g56iA55aP55+p6Zi155qE5Y2B5a2X6ZO+6KGo5a2Y5YKo6KGo56S6XHJcbmNsYXNzIE9MTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpID0gMCwgaiA9IDAsIGUpIHtcclxuICAgICAgICAvLyDor6XpnZ7pm7blhYPnmoTooYzlkozliJfkuIvmoIdcclxuICAgICAgICB0aGlzLmkgPSBpO1xyXG4gICAgICAgIHRoaXMuaiA9IGo7XHJcbiAgICAgICAgdGhpcy5lID0gZTtcclxuICAgICAgICAvLyDor6XpnZ7pm7blhYPmiYDlnKjooYzooajlkozliJfooajnmoTlkI7nu6fpk77ln59cclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDsgIC8vIHR5cGU6IE9MTm9kZVxyXG4gICAgICAgIHRoaXMuZG93biA9IG51bGw7ICAgLy8gdHlwZTogT0xOb2RlXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyb3NzTGlzdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyDooYzlkozliJfpk77ooajlpLTmjIfpkojlkJHph4/ln7rlnYDnlLFDcmVhdGVTTWF0cml45YiG6YWNXHJcbiAgICAgICAgdGhpcy5yaGVhZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hlYWQgPSBbXTtcclxuICAgICAgICAvLyDnqIDnlo/nn6npmLXnmoTooYzmlbDvvIzliJfmlbBcclxuICAgICAgICB0aGlzLm11ID0gMDtcclxuICAgICAgICB0aGlzLm51ID0gMDtcclxuICAgICAgICB0aGlzLnR1ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOefqemYteWIneWni+WMllxyXG4gICAgICogQHBhcmFtIG1cclxuICAgICAqIEBwYXJhbSBuXHJcbiAgICAgKiBAcGFyYW0gdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCDkuoznu7TmlbDnu4TvvIzmr4/ooYznmoTlhYPntKDliIbliKvmmK9baSwgaiwgZV1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlU01hdHJpeChtLCBuLCB0LCBsaXN0KSB7XHJcbiAgICAgICAgdGhpcy5tdSA9IG07XHJcbiAgICAgICAgdGhpcy5udSA9IG47XHJcbiAgICAgICAgdGhpcy50dSA9IHQ7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGxpc3QubGVuZ3RoOyByb3crKykge1xyXG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBPTE5vZGUoLi4ubGlzdFtyb3ddKTtcclxuICAgICAgICAgICAgbGV0IFtpLCBqXSA9IGxpc3Rbcm93XTtcclxuICAgICAgICAgICAgbGV0IHE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaGVhZFtpXSA9PSBudWxsIHx8IHRoaXMucmhlYWRbaV0uaiA+IGopIHtcclxuICAgICAgICAgICAgICAgIHAucmlnaHQgPSB0aGlzLnJoZWFkW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaGVhZFtpXSA9IHA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmn6Xor6LlnKjooYzooajkuK3nmoTmj5LlhaXkvY3nva5cclxuICAgICAgICAgICAgICAgIGZvciAocSA9IHRoaXMucmhlYWRbaV07IHEucmlnaHQgJiYgcS5yaWdodC5qIDwgajsgcSA9IHEucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcC5yaWdodCA9IHEucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBxLnJpZ2h0ID0gcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlYWRbal0gPT0gbnVsbCB8fCB0aGlzLmNoZWFkW2pdLmkgPiBpKSB7XHJcbiAgICAgICAgICAgICAgICBwLmRvd24gPSB0aGlzLmNoZWFkW2pdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVhZFtqXSA9IHA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHEgPSB0aGlzLmNoZWFkW2pdOyBxLmRvd24gJiYgcS5kb3duLmkgPCBpOyBxID0gcS5kb3duKTtcclxuICAgICAgICAgICAgICAgIHAuZG93biA9IHEuZG93bjtcclxuICAgICAgICAgICAgICAgIHEuZG93biA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g55+p6Zi155u45YqgXHJcbiAgICBhZGRNYXRyaXgoY3Jvc3NMaXN0KSB7XHJcbiAgICAgICAgbGV0IGhsID0gW107XHJcbiAgICAgICAgLy9obOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IHRoaXMubnU7IGorKylcclxuICAgICAgICAgICAgaGxbal0gPSB0aGlzLmNoZWFkW2pdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLm11OyBpKyspIHtcclxuICAgICAgICAgICAgLy9wYeWSjHBi5oyH5ZCR5q+P5LiA6KGM55qE56ys5LiA5Liq6Z2eMOWFg+e7k+eCue+8jOebtOiHs+acgOWQjuS4gOihjFxyXG4gICAgICAgICAgICBsZXQgcGEgPSB0aGlzLnJoZWFkW2ldO1xyXG4gICAgICAgICAgICBsZXQgcGIgPSBjcm9zc0xpc3QucmhlYWRbaV07XHJcbiAgICAgICAgICAgIGxldCBwcmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy/lpITnkIZC55qE5LiA6KGM77yM55u06Iez5pys6KGM5Lit5peg6Z2eMOWFg+e0oOeahOe7k+eCuVxyXG4gICAgICAgICAgICB3aGlsZSAocGIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwLCBxO1xyXG4gICAgICAgICAgICAgICAgLy8g5paw5o+S5YWl5LiA5Liq57uT54K55YiwcGHnmoTlt6bkvqdcclxuICAgICAgICAgICAgICAgIGlmICghcGEgfHwgcGEuaiA+IHBiLmopIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gbmV3IE9MTm9kZShwYi5pLCBwYi5qLCBwYi5lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy/ooYzooajnmoTmjIfpkojlj5jljJZcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZSkgdGhpcy5yaGVhZFtwLmldID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHByZS5yaWdodCA9IHA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHAucmlnaHQgPSBwYTtcclxuICAgICAgICAgICAgICAgICAgICBwcmUgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL+WIl+ihqOeahOaMh+mSiOWPmOWMllxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChobFtwLmpdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS7jmhsW3Aual3lvIDlp4vmib7liLDmlrDnu5PngrnlnKjlkIzkuIDliJfkuK3nmoTliY3pqbHnu5PngrnvvIzlubborqlobFtwLmpd5oyH5ZCR5a6DXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGhsW3Aual07IHEgJiYgcS5pIDwgcC5pO3EgPSBxLmRvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobFtwLmpdID0gcTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8v5Zyo5YiX6KGo5Lit5o+S5YWl5paw57uT54K577yM5qC55o2u6KGM5pWw5Yik5pat5o+S5YWl5YmN6Z2i6L+Y5piv5ZCO6Z2iXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWFkW3Aual0gfHwgdGhpcy5jaGVhZFtwLmpdLmkgPiBwLmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC5kb3duID0gdGhpcy5jaGVhZFtwLmpdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWFkW3Aual0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuZG93biA9IGhsW3Aual0uZG93bjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGxbcC5qXS5kb3duID0gcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGhsW3Aual0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBiID0gcGIucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhLmogPCBwYi5qKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGEgPSBwYS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lvZNwYS5qID09PSBwYi5q5pe277yM5bCGQuS4reW9k+WJjee7k+eCueeahOWAvOWKoOWIsEHkuK3lvZPliY3nu5PngrnkuIpcclxuICAgICAgICAgICAgICAgICAgICBwYS5lICs9IHBiLmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8v5b2TcGEuZSA9PT0gMOaXtu+8jOWIoOmZpOivpee7k+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYS5lID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiLpeaXoOWJjempsee7k+eCue+8jOWwhuesrOS4gOS4qumdnjDlhYPnu5Pngrnnva7kuLrlvZPliY3nu5PngrnnmoTlkI7nu6fnu5PngrnvvIxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5YmN6amx57uT54K555qE5ZCO57un57uT54K55Li65b2T5YmN57uT54K555qE5ZCO57un57uT54K5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlKSB0aGlzLnJoZWFkW3BhLmldID0gcGEucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcHJlLnJpZ2h0ID0gcGEucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhID0gcGEucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WIl+ihqOeahOaMh+mSiOWPmOWMllxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGxbcC5qXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/ku45obFtwLmpd5byA5aeL5om+5Yiw5paw57uT54K55Zyo5ZCM5LiA5YiX5Lit55qE5YmN6amx57uT54K577yM5bm26K6paGxbcC5qXeaMh+WQkeWug1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gaGxbcC5qXTsgcSAmJiBxLmkgPCBwLmk7IHEgPSBxLmRvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxbcC5qXSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWFkW3Aual0gPT0gcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlYWRbcC5qXSA9IGhsW3Aual0gPSBwLmRvd247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsW3Aual0uZG93biA9IHAuZG93bjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBiID0gcGIucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxubGV0IGxpc3RzID0gW1xyXG4gICAgWzEsIDQsIDVdLFxyXG4gICAgWzIsIDIsIC0xXSxcclxuICAgIFsxLCAxLCAzXSxcclxuICAgIFszLCAxLCAyXVxyXG5dO1xyXG5sZXQgYSA9IG5ldyBDcm9zc0xpc3QoKTtcclxuYS5jcmVhdGVTTWF0cml4KDQsIDQsIDQsIGxpc3RzKTtcclxuY29uc29sZS5sb2coYSk7XHJcblxyXG5sZXQgbGlzdHMyID0gW1xyXG4gICAgWzEsIDQsIC01XSxcclxuICAgIFsyLCAzLCAxXSxcclxuICAgIFsxLCAxLCAzXSxcclxuICAgIFszLCAyLCAyXVxyXG5dO1xyXG5sZXQgYiA9IG5ldyBDcm9zc0xpc3QoKTtcclxuYi5jcmVhdGVTTWF0cml4KDQsIDQsIDQsIGxpc3RzMik7XHJcbmNvbnNvbGUubG9nKGIpO1xyXG5cclxuYS5hZGRNYXRyaXgoYik7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9BcnJheS9Dcm9zc0xpc3QuanNcbiAqKi8iLCIvKipcclxuICog57O75pWw55+p6Zi155qE5LiJ5YWD57uE6aG65bqP6KGo5a2Y5YKo6KGo56S6XHJcbiAqL1xyXG5cclxuY2xhc3MgVHJpcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGksIGosIGVsZW0pIHtcclxuICAgICAgICAvLyDor6XpnZ7pm7blhYPnmoTooYzkuIvmoIflkozliJfkuIvmoIdcclxuICAgICAgICB0aGlzLmkgPSBpIHx8IDA7XHJcbiAgICAgICAgdGhpcy5qID0gaiB8fCAwO1xyXG4gICAgICAgIHRoaXMuZSA9IGVsZW0gfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRTTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKG11LCBudSkge1xyXG4gICAgICAgIC8vIOmdnumbtuWFg+S4ieWFg+e7hOihqFxyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgIC8vIOefqemYteeahOihjOaVsO+8jOWIl+aVsFxyXG4gICAgICAgIHRoaXMubXUgPSBtdSB8fCAwO1xyXG4gICAgICAgIHRoaXMubnUgPSBudSB8fCAwO1xyXG4gICAgfVxyXG4gICAgYWRkVHJpcGxlICh0cmlwbGUpIHtcclxuICAgICAgICBpZiAodHJpcGxlIGluc3RhbmNlb2YgVHJpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmKHRyaXBsZS5pID49IHRoaXMubXUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm11ID0gdHJpcGxlLmkgKyAxO1xyXG4gICAgICAgICAgICBpZih0cmlwbGUuaiA+PSB0aGlzLm51KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5udSA9IHRyaXBsZS5qICsgMTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHRyaXBsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyDph4fnlKjkuInlhYPnu4TooajlrZjlgqjooajnpLrvvIzmsYLnqIDnlo/nn6npmLXnmoTovaznva7nn6npmLV0XHJcbiAgICAvLyDmjInnhadiLmRhdGHkuK3kuInlhYPnu4TnmoTmrKHluo/kvp3mrKHlnKhhLmRhdGHkuK3mib7liLDnm7jlupTnmoTkuInlhYPnu4Tov5vooYzovaznva5cclxuICAgIHRyYW5zcG9zZVNNYXRyaXggKCkge1xyXG4gICAgICAgIGxldCB0ID0gbmV3IFRTTWF0cml4KCk7XHJcbiAgICAgICAgdC5tdSA9IHRoaXMubnU7XHJcbiAgICAgICAgdC5udSA9IHRoaXMubXU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBxID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udTsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgdGhpcy5kYXRhLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtwXS5qID09PSBjb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZGF0YVtxKytdID0gbmV3IFRyaXBsZSh0aGlzLmRhdGFbcF0uaiwgdGhpcy5kYXRhW3BdLmksIHRoaXMuZGF0YVtwXS5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICAvLyDph4fnlKjkuInlhYPnu4TooajlrZjlgqjooajnpLrvvIzmsYLnqIDnlo/nn6npmLXnmoTovaznva7nn6npmLV0XHJcbiAgICAvKlxyXG4gICAgIOaMieeFp2EuZGF0YeS4reS4ieWFg+e7hOeahOasoeW6j+i/m+ihjOi9rOe9ru+8jOW5tuWwhui9rOe9ruWQjueahOS4ieWFg+e7hOe9ruWFpWLkuK3mgbDlvZPnmoTkvY3nva7jgIJcclxuICAgICDlpoLmnpzog73pooTlhYjnoa7lrprnn6npmLVN5Lit5q+P5LiA5YiX77yI5Y2zVOS4reavj+S4gOihjO+8ieeahOesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reW6lOacieeahOS9jee9ru+8jFxyXG4gICAgIOmCo+S5iOWcqOWvuWEuZGF0YeS4reeahOS4ieWFg+e7hOS+neasoeWBmui9rOe9ruaXtu+8jOS+v+WPr+ebtOaOpeaUvuWIsGIuZGF0YeS4reaBsOW9k+eahOS9jee9ruS4iuWOu+OAglxyXG4gICAgIOS4uuS6huWFtumineWumui/meS6m+S9jee9ru+8jOWcqOi9rOe9ruWJje+8jOW6lOWFiOaxguW+l03nmoTmr4/kuIDliJfkuK3pnZ7pm7blhYPnmoTkuKrmlbDvvIzov5vogIzmsYLlvpfmr4/kuIDliJfnmoTnrKzkuIDkuKrpnZ7pm7blhYPlnKhiLmRhdGHkuK3lupTmnInnmoTkvY3nva7jgIJcclxuICAgICDlnKjmraTvvIzpnIDopoHorr5udW3lkoxjcG905Lik5Liq5Y+Y6YeP44CCbnVtW2NvbF3ooajnpLrnn6npmLVN5Lit56ysY29s5YiX5Lit6Z2e6Zu25YWD55qE5Liq5pWw77yMXHJcbiAgICAgY3BvdFtjb2xd5oyH56S6TeS4reesrGNvbOWIl+eahOesrOS4gOS4qumdnumbtuWFg+WcqGIuZGF0YeS4reeahOaBsOW9k+S9jee9ruOAguaYvueEtuacie+8mlxyXG4gICAgIGNwb3RbMF0gPSAxO1xyXG4gICAgIGNwb3RbY29sXSA9IGNwb3RbY29sIC0gMV0gKyBudW1bY29sIC0gMV0gICAgMiA8PSBjb2wgPD0gYS5udVxyXG4gICAgICovXHJcbiAgICBmYXN0VHJhbnNwb3NlU01hdHJpeCgpe1xyXG4gICAgICAgIGxldCB0ID0gbmV3IFRTTWF0cml4KCk7XHJcbiAgICAgICAgdC5tdSA9IHRoaXMubnU7XHJcbiAgICAgICAgdC5udSA9IHRoaXMubXU7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZXQgbnVtID0gW107XHJcbiAgICAgICAgICAgIGZvcihsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udTsgY29sKyspXHJcbiAgICAgICAgICAgICAgICBudW1bY29sXSA9IDA7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICArK251bVt0aGlzLmRhdGFbaV0ual07ICAvLyDmsYLnn6npmLXkuK3mr4/kuIDliJflkKvpnZ7pm7blhYPkuKrmlbBcclxuICAgICAgICAgICAgLy8g5rGC56ysY29s5YiX5Lit56ys5LiA5Liq6Z2e6Zu25YWD5ZyoYi5kYXRh5Lit55qE5bqP5Y+3XHJcbiAgICAgICAgICAgIGxldCBjcG90ID0gWzBdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGNvbCA9IDE7IGNvbCA8IHRoaXMubnU7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgLy8g5LiK5LiA5YiX5LmL5YmN55qE5bqP5Y+3K+S4iuS4gOWIl+eahOmdnumbtuWFg+S4quaVsCA9IOivpeWIl+eahOW6j+WPt1xyXG4gICAgICAgICAgICAgICAgY3BvdFtjb2xdID0gY3BvdFtjb2wgLSAxXSArIG51bVtjb2wgLSAxXTtcclxuICAgICAgICAgICAgZm9yKGxldCBwID0gMDsgcCA8IHRoaXMuZGF0YS5sZW5ndGg7IHArKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29sID0gdGhpcy5kYXRhW3BdLmo7XHJcbiAgICAgICAgICAgICAgICBsZXQgcSA9IGNwb3RbY29sXTtcclxuICAgICAgICAgICAgICAgIHQuZGF0YVtxXSA9IG5ldyBUcmlwbGUodGhpcy5kYXRhW3BdLmosIHRoaXMuZGF0YVtwXS5pLCB0aGlzLmRhdGFbcF0uZSk7XHJcbiAgICAgICAgICAgICAgICAvLyDnu5nor6XliJfnmoTluo/lj7crMe+8jOeUqOS9nOebuOWQjOWIl+aVsOeahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgKytjcG90W2NvbF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgYTEgPSBuZXcgVHJpcGxlKDEsIDIsIDEyKTtcclxubGV0IGEyID0gbmV3IFRyaXBsZSgxLCAzLCA5KTtcclxubGV0IGEzID0gbmV3IFRyaXBsZSgzLCAxLCAtMyk7XHJcbmxldCBhNCA9IG5ldyBUcmlwbGUoMywgNiwgMTQpO1xyXG5sZXQgYTUgPSBuZXcgVHJpcGxlKDQsIDMsIDI0KTtcclxubGV0IGE2ID0gbmV3IFRyaXBsZSg1LCAyLCAxOCk7XHJcbmxldCBhNyA9IG5ldyBUcmlwbGUoNiwgMSwgMTUpO1xyXG5sZXQgYTggPSBuZXcgVHJpcGxlKDYsIDQsIC03KTtcclxuXHJcbmxldCBtYXRyaXggPSBuZXcgVFNNYXRyaXgoKTtcclxubWF0cml4LmFkZFRyaXBsZShhMSk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTIpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGEzKTtcclxubWF0cml4LmFkZFRyaXBsZShhNCk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTUpO1xyXG5tYXRyaXguYWRkVHJpcGxlKGE2KTtcclxubWF0cml4LmFkZFRyaXBsZShhNyk7XHJcbm1hdHJpeC5hZGRUcmlwbGUoYTgpO1xyXG5cclxuY29uc29sZS5sb2cobWF0cml4LnRyYW5zcG9zZVNNYXRyaXgoKSk7XHJcbmNvbnNvbGUubG9nKG1hdHJpeC5mYXN0VHJhbnNwb3NlU01hdHJpeCgpKTtcclxuXHJcbi8qXHJcbiDkuInlhYPnu4Tpobrluo/ooajlj4jnp7DmnInluo/nmoTlj4zkuIvmoIfms5XvvIzlroPnmoTnibnngrnmmK/vvIzpnZ7pm7blhYPlnKjooajkuK3mjInooYzluo/mnInluo/lrZjlgqjvvIzlm6DmraTkvr/kuo7ov5vooYzkvp3ooYzpobrluo/lpITnkIbnmoTnn6npmLXov5DnrpfjgIJcclxuIOeEtuiAjO+8jOiLpemcgOaMieihjOWPt+WtmOWPluafkOS4gOihjOeahOmdnumbtuWFg++8jOWImeS7juWktOW8gOWni+i/m+ihjOafpeaJvuOAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDooYzpgLvovpHpk77mjqXnmoTpobrluo/ooahcclxuICpcclxuICog5Li65LqG5L6/5LqO6ZqP5py65a2Y5Y+W5Lu75oSP5LiA6KGM55qE6Z2e6Zu25YWD77yM5YiZ6ZyA55+l6YGT5q+P5LiA6KGM55qE56ys5LiA5Liq6Z2e6Zu25YWD5Zyo5LiJ5YWD57uE6KGo5Lit55qE5L2N572u44CCXHJcbiAqIOS4uuatpOWPr+WwhuW/q+mAn+i9rOe9ruefqemYteeahOeul+azleS4reWIm+W7uueahO+8jOaMh+ekuuKAnOihjOKAneS/oeaBr+eahOi+heWKqeaVsOe7hGNwb3Tlm7rlrprlnKjnqIDnlo/nn6npmLXnmoTlrZjlgqjnu5PmnoTkuK3jgIJcclxuICog56ew6L+Z56eN4oCc5bim6KGM6ZO+5o6l5L+h5oGv4oCd55qE5LiJ5YWD57uE6KGo5Li66KGM6YC76L6R6ZO+5o6l55qE6aG65bqP6KGoXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUkxTTWF0cml4IGV4dGVuZHMgVFNNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMucnBvcyA9IFswXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5rGC55+p6Zi15LmY56evUSA9IE0gKiBO77yM6YeH55So6KGM6YC76L6R6ZO+5o6l5a2Y5YKo6KGo56S6XHJcbiAgICAgKiBAcGFyYW0gbk1hdHJpeFxyXG4gICAgICogQHJldHVybnMge1JMU01hdHJpeH1cclxuICAgICAqL1xyXG4gICAgbXVsdFNNYXRyaXgobk1hdHJpeCl7XHJcbiAgICAgICAgaWYodGhpcy5udSAhPT0gbk1hdHJpeC5tdSkgdGhyb3cgRXJyb3IoJ251IGlzIG5vdCBlcXVpdmFsZW50IHRvIG11Jyk7XHJcblxyXG4gICAgICAgIC8vIOWIneWni+WMllFcclxuICAgICAgICBsZXQgcU1hdHJpeCA9IG5ldyBSTFNNYXRyaXgodGhpcy5tdSwgbk1hdHJpeC5udSk7XHJcbiAgICAgICAgLy8gUeaYr+mdnumbtuefqemYtVxyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5sZW5ndGggKiBuTWF0cml4LmRhdGEubGVuZ3RoICE9PSAwKXtcclxuICAgICAgICAgICAgLy8g5aSE55CGTeeahOavj+S4gOihjFxyXG4gICAgICAgICAgICBmb3IobGV0IGFyb3cgPSAwOyBhcm93IDwgdGhpcy5tdTsgYXJvdysrKXtcclxuICAgICAgICAgICAgICAgIC8vIOW9k+WJjeihjOWQhOWFg+e0oOe0r+WKoOWZqOa4hembtlxyXG4gICAgICAgICAgICAgICAgbGV0IGN0ZW1wID0gW107XHJcbiAgICAgICAgICAgICAgICBxTWF0cml4LnJwb3NbYXJvd10gPSBxTWF0cml4LmRhdGEubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgIGxldCB0cCwgY2NvbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihhcm93IDwgdGhpcy5tdSlcclxuICAgICAgICAgICAgICAgICAgICB0cCA9IHRoaXMucnBvc1thcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdHAgPSB0aGlzLmRhdGEubGVuZ3RoICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL+WvueW9k+WJjeihjOS4reavj+S4gOS4qumdnumbtuWFg+aJvuWIsOWvueW6lOWFg+WcqE7kuK3nmoTooYzlj7dcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcCA9IHRoaXMucnBvc1thcm93XTsgcCA8IHRwOyBwKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBicm93ID0gdGhpcy5kYXRhW3BdLmo7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYnJvdyA8IG5NYXRyaXgubXUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuTWF0cml4LnJwb3NbYnJvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG5NYXRyaXguZGF0YS5sZW5ndGggKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHEgPSBuTWF0cml4LnJwb3NbYnJvd107IHEgPCB0OyBxKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDkuZjnp6/lhYPntKDlnKhR5Lit55qE5bqP5Y+3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjb2wgPSBuTWF0cml4LmRhdGFbcV0uajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RlbXBbY2NvbF0gPSAoY3RlbXBbY2NvbF0gfHwgMCkgKyB0aGlzLmRhdGFbcF0uZSAqIG5NYXRyaXguZGF0YVtxXS5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDljovnvKnlrZjlgqjor6XooYzpnZ7pm7blhYNcclxuICAgICAgICAgICAgICAgIGZvcihjY29sID0gMTsgY2NvbCA8IHFNYXRyaXgubnU7IGNjb2wrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3RlbXBbY2NvbF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigrK3FNYXRyaXguZGF0YS5sZW5ndGggPiBSTFNNYXRyaXguTUFYU0laRSkgdGhyb3cgRXJyb3IoJ292ZXJmbG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFNYXRyaXguZGF0YVtxTWF0cml4LmRhdGEubGVuZ3RoIC0gMV0gPSBuZXcgVHJpcGxlKGFyb3csIGNjb2wsIGN0ZW1wW2Njb2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxTWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIF9jYWxjUG9zICgpe1xyXG4gICAgICAgIGxldCBudW0gPSBbXTtcclxuICAgICAgICBmb3IobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnU7IGNvbCsrKVxyXG4gICAgICAgICAgICBudW1bY29sXSA9IDA7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgKytudW1bdGhpcy5kYXRhW2ldLmpdOyAgLy8g5rGC55+p6Zi15Lit5q+P5LiA5YiX5ZCr6Z2e6Zu25YWD5Liq5pWwXHJcbiAgICAgICAgLy8g5rGC56ysY29s5YiX5Lit56ys5LiA5Liq6Z2e6Zu25YWD5ZyoYi5kYXRh5Lit55qE5bqP5Y+3XHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSAxOyBjb2wgPCB0aGlzLm51OyBjb2wrKylcclxuICAgICAgICAgICAgLy8g5LiK5LiA5YiX5LmL5YmN55qE5bqP5Y+3K+S4iuS4gOWIl+eahOmdnumbtuWFg+S4quaVsCA9IOivpeWIl+eahOW6j+WPt1xyXG4gICAgICAgICAgICB0aGlzLnJwb3NbY29sXSA9IHRoaXMucnBvc1tjb2wgLSAxXSArIG51bVtjb2wgLSAxXTtcclxuICAgIH1cclxufVxyXG5STFNNYXRyaXguTUFYU0laRSA9IDEwMDtcclxuXHJcblxyXG5sZXQgYjEgPSBuZXcgVHJpcGxlKDEsIDEsIDMpO1xyXG5sZXQgYjIgPSBuZXcgVHJpcGxlKDEsIDMsIDUpO1xyXG5sZXQgYjMgPSBuZXcgVHJpcGxlKDIsIDIsIC0xKTtcclxubGV0IGI0ID0gbmV3IFRyaXBsZSgzLCAxLCAyKTtcclxuXHJcbmxldCB0MSA9IG5ldyBSTFNNYXRyaXgoKTtcclxudDEuYWRkVHJpcGxlKGIxKTtcclxudDEuYWRkVHJpcGxlKGIyKTtcclxudDEuYWRkVHJpcGxlKGIzKTtcclxudDEuYWRkVHJpcGxlKGI0KTtcclxudDEuX2NhbGNQb3MoKTtcclxuXHJcbmxldCBjMSA9IG5ldyBUcmlwbGUoMSwgMiwgMik7XHJcbmxldCBjMiA9IG5ldyBUcmlwbGUoMiwgMSwgMSk7XHJcbmxldCBjMyA9IG5ldyBUcmlwbGUoMywgMSwgLTIpO1xyXG5sZXQgYzQgPSBuZXcgVHJpcGxlKDMsIDIsIDQpO1xyXG5cclxubGV0IHQyID0gbmV3IFJMU01hdHJpeCgpO1xyXG50Mi5hZGRUcmlwbGUoYzEpO1xyXG50Mi5hZGRUcmlwbGUoYzIpO1xyXG50Mi5hZGRUcmlwbGUoYzMpO1xyXG50Mi5hZGRUcmlwbGUoYzQpO1xyXG50Mi5fY2FsY1BvcygpO1xyXG5cclxudDEubXVsdFNNYXRyaXgodDIpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0FycmF5L1RTTWF0cml4LmpzXG4gKiovIiwiLyoqXHJcbiAqIOi1q+Wkq+abvO+8iEh1ZmZtYW7vvInmoJHvvIzlj4jnp7DmnIDkvJjmoJHvvIzmmK/kuIDnsbvluKbmnYPot6/lvoTplb/luqbmnIDnn63nmoTmoJHvvIzmnInnnYDlub/ms5vlupTnlKjjgIJcclxuICpcclxuICog5LuO5qCR5Lit5LiA5Liq57uT54K55Yiw5Y+m5LiA5Liq57uT54K55LmL6Ze055qE5YiG5pSv5p6E5oiQ6L+Z5Lik5Liq57uT54K55LmL6Ze055qE6Lev5b6E77yM6Lev5b6E5LiK55qE5YiG5pSv5pWw55uu56ew5L2c6Lev5b6E6ZW/5bqm44CCXHJcbiAqIOagkeeahOi3r+W+hOmVv+W6puaYr+S7juagkeagueWIsOavj+S4gOS4que7k+eCueeahOi3r+W+hOS5i+WSjOOAglxyXG4gKiDnu5PngrnnmoTluKbmnYPot6/lvoTplb/luqbkuLrku47or6Xnu5PngrnliLDmoJHmoLnkuYvpl7TnmoTot6/lvoTplb/luqbkuI7nu5PngrnkuIrmnYPnmoTkuZjnp6/jgILmoJHnmoTluKbmnYPot6/lvoTplb/luqbkuLrmoJHkuK3miYDmnInlj7blrZDnu5PngrnnmoTluKbmnYPot6/lvoTplb/luqbkuYvlkozjgIJcclxuICpcclxuICog5p6E6YCg6LWr5aSr5pu85qCR55qE5q2l6aqk77yaXHJcbiAqIO+8iDHvvInmoLnmja7nu5nlrprnmoRu5Liq5p2D5YC8e3cxLHcyLC4uLndufeaehOaIkG7mo7Xkuozlj4nmoJHnmoTpm4blkIhGID0ge1QxLFQyLC4uLlRufe+8jOWFtuS4reavj+ajteS6jOWPieagkVRp5Lit5Y+q5pyJ5LiA5Liq5bim5p2D5Li6d2nnmoTmoLnnu5PngrnvvIzlhbblt6blj7PlrZDmoJHlnYfnqbrjgIJcclxuICog77yIMu+8ieWcqEbkuK3pgInlj5bkuKTmo7XmoLnnu5PngrnnmoTmnYPlgLzmnIDlsI/nmoTmoJHkvZzkuLrlt6blj7PlrZDmoJHmnoTpgKDkuIDmo7XmlrDnmoTkuozlj4nmoJHvvIzkuJTnva7mlrDnmoTkuozlj4nmoJHnmoTmoLnnu5PngrnnmoTmnYPlgLzkuLrlhbblt6blj7PlrZDmoJHkuIrmoLnnu5PngrnnmoTmnYPlgLzkuYvlkozjgIJcclxuICog77yIM++8ieWcqEbkuK3liKDpmaTov5nkuKTmo7XmoJHvvIzlkIzml7blsIbmlrDlvpfliLDnmoTkuozlj4nmoJHliqDlhaVG5Lit44CCXHJcbiAqIO+8iDTvvInph43lpI3vvIgy77yJ5ZKM77yIM++8ie+8jOebtOWIsEblj6rlkKvkuIDmo7XmoJHkuLrmraLjgILov5nmo7XmoJHkvr/mmK/otavlpKvmm7zmoJHjgIJcclxuICovXHJcbi8qXHJcbui1q+Wkq+abvOe8lueggVxyXG5odHRwOi8vemgud2lraXBlZGlhLm9yZy93aWtpLyVFOSU5QyU4RCVFNSVBNCVBQiVFNiU5QiVCQyVFNyVCQyU5NiVFNyVBMCU4MVxyXG5cclxu5YGH6K6+55S15oql6ZyA5Lyg6YCB55qE55S15paH5Li64oCcQSBCIEEgQyBDIEQgQeKAne+8jOWug+WPquaciTTnp43lrZfnrKblj6rpnIDkuKTkuKrlrZfnrKbkuLLkvr/lj6/liIbovqjjgILlgYforr5BLEIsQyxE55qE57yW56CB5YiG5Yir5Li6MDAsMDEsMTDlkowxMe+8jOWImeS4iui/sDfkuKrlrZfnrKbnmoTnlLXmlofkvr/kuLrigJwwMDAxMDAxMDEwMTEwMOKAne+8jOWvueaWueaOpeaUtuaXtu+8jOWPr+aMieS6jOS9jeS4gOWIhui/m+ihjOivkeeggeOAglxyXG7lnKjkvKDpgIHnlLXmlofml7bvvIzluIzmnJvmgLvplb/lsL3lj6/og73lnLDnn63jgILlpoLmnpzlr7nmr4/kuKrlrZfnrKborr7orqHplb/luqbkuI3nrYnnmoTnvJbnoIHvvIzkuJTorqnnlLXmlofkuK3lh7rnjrDmrKHmlbDovoPlpJrnmoTlrZfnrKbph4fnlKjlsL3lj6/og73nn63nmoTnvJbnoIHvvIzliJnkvKDpgIHnlLXmlofnmoTmgLvplb/kvr/lj6/lh4/lsJHjgIJcclxu5aaC5p6c5raJ5Y+KQSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAsMDAsMeWSjDAx77yM5YiZ5LiK6L+wN+S4quWtl+espueahOeUteaWh+WPr+i9rOaNouaIkOaAu+mVv+S4ujnnmoTlrZfnrKbkuLLigJwwMDAwMTEwMTDigJ3jgILkvYbmmK/vvIzov5nmoLfnmoTnlLXmlofml6Dms5Xnv7vor5HvvIzlm6DkuLrlj6/mnInlpJrnp43or5Hms5XjgIJcclxu5Zug5q2k77yM6Iul6KaB6K6+6K6h6ZW/55+t5LiN562J55qE57yW56CB77yM5YiZ5b+F6aG75piv5Lu75oSP5Liq5a2X56ym55qE57yW56CB6YO95LiN5piv5Y+m5LiA5Liq5a2X56ym57yW56CB55qE5YmN57yA77yM6L+Z56eN57yW56CB56ew5L2c5YmN57yA57yW56CB44CCXHJcbuWPr+WIqeeUqOS6jOWPieagkeadpeiuvuiuoeS6jOi/m+WItueahOWJjee8gOe8lueggeOAguWBh+iuvuacieS4gOajteS6jOWPieagke+8jOWFtjTkuKrlj7blrZDnu5PngrnliIbliKvooajnpLpBLEIsQyxE6L+ZNOS4quWtl+espu+8jOS4lOe6puWumuW3puWIhuaUr+ihqOekuuWtl+espuKAnDDigJ3vvIzlj7PliIbmlK/ooajnpLrlrZfnrKbigJwx4oCd77yM5YiZ5Y+v5Lul5LuO5qC557uT54K55Yiw5Y+25a2Q57uT54K555qE6Lev5b6E5LiK5YiG5pSv5a2X56ym57uE5oiQ55qE5a2X56ym5Liy5L2c5Li66K+l5Y+25a2Q57uT54K55a2X56ym55qE57yW56CB44CC5omA5b6X5LqM6L+b5Yi25YmN57yA57yW56CB5YiG5Yir5Li6MCwxMCwxMTAsMTExLlxyXG7orr7orqHnlLXmlofmgLvplb/mnIDnn63nmoTkuozov5vliLbliY3nvIDnvJbnoIHljbPku6Vu56eN5a2X56ym5Ye6546w55qE6aKR546H5L2c5p2D44CCXHJcbiAqL1xyXG5cclxuLy8g6LWr5aSr5pu85qCR5ZKM6LWr5aSr5pu857yW56CB55qE5a2Y5YKo57uT5p6EXHJcbmZ1bmN0aW9uIEh1ZmZtYW5Ob2RlKHdlaWdodCwgcGFyZW50LCBsZWZ0Q2hpbGQsIHJpZ2h0Q2hpbGQpIHtcclxuICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0IHx8IDA7XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCAwO1xyXG4gICAgdGhpcy5sZWZ0Q2hpbGQgPSBsZWZ0Q2hpbGQgfHwgMDtcclxuICAgIHRoaXMucmlnaHRDaGlsZCA9IHJpZ2h0Q2hpbGQgfHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaHVmZk1hbkNvZGluZyh3ZWlnaHRzKSB7XHJcbiAgICBsZXQgbiA9IHdlaWdodHMubGVuZ3RoO1xyXG4gICAgaWYgKG4gPCAxKSByZXR1cm47XHJcblxyXG4gICAgbGV0IGh1ZmZtYW5UcmVlID0gYnVpbGRIdWZmbWFuVHJlZSh3ZWlnaHRzLCBuKTtcclxuXHJcbiAgICAvLyDku47lj7blrZDliLDmoLnpgIblkJHmsYLmr4/kuKrlrZfnrKbnmoTotavlpKvmm7znvJbnoIFcclxuICAgIGxldCBoYyA9IGNhbGNIdWZmbWFuQ29kZShodWZmbWFuVHJlZSwgbik7XHJcblxyXG4gICAgcmV0dXJuIFtodWZmbWFuVHJlZSwgaGNdO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY2FsY0h1ZmZtYW5Db2RlKGh1ZmZtYW5UcmVlLCBuKSB7XHJcbiAgICAvLyDku47lj7blrZDliLDmoLnpgIblkJHmsYLmr4/kuKrlrZfnrKbnmoTotavlpKvmm7znvJbnoIFcclxuICAgIGxldCBoYyA9IFtdO1xyXG4gICAgbGV0IGNkID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIGxldCBzdGFydCA9IG4gLSAxO1xyXG4gICAgICAgIGZvciAobGV0IGMgPSBpLCBmID0gaHVmZm1hblRyZWVbaV0ucGFyZW50OyBmICE9IDA7IGMgPSBmLCBmID0gaHVmZm1hblRyZWVbZl0ucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChodWZmbWFuVHJlZVtmXS5sZWZ0Q2hpbGQgPT0gYykgY2RbLS1zdGFydF0gPSAnMCc7XHJcbiAgICAgICAgICAgIGVsc2UgY2RbLS1zdGFydF0gPSAnMSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoY1tpXSA9IHN0ckNvcHkoY2QsIHN0YXJ0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGM7XHJcbn1cclxuXHJcbi8vIOWIm+W7uuS4gOajteWPtuWtkOe7k+eCueaVsOS4um7nmoRIdWZmbWFu5qCRXHJcbmZ1bmN0aW9uIGJ1aWxkSHVmZm1hblRyZWUod2VpZ2h0cywgbikge1xyXG4gICAgbiA9IG4gfHwgd2VpZ2h0cy5sZW5ndGg7XHJcbiAgICBsZXQgbSA9IDIgKiBuIC0gMTtcclxuICAgIGxldCBodWZmbWFuVHJlZSA9IFtdO1xyXG5cclxuICAgIC8vIOWIneWni+WMllxyXG4gICAgbGV0IGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldID0gbmV3IEh1ZmZtYW5Ob2RlKHdlaWdodHNbaV0sIDAsIDAsIDApO1xyXG4gICAgZm9yICg7IGkgPCBtOyBpKyspXHJcbiAgICAgICAgaHVmZm1hblRyZWVbaV0gPSBuZXcgSHVmZm1hbk5vZGUoMCwgMCwgMCwgMCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IG47IGkgPCBtOyBpKyspIHtcclxuICAgICAgICAvLyDlnKhIVFsxLi5pLTFd6YCJ5oupcGFyZW505Li6MOS4lHdlaWdodOacgOWwj+eahOS4pOS4que7k+eCue+8jOi/lOWbnuWFtuW6j+WPt+S4ultzMSwgczJdXHJcbiAgICAgICAgbGV0IHJldCA9IHNlbGVjdChodWZmbWFuVHJlZSwgaSk7XHJcbiAgICAgICAgbGV0IHMxID0gcmV0WzBdO1xyXG4gICAgICAgIGxldCBzMiA9IHJldFsxXTtcclxuICAgICAgICBodWZmbWFuVHJlZVtzMV0ucGFyZW50ID0gaTtcclxuICAgICAgICBodWZmbWFuVHJlZVtzMl0ucGFyZW50ID0gaTtcclxuICAgICAgICBodWZmbWFuVHJlZVtpXS5sZWZ0Q2hpbGQgPSBzMTtcclxuICAgICAgICBodWZmbWFuVHJlZVtpXS5yaWdodENoaWxkID0gczI7XHJcbiAgICAgICAgaHVmZm1hblRyZWVbaV0ud2VpZ2h0ID0gaHVmZm1hblRyZWVbczFdLndlaWdodCArIGh1ZmZtYW5UcmVlW3MyXS53ZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGh1ZmZtYW5UcmVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJDb3B5KHN0ciwgc3RhcnQpIHtcclxuICAgIGxldCBzID0gJyc7XHJcbiAgICBmb3IgKDsgc3RyW3N0YXJ0XTsgc3RhcnQrKykge1xyXG4gICAgICAgIHMgKz0gc3RyW3N0YXJ0XTtcclxuICAgIH1cclxuICAgIHJldHVybiBzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3QoaHVmZm1hblRyZWUsIGxlbikge1xyXG4gICAgbGV0IHJldCA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGxldCBub2RlID0gaHVmZm1hblRyZWVbaV07XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgaWYgKHJldC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGh1ZmZtYW5UcmVlW3JldFswXV0ud2VpZ2h0ID4gaHVmZm1hblRyZWVbcmV0WzFdXS53ZWlnaHRcclxuICAgICAgICAgICAgICAgID8gMCA6IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS53ZWlnaHQgPCBodWZmbWFuVHJlZVtyZXRbaW5kZXhdXS53ZWlnaHQpXHJcbiAgICAgICAgICAgICAgICByZXRbaW5kZXhdID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJldFswXSA+IHJldFsxXSkge1xyXG4gICAgICAgIGxldCB0ZW1wID0gcmV0WzBdO1xyXG4gICAgICAgIHJldFswXSA9IHJldFsxXTtcclxuICAgICAgICByZXRbMV0gPSB0ZW1wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCctLS0tLS0taHVmZm1hbiBjb2RpbmcgMTotLS0tLS0nKTtcclxuY29uc29sZS5sb2coaHVmZk1hbkNvZGluZyhbNSwgMjksIDcsIDgsIDE0LCAyMywgMywgMTFdKSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvQmluYXJ5VHJlZS9odWZmTWFuQ29kaW5nLmpzXG4gKiovIiwiLyoqXHJcbiAqIOW5v+S5ieihqFxyXG4gKlxyXG4gKiDlub/kuYnooajmmK/nur/mgKfooajnmoTmjqjlub/jgILlub/ms5vnlKjkuo7kurrlt6Xmmbrog73nmoTooajlpITnkIbor63oqIBMaXNw77yM5oqK5bm/5LmJ6KGo5L2c5Li65Z+65pys55qE5pWw5o2u57uT5p6E44CCXHJcbiAqIOW5v+S5ieihqOS4gOiIrOiusOS9nO+8mlxyXG4gKiAgICAgIExTID0gKGExLCBhMiwgLi4uLCBhbilcclxuICogTFPmmK/lub/kuYnooajnmoTlkI3np7DvvIxu5piv5a6D55qE6ZW/5bqm77yMYWnlj6/ku6XmmK/ljZXkuKrlhYPntKDvvIzkuZ/lj6/ku6XmmK/lub/kuYnooajvvIzliIbliKvnp7DkuLrlub/kuYnooahMU+eahOWOn+WtkOWSjOWtkOihqOOAguS5oOaDr+S4iu+8jOeUqOWkp+WGmeWtl+avjeihqOekuuW5v+S5ieihqOeahOWQjeensO+8jOWwj+WGmeWtl+avjeihqOekuuWOn+WtkOOAguW9k+W5v+S5ieihqExT6Z2e56m65pe277yM56ew56ys5LiA5Liq5YWD57SgYTHkuLpMU+eahOihqOWktO+8jOensOWFtuS9meWFg+e0oOe7hOaIkOeahOihqChhMiwgYTMsIC4uLiwgYW4p5pivTFPnmoTooajlsL7jgIJcclxuICpcclxuICog5LiL6Z2i5YiX5Li+5LiA5Lqb5bm/5LmJ6KGo55qE5L6L5a2Q77yaXHJcbiAqIDEuQSA9ICgpIC0tLS0gQeaYr+S4gOS4quepuuihqO+8jOWug+eahOmVv+W6puS4ujDjgIJcclxuICogMi5CID0gKGUpIC0tLS0g5YiX6KGoQuWPquacieS4gOS4quWOn+WtkGXvvIxC55qE6ZW/5bqm5Li6MeOAglxyXG4gKiAzLkMgPSAoYSwgKGIsIGMsIGQpKSAtLS0tIOWIl+ihqEPnmoTplb/luqbkuLoy77yM5Lik5Liq5YWD57Sg5YiG5Yir5Li65Y6f5a2QYeWSjOWtkOihqChiLCBjLCBkKeOAglxyXG4gKiA0LkQgPSAoQSwgQiwgQykgLS0tLSDliJfooahE55qE6ZW/5bqm5Li6Mywz5Liq5YWD57Sg6YO95piv5YiX6KGo44CC5pi+56S677yM5bCG5a2Q6KGo55qE5YC85Luj5YWl5ZCO77yM5YiZ5pyJRCA9ICgoKSwgKGUpLCAoYSwgKGIsIGMsIGQpKSnjgIJcclxuICogNS5FID0gKGEsIEUpIC0tLS0g6L+Z5piv5LiA5Liq6YCS5b2S55qE6KGo77yM5a6D55qE6ZW/5bqm5Li6Mi5F55u45b2T5LqO5LiA5Liq5peg6ZmQ55qE5YiX6KGoRSA9IChhLCAoYSwgKGEsIC4uLikpKeOAglxyXG4gKlxyXG4gKiAx77yJ5YiX6KGo55qE5YWD57Sg5Y+v5Lul5piv5a2Q6KGo77yM6ICM5a2Q6KGo55qE5YWD57Sg6L+Y5Y+v5Lul5piv5a2Q6KGo44CC55Sx5q2k77yM5YiX6KGo5piv5LiA5Liq5aSa5bGC5qyh55qE57uT5p6E77yM5Y+v5Lul55So5Zu+5b2i6LGh5Zyw6KGo56S644CCXHJcbiAqIDIp5YiX6KGo5Y+v5Li65YW25a6D5YiX6KGo5omA5YWx5Lqr44CC5YiX6KGoQe+8jELlkoxD5Li6ROeahOWtkOihqO+8jOWImeWcqETkuK3lj6/ku6XkuI3lv4XliJflh7rlrZDooajnmoTlgLzjgIJcclxuICogM++8ieWIl+ihqOWPr+S7peaYr+S4gOS4qumAkuW9kueahOihqO+8jOWNs+WIl+ihqOS5n+WPr+S7peaYr+WFtuacrOi6q+eahOS4gOS4quWtkOihqOOAguS+i+WmguWIl+ihqEXjgIJcclxuICpcclxuICog5Lu75L2V5LiA5Liq6Z2e56m65YiX6KGo5YW26KGo5aS05Y+v6IO95piv5Y6f5a2Q77yM5Lmf5Y+v6IO95piv5YiX6KGo77yM6ICM5YW26KGo5bC+5b+F5a6a5Li65YiX6KGo44CCXHJcbiAqXHJcbiAqL1xyXG5cclxuLypcclxuIOW5v+S5ieihqOeahOmAkuW9kueul+azlVxyXG5cclxuIOmAkuW9kuWumuS5ieeahOW9kue6s+mhueaPj+i/sOS6huWmguS9leWunueOsOS7juW9k+WJjeeKtuaAgeWIsOe7iOe7k+eKtuaAgeeahOi9rOWMluOAglxyXG5cclxuIOeUseS6jumAkuW9kuWHveaVsOeahOiuvuiuoeeUqOeahOaYr+W9kue6s+aAnee7tOeahOaWueazle+8jOWImeWcqOiuvuiuoemAkuW9kuWHveaVsOaXtu+8jOW6lOazqOaEj++8mlxyXG4g77yIMe+8iemmluWFiOW6lOS5puWGmeWHveaVsOeahOmmlumDqOWSjOinhOagvOivtOaYju+8jOS4peagvOWumuS5ieWHveaVsOeahOWKn+iDveWSjOaOpeWPo++8iOmAkuW9kuiwg+eUqOeahOeVjOmdou+8ie+8jOWvueaxgueyvuWHveaVsOS4reaJgOW+l+eahOWSjOWOn+mXrumimOaAp+i0qOebuOWQjOeahOWtl+mXrumimO+8jOWPquimgeaOpeWPo+S4gOiHtO+8jOS+v+WPr+i/m+ihjOmAkuW9kuiwg+eUqOOAglxyXG4g77yIMu+8ieWvueWHveaVsOS4reeahOavj+S4gOS4qumAkuW9kuiwg+eUqOmDveeci+aIkOWPquaYr+S4gOS4queugOWNleeahOaTjeS9nO+8jOWPquimgeaOpeWPo+S4gOiHtO+8jOW/heiDveWunueOsOinhOagvOivtOaYjuS4reWumuS5ieeahOWKn+iDve+8jOWIh+W/jOaDs+W+l+Wkqua3seWkqui/nOOAglxyXG4gKi9cclxuXHJcbi8qXHJcbiDmsYLlub/kuYnooajnmoTmt7HluqZcclxuXHJcbiDlub/kuYnooajnmoTmt7HluqblrprkuYnkuLrlub/kuYnooajkuK3mi6zlvKfnmoTph43mlbDvvIzmmK/lub/kuYnooajnmoTkuIDnp43ph4/luqbjgIJcclxuIOiuvumdnuepuuW5v+S5ieihqOS4ujpcclxuIExTID0gKGExLCBhMiwgLi4uLCBhbilcclxuXHJcbiDlhbbkuK1haShpID0gMSwgMiwgLi4uLCBuKeaIluS4uuWOn+WtkOaIluS4ukxT55qE5a2Q6KGo77yM5YiZ5rGCTFPnmoTmt7Hluqblj6/liIbop6PkuLpu5Liq5a2Q6Zeu6aKY77yM5q+P5Liq5a2Q6Zeu6aKY5Li65rGCYWnnmoTmt7HluqbvvIzoi6VhaeaYr+WOn+WtkO+8jOWImeeUseWumuS5ieWFtua3seW6puS4uumbtu+8jOiLpWFp5piv5bm/5LmJ6KGo77yM5YiZ6YCS5b2S5aSE55CG77yM6ICMTFPnmoTmt7HluqbkuLrlkIRhaShpID0gMSwgMiwgLi4uLCBuKeeahOa3seW6puacgOWkp+WAvOWKoDEu56m66KGo5Lmf5piv5bm/5LmJ6KGo77yM5LiU5rex5bqm5Li6MS5cclxuXHJcbiDlub/kuYnooajnmoTmt7HluqZERVBUSChMUynnmoTpgJLlvZLlrprkuYnkuLrvvJpcclxuIOWfuuacrOmhue+8miAgICBERVBUSChMUykgPSAxICAg5b2TTFPkuLrnqbrooajml7ZcclxuIERFUFRIKExTKSA9IDAgICDlvZNMU+S4uuWOn+WtkOaXtlxyXG4g5b2S57qz6aG577yaICAgIERFUFRIKExTKSA9IDEgKyBNQVh7REVQVEgoYWkpfSAgMSA8PSBpIDw9IG5cclxuICovXHJcblxyXG5jb25zdCBBVE9NID0gU3ltYm9sKCk7XHJcbmNvbnN0IExJU1QgPSBTeW1ib2woKTtcclxuXHJcbmxldCBnbG9iYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG4vLyDkvb/nlKjpk77pmJ/liJdcclxuaW1wb3J0IFF1ZXVlIGZyb20gJy4uL1F1ZXVlL1F1ZXVlLmpzJztcclxuXHJcbi8vIOW5v+S5ieihqOeahOWktOWwvumTvuihqOWtmOWCqOihqOekulxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHTE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICAvLyDlhazlhbHpg6jliIbvvIznlKjkuo7ljLrliIbljp/lrZDnu5Pngrnlkozooajnu5PngrlcclxuICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gYXRvbeaYr+WOn+WtkOe7k+eCueeahOWAvOWfn1xyXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XHJcbiAgICAgICAgLy8gcHRy5piv6KGo57uT54K555qE5oyH6ZKI5Z+fXHJcbiAgICAgICAgdGhpcy5wdHIgPSB7XHJcbiAgICAgICAgICAgIC8vIHB0ci5ocOWSjHB0ci50cOWIhuWIq+aMh+WQkeihqOWktOWSjOihqOWwvlxyXG4gICAgICAgICAgICBocDogbnVsbCxcclxuICAgICAgICAgICAgdHA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOmHh+eUqOWktOWwvumTvuihqOWtmOWCqOe7k+aehO+8jOaxguW5v+S5ieihqOeahOa3seW6plxyXG4gICAgZGVwdGggKCl7XHJcbiAgICAgICAgcmV0dXJuIGdldERlcHRoKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWkjeWItuW5v+S5ieihqFxyXG4gICAgY29weUxpc3QgKGdMaXN0KSB7XHJcbiAgICAgICAgZ0xpc3QudGFnID0gdGhpcy50YWc7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gQVRPTSkge1xyXG4gICAgICAgICAgICBnTGlzdC5hdG9tID0gdGhpcy5hdG9tO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ci5ocCkge1xyXG4gICAgICAgICAgICAgICAgZ0xpc3QucHRyLmhwID0gbmV3IEdMTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIuaHAuY29weUxpc3QoZ0xpc3QucHRyLmhwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wdHIudHApIHtcclxuICAgICAgICAgICAgICAgIGdMaXN0LnB0ci50cCA9IG5ldyBHTE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyLnRwLmNvcHlMaXN0KGdMaXN0LnB0ci50cCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6YeH55So5aS05bC+6ZO+6KGo5a2Y5YKo57uT5p6E77yM55Sx5bm/5LmJ6KGo55qE5Lmm5YaZ5b2i5byP5Liy5Yib5bu65bm/5LmJ6KGoXHJcbiAgICBjcmVhdGVHTGlzdCAoc3RyaW5nKSB7XHJcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcclxuXHJcbiAgICAgICAgLy8g5Yib5bu65Y2V5Y6f5a2Q5bm/5LmJ6KGoXHJcbiAgICAgICAgbGV0IHE7XHJcbiAgICAgICAgaWYgKGlzV29yZChzdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnID0gQVRPTTtcclxuICAgICAgICAgICAgdGhpcy5hdG9tID0gc3RyaW5nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnID0gTElTVDtcclxuICAgICAgICAgICAgbGV0IHAgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8g6ISx5aSW5bGC5ous5Y+3XHJcbiAgICAgICAgICAgIGxldCBzdWIgPSBzdHJpbmcuc3Vic3RyKDEsIHN0cmluZy5sZW5ndGggLSAyKTtcclxuXHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGxldCBoc3ViO1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSBzdWIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoO1xyXG5cclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBjaCA9IHN1YltpKytdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSAnKCcpICsraztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PSAnKScpIC0taztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBuICYmIChjaCAhPSAnLCcgfHwgayAhPSAwKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaeS4uuesrOS4gOS4qumAl+WPt+WIhumalOe0ouW8lVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHN1YiA9IHN1Yi5zdWJzdHIoMCwgaSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IHN1Yi5zdWJzdHIoaSwgbiAtIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDmnIDlkI7kuIDnu4RcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHN1YiA9IHN1YjtcclxuICAgICAgICAgICAgICAgICAgICBzdWIgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihoc3ViID09PSAnKCknKSBwLnB0ci5ocCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyDliJvlu7rooajlpLTnu5PngrlcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAucHRyLmhwID0gbmV3IEdMTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAucHRyLmhwLmNyZWF0ZUdMaXN0KGhzdWIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHEgPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIOWIm+W7uuihqOWwvue7k+eCuVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgR0xOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcC50YWcgPSBMSVNUO1xyXG4gICAgICAgICAgICAgICAgICAgIHEucHRyLnRwID0gcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAoc3ViKTtcclxuXHJcbiAgICAgICAgICAgIHEucHRyLnRwID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGVxdWFsKGdMaXN0MSwgZ0xpc3QyKSB7XHJcbiAgICAgICAgLy8g56m66KGo5pe255u4562J55qEXHJcbiAgICAgICAgaWYgKCFnTGlzdDEgJiYgIWdMaXN0MikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKGdMaXN0MS50YWcgPT09IEFUT00gJiYgZ0xpc3QyLnRhZyA9PT0gQVRPTSAmJiBnTGlzdDEuYXRvbSA9PT0gZ0xpc3QyLmF0b20pIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoZ0xpc3QxLnRhZyA9PT0gTElTVCAmJiBnTGlzdDIudGFnID09PSBMSVNUKSB7XHJcbiAgICAgICAgICAgIC8vIOihqOWktOihqOWwvumDveebuOetiVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbChnTGlzdDEucHRyLmhwLCBnTGlzdDIucHRyLmhwKSAmJiB0aGlzLmVxdWFsKGdMaXN0MS5wdHIudHAsIGdMaXN0Mi5wdHIudHApKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDpgJLlvZLpgIbovazlub/kuYnooahcclxuICAgIHJldmVyc2UoKSB7XHJcbiAgICAgICAgbGV0IHB0ciA9IFtdO1xyXG4gICAgICAgIC8vIOW9k0HkuI3kuLrljp/lrZDkuJTooajlsL7pnZ7nqbrml7bmiY3pnIDpgIbovaxcclxuICAgICAgICBpZiAodGhpcy50YWcgPT09IExJU1QgJiYgdGhpcy5wdHIudHApIHtcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwLCBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIOmAhui9rOWQhOWtkOihqFxyXG4gICAgICAgICAgICAgICAgaWYgKHAucHRyLmhwKSBwLnB0ci5ocC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcHRyW2ldID0gcC5wdHIuaHA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOmHjeaWsOaMiemAhuW6j+aOkuWIl+WQhOWtkOihqOeahOmhuuW6j1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKVxyXG4gICAgICAgICAgICAgICAgcC5wdHIuaHAgPSBwdHJbLS1pXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGxldCBzdHIgPSAnJztcclxuICAgICAgICBpZiAodGhpcyA9PSBnbG9iYWwgfHwgdGhpcyA9PSBudWxsKSBzdHIgPSAnKCknO1xyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFnID09PSBBVE9NKSBzdHIgPSB0aGlzLmF0b207ICAvLyDljp/lrZBcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RyICs9ICcoJztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApIHtcclxuICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnRvU3RyaW5nLmNhbGwocC5wdHIuaHApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAucHRyLnRwKSBzdHIgKz0gJywgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHIgKz0gJyknO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmjInlsYLluo/ovpPlh7rlub/kuYnooahcclxuICAgIC8vIOWxguW6j+mBjeWOhueahOmXrumimO+8jOS4gOiIrOmDveaYr+WAn+WKqemYn+WIl+adpeWujOaIkOeahO+8jOavj+asoeS7jumYn+WktFxyXG4gICAgLy8g5Y+W5Ye65LiA5Liq5YWD57Sg55qE5ZCM5pe25oqK5a6D5LiL5LiA5bGC55qE5a2p5a2Q5o+S5YWl6Zif5bC+77yM6L+Z5piv5bGC5bqP6YGN5Y6G55qE5Z+65pys5oCd5oOzXHJcbiAgICBvcmRlclByaW50ICgpe1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IFtdO1xyXG4gICAgICAgIGZvcihsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCkgcXVldWUucHVzaChwKTtcclxuXHJcbiAgICAgICAgd2hpbGUocXVldWUubGVuZ3RoKXtcclxuICAgICAgICAgICAgbGV0IHIgPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZihyLnRhZyA9PT0gQVRPTSkgY29uc29sZS5sb2coci5hdG9tKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IociA9IHIucHRyLmhwOyByOyByID0gci5wdHIudHApXHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvcmRlclByaW50MiAoKXtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKSBxdWV1ZS5lblF1ZXVlKHApO1xyXG5cclxuICAgICAgICB3aGlsZShxdWV1ZS5zaXplKXtcclxuICAgICAgICAgICAgbGV0IHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIGlmKHIudGFnID09PSBBVE9NKSBjb25zb2xlLmxvZyhyLmF0b20pO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcihyID0gci5wdHIuaHA7IHI7IHIgPSByLnB0ci50cClcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyDlub/kuYnooajnmoTmianlsZXnur/mgKfpk77ooajlrZjlgqjooajnpLpcclxuY2xhc3MgR0xOb2RlMiB7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIC8vIOWFrOWFsemDqOWIhu+8jOeUqOS6juWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxyXG4gICAgICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvLyDljp/lrZDnu5PngrnnmoTlgLzln59cclxuICAgICAgICB0aGlzLmF0b20gPSBudWxsO1xyXG4gICAgICAgIC8vIOihqOe7k+eCueeahOihqOWktOaMh+mSiFxyXG4gICAgICAgIHRoaXMuaHAgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyDnm7jlvZPkuo7nur/mgKfpk77ooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XHJcbiAgICAgICAgdGhpcy50cCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlcHRoKGdMaXN0KSB7XHJcbiAgICBpZiAoIWdMaXN0KSByZXR1cm4gMTtcclxuICAgIGVsc2UgaWYgKGdMaXN0LnRhZyA9PT0gQVRPTSkgcmV0dXJuIDA7XHJcblxyXG4gICAgbGV0IG0gPSBnZXREZXB0aChnTGlzdC5wdHIuaHApICsgMTtcclxuICAgIGxldCBuID0gZ2V0RGVwdGgoZ0xpc3QucHRyLnRwKTtcclxuXHJcbiAgICByZXR1cm4gbSA+IG4gPyBtIDogbjtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNXb3JkKHN0cil7XHJcbiAgICByZXR1cm4gL15bXFx3LV0rJC8udGVzdChzdHIpO1xyXG59XHJcblxyXG5cclxuLypcclxuIG3lhYPlpJrpobnlvI/ooajnpLpcclxuXHJcbiDlpoLmnpznlKjnur/mgKfooajmnaXooajnpLos5YiZ5q+P5Liq5pWw5o2u5YWD57Sg6ZyA6KaBbSsx5Liq5pWw5o2u6aG577yM5Lul5a2Y5YKo5LiA5Liq57O75pWw5ZKMbeS4quaMh+aVsOWAvO+8jOi/meWwhuS6p+eUn+S4pOS4qumXrumimOOAglxyXG4g5LiA5piv5peg6K665aSa6aG55byP5Lit5ZCE6aG555qE5Y+Y5YWD5pWw5piv5aSa5piv5bCR77yM6Iul6YO95oyJbeS4quWPmOWFg+WIhumFjeWtmOWCqOepuumXtO+8jOWImeWwhumAoOaIkOa1qui0ue+8m+WPjeS5i++8jOiLpeaMieWQhOmhueWunumZheeahOWPmOWFg+aVsOWIhumFjeWtmOWCqOepuumXtO+8jOWwseS8mumAoOaIkOe7k+eCueeahOWkp+Wwj+S4jeWMgO+8jOe7meaTjeS9nOW4puadpeS4jeS+v+OAguS6jOaYr+WvuW3lgLzkuI3lkIznmoTlpJrpobnlvI/vvIznur/mgKfooajkuK3nmoTnu5PngrnlpKflsI/kuZ/kuI3lkIzvvIzov5nlkIzmoLflvJXotbflrZjlgqjnrqHnkIbnmoTkuI3kvr/jgIJcclxuIOaVheS4jemAguS6jueUqOe6v+aAp+ihqOihqOekuuOAglxyXG5cclxuIOS+i+WmguS4ieWFg+WkmumhueW8j++8mlxyXG4gUCh4LCB5LCB6KSA9IHgoMTApeSgzKXooMikgKyAyeCg2KXkoMyl6KDIpICsgM3goNSl5KDIpeigyKSArIHgoNCl5KDQpeiArIDJ5eiArIDE1XHJcblxyXG4g5aaC6Iul5pS55YaZ5Li677yaXHJcbiBQKHgsIHksIHopID0gKCh4KDEwKSArIDJ4KDYpKXkoMykgKyAzeCg1KXkoMikpeigyKSArICgoeCg0KSArIDZ4KDMpKXkoNCkgKyAyeSl6ICsgMTVcclxuXHJcbiDnlKjlub/kuYnooajooajnpLrvvJpcclxuIFAgPSB6KChBLCAyKSwgKEIsIDEpLCAoMTUsIDApKVxyXG4gQSA9IHkoKEMsIDMpLCAoRCwgMikpXHJcbiBCID0geSgoRSwgNCksIChGLCAxKSlcclxuIEMgPSB4KCgxLCAxMCksICgyLCA2KSlcclxuIEQgPSB4KCgzLCA1KSlcclxuIEUgPSB4KCgxLCA0KSwgKDYsIDMpKVxyXG4gRiA9IHgoKDIsIDApKVxyXG5cclxuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTVBOb2RlKCkge1xyXG4gICAgLy8g5Yy65YiG5Y6f5a2Q57uT54K55ZKM6KGo57uT54K5XHJcbiAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcclxuICAgIC8vIOaMh+aVsOWfn1xyXG4gICAgdGhpcy5leHAgPSAwO1xyXG5cclxuICAgIC8vIOezu+aVsOWfn1xyXG4gICAgdGhpcy5jb2VmID0gMDtcclxuICAgIC8vIOihqOe7k+eCueeahOihqOWktOaMh+mSiFxyXG4gICAgdGhpcy5ocCA9IG51bGw7XHJcblxyXG4gICAgLy8g55u45b2T5LqO57q/5oCn6KGo55qEbmV4dO+8jOaMh+WQkeS4i+S4gOS4quWFg+e0oOe7k+eCuVxyXG4gICAgdGhpcy50cCA9IG51bGw7XHJcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9HZW5lcmFsaXplZExpc3QvR0xpc3QuanNcbiAqKi8iLCIvKlxyXG4g6YK75o6l5aSa6YeN6KGoXHJcblxyXG4g6YK75o6l5aSa6YeN6KGoKEFkamFjZW5jeSBNdWx0aWxpc3Qp5piv5peg5ZCR5Zu+55qE5Y+m5LiA56eN6ZO+5byP5a2Y5YKo57uT5p6E44CCXHJcblxyXG4g6YK75o6l6KGo5piv5peg5ZCR5Zu+55qE5LiA56eN5pyJ5pWI55qE5a2Y5YKo57uT5p6E77yM5Zyo5peg5ZCR5Zu+55qE6YK75o6l6KGo5Lit77yM5LiA5p2h6L65KHYsdynnmoTkuKTkuKrooajnu5PngrnliIbliKvliJ3pgInlnKjku6V25ZKMd+S4uuWktOe7k+eCueeahOmTvuihqOS4re+8jOW+iOWuueaYk+axguW+l+mhtueCueWSjOi+ueeahOS/oeaBr++8jOS9huWcqOa2ieWPiuWIsOi+ueeahOaTjeS9nOS8muW4puadpeS4jeS+v+OAglxyXG5cclxuIOmCu+aOpeWkmumHjeihqOeahOe7k+aehOWSjOWNgeWtl+mTvuihqOexu+S8vO+8jOavj+adoei+ueeUqOS4gOS4que7k+eCueihqOekuu+8m+mCu+aOpeWkmumHjeihqOS4reeahOmhtueCuee7k+eCuee7k+aehOS4jumCu+aOpeihqOS4reeahOWujOWFqOebuOWQjO+8jOiAjOihqOe7k+eCueWMheaLrOWFreS4quWfn+OAglxyXG5cclxuIOKXhiAgRGF0YeWfn++8muWtmOWCqOWSjOmhtueCueebuOWFs+eahOS/oeaBr++8m1xyXG4g4peGIOaMh+mSiOWfn2ZpcnN0ZWRnZe+8muaMh+WQkeS+nemZhOS6juivpemhtueCueeahOesrOS4gOadoei+ueaJgOWvueW6lOeahOihqOe7k+eCue+8m1xyXG4g4peGIOagh+W/l+Wfn21hcmvvvJrnlKjku6XmoIfor4bor6XmnaHovrnmmK/lkKbooqvorr/pl67ov4fvvJtcclxuIOKXhiBpdmV45ZKManZleOWfn++8muWIhuWIq+S/neWtmOivpei+ueaJgOS+nemZhOeahOS4pOS4qumhtueCueWcqOWbvuS4reeahOS9jee9ru+8m1xyXG4g4peGIGluZm/ln5/vvJrkv53lrZjor6XovrnnmoTnm7jlhbPkv6Hmga/vvJtcclxuIOKXhiDmjIfpkojln59pbGlua++8muaMh+WQkeS4i+S4gOadoeS+nemZhOS6jumhtueCuWl2ZXjnmoTovrnvvJtcclxuIOKXhiDmjIfpkojln59qbGlua++8muaMh+WQkeS4i+S4gOadoeS+nemZhOS6jumhtueCuWp2ZXjnmoTovrnvvJtcclxuXHJcbiDpgrvmjqXlpJrph43ooajkuI7pgrvmjqXooajnmoTljLrliKvvvJpcclxuIOWQjuiAheeahOWQjOS4gOadoei+ueeUqOS4pOS4quihqOe7k+eCueihqOekuu+8jOiAjOWJjeiAheWPqueUqOS4gOS4quihqOe7k+eCueihqOekuu+8m+mZpOagh+W/l+Wfn+Wklu+8jOmCu+aOpeWkmumHjeihqOS4jumCu+aOpeihqOihqOi+vueahOS/oeaBr+aYr+ebuOWQjOeahO+8jOWboOatpO+8jOaTjeS9nOeahOWunueOsOS5n+WfuuacrOebuOS8vOOAglxyXG5cclxuICovXHJcblxyXG5jb25zdCBVTlZJU0lURUQgPSAwO1xyXG5jb25zdCBWSVNJVEVEID0gMTtcclxuXHJcblxyXG5jbGFzcyBFQm94IHtcclxuICAgIC8qKlxyXG4gICAgICog6L6555qE57uT54K56KGo56S6XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWFyayDorr/pl67moIforrAgMCAtLSDmnKrorr/pl64gIDEgPT0g5bey6K6/6ZeuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaXZleCDor6Xovrnkvp3pmYTnmoTkuKTkuKrpobbngrnnmoTkvY3nva5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBqdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxyXG4gICAgICogQHBhcmFtIHtFQm94fSBpbGluayDliIbliKvmjIflkJHkvp3pmYTov5nkuKTkuKrpobbngrnnmoTkuIvkuIDmnaHovrlcclxuICAgICAqIEBwYXJhbSB7RUJveH0gamxpbmsg5YiG5Yir5oyH5ZCR5L6d6ZmE6L+Z5Lik5Liq6aG254K555qE5LiL5LiA5p2h6L65XHJcbiAgICAgKiBAcGFyYW0geyp9IGluZm8g6K+l6L655L+h5oGvXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWFyaywgaXZleCwganZleCwgaWxpbmssIGpsaW5rLCBpbmZvKXtcclxuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrIHx8IFVOVklTSVRFRDtcclxuICAgICAgICB0aGlzLml2ZXggPSBpdmV4IHx8IDA7XHJcbiAgICAgICAgdGhpcy5qdmV4ID0ganZleCB8fCAwO1xyXG4gICAgICAgIHRoaXMuaWxpbmsgPSBpbGluayB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuamxpbmsgPSBqbGluayB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgQU1MVmV4Qm94IHtcclxuICAgIC8qKlxyXG4gICAgICog6aG254K555qE57uT54K56KGo56S6XHJcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcclxuICAgICAqIEBwYXJhbSB7RUJveH0gZmlyc3RFZGdlIOaMh+WQkeesrOS4gOadoeS+nemZhOivpemhtueCueeahOi+uVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGZpcnN0RWRnZSl7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZmlyc3RFZGdlID0gZmlyc3RFZGdlIHx8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFNTEdyYXBoIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBBTUxWZXhCb3h9IGFkak11bGlzdFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2VudW1cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZGpNdWxpc3QsIHZleG51bSwgZWRnZW51bSl7XHJcbiAgICAgICAgdGhpcy5hZGpNdWxpc3QgPSBhZGpNdWxpc3QgfHwgW107XHJcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW0gfHwgMDtcclxuICAgICAgICB0aGlzLmVkZ2VudW0gPSBlZGdlbnVtIHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgbG9jYXRlVmV4ICh2KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkak11bGlzdFtpXS5kYXRhID09PSB2KSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZUFyYyh2LCB3KSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcclxuICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KHcpO1xyXG5cclxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHRocm93IG5ldyBFcnJvcignVmVydGV4IG5vdCBmb3VuZCEnKTtcclxuXHJcbiAgICAgICAgdmFyIHA7XHJcbiAgICAgICAgLy8g5ZyoaemTvuihqOS4reWIoOmZpOivpei+uVxyXG4gICAgICAgIGlmICh0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UuanZleCA9PT0gaikge1xyXG4gICAgICAgICAgICB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UgPSB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UuaWxpbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChwID0gdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlOyBwICYmIHAuaWxpbmsuanZleCAhPT0gajsgcCA9IHAuaWxpbmspO1xyXG4gICAgICAgICAgICBpZiAoIXApIHRocm93IG5ldyBFcnJvcignZWRnZSBub3QgZm91bmQhJyk7XHJcbiAgICAgICAgICAgIHAuaWxpbmsgPSBwLmlsaW5rLmlsaW5rO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5ZyoaumTvuihqOS4reWIoOmZpOivpei+uVxyXG4gICAgICAgIGlmICh0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UuaXZleCA9PT0gaSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UgPSB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2Uuamxpbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChwID0gdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlOyBwICYmIHAuamxpbmsuaXZleCAhPT0gaTsgcCA9IHAuamxpbmspO1xyXG4gICAgICAgICAgICBpZiAoIXApIHRocm93IG5ldyBFcnJvcignZWRnZSBub3QgZm91bmQhJyk7XHJcbiAgICAgICAgICAgIHAuamxpbmsgPSBwLmpsaW5rLmpsaW5rO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lZGdlbnVtLS07XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlR3JhcGgoKSB7XHJcbiAgICAgICAgdmFyIHZleG51bSA9ICtwcm9tcHQoJ3ZleG51bTogJyk7XHJcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW07XHJcbiAgICAgICAgdmFyIGVkZ2VudW0gPSArcHJvbXB0KCdlZGdlbnVtOiAnKTtcclxuICAgICAgICB0aGlzLmVkZ2VudW0gPSBlZGdlbnVtO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHZleG51bTsgKyttKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W21dID0gbmV3IEFNTFZleEJveChwcm9tcHQoJ2RhdGE6ICcpLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobSA9IDA7IG0gPCBlZGdlbnVtOyArK20pIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBwcm9tcHQoJ3RhaWxWZXg6ICcpO1xyXG4gICAgICAgICAgICB2YXIgaCA9IHByb21wdCgnaGVhZFZleDogJyk7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5sb2NhdGVWZXgodCk7XHJcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgoaCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3ZlcnRleCBub3QgZm91bmQhIFRyeSBhZ2FpbjonKTtcclxuICAgICAgICAgICAgICAgIG0tLTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBFQm94KDAsIGksIGosIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgcSwgcjtcclxuXHJcbiAgICAgICAgICAgIC8vIOaPkuWFpWnpk77ooajlsL7pg6hcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSA9IHA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHEpIHtcclxuICAgICAgICAgICAgICAgICAgICByID0gcTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocS5pdmV4ID09PSBpKSBxID0gcS5pbGluaztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHEgPSBxLmpsaW5rO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHIuaXZleCA9PT0gaSkgci5pbGluayA9IHA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHIuamxpbmsgPSBwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDmj5LlhaVq6ZO+6KGo5bC+6YOoXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UgPSBwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcSA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuanZleCA9PT0gaikgcSA9IHEuamxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxID0gcS5pbGluaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyLmp2ZXggPT09IGopIHIuamxpbmsgPSBwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSByLmlsaW5rID0gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy92YXIgZyA9IG5ldyBBTUxHcmFwaCgpO1xyXG4vL2cuY3JlYXRlR3JhcGgoKTtcclxuLy9jb25zb2xlLmxvZyhnKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvR3JhcGgvQU1MR3JhcGguanNcbiAqKi8iLCIvKiBDcmVhdGUgQnkgTHVrZSAqL1xyXG5cclxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcclxuaW1wb3J0IFF1ZXVlIGZyb20gJy4uL1F1ZXVlL1F1ZXVlJztcclxuaW1wb3J0IHsgQ2hpbGRTaWJsaW5nVHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XHJcblxyXG4vLyDlm77nmoTmlbDnu4TvvIjpgrvmjqXnn6npmLXvvInlrZjlgqjooajnpLpcclxuY29uc3QgREcgPSAxOyAgICAgLy8g5pyJ5ZCR5Zu+XHJcbmNvbnN0IEROID0gMjsgICAgIC8vIOacieWQkee9kVxyXG5jb25zdCBVREcgPSAzOyAgICAvLyDml6DlkJHlm75cclxuY29uc3QgVUROID0gNDsgICAgLy8g5peg5ZCR572RXHJcblxyXG5cclxuLypcclxuIOmCu+aOpemTvuihqOazlVxyXG5cclxuIOWfuuacrOaAneaDs++8muWvueWbvueahOavj+S4qumhtueCueW7uueri+S4gOS4quWNlemTvuihqO+8jOWtmOWCqOivpemhtueCueaJgOaciemCu+aOpemhtueCueWPiuWFtuebuOWFs+S/oeaBr+OAguavj+S4gOS4quWNlemTvuihqOiuvuS4gOS4quihqOWktOe7k+eCueOAglxyXG5cclxuIOesrGnkuKrljZXpk77ooajooajnpLrkvp3pmYTkuo7pobbngrlWaeeahOi+uSjlr7nmnInlkJHlm77mmK/ku6XpobbngrlWaeS4uuWktOaIluWwvueahOW8pynjgIJcclxuXHJcbiAxICDnu5Pngrnnu5PmnoTkuI7pgrvmjqXpk77ooajnpLrkvotcclxuXHJcbiDpk77ooajkuK3nmoTnu5Pngrnnp7DkuLrooajnu5PngrnvvIzmr4/kuKrnu5PngrnnlLHkuInkuKrln5/nu4TmiJDjgILlhbbkuK3pgrvmjqXngrnln58oYWRqdmV4KeaMh+ekuuS4jumhtueCuVZp6YK75o6l55qE6aG254K55Zyo5Zu+5Lit55qE5L2N572uKOmhtueCuee8luWPtynvvIzpk77ln58obmV4dGFyYynmjIflkJHkuIvkuIDkuKrkuI7pobbngrlWaemCu+aOpeeahOihqOe7k+eCue+8jOaVsOaNruWfnyhpbmZvKeWtmOWCqOWSjOi+ueaIluW8p+ebuOWFs+eahOS/oeaBr++8jOWmguadg+WAvOetieOAguWvueS6juaXoOadg+Wbvu+8jOWmguaenOayoeacieS4jui+ueebuOWFs+eahOWFtuS7luS/oeaBr++8jOWPr+ecgeeVpeatpOWfn+OAglxyXG5cclxuIOavj+S4qumTvuihqOiuvuS4gOS4quihqOWktOe7k+eCuSjnp7DkuLrpobbngrnnu5Pngrkp77yM55Sx5Lik5Liq5Z+f57uE5oiQ44CC6ZO+5Z+fKGZpcnN0YXJjKeaMh+WQkemTvuihqOS4reeahOesrOS4gOS4que7k+eCue+8jOaVsOaNruWfnyhkYXRhKSDlrZjlgqjpobbngrnlkI3miJblhbbku5bkv6Hmga/jgIJcclxuXHJcbiDlnKjlm77nmoTpgrvmjqXpk77ooajooajnpLrkuK3vvIzmiYDmnInpobbngrnnu5PngrnnlKjkuIDkuKrlkJHph48g5Lul6aG65bqP57uT5p6E5b2i5byP5a2Y5YKo77yM5Y+v5Lul6ZqP5py66K6/6Zeu5Lu75oSP6aG254K555qE6ZO+6KGo77yM6K+l5ZCR6YeP56ew5Li66KGo5aS05ZCR6YeP77yM5ZCR6YeP55qE5LiL5qCH5oyH56S66aG254K555qE5bqP5Y+344CCXHJcblxyXG4g55So6YK75o6l6ZO+6KGo5a2Y5YKo5Zu+5pe277yM5a+55peg5ZCR5Zu+77yM5YW26YK75o6l6ZO+6KGo5piv5ZSv5LiA55qE77yb5a+55pyJ5ZCR5Zu+77yM5YW26YK75o6l6ZO+6KGo5pyJ5Lik56eN5b2i5byP44CCXHJcblxyXG5cclxuIDIgIOmCu+aOpeihqOazleeahOeJueeCuVxyXG5cclxuIOKXhiDooajlpLTlkJHph4/kuK3mr4/kuKrliIbph4/lsLHmmK/kuIDkuKrljZXpk77ooajnmoTlpLTnu5PngrnvvIzliIbph4/kuKrmlbDlsLHmmK/lm77kuK3nmoTpobbngrnmlbDnm67vvJtcclxuIOKXhiDlnKjovrnmiJblvKfnqIDnlo/nmoTmnaHku7bkuIvvvIznlKjpgrvmjqXooajooajnpLrmr5TnlKjpgrvmjqXnn6npmLXooajnpLroioLnnIHlrZjlgqjnqbrpl7TvvJtcclxuIOKXhiDlnKjml6DlkJHlm77vvIzpobbngrlWaeeahOW6puaYr+esrGnkuKrpk77ooajnmoTnu5PngrnmlbDvvJtcclxuIOKXhiDlr7nmnInlkJHlm77lj6/ku6Xlu7rnq4vmraPpgrvmjqXooajmiJbpgIbpgrvmjqXooajjgILmraPpgrvmjqXooajmmK/ku6XpobbngrlWaeS4uuWHuuW6pijljbPkuLrlvKfnmoTotbfngrkp6ICM5bu656uL55qE6YK75o6l6KGo77yb6YCG6YK75o6l6KGo5piv5Lul6aG254K5VmnkuLrlhaXluqYo5Y2z5Li65byn55qE57uI54K5KeiAjOW7uueri+eahOmCu+aOpeihqO+8m1xyXG4g4peGIOWcqOacieWQkeWbvuS4re+8jOesrGnkuKrpk77ooajkuK3nmoTnu5PngrnmlbDmmK/pobbngrlWaeeahOWHuiAo5oiW5YWlKeW6pu+8m+axguWFpSAo5oiW5Ye6KeW6pu+8jOmhu+mBjeWOhuaVtOS4qumCu+aOpeihqO+8m1xyXG4g4peGIOWcqOmCu+aOpeihqOS4iuWuueaYk+aJvuWHuuS7u+S4gOmhtueCueeahOesrOS4gOS4qumCu+aOpeeCueWSjOS4i+S4gOS4qumCu+aOpeeCue+8m1xyXG5cclxuICovXHJcblxyXG5cclxuY2xhc3MgQXJjTm9kZSB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWRqVmV4XHJcbiAgICAgKiBAcGFyYW0ge0FyY05vZGV9IG5leHRBcmNcclxuICAgICAqIEBwYXJhbSB7Kn0gaW5mb1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFkalZleCA9IDAsIG5leHRBcmMgPSBudWxsLCBpbmZvID0gbnVsbCl7XHJcbiAgICAgICAgLy8g6K+l5byn5omA5oyH5ZCR55qE6aG254K555qE5L2N572uXHJcbiAgICAgICAgdGhpcy5hZGpWZXggPSBhZGpWZXg7XHJcbiAgICAgICAgLy8g5oyH5ZCR5LiL5LiA5p2h5byn55qE5oyH6ZKIXHJcbiAgICAgICAgdGhpcy5uZXh0QXJjID0gbmV4dEFyYztcclxuICAgICAgICAvLyDor6XlvKfnm7jlhbPkv6Hmga/nmoTmjIfpkohcclxuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBWZXhOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gICAgICogQHBhcmFtIHtBcmNOb2RlfSBmaXJzdEFyY1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGVncmVlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZmlyc3RBcmMgPSBudWxsLCBpbmRlZ3JlZSA9IDApe1xyXG4gICAgICAgIC8vIOmhtueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgLy8g5oyH5ZCR56ys5LiA5p2h5L6d6ZmE6K+l6aG254K555qE5byn55qE5oyH6ZKIXHJcbiAgICAgICAgdGhpcy5maXJzdEFyYyA9IGZpcnN0QXJjO1xyXG4gICAgICAgIC8vICDpobbngrnnmoTluqYsIOacieWQkeWbvuaYr+WFpeW6puaIluWHuuW6puaIluayoeaciVxyXG4gICAgICAgIHRoaXMuaW5kZWdyZWUgPSBpbmRlZ3JlZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRqYWNlbmN5TGlzdEdyYXBoIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBWZXhOb2RlfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyY251bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtpbmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcyA9IFtdLCB2ZXhudW0gPSAwLCBhcmNudW0gPSAwLCBraW5kID0gREcpe1xyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuICAgICAgICAvLyDlm77nmoTlvZPliY3pobbngrnmlbDlkozlvKfmlbBcclxuICAgICAgICB0aGlzLnZleG51bSA9IHZleG51bTtcclxuICAgICAgICB0aGlzLmFyY251bSA9IGFyY251bTtcclxuICAgICAgICAvLyDlm77nmoTnp43nsbvmoIflv5dcclxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOafpeaJvumhtueCueS9jee9rlxyXG4gICAgbG9jYXRlVmV4KHZwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2VzW2ldLmRhdGEgPT09IHZwKSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmt7vliqDpobbngrlcclxuICAgIGFkZFZlcnRleCh2cCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvY2F0ZVZleCh2cCkgIT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBoYXMgZXhpc3RlZCEnKTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZleG51bSsrXSA9IG5ldyBWZXhOb2RlKHZwLCBudWxsLCAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy52ZXhudW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDlvKdcclxuICAgICAqIOWmguaenOaYr+aXoOWQkeWbvuaIluiAheaXoOWQkee9kSxhcmMx5ZKMYXJjMuaXoOmhuuW6j+imgeaxglxyXG4gICAgICog5aaC5p6c5piv5pyJ5ZCR5Zu+5oiW6ICF5pyJ5ZCR572R77yM5Y+q5Lya5re75YqgYXJjMe+8jOWboOatpOato+mCu+aOpeihqOWSjOmAhumCu+aOpeihqOeahOmhuuW6j+mcgOimgeazqOaEj1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyYzFcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmMyXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBhZGRBcmMoYXJjMSwgYXJjMiwgaW5mbykge1xyXG4gICAgICAgIGxldCBrID0gdGhpcy5sb2NhdGVWZXgoYXJjMSk7XHJcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleChhcmMyKTtcclxuXHJcbiAgICAgICAgaWYgKGsgPT09IC0xIHx8IGogPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0FyY1xcJ3MgVmVydGV4IGRvIG5vdCBleGlzdGVkIScpO1xyXG5cclxuICAgICAgICAvLyDovrnnmoTotbflp4vooajnu5PngrnotYvlgLxcclxuICAgICAgICBsZXQgcCA9IG5ldyBBcmNOb2RlKGssIG51bGwsIGluZm8pO1xyXG4gICAgICAgIC8vIOi+ueeahOacq+WwvuihqOe7k+eCuei1i+WAvFxyXG4gICAgICAgIGxldCBxID0gbmV3IEFyY05vZGUoaiwgbnVsbCwgaW5mbyk7XHJcblxyXG4gICAgICAgIC8vIOaYr+aXoOWQkeWbvu+8jOeUqOWktOaPkuWFpeazleaPkuWFpeWIsOS4pOS4quWNlemTvuihqFxyXG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFVERyB8fCB0aGlzLmtpbmQgPT09IFVETikge1xyXG4gICAgICAgICAgICBxLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2tdLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2tdLmZpcnN0QXJjID0gcTtcclxuICAgICAgICAgICAgcC5uZXh0QXJjID0gdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYztcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYyA9IHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW7uueri+acieWQkeWbvueahOmCu+aOpemTvuihqO+8jOeUqOWktOaPkuWFpeazlVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjID0gcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICsrdGhpcy5hcmNudW07XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8g5YW25LuW5Zu+57G75Z6L55qE5Yib5bu65pqC5pe25rKh5byEXHJcbiAgICBjcmVhdGVHcmFwaCgpIHtcclxuICAgICAgICB0aGlzLnZleG51bSA9ICtwcm9tcHQoJ3ZleG51bTogJyk7XHJcbiAgICAgICAgdGhpcy5hcmNudW0gPSArcHJvbXB0KCdhcmNudW06ICcpO1xyXG4gICAgICAgIC8vIGluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXHJcbiAgICAgICAgbGV0IGluY0luZm8gPSArcHJvbXB0KCdpbmNJbmZvOiAnKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCB0aGlzLnZleG51bTsgKyttKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbbV0gPSBuZXcgVmV4Tm9kZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW21dLmRhdGEgPSBwcm9tcHQoJ3ZlcnRleDogJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKG0gPSAwOyBtIDwgdGhpcy5hcmNudW07ICsrbSkge1xyXG4gICAgICAgICAgICBsZXQgaCA9IHByb21wdCgn5byn5aS0OiAnKTtcclxuICAgICAgICAgICAgbGV0IHQgPSBwcm9tcHQoJ+W8p+WwvjogJyk7XHJcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5sb2NhdGVWZXgodCk7XHJcbiAgICAgICAgICAgIGxldCBqID0gdGhpcy5sb2NhdGVWZXgoaCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KCfpobbngrnkuLrmib7liLDvvIzor7fph43mlrDovpPlhaXvvIEnKTtcclxuICAgICAgICAgICAgICAgIG0tLTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBBcmNOb2RlKGosIG51bGwsIGluY0luZm8gJiYgcHJvbXB0KCdpbmZvOiAnKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmVydGljZXNbaV0uZmlyc3RBcmMpIHRoaXMudmVydGljZXNbaV0uZmlyc3RBcmMgPSBwO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHEgPSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBxLm5leHRBcmM7IHEgPSBxLm5leHRBcmMpO1xyXG4gICAgICAgICAgICAgICAgcS5uZXh0QXJjID0gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDliKTmlq3kuIDkuKrpgrvmjqXooajlrZjlgqjnmoTmnInlkJHlm77mmK/lkKblj6/kvKDpgJJcclxuICAgIGlzUGFzcygpIHtcclxuICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMudmV4bnVtOyArK3gpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbeF0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBxID0gdGhpcy52ZXJ0aWNlc1t5XS5maXJzdEFyYzsgcTsgcSA9IHEubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB6ID0gcS5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHogIT09IHggJiYgdGhpcy5pc0Fkaih4LCB6KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDliKTmlq3mnInlkJHlm77mmK/lkKblrZjlnKjovrkobSxuKVxyXG4gICAgaXNBZGoobSwgbikge1xyXG4gICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW21dLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgIGlmIChwLmFkalZleCA9PT0gbikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa3seW6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpcclxuICAgICAqL1xyXG4gICAgZXhpc3RfcGF0aF9ERlMoaSwgaikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KGkpO1xyXG4gICAgICAgIGogPSB0aGlzLmxvY2F0ZVZleChqKTtcclxuXHJcbiAgICAgICAgaWYgKGkgPCAwIHx8IGogPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRleCBub3QgZm91bmQhJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBleGlzdF9wYXRoKHRoaXMsIGksIGopO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBleGlzdF9wYXRoKGdyYXBoLCBpLCBqKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBqKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRba10gJiYgZXhpc3RfcGF0aChncmFwaCwgaywgaikpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bm/5bqm5LyY5YWI5Yik5patPGI+5pyJ5ZCR5Zu+PGI+55qE6aG254K5aeWIsOmhtueCuWrmmK/lkKbmnInot6/lvoTvvIzlrp7liJnov5Tlm550cnVl77yM5ZCm5YiZ6L+U5ZueZmFsc2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxyXG4gICAgICovXHJcbiAgICBleGlzdF9wYXRoX0JGUyhpLCBqKSB7XHJcbiAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KGkpO1xyXG4gICAgICAgIGogPSB0aGlzLmxvY2F0ZVZleChqKTtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XHJcblxyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XHJcbiAgICAgICAgICAgIGxldCB1ID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgICAgICB2aXNpdGVkW3VdID0gMTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09IGopIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2tdKSBxdWV1ZS5lblF1ZXVlKGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq3pgrvmjqXooajmlrnlvI/lrZjlgqjnmoTmnInlkJHlm77nmoTpobbngrlp5YiwauaYr+WQpuWtmOWcqOmVv+W6puS4umvnmoTnroDljZXot6/lvoRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcclxuICAgICAqL1xyXG4gICAgZXhpc3RfcGF0aF9sZW4oaSwgaiwgaykge1xyXG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcclxuICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiByZWN1cnNlKGdyYXBoLCBpLCBqLCBrKSB7XHJcbiAgICAgICAgICAgIC8vIOaJvuWIsOS6huS4gOadoei3r+W+hO+8jOS4lOmVv+W6puespuWQiFxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaiAmJiBrID09PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoayA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5Ymp5L2Z6Lev5b6E6ZW/5bqm5YeP5LiAXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKGdyYXBoLCBsLCBqLCBrIC0gMSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOWFgeiuuOabvue7j+iiq+iuv+mXrui/h+eahOe7k+eCueWHuueOsOWcqOWPpuS4gOadoei3r+W+hOS4ilxyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KSh0aGlzLCBpLCBqLCBrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaxguacieWQkeWbvuS4remhtueCuXXliLB25LmL6Ze055qE5omA5pyJ566A5Y2V6Lev5b6E77yMa+S4uuW9k+WJjei3r+W+hOmVv+W6plxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgZ3JhcGguZmluZF9hbGxfcGF0aCgndjEnLCAndjInLCAwKTtcclxuICAgICAqL1xyXG4gICAgZmluZF9hbGxfcGF0aCh1LCB2LCBrKSB7XHJcbiAgICAgICAgdSA9IHRoaXMubG9jYXRlVmV4KHUpO1xyXG4gICAgICAgIHYgPSB0aGlzLmxvY2F0ZVZleCh2KTtcclxuICAgICAgICBsZXQgcGF0aCA9IFtdO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcblxyXG4gICAgICAgIGZpbmRQYXRoKHRoaXMsIHUsIHYsIGspO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBmaW5kUGF0aChncmFwaCwgdSwgdiwgaykge1xyXG4gICAgICAgICAgICAvLyDliqDlhaXlvZPliY3ot6/lvoTkuK1cclxuICAgICAgICAgICAgcGF0aFtrXSA9IHU7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdV0gPSAxO1xyXG5cclxuICAgICAgICAgICAgLy8g5om+5Yiw5LiA5p2h566A5Y2V6Lev5b6EXHJcbiAgICAgICAgICAgIGlmICh1ID09PSB2KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgb25lIHBhdGghJyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgcGF0aFtpXTsgKytpKSBjb25zb2xlLmxvZyhwYXRoW2ldKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t1XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g57un57ut5a+75om+XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSBmaW5kUGF0aChncmFwaCwgbCwgdiwgayArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2aXNpdGVkW3VdID0gMDtcclxuICAgICAgICAgICAgLy8g5Zue5rqvXHJcbiAgICAgICAgICAgIHBhdGhba10gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaxguacieWQkeWbvueahOmhtueCueS5i+mXtOmVv+W6puS4umxlbueahOeugOWNlei3r+W+hOadoeaVsFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuXHJcbiAgICAgKi9cclxuICAgIGdldFBhdGhOdW1fbGVuKGksIGosIGxlbikge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcblxyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gcmVjdXJzZShncmFwaCwgaSwgaiwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBqICYmIGxlbiA9PT0gMCkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtsXSkgc3VtICs9IHJlY3Vyc2UobCwgaiwgbGVuIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSh0aGlzLCBpLCBqLCBsZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rGC5pyJ5ZCR5peg546v5Zu+55qE5qC5XHJcbiAgICAgKi9cclxuICAgIGdldFJvb3QoKXtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICAvLyDmr4/mrKHpg73opoHlsIborr/pl67mlbDnu4TmuIXpm7ZcclxuICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB2aXNpdGVkW3ddID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIOS7jumhtueCuWnlh7rlj5Hov5vooYzmt7HluqbkvJjlhYjpgY3ljoZcclxuICAgICAgICAgICAgZGZzKHRoaXMsIGkpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KXtcclxuICAgICAgICAgICAgICAgIC8vIOWmguaenGnmmK/moLnvvIzliJnmt7HluqbkvJjlhYjpgY3ljoblj6/ku6Xorr/pl67liLDmiYDmnInnu5PngrlcclxuICAgICAgICAgICAgICAgIGlmKCF2aXNpdGVkW3ddKSBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGZsYWcpIGNvbnNvbGUubG9nKCdGb3VuZCBhIHJvb3QgdmVydGV4OiAlZCcsIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2KXtcclxuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdyA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYoIXZpc2l0ZWRbd10pIGRmcyhncmFwaCwgdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmsYLkuIDkuKrmnInlkJHml6Dnjq/lm77kuK3mnIDplb/nmoTot6/lvoRcclxuICAgICAqL1xyXG4gICAgZ2V0TG9uZ2VzdFBhdGgoKXtcclxuICAgICAgICBsZXQgbWxwID0gW107XHJcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBtYXhMZW4gPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmNvdW50SW5kZWdyZWUoKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB2aXNpdGVkW2pdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIOS7juavj+S4gOS4qumbtuWFpeW6pue7k+eCueW8gOWni+a3seW6puS8mOWFiOmBjeWOhlxyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc1tpXS5pbmRlZ3JlZSA9PT0gMCkgZGZzKHRoaXMsIGksIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xvbmdlc3QgUGF0aDonKTtcclxuICAgICAgICAvLyDovpPlh7rmnIDplb/ot6/lvoRcclxuICAgICAgICBmb3IoaSA9IDA7IG1scFtpXTsgKytpKSBjb25zb2xlLmxvZyhtbHAuam9pbignLCcpKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGZzKGdyYXBoLCBpLCBsZW4pe1xyXG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgcGF0aFtsZW5dID0gaTtcclxuXHJcbiAgICAgICAgICAgIC8vIOaWsOeahOacgOmVv+i3r+W+hFxyXG4gICAgICAgICAgICBpZihsZW4gPiBtYXhMZW4gJiYgIWdyYXBoLnZlcnRpY2VzW2ldLmZpcnN0QXJjKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDkv53lrZjkuIvmnaVcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPD0gbGVuOyArK2opIG1scFtqXSA9IHBhdGhbal07XHJcbiAgICAgICAgICAgICAgICBtYXhMZW4gPSBsZW47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHcgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgICAgICBpZighdmlzaXRlZFt3XSkgZGZzKGdyYXBoLCB3LCBsZW4gKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGF0aFtpXSA9IDA7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6YK75o6l6KGo55qE6YCS5b2S5byP5rex5bqm5LyY5YWI6YGN5Y6GXHJcbiAgICBERlNUcmF2ZXJzZSh2aXNpdEZuKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzKHRoaXMsIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2KSB7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB2aXNpdEZuLmNhbGwoZ3JhcGgsIHYpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcclxuICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIGRmcyhncmFwaCwgcC5hZGpWZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6YK75o6l6KGo55qE6Z2e6YCS5b2S5rex5bqm5LyY5YWI5pCc57SiXHJcbiAgICBERlNUcmF2ZXJzZV9Ob25SZWN1cnNlKHZpc2l0Rm4pIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHY7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHYgPSBzdGFjay5wZWVrKCkpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXMudmVydGljZXNbdl0uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuYWRqVmV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIHAuYWRqVmV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocC5hZGpWZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugc3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6YK75o6l6KGo55qE5bm/5bqm5LyY5YWI5pCc57SiXHJcbiAgICBCRlNUcmF2ZXJzZSh2aXNpdEZuKSB7XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHcgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzLnZlcnRpY2VzW3ddLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbcC5hZGpWZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBwLmFkalZleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAuYWRqVmV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5bu656uL5peg5ZCR5Zu+55qE5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6X55qE5a2p5a2Q5YWE5byf6ZO+6KGo5qCRXHJcbiAgICBjcmVhdGVERlNGb3Jlc3QoKSB7XHJcbiAgICAgICAgbGV0IHRyZWUgPSBudWxsO1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCBxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIOaWsOeahOeUn+aIkOagkeeahOaguee7k+eCuVxyXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBuZXcgQ2hpbGRTaWJsaW5nVHJlZSh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIOesrOS4gOajteeUn+aIkOagkeeahOaguVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gcDtcclxuICAgICAgICAgICAgICAgIC8vIOWFtuWug+eUn+aIkOagkeeahOaguVxyXG4gICAgICAgICAgICAgICAgZWxzZSBxLm5leHRTaWJsaW5nID0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBx5Li65b2T5YmN55Sf5oiQ5qCR55qE5qC5XHJcbiAgICAgICAgICAgICAgICBxID0gcDtcclxuICAgICAgICAgICAgICAgIC8vIOW7uueri+S7pXDkuLrmoLnnmoTnlJ/miJDmoJFcclxuICAgICAgICAgICAgICAgIERGU1RyZWUodGhpcywgaSwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG5cclxuICAgICAgICAvLyDku6XnrKx25Liq6aG254K56Kem5Y+R5rex5bqm5LyY5YWI6YGN5Y6G5Zu+77yM5bu656uL5LuldHJlZeS4uuagueeahOeUn+aIkOagkVxyXG4gICAgICAgIGZ1bmN0aW9uIERGU1RyZWUoZ3JhcGgsIHYsIHRyZWUpIHtcclxuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCB3ID0gZ3JhcGgudmVydGljZXNbdl0uZmlyc3RBcmM7XHJcbiAgICAgICAgICAgIGxldCBxO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3LmFkalZleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW3cuYWRqVmV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSBuZXcgQ2hpbGRTaWJsaW5nVHJlZShncmFwaC52ZXJ0aWNlc1t3LmFkalZleF0uZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHfmmK9255qE56ys5LiA5Liq5pyq6KKr6K6/6Zeu55qE6YK75o6l57uT54K5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuZmlyc3RDaGlsZCA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHfmmK9255qE5YW25a6D5pyq6KKr6K6/6Zeu55qE6YK75o6l6aG254K5XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxLm5leHRTaWJsaW5nID0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIERGU1RyZWUoZ3JhcGgsIHcuYWRqVmV4LCBxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3ID0gdy5uZXh0QXJjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUJGU0ZvcmVzdCgpIHtcclxuICAgICAgICBsZXQgdHJlZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IHE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gbmV3IENoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1tpXS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmICghdHJlZSkgdHJlZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIHEgPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHcgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzLnZlcnRpY2VzW3ddLmZpcnN0QXJjO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuYWRqVmV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShwLmFkalZleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUyID0gbmV3IENoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1twLmFkalZleF0uZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5maXJzdENoaWxkID0gbm9kZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcHJlLm5leHRTaWJsaW5nID0gbm9kZTI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlID0gbm9kZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRBcnRpY3VsKCkge1xyXG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcclxuICAgICAgICBsZXQgbG93ID0gW107XHJcbiAgICAgICAgbG93WzBdID0gY291bnQ7XHJcbiAgICAgICAgdmlzaXRlZFswXSA9IDE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gMDtcclxuICAgICAgICBsZXQgcCA9IHRoaXMudmVydGljZXNbMF0uZmlyc3RBcmM7XHJcbiAgICAgICAgbGV0IHYgPSBwLmFkalZleDtcclxuXHJcbiAgICAgICAgREZTQXJ0aWN1bCh0aGlzLCB2KTtcclxuICAgICAgICBpZiAoY291bnQgPCB0aGlzLnZleG51bSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygwICsgJyAgJyArIHRoaXMudmVydGljZXNbMF0uZGF0YSk7XHJcbiAgICAgICAgICAgIHdoaWxlIChwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XHJcbiAgICAgICAgICAgICAgICB2ID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFt2XSA9PT0gMCkgREZTQXJ0aWN1bCh0aGlzLCB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gREZTQXJ0aWN1bChncmFwaCwgdjApIHtcclxuICAgICAgICAgICAgbGV0IG1pbiA9IHZpc2l0ZWRbdjBdID0gKytjb3VudDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IGdyYXBoLnZlcnRpY2VzW3YwXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHcgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW3ddID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgREZTQXJ0aWN1bChncmFwaCwgdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd1t3XSA8IG1pbikgbWluID0gbG93W3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dbd10gPj0gdmlzaXRlZFt2MF0pIGNvbnNvbGUubG9nKHYwICsgJyAgJyArIGdyYXBoLnZlcnRpY2VzW3YwXS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlzaXRlZFt3XSA8IG1pbikgbWluID0gdmlzaXRlZFt3XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb3dbdjBdID0gbWluO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDnu5/orqHlkITpobbngrnlhaXluqbnmoTlh73mlbBcclxuICAgIGNvdW50SW5kZWdyZWUoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB0aGlzLnZlcnRpY2VzW2tdLmluZGVncmVlID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2tdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKVxyXG4gICAgICAgICAgICAgICAgKyt0aGlzLnZlcnRpY2VzW3AuYWRqVmV4XS5pbmRlZ3JlZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4vLyDmi5PmiZHmjpLluo/nrpfms5VcclxuICAgIHRvcG9sb2dpY1NvcnQoKSB7XHJcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrKCk7XHJcbiAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyID0gW107XHJcbiAgICAgICAgdGhpcy5jb3VudEluZGVncmVlKCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc1tpXS5pbmRlZ3JlZSA9PT0gMCkgc3RhY2sucHVzaChpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgaSA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRvcG9sb2dpY2FsT3JkZXIucHVzaChpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1tpXS5kYXRhKTtcclxuICAgICAgICAgICAgKytjb3VudDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoLS10aGlzLnZlcnRpY2VzW2tdLmluZGVncmVlID09PSAwKSBzdGFjay5wdXNoKGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKGNvdW50ID49IHRoaXMudmV4bnVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDovpPlh7rmnInlkJHlm77nmoTlkITpobnlhbPplK7mtLvliqhcclxuICAgIGNyaXRpY2FsUGF0aCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudG9wb2xvZ2ljU29ydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ0FPRee9keS4reWtmOWcqOWbnui3r++8gScpO1xyXG5cclxuICAgICAgICBsZXQgdmUgPSBbXTtcclxuICAgICAgICAvLyDkuovku7bmnIDml6nlj5HnlJ/ml7bpl7TliJ3lp4vljJZcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZlW2pdID0gMDtcclxuICAgICAgICAvLyDorqHnrpfmr4/kuKrkuovku7bnmoTmnIDml6nlj5HnlJ/ml7bpl7R2ZeWAvFxyXG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xyXG4gICAgICAgICAgICBsZXQgaiA9IHRoaXMudG9wb2xvZ2ljYWxPcmRlclttXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmVbal0gKyBwLmluZm8gPiB2ZVtrXSkgdmVba10gPSB2ZVtqXSArIHAuaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdmwgPSBbXTtcclxuICAgICAgICAvLyDkuovku7bmnIDmmZrlj5HnlJ/ml7bpl7TliJ3lp4vljJZcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZsW2pdID0gdmVbdGhpcy52ZXhudW0gLSAxXTtcclxuICAgICAgICAvLyDorqHnrpfmr4/kuKrkuovku7bnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bOeahOWAvFxyXG4gICAgICAgIGZvciAobGV0IG0gPSB0aGlzLnZleG51bSAtIDE7IG0gPj0gMDsgLS1tKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gdGhpcy50b3BvbG9naWNhbE9yZGVyW21dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICh2bFtrXSAtIHAuaW5mbyA8IHZsW2pdKSB2bFtqXSA9IHZsW2tdIC0gcC5pbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOi+k+WHuuaJgOacieWFs+mUrua0u+WKqFxyXG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1ttXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcclxuICAgICAgICAgICAgICAgIGlmICh2ZVttXSArIHAuaW5mbyA9PT0gdmxba10pIGNvbnNvbGUubG9nKCc8JWQsICVkPicsIG0sIGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNob3J0ZXN0UGF0aF9EaWprc3RyYSh2MCkge1xyXG4gICAgICAgIGxldCBkaXN0ID0gW107XHJcbiAgICAgICAgbGV0IHByZSA9IFtdO1xyXG4gICAgICAgIGxldCBmaW5hbCA9IFtdO1xyXG4gICAgICAgIGxldCB3O1xyXG5cclxuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpXHJcbiAgICAgICAgICAgIGRpc3Rbdl0gPSBJbmZpbml0eTtcclxuICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1t2MF0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpXHJcbiAgICAgICAgICAgIGRpc3RbcC5hZGpWZXhdID0gcC5pbmZvO1xyXG5cclxuICAgICAgICBsZXQgdjtcclxuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xyXG4gICAgICAgICAgICBmaW5hbFt2XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBwcmVbdl0gPSBwcmVbdl0gfHwgW107XHJcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSBwcmVbdl1bd10gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkaXN0W3ZdIDwgSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHJlW3ZdW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGlzdFt2MF0gPSAwO1xyXG4gICAgICAgIGZpbmFsW3YwXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmFsW3ddICYmIGRpc3Rbd10gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gdztcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0W3ddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmaW5hbFt2XSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1t2XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xyXG4gICAgICAgICAgICAgICAgdyA9IHAuYWRqVmV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBtaW4gKyBwLmluZm8gPCBkaXN0W3ddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFt3XSA9IG1pbiArIHAuaW5mbztcclxuICAgICAgICAgICAgICAgICAgICBwcmVbd10gPSBwcmVbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddW3ddID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coZmluYWwpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHByZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coZGlzdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbmFsOiBmaW5hbCxcclxuICAgICAgICAgICAgcHJlOiBwcmUsXHJcbiAgICAgICAgICAgIGRpc3Q6IGRpc3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8g5peg5ZCR5Zu+55qE6YK75o6l6KGoXHJcbnZhciBhZGpMaXN0R3JhcGggPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBVREcpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MScpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MicpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MycpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NCcpO1xyXG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NScpO1xyXG5cclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjEnLCAndjInKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjEnLCAndjMnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjEnLCAndjQnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjInLCAndjMnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjQnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjUnKTtcclxuYWRqTGlzdEdyYXBoLmFkZEFyYygndjQnLCAndjUnKTtcclxuXHJcbmNvbnNvbGUubG9nKGFkakxpc3RHcmFwaCk7XHJcblxyXG4vLyDmnInlkJHlm77nmoTpgIbpgrvmjqXooahcclxudmFyIGcgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XHJcbmcuYWRkVmVydGV4KCd2MScpO1xyXG5nLmFkZFZlcnRleCgndjInKTtcclxuZy5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmcuYWRkVmVydGV4KCd2NCcpO1xyXG5nLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmcuYWRkQXJjKCd2MScsICd2MicpO1xyXG5nLmFkZEFyYygndjEnLCAndjQnKTtcclxuZy5hZGRBcmMoJ3YzJywgJ3YyJyk7XHJcbmcuYWRkQXJjKCd2MycsICd2MScpO1xyXG5nLmFkZEFyYygndjQnLCAndjMnKTtcclxuZy5hZGRBcmMoJ3YzJywgJ3Y1Jyk7XHJcbmcuYWRkQXJjKCd2NScsICd2NCcpO1xyXG5cclxuY29uc29sZS5sb2coZyk7XHJcblxyXG4vLyDmnInlkJHlm77nmoTmraPpgrvmjqXooahcclxudmFyIGcgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XHJcbmcuYWRkVmVydGV4KCd2MScpO1xyXG5nLmFkZFZlcnRleCgndjInKTtcclxuZy5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmcuYWRkVmVydGV4KCd2NCcpO1xyXG5nLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmcuYWRkQXJjKCd2MicsICd2MScpO1xyXG5nLmFkZEFyYygndjQnLCAndjEnKTtcclxuZy5hZGRBcmMoJ3YyJywgJ3YzJyk7XHJcbmcuYWRkQXJjKCd2MScsICd2MycpO1xyXG5nLmFkZEFyYygndjMnLCAndjQnKTtcclxuZy5hZGRBcmMoJ3Y1JywgJ3YzJyk7XHJcbmcuYWRkQXJjKCd2NCcsICd2NScpO1xyXG5cclxuY29uc29sZS5sb2coZyk7XHJcblxyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIERGU1RyYXZlcnNlOiAnKTtcclxudmFyIGFkakxpc3RHcmFwaCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIFVERyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2NScsICd2NCcpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2MicpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MicsICd2MScpO1xyXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2MScpO1xyXG5cclxuYWRqTGlzdEdyYXBoLkRGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZlcnRpY2VzW3ZdLmRhdGEpO1xyXG59KTtcclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coJ2Fkakxpc3RHcmFwaCBERlNUcmF2ZXJzZV9Ob25SZWN1cnNlOiAnKTtcclxuYWRqTGlzdEdyYXBoLkRGU1RyYXZlcnNlX05vblJlY3Vyc2UoZnVuY3Rpb24gKHYpIHtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIEJGU1RyYXZlcnNlOiAnKTtcclxudmFyIGcyID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xyXG5nMi5hZGRWZXJ0ZXgoJ3YxJyk7XHJcbmcyLmFkZFZlcnRleCgndjInKTtcclxuZzIuYWRkVmVydGV4KCd2MycpO1xyXG5nMi5hZGRWZXJ0ZXgoJ3Y0Jyk7XHJcbmcyLmFkZFZlcnRleCgndjUnKTtcclxuXHJcbmcyLmFkZEFyYygndjQnLCAndjEnKTtcclxuZzIuYWRkQXJjKCd2MicsICd2MScpO1xyXG5nMi5hZGRBcmMoJ3Y1JywgJ3YzJyk7XHJcbmcyLmFkZEFyYygndjInLCAndjMnKTtcclxuZzIuYWRkQXJjKCd2MScsICd2MycpO1xyXG5nMi5hZGRBcmMoJ3YzJywgJ3Y0Jyk7XHJcbmcyLmFkZEFyYygndjQnLCAndjUnKTtcclxuXHJcbmcyLkJGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZlcnRpY2VzW3ZdLmRhdGEpO1xyXG59KTtcclxuXHJcbmNvbnNvbGUubG9nKCdERlM6IGV4cGVjdCBmYWxzZTogJyArIGFkakxpc3RHcmFwaC5leGlzdF9wYXRoX0RGUygndjEnLCAndjQnKSk7XHJcbmNvbnNvbGUubG9nKCdERlM6IGV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0X3BhdGhfREZTKCd2MScsICd2MicpKTtcclxuXHJcbmNvbnNvbGUubG9nKCdCRlMgOiBleHBlY3QgZmFsc2U6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RfcGF0aF9CRlMoJ3YxJywgJ3Y0JykpO1xyXG5jb25zb2xlLmxvZygnQkZTIDpleHBlY3QgdHJ1ZTogJyArIGFkakxpc3RHcmFwaC5leGlzdF9wYXRoX0JGUygndjEnLCAndjInKSk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDlm77nmoTov57pgJrmgKfpl67pophcclxuXHJcbiDml6DlkJHlm77nmoTov57pgJrliIbph4/kuI7nlJ/miJDmoJFcclxuXHJcbiAxIOaXoOWQkeWbvueahOi/numAmuWIhumHj+WSjOeUn+aIkOagkVxyXG4g5a+55LqO5peg5ZCR5Zu+77yM5a+55YW26L+b6KGM6YGN5Y6G5pe277yaXHJcbiDil4Yg6Iul5piv6L+e6YCa5Zu+77ya5LuF6ZyA5LuO5Zu+5Lit5Lu75LiA6aG254K55Ye65Y+R77yM5bCx6IO96K6/6Zeu5Zu+5Lit55qE5omA5pyJ6aG254K577ybXHJcbiDil4Yg6Iul5piv6Z2e6L+e6YCa5Zu+77ya6ZyA5LuO5Zu+5Lit5aSa5Liq6aG254K55Ye65Y+R44CC5q+P5qyh5LuO5LiA5Liq5paw6aG254K55Ye65Y+R5omA6K6/6Zeu55qE6aG254K56ZuG5bqP5YiX5oGw5aW95piv5ZCE5Liq6L+e6YCa5YiG6YeP55qE6aG254K56ZuG77ybXHJcblxyXG4g4pG0IOiLpUc9KFYsRSnmmK/ml6DlkJHov57pgJrlm77vvIwg6aG254K56ZuG5ZKM6L656ZuG5YiG5Yir5pivVihHKSDvvIxFKEcpIOOAguiLpeS7jkfkuK3ku7vmhI/ngrnlh7rlj5HpgY3ljobml7bvvIwgRShHKeiiq+WIhuaIkOS4pOS4quS6kuS4jeebuOS6pOeahOmbhuWQiO+8mlxyXG4gVChHKSDvvJrpgY3ljobov4fnqIvkuK3miYDnu4/ov4fnmoTovrnnmoTpm4blkIjvvJtcclxuIEIoRykg77ya6YGN5Y6G6L+H56iL5Lit5pyq57uP6L+H55qE6L6555qE6ZuG5ZCI77ybXHJcbiDmmL7nhLbvvJogRShHKT1UKEcp4oiqQihHKSDvvIxUKEcp4oipQihHKT3DmFxyXG4g5pi+54S277yM5Zu+R+KAmT0oViwgVChHKSnmmK9H55qE5p6B5bCP6L+e6YCa5a2Q5Zu+77yM5LiUR+KAmeaYr+S4gOajteagkeOAgkfigJnnp7DkuLrlm75H55qE5LiA5qO155Sf5oiQ5qCR44CCXHJcbiDku47ku7vmhI/ngrnlh7rlj5HmjIlERlPnrpfms5XlvpfliLDnlJ/miJDmoJFH4oCZ56ew5Li65rex5bqm5LyY5YWI55Sf5oiQ5qCR77yb5oyJQkZT566X5rOV5b6X5Yiw55qER+KAmeensOS4uuW5v+W6puS8mOWFiOeUn+aIkOagkeOAglxyXG5cclxuIOKRtSAg6IulRz0oVixFKeaYr+aXoOWQkemdnui/numAmuWbvu+8jOWvueWbvui/m+ihjOmBjeWOhuaXtuW+l+WIsOiLpeW5suS4qui/numAmuWIhumHj+eahOmhtueCuembhu+8mlYxKEcpICxWMihHKSAs4oCmLFZuKEcp5ZKM55u45bqU5omA57uP6L+H55qE6L656ZuG77yaVDEoRykgLFQyKEcpICwg4oCmLFRuKEcpIOOAglxyXG4g5YiZ5a+55bqU55qE6aG254K56ZuG5ZKM6L656ZuG55qE5LqM5YWD57uE77yaR2k9KFZpKEcpLFRpKEcpKVxyXG4gKDHiiaZp4ommbinmmK/lr7nlupTliIbph4/nmoTnlJ/miJDmoJHvvIzmiYDmnInov5nkupvnlJ/miJDmoJHmnoTmiJDkuobljp/mnaXpnZ7ov57pgJrlm77nmoTnlJ/miJDmo67mnpfjgIJcclxuXHJcbiDor7TmmI7vvJrlvZPnu5nlrprml6DlkJHlm77opoHmsYLnlLvlh7rlhbblr7nlupTnmoTnlJ/miJDmoJHmiJbnlJ/miJDmo67mnpfml7bvvIzlv4XpobvlhYjnu5nlh7rnm7jlupTnmoTpgrvmjqXooajvvIznhLblkI7miY3og73moLnmja7pgrvmjqXooajnlLvlh7rlhbblr7nlupTnmoTnlJ/miJDmoJHmiJbnlJ/miJDmo67mnpfjgIJcclxuXHJcblxyXG4gMiAg5Zu+55qE55Sf5oiQ5qCR5ZKM55Sf5oiQ5qOu5p6X566X5rOVXHJcblxyXG4g5a+55Zu+55qE5rex5bqm5LyY5YWI5pCc57Si6YGN5Y6GREZTKOaIlkJGUynnrpfms5XnqI3kvZzkv67mlLnvvIzlsLHlj6/lvpfliLDmnoTpgKDlm77nmoRERlPnlJ/miJDmoJHnrpfms5XjgIJcclxuIOWcqOeul+azleS4re+8jOagkeeahOWtmOWCqOe7k+aehOmHh+eUqOWtqeWtkOKAlOWFhOW8n+ihqOekuuazleOAgummluWFiOW7uueri+S7juafkOS4qumhtueCuVblh7rlj5HvvIzlu7rnq4vkuIDkuKrmoJHnu5PngrnvvIznhLblkI7lho3liIbliKvku6VW55qE6YK75o6l54K55Li66LW35aeL54K577yM5bu656uL55u45bqU55qE5a2Q55Sf5oiQ5qCR77yM5bm25bCG5YW25L2c5Li6ViDnu5PngrnnmoTlrZDmoJHpk77mjqXliLBW57uT54K55LiK44CC5pi+54S277yM566X5rOV5piv5LiA5Liq6YCS5b2S566X5rOV44CCXHJcblxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKGFkakxpc3RHcmFwaC5jcmVhdGVERlNGb3Jlc3QoKSk7XHJcblxyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZyhhZGpMaXN0R3JhcGguY3JlYXRlQkZTRm9yZXN0KCkpO1xyXG5cclxuXHJcblxyXG4vKlxyXG4g5Zyo5p+Q5Zu+5Lit77yM6Iul5Yig6Zmk6aG254K5VuS7peWPilbnm7jlhbPnmoTovrnlkI7vvIzlm77nmoTkuIDkuKrov57pgJrliIbph4/liIblibLkuLrkuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTov57pgJrliIbph4/vvIzliJnnp7DpobbngrlW5Li66K+l5Zu+55qE5LiA5Liq5YWz6IqC54K544CC5LiA5Liq5rKh5pyJ5YWz6IqC54K555qE6L+e6YCa5Zu+56ew5Li66YeN6L+e6YCa5Zu+44CCXHJcbiDlnKjph43ov57pgJrlm77kuK3vvIzku7vmhI/kuIDlr7npobbngrnkuYvpl7Toh7PlsJHlrZjlnKjkuKTmnaHot6/lvoTvvIzliJnlho3liKDljrvmn5DkuKrpobbngrnljbPnm7jlhbPlkITovrnlkI7kuZ/kuI3noLTlnY/lm77nmoTov57pgJrmgKfjgILoi6XlnKjlm77nmoTov57pgJrlm77kuIrliKDljrtr5Liq6IqC54K55omN6IO956C05Z2P5Zu+55qE6L+e6YCa5oCn77yM5YiZ56ewS+S4uuatpOWbvueahOi/numAmuW6puOAglxyXG4g5LuW5Lus5bi45bi45Zyo6YCa5L+h572R57uc55qE5Zu+5oiW6Iiq56m6572R5Lit5bqU55So77yMS+i2iuWkp++8jOezu+e7n+i2iueos+Wumu+8jOWPjeS5i++8jOaImOS6ieS4reiLpeimgeaRp+avgeaVjOaWueeahOi/kOi+k+e6v++8jOWPqumhu+egtOWdj+WFtui/kOi+k+e9keS4reeahOWFs+iKgueCueWNs+WPr+OAglxyXG4gKi9cclxuXHJcblxyXG5cclxudmFyIGFydGljdWxUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgVURHKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdBJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0MnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdEJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRScpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0YnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdHJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSCcpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0knKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdKJyk7XHJcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSycpO1xyXG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0wnKTtcclxuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdNJyk7XHJcblxyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnQycpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnRicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnTCcpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0MnLCAnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0QnLCAnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0gnLCAnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ00nLCAnQicpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0QnLCAnRScpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnSCcpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnSScpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnSycpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0gnLCAnSycpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0onLCAnTCcpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0onLCAnTScpO1xyXG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0wnLCAnTScpO1xyXG5cclxuYXJ0aWN1bFRlc3QuZmluZEFydGljdWwoKTtcclxuXHJcblxyXG4vKlxyXG4g5pyJ5ZCR5peg546v5Zu+5Y+K5YW25bqU55SoXHJcblxyXG4g5pyJ5ZCR5peg546v5Zu+KERpcmVjdGVkIEFjeWNsaW5nIEdyYXBoKe+8muaYr+WbvuS4reayoeacieWbnui3ryjnjq8p55qE5pyJ5ZCR5Zu+44CC5piv5LiA57G75YW35pyJ5Luj6KGo5oCn55qE5Zu+77yM5Li76KaB55So5LqO56CU56m25bel56iL6aG555uu55qE5bel5bqP6Zeu6aKY44CB5bel56iL5pe26Ze06L+b5bqm6Zeu6aKY562J44CCXHJcblxyXG4g5LiA5Liq5bel56iLKHByb2plY3Qp6YO95Y+v5YiG5Li66Iul5bmy5Liq56ew5Li65rS75YqoKGFjdGl2ZSnnmoTlrZDlt6XnqIso5oiW5bel5bqPKe+8jOWQhOS4quWtkOW3peeoi+WPl+WIsOS4gOWumueahOadoeS7tue6puadn++8muafkOS4quWtkOW3peeoi+W/hemhu+W8gOWni+S6juWPpuS4gOS4quWtkOW3peeoi+WujOaIkOS5i+WQju+8m+aVtOS4quW3peeoi+acieS4gOS4quW8gOWni+eCuSjotbfngrkp5ZKM5LiA5Liq57uI54K544CC5Lq65Lus5YWz5b+D77yaXHJcbiDil4Yg5bel56iL6IO95ZCm6aG65Yip5a6M5oiQP+W9seWTjeW3peeoi+eahOWFs+mUrua0u+WKqOaYr+S7gOS5iD9cclxuIOKXhiDkvLDnrpfmlbTkuKrlt6XnqIvlrozmiJDmiYDlv4XpobvnmoTmnIDnn63ml7bpl7TmmK/lpJrlsJE/XHJcblxyXG4g5a+55bel56iL55qE5rS75Yqo5Yqg5Lul5oq96LGh77ya5Zu+5Lit6aG254K56KGo56S65rS75Yqo77yM5pyJ5ZCR6L656KGo56S65rS75Yqo5LmL6Ze055qE5LyY5YWI5YWz57O777yM6L+Z5qC355qE5pyJ5ZCR5Zu+56ew5Li66aG254K56KGo56S65rS75Yqo55qE572RKEFjdGl2aXR5IE9uIFZlcnRleCBOZXR3b3JrIO+8jEFPVue9kSkg44CCXHJcblxyXG5cclxuIOaLk+aJkeaOkuW6j1xyXG5cclxuIDEg5a6a5LmJXHJcbiDmi5PmiZHmjpLluo8oVG9wb2xvZ2ljYWwgU29ydCkg77ya55Sx5p+Q5Liq6ZuG5ZCI5LiK55qE5LiA5Liq5YGP5bqP5b6X5Yiw6K+l6ZuG5ZCI5LiK55qE5LiA5Liq5YWo5bqP55qE5pON5L2c44CCXHJcblxyXG4g4peGIOmbhuWQiOS4iueahOWFs+ezu++8mumbhuWQiEHkuIrnmoTlhbPns7vmmK/ku45B5YiwQeeahOWFs+ezuyhB74K0QSkg44CCXHJcbiDil4Yg5YWz57O755qE6Ieq5Y+N5oCn77ya6Iul74CiYeKIiEHmnIkoYe+8jGEp4oiIUu+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv6Ieq5Y+N55qE44CCXHJcbiDil4Yg5YWz57O755qE5a+556ew5oCn77ya5aaC5p6c5a+55LqOYe+8jGLiiIhBIO+8jOWPquimgeaciShh77yMYiniiIhS5bCx5pyJKGLvvIxhKeKIiFIg77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/lr7nnp7DnmoTjgIJcclxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfkuI7lj43lr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAguWmguaenOWvueS6jmHvvIxi4oiIQSDvvIzku4XlvZNhPWLml7bmnIkoYe+8jGIp4oiIUuWSjChi77yMYSniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5Y+N5a+556ew55qE44CCXHJcbiDil4Yg5YWz57O755qE5Lyg6YCS5oCn77ya6IulYe+8jGLvvIxj4oiIQe+8jOiLpShh77yMYiniiIhS77yM5bm25LiUKGLvvIxjKeKIiFIg77yM5YiZKGHvvIxjKeKIiFIg77yM56ew6ZuG5ZCIQeS4iueahOWFs+ezu1LmmK/kvKDpgJLnmoTjgIJcclxuIOKXhiDlgY/luo/vvJroi6Xpm4blkIhB5LiK55qE5YWz57O7UuaYr+iHquWPjeeahO+8jOWPjeWvueensOeahOWSjOS8oOmAkueahO+8jOWImeensFLmmK/pm4blkIhB5LiK55qE5YGP5bqP5YWz57O744CCXHJcbiDil4Yg5YWo5bqP77ya6K6+UuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vvvIzvgKJh77yMYuKIiEHvvIzlv4XmnIlhUmLmiJZiUmHvvIwg5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlhajluo/lhbPns7vjgIJcclxuXHJcbiDljbPlgY/luo/mmK/mjIfpm4blkIjkuK3ku4XmnInpg6jliIblhYPntKDkuYvpl7Tlj6/ku6Xmr5TovoPvvIzogIzlhajluo/mmK/mjIfpm4blkIjkuK3ku7vmhI/kuKTkuKrlhYPntKDkuYvpl7Tpg73lj6/ku6Xmr5TovoPjgIJcclxuIOWcqEFPVue9keS4re+8jOiLpeacieacieWQkei+uTxpLCBqPu+8jOWImWnmmK9q55qE55u05o6l5YmN6amx77yMauaYr2nnmoTnm7TmjqXlkI7nu6fvvJvmjqjogIzlub/kuYvvvIzoi6Xku47pobbngrlp5Yiw6aG254K5auacieacieWQkei3r+W+hO+8jOWImWnmmK9q55qE5YmN6amx77yMauaYr2nnmoTlkI7nu6fjgIJcclxuIOWcqEFPVue9keS4re+8jOS4jeiDveacieeOr++8jOWQpuWIme+8jOafkOmhuea0u+WKqOiDveWQpui/m+ihjOaYr+S7peiHqui6q+eahOWujOaIkOS9nOS4uuWJjeaPkOadoeS7tuOAglxyXG4g5qOA5p+l5pa55rOV77ya5a+55pyJ5ZCR5Zu+55qE6aG254K56L+b6KGM5ouT5omR5o6S5bqP77yM6Iul5omA5pyJ6aG254K56YO95Zyo5YW25ouT5omR5pyJ5bqP5bqP5YiX5Lit77yM5YiZ5peg546v44CCXHJcbiDmnInlkJHlm77nmoTmi5PmiZHmjpLluo/vvJrmnoTpgKBBT1bnvZHkuK3pobbngrnnmoTkuIDkuKrmi5PmiZHnur/mgKfluo/liJcoduKAmTEsduKAmTIsIOKLryx24oCZbinvvIzkvb/lvpfor6Xnur/mgKfluo/liJfkuI3ku4Xkv53mjIHljp/mnaXmnInlkJHlm77kuK3pobbngrnkuYvpl7TnmoTkvJjlhYjlhbPns7vvvIzogIzkuJTlr7nljp/lm77kuK3msqHmnInkvJjlhYjlhbPns7vnmoTpobbngrnkuYvpl7TkuZ/lu7rnq4vkuIDnp40o5Lq65Li655qEKeS8mOWFiOWFs+ezu+OAglxyXG5cclxuIDIg5ouT5omR5o6S5bqP566X5rOVXHJcbiDnrpfms5XmgJ3mg7NcclxuXHJcbiDikaAg5ZyoQU9W572R5Lit6YCJ5oup5LiA5Liq5rKh5pyJ5YmN6amx55qE6aG254K55LiU6L6T5Ye677ybXHJcbiDikaEg5ZyoQU9W572R5Lit5Yig6Zmk6K+l6aG254K55Lul5Y+K5LuO6K+l6aG254K55Ye65Y+R55qEKOS7peivpemhtueCueS4uuWwvueahOW8pynmiYDmnInmnInlkJHlvKco6L65KSDvvJtcclxuIOKRoiDph43lpI3ikaDjgIHikaHvvIznm7TliLDlm77kuK3lhajpg6jpobbngrnpg73lt7LovpPlh7oo5Zu+5Lit5peg546vKeaIluWbvuS4reS4jeWtmOWcqOaXoOWJjempseeahOmhtueCuSjlm77kuK3lv4XmnInnjq8p44CCXHJcblxyXG4gMyAg566X5rOV5a6e546w6K+05piOXHJcbiDil4Yg6YeH55So5q2j6YK75o6l6ZO+5L2c5Li6QU9W572R55qE5a2Y5YKo57uT5p6E77ybXHJcbiDil4Yg6K6+56uL5aCG5qCI77yM55So5p2l5pqC5a2Y5YWl5bqm5Li6MOeahOmhtueCue+8m1xyXG4g4peGIOWIoOmZpOmhtueCueS7peWug+S4uuWwvueahOW8p++8muW8p+WktOmhtueCueeahOWFpeW6puWHjzHjgIJcclxuXHJcbiDmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg44CCXHJcblxyXG4gKi9cclxuXHJcbnZhciB0b3BvbG9naWNUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xyXG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjEnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2MycpO1xyXG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjQnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2NicpO1xyXG5cclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YyJywgJ3YxJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NCcsICd2MScpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjMnLCAndjEnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YyJywgJ3YzJyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2MycpO1xyXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjQnLCAndjYnKTtcclxudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XHJcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2NicpO1xyXG5cclxuY29uc29sZS5sb2coJ3RvcG9sb2dpY1NvcnQ6ICcpO1xyXG5jb25zb2xlLmxvZyh0b3BvbG9naWNUZXN0LnRvcG9sb2dpY1NvcnQoKSk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDlhbPplK7ot6/lvoQoQ3JpdGljYWwgUGF0aClcclxuXHJcbiDkuI5BT1bnvZHnm7jlr7nlupTnmoTmmK9BT0UoQWN0aXZpdHkgT24gRWRnZSkg77yM5piv6L656KGo56S65rS75Yqo55qE5pyJ5ZCR5peg546v5Zu+77yM5aaC5Zu+Ny0yNOaJgOekuuOAguWbvuS4remhtueCueihqOekuuS6i+S7tihFdmVudCnvvIzmr4/kuKrkuovku7booajnpLrlnKjlhbbliY3nmoTmiYDmnInmtLvliqjlt7Lnu4/lrozmiJDvvIzlhbblkI7nmoTmtLvliqjlj6/ku6XlvIDlp4vvvJvlvKfooajnpLrmtLvliqjvvIzlvKfkuIrnmoTmnYPlgLzooajnpLrnm7jlupTmtLvliqjmiYDpnIDnmoTml7bpl7TmiJbotLnnlKjjgIJcclxuXHJcbiAxIOS4jkFPReacieWFs+eahOeglOeptumXrumimFxyXG4g4peGIOWujOaIkOaVtOS4quW3peeoi+iHs+WwkemcgOimgeWkmuWwkeaXtumXtD9cclxuIOKXhiDlk6rkupvmtLvliqjmmK/lvbHlk43lt6XnqIvov5vluqYo6LS555SoKeeahOWFs+mUrj9cclxuIOW3peeoi+WujOaIkOacgOefreaXtumXtO+8muS7jui1t+eCueWIsOe7iOeCueeahOacgOmVv+i3r+W+hOmVv+W6pijot6/lvoTkuIrlkITmtLvliqjmjIHnu63ml7bpl7TkuYvlkowpIOOAgumVv+W6puacgOmVv+eahOi3r+W+hOensOS4uuWFs+mUrui3r+W+hO+8jOWFs+mUrui3r+W+hOS4iueahOa0u+WKqOensOS4uuWFs+mUrua0u+WKqOOAguWFs+mUrua0u+WKqOaYr+W9seWTjeaVtOS4quW3peeoi+eahOWFs+mUruOAglxyXG4g6K6+djDmmK/otbfngrnvvIzku452MOWIsHZp55qE5pyA6ZW/6Lev5b6E6ZW/5bqm56ew5Li65LqL5Lu2dmnnmoTmnIDml6nlj5HnlJ/ml7bpl7TvvIzljbPmmK/ku6V2aeS4uuWwvueahOaJgOaciea0u+WKqOeahOacgOaXqeWPkeeUn+aXtumXtOOAglxyXG4g6Iul5rS75YqoYWnmmK/lvKc8aiwgaz7vvIzmjIHnu63ml7bpl7TmmK9kdXQoPGosIGs+Ke+8jOiuvu+8mlxyXG4g4peGIGUoaSnvvJrooajnpLrmtLvliqhhaeeahOacgOaXqeW8gOWni+aXtumXtO+8m1xyXG4g4peGIGwoaSnvvJrlnKjkuI3lvbHlk43ov5vluqbnmoTliY3mj5DkuIvvvIzooajnpLrmtLvliqhhaeeahOacgOaZmuW8gOWni+aXtumXtO+8myDliJlsKGkpLWUoaSnooajnpLrmtLvliqhhaeeahOaXtumXtOS9memHj++8jOiLpWwoaSktZShpKT0w77yM6KGo56S65rS75YqoYWnmmK/lhbPplK7mtLvliqjjgIJcclxuIOKXhiB2ZShpKe+8muihqOekuuS6i+S7tnZp55qE5pyA5pep5Y+R55Sf5pe26Ze077yM5Y2z5LuO6LW354K55Yiw6aG254K5dmnnmoTmnIDplb/ot6/lvoTplb/luqbvvJtcclxuIOKXhiB2bChpKe+8muihqOekuuS6i+S7tnZp55qE5pyA5pma5Y+R55Sf5pe26Ze044CC5YiZ5pyJ5Lul5LiL5YWz57O777yaXHJcbiBlKGkpPXZlKGopXHJcbiBsKGkpPSB2bChrKS1kdXQoPGosIGs+KVxyXG4gMCAgICBqPTDvvIzooajnpLp2auaYr+i1t+eCuVxyXG4gdmUoaik9XHJcbiBNYXh7dmUoaSkrZHV0KDxpLCBqPil8PHZpLCB2aj7mmK/nvZHkuK3nmoTlvKd9XHJcblxyXG4g5ZCr5LmJ5piv77ya5rqQ54K55LqL5Lu255qE5pyA5pep5Y+R55Sf5pe26Ze06K6+5Li6MO+8m+mZpOa6kOeCueWklu+8jOWPquaciei/m+WFpemhtueCuXZq55qE5omA5pyJ5byn5omA5Luj6KGo55qE5rS75Yqo5YWo6YOo57uT5p2f5ZCO77yM5LqL5Lu2dmrmiY3og73lj5HnlJ/jgILljbPlj6rmnIl2aueahOaJgOacieWJjempseS6i+S7tnZp55qE5pyA5pep5Y+R55Sf5pe26Ze0dmUoaSnorqHnrpflh7rmnaXlkI7vvIzmiY3og73orqHnrpd2ZShqKSDjgIJcclxuIOaWueazleaYr++8muWvueaJgOacieS6i+S7tui/m+ihjOaLk+aJkeaOkuW6j++8jOeEtuWQjuS+neasoeaMieaLk+aJkemhuuW6j+iuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtOOAglxyXG4gdmUobi0xKSAgICBqPW4tMe+8jOihqOekunZq5piv57uI54K5XHJcbiB2bChqKT1cclxuIE1pbnt2bChrKS1kdXQoPGosIGs+KXw8dmosIHZrPuaYr+e9keS4reeahOW8p31cclxuIOWQq+S5ieaYr++8muWPquaciXZq55qE5omA5pyJ5ZCO57un5LqL5Lu2dmvnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bChrKeiuoeeul+WHuuadpeWQju+8jOaJjeiDveiuoeeul3ZsKGopIOOAglxyXG4g5pa55rOV5piv77ya5oyJ5ouT5omR5o6S5bqP55qE6YCG6aG65bqP77yM5L6d5qyh6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pma5Y+R55Sf5pe26Ze044CCXHJcblxyXG5cclxuIDIg5rGCQU9F5Lit5YWz6ZSu6Lev5b6E5ZKM5YWz6ZSu5rS75YqoXHJcbiDikbQg566X5rOV5oCd5oOzXHJcbiDikaAg5Yip55So5ouT5omR5o6S5bqP5rGC5Ye6QU9F572R55qE5LiA5Liq5ouT5omR5bqP5YiX77ybXHJcbiDikaEgIOS7juaLk+aJkeaOkuW6j+eahOW6j+WIl+eahOesrOS4gOS4qumhtueCuSjmupDngrkp5byA5aeL77yM5oyJ5ouT5omR6aG65bqP5L6d5qyh6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pep5Y+R55Sf5pe26Ze0dmUoaSkg77ybXHJcbiDikaIgIOS7juaLk+aJkeaOkuW6j+eahOW6j+WIl+eahOacgOWQjuS4gOS4qumhtueCuSjmsYfngrkp5byA5aeL77yM5oyJ6YCG5ouT5omR6aG65bqP5L6d5qyh6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pma5Y+R55Sf5pe26Ze0dmwoaSkg77ybXHJcblxyXG4g6K6+QU9F572R5pyJbuS4quS6i+S7tu+8jGXkuKrmtLvliqjvvIzliJnnrpfms5XnmoTkuLvopoHmiafooYzmmK/vvJpcclxuIOKXhiDov5vooYzmi5PmiZHmjpLluo/vvJrml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg77ybXHJcbiDil4Yg5rGC5q+P5Liq5LqL5Lu255qEdmXlgLzlkox2bOWAvO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcclxuIOKXhiDmoLnmja52ZeWAvOWSjHZs5YC85om+5YWz6ZSu5rS75Yqo77ya5pe26Ze05aSN5p2C5bqm5pivTyhuK2UpIO+8m1xyXG4g5Zug5q2k77yM5pW05Liq566X5rOV55qE5pe26Ze05aSN5p2C5bqm5pivTyhuK2UpIOOAglxyXG5cclxuICovXHJcblxyXG5cclxudmFyIGNyaXRpY2FsUGF0aFRlc3QgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MCcpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjEnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MycpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjQnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NicpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjcnKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y4Jyk7XHJcblxyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjEnLCAndjAnLCAzKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3YyJywgJ3YwJywgMTApO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjQnLCAndjEnLCAxMyk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NCcsICd2MicsIDEyKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3YzJywgJ3YxJywgOSk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NScsICd2MicsIDcpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjcnLCAndjQnLCA2KTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y3JywgJ3YzJywgNCk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NycsICd2NScsIDExKTtcclxuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y2JywgJ3YzJywgOCk7XHJcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2OCcsICd2NycsIDUpO1xyXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjgnLCAndjYnLCAyKTtcclxuXHJcbmNyaXRpY2FsUGF0aFRlc3QuY3JpdGljYWxQYXRoKCk7XHJcblxyXG5cclxuXHJcblxyXG52YXIgZGlqVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XHJcblxyXG5kaWpUZXN0LmFkZFZlcnRleCgnMCcpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnMScpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnMicpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnMycpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnNCcpO1xyXG5kaWpUZXN0LmFkZFZlcnRleCgnNScpO1xyXG5cclxuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMCcsIDIwKTtcclxuZGlqVGVzdC5hZGRBcmMoJzQnLCAnMCcsIDEwKTtcclxuZGlqVGVzdC5hZGRBcmMoJzInLCAnMCcsIDYwKTtcclxuZGlqVGVzdC5hZGRBcmMoJzUnLCAnMCcsIDY1KTtcclxuZGlqVGVzdC5hZGRBcmMoJzInLCAnMScsIDMwKTtcclxuZGlqVGVzdC5hZGRBcmMoJzMnLCAnMicsIDQwKTtcclxuZGlqVGVzdC5hZGRBcmMoJzInLCAnNScsIDE1KTtcclxuZGlqVGVzdC5hZGRBcmMoJzUnLCAnNCcsIDIwKTtcclxuZGlqVGVzdC5hZGRBcmMoJzQnLCAnMycsIDM1KTtcclxuZGlqVGVzdC5hZGRBcmMoJzMnLCAnMScsIDcwKTtcclxuXHJcbmRpalRlc3Quc2hvcnRlc3RQYXRoX0RpamtzdHJhKDApO1xyXG5cclxuXHJcbihmdW5jdGlvbigpe1xyXG4gICAgLyoqXHJcbiAgICAgKiDovpPlh7rmnInlkJHml6Dnjq/lm77lvaLlvI/ooajnpLrnmoTpgIbms6LlhbDlvI9cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbmlCb0xhbl9EQUcoZ3JhcGgpe1xyXG4gICAgICAgIGdyYXBoLmNvdW50SW5kZWdyZWUoKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZ3JhcGgudmV4bnVtOyArK2kpe1xyXG4gICAgICAgICAgICAvLyDmib7liLDmnInlkJHml6Dnjq/lm77nmoTmoLlcclxuICAgICAgICAgICAgaWYoZ3JhcGgudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHByaW50TmlCb0xhbihncmFwaCwgaSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByaW50TmlCb0xhbihncmFwaCwgaSl7XHJcbiAgICAgICAgbGV0IGMgPSBncmFwaC52ZXJ0aWNlc1tpXS5kYXRhO1xyXG4gICAgICAgIGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7XHJcblxyXG4gICAgICAgIC8vIOWtkOihqOi+vuW8j1xyXG4gICAgICAgIGlmKHApIHtcclxuICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBwLmFkalZleCk7XHJcbiAgICAgICAgICAgIHByaW50TmlCb0xhbihncmFwaCwgcC5uZXh0QXJjLmFkalZleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhjICsgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uZ5pyJ5ZCR5peg546v5Zu+6KGo56S655qE6KGo6L6+5byP5rGC5YC8XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlX0RBRyhncmFwaCl7XHJcbiAgICAgICAgZ3JhcGguY291bnRJbmRlZ3JlZSgpO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBncmFwaC52ZXhudW07ICsraSl7XHJcbiAgICAgICAgICAgIGlmKCFncmFwaC52ZXJ0aWNlc1tpXS5pbmRlZ3JlZSkgcmV0dXJuIGV2YWx1YXRlX2ltcChncmFwaCwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlX2ltcChnLCBpKXtcclxuICAgICAgICBpZigvXlxcZCskLy50ZXN0KGcudmVydGljZXNbaV0uZGF0YSkpIHJldHVybiBnLnZlcnRpY2VzW2ldLmRhdGE7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBwID0gZy52ZXJ0aWNlc1tpXS5maXJzdEFyYztcclxuICAgICAgICAgICAgbGV0IHYxID0gZXZhbHVhdGVfaW1wKGcsIHAuYWRqVmV4KTtcclxuICAgICAgICAgICAgbGV0IHYyID0gZXZhbHVhdGVfaW1wKGcsIHAubmV4dEFyYy5hZGpWZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlKHYxLCBnLnZlcnRpY2VzW2ldLmRhdGEsIHYyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlKGEsIG9wZXJhdGlvbiwgYil7XHJcbiAgICAgICAgLy8g5YG35LiA5LiL5oeSLi5cclxuICAgICAgICByZXR1cm4gZXZhbChhICsgb3BlcmF0aW9uICsgYik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKCgxICsgMikgKiAoMiAqICgzICsgNCkpICsgKDMgKyA0KSAqIDUpICogKCgzICsgNCkgKiA1KVxyXG4gICAgbGV0IGRhZyA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIERHKTtcclxuXHJcbiAgICBsZXQgYTEgPSBuZXcgU3RyaW5nKCcqJyk7XHJcbiAgICBsZXQgYTIgPSBuZXcgU3RyaW5nKCcrJyk7XHJcbiAgICBsZXQgYTMgPSBuZXcgU3RyaW5nKCcqJyk7XHJcbiAgICBsZXQgYTQgPSBuZXcgU3RyaW5nKCcqJyk7XHJcbiAgICBsZXQgYTUgPSBuZXcgU3RyaW5nKCcrJyk7XHJcbiAgICBsZXQgYTYgPSBuZXcgU3RyaW5nKCcqJyk7XHJcbiAgICBsZXQgYTcgPSBuZXcgU3RyaW5nKCcrJyk7XHJcblxyXG4gICAgLy8gMTJcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTEpO1xyXG4gICAgZGFnLmFkZFZlcnRleChhMik7XHJcbiAgICBkYWcuYWRkVmVydGV4KGEzKTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTQpO1xyXG4gICAgZGFnLmFkZFZlcnRleChhNSk7XHJcbiAgICBkYWcuYWRkVmVydGV4KGE2KTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoYTcpO1xyXG4gICAgZGFnLmFkZFZlcnRleCgxKTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoMik7XHJcbiAgICBkYWcuYWRkVmVydGV4KDMpO1xyXG4gICAgZGFnLmFkZFZlcnRleCg0KTtcclxuICAgIGRhZy5hZGRWZXJ0ZXgoNSk7XHJcblxyXG4gICAgLy8gMTRcclxuICAgIGRhZy5hZGRBcmMoYTIsIGExKTtcclxuICAgIGRhZy5hZGRBcmMoYTQsIGExKTtcclxuICAgIGRhZy5hZGRBcmMoYTMsIGEyKTtcclxuICAgIGRhZy5hZGRBcmMoYTQsIGEyKTtcclxuICAgIGRhZy5hZGRBcmMoYTUsIGEzKTtcclxuICAgIGRhZy5hZGRBcmMoYTYsIGEzKTtcclxuICAgIGRhZy5hZGRBcmMoYTcsIGE2KTtcclxuICAgIGRhZy5hZGRBcmMoYTcsIGE0KTtcclxuICAgIGRhZy5hZGRBcmMoNSwgYTQpO1xyXG4gICAgZGFnLmFkZEFyYygxLCBhNSk7XHJcbiAgICBkYWcuYWRkQXJjKDIsIGE1KTtcclxuICAgIGRhZy5hZGRBcmMoMiwgYTYpO1xyXG4gICAgZGFnLmFkZEFyYygzLCBhNyk7XHJcbiAgICBkYWcuYWRkQXJjKDQsIGE3KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnbmlCb0xhbl9EQUc6ICcpO1xyXG4gICAgbmlCb0xhbl9EQUcoZGFnKTtcclxuICAgIGNvbnNvbGUubG9nKCdldmFsdWF0ZV9EQUc6ICcgKyBldmFsdWF0ZV9EQUcoZGFnKSk7ICAvLyAyNjk1XHJcbn0pKCk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0dyYXBoL0FkamFjZW5jeUxpc3RHcmFwaC5qc1xuICoqLyIsIi8qIGNyZWF0ZSBieSBMdWtlICovXHJcbi8qKlxyXG4gKiDlm74oR3JhcGgpXHJcbiAqXHJcbiAqIOWbvihHcmFwaCnmmK/kuIDnp43mr5Tnur/mgKfooajlkozmoJHmm7TkuLrlpI3mnYLnmoTmlbDmja7nu5PmnoTjgIJcclxuICpcclxuICog57q/5oCn57uT5p6E77ya5piv56CU56m25pWw5o2u5YWD57Sg5LmL6Ze055qE5LiA5a+55LiA5YWz57O744CC5Zyo6L+Z56eN57uT5p6E5Lit77yM6Zmk56ys5LiA5Liq5ZKM5pyA5ZCO5LiA5Liq5YWD57Sg5aSW77yM5Lu75L2V5LiA5Liq5YWD57Sg6YO95pyJ5ZSv5LiA55qE5LiA5Liq55u05o6l5YmN6amx5ZKM55u05o6l5ZCO57un44CCXHJcbiAqXHJcbiAqIOagkee7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueWkmueahOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOavj+S4quWFg+e0oOWvueS4iyjlsYIp5Y+v5Lul5pyJMOS4quaIluWkmuS4quWFg+e0oOebuOiBlOezu++8jOWvueS4iijlsYIp5Y+q5pyJ5ZSv5LiA55qE5LiA5Liq5YWD57Sg55u45YWz77yM5pWw5o2u5YWD57Sg5LmL6Ze05pyJ5piO5pi+55qE5bGC5qyh5YWz57O744CCXHJcbiAqXHJcbiAqIOWbvue7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOWkmuWvueWkmueahOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOS7u+aEj+S4pOS4quWFg+e0oOS5i+mXtOWPr+iDveWtmOWcqOWFs+ezu+OAguWNs+e7k+eCueS5i+mXtOeahOWFs+ezu+WPr+S7peaYr+S7u+aEj+eahO+8jOWbvuS4reS7u+aEj+WFg+e0oOS5i+mXtOmDveWPr+iDveebuOWFs+OAglxyXG4gKlxyXG4gKiDlm77nmoTlupTnlKjmnoHkuLrlub/ms5vvvIzlt7LmuJflhaXliLDor7jlpoLor63oqIDlrabjgIHpgLvovpHlrabjgIHniannkIbjgIHljJblrabjgIHnlLXorq/jgIHorqHnrpfmnLrnp5Hlrabku6Xlj4rmlbDlrabnmoTlhbblroPliIbmlK/jgIJcclxuICpcclxuICog5Zu+55qE5Z+65pys5qaC5b+1XHJcbiAqXHJcbiAqIOS4gOS4quWbvihHKeWumuS5ieS4uuS4gOS4quWBtuWvuShWLEUpIO+8jOiusOS4ukc9KFYsRSkg44CC5YW25Lit77yaIFbmmK/pobbngrkoVmVydGV4KeeahOmdnuepuuaciemZkOmbhuWQiO+8jOiusOS4ulYoRynvvJtF5piv5peg5bqP6ZuGViZW55qE5LiA5Liq5a2Q6ZuG77yM6K6w5Li6RShHKSDvvIzlhbblhYPntKDmmK/lm77nmoTlvKcoQXJjKeOAglxyXG4gKiDlsIbpobbngrnpm4blkIjkuLrnqbrnmoTlm77np7DkuLrnqbrlm77jgILlhbblvaLlvI/ljJblrprkuYnkuLrvvJpcclxuIEc9KFYg77yMRSlcclxuIFY9e3Z8duKIiGRhdGEgb2JqZWN0fVxyXG4gRT17PHYsdz58IHYsd+KIiFbiiKdwKHYsdyl9XHJcbiBQKHYsdynooajnpLrku47pobbngrl25Yiw6aG254K5d+acieS4gOadoeebtOaOpemAmui3r+OAglxyXG4gKlxyXG4gKiDlvKcoQXJjKSDvvJrooajnpLrkuKTkuKrpobbngrl25ZKMd+S5i+mXtOWtmOWcqOS4gOS4quWFs+ezu++8jOeUqOmhtueCueWBtuWvuTx2LHc+6KGo56S644CC6YCa5bi45qC55o2u5Zu+55qE6aG254K55YG25a+55bCG5Zu+5YiG5Li65pyJ5ZCR5Zu+5ZKM5peg5ZCR5Zu+44CCXHJcbiAqIOacieWQkeWbvihEaWdyYXBoKe+8miDoi6Xlm75H55qE5YWz57O76ZuG5ZCIRShHKeS4re+8jOmhtueCueWBtuWvuTx2LHc+55qEduWSjHfkuYvpl7TmmK/mnInluo/nmoTvvIznp7Dlm75H5piv5pyJ5ZCR5Zu+44CCXHJcbiAqICAg5Zyo5pyJ5ZCR5Zu+5Lit77yM6IulIDx2LHc+4oiIRShHKSDvvIzooajnpLrku47pobbngrl25Yiw6aG254K5d+acieS4gOadoeW8p+OAgiDlhbbkuK3vvJp256ew5Li65byn5bC+KHRhaWwp5oiW5aeL54K5KGluaXRpYWwgbm9kZSnvvIx356ew5Li65byn5aS0KGhlYWQp5oiW57uI54K5KHRlcm1pbmFsIG5vZGUpIOOAglxyXG4gKiDml6DlkJHlm74oVW5kaWdyYXBoKe+8miDoi6Xlm75H55qE5YWz57O76ZuG5ZCIRShHKeS4re+8jOmhtueCueWBtuWvuTx2LHc+55qEduWSjHfkuYvpl7TmmK/ml6Dluo/nmoTvvIznp7Dlm75H5piv5peg5ZCR5Zu+44CCXHJcbiAqICAg5Zyo5peg5ZCR5Zu+5Lit77yM6Iul74CiPHYsdz7iiIhFKEcpIO+8jOaciTx3LHY+4oiIRShHKSDvvIzljbNFKEcp5piv5a+556ew77yM5YiZ55So5peg5bqP5a+5KHYsdykg6KGo56S6duWSjHfkuYvpl7TnmoTkuIDmnaHovrkoRWRnZSnvvIzlm6DmraQodix3KSDlkowodyx2KeS7o+ihqOeahOaYr+WQjOS4gOadoei+ueOAglxyXG4gKlxyXG4gKiDkvosx77ya6K6+5pyJ5pyJ5ZCR5Zu+RzHlkozml6DlkJHlm75HMu+8jOW9ouW8j+WMluWumuS5ieWIhuWIq+aYr++8mlxyXG4gRzE9KFYxIO+8jEUxKVxyXG4gVjE9e2EsYixjLGQsZX1cclxuIEUxPXs8YSxiPiw8YSxjPiwgPGEsZT4sPGMsZD4sPGMsZT4gLDxkLGE+LDxkLGI+LDxlLGQ+fVxyXG4gRzI9KFYyIO+8jEUyKVxyXG4gVjI9e2EsYixjLGR9XHJcbiBFMj17KGEsYiksIChhLGMpLCAoYSxkKSwgKGIsZCksIChiLGMpLCAoYyxkKX1cclxuICpcclxuICog5a6M5YWo5peg5ZCR5Zu+77ya5a+55LqO5peg5ZCR5Zu+77yM6Iul5Zu+5Lit6aG254K55pWw5Li6biDvvIznlKhl6KGo56S66L6555qE5pWw55uu77yM5YiZZSDiiIhbMO+8jG4obi0xKS8yXSDjgILlhbfmnIluKG4tMSkvMuadoei+ueeahOaXoOWQkeWbvuensOS4uuWujOWFqOaXoOWQkeWbvuOAglxyXG4g5a6M5YWo5peg5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXHJcbiAqIOWvueS6juaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZp77yMdmog4oiIViDvvIzlvZN2aeKJoHZq5pe277yM5pyJKHZpICx2ainiiIhF77yM5Y2z5Zu+5Lit5Lu75oSP5Lik5Liq5LiN5ZCM55qE6aG254K56Ze06YO95pyJ5LiA5p2h5peg5ZCR6L6577yM6L+Z5qC355qE5peg5ZCR5Zu+56ew5Li65a6M5YWo5peg5ZCR5Zu+44CCXHJcbiAqXHJcbiAqIOWujOWFqOacieWQkeWbvu+8muWvueS6juacieWQkeWbvu+8jOiLpeWbvuS4remhtueCueaVsOS4um4g77yM55SoZeihqOekuuW8p+eahOaVsOebru+8jOWImWXiiIhbMO+8jG4obi0xKV0g44CC5YW35pyJbihuLTEp5p2h6L6555qE5pyJ5ZCR5Zu+56ew5Li65a6M5YWo5pyJ5ZCR5Zu+44CCXHJcbiDlrozlhajmnInlkJHlm77lj6blpJbnmoTlrprkuYnmmK/vvJpcclxuICog5a+55LqO5pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74CidmnvvIx2auKIiFYg77yM5b2Tdmkg4omgdmrml7bvvIzmnIk8dmkgLHZqPuKIiEXiiKc8dmogLCB2aSA+4oiIRSDvvIzljbPlm77kuK3ku7vmhI/kuKTkuKrkuI3lkIznmoTpobbngrnpl7Tpg73mnInkuIDmnaHlvKfvvIzov5nmoLfnmoTmnInlkJHlm77np7DkuLrlrozlhajmnInlkJHlm77jgIJcclxuICpcclxuICog5pyJ5b6I5bCR6L655oiW5byn55qE5Zu+77yIZTxu44+Sbu+8ieeahOWbvuensOS4uueogOeWj+Wbvu+8jOWPjeS5i+ensOS4uueooOWvhuWbvuOAglxyXG4gKiDmnYMoV2VpZ2h0Ke+8muS4juWbvueahOi+ueWSjOW8p+ebuOWFs+eahOaVsOOAguadg+WPr+S7peihqOekuuS7juS4gOS4qumhtueCueWIsOWPpuS4gOS4qumhtueCueeahOi3neemu+aIluiAl+i0ueOAglxyXG4gKlxyXG4gKiDlrZDlm77lkoznlJ/miJDlrZDlm77vvJrorr7mnInlm75HPShW77yMRSnlkoxH4oCZPShW4oCZ77yMReKAmSnvvIzoi6VW4oCZ4oiIVuS4lEXigJniiIhFIO+8jOWImeensOWbvkfigJnmmK9H55qE5a2Q5Zu+77yb6IulVuKAmT1W5LiUReKAmeKIiEXvvIzliJnnp7Dlm75H4oCZ5pivR+eahOS4gOS4queUn+aIkOWtkOWbvuOAglxyXG4gKiDpobbngrnnmoTpgrvmjqUoQWRqYWNlbnQp77ya5a+55LqO5peg5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul6L65KHYsdyniiIhF77yM5YiZ56ew6aG254K5duWSjHcg5LqS5Li66YK75o6l54K577yM5Y2zduWSjHfnm7jpgrvmjqXjgILovrkodix3KeS+nemZhChpbmNpZGVudCnkuI7pobbngrl25ZKMdyDjgIJcclxuICog5a+55LqO5pyJ5ZCR5Zu+Rz0oViDvvIxFKe+8jOiLpeacieWQkeW8pzx2LHc+4oiIRe+8jOWImeensOmhtueCuXYg4oCc6YK75o6l5Yiw4oCd6aG254K5d++8jOmhtueCuXcg4oCc6YK75o6l6Ieq4oCd6aG254K5diDvvIzlvKc8dix3PiDkuI7pobbngrl25ZKMdyDigJznm7jlhbPogZTigJ0g44CCXHJcbiAqXHJcbiAqIOmhtueCueeahOW6puOAgeWFpeW6puOAgeWHuuW6pu+8muWvueS6juaXoOWQkeWbvkc9KFbvvIxFKe+8jCDvgKJ2aeKIiFbvvIzlm75H5Lit5L6d6ZmE5LqOdmnnmoTovrnnmoTmlbDnm67np7DkuLrpobbngrl2aeeahOW6pihkZWdyZWUp77yM6K6w5Li6VEQodmkp44CCXHJcbiDmmL7nhLbvvIzlnKjml6DlkJHlm77kuK3vvIzmiYDmnInpobbngrnluqbnmoTlkozmmK/lm77kuK3ovrnnmoQy5YCN44CCIOWNsyAgIOKIkVREKHZpKT0yZSAgICAgIGk9MSwgMiwg4oCmLCBuIO+8jGXkuLrlm77nmoTovrnmlbDjgIJcclxuIOWvueacieWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZpIOKIiFYg77yM5Zu+R+S4reS7pXZp5L2c5Li66LW354K555qE5pyJ5ZCR6L65KOW8pynnmoTmlbDnm67np7DkuLrpobbngrl2aeeahOWHuuW6pihPdXRkZWdyZWUp77yM6K6w5Li6T0QodmkpIO+8m+S7pXZp5L2c5Li657uI54K555qE5pyJ5ZCR6L65KOW8pynnmoTmlbDnm67np7DkuLrpobbngrl2aeeahOWFpeW6pihJbmRlZ3JlZSnvvIzorrDkuLpJRCh2aSkg44CC6aG254K5dmnnmoTlh7rluqbkuI7lhaXluqbkuYvlkoznp7DkuLp2aeeahOW6pu+8jOiusOS4ulREKHZpKSDjgILljbNcclxuIFREKHZpKT1PRCh2aSkrSUQodmkpXHJcbiAqXHJcbiAqIOi3r+W+hChQYXRoKeOAgei3r+W+hOmVv+W6puOAgeWbnui3ryhDeWNsZSkg77ya5a+55peg5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul5LuO6aG254K5dmnnu4/ov4foi6XlubLmnaHovrnog73liLDovr52au+8jOensOmhtueCuXZp5ZKMdmrmmK/ov57pgJrnmoTvvIzlj4jnp7Dpobbngrl2aeWIsHZq5pyJ6Lev5b6E44CCXHJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzku47pobbngrl2aeWIsHZq5pyJ5pyJ5ZCR6Lev5b6E77yM5oyH55qE5piv5LuO6aG254K5dmnnu4/ov4foi6XlubLmnaHmnInlkJHovrko5bynKeiDveWIsOi+vnZq44CCXHJcbiDmiJbot6/lvoTmmK/lm75H5Lit6L+e5o6l5Lik6aG254K55LmL6Ze05omA57uP6L+H55qE6aG254K55bqP5YiX44CC5Y2zXHJcbiBQYXRoPXZpMHZpMeKApnZpbSDvvIx2aWriiIhW5LiUKHZpai0xLCB2aWop4oiIRSAgIGo9MSwyLCDigKYsbVxyXG4g5oiWXHJcbiBQYXRoPXZpMHZpMSDigKZ2aW0g77yMdmlq4oiIVuS4lDx2aWotMSwgdmlqPuKIiEUgIGo9MSwyLCDigKYsbVxyXG4g6Lev5b6E5LiK6L655oiW5pyJ5ZCR6L65KOW8pynnmoTmlbDnm67np7DkuLror6Xot6/lvoTnmoTplb/luqbjgIJcclxuIOWcqOS4gOadoei3r+W+hOS4re+8jOiLpeayoeaciemHjeWkjeebuOWQjOeahOmhtueCue+8jOivpei3r+W+hOensOS4uueugOWNlei3r+W+hO+8m+esrOS4gOS4qumhtueCueWSjOacgOWQjuS4gOS4qumhtueCueebuOWQjOeahOi3r+W+hOensOS4uuWbnui3ryjnjq8p77yb5Zyo5LiA5Liq5Zue6Lev5Lit77yM6Iul6Zmk56ys5LiA5Liq5LiO5pyA5ZCO5LiA5Liq6aG254K55aSW77yM5YW25L2Z6aG254K55LiN6YeN5aSN5Ye6546w55qE5Zue6Lev56ew5Li6566A5Y2V5Zue6LevKOeugOWNleeOrynjgIJcclxuICpcclxuICog6L+e6YCa5Zu+44CB5Zu+55qE6L+e6YCa5YiG6YeP77ya5a+55peg5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74Cidmkg77yMdmog4oiIVu+8jHZp5ZKMdmrpg73mmK/ov57pgJrnmoTvvIzliJnnp7Dlm75H5piv6L+e6YCa5Zu+77yM5ZCm5YiZ56ew5Li66Z2e6L+e6YCa5Zu+44CC6IulR+aYr+mdnui/numAmuWbvu+8jOWImeaegeWkp+eahOi/numAmuWtkOWbvuensOS4ukfnmoTov57pgJrliIbph4/jgIJcclxuIOWvueacieWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZpIO+8jHZqIOKIiFbvvIzpg73mnInku6V2aeS4uui1t+eCue+8jCB2aiDkuLrnu4jngrnku6Xlj4rku6V2auS4uui1t+eCue+8jHZp5Li657uI54K555qE5pyJ5ZCR6Lev5b6E77yM56ew5Zu+R+aYr+W8uui/numAmuWbvu+8jOWQpuWImeensOS4uumdnuW8uui/numAmuWbvuOAguiLpUfmmK/pnZ7lvLrov57pgJrlm77vvIzliJnmnoHlpKfnmoTlvLrov57pgJrlrZDlm77np7DkuLpH55qE5by66L+e6YCa5YiG6YeP44CCXHJcbiDigJzmnoHlpKfigJ3nmoTlkKvkuYnvvJrmjIfnmoTmmK/lr7nlrZDlm77lho3lop7liqDlm75H5Lit55qE5YW25a6D6aG254K577yM5a2Q5Zu+5bCx5LiN5YaN6L+e6YCa44CCXHJcbiDnlJ/miJDmoJHjgIHnlJ/miJDmo67mnpfvvJrkuIDkuKrov57pgJrlm74o5peg5ZCR5Zu+KeeahOeUn+aIkOagkeaYr+S4gOS4quaegeWwj+i/numAmuWtkOWbvu+8jOWug+WQq+acieWbvuS4reWFqOmDqG7kuKrpobbngrnlkozlj6rmnInotrPku6XmnoTmiJDkuIDmo7XmoJHnmoRuLTHmnaHovrnvvIznp7DkuLrlm77nmoTnlJ/miJDmoJHjgIJcclxuIOWFs+S6juaXoOWQkeWbvueahOeUn+aIkOagkeeahOWHoOS4que7k+iuuu+8mlxyXG4g4peGIOS4gOajteaciW7kuKrpobbngrnnmoTnlJ/miJDmoJHmnInkuJTku4XmnIluLTHmnaHovrnvvJtcclxuIOKXhiDlpoLmnpzkuIDkuKrlm77mnIlu5Liq6aG254K55ZKM5bCP5LqObi0x5p2h6L6577yM5YiZ5piv6Z2e6L+e6YCa5Zu+77ybXHJcbiDil4Yg5aaC5p6c5aSa5LqObi0x5p2h6L6577yM5YiZ5LiA5a6a5pyJ546v77ybXHJcbiDil4Yg5pyJbi0x5p2h6L6555qE5Zu+5LiN5LiA5a6a5piv55Sf5oiQ5qCR44CCXHJcblxyXG4g5pyJ5ZCR5Zu+55qE55Sf5oiQ5qOu5p6X5piv6L+Z5qC35LiA5Liq5a2Q5Zu+77yM55Sx6Iul5bmy5qO15pyJ5ZCR5qCR57uE5oiQ77yM5ZCr5pyJ5Zu+5Lit5YWo6YOo6aG254K544CCXHJcbiDmnInlkJHmoJHmmK/lj6rmnInkuIDkuKrpobbngrnnmoTlhaXluqbkuLowIO+8jOWFtuS9memhtueCueeahOWFpeW6puWdh+S4ujHnmoTmnInlkJHlm77jgIJcclxuXHJcbiAqXHJcbiAqIOe9ke+8muavj+S4qui+uSjmiJblvKcp6YO96ZmE5Yqg5LiA5Liq5p2D5YC855qE5Zu+77yM56ew5Li65bim5p2D5Zu+44CC5bim5p2D55qE6L+e6YCa5Zu+KOWMheaLrOW8sei/numAmueahOacieWQkeWbvinnp7DkuLrnvZHmiJbnvZHnu5zjgILnvZHnu5zmmK/lt6XnqIvkuIrluLjnlKjnmoTkuIDkuKrmpoLlv7XvvIznlKjmnaXooajnpLrkuIDkuKrlt6XnqIvmiJbmn5Dnp43mtYHnqItcclxuICovXHJcblxyXG4vKipcclxuICog5Zu+55qE5a2Y5YKo57uT5p6EXHJcbiAqXHJcbiDlm77nmoTlrZjlgqjnu5PmnoTmr5TovoPlpI3mnYLvvIzlhbblpI3mnYLmgKfkuLvopoHooajnjrDlnKjvvJpcclxuIOKXhiDku7vmhI/pobbngrnkuYvpl7Tlj6/og73lrZjlnKjogZTns7vvvIzml6Dms5Xku6XmlbDmja7lhYPntKDlnKjlrZjlgqjljLrkuK3nmoTniannkIbkvY3nva7mnaXooajnpLrlhYPntKDkuYvpl7TnmoTlhbPns7vjgIJcclxuIOKXhiDlm77kuK3pobbngrnnmoTluqbkuI3kuIDmoLfvvIzmnInnmoTlj6/og73nm7jlt67lvojlpKfvvIzoi6XmjInluqbmlbDmnIDlpKfnmoTpobbngrnorr7orqHnu5PmnoTvvIzliJnkvJrmtarotLnlvojlpJrlrZjlgqjljZXlhYPvvIzlj43kuYvmjInmr4/kuKrpobbngrnoh6rlt7HnmoTluqborr7orqHkuI3lkIznmoTnu5PmnoTvvIzlj4jkvJrlvbHlk43mk43kvZzjgIJcclxuIOWbvueahOW4uOeUqOeahOWtmOWCqOe7k+aehOacie+8mumCu+aOpeefqemYteOAgemCu+aOpemTvuihqOOAgeWNgeWtl+mTvuihqOOAgemCu+aOpeWkmumHjeihqOWSjOi+ueihqOOAglxyXG4gKi9cclxuXHJcbi8qXHJcbiDpgrvmjqXnn6npmLUo5pWw57uEKeihqOekuuazlVxyXG5cclxuIOWfuuacrOaAneaDs++8muWvueS6juaciW7kuKrpobbngrnnmoTlm77vvIznlKjkuIDnu7TmlbDnu4R2ZXhzW25d5a2Y5YKo6aG254K55L+h5oGv77yM55So5LqM57u05pWw57uEQVtuXVtuXeWtmOWCqOmhtueCueS5i+mXtOWFs+ezu+eahOS/oeaBr+OAguivpeS6jOe7tOaVsOe7hOensOS4uumCu+aOpeefqemYteOAguWcqOmCu+aOpeefqemYteS4re+8jOS7pemhtueCueWcqHZleHPmlbDnu4TkuK3nmoTkuIvmoIfku6PooajpobbngrnvvIzpgrvmjqXnn6npmLXkuK3nmoTlhYPntKBBW2ldW2pd5a2Y5pS+55qE5piv6aG254K5aeWIsOmhtueCuWrkuYvpl7TlhbPns7vnmoTkv6Hmga/jgIJcclxuXHJcbiAxICDml6DlkJHlm77nmoTmlbDnu4TooajnpLpcclxuXHJcbiAoMSkgIOaXoOadg+WbvueahOmCu+aOpeefqemYtVxyXG4g5peg5ZCR5peg5p2D5Zu+Rz0oVu+8jEUp5pyJbihu4omnMSnkuKrpobbngrnvvIzlhbbpgrvmjqXnn6npmLXmmK9u6Zi25a+556ew5pa56Zi144CC5YW25YWD57Sg55qE5a6a5LmJ5aaC5LiL77yaXHJcbiAgICAgICAgICAgIC0tIDEgICDoi6UodmkgLCB2ainiiIhF77yM5Y2zdmkgLCB2aumCu+aOpVxyXG4gQVtpXVtqXT1cclxuICAgICAgICAgICAgIC0tIDAgICDoi6UodmkgLCB2ainiiIlF77yM5Y2zdmkgLCB2auS4jemCu+aOpVxyXG5cclxuICgyKSAg5bim5p2D5Zu+55qE6YK75o6l55+p6Zi1XHJcbiDml6DlkJHluKbmnYPlm75HPShW77yMRSkg55qE6YK75o6l55+p6Zi144CC5YW25YWD57Sg55qE5a6a5LmJ5aaC5LiL77yaXHJcbiAgICAgICAgICAgIC0tIFdpaiAgICDoi6UodmkgLCB2ainiiIhF77yM5Y2zdmkgLCB2aumCu+aOpe+8jOadg+WAvOS4undpalxyXG4gQVtpXVtqXT1cclxuXHJcbiAgICAgICAgICAgIC0tIOKIniAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6l5pe2XHJcblxyXG4gKDMpICDml6DlkJHlm77pgrvmjqXnn6npmLXnmoTnibnmgKdcclxuIOKXhiDpgrvmjqXnn6npmLXmmK/lr7nnp7DmlrnpmLVcclxuIOKXhiDlr7nkuo7pobbngrl2ae+8jOWFtuW6puaVsOaYr+esrGnooYznmoTpnZ4w5YWD57Sg55qE5Liq5pWw77ybXHJcbiDil4Yg5peg5ZCR5Zu+55qE6L655pWw5piv5LiKKOaIluS4iynkuInop5LlvaLnn6npmLXkuK3pnZ4w5YWD57Sg5Liq5pWw44CCXHJcblxyXG4gMiAg5pyJ5ZCR5Zu+55qE5pWw57uE6KGo56S6XHJcblxyXG4gKDEpICDml6DmnYPlm77nmoTpgrvmjqXnn6npmLVcclxuIOiLpeacieWQkeaXoOadg+Wbvkc9KFbvvIxFKeaciW4obuKJpzEp5Liq6aG254K577yM5YiZ5YW26YK75o6l55+p6Zi15pivbumYtuWvueensOaWuemYteOAguWFg+e0oOWumuS5ieWmguS4i++8mlxyXG4gICAgICAgICAgICAtLSAxICAg6IulPHZpLCB2aj7iiIhF77yM5LuOdmnliLB2auacieW8p1xyXG4gQVtpXVtqXT1cclxuICAgICAgICAgICAgLS0gMCAgIOiLpTx2aSAsIHZqPuKIiUUgIOS7jnZp5Yiwdmog5rKh5pyJ5bynXHJcblxyXG4gKDIpICDluKbmnYPlm77nmoTpgrvmjqXnn6npmLVcclxuIOacieWQkeW4puadg+Wbvkc9KFbvvIxFKeeahOmCu+aOpeefqemYteOAguWFtuWFg+e0oOeahOWumuS5ieWmguS4i++8mlxyXG4gICAgICAgICAgICAtLSB3aWogICAg6IulPHZpLHZqPuKIiEXvvIzljbN2aSAsIHZq6YK75o6l77yM5p2D5YC85Li6d2lqXHJcbiBBW2ldW2pdPVxyXG4gICAgICAgICAgICDiiJ4gICDoi6U8dmksdmo+4oiJRe+8jOWNs3ZpICwgdmrkuI3pgrvmjqXml7ZcclxuXHJcbiDikbYg5pyJ5ZCR5Zu+6YK75o6l55+p6Zi155qE54m55oCnXHJcbiDil4Yg5a+55LqO6aG254K5dmnvvIznrKxp6KGM55qE6Z2eMOWFg+e0oOeahOS4quaVsOaYr+WFtuWHuuW6pk9EKHZpKe+8m+esrGnliJfnmoTpnZ4w5YWD57Sg55qE5Liq5pWw5piv5YW25YWl5bqmSUQodmkpIOOAglxyXG4g4peGIOmCu+aOpeefqemYteS4remdnjDlhYPntKDnmoTkuKrmlbDlsLHmmK/lm77nmoTlvKfnmoTmlbDnm67jgIJcclxuXHJcbiAzICDlm77nmoTpgrvmjqXnn6npmLXnmoTmk43kvZxcclxuXHJcbiDlm77nmoTpgrvmjqXnn6npmLXnmoTlrp7njrDmr5TovoPlrrnmmJPvvIzlrprkuYnkuKTkuKrmlbDnu4TliIbliKvlrZjlgqjpobbngrnkv6Hmga8o5pWw5o2u5YWD57SgKeWSjOi+ueaIluW8p+eahOS/oeaBryjmlbDmja7lhYPntKDkuYvpl7TnmoTlhbPns7spIOOAglxyXG5cclxuICovXHJcblxyXG5pbXBvcnQgU3RhY2sgZnJvbSAnLi4vU3RhY2svaW5kZXgnO1xyXG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vUXVldWUvUXVldWUnO1xyXG5pbXBvcnQgeyBDaGlsZFNpYmxpbmdUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcclxuXHJcbi8vIOWbvueahOaVsOe7hO+8iOmCu+aOpeefqemYte+8ieWtmOWCqOihqOekulxyXG5jb25zdCBERyA9IDE7ICAgICAvLyDmnInlkJHlm75cclxuY29uc3QgRE4gPSAyOyAgICAgLy8g5pyJ5ZCR572RXHJcbmNvbnN0IFVERyA9IDM7ICAgIC8vIOaXoOWQkeWbvlxyXG5jb25zdCBVRE4gPSA0OyAgICAvLyDml6DlkJHnvZFcclxuXHJcblxyXG5jbGFzcyBBcmNDZWxsIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhZGpcclxuICAgICAqIEBwYXJhbSB7Kn0gaW5mb1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFkaiwgaW5mbyA9IG51bGwpe1xyXG4gICAgICAgIC8vIOmhtueCueexu+Wei+OAguWvueS6juaXoOadg+Wbvu+8jOeUqDHmiJYw6KGo56S655u46YK75ZCm77yb5a+55bim5p2D5Zu+77yM5YiZ5Li65p2D5YC857G75Z6LXHJcbiAgICAgICAgdGhpcy5hZGogPSB0eXBlb2YgYWRqID09PSAnbnVtYmVyJyA/IGFkaiA6IEluZmluaXR5O1xyXG4gICAgICAgIC8vIOivpeW8p+ebuOWFs+S/oeaBr1xyXG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGphY2VuY3lNYXRyaXhHcmFwaCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2ZXhzIOmhtueCueWQkemHj1xyXG4gICAgICogQHBhcmFtIHtBcnJheSB8IEFyY0NlbGx9IGFyY3Mg6YK75o6l55+p6Zi1XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmV4bnVtXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJjbnVtXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2luZFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZleHMgPSBbXSwgYXJjcyA9IFtdLCB2ZXhudW0gPSAwLCBhcmNudW0gPSAwLCBraW5kID0gREcpe1xyXG4gICAgICAgIC8vIOmhtueCueWQkemHj1xyXG4gICAgICAgIHRoaXMudmV4cyA9IHZleHM7XHJcbiAgICAgICAgLy8g6YK75o6l55+p6Zi1XHJcbiAgICAgICAgdGhpcy5hcmNzID0gYXJjcztcclxuICAgICAgICAvLyDlm77nmoTlvZPliY3pobbngrnmlbBcclxuICAgICAgICB0aGlzLnZleG51bSA9IHZleG51bTtcclxuICAgICAgICAvLyDlm77nmoTlvZPliY3lvKfmlbBcclxuICAgICAgICB0aGlzLmFyY251bSA9IGFyY251bTtcclxuICAgICAgICAvLyDlm77nmoTnp43nsbvmoIflv5dcclxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUdyYXBoKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgREc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlREcodGhpcyk7ICAgICAvLyDmnoTpgKDmnInlkJHlm75cclxuICAgICAgICAgICAgY2FzZSBETjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVETih0aGlzKTsgICAgIC8vIOaehOmAoOacieWQkee9kVxyXG4gICAgICAgICAgICBjYXNlIFVERzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVREcodGhpcyk7ICAgIC8vIOaehOmAoOaXoOWQkeWbvlxyXG4gICAgICAgICAgICBjYXNlIFVETjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVRE4odGhpcyk7ICAgIC8vIOaehOmAoOaXoOWQkee9kVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfpnZ7mnInmlYjnmoTlm77nsbvlnosnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmn6Xmib7pobbngrlcclxuICAgICAqIEBwYXJhbSB7Kn0gdnAg6aG254K55ZCR6YePXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBsb2NhdGVWZXggKHZwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZleHNbaV0gPT09IHZwKSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWQkeWbvuS4reWinuWKoOmhtueCuVxyXG4gICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cclxuICAgICAqL1xyXG4gICAgYWRkVmVydGV4KHZwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG9jYXRlVmV4KHZwKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IGhhcyBleGlzdGVkIScpO1xyXG5cclxuICAgICAgICBsZXQgayA9IHRoaXMudmV4bnVtO1xyXG4gICAgICAgIHRoaXMudmV4c1t0aGlzLnZleG51bSsrXSA9IHZwO1xyXG5cclxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmtpbmQgPT09IERHIHx8IHRoaXMua2luZCA9PT0gVURHID9cclxuICAgICAgICAgICAgMCA6IEluZmluaXR5O1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nbal0gPSB0aGlzLmFyY3Nbal0gfHwgW107XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1trXSA9IHRoaXMuYXJjc1trXSB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdID0gdGhpcy5hcmNzW2pdW2tdIHx8IG5ldyBBcmNDZWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1trXVtqXSA9IHRoaXMuYXJjc1trXVtqXSB8fCBuZXcgQXJjQ2VsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10uYWRqID0gdGhpcy5hcmNzW2tdW2pdLmFkaiA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWQkeWbvuS4reWinuWKoOS4gOadoeW8p1xyXG4gICAgICogQHBhcmFtIHsqfSB2ZXgxIOmhtueCuTHlkJHph49cclxuICAgICAqIEBwYXJhbSB7Kn0gdmV4MiDpobbngrky5ZCR6YePXHJcbiAgICAgKiBAcGFyYW0ge0FyY0NlbGx9IGFyY1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGFkZEFyYyh2ZXgxLCB2ZXgyLCBhcmMpIHtcclxuICAgICAgICBhcmMgPSBhcmMgfHwgbmV3IEFyY0NlbGwodGhpcy5raW5kID09PSBERyB8fCB0aGlzLmtpbmQgPT09IFVERyA/IDEgOiAnd2VpZ2h0Jyk7XHJcbiAgICAgICAgbGV0IGsgPSB0aGlzLmxvY2F0ZVZleCh2ZXgxKTtcclxuICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KHZleDIpO1xyXG5cclxuICAgICAgICBpZiAoayA9PT0gLTEgfHwgaiA9PT0gLTEpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XHJcblxyXG4gICAgICAgIHRoaXMuYXJjc1trXVtqXS5hZGogPSBhcmMuYWRqO1xyXG4gICAgICAgIHRoaXMuYXJjc1trXVtqXS5pbmZvID0gYXJjLmluZm87XHJcbiAgICAgICAgLy8g5peg5ZCR5Zu+5oiW5peg5ZCR572RXHJcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gVURHIHx8IHRoaXMua2luZCA9PT0gVUROKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5hZGogPSBhcmMuYWRqO1xyXG4gICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10uaW5mbyA9IGFyYy5pbmZvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgKyt0aGlzLmFyY251bTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTpobbngrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXgg6KaB5Yig6Zmk55qE6aG254K5XHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZVZleCh2ZXgpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMudmV4bnVtIC0gMTtcclxuICAgICAgICBsZXQgbSA9IHRoaXMubG9jYXRlVmV4KHZleCk7XHJcblxyXG4gICAgICAgIGlmIChtIDwgMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAvLyDlsIblvoXliKDpmaTpobbngrnkuqTmjaLliLDmnIDlkI7kuIDkuKrpobbngrlcclxuICAgICAgICBsZXQgdGVtcCA9IHRoaXMudmV4c1ttXTtcclxuICAgICAgICB0aGlzLnZleHNbbV0gPSB0aGlzLnZleHNbbl07XHJcbiAgICAgICAgdGhpcy52ZXhzW25dID0gdGVtcDtcclxuXHJcbiAgICAgICAgLy8g5bCG6L6555qE5YWz57O76ZqP5LmL5Lqk5o2iXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjc1tpXVttXSA9IHRoaXMuYXJjc1tpXVtuXTtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW21dW2ldID0gdGhpcy5hcmNzW25dW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hcmNzW21dW21dLmFkaiA9IDA7XHJcbiAgICAgICAgdGhpcy52ZXhzLmxlbmd0aCA9IC0tdGhpcy52ZXhudW07XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTovrkodiwgdylcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZUFyYyh2LCB3KSB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcclxuICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KHcpO1xyXG5cclxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJjc1tpXVtqXS5hZGopIHtcclxuICAgICAgICAgICAgdGhpcy5hcmNzW2ldW2pdLmFkaiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDliKTmlq3kuIDkuKrpgrvmjqXnn6npmLXlrZjlgqjnmoTmnInlkJHlm77mmK/lkKblj6/kvKDpgJJcclxuICAgIGlzUGFzcygpIHtcclxuICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMudmV4bnVtOyArK3gpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnZleG51bTsgKyt5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmNzW3hdW3ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aGlzLnZleG51bTsgKyt6KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuYXJjc1t5XVt6XSAmJiAhdGhpcy5hcmNzW3hdW3pdKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmaXJzdEFkalZleCh2KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t2XVtpXS5hZGogIT09IEluZmluaXR5KSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0QWRqVmV4KHYsIHcpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gdyArIDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t2XVtpXS5hZGogIT09IEluZmluaXR5KSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDlr7npgrvmjqXnn6npmLXlm77kvZzpgJLlvZLlvI/mt7HluqbkvJjlhYjpgY3ljoZcclxuICAgIERGU1RyYXZlcnNlKHZpc2l0Rm4pIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIC8vIOiuv+mXruagh+W/l+aVsOe7hOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmcyh0aGlzLCBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdmVydGV4KSB7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdmVydGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChncmFwaCwgdmVydGV4KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JhcGgudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmFwaC5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSAwICYmIGdyYXBoLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIGRmcyhncmFwaCwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6Z2e6YCS5b2SXHJcbiAgICBERlNUcmF2ZXJzZV9Ob25SZWN1cnNlKHZpc2l0Rm4pIHtcclxuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XHJcbiAgICAgICAgLy8g6K6/6Zeu5qCH5b+X5pWw57uE5Yid5aeL5YyWXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChtZSwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodmVydGV4ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChtZSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW2pdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5a+56YK75o6l55+p6Zi15Zu+5L2c5bm/5bqm5LyY5YWI6YGN5Y6GXHJcbiAgICBCRlNUcmF2ZXJzZSh2aXNpdEZuKSB7XHJcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xyXG4gICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcXVldWUuZGVRdWV1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t1XVtqXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3VdW2pdLmFkaiAhPT0gSW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICF2aXNpdGVkW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW2pdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbWluU3BhblRyZWVfUFJJTSh1KSB7XHJcbiAgICAgICAgbGV0IGNsb3NlZGdlID0gW107XHJcblxyXG4gICAgICAgIC8vIOWIneWni+WMllxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICBjbG9zZWRnZVtqXSA9IHthZGp2ZXg6IHUsIGxvd2Nvc3Q6ICt0aGlzLmFyY3Nbal1bdV0uYWRqfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvc2VkZ2VbdV0ubG93Y29zdCA9IDA7XHJcblxyXG4gICAgICAgIGxldCB0ZSA9IFtdO1xyXG4gICAgICAgIC8vIOmAieaLqeWFtuS9mXRoaXMudmV4bnVtIC0gMeS4qumhtueCuVxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW0gLSAxOyArK2opIHtcclxuICAgICAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICBsZXQgaztcclxuICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkZ2Vbdl0ubG93Y29zdCAhPT0gMCAmJiBjbG9zZWRnZVt2XS5sb3djb3N0IDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2xvc2VkZ2Vbdl0ubG93Y29zdDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGVbal0gPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXgxOiBjbG9zZWRnZVtrXS5hZGp2ZXgsXHJcbiAgICAgICAgICAgICAgICB2ZXgyOiBrLFxyXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiBjbG9zZWRnZVtrXS5sb3djb3N0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNsb3NlZGdlW2tdLmxvd2Nvc3QgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3Nbdl1ba10uYWRqIDwgY2xvc2VkZ2Vbdl0ubG93Y29zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZGdlW3ZdLmxvd2Nvc3QgPSB0aGlzLmFyY3Nbdl1ba10uYWRqO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZGdlW3ZdLmFkanZleCA9IGs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZTtcclxuICAgIH1cclxuXHJcbiAgICBtaW5TcGFuVHJlZV9LcnVza2FsKCkge1xyXG4gICAgICAgIGxldCBzZXQgPSBbXTtcclxuICAgICAgICBsZXQgdGUgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHNldFtpXSA9IGk7XHJcblxyXG4gICAgICAgIGxldCBrID0gMDtcclxuICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IGEgPSAwO1xyXG4gICAgICAgIGxldCBiID0gMDtcclxuICAgICAgICB3aGlsZShrIDwgdGhpcy52ZXhudW0gLSAxKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBqID0gaSArIDE7IGogPCB0aGlzLnZleG51bTsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmFyY3NbaV1bal0uYWRqIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHRoaXMuYXJjc1tpXVtqXS5hZGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNldFthXSAhPT0gc2V0W2JdKXtcclxuICAgICAgICAgICAgICAgIHRlW2srK10gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmV4MTogYSxcclxuICAgICAgICAgICAgICAgICAgICB2ZXgyOiBiLFxyXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogdGhpcy5hcmNzW2FdW2JdLmFkalxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2V0W2ldID09PSBzZXRbYl0gJiYgaSAhPT0gYilcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0W2ldID0gc2V0W2FdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0W2JdID0gc2V0W2FdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtaW4gPSB0aGlzLmFyY3NbYV1bYl0uYWRqID0gSW5maW5pdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlKhEaWprc3RyYeeul+azleaxguacieWQkee9keeahHYw6aG254K55Yiw5YW25L2Z6aG254K5dueahOacgOefrei3r+W+hHByZVt2XeWPiuWFtuW4puadg+mVv+W6pmRpc3Rbdl3jgIJcclxuICAgICAqIOiLpXByZVt2XVt3XeS4unRydWXvvIzliJl35piv5LuOdjDliLB25b2T5YmN5rGC5b6X5pyA55+t6Lev5b6E5LiK55qE6aG254K544CCXHJcbiAgICAgKiBmaW5hbFt2XeS4unRydWXlvZPkuJTku4XlvZN24oiIU++8jOWNs+W3sue7j+axguW+l3Yw5YiwdueahOacgOefrei3r+W+hFxyXG4gICAgICogQHBhcmFtIHYwXHJcbiAgICAgKi9cclxuICAgIHNob3J0ZXN0UGF0aF9EaWprc3RyYSh2MCkge1xyXG4gICAgICAgIGxldCBwcmUgPSBbXTtcclxuICAgICAgICBsZXQgZGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBmaW5hbCA9IFtdO1xyXG4gICAgICAgIGxldCB3LCB2O1xyXG5cclxuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpIHtcclxuICAgICAgICAgICAgZmluYWxbdl0gPSBmYWxzZTtcclxuICAgICAgICAgICAgZGlzdFt2XSA9IHRoaXMuYXJjc1t2MF1bdl0uYWRqO1xyXG4gICAgICAgICAgICBwcmVbdl0gPSBwcmVbdl0gfHwgW107XHJcbiAgICAgICAgICAgIC8vIOiuvuepuui3r+W+hFxyXG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykgcHJlW3ZdW3ddID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChkaXN0W3ZdIDwgSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHJlW3ZdW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Yid5aeL5YyW77yMdjDpobbngrnlsZ7kuo5T6ZuGXHJcbiAgICAgICAgZGlzdFt2MF0gPSAwO1xyXG4gICAgICAgIGZpbmFsW3YwXSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIOW8gOWni+S4u+W+queOr++8jOavj+asoeaxguW+l3Yw5Yiw5p+Q5LiqdumhtueCueeahOacgOefrei3r+W+hO+8jOW5tuWKoHbliLBT6ZuGXHJcblxyXG4gICAgICAgIC8vIOWFtuS9meeahOmhtueCuVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIC8vIOW9k+WJjeaJgOaMh+emu3Yw6aG254K555qE5pyA6L+R6Led56a7XHJcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB36aG254K55ZyoViAtIFPkuK1cclxuICAgICAgICAgICAgICAgIC8vIOS4lHfpobbngrnnprt2MOmhtueCueabtOi/kVxyXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBkaXN0W3ddIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdFt3XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g56a7djDpobbngrnmnIDov5HnmoR25Yqg5YWlU+mbhlxyXG4gICAgICAgICAgICBmaW5hbFt2XSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIOabtOaWsOW9k+WJjeacgOefrei3r+W+hOWPiui3neemu1xyXG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBtaW4gKyB0aGlzLmFyY3Nbdl1bd10uYWRqIDwgZGlzdFt3XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Rbd10gPSBtaW4gKyB0aGlzLmFyY3Nbdl1bd10uYWRqO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcclxuICAgICAgICAgICAgICAgICAgICBwcmVbd11bd10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhmaW5hbCk7XHJcbiAgICAgICAgY29uc29sZS5sb2cocHJlKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhkaXN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmluYWw6IGZpbmFsLFxyXG4gICAgICAgICAgICBwcmU6IHByZSxcclxuICAgICAgICAgICAgZGlzdDogZGlzdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc2hvcnRlc3RQYXRoX0ZMT1lEKCkge1xyXG4gICAgICAgIGxldCBhID0gW107XHJcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XHJcbiAgICAgICAgICAgIGFbal0gPSBhW2pdIHx8IFtdO1xyXG4gICAgICAgICAgICBwYXRoW2pdID0gcGF0aFtqXSB8fCBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XHJcbiAgICAgICAgICAgICAgICBpZihqID09PSBrKSBhW2pdW2tdID0gMDtcclxuICAgICAgICAgICAgICAgIGVsc2UgYVtqXVtrXSA9IHRoaXMuYXJjc1tqXVtrXS5hZGo7XHJcbiAgICAgICAgICAgICAgICBwYXRoW2pdW2tdID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhW2pdW21dICsgYVttXVtrXSA8IGFbal1ba10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYVtqXVtrXSA9IGFbal1bbV0gKyBhW21dW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoW2pdW2tdID0gbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMudmV4bnVtOyArK2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChqICE9PSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVk5YiwJWTnmoTmnIDnn63ot6/lvoTkuLrvvJonLCBqLCBrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWQgJywgaik7IHBybl9wYXNzKGosIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZCAnLCBrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn5pyA55+t6Lev5b6E6ZW/5bqm5Li677yaICVkJywgYVtqXVtrXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBybl9wYXNzKGosIGspIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhbal1ba10gIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBwcm5fcGFzcyhqLCBwYXRoW2pdW2tdKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcsICVkJywgcGF0aFtqXVtrXSk7XHJcbiAgICAgICAgICAgICAgICBwcm5fcGFzcyhwYXRoW2pdW2tdLCBrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubGV0IGNyZWF0ZURHID0gY3JlYXRlR3JhcGgoREcpO1xyXG5sZXQgY3JlYXRlRE4gPSBjcmVhdGVHcmFwaChETik7XHJcbmxldCBjcmVhdGVVREcgPSBjcmVhdGVHcmFwaChVREcpO1xyXG5sZXQgY3JlYXRlVUROID0gY3JlYXRlR3JhcGgoVUROKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUdyYXBoKGtpbmQpIHtcclxuICAgIGxldCBhZGo7XHJcbiAgICBsZXQgc2V0TWF0cml4VmFsdWU7XHJcblxyXG4gICAgaWYgKGtpbmQgPT09IDIgfHwga2luZCA9PT0gNCkge1xyXG4gICAgICAgIGFkaiA9IEluZmluaXR5O1xyXG4gICAgICAgIHNldE1hdHJpeFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbXB0KCd3ZWlnaHQ6ICcpO1xyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkaiA9IDA7XHJcbiAgICAgICAgc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChBZGphY2VuY3lNYXRyaXhHcmFwaCkge1xyXG4gICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bSA9IHBhcnNlSW50KHByb21wdCgndmV4bnVtOiAnKSwgMTApO1xyXG4gICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY251bSA9IHBhcnNlSW50KHByb21wdCgnYXJjbnVtOiAnKSwgMTApO1xyXG4gICAgICAgIC8vIGluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXHJcbiAgICAgICAgbGV0IGluY0luZm8gPSBwYXJzZUludChwcm9tcHQoJ2luY0luZm86ICcpLCAxMCk7XHJcblxyXG4gICAgICAgIC8vIOaehOmAoOmhtueCueWQkemHj1xyXG4gICAgICAgIGxldCBpLCBqO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW07ICsraSkgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4c1tpXSA9IHByb21wdCgn6aG254K55ZCR6YePdmV4OiAnKTtcclxuXHJcbiAgICAgICAgLy8g5Yid5aeL5YyW6YK75o6l55+p6Zi1XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW07ICsraikge1xyXG4gICAgICAgICAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXSA9IEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV0gfHwgW107XHJcbiAgICAgICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdID0gbmV3IEFyY0NlbGwoYWRqLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5p6E6YCg6YK75o6l55+p6Zi1XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNudW07ICsraykge1xyXG4gICAgICAgICAgICAvLyDovpPlhaXkuIDmnaHovrnkvp3pmYTnmoTpobbngrnlj4rmnYPlgLxcclxuICAgICAgICAgICAgbGV0IHYxID0gcHJvbXB0KCd2MTogJyk7XHJcbiAgICAgICAgICAgIGxldCB2MiA9IHByb21wdCgndjI6ICcpO1xyXG5cclxuICAgICAgICAgICAgLy8g56Gu5a6adjHvvIx2MuWcqEfkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgaSA9IEFkamFjZW5jeU1hdHJpeEdyYXBoLmxvY2F0ZVZleCh2MSk7XHJcbiAgICAgICAgICAgIGogPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5sb2NhdGVWZXgodjIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHcgPSBzZXRNYXRyaXhWYWx1ZSgpO1xyXG4gICAgICAgICAgICAvLyDlvKc8djEsIHYyPueahOadg+WAvFxyXG4gICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdLmFkaiA9IHc7XHJcbiAgICAgICAgICAgIGlmIChpbmNJbmZvKSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdLmluZm8gPSBwcm9tcHQoJ2luZm86ICcpO1xyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gMyB8fCBraW5kID09PSA0KSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2pdW2ldID0gQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyDnrKzkuIDnp43liJvlu7rlm77mlrnms5VcclxubGV0IHZleHMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xyXG5sZXQgYXJjcyA9IFtcclxuICAgIFtcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIyXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICB7XCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIzXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIzXCIsIFwiaW5mb1wiOiBudWxsfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICB7XCJhZGpcIjogXCIyXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIzXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIxXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIxXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCIzXCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsfSxcclxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfVxyXG4gICAgXVxyXG5dO1xyXG5sZXQgdWRuID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKHZleHMsIGFyY3MsIDUsIDcsIDQpO1xyXG5cclxuLy8g56ys5LqM56eN5Yib5bu65Zu+5pa55rOVXHJcbmxldCBkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIDIpO1xyXG5kbi5hZGRWZXJ0ZXgoJ2EnKTtcclxuZG4uYWRkVmVydGV4KCdiJyk7XHJcbmRuLmFkZFZlcnRleCgnYycpO1xyXG5kbi5hZGRWZXJ0ZXgoJ2QnKTtcclxuZG4uYWRkVmVydGV4KCdlJyk7XHJcblxyXG5kbi5hZGRBcmMoJ2EnLCAnYicsIHtcclxuICAgIGFkajogNlxyXG59KTtcclxuZG4uYWRkQXJjKCdhJywgJ2MnLCB7XHJcbiAgICBhZGo6IDJcclxufSk7XHJcbmRuLmFkZEFyYygnYycsICdiJywge1xyXG4gICAgYWRqOiAzXHJcbn0pO1xyXG5kbi5hZGRBcmMoJ2MnLCAnZCcsIHtcclxuICAgIGFkajogMVxyXG59KTtcclxuZG4uYWRkQXJjKCdkJywgJ2InLCB7XHJcbiAgICBhZGo6IDRcclxufSk7XHJcbmRuLmFkZEFyYygnYicsICdlJywge1xyXG4gICAgYWRqOiAzXHJcbn0pO1xyXG5kbi5hZGRBcmMoJ2QnLCAnZScsIHtcclxuICAgIGFkajogNVxyXG59KTtcclxuXHJcbmNvbnNvbGUubG9nKGRuKTtcclxuXHJcbi8qXHJcblxyXG4gLy8g56ys5LiJ56eN5Yib5bu65Zu+5pa55rOVXHJcbiBsZXQgZyA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaCgpO1xyXG4gZy5raW5kID0gRE47XHJcbiBnLmNyZWF0ZUdyYXBoKCk7XHJcbiBjb25zb2xlLmxvZyhnKTtcclxuXHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuLypcclxuIOWbvueahOmBjeWOhlxyXG5cclxuIOWbvueahOmBjeWOhihUcmF2ZXJpbmcgR3JhcGgp77ya5LuO5Zu+55qE5p+Q5LiA6aG254K55Ye65Y+R77yM6K6/6YGN5Zu+5Lit55qE5YW25L2Z6aG254K577yM5LiU5q+P5Liq6aG254K55LuF6KKr6K6/6Zeu5LiA5qyh44CC5Zu+55qE6YGN5Y6G566X5rOV5piv5ZCE56eN5Zu+55qE5pON5L2c55qE5Z+656GA44CCXHJcblxyXG4g4peGIOWkjeadguaAp++8muWbvueahOS7u+aEj+mhtueCueWPr+iDveWSjOWFtuS9meeahOmhtueCueebuOmCu+aOpe+8jOWPr+iDveWcqOiuv+mXruS6huafkOS4qumhtueCueWQju+8jOayv+afkOadoei3r+W+hOaQnOe0ouWQjuWPiOWbnuWIsOWOn+mhtueCueOAglxyXG4g4peGIOino+WGs+WKnuazle+8muWcqOmBjeWOhui/h+eoi+S4reiusOS4i+W3suiiq+iuv+mXrui/h+eahOmhtueCueOAguiuvue9ruS4gOS4qui+heWKqeWQkemHj1Zpc2l0ZWRbMeKApm5dKG7kuLrpobbngrnmlbAp77yM5YW25Yid5YC85Li6MO+8jOS4gOaXpuiuv+mXruS6humhtueCuXZp5ZCO77yM5L2/VmlzaXRlZFtpXeS4ujHmiJbkuLrorr/pl67nmoTmrKHluo/lj7fjgIJcclxuIOWbvueahOmBjeWOhueul+azleaciea3seW6puS8mOWFiOaQnOe0oueul+azleWSjOW5v+W6puS8mOWFiOaQnOe0oueul+azleOAglxyXG5cclxuIOa3seW6puS8mOWFiOaQnOe0oihEZXB0aCBGaXJzdCBTZWFyY2gtLURGUynpgY3ljobnsbvkvLzmoJHnmoTlhYjluo/pgY3ljobvvIzmmK/moJHnmoTlhYjluo/pgY3ljobnmoTmjqjlub/jgIJcclxuXHJcbiDnrpfms5XmgJ3mg7NcclxuIOiuvuWIneWni+eKtuaAgeaXtuWbvuS4reeahOaJgOaciemhtueCueacquiiq+iuv+mXru+8jOWIme+8mlxyXG4g4pG0IO+8muS7juWbvuS4reafkOS4qumhtueCuXZp5Ye65Y+R77yM6K6/6ZeudmnvvJvnhLblkI7mib7liLB2aeeahOS4gOS4qumCu+aOpemhtueCuXZpMSDvvJtcclxuIOKRte+8muS7jnZpMeWHuuWPke+8jOa3seW6puS8mOWFiOaQnOe0ouiuv+mXruWSjHZpMeebuOmCu+aOpeS4lOacquiiq+iuv+mXrueahOaJgOaciemhtueCue+8m1xyXG4g4pG277ya6L2s4pG0IO+8jOebtOWIsOWSjHZp55u46YK75o6l55qE5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2iXHJcbiDikbcg77ya57un57ut6YCJ5Y+W5Zu+5Lit5pyq6KKr6K6/6Zeu6aG254K5dmrkvZzkuLrotbflp4vpobbngrnvvIzovawoMSnvvIznm7TliLDlm77kuK3miYDmnInpobbngrnpg73ooqvorr/pl67kuLrmraLjgIJcclxuXHJcblxyXG4g5bm/5bqm5LyY5YWI5pCc57SiKEJyZWFkdGggRmlyc3QgU2VhcmNoLS1CRlMp6YGN5Y6G57G75Ly85qCR55qE5oyJ5bGC5qyh6YGN5Y6G55qE6L+H56iL44CCXHJcblxyXG4g566X5rOV5oCd5oOzXHJcbiDorr7liJ3lp4vnirbmgIHml7blm77kuK3nmoTmiYDmnInpobbngrnmnKrooqvorr/pl67vvIzliJnvvJpcclxuIOKRtCDvvJrku47lm77kuK3mn5DkuKrpobbngrl2aeWHuuWPke+8jOiuv+mXrnZp77ybXHJcbiDikbXvvJrorr/pl652aeeahOaJgOacieebuOmCu+aOpeS4lOacquiiq+iuv+mXrueahOaJgOaciemhtueCuXZpMe+8jHZpMu+8jOKApu+8jHZpbe+8m1xyXG4g4pG277ya5Luldmkx77yMdmky77yMIOKApu+8jHZpbeeahOasoeW6j++8jOS7pXZpaigx4ommauKJpm0p5L6d5q2k5L2c5Li6dmkg77yM6L2s4pG077ybXHJcbiDikbcg77ya57un57ut6YCJ5Y+W5Zu+5Lit5pyq6KKr6K6/6Zeu6aG254K5dmvkvZzkuLrotbflp4vpobbngrnvvIzovazikbTvvIznm7TliLDlm77kuK3miYDmnInpobbngrnpg73ooqvorr/pl67kuLrmraLjgIJcclxuXHJcbiDnlKjlub/luqbkvJjlhYjmkJzntKLnrpfms5XpgY3ljoblm77kuI7mt7HluqbkvJjlhYjmkJzntKLnrpfms5XpgY3ljoblm77nmoTllK/kuIDljLrliKvmmK/pgrvmjqXngrnmkJzntKLmrKHluo/kuI3lkIwuXHJcbiAqL1xyXG5cclxuXHJcblxyXG5jb25zb2xlLmxvZygnREZTVHJhdmVyc2U6IHVkbicpO1xyXG5cclxubGV0IGcxID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgVURHKTtcclxuZzEuYWRkVmVydGV4KCd2MScpO1xyXG5nMS5hZGRWZXJ0ZXgoJ3YzJyk7XHJcbmcxLmFkZFZlcnRleCgndjInKTtcclxuZzEuYWRkVmVydGV4KCd2NCcpO1xyXG5nMS5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5nMS5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XHJcbmcxLmFkZEFyYygndjMnLCAndjEnKTtcclxuZzEuYWRkQXJjKCd2MicsICd2MScpO1xyXG5nMS5hZGRBcmMoJ3YzJywgJ3YyJyk7XHJcblxyXG5cclxuZzEuREZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMudmV4c1t2XSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2coJ0RGU1RyYXZlcnNlX05vblJlY3Vyc2U6IHVkbicpO1xyXG5nMS5ERlNUcmF2ZXJzZV9Ob25SZWN1cnNlKGZ1bmN0aW9uICh2KSB7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdCRlNUcmF2ZXJzZTogJyk7XHJcbmxldCBic2ZHID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgREcpO1xyXG5ic2ZHLmFkZFZlcnRleCgndjEnKTtcclxuYnNmRy5hZGRWZXJ0ZXgoJ3YyJyk7XHJcbmJzZkcuYWRkVmVydGV4KCd2MycpO1xyXG5ic2ZHLmFkZFZlcnRleCgndjQnKTtcclxuYnNmRy5hZGRWZXJ0ZXgoJ3Y1Jyk7XHJcblxyXG5ic2ZHLmFkZEFyYygndjEnLCAndjQnKTtcclxuYnNmRy5hZGRBcmMoJ3YxJywgJ3YyJyk7XHJcbmJzZkcuYWRkQXJjKCd2MycsICd2NScpO1xyXG5ic2ZHLmFkZEFyYygndjMnLCAndjInKTtcclxuYnNmRy5hZGRBcmMoJ3YzJywgJ3YxJyk7XHJcbmJzZkcuYWRkQXJjKCd2NCcsICd2MycpO1xyXG5ic2ZHLmFkZEFyYygndjUnLCAndjQnKTtcclxuXHJcbmJzZkcuQkZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMudmV4c1t2XSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuLypcclxuIOacgOWwj+eUn+aIkOagkVxyXG5cclxuIOWmguaenOi/numAmuWbvuaYr+S4gOS4quW4puadg+Wbvu+8jOWImeWFtueUn+aIkOagkeS4reeahOi+ueS5n+W4puadg++8jOeUn+aIkOagkeS4reaJgOaciei+ueeahOadg+WAvOS5i+WSjOensOS4uueUn+aIkOagkeeahOS7o+S7t+OAglxyXG5cclxuIOacgOWwj+eUn+aIkOagkShNaW5pbXVtIFNwYW5uaW5nIFRyZWUpIO+8muW4puadg+i/numAmuWbvuS4reS7o+S7t+acgOWwj+eahOeUn+aIkOagkeensOS4uuacgOWwj+eUn+aIkOagkeOAglxyXG5cclxuIOacgOWwj+eUn+aIkOagkeWcqOWunumZheS4reWFt+aciemHjeimgeeUqOmAlO+8jOWmguiuvuiuoemAmuS/oee9keOAguiuvuWbvueahOmhtueCueihqOekuuWfjuW4gu+8jOi+ueihqOekuuS4pOS4quWfjuW4guS5i+mXtOeahOmAmuS/oee6v+i3r++8jOi+ueeahOadg+WAvOihqOekuuW7uumAoOmAmuS/oee6v+i3r+eahOi0ueeUqOOAgm7kuKrln47luILkuYvpl7TmnIDlpJrlj6/ku6Xlu7pu74K0KG4tMSkvMuadoee6v+i3r++8jOWmguS9lemAieaLqeWFtuS4reeahG4tMeadoe+8jOS9v+aAu+eahOW7uumAoOi0ueeUqOacgOS9jj9cclxuXHJcbiDmnoTpgKDmnIDlsI/nlJ/miJDmoJHnmoTnrpfms5XmnInorrjlpJrvvIzln7rmnKzljp/liJnmmK/vvJpcclxuIOKXhiDlsL3lj6/og73pgInlj5bmnYPlgLzmnIDlsI/nmoTovrnvvIzkvYbkuI3og73mnoTmiJDlm57ot6/vvJtcclxuIOKXhiDpgInmi6luLTHmnaHovrnmnoTmiJDmnIDlsI/nlJ/miJDmoJHjgIJcclxuIOS7peS4iueahOWfuuacrOWOn+WImeaYr+WfuuS6jk1TVOeahOWmguS4i+aAp+i0qO+8mlxyXG4g6K6+Rz0oVu+8jEUp5piv5LiA5Liq5bim5p2D6L+e6YCa5Zu+77yMVeaYr+mhtueCuembhlbnmoTkuIDkuKrpnZ7nqbrlrZDpm4bjgILoi6V14oiIVSDvvIx24oiIVi1V77yM5LiUKHUsIHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOWImeW/heWtmOWcqOS4gOajteWMheWQq+i+uSh1LCB2KeeahOacgOWwj+eUn+aIkOagkeOAglxyXG5cclxuIOivgeaYju+8miDnlKjlj43or4Hms5Xor4HmmI7jgIJcclxuIOiuvuWbvkfnmoTku7vkvZXkuIDmo7XmnIDlsI/nlJ/miJDmoJHpg73kuI3ljIXlkKvovrkodSx2KeOAguiuvlTmmK9H55qE5LiA5qO155Sf5oiQ5qCR77yM5YiZVOaYr+i/numAmueahO+8jOS7jnXliLB25b+F5pyJ5LiA5p2h6Lev5b6EKHUs4oCmLHYp77yM5b2T5bCG6L65KHUsdinliqDlhaXliLBU5Lit5pe25bCx5p6E5oiQ5LqG5Zue6Lev44CC5YiZ6Lev5b6EKHUsIOKApix2KeS4reW/heacieS4gOadoei+uSh14oCZLHbigJkpIO+8jOa7oei2s3XigJniiIhVIO+8jHbigJniiIhWLVUg44CC5Yig5Y676L65KHXigJksduKAmSkg5L6/5Y+v5raI6Zmk5Zue6Lev77yM5ZCM5pe25b6X5Yiw5Y+m5LiA5qO155Sf5oiQ5qCRVOKAmeOAglxyXG4g55Sx5LqOKHUsdinmmK9V5Lit6aG254K55YiwVi1V5Lit6aG254K55LmL6Ze05p2D5YC85pyA5bCP55qE6L6577yM5pWFKHUsdinnmoTmnYPlgLzkuI3kvJrpq5jkuo4odeKAmSx24oCZKeeahOadg+WAvO+8jFTigJnnmoTku6Pku7fkuZ/kuI3kvJrpq5jkuo5U77yMIFTigJnmmK/ljIXlkKsodSx2KSDnmoTkuIDmo7XmnIDlsI/nlJ/miJDmoJHvvIzkuI7lgYforr7nn5vnm77jgIJcclxuXHJcbiAqL1xyXG5cclxuLypcclxuIOaZrumHjOWnhihQcmltKeeul+azlVxyXG5cclxuIOmAguWQiOi+ueeooOWvhueahOe9kVxyXG5cclxuIOS7jui/numAmue9kU49KFXvvIxFKeS4reaJvuacgOWwj+eUn+aIkOagkVQ9KFXvvIxURSkg44CCXHJcblxyXG4gMSDnrpfms5XmgJ3mg7NcclxuIOKRtCAg6Iul5LuO6aG254K5djDlh7rlj5HmnoTpgKDvvIxVPXt2MH3vvIxURT17fe+8m1xyXG4g4pG1IOWFiOaJvuadg+WAvOacgOWwj+eahOi+uSh177yMdinvvIzlhbbkuK114oiIVeS4lHbiiIhWLVXvvIzlubbkuJTlrZDlm77kuI3mnoTmiJDnjq/vvIzliJlVPSBV4oiqe3Z977yMVEU9VEXiiKp7KHXvvIx2KX0g77ybXHJcbiDikbYg6YeN5aSN4pG1IO+8jOebtOWIsFU9VuS4uuatouOAguWImVRF5Lit5b+F5pyJbi0x5p2h6L6577yMIFQ9KFXvvIxURSnlsLHmmK/mnIDlsI/nlJ/miJDmoJHjgIJcclxuXHJcbiAyLueul+azleWunueOsOivtOaYjlxyXG4g5Li65L6/5LqO566X5rOV5a6e546w77yM6K6+572u5LiA5Liq5LiA57u05pWw57uEY2xvc2VkZ2Vbbl3vvIznlKjmnaXkv53lrZhWLSBV5Lit5ZCE6aG254K55YiwVeS4remhtueCueWFt+acieadg+WAvOacgOWwj+eahOi+ueOAglxyXG4gY2xvc2VkZ2Vbal0uYWRqdmV4PWvvvIzooajmmI7ovrkodmosIHZrKeaYr1YtVeS4remhtueCuXZq5YiwVeS4readg+WAvOacgOWwj+eahOi+ue+8jOiAjOmhtueCuXZr5piv6K+l6L655omA5L6d6ZmE55qEVeS4reeahOmhtueCueOAgiBjbG9zZWRnZVtqXS5sb3djb3N05a2Y5pS+6K+l6L6555qE5p2D5YC844CCXHJcbiDlgYforr7ku47pobbngrl2c+W8gOWni+aehOmAoOacgOWwj+eUn+aIkOagkeOAguWIneWni+aXtuS7pO+8mlxyXG4gQ2xvc2VkZ2Vbc10ubG93Y29zdD0wIO+8muihqOaYjumhtueCuXZz6aaW5YWI5Yqg5YWl5YiwVeS4re+8m1xyXG4gQ2xvc2VkZ2Vba10uYWRqdmV4PXMg77yMQ2xvc2VkZ2Vba10ubG93Y29zdD1jb3N0KGssIHMpXHJcbiDooajnpLpWLVXkuK3nmoTlkITpobbngrnliLBV5Lit5p2D5YC85pyA5bCP55qE6L65KGviiaBzKSDvvIxjb3N0KGssIHMp6KGo56S66L65KHZrLCB2cykg5p2D5YC844CCXHJcblxyXG4gMy7nrpfms5XmraXpqqRcclxuIOKRtCAg5LuOY2xvc2VkZ2XkuK3pgInmi6nkuIDmnaHmnYPlgLwo5LiN5Li6MCnmnIDlsI/nmoTovrkodmssIHZqKSDvvIznhLblkI7lgZrvvJpcclxuIOKRoCDnva5jbG9zZWRnZVtrXS5sb3djb3N05Li6MCDvvIzooajnpLp2a+W3suWKoOWFpeWIsFXkuK3jgIJcclxuIOKRoSAg5qC55o2u5paw5Yqg5YWldmvnmoTmm7TmlrBjbG9zZWRnZeS4reavj+S4quWFg+e0oO+8mlxyXG4g74CidmniiIhWLVUg77yM6IulY29zdChpLCBrKeKJpmNvbHNlZGdlW2ldLmxvd2Nvc3TvvIzooajmmI7lnKhV5Lit5paw5Yqg5YWl6aG254K5dmvlkI7vvIwgKHZpLCB2aynmiJDkuLp2aeWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIznva7vvJpcclxuIENsb3NlZGdlW2ldLmxvd2Nvc3Q9Y29zdChpLCBrKVxyXG4gQ2xvc2VkZ2VbaV0uYWRqdmV4PWtcclxuIOKRtSAg6YeN5aSN4pG0bi0x5qyh5bCx5b6X5Yiw5pyA5bCP55Sf5oiQ5qCR44CCXHJcblxyXG4g566X5rOV5YiG5p6Q77yaXHJcbiDorr7luKbmnYPov57pgJrlm77mnIlu5Liq6aG254K577yM5YiZ566X5rOV55qE5Li76KaB5omn6KGM5piv5LqM6YeN5b6q546v77yaIOaxgmNsb3NlZGdl5Lit5p2D5YC85pyA5bCP55qE6L6577yM6aKR5bqm5Li6bi0x77ybIOS/ruaUuWNsb3NlZGdl5pWw57uE77yM6aKR5bqm5Li6biDjgILlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4yKe+8jOS4jui+ueeahOaVsOebruaXoOWFs+OAglxyXG5cclxuICovXHJcblxyXG51ZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCA0KTtcclxudWRuLmFkZFZlcnRleCgndjEnKTtcclxudWRuLmFkZFZlcnRleCgndjInKTtcclxudWRuLmFkZFZlcnRleCgndjMnKTtcclxudWRuLmFkZFZlcnRleCgndjQnKTtcclxudWRuLmFkZFZlcnRleCgndjUnKTtcclxudWRuLmFkZFZlcnRleCgndjYnKTtcclxuXHJcbnVkbi5hZGRBcmMoJ3YxJywgJ3YyJywge2FkajogNn0pO1xyXG51ZG4uYWRkQXJjKCd2MScsICd2MycsIHthZGo6IDF9KTtcclxudWRuLmFkZEFyYygndjEnLCAndjQnLCB7YWRqOiA1fSk7XHJcbnVkbi5hZGRBcmMoJ3YyJywgJ3YzJywge2FkajogNX0pO1xyXG51ZG4uYWRkQXJjKCd2MicsICd2NScsIHthZGo6IDN9KTtcclxudWRuLmFkZEFyYygndjMnLCAndjQnLCB7YWRqOiA1fSk7XHJcbnVkbi5hZGRBcmMoJ3YzJywgJ3Y1Jywge2FkajogNn0pO1xyXG51ZG4uYWRkQXJjKCd2MycsICd2NicsIHthZGo6IDR9KTtcclxudWRuLmFkZEFyYygndjQnLCAndjYnLCB7YWRqOiAyfSk7XHJcbnVkbi5hZGRBcmMoJ3Y1JywgJ3Y2Jywge2FkajogNn0pO1xyXG5cclxuY29uc29sZS5sb2coJ21pblNwYW5UcmVlX1BSSU06ICcpO1xyXG5jb25zb2xlLmxvZyh1ZG4ubWluU3BhblRyZWVfUFJJTSgwKSk7XHJcblxyXG5cclxuXHJcbi8qXHJcbiDlhYvpsoHmlq/ljaHlsJQoS3J1c2thbCnnrpfms5VcclxuXHJcbiDpgILlkIjovrnnqIDnlo/nmoTnvZFcclxuXHJcbiAxIOeul+azleaAneaDs1xyXG4g6K6+Rz0oViwgRSnmmK/lhbfmnIlu5Liq6aG254K555qE6L+e6YCa572R77yMVD0oVSwgVEUp5piv5YW25pyA5bCP55Sf5oiQ5qCR44CC5Yid5YC877yaVT1W77yMVEU9e30g44CCXHJcbiDlr7lH5Lit55qE6L655oyJ5p2D5YC85aSn5bCP5LuO5bCP5Yiw5aSn5L6d5qyh6YCJ5Y+W44CCXHJcbiDikbQgICDpgInlj5bmnYPlgLzmnIDlsI/nmoTovrkodmnvvIx2ainvvIzoi6XovrkodmnvvIx2ainliqDlhaXliLBUReWQjuW9ouaIkOWbnui3r++8jOWImeiIjeW8g+ivpei+uSjovrkodmnvvIx2aikg77yb5ZCm5YiZ77yM5bCG6K+l6L655bm25YWl5YiwVEXkuK3vvIzljbNURT1UReKIqnsodmnvvIx2ail9IOOAglxyXG4g4pG1IOmHjeWkjeKRtCDvvIznm7TliLBUReS4reWMheWQq+aciW4tMeadoei+ueS4uuatouOAglxyXG4g5aaC5Zu+Ny0yMuaJgOaPkOekuuOAglxyXG5cclxuIDIg566X5rOV5a6e546w6K+05piOXHJcbiBLcnVza2Fs566X5rOV5a6e546w55qE5YWz6ZSu5piv77ya5b2T5LiA5p2h6L655Yqg5YWl5YiwVEXnmoTpm4blkIjlkI7vvIzlpoLkvZXliKTmlq3mmK/lkKbmnoTmiJDlm57ot68/XHJcbiDnroDljZXnmoTop6PlhrPmlrnms5XmmK/vvJrlrprkuYnkuIDkuKrkuIDnu7TmlbDnu4RWc2V0W25dIO+8jOWtmOaUvuWbvlTkuK3mr4/kuKrpobbngrnmiYDlnKjnmoTov57pgJrliIbph4/nmoTnvJblj7fjgIJcclxuIOKXhiDliJ3lgLzvvJpWc2V0W2ldPWnvvIzooajnpLrmr4/kuKrpobbngrnlkIToh6rnu4TmiJDkuIDkuKrov57pgJrliIbph4/vvIzov57pgJrliIbph4/nmoTnvJblj7fnroDljZXlnLDkvb/nlKjpobbngrnlnKjlm77kuK3nmoTkvY3nva4o57yW5Y+3KeOAglxyXG4g4peGIOW9k+W+gFTkuK3lop7liqDkuIDmnaHovrkodmnvvIx2aikg5pe277yM5YWI5qOA5p+lVnNldFtpXeWSjFZzZXRbal3lgLzvvJpcclxuIOKYhiDoi6VWc2V0W2ldPVZzZXRbal3vvJrooajmmI52aeWSjHZq5aSE5Zyo5ZCM5LiA5Liq6L+e6YCa5YiG6YeP5Lit77yM5Yqg5YWl5q2k6L655Lya5b2i5oiQ5Zue6Lev77ybXHJcbiDimIYg6IulVnNldFtpXeKJoFZzZXRbal3vvIzliJnliqDlhaXmraTovrnkuI3kvJrlvaLmiJDlm57ot6/vvIzlsIbmraTovrnliqDlhaXliLDnlJ/miJDmoJHnmoTovrnpm4bkuK3jgIJcclxuIOKXhiDliqDlhaXkuIDmnaHmlrDovrnlkI7vvIzlsIbkuKTkuKrkuI3lkIznmoTov57pgJrliIbph4/lkIjlubbvvJrlsIbkuIDkuKrov57pgJrliIbph4/nmoTnvJblj7fmjaLmiJDlj6bkuIDkuKrov57pgJrliIbph4/nmoTnvJblj7fjgIJcclxuXHJcbiAqL1xyXG5cclxuY29uc29sZS5sb2coJ21pblNwYW5UcmVlX0tydXNrYWw6ICcpO1xyXG5jb25zb2xlLmxvZyh1ZG4ubWluU3BhblRyZWVfS3J1c2thbCgpKTtcclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbiDmnIDnn63ot6/lvoRcclxuXHJcbiDoi6XnlKjluKbmnYPlm77ooajnpLrkuqTpgJrnvZHvvIzlm77kuK3pobbngrnooajnpLrlnLDngrnvvIzovrnku6PooajkuKTlnLDkuYvpl7TmnInnm7TmjqXpgZPot6/vvIzovrnkuIrnmoTmnYPlgLzooajnpLrot6/nqIso5oiW5omA6Iqx6LS555So5oiW5pe26Ze0KSDjgILku47kuIDkuKrlnLDmlrnliLDlj6bkuIDkuKrlnLDmlrnnmoTot6/lvoTplb/luqbooajnpLror6Xot6/lvoTkuIrlkITovrnnmoTmnYPlgLzkuYvlkozjgILpl67popjvvJpcclxuIOKXhiDkuKTlnLDkuYvpl7TmmK/lkKbmnInpgJrot68/XHJcbiDil4Yg5Zyo5pyJ5aSa5p2h6YCa6Lev55qE5oOF5Ya15LiL77yM5ZOq5p2h5pyA55+tP1xyXG4g6ICD6JmR5Yiw5Lqk6YCa572R55qE5pyJ5ZCR5oCn77yM55u05o6l6K6o6K6655qE5piv5bim5p2D5pyJ5ZCR5Zu+55qE5pyA55+t6Lev5b6E6Zeu6aKY77yM5L2G6Kej5Yaz6Zeu6aKY55qE566X5rOV5Lmf6YCC55So5LqO5peg5ZCR5Zu+44CCXHJcbiDlsIbkuIDkuKrot6/lvoTnmoTotbflp4vpobbngrnnp7DkuLrmupDngrnvvIzmnIDlkI7kuIDkuKrpobbngrnnp7DkuLrnu4jngrnjgIJcclxuXHJcblxyXG4g5Y2V5rqQ54K55pyA55+t6Lev5b6EXHJcblxyXG4g5a+55LqO57uZ5a6a55qE5pyJ5ZCR5Zu+Rz0oVu+8jEUp5Y+K5Y2V5Liq5rqQ54K5VnPvvIzmsYJWc+WIsEfnmoTlhbbkvZnlkITpobbngrnnmoTmnIDnn63ot6/lvoTjgIJcclxuIOmSiOWvueWNlea6kOeCueeahOacgOefrei3r+W+hOmXrumimO+8jERpamtzdHJh5o+Q5Ye65LqG5LiA56eN5oyJ6Lev5b6E6ZW/5bqm6YCS5aKe5qyh5bqP5Lqn55Sf5pyA55+t6Lev5b6E55qE566X5rOV77yM5Y2z6L+q5p2w5pav54m55ouJKERpamtzdHJhKeeul+azleOAglxyXG5cclxuIDEg5Z+65pys5oCd5oOzXHJcbiDku47lm77nmoTnu5nlrprmupDngrnliLDlhbblroPlkITkuKrpobbngrnkuYvpl7TlrqLop4LkuIrlupTlrZjlnKjkuIDmnaHmnIDnn63ot6/lvoTvvIzlnKjov5nnu4TmnIDnn63ot6/lvoTkuK3vvIzmjInlhbbplb/luqbnmoTpgJLlop7mrKHluo/vvIzkvp3mrKHmsYLlh7rliLDkuI3lkIzpobbngrnnmoTmnIDnn63ot6/lvoTlkozot6/lvoTplb/luqbjgIJcclxuIOWNs+aMiemVv+W6pumAkuWinueahOasoeW6j+eUn+aIkOWQhOmhtueCueeahOacgOefrei3r+W+hO+8jOWNs+WFiOaxguWHuumVv+W6puacgOWwj+eahOS4gOadoeacgOefrei3r+W+hO+8jOeEtuWQjuaxguWHuumVv+W6puesrOS6jOWwj+eahOacgOefrei3r+W+hO+8jOS+neatpOexu+aOqO+8jOebtOWIsOaxguWHuumVv+W6puacgOmVv+eahOacgOefrei3r+W+hOOAglxyXG5cclxuIDIg566X5rOV5oCd5oOz6K+05piOXHJcbiDorr7nu5nlrprmupDngrnkuLpWc++8jFPkuLrlt7LmsYLlvpfmnIDnn63ot6/lvoTnmoTnu4jngrnpm4bvvIzlvIDlp4vml7bku6RTPXtWc30g44CC5b2T5rGC5b6X56ys5LiA5p2h5pyA55+t6Lev5b6EKFZzIO+8jFZpKeWQju+8jFPkuLp7VnPvvIxWaX0g44CC5qC55o2u5Lul5LiL57uT6K665Y+v5rGC5LiL5LiA5p2h5pyA55+t6Lev5b6E44CCXHJcbiDorr7kuIvkuIDmnaHmnIDnn63ot6/lvoTnu4jngrnkuLpWaiDvvIzliJlWauWPquacie+8mlxyXG4g4peGICDmupDngrnliLDnu4jngrnmnInnm7TmjqXnmoTlvKc8VnPvvIxWaj7vvJtcclxuIOKXhiDku45WcyDlh7rlj5HliLBWaiDnmoTov5nmnaHmnIDnn63ot6/lvoTmiYDnu4/ov4fnmoTmiYDmnInkuK3pl7Tpobbngrnlv4XlrprlnKhT5Lit44CC5Y2z5Y+q5pyJ6L+Z5p2h5pyA55+t6Lev5b6E55qE5pyA5ZCO5LiA5p2h5byn5omN5piv5LuOU+WGheafkOS4qumhtueCuei/nuaOpeWIsFPlpJbnmoTpobbngrlWaiDjgIJcclxuIOiLpeWumuS5ieS4gOS4quaVsOe7hGRpc3Rbbl3vvIzlhbbmr4/kuKpkaXN0W2ld5YiG6YeP5L+d5a2Y5LuOVnMg5Ye65Y+R5Lit6Ze05Y+q57uP6L+H6ZuG5ZCIU+S4reeahOmhtueCueiAjOWIsOi+vlZp55qE5omA5pyJ6Lev5b6E5Lit6ZW/5bqm5pyA5bCP55qE6Lev5b6E6ZW/5bqm5YC877yM5YiZ5LiL5LiA5p2h5pyA55+t6Lev5b6E55qE57uI54K5Vmrlv4XlrprmmK/kuI3lnKhT5Lit5LiU5YC85pyA5bCP55qE6aG254K577yM5Y2z77yaXHJcbiBkaXN0W2ldPU1pbnsgZGlzdFtrXXwgVmviiIhWLVMgfVxyXG4g5Yip55So5LiK6L+w5YWs5byP5bCx5Y+v5Lul5L6d5qyh5om+5Ye65LiL5LiA5p2h5pyA55+t6Lev5b6E44CCXHJcblxyXG4gMyAg566X5rOV5q2l6aqkXHJcbiDikaAg5LukUz17VnN9IO+8jOeUqOW4puadg+eahOmCu+aOpeefqemYteihqOekuuacieWQkeWbvu+8jOWvueWbvuS4reavj+S4qumhtueCuVZp5oyJ5Lul5LiL5Y6f5YiZ572u5Yid5YC877yaXHJcbiAwICAgIGkgPXNcclxuIGRpc3RbaV0gPSAgIFdzaSAgICAgaeKJoHPkuJQ8dnMsdmk+4oiIRe+8jCB3c2nkuLrlvKfkuIrnmoTmnYPlgLxcclxuIOKIniAgIGniiaBz5LiUPHZzLHZpPuS4jeWxnuS6jkVcclxuIOKRoSDpgInmi6nkuIDkuKrpobbngrlWaiDvvIzkvb/lvpfvvJpcclxuIGRpc3Rbal09TWlueyBkaXN0W2tdfCBWa+KIiFYtUyB9XHJcbiBWauWwseaYr+axguW+l+eahOS4i+S4gOadoeacgOefrei3r+W+hOe7iOeCue+8jOWwhlZqIOW5tuWFpeWIsFPkuK3vvIzljbNTPVPiiKp7Vmp9IOOAglxyXG4g4pGiIOWvuVYtU+S4reeahOavj+S4qumhtueCuVZrIO+8jOS/ruaUuWRpc3Rba13vvIzmlrnms5XmmK/vvJpcclxuIOiLpWRpc3Rbal0rV2prPGRpc3Rba13vvIzliJnkv67mlLnkuLrvvJpcclxuIGRpc3Rba109ZGlzdFtqXStXamsgKO+AolZr4oiIVi1TIClcclxuIOKRoyDph43lpI3ikaHvvIzikaLvvIznm7TliLBTPVbkuLrmraLjgIJcclxuXHJcbiA0IOeul+azleWunueOsFxyXG4g55So5bim5p2D55qE6YK75o6l55+p6Zi16KGo56S65pyJ5ZCR5Zu+77yMIOWvuVByaW3nrpfms5XnlaXliqDmlLnliqjlsLHmiJDkuoZEaWprc3RyYeeul+azle+8jOWwhlByaW3nrpfms5XkuK3msYLmr4/kuKrpobbngrlWa+eahGxvd2Nvc3TlgLznlKhkaXN0W2td5Luj5pu/5Y2z5Y+v44CCXHJcbiDil4YgIOiuvuaVsOe7hHByZVtuXeS/neWtmOS7jlZz5Yiw5YW25a6D6aG254K555qE5pyA55+t6Lev5b6E44CC6IulcHJlW2ldPWvvvIzooajnpLrku45WcyDliLBWaeeahOacgOefrei3r+W+hOS4re+8jFZp55qE5YmN5LiA5Liq6aG254K55pivVmvvvIzljbPmnIDnn63ot6/lvoTluo/liJfmmK8oVnMgLCDigKYsIFZrICAsIFZpKSDjgIJcclxuIOKXhiDorr7mlbDnu4RmaW5hbFtuXe+8jOagh+ivhuS4gOS4qumhtueCueaYr+WQpuW3suWKoOWFpVPkuK3jgIJcclxuXHJcbiA1ICDnrpfms5XliIbmnpBcclxuIERpamtzdHJh566X5rOV55qE5Li76KaB5omn6KGM5piv77yaXHJcbiDil4Yg5pWw57uE5Y+Y6YeP55qE5Yid5aeL5YyW77ya5pe26Ze05aSN5p2C5bqm5pivTyhuKSDvvJtcclxuIOKXhiDmsYLmnIDnn63ot6/lvoTnmoTkuozph43lvqrnjq/vvJrml7bpl7TlpI3mnYLluqbmmK9PKG4yKSDvvJtcclxuIOWboOatpO+8jOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08objIpIOOAglxyXG5cclxuICovXHJcblxyXG5sZXQgZGlqVGVzdCA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIEROKTtcclxuXHJcbmRpalRlc3QuYWRkVmVydGV4KCcwJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCcxJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCcyJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCczJyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCc0Jyk7XHJcbmRpalRlc3QuYWRkVmVydGV4KCc1Jyk7XHJcblxyXG5kaWpUZXN0LmFkZEFyYygnMCcsICcxJywge2FkajogMjB9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzAnLCAnNCcsIHthZGo6IDEwfSk7XHJcbmRpalRlc3QuYWRkQXJjKCcwJywgJzInLCB7YWRqOiA2MH0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMCcsICc1Jywge2FkajogNjV9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMicsIHthZGo6IDMwfSk7XHJcbmRpalRlc3QuYWRkQXJjKCcyJywgJzMnLCB7YWRqOiA0MH0pO1xyXG5kaWpUZXN0LmFkZEFyYygnNScsICcyJywge2FkajogMTV9KTtcclxuZGlqVGVzdC5hZGRBcmMoJzQnLCAnNScsIHthZGo6IDIwfSk7XHJcbmRpalRlc3QuYWRkQXJjKCczJywgJzQnLCB7YWRqOiAzNX0pO1xyXG5kaWpUZXN0LmFkZEFyYygnMScsICczJywge2FkajogNzB9KTtcclxuXHJcbmRpalRlc3Quc2hvcnRlc3RQYXRoX0RpamtzdHJhKDApO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbiDmr4/kuIDlr7npobbngrnpl7TnmoTmnIDnn63ot6/lvoRcclxuXHJcbiDnlKhEaWprc3RyYeeul+azleS5n+WPr+S7peaxguW+l+acieWQkeWbvkc9KFbvvIxFKeS4reavj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hOOAguaWueazleaYr++8muavj+asoeS7peS4gOS4quS4jeWQjOeahOmhtueCueS4uua6kOeCuemHjeWkjURpamtzdHJh566X5rOV5L6/5Y+v5rGC5b6X5q+P5LiA5a+56aG254K56Ze055qE5pyA55+t6Lev5b6E77yM5pe26Ze05aSN5p2C5bqm5pivTyhuMykg44CCXHJcblxyXG4g5byX572X5LyK5b63KEZsb3lkKeaPkOWHuuS6huWPpuS4gOS4queul+azle+8jOWFtuaXtumXtOWkjeadguW6puS7jeaYr08objMpIO+8jCDkvYbnrpfms5XlvaLlvI/mm7TkuLrnroDmmI7jgIJcclxuXHJcbiAxIOeul+azleaAneaDs1xyXG5cclxuIOiuvumhtueCuembhlMo5Yid5YC85Li656m6Ke+8jOeUqOaVsOe7hEHnmoTmr4/kuKrlhYPntKBBW2ldW2pd5L+d5a2Y5LuOVmnlj6rnu4/ov4dT5Lit55qE6aG254K55Yiw6L6+VmrnmoTmnIDnn63ot6/lvoTplb/luqbvvIzlhbbmgJ3mg7PmmK/vvJpcclxuIOKRoCDliJ3lp4vml7bku6RTPXsgfSDvvIwgQVtpXVtqXeeahOi1i+WIneWAvOaWueW8j+aYr++8mlxyXG4gMCAgICBpID1q5pe2XHJcbiBBW2ldW2pdPSAgICBXaWogICAgIGniiaBq5LiUPHZpLHZqPuKIiEXvvIwgd2lq5Li65byn5LiK55qE5p2D5YC8XHJcbiDiiJ4gICBp4omgauS4lDx2aSx2aj7kuI3lsZ7kuo5FXHJcbiDikaEg5bCG5Zu+5Lit5LiA5Liq6aG254K5Vmsg5Yqg5YWl5YiwU+S4re+8jOS/ruaUuUFbaV1bal3nmoTlgLzvvIzkv67mlLnmlrnms5XmmK/vvJpcclxuIEFbaV1bal09TWlue0FbaV1bal0gLCAoQVtpXVtrXStBW2tdW2pdKSB9XHJcbiDljp/lm6DvvJog5LuOVmrlj6rnu4/ov4dT5Lit55qE6aG254K5KFZrKeWIsOi+vlZq55qE6Lev5b6E6ZW/5bqm5Y+v6IO95q+U5Y6f5p2l5LiN57uP6L+HVmvnmoTot6/lvoTmm7Tnn63jgIJcclxuIOKRoiDph43lpI3ikaHvvIznm7TliLBH55qE5omA5pyJ6aG254K56YO95Yqg5YWl5YiwU+S4reS4uuatouOAglxyXG5cclxuIDIg566X5rOV5a6e546wXHJcblxyXG4g4peGICDlrprkuYnkuoznu7TmlbDnu4RQYXRoW25dW25dKG7kuLrlm77nmoTpobbngrnmlbApIO+8jOWFg+e0oFBhdGhbaV1bal3kv53lrZjku45WaeWIsFZq55qE5pyA55+t6Lev5b6E5omA57uP6L+H55qE6aG254K544CCXHJcbiDil4Yg6IulUGF0aFtpXVtqXT1r77ya5LuOVmnliLBWaiDnu4/ov4dWayDvvIzmnIDnn63ot6/lvoTluo/liJfmmK8oVmkgLCDigKYsIFZrICwg4oCmLCBWaikg77yM5YiZ6Lev5b6E5a2Q5bqP5YiX77yaKFZpICwg4oCmLCBWaynlkowoVmsgLCDigKYsIFZqKeS4gOWumuaYr+S7jlZp5YiwVmvlkozku45Wa+WIsFZqIOeahOacgOefrei3r+W+hOOAguS7juiAjOWPr+S7peagueaNrlBhdGhbaV1ba13lkoxQYXRoW2tdW2pd55qE5YC85YaN5om+5Yiw6K+l6Lev5b6E5LiK5omA57uP6L+H55qE5YW25a6D6aG254K577yM4oCm5L6d5q2k57G75o6o44CCXHJcbiDil4Yg5Yid5aeL5YyW5Li6UGF0aFtpXVtqXT0tMe+8jOihqOekuuS7jlZp5YiwVmog5LiN57uP6L+H5Lu75L2VKFPkuK3nmoTkuK3pl7Qp6aG254K544CC5b2T5p+Q5Liq6aG254K5VmvliqDlhaXliLBT5Lit5ZCO5L2/QVtpXVtqXeWPmOWwj+aXtu+8jOS7pFBhdGhbaV1bal09a+OAglxyXG5cclxuXHJcbiAqL1xyXG5cclxubGV0IGZsb3lkID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgRE4pO1xyXG5mbG95ZC5hZGRWZXJ0ZXgoJ3YwJyk7XHJcbmZsb3lkLmFkZFZlcnRleCgndjEnKTtcclxuZmxveWQuYWRkVmVydGV4KCd2MicpO1xyXG5mbG95ZC5hZGRBcmMoJ3YwJywgJ3YyJywge2FkajogOH0pO1xyXG5mbG95ZC5hZGRBcmMoJ3YwJywgJ3YxJywge2FkajogMn0pO1xyXG5mbG95ZC5hZGRBcmMoJ3YxJywgJ3YyJywge2FkajogNH0pO1xyXG5mbG95ZC5hZGRBcmMoJ3YyJywgJ3YwJywge2FkajogNX0pO1xyXG5cclxuZmxveWQuc2hvcnRlc3RQYXRoX0ZMT1lEKCk7XHJcblxyXG4vLyBodHRwOi8vYmxvZy5jc2RuLm5ldC9oZ3Vpc3UvYXJ0aWNsZS9kZXRhaWxzLzc3MTk0MjhcclxuLy8g5re75Yqg44CK5Zu+55qE5bqU55So6K+m6KejLeaVsOaNrue7k+aehOOAi1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoLmpzXG4gKiovIiwiLypcclxuIOWNgeWtl+mTvuihqOazlVxyXG5cclxuIOWNgeWtl+mTvuihqChPcnRob2dvbmFsIExpc3Qp5piv5pyJ5ZCR5Zu+55qE5Y+m5LiA56eN6ZO+5byP5a2Y5YKo57uT5p6E77yM5piv5bCG5pyJ5ZCR5Zu+55qE5q2j6YK75o6l6KGo5ZKM6YCG6YK75o6l6KGo57uT5ZCI6LW35p2l5b6X5Yiw55qE5LiA56eN6ZO+6KGo44CCXHJcblxyXG4g5Zyo6L+Z56eN57uT5p6E5Lit77yM5q+P5p2h5byn55qE5byn5aS057uT54K55ZKM5byn5bC+57uT54K56YO95a2Y5pS+5Zyo6ZO+6KGo5Lit77yM5bm25bCG5byn57uT54K55YiG5Yir57uE57uH5Yiw5Lul5byn5bC+57uT54K55Li65aS0KOmhtueCuSnnu5Pngrnlkozku6XlvKflpLTnu5PngrnkuLrlpLQo6aG254K5Kee7k+eCueeahOmTvuihqOS4reOAglxyXG5cclxuIOKXhiAgZGF0YeWfn++8muWtmOWCqOWSjOmhtueCueebuOWFs+eahOS/oeaBr++8m1xyXG4g4peGIOaMh+mSiOWfn2ZpcnN0aW7vvJrmjIflkJHku6Xor6XpobbngrnkuLrlvKflpLTnmoTnrKzkuIDmnaHlvKfmiYDlr7nlupTnmoTlvKfnu5PngrnvvJtcclxuIOKXhiDmjIfpkojln59maXJzdG91dO+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WwvueahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xyXG4g4peGIOWwvuWfn3RhaWx2ZXjvvJrmjIfnpLrlvKflsL7pobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcclxuIOKXhiDlpLTln59oZWFkdmV477ya5oyH56S65byn5aS06aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXHJcbiDil4Yg5oyH6ZKI5Z+faGxpbmvvvJrmjIflkJHlvKflpLTnm7jlkIznmoTkuIvkuIDmnaHlvKfvvJtcclxuIOKXhiDmjIfpkojln590bGlua++8muaMh+WQkeW8p+WwvuebuOWQjOeahOS4i+S4gOadoeW8p++8m1xyXG4g4peGIEluZm/ln5/vvJrmjIflkJHor6XlvKfnmoTnm7jlhbPkv6Hmga/vvJtcclxuXHJcbiDku47ov5nnp43lrZjlgqjnu5PmnoTlm77lj6/ku6XnnIvlh7rvvIzku47kuIDkuKrpobbngrnnu5PngrnnmoRmaXJzdG91dOWHuuWPke+8jOayv+ihqOe7k+eCueeahHRsaW5r5oyH6ZKI5p6E5oiQ5LqG5q2j6YK75o6l6KGo55qE6ZO+6KGo57uT5p6E77yM6ICM5LuO5LiA5Liq6aG254K557uT54K555qEZmlyc3RpbuWHuuWPke+8jOayv+ihqOe7k+eCueeahGhsaW5r5oyH6ZKI5p6E5oiQ5LqG6YCG6YK75o6l6KGo55qE6ZO+6KGo57uT5p6E44CCXHJcblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGVhZFZleCDlvKfnmoTlpLTpobbngrnnmoTkvY3nva5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRhaWxWZXgg5byn55qE5bC+6aG254K55L2N572uXHJcbiAqIEBwYXJhbSB7QXJjQm94fSBoTGluayDlvKflpLTnm7jlkIznmoTlvKfnmoTpk77ln59cclxuICogQHBhcmFtIHtBcmNCb3h9IHRMaW5rIOW8p+WwvuebuOWQjOeahOW8p+eahOmTvuWfn1xyXG4gKiBAcGFyYW0geyp9IGluZm9cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBBcmNCb3godGFpbFZleCwgaGVhZFZleCwgaExpbmssIHRMaW5rLCBpbmZvKSB7XHJcbiAgICB0aGlzLmhlYWRWZXggPSBoZWFkVmV4IHx8IDA7XHJcbiAgICB0aGlzLnRhaWxWZXggPSB0YWlsVmV4IHx8IDA7XHJcbiAgICB0aGlzLmhMaW5rID0gaExpbmsgfHwgbnVsbDtcclxuICAgIHRoaXMudExpbmsgPSB0TGluayB8fCBudWxsO1xyXG4gICAgdGhpcy5pbmZvID0gaW5mbyB8fCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhXHJcbiAqIEBwYXJhbSB7QXJjQm94fSBmaXJzdEluIOivpemhtueCueesrOS4gOadoeWFpeW8p1xyXG4gKiBAcGFyYW0ge0FyY0JveH0gZmlyc3RPdXQg6K+l6aG254K556ys5LiA5p2h5Ye65bynXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gT0xWZXhOb2RlKGRhdGEsIGZpcnN0SW4sIGZpcnN0T3V0KSB7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGw7XHJcbiAgICB0aGlzLmZpcnN0SW4gPSBmaXJzdEluIHx8IG51bGw7XHJcbiAgICB0aGlzLmZpcnN0T3V0ID0gZmlyc3RPdXQgfHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXkgfCBPTFZleE5vZGV9IHhMaXN0IOihqOWktOWQkemHj1xyXG4gKiBAcGFyYW0ge051bWJlcn0gdmV4bnVtIOacieWQkeWbvueahOW9k+WJjemhtueCueaVsFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYXJjbnVtIOacieWQkeWbvueahOW9k+WJjeW8p+aVsFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE9MR3JhcGgoeExpc3QsIHZleG51bSwgYXJjbnVtKSB7XHJcbiAgICB0aGlzLnhMaXN0ID0geExpc3QgfHwgW107XHJcbiAgICB0aGlzLnZleG51bSA9IHZleG51bSB8fCAwO1xyXG4gICAgdGhpcy5hcmNudW0gPSBhcmNudW0gfHwgMDtcclxufVxyXG5leHBvcnRzLk9MR3JhcGggPSBPTEdyYXBoO1xyXG5PTEdyYXBoLnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBPTEdyYXBoLFxyXG5cclxuICAgIGxvY2F0ZVZleDogZnVuY3Rpb24gKHZwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmRhdGEgPT09IHZwKSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8g5Yig6Zmk6aG254K5XHJcbiAgICBkZWxldGVWZXJ0ZXg6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG0gPSB0aGlzLmxvY2F0ZVZleCh2KTtcclxuXHJcbiAgICAgICAgaWYgKG0gPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRleCBub3QgZm91bmQhJyk7XHJcblxyXG4gICAgICAgIHZhciBuID0gdGhpcy52ZXhudW07XHJcbiAgICAgICAgdmFyIHEsIGksIHA7XHJcbiAgICAgICAgLy8g5Yig6Zmk5omA5pyJ5LulduS4uuWktOeahOi+uVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5b6F5Yig6Zmk55qE6L655piv5aS06ZO+5LiK55qE56ys5LiA5Liq57uT54K5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmZpcnN0SW4udGFpbFZleCA9PT0gbSkge1xyXG4gICAgICAgICAgICAgICAgcSA9IHRoaXMueExpc3RbaV0uZmlyc3RJbjtcclxuICAgICAgICAgICAgICAgIHRoaXMueExpc3RbaV0uZmlyc3RJbiA9IHEuaExpbms7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdEluOyBwICYmIHAuaExpbmsudGFpbFZleCAhPT0gbTsgcCA9IHAuaExpbmspO1xyXG4gICAgICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICBxID0gcC5oTGluaztcclxuICAgICAgICAgICAgICAgICAgICBwLmhMaW5rID0gcS5oTGluaztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDliKDpmaTmiYDmnInku6V25Li65bC+55qE6L65XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzlvoXliKDpmaTnmoTovrnmmK/lsL7pk77kuIrnmoTnrKzkuIDkuKrnu5PngrlcclxuICAgICAgICAgICAgaWYgKHRoaXMueExpc3RbaV0uZmlyc3RPdXQuaGVhZFZleCA9PT0gbSkge1xyXG4gICAgICAgICAgICAgICAgcSA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0ID0gcS50TGluaztcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0OyBwICYmIHAudExpbmsuaGVhZFZleCAhPT0gbTsgcCA9IHAudExpbmspO1xyXG4gICAgICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgICAgICBxID0gcC50TGluaztcclxuICAgICAgICAgICAgICAgICAgICBwLnRMaW5rID0gcS50TGluaztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDpobrmrKHnlKjnu5Pngrlt5LmL5ZCO55qE6aG254K55Y+W5Luj5YmN5LiA5Liq6aG254K5XHJcbiAgICAgICAgZm9yIChpID0gbTsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAvLyDkv67mlLnooajlpLTlkJHph49cclxuICAgICAgICAgICAgdGhpcy54TGlzdFtpXSA9IHRoaXMueExpc3RbaSArIDFdO1xyXG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKVxyXG4gICAgICAgICAgICAgICAgcC5oZWFkVmV4LS07XHJcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQ7IHA7IHAgPSBwLnRMaW5rKVxyXG4gICAgICAgICAgICAgICAgcC50YWlsVmV4LS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZleG51bS0tO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVERzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmV4bnVtID0gcHJvbXB0KCdWZXhudW06ICcpO1xyXG4gICAgICAgIHRoaXMuYXJjbnVtID0gcHJvbXB0KCdBcmNudW06ICcpO1xyXG4gICAgICAgIC8vIEluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXHJcbiAgICAgICAgdmFyIGluY0luZm8gPSArcHJvbXB0KCdJbmNJbmZvOiAnKTtcclxuXHJcbiAgICAgICAgLy8g6L6T5YWl6aG254K55YC8XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMueExpc3RbaV0gPSBuZXcgT0xWZXhOb2RlKHByb21wdCgnZGF0YTogJyksIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmFyY251bTsgKytrKSB7XHJcbiAgICAgICAgICAgIHZhciB2MSA9IHByb21wdCgndjE6ICcpO1xyXG4gICAgICAgICAgICB2YXIgdjIgPSBwcm9tcHQoJ3YyOiAnKTtcclxuXHJcbiAgICAgICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleCh2MSk7XHJcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgodjIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgPT09IC0xIHx8IGogPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBhbGVydCgn5peg5q2k6aG254K577yM6K+36YeN5paw6L6T5YWlIScpO1xyXG4gICAgICAgICAgICAgICAgay0tO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwID0gbmV3IEFyY0JveChpLCBqLCB0aGlzLnhMaXN0W2pdLmZpcnN0SW4sIHRoaXMueExpc3RbaV0uZmlyc3RPdXQsIGluY0luZm8gJiYgcHJvbXB0KCdpbmZvOiAnKSk7XHJcbiAgICAgICAgICAgIHRoaXMueExpc3Rbal0uZmlyc3RJbiA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQgPSBwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmsYLmnInlkJHlm77nmoTlvLrov57pgJrliIbph49cclxuICAgICAqL1xyXG4gICAgZ2V0U0dyYXBoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcclxuICAgICAgICB2YXIgZmluaXNoZWQgPSBbXTtcclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgICAgICAvLyDnrKzkuIDmrKHmt7HluqbkvJjlhYjpgY3ljoblu7rnq4tmaW5pc2hlZOaVsOe7hFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzMSh0aGlzLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5riF56m6dmlzaXRlZOaVsOe7hFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XHJcbiAgICAgICAgLy8g56ys5LqM5qyh6YCG5ZCR55qE5rex5bqm5LyY5YWI6YGN5Y6GXHJcbiAgICAgICAgZm9yICh2YXIgbGVuID0gdGhpcy52ZXhudW0gLSAxOyBsZW4gPj0gMDsgLS1sZW4pIHtcclxuICAgICAgICAgICAgaSA9IGZpbmlzaGVkW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmczIodGhpcywgaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZnMxKGdyYXBoLCB2KSB7XHJcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwID0gZ3JhcGgueExpc3Rbdl0uZmlyc3RPdXQ7IHA7IHAgPSBwLnRMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHAuaGVhZFZleDtcclxuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3XSkgZGZzMShncmFwaCwgdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluaXNoZWRbKytjb3VudF0gPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGZzMihncmFwaCwgdikge1xyXG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJyVkJywgdik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdEluOyBwOyBwID0gcC5oTGluaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBwLnRhaWxWZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbd10pIGRmczIoZ3JhcGgsIHcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy92YXIgZyA9IG5ldyBPTEdyYXBoKCk7XHJcbi8vZy5jcmVhdGVERygpO1xyXG4vL2NvbnNvbGUubG9nKGcpO1xyXG5cclxuXHJcbi8qXHJcbiDmnInlkJHlm77nmoTlvLrov57pgJrliIbph49cclxuXHJcbiDlr7nkuo7mnInlkJHlm77vvIzlnKjlhbbmr4/kuIDkuKrlvLrov57pgJrliIbph4/kuK3vvIzku7vkvZXkuKTkuKrpobbngrnpg73mmK/lj6/ovr7nmoTjgIIgVuKIiEfvvIzkuI5W5Y+v55u45LqS5Yiw6L6+55qE5omA5pyJ6aG254K55bCx5piv5YyF5ZCrVueahOW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxyXG5cclxuIOiuvuS7jlblj6/liLDovr4gKOS7pVbkuLrotbfngrnnmoTmiYDmnInmnInlkJHot6/lvoTnmoTnu4jngrkp55qE6aG254K56ZuG5ZCI5Li6VDEoRynvvIzogIzliLDovr5WICjku6VW5Li657uI54K555qE5omA5pyJ5pyJ5ZCR6Lev5b6E55qE6LW354K5KeeahOmhtueCuembhuWQiOS4ulQyKEcp77yM5YiZ5YyF5ZCrVueahOW8uui/numAmuWIhumHj+eahOmhtueCuembhuWQiOaYr++8miBUMShHKeKIqVQyKEcpIOOAglxyXG5cclxuIOaxguacieWQkeWbvkfnmoTlvLrov57pgJrliIbph4/nmoTln7rmnKzmraXpqqTmmK/vvJpcclxuIOKRtCDlr7lH6L+b6KGM5rex5bqm5LyY5YWI6YGN5Y6G77yM55Sf5oiQR+eahOa3seW6puS8mOWFiOeUn+aIkOajruael1TjgIJcclxuIOKRtSAg5a+55qOu5p6XVOeahOmhtueCueaMieS4reW6j+mBjeWOhumhuuW6j+i/m+ihjOe8luWPt+OAglxyXG4g4pG2ICDmlLnlj5hH5Lit5q+P5LiA5p2h5byn55qE5pa55ZCR77yM5p6E5oiQ5LiA5Liq5paw55qE5pyJ5ZCR5Zu+R+KAmeOAglxyXG4g4pG3ICDmjInikbXkuK3moIflh7rnmoTpobbngrnnvJblj7fvvIzku47nvJblj7fmnIDlpKfnmoTpobbngrnlvIDlp4vlr7lH4oCZ6L+b6KGM5rex5bqm5LyY5YWI5pCc57Si77yM5b6X5Yiw5LiA5qO15rex5bqm5LyY5YWI55Sf5oiQ5qCR44CC6Iul5LiA5qyh5a6M5pW055qE5pCc57Si6L+H56iL5rKh5pyJ6YGN5Y6GR+KAmeeahOaJgOaciemhtueCue+8jOWImeS7juacquiuv+mXrueahOmhtueCueS4remAieaLqeS4gOS4que8luWPt+acgOWkp+eahOmhtueCue+8jOeUseWug+W8gOWni+WGjei/m+ihjOa3seW6puS8mOWFiOaQnOe0ou+8jOW5tuW+l+WIsOWPpuS4gOajtea3seW6puS8mOWFiOeUn+aIkOagkeOAguWcqOivpeatpemqpOS4re+8jOavj+S4gOasoea3seW6puS8mOWFiOaQnOe0ouaJgOW+l+WIsOeahOeUn+aIkOagkeS4reeahOmhtueCueWwseaYr0fnmoTkuIDkuKrlvLrov57pgJrliIbph4/nmoTmiYDmnInpobbngrnjgIJcclxuIOKRuCAg6YeN5aSN5q2l6aqk4pG3IO+8jOebtOWIsEfigJnkuK3nmoTmiYDmnInpobbngrnpg73ooqvorr/pl67jgIJcclxuXHJcbiDlnKjnrpfms5Xlrp7njrDml7bvvIzlu7rnq4vkuIDkuKrmlbDnu4Rpbl9vcmRlcltuXeWtmOaUvua3seW6puS8mOWFiOeUn+aIkOajruael+eahOS4reW6j+mBjeWOhuW6j+WIl+OAguWvueavj+S4qumhtueCuXbvvIzlnKjosIPnlKhERlPlh73mlbDnu5PmnZ/ml7bvvIzlsIbpobbngrnkvp3mrKHlrZjmlL7lnKjmlbDnu4Rpbl9vcmRlcltuXeS4reOAguWbvumHh+eUqOWNgeWtl+mTvuihqOS9nOS4uuWtmOWCqOe7k+aehOacgOWQiOmAguOAglxyXG5cclxuICovXHJcblxyXG4vLyB0b2RvIHRvIGJlIHRlc3RlZFxyXG5PTEdyYXBoLnByb3RvdHlwZS5jb25uZWN0ZWRfREcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmlzaXRlZCA9IFtdO1xyXG4gICAgdmFyIGluX29yZGVyID0gW107XHJcbiAgICB2YXIgY291bnQgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG4gICAgLy8g5a+55Zu+5q2j5ZCR6YGN5Y6GXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xyXG4gICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xyXG4gICAgICAgICAgICBkZnModGhpcywgaSwgaW5fb3JkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xyXG4gICAgLy8g5a+55Zu+6YCG5ZCR6YGN5Y6GXHJcbiAgICB2YXIgayA9IDE7XHJcbiAgICBmb3IgKHZhciBqID0gdGhpcy52ZXhudW0gLSAxOyBqID49IDA7IC0taikge1xyXG4gICAgICAgIHZhciB2ID0gaW5fb3JkZXJbal07XHJcbiAgICAgICAgaWYgKCF2aXNpdGVkW3ZdKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfnrKwnICsgaysrICsgJ+S4qui/numAmuWIhumHj+mhtueCuScpO1xyXG4gICAgICAgICAgICByZXZfZGZzKHRoaXMsIHYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHYpIHtcclxuICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaykge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5oZWFkVmV4XSkge1xyXG4gICAgICAgICAgICAgICAgZGZzKGdyYXBoLCBwLmhlYWRWZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbl9vcmRlcltjb3VudCsrXSA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmV2X2RmcyhncmFwaCwgdikge1xyXG4gICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfpobbngrnvvJonICsgdik7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdEluOyBwOyBwID0gcC5oTGluaykge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC50YWlsVmV4XSkge1xyXG4gICAgICAgICAgICAgICAgcmV2X2RmcyhncmFwaCwgcC50YWlsVmV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9HcmFwaC9PTEdyYXBoLmpzXG4gKiovIiwiLyoqXHJcbiAqIExSVSggTGVhc3QgcmVjZW50bHkgdXNlZCApXHJcbiAqL1xyXG5cclxuaW1wb3J0IERvdWJsZUxpbmtlZExpc3QgZnJvbSAnLi9Eb3VibGVMaW5rZWRMaXN0JztcclxuXHJcbmNvbnN0IExJTUlUID0gMjA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMUlVDYWNoZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcUxpc3QsIGxpbWl0ID0gTElNSVQpe1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICBzcUxpc3QgPSAoc3FMaXN0ICYmIHNxTGlzdC5sZW5ndGgpID8gc3FMaXN0ICYmIHNxTGlzdC5sZW5ndGguc2xpY2UoMCwgdGhpcy5saW1pdCkgOiBbXTtcclxuICAgICAgICB0aGlzLl9fY2FjaGUgPSBuZXcgRG91YmxlTGlua2VkTGlzdChzcUxpc3QsIGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgICAgICByZXR1cm4gYS5rZXkgPT09IGIua2V5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZVtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNpemUoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnNpemU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbW92ZShrZXkpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUucmVtb3ZlKHsga2V5IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19fY2FjaGUuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0KGtleSl7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fX2NhY2hlLmluZGV4T2YoeyBrZXkgfSk7XHJcblxyXG4gICAgICAgIGlmKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9fY2FjaGUuZmluZEJ5SW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLl9fY2FjaGUucmVtb3ZlKGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLl9fY2FjaGUudW5zaGlmdChkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhZGQoa2V5LCB2YWx1ZSl7XHJcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgIGlmKGRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9fY2FjaGUudW5zaGlmdCh7XHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKXtcclxuICAgICAgICBsZXQgYXJyID0gW107XHJcbiAgICAgICAgdGhpcy5fX2NhY2hlLmZvckVhY2goZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKGAkeyBkYXRhLmtleSB9OiR7IGRhdGEudmFsdWUgfWApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYXJyLmpvaW4oJyA+ICcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRvSlNPTigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUudG9KU09OKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKCdMUlVDYWNoZScpO1xyXG5cclxubGV0IGEgPSBuZXcgTFJVQ2FjaGUoW10sIDMpO1xyXG5hLmFkZCgnYWRhbScsIDI5KTtcclxuYS5hZGQoJ2pvaG4nLCAyNik7XHJcbmEuYWRkKCdhbmdlbGEnLCAyNCk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcbmEuZ2V0KCdqb2huJyk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcbmEuYWRkKCd6b3JybycsIDE0MSk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcbmNvbnNvbGUubG9nKGEudG9KU09OKCkpO1xyXG5cclxuZm9yKGxldCBpdGVtIG9mIGEpe1xyXG4gICAgY29uc29sZS5sb2coaXRlbSk7XHJcbn1cclxuXHJcbmEucmVtb3ZlKCd6b3JybycpO1xyXG5hLnJlbW92ZSgnam9obicpO1xyXG5hLnJlbW92ZSgnYW5nZWxhJyk7XHJcbmNvbnNvbGUubG9nKGEgKyAnJyk7XHJcblxyXG5jb25zb2xlLmxvZygnTFJVQ2FjaGVFbmQnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9MaXN0L0xSVS5qc1xuICoqLyIsIi8qKlxyXG4gKiDnur/mgKfooahcclxuICovXHJcblxyXG4vLyDnur/mgKfooajnmoTnsbvlnovlrprkuYlcclxuLy8g5bCG5omA5pyJ5Zyo5pWw57uEYuS4reS9huS4jeWcqOaVsOe7hGHnmoTmlbDmja7lhYPntKDmj5LlhaXliLBh5LitXHJcblxyXG52YXIgYSA9IFsxLCAyLCAzLCA0LCA1XTtcclxudmFyIGIgPSBbMSwgMywgNSwgNywgOV07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdW5pb24oYSwgYikge1xyXG4gICAgdmFyIGVsZW0sIGVxdWFsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBiTGVuID0gYi5sZW5ndGg7IGkgPCBiTGVuOyBpKyspIHtcclxuICAgICAgICBlbGVtID0gYltpXTtcclxuICAgICAgICBlcXVhbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgYUxlbiA9IGEubGVuZ3RoOyBqIDwgYUxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtID09PSBhW2pdKSB7XHJcbiAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFlcXVhbCkgYS5wdXNoKGVsZW0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bmlvbihhLCBiKTtcclxuY29uc29sZS5sb2coYSk7XHJcbi8vIFsxLCAyLCAzLCA0LCA1LCA3LCA5XVxyXG5cclxuLy8g5pe26Ze05aSN5p2C5bqm77yaTyhhTGVuICogYkxlbilcclxuXHJcbi8vIOW3suefpeaVsOe7hGHlkozmlbDnu4Ri5Lit55qE5pWw5o2u5YWD57Sg5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXHJcbi8vIOW9kuW5tmHlkoxi5b6X5Yiw5paw55qE5pWw57uEY++8jGPnmoTmlbDmja7lhYPntKDkuZ/mjInlgLzpnZ7pgJLlh4/mjpLliJdcclxudmFyIGEgPSBbMywgNSwgOCwgMTFdO1xyXG52YXIgYiA9IFsyLCA2LCA4LCA5LCAxMSwgMTUsIDIwXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxpc3QoYSwgYikge1xyXG4gICAgdmFyIGMgPSBbXSwgYUVsZW0sIGJFbGVtO1xyXG4gICAgdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7XHJcbiAgICB2YXIgYUxlbiA9IGEubGVuZ3RoO1xyXG4gICAgdmFyIGJMZW4gPSBiLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IGFMZW4gJiYgaiA8IGJMZW4pIHtcclxuICAgICAgICBhRWxlbSA9IGFbaV07XHJcbiAgICAgICAgYkVsZW0gPSBiW2pdO1xyXG5cclxuICAgICAgICBpZiAoYUVsZW0gPCBiRWxlbSkge1xyXG4gICAgICAgICAgICBjW2srK10gPSBhRWxlbTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNbaysrXSA9IGJFbGVtO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChpIDwgYUxlbikge1xyXG4gICAgICAgIGNbaysrXSA9IGFbaSsrXTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoaiA8IGJMZW4pIHtcclxuICAgICAgICBjW2srK10gPSBiW2orK107XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGM7XHJcbn1cclxuXHJcbnZhciBjID0gbWVyZ2VMaXN0KGEsIGIpO1xyXG5jb25zb2xlLmxvZyhjKTtcclxuLy8gWzIsIDMsIDUsIDYsIDgsIDgsIDksIDExLCAxMSwgMTUsIDIwXVxyXG5cclxuLy8g5pe26Ze05aSN5p2C5bqm77yaIE8oYUxlbiArIGJMZW4pXHJcblxyXG4vLyDnur/mgKfooajnmoTpobrluo/ooajnpLrlkozlrp7njrBcclxuLy8g5L2/55So5Lyq5pWw57uE5qih5ouf57q/5oCn6KGo5o+S5YWl5pON5L2c55qE5YmN5ZCO5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo56m66Ze05Lit55qE5L2N572u5Y+Y5YyWXHJcbnZhciBhID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDV9O1xyXG5hLmxlbmd0aCA9IDY7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KGEsIGksIGVsZW0pIHtcclxuICAgIGlmICghZWxlbSkgcmV0dXJuO1xyXG5cclxuICAgIHZhciBsZW4gPSBhLmxlbmd0aDtcclxuICAgIGlmIChpID49IGxlbikge1xyXG4gICAgICAgIHdoaWxlIChsZW4gPCBpKSB7XHJcbiAgICAgICAgICAgIGFbbGVuKytdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBhLmxlbmd0aCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2ldID0gZWxlbTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKGxlbiA+IGkpIHtcclxuICAgICAgICAgICAgYVtsZW4tLV0gPSBhW2xlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFbaV0gPSBlbGVtO1xyXG4gICAgfVxyXG4gICAgYS5sZW5ndGgrKztcclxufVxyXG5cclxuaW5zZXJ0KGEsIDMsIDgpO1xyXG5pbnNlcnQoYSwgMTAsIDEwKTtcclxuY29uc29sZS5sb2coYSk7XHJcblxyXG4vLyDkvb/nlKjkvKrmlbDnu4TmqKHmi5/nur/mgKfooajliKDpmaTmk43kvZznmoTliY3lkI7mlbDmja7lhYPntKDlnKjlrZjlgqjnqbrpl7TkuK3nmoTkvY3nva7lj5jljJZcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWwoYSwgaSkge1xyXG4gICAgdmFyIHRlbXAgPSBhW2ldO1xyXG4gICAgdmFyIGogPSBpICsgMTtcclxuICAgIHZhciBsZW4gPSBhLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaiA8IGxlbikge1xyXG4gICAgICAgIGFbaiAtIDFdID0gYVtqKytdO1xyXG4gICAgfVxyXG4gICAgYS5sZW5ndGgtLTtcclxuICAgIGRlbGV0ZSBhW2xlbiAtIDFdO1xyXG5cclxuICAgIHJldHVybiB0ZW1wO1xyXG59XHJcblxyXG5kZWwoYSwgMyk7XHJcbmNvbnNvbGUubG9nKGEpO1xyXG5kZWwoYSwgMTApO1xyXG5jb25zb2xlLmxvZyhhKTtcclxuXHJcbi8vIOaXtumXtOWkjeadguW6pu+8miBPKGEubGVuZ3RoKVxyXG5cclxuLy8g5q+U6L6D5a2X56ym6KGoQeWSjELvvIzlubbnlKjov5Tlm57lgLzooajnpLrnu5PmnpzvvIzlgLzkuLox77yM6KGo56S6QT5C77yM5YC85Li6LTHvvIzooajnpLpBPELvvIzlgLzkuLow77yM6KGo56S6QT1CXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q29tcChhTGlzdCwgYkxpc3QpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYUxpc3QubGVuZ3RoICYmIGkgPCBiTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhTGlzdFtpXSAhPT0gYkxpc3RbaV0pIHJldHVybiBhTGlzdFtpXSA+IGJMaXN0W2ldID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhTGlzdC5sZW5ndGggPT0gYkxpc3QubGVuZ3RoKSByZXR1cm4gMDtcclxuXHJcbiAgICByZXR1cm4gYUxpc3QubGVuZ3RoID4gYkxpc3QubGVuZ3RoID8gMSA6IC0xO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZShsaXN0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxpc3QubGVuZ3RoIC0gMTsgaSA8PSBqOyBpKyssIGotLSkge1xyXG4gICAgICAgIHZhciB0ZW1wID0gbGlzdFtpXTtcclxuICAgICAgICBsaXN0W2ldID0gbGlzdFtqXTtcclxuICAgICAgICBsaXN0W2pdID0gdGVtcDtcclxuICAgIH1cclxufVxyXG5cclxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3QoYUxpc3QsIGJMaXN0KSB7XHJcbiAgICB2YXIgY0xpc3QgPSBbXTtcclxuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xyXG5cclxuICAgIHdoaWxlIChhTGlzdFtpXSAmJiBiTGlzdFtqXSkge1xyXG4gICAgICAgIGlmIChhTGlzdFtpXSA8IGJMaXN0W2pdKSBpKys7XHJcbiAgICAgICAgZWxzZSBpZiAoYUxpc3RbaV0gPiBiTGlzdFtqXSkgaisrO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjTGlzdFtrKytdID0gYUxpc3RbaV07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY0xpc3Q7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdChbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcclxuXHJcbi8vIOaxguWFg+e0oOmAkuWinuaOkuWIl+eahOe6v+aAp+ihqEHlkoxC55qE5YWD57Sg55qE5Lqk6ZuG5bm25a2Y5YWl5ZueYVxyXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0X3RydWUoYSwgYikge1xyXG4gICAgdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGFbaV0gJiYgYltqXSkge1xyXG4gICAgICAgIGlmIChhW2ldIDwgYltqXSkgaSsrO1xyXG4gICAgICAgIGVsc2UgaWYgKGFbaV0gPiBiW2pdKSBqKys7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFbaysrXSA9IGFbaV07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoYVtrXSkgYS5zcGxpY2UoaywgMSk7XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKGludGVyc2VjdF90cnVlKFsxLCAzLCA1LCA3LCA5XSwgWzEsIDUsIDksIDEzLCAxN10pICsgJycpO1xyXG5cclxuLy8gYe+8jGLvvIxj55qE5YWD57Sg5Z2H5piv6Z2e6YCS5YeP5o6S5YiXXHJcbi8vIOaxgmHmlbDnu4TkuK3pnZ5i5pWw57uE5ZKMY+aVsOe7hOeahOS6pOmbhueahOWFg+e0oOOAglxyXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0X2RlbGV0ZShhLCBiLCBjKSB7XHJcbiAgICB2YXIgaSA9IDAsIGogPSAwLCBrID0gMCwgbSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBqIDwgYi5sZW5ndGggJiYgayA8IGMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGJbal0gPCBjW2tdKSBqKys7XHJcbiAgICAgICAgZWxzZSBpZiAoYltqXSA+IGNba10pIGsrKztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5LqG55u45ZCM5YWD57Sgc2FtZVxyXG4gICAgICAgICAgICB2YXIgc2FtZSA9IGJbal07XHJcblxyXG4gICAgICAgICAgICAvLyBq77yMa+WQjuenu+WIsOaWsOeahOWFg+e0oFxyXG4gICAgICAgICAgICB3aGlsZSAoYltqXSA9PT0gc2FtZSkgaisrO1xyXG4gICAgICAgICAgICB3aGlsZSAoY1trXSA9PT0gc2FtZSkgaysrO1xyXG4gICAgICAgICAgICAvLyDpnIDkv53nlZnnmoTlhYPntKDnp7vliqjliLDmlrDkvY3nva5cclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldIDwgc2FtZSkgYVttKytdID0gYVtpKytdO1xyXG4gICAgICAgICAgICAvLyDot7Pov4fnm7jlkIznmoTlhYPntKBcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldID09PSBzYW1lKSBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGHnmoTliankvZnlhYPntKDph43mlrDlrZjlgqhcclxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGgpIGFbbSsrXSA9IGFbaSsrXTtcclxuICAgIGEubGVuZ3RoID0gbTtcclxuXHJcbiAgICByZXR1cm4gYTtcclxufVxyXG5cclxuY29uc29sZS5sb2coaW50ZXJzZWN0X2RlbGV0ZShbMSwgMiwgMywgNCwgNSwgNiwgOV0sIFsxLCAzLCA1LCA3LCA5XSwgWzEsIDUsIDksIDEzLCAxN10pICsgJycpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9MaXN0L0xpbmVhckxpc3QuanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS8xLzE5LlxyXG4gKi9cclxuXHJcbi8vIOW+queOr+mYn+WIl1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDeWNsZVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heHNpemUgPSAxMDApe1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xyXG4gICAgICAgIHRoaXMuTUFYUVNJWkUgPSBtYXhzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGVuUXVldWUoZGF0YSkge1xyXG4gICAgICAgIGlmICgodGhpcy5yZWFyICsgMSkgJSB0aGlzLk1BWFFTSVpFID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2N5Y2xlUXVldWUgaXMgYWxyZWFkeSBmdWxsIScpO1xyXG5cclxuICAgICAgICB0aGlzLmJhc2VbdGhpcy5yZWFyXSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5yZWFyID0gKHRoaXMucmVhciArIDEpICUgdGhpcy5NQVhRU0laRTtcclxuICAgIH1cclxuICAgIGRlUXVldWUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQgPT09IHRoaXMucmVhcikgdGhyb3cgbmV3IEVycm9yKCdjeWNsZVF1ZXVlIGlzIGFscmVhZHkgZW1wdHknKTtcclxuXHJcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VbdGhpcy5mcm9udF07XHJcbiAgICAgICAgdGhpcy5mcm9udCA9ICh0aGlzLmZyb250ICsgMSkgJSB0aGlzLk1BWFFTSVpFO1xyXG5cclxuICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlYXIgLSB0aGlzLmZyb250ICsgdGhpcy5NQVhRU0laRSkgJSB0aGlzLk1BWFFTSVpFO1xyXG4gICAgfVxyXG4gICAgcGVla0F0KGluZGV4ID0gMCkge1xyXG4gICAgICAgIGluZGV4ID0gKGluZGV4ICsgdGhpcy5NQVhRU0laRSkgJSB0aGlzLk1BWFFTSVpFO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlW2luZGV4ICsgdGhpcy5mcm9udF0gfHwgbnVsbDtcclxuICAgIH1cclxuICAgIGdldEhlYWQoKSB7XHJcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VbdGhpcy5mcm9udF07XHJcbiAgICAgICAgcmV0dXJuIGVsZW0gPyBlbGVtIDogbnVsbDtcclxuICAgIH1cclxuICAgIHF1ZXVlVHJhdmVyc2UoaXRlcmF0b3IpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5mcm9udCwgbGVuID0gdGhpcy5yZWFyID0gdGhpcy5mcm9udDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcih0aGlzLmJhc2VbaV0sIGkpKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICB2YXIgYmFzZSA9IFtdLnNsaWNlLmNhbGwodGhpcy5iYXNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJhc2Uuc2xpY2UodGhpcy5mcm9udCwgdGhpcy5yZWFyIC0gdGhpcy5mcm9udCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBxdWV1ZSA9IG5ldyBDeWNsZVF1ZXVlKCk7XHJcbnF1ZXVlLmVuUXVldWUoMSk7XHJcbnF1ZXVlLmRlUXVldWUoKTtcclxucXVldWUuZW5RdWV1ZSgyKTtcclxucXVldWUuZW5RdWV1ZSgzKTtcclxuY29uc29sZS5sb2cocXVldWUucGVla0F0KDApKTtcclxuY29uc29sZS5sb2cocXVldWUucGVla0F0KDEpKTtcclxuY29uc29sZS5sb2cocXVldWUucGVla0F0KDIpKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9RdWV1ZS9DeWNsZVF1ZXVlLmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMjYuXHJcbiAqL1xyXG5cclxuLypcclxu5LyY5YWI6Zif5YiXKHByaW9yaXR5IHF1ZXVlKVxyXG5cclxu5pmu6YCa55qE6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye655qE5pWw5o2u57uT5p6E77yM5YWD57Sg5Zyo6Zif5YiX5bC+6L+95Yqg77yM6ICM5LuO6Zif5YiX5aS05Yig6Zmk44CC5Zyo5LyY5YWI6Zif5YiX5Lit77yM5YWD57Sg6KKr6LWL5LqI5LyY5YWI57qn44CC5b2T6K6/6Zeu5YWD57Sg5pe277yM5YW35pyJ5pyA6auY5LyY5YWI57qn55qE5YWD57Sg5pyA5YWI5Yig6Zmk44CC5LyY5YWI6Zif5YiX5YW35pyJ5pyA6auY57qn5YWI5Ye6IO+8iGxhcmdlc3QtaW7vvIxmaXJzdC1vdXTvvInnmoTooYzkuLrnibnlvoHjgIJcclxuXHJcbuS8mOWFiOmYn+WIl+aYrzDkuKrmiJblpJrkuKrlhYPntKDnmoTpm4blkIgs5q+P5Liq5YWD57Sg6YO95pyJ5LiA5Liq5LyY5YWI5p2D5oiW5YC8LOWvueS8mOWFiOmYn+WIl+aJp+ihjOeahOaTjeS9nOaciTEpIOafpeaJvjsyKSDmj5LlhaXkuIDkuKrmlrDlhYPntKA7Mykg5Yig6ZmkLuWcqOacgOWwj+S8mOWFiOmYn+WIlyhtaW4gcHJpb3JpdHlxIHUgZSB1IGUp5LitLOafpeaJvuaTjeS9nOeUqOadpeaQnOe0ouS8mOWFiOadg+acgOWwj+eahOWFg+e0oCzliKDpmaTmk43kvZznlKjmnaXliKDpmaTor6XlhYPntKA75a+55LqO5pyA5aSn5LyY5YWI6Zif5YiXKG1heCBwcmlvcml0eSBxdWV1ZSks5p+l5om+5pON5L2c55So5p2l5pCc57Si5LyY5YWI5p2D5pyA5aSn55qE5YWD57SgLOWIoOmZpOaTjeS9nOeUqOadpeWIoOmZpOivpeWFg+e0oC7kvJjlhYjmnYPpmJ/liJfkuK3nmoTlhYPntKDlj6/ku6XmnInnm7jlkIznmoTkvJjlhYjmnYMs5p+l5om+5LiO5Yig6Zmk5pON5L2c5Y+v5qC55o2u5Lu75oSP5LyY5YWI5p2D6L+b6KGMLlxyXG5cclxuXHJcbuWFpemYn+aTjeS9nFxyXG7ikaDvvJrlrozlhajkuozlj4nmoJHnmoTmnoTlu7rmk43kvZzmmK/igJzku47kuIrliLDkuIvvvIzku47lt6bliLDlj7PigJ3nmoTlvaLlvI/vvIzmiYDku6XlhaXpmJ/nmoToioLngrnmmK/mlL7lnKjmlbDnu4TnmoTmnIDlkI7vvIzkuZ/lsLHmmK/moJHkuK3lj7blrZDlsYLnmoTmnInluo/mnIDlj7PovrnnqbrkvY3jgIJcclxu4pGh77ya5b2T6IqC54K55o+S5YWl5Yiw5pyA5ZCO5pe277yM5pyJ5Y+v6IO956C05Z2P5LqG5aCG55qE5oCn6LSo77yM5q2k5pe25oiR5Lus6KaB6L+b6KGM4oCc5LiK5ruk5pON5L2c4oCd77yM5b2T54S25pe26Ze05aSN5p2C5bqm5Li6TyhsZ04p44CCXHJcblxyXG7lh7rpmJ/mk43kvZxcclxu5Ye66Zif5pON5L2c5pe277yM5oiR5Lus6YeH5Y+W55qE5pa55qGI5piv77ya5by55Ye65aCG6aG25YWD57Sg77yM54S25ZCO5bCG5Y+25a2Q5bGC5Lit55qE5pyA5Y+z5a2Q6IqC54K56LWL57uZ5aCG6aG277yM5ZCM5qC36L+Z5pe25Lmf5Lya5Y+v6IO95a2Y5Zyo56C05Z2P5aCG55qE5oCn6LSo77yM5pyA5ZCO5oiR5Lus6KaB6KKr6L+r6L+b6KGM5LiL5ruk5pON5L2c44CCXHJcbiAqL1xyXG5cclxuLy8g55So5aCG5a6e546w5LyY5YWI6Zif5YiXXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBzaXplKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgZW5RdWV1ZSh2YWx1ZSwgcHJpb3JpdHkgPSAwKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCByZXF1aXJlZCcpO1xyXG5cclxuICAgICAgICAvLyDlsIblvZPliY3oioLngrnov73liqDliLDloIblsL5cclxuICAgICAgICB0aGlzLmhlYXAucHVzaCh7XHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDlpoLmnpzlj6rmnInkuIDkuKroioLngrnvvIzliJnkuI3pnIDopoHov5vooYznrZvpgInmk43kvZxcclxuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyDojrflj5bmnIDlkI7kuIDkuKrpnZ7lj7blrZDoioLngrnvvIzlubbov5vooYzloIbosIPmlbRcclxuICAgICAgICB1cEhlYXBBZGp1c3QodGhpcy5oZWFwLCAodGhpcy5oZWFwLmxlbmd0aCA+PiAxKSAtIDEpO1xyXG4gICAgfVxyXG4gICAgZGVRdWV1ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBsZXQgaGVhcCA9IHRoaXMuaGVhcDtcclxuICAgICAgICAvLyDlh7rpmJ/liJfmk43kvZzvvIzlvLnlh7rmlbDmja7lpLTlhYPntKBcclxuICAgICAgICBsZXQgZGF0YSA9IGhlYXBbMF07XHJcbiAgICAgICAgLy8g55So5bC+5YWD57Sg5aGr5YWF5aS05YWD57SgXHJcbiAgICAgICAgaGVhcFswXSA9IGhlYXBbaGVhcC5sZW5ndGggLSAxXTtcclxuICAgICAgICAvLyDliKDpmaTlsL7oioLngrlcclxuICAgICAgICBoZWFwLnBvcCgpO1xyXG5cclxuICAgICAgICAvL+eEtuWQjuS7juagueiKgueCueS4i+a7pOWghlxyXG4gICAgICAgIGRvd25IZWFwQWRqdXN0KGhlYXAsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpe1xyXG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyDlr7nloIbov5vooYzkuIrmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcclxuZnVuY3Rpb24gdXBIZWFwQWRqdXN0KGhlYXAsIHBhcmVudCkge1xyXG4gICAgbGV0IGxlbiA9IGhlYXAubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChwYXJlbnQgPj0gMCkge1xyXG4gICAgICAgIGxldCBsZWZ0Q2hpbGQgPSAyICogcGFyZW50ICsgMTtcclxuICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XHJcbiAgICAgICAgbGV0IG1heCA9IGxlZnRDaGlsZDtcclxuXHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQgPCBsZW4pIHtcclxuICAgICAgICAgICAgbWF4ID0gaGVhcFtsZWZ0Q2hpbGRdLnByaW9yaXR5IDwgaGVhcFtyaWdodENoaWxkXS5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgPyByaWdodENoaWxkIDogbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5aaC5p6ccGFyZW506IqC54K55bCP5LqO5a6D55qE5p+Q5Liq5a2Q6IqC54K555qE6K+d77yM5q2k5pe2562b6YCJ5pON5L2cXHJcbiAgICAgICAgaWYgKGhlYXBbcGFyZW50XS5wcmlvcml0eSA8IGhlYXBbbWF4XS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICBsZXQgdGVtcCA9IGhlYXBbcGFyZW50XTtcclxuICAgICAgICAgICAgaGVhcFtwYXJlbnRdID0gaGVhcFttYXhdO1xyXG4gICAgICAgICAgICBoZWFwW21heF0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgLy8g57un57ut6L+b6KGM5pu05LiK5LiA5bGC55qE6L+H5rukXHJcbiAgICAgICAgICAgIHBhcmVudCA9IE1hdGguY2VpbChwYXJlbnQgLyAyKSAtIDE7XHJcbiAgICAgICAgfSBlbHNlIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyDlr7nloIbov5vooYzkuIvmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcclxuZnVuY3Rpb24gZG93bkhlYXBBZGp1c3QoaGVhcCwgcGFyZW50KSB7XHJcbiAgICBsZXQgbGVuID0gaGVhcC5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKDIgKiBwYXJlbnQgKyAxIDwgbGVuKSB7XHJcbiAgICAgICAgbGV0IGxlZnRDaGlsZCA9IDIgKiBwYXJlbnQgKyAxO1xyXG4gICAgICAgIGxldCByaWdodENoaWxkID0gbGVmdENoaWxkICsgMTtcclxuICAgICAgICBsZXQgbWF4ID0gbGVmdENoaWxkO1xyXG5cclxuICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xyXG4gICAgICAgICAgICBtYXggPSBoZWFwW2xlZnRDaGlsZF0ucHJpb3JpdHkgPCBoZWFwW3JpZ2h0Q2hpbGRdLnByaW9yaXR5XHJcbiAgICAgICAgICAgICAgICA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGVhcFtwYXJlbnRdLnByaW9yaXR5IDwgaGVhcFttYXhdLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wID0gaGVhcFtwYXJlbnRdO1xyXG4gICAgICAgICAgICBoZWFwW3BhcmVudF0gPSBoZWFwW21heF07XHJcbiAgICAgICAgICAgIGhlYXBbbWF4XSA9IHRlbXA7XHJcblxyXG4gICAgICAgICAgICBwYXJlbnQgPSBtYXg7XHJcbiAgICAgICAgfSBlbHNlIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgdGVzdCA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XHJcbnRlc3QuZW5RdWV1ZSg4LCA1KTtcclxudGVzdC5lblF1ZXVlKDcsIDIpO1xyXG50ZXN0LmVuUXVldWUoNiwgMSk7XHJcbnRlc3QuZW5RdWV1ZSg1LCA0KTtcclxudGVzdC5lblF1ZXVlKDQsIDcpO1xyXG50ZXN0LmVuUXVldWUoMywgMyk7XHJcbnRlc3QuZW5RdWV1ZSgyLCA4KTtcclxudGVzdC5lblF1ZXVlKDEsIDEwKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcclxuY29uc29sZS5sb2codGVzdC5kZVF1ZXVlKCkpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LmRlUXVldWUoKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QuZGVRdWV1ZSgpKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9RdWV1ZS9Qcmlvcml0eVF1ZXVlLmpzXG4gKiovIiwiLyoqXHJcbiAqIEFWTCBUUkVFIENsYXNzXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJpY2UgQ2hldmFsaWVyXHJcbiAqXHJcbiAqXHJcbiAqIEBkZXNjXHJcbiAqXHJcbiAqICAgIE1ldGhvZCAgICAgICAgICAgICAgICBUaW1lIENvbXBsZXhpdHlcclxuICogICAgX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cclxuICpcclxuICogICAgYWRkICAgICAgICAgICAgICAgICAgICBPKGxvZzIobikpXHJcbiAqICAgIHJlbW92ZSAgICAgICAgICAgICAgICBPKGxvZzIobikpXHJcbiAqICAgIGdldEZpcnN0ICAgICAgICAgICAgTygxKVxyXG4gKiAgICBnZXRMYXN0ICAgICAgICAgICAgICAgIE8oMSlcclxuICogICAgZ2V0Q291bnQgICAgICAgICAgICBPKDEpXHJcbiAqICAgIGFwcGx5ICAgICAgICAgICAgICAgIE8obilcclxuICogICAgY2xlYXIgICAgICAgICAgICAgICAgTyhuKVxyXG4gKlxyXG4gKiAgICBNZW1vcnkgQ29tcGxleGl0eSBpbiBPKG4pXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTm9kZShvYmopIHtcclxuICAgIHRoaXMub2JqZWN0ID0gb2JqO1xyXG4gICAgdGhpcy5oZWlnaHQgPSAxO1xyXG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XHJcbiAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBBdmxUcmVlKCkge1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgdGhpcy5maXJzdCA9IG51bGw7XHJcbiAgICB0aGlzLmxhc3QgPSBudWxsO1xyXG59XHJcbkF2bFRyZWUuY21wID0gZnVuY3Rpb24oYSwgYil7XHJcbiAgICBpZihhID4gYikgcmV0dXJuIDE7XHJcbiAgICBlbHNlIGlmKGEgPCBiKSByZXR1cm4gLTE7XHJcbiAgICBlbHNlIHJldHVybiAwO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZExlZnQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICBub2RlLnByZXZpb3VzID0gcGFyZW50LnByZXZpb3VzO1xyXG4gICAgbm9kZS5uZXh0ID0gcGFyZW50O1xyXG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgcGFyZW50LmxlZnQgPSBub2RlO1xyXG4gICAgcGFyZW50LnByZXZpb3VzID0gbm9kZTtcclxuXHJcbiAgICBpZiAobm9kZS5wcmV2aW91cykge1xyXG4gICAgICAgIG5vZGUucHJldmlvdXMubmV4dCA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhcmVudCA9PT0gdGhpcy5maXJzdCkge1xyXG4gICAgICAgIHRoaXMuZmlyc3QgPSBub2RlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgbm9kZS5wcmV2aW91cyA9IHBhcmVudDtcclxuICAgIG5vZGUubmV4dCA9IHBhcmVudC5uZXh0O1xyXG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgcGFyZW50LnJpZ2h0ID0gbm9kZTtcclxuICAgIHBhcmVudC5uZXh0ID0gbm9kZTtcclxuXHJcbiAgICBpZiAobm9kZS5uZXh0KSB7XHJcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyZW50ID09PSB0aGlzLmxhc3QpIHtcclxuICAgICAgICB0aGlzLmxhc3QgPSBub2RlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdGhpcy5jb3VudCArPSAxO1xyXG4gICAgdmFyIG5ld05vZGUgPSBuZXcgTm9kZShvYmopO1xyXG5cclxuICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJvb3QgPSBuZXdOb2RlO1xyXG4gICAgICAgIHRoaXMuZmlyc3QgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5yb290O1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5yb290O1xyXG5cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcblxyXG4gICAgICAgIHZhciBjbXAgPSBBdmxUcmVlLmNtcChvYmosIGN1cnJlbnQub2JqZWN0KTtcclxuICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIGxlZnRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVmdChuZXdOb2RlLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSaWdodChuZXdOb2RlLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMZWZ0KG5ld05vZGUsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmlnaHQobmV3Tm9kZSwgY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmhlaWdodCA8IGN1cnJlbnQubGVmdC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9iYWxhbmNlKG5ld05vZGUucGFyZW50KTtcclxuXHJcbiAgICByZXR1cm4gbmV3Tm9kZTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlTGVmdFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgdmFyIGEgPSBsZWZ0LmxlZnQ7XHJcbiAgICB2YXIgYiA9IGxlZnQucmlnaHQubGVmdDtcclxuXHJcbiAgICBsZWZ0LnJpZ2h0LmxlZnQgPSBsZWZ0O1xyXG4gICAgbm9kZS5sZWZ0ID0gbGVmdC5yaWdodDtcclxuICAgIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICBsZWZ0LnBhcmVudCA9IG5vZGU7XHJcblxyXG4gICAgdmFyIGxlZnRMZWZ0ID0gbGVmdC5sZWZ0O1xyXG4gICAgbGVmdExlZnQucGFyZW50ID0gbGVmdDtcclxuICAgIGxlZnRMZWZ0LmxlZnQgPSBhO1xyXG4gICAgbGVmdExlZnQucmlnaHQgPSBiO1xyXG4gICAgaWYgKGEgIT09IG51bGwpIHtcclxuICAgICAgICBhLnBhcmVudCA9IGxlZnRMZWZ0O1xyXG4gICAgfVxyXG4gICAgaWYgKGIgIT09IG51bGwpIHtcclxuICAgICAgICBiLnBhcmVudCA9IGxlZnRMZWZ0O1xyXG4gICAgfVxyXG5cclxuICAgIGxlZnQuaGVpZ2h0ID0gbGVmdExlZnQuaGVpZ2h0ICsgMTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlTGVmdExlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICB2YXIgYyA9IGxlZnQucmlnaHQ7XHJcblxyXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xyXG4gICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5yaWdodCA9IGxlZnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxlZnQucmlnaHQgPSBub2RlO1xyXG4gICAgbGVmdC5wYXJlbnQgPSBub2RlLnBhcmVudDtcclxuICAgIG5vZGUucGFyZW50ID0gbGVmdDtcclxuICAgIG5vZGUubGVmdCA9IGM7XHJcbiAgICBpZihjICE9PSBudWxsKSB7XHJcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodExlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgIHZhciBhID0gcmlnaHQucmlnaHQ7XHJcbiAgICB2YXIgYiA9IHJpZ2h0LmxlZnQucmlnaHQ7XHJcblxyXG4gICAgcmlnaHQubGVmdC5yaWdodCA9IHJpZ2h0O1xyXG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0LmxlZnQ7XHJcbiAgICByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICByaWdodC5wYXJlbnQgPSBub2RlO1xyXG5cclxuICAgIHZhciByaWdodFJpZ2h0ID0gcmlnaHQucmlnaHQ7XHJcbiAgICByaWdodFJpZ2h0LnBhcmVudCA9IHJpZ2h0O1xyXG4gICAgcmlnaHRSaWdodC5yaWdodCA9IGE7XHJcbiAgICByaWdodFJpZ2h0LmxlZnQgPSBiO1xyXG4gICAgaWYgKGEgIT09IG51bGwpIHtcclxuICAgICAgICBhLnBhcmVudCA9IHJpZ2h0UmlnaHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGIucGFyZW50ID0gcmlnaHRSaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBub2RlLnJpZ2h0LmhlaWdodCA9IHJpZ2h0UmlnaHQuaGVpZ2h0ICsgMTtcclxufTtcclxuXHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5fYmFsYW5jZVJpZ2h0UmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgIHZhciBjID0gcmlnaHQubGVmdDtcclxuXHJcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcmlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudC5sZWZ0ID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByaWdodDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByaWdodC5sZWZ0ID0gbm9kZTtcclxuICAgIHJpZ2h0LnBhcmVudCA9IG5vZGUucGFyZW50O1xyXG4gICAgbm9kZS5wYXJlbnQgPSByaWdodDtcclxuICAgIG5vZGUucmlnaHQgPSBjO1xyXG4gICAgaWYoYyAhPT0gbnVsbCkge1xyXG4gICAgICAgIGMucGFyZW50ID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBub2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0IC0gMTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9iYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIC8vIEJhbGFuY2luZyB0aGUgdHJlZVxyXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xyXG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgbGVmdEhlaWdodCA9IChjdXJyZW50LmxlZnQgPT09IG51bGwpID8gMCA6IGN1cnJlbnQubGVmdC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0SGVpZ2h0ID0gKGN1cnJlbnQucmlnaHQgPT09IG51bGwpID8gMCA6IGN1cnJlbnQucmlnaHQuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSAxICsgTWF0aC5tYXgobGVmdEhlaWdodCwgcmlnaHRIZWlnaHQpO1xyXG5cclxuICAgICAgICBpZiAobmV3SGVpZ2h0ID4gY3VycmVudC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgY3VycmVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0SGVpZ2h0IC0gcmlnaHRIZWlnaHQgPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0LnJpZ2h0ICE9PSBudWxsICYmIChjdXJyZW50LmxlZnQubGVmdCA9PT0gbnVsbCB8fCBjdXJyZW50LmxlZnQubGVmdC5oZWlnaHQgPCBjdXJyZW50LmxlZnQucmlnaHQuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnQgUmlnaHQgQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VMZWZ0UmlnaHQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBMZWZ0IENhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VMZWZ0TGVmdChjdXJyZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdHJlZSBoYXMgYmVlbiBiYWxhbmNlZFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRIZWlnaHQgLSBsZWZ0SGVpZ2h0ID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmxlZnQgIT09IG51bGwgJiYgKGN1cnJlbnQucmlnaHQucmlnaHQgPT09IG51bGwgfHwgY3VycmVudC5yaWdodC5yaWdodC5oZWlnaHQgPCBjdXJyZW50LnJpZ2h0LmxlZnQuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJpZ2h0IExlZnQgQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodExlZnQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgUmlnaHQgQ2FzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZVJpZ2h0UmlnaHQoY3VycmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRyZWUgaGFzIGJlZW4gYmFsYW5jZWRcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpcyBiYWxhbmNlZFxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdGhpcy5fcmVtb3ZlKG9iaiwgdGhpcy5yb290KTtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAob2JqLCBub2RlKSB7XHJcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XHJcblxyXG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgY21wID0gQXZsVHJlZS5jbXAob2JqLCBjdXJyZW50Lm9iamVjdCk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gY3VycmVudC5vYmplY3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgLT0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wcmV2aW91cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMubmV4dCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2luZyB0aGUgbm9kZSBieSB0aGUgc21hbGxlc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gaXRcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY3VycmVudC5yaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2UocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhbGFuY2VGcm9tO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUZyb20gPSByZXBsYWNlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQucmlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5yaWdodCA9IHJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQucGFyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LmxlZnQgPSBsZWZ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3ZlKG9iaiwgY3VycmVudC5sZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShvYmosIGN1cnJlbnQucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUucmVtb3ZlQnlSZWYgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgLy8gTm9kZSByZW1vdmFsXHJcbiAgICB0aGlzLmNvdW50IC09IDE7XHJcblxyXG4gICAgaWYgKG5vZGUucHJldmlvdXMgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLmZpcnN0ID0gbm9kZS5uZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5uZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZS5wcmV2aW91cztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZS5wcmV2aW91cztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXBsYWNpbmcgdGhlIG5vZGUgYnkgdGhlIHNtYWxsZXN0IGVsZW1lbnQgZ3JlYXRlciB0aGFuIGl0XHJcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XHJcbiAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcclxuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XHJcblxyXG4gICAgaWYgKG5vZGUucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9iYWxhbmNlKHBhcmVudCk7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlcGxhY2VtZW50ID0gbm9kZS5yaWdodDtcclxuICAgIHZhciBiYWxhbmNlRnJvbTtcclxuXHJcbiAgICBpZiAocmVwbGFjZW1lbnQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcGxhY2VtZW50LmxlZnQgPSBsZWZ0O1xyXG5cclxuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xyXG5cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XHJcbiAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVwbGFjZW1lbnQucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICByZXBsYWNlbWVudC5yaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xyXG5cclxuICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50O1xyXG4gICAgfVxyXG4gICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcclxuXHJcbiAgICBiYWxhbmNlRnJvbSA9IHJlcGxhY2VtZW50LnBhcmVudDtcclxuXHJcbiAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlbWVudC5sZWZ0ID0gbGVmdDtcclxuXHJcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgdGhpcy5fYmFsYW5jZShiYWxhbmNlRnJvbSk7XHJcblxyXG4gICAgcmV0dXJuIDE7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRGaXJzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmZpcnN0O1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0TGFzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmxhc3Q7XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290O1xyXG59O1xyXG5cclxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb3VudDtcclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAocHJvY2Vzc2luZ0Z1bmMsIHBhcmFtcykge1xyXG4gICAgZm9yICh2YXIgY3VycmVudCA9IHRoaXMuZmlyc3Q7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50Lm5leHQpIHtcclxuICAgICAgICBwcm9jZXNzaW5nRnVuYyhjdXJyZW50Lm9iamVjdCwgcGFyYW1zKTtcclxuICAgIH1cclxufTtcclxuXHJcbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKHByb2Nlc3NpbmdGdW5jLCBwYXJhbXMpIHtcclxuICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmxhc3Q7IGN1cnJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzKSB7XHJcbiAgICAgICAgcHJvY2Vzc2luZ0Z1bmMoY3VycmVudC5vYmplY3QsIHBhcmFtcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BdmxUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXZsVHJlZTtcclxuXHJcblxyXG5jb25zb2xlLmxvZygnXFxuQVZMIHRyZWUgaW5zZXJ0MjogJyk7XHJcbnZhciB0ZXN0ID0gbmV3IEF2bFRyZWUoKTtcclxudGVzdC5hZGQoMyk7XHJcbnRlc3QuYWRkKDE0KTtcclxudGVzdC5hZGQoMjUpO1xyXG50ZXN0LmFkZCg4MSk7XHJcbnRlc3QuYWRkKDQ0KTtcclxuXHJcbi8qXHJcbiAxNFxyXG4gLyAgICBcXFxyXG4gMyAgICAgICA0NFxyXG4gLyAgIFxcXHJcbiAyNSAgICAgODFcclxuICovXHJcblxyXG5cclxuY29uc29sZS5sb2coJ3JlbW92ZV9SZWN1cnNpdmUgMjonKTtcclxuXHJcbnRlc3QucmVtb3ZlKDgxKTtcclxudGVzdC5yZW1vdmUoMyk7XHJcbnRlc3QucmVtb3ZlKDE0KTtcclxudGVzdC5yZW1vdmUoMjUpO1xyXG50ZXN0LnJlbW92ZSg0NCk7XHJcblxyXG5cclxubGV0IHN0ciA9ICdja25vYmZqdGxwcWFlZ3JtZGhzJztcclxuLy92YXIgc3RyID0gJ2NrYmZqbGFlZ21kaCc7XHJcblxyXG5cclxudGVzdCA9IG5ldyBBdmxUcmVlKCk7XHJcbmZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpe1xyXG4gICAgdGVzdC5hZGQoc3RyW2ldKTtcclxufVxyXG5cclxuXHJcbnRlc3QucmVtb3ZlKCdlJyk7XHJcbnRlc3QucmVtb3ZlKCdoJyk7XHJcbnRlc3QucmVtb3ZlKCdiJyk7XHJcbnRlc3QucmVtb3ZlKCdsJyk7XHJcbnRlc3QucmVtb3ZlKCdmJyk7XHJcbnRlc3QucmVtb3ZlKCdqJyk7XHJcbnRlc3QucmVtb3ZlKCdnJyk7XHJcbnRlc3QucmVtb3ZlKCdkJyk7XHJcbnRlc3QucmVtb3ZlKCdrJyk7XHJcbnRlc3QucmVtb3ZlKCdhJyk7XHJcbnRlc3QucmVtb3ZlKCdtJyk7XHJcbnRlc3QucmVtb3ZlKCduJyk7XHJcbnRlc3QucmVtb3ZlKCdvJyk7XHJcbnRlc3QucmVtb3ZlKCdwJyk7XHJcbnRlc3QucmVtb3ZlKCdxJyk7XHJcbnRlc3QucmVtb3ZlKCdyJyk7XHJcbnRlc3QucmVtb3ZlKCdzJyk7XHJcbnRlc3QucmVtb3ZlKCd0Jyk7XHJcbnRlc3QucmVtb3ZlKCdjJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0FWTFRyZWUuanNcbiAqKi8iLCIvKlxyXG4gTUlUIExpY2Vuc2VcclxuIENvcHlyaWdodCAoYykgMjAxMiBTYW50YW51IEJhc3VcclxuIENvcHlyaWdodCAoYykgMjAxMyBEYW5pZWwgV2lydHpcclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxyXG4gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxyXG4gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vLyBCYXNlZCBvbiBTYW50YW51IEJhc3UncyBCUGx1c0pTXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW50YW51YmFzdS9CUGx1c0pTXHJcbi8vIE1vZGlmaWVkIGZvciBzdGFuZC1hbG9uZSB1c2VcclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBCVHJlZS5qc1xyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9CVHJlZS5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGVmaW5lZCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAxMDA7XHJcbiAgICAgICAgdGhpcy5tZXJnZVRocmVzaG9sZCA9IG9wdGlvbnMubWVyZ2VUaHJlc2hvbGQgfHwgNDA7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gW107XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldExlZnRQZWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRQZWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRMZWZ0UGVlciA9IGZ1bmN0aW9uIChsZWZ0UGVlcikge1xyXG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBsZWZ0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRQZWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuc2V0UmlnaHRQZWVyID0gZnVuY3Rpb24gKHJpZ2h0UGVlcikge1xyXG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gcmlnaHRQZWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGUucHJvdG90eXBlLmdldFN1cnBsdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKHRoaXMuZGF0YS5sZW5ndGggLSB0aGlzLm1lcmdlVGhyZXNob2xkKSAvIDIpKTtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRTdXJwbHVzRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VycGx1cyA9IHRoaXMuZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3BsaWNlKHRoaXMuZGF0YS5sZW5ndGggLSBzdXJwbHVzKTtcclxuICAgIH07XHJcblxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0TGVmdFN1cnBsdXNEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdXJwbHVzID0gdGhpcy5nZXRTdXJwbHVzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zcGxpY2UoMCwgc3VycGx1cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBJbnRlcm5hbE5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgdGhpcy5sZWZ0UGVlciA9IG9wdGlvbnMubGVmdFBlZXI7XHJcbiAgICAgICAgdGhpcy5yaWdodFBlZXIgPSBvcHRpb25zLnJpZ2h0UGVlcjtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xyXG5cclxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVttaWRdLmtleSA8IGtleSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdLmtleSA+IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChsZWZ0IDwgcmlnaHQgJiYgIWZvdW5kKTtcclxuICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1pZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmRDaGlsZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY2xvYmJlcikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICB2YXIgbmV3Tm9kZXMsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIG5ld05vZGVzID0gY2hpbGQuaW5zZXJ0KGtleSwgdmFsdWUsIGNsb2JiZXIpO1xyXG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRFbGVtZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1swXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5ld05vZGVzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xyXG4gICAgICAgICAgICBuZXdOb2RlcyA9IGNoaWxkLmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcclxuICAgICAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5ld05vZGVzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ld05vZGVzWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbGVtZW50LnJpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSwgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdOb2RlcztcclxuICAgIH07XHJcblxyXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2UoMCwgc3BsaXRJbmRleCksXHJcbiAgICAgICAgICAgIGxlZnRQZWVyOiB0aGlzLmxlZnRQZWVyLFxyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZShzcGxpdEluZGV4ICsgMSwgdGhpcy5kYXRhLmxlbmd0aCksXHJcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXHJcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xyXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRMZWZ0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIHZhciBtZXJnZUluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGNoaWxkO1xyXG4gICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IGNoaWxkLnJlbW92ZShrZXksIGVsZW1lbnQubGVmdCwgaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSA/IGNoaWxkLmdldFJpZ2h0UGVlcigpIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMSAmJiByZXR2YWwubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcmV0dmFsWzBdLCByZXR2YWxbM11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHZhbFsxXSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xyXG4gICAgICAgICAgICByZXR2YWwgPSBjaGlsZC5yZW1vdmUoa2V5LCBpbmRleCA+IDAgPyBjaGlsZC5nZXRMZWZ0UGVlcigpIDogdW5kZWZpbmVkLCBlbGVtZW50LnJpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMSAmJiByZXR2YWwubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcmV0dmFsWzBdLCByZXR2YWxbM11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHZhbFsxXSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyZ2VJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXJnZUVsZW1lbnQgPSB0aGlzLmRhdGFbbWVyZ2VJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID09IDUpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudC5rZXkgPSByZXR2YWxbM107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbWVyZ2VJbmRleCAtIDFdLnJpZ2h0ID0gcmV0dmFsWzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVttZXJnZUluZGV4ICsgMV0ubGVmdCA9IHJldHZhbFszXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UobWVyZ2VJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXV0uY29uY2F0KHRoaXMubWVyZ2UobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcclxuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGxlZnRTdXJwbHVzID0gMDtcclxuICAgICAgICB2YXIgbGVmdERhdGE7XHJcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XHJcbiAgICAgICAgdmFyIHJpZ2h0RGF0YTtcclxuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xyXG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIHJpZ2h0U3VycGx1cyA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnRTdXJwbHVzRGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXRSaWdodFN1cnBsdXNEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5zbGljZSgxKS5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0U3VycGx1c0RhdGFbbGVmdFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmRhdGFbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcclxuICAgICAgICAgICAgcmV0dmFsWzFdID0gbGVmdE1lcmdlT3B0aW9uO1xyXG4gICAgICAgICAgICByZXR2YWxbMl0gPSBsZWZ0U3VycGx1c0RhdGFbMF0ua2V5O1xyXG4gICAgICAgICAgICByZXR2YWxbM10gPSB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRTdXJwbHVzID4gbGVmdFN1cnBsdXMpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0U3VycGx1c0RhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0U3VycGx1c0RhdGFbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCByaWdodFN1cnBsdXNEYXRhLnNsaWNlKDAsIHJpZ2h0U3VycGx1c0RhdGEubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xyXG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR2YWxbMl0gPSByaWdodFN1cnBsdXNEYXRhW3JpZ2h0U3VycGx1c0RhdGEubGVuZ3RoIC0gMV0ua2V5O1xyXG4gICAgICAgICAgICByZXR2YWxbM10gPSByaWdodE1lcmdlT3B0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtZXJnZWRJbnRlcm5hbE5vZGU7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnREYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcmlnaHREYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHREYXRhWzBdLmxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHJpZ2h0RGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0RlZmluZWQocmlnaHREYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGVmdERhdGEuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdERhdGFbbGVmdERhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHRoaXMuZGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0RGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RGF0YVswXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLCByaWdodERhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRJbnRlcm5hbE5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnREYXRhW2xlZnREYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuZGF0YVswXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLmRhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRJbnRlcm5hbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENoaWxkKGtleSkuZmluZChrZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kQ2hpbGQoc3RhcnQpLnJhbmdlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGluZGVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbaW5kZW50ICsgXCJba2V5PVwiICsgZWxlbWVudC5rZXksIFwiXFxuXCIgKyBpbmRlbnQgKyBcIiAgICBMRUZUXFxuXCIgKyBlbGVtZW50LmxlZnQudG9TdHJpbmcoaW5kZW50ICsgXCIgICAgXCIpLCBcIlxcblwiICsgaW5kZW50ICsgXCIgICAgUklHSFRcXG5cIiArIGVsZW1lbnQucmlnaHQudG9TdHJpbmcoaW5kZW50ICsgXCIgICAgXCIpICsgXCJcXG5cIiArIGluZGVudCArIFwiXVwiXTtcclxuICAgICAgICB9KS5qb2luKFwiLFxcblwiKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIExlYWZOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBvcHRpb25zLmxlZnRQZWVyO1xyXG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gb3B0aW9ucy5yaWdodFBlZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICB2YXIgbWlkID0gbGVmdCArIE1hdGguZmxvb3IoKHJpZ2h0IC0gbGVmdCkgLyAyKTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW21pZF0ua2V5IDwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW21pZF0ua2V5ID4ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGxlZnQgIT09IHJpZ2h0ICYmICFmb3VuZCk7XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNsb2JiZXIpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbWVudC52YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhpcyBjb25kaXRpb24gbWF5IG5ldmVyIG9jY3VyLCBnaXZlbiB0aGUgd2F5IGZpbmRJbmRleCBpcyB3cml0dGVuXHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmtleSA8IGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4ICsgMSwgMCwge1xyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMCwge1xyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZSgwLCBzcGxpdEluZGV4KSxcclxuICAgICAgICAgICAgbGVmdFBlZXI6IHRoaXMubGVmdFBlZXIsXHJcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByaWdodE5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2Uoc3BsaXRJbmRleCwgdGhpcy5kYXRhLmxlbmd0aCksXHJcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXHJcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xyXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRMZWZ0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoICYmIGVsZW1lbnQua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudC52YWx1ZV0uY29uY2F0KHRoaXMubWVyZ2UobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcclxuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGxlZnRTdXJwbHVzID0gMDtcclxuICAgICAgICB2YXIgbGVmdERhdGE7XHJcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XHJcbiAgICAgICAgdmFyIHJpZ2h0RGF0YTtcclxuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xyXG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIHJpZ2h0U3VycGx1cyA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnRTdXJwbHVzRGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXRSaWdodFN1cnBsdXNEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5jb25jYXQodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgIHJldHZhbFsxXSA9IGxlZnRNZXJnZU9wdGlvbjtcclxuICAgICAgICAgICAgcmV0dmFsWzJdID0gdGhpcy5kYXRhWzBdLmtleTtcclxuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcclxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0U3VycGx1cyA+IGxlZnRTdXJwbHVzKSB7XHJcbiAgICAgICAgICAgIHZhciByaWdodFN1cnBsdXNEYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXRMZWZ0U3VycGx1c0RhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChyaWdodFN1cnBsdXNEYXRhKTtcclxuICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcclxuICAgICAgICAgICAgcmV0dmFsWzFdID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICByZXR2YWxbM10gPSByaWdodE1lcmdlT3B0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtZXJnZWRMZWFmTm9kZTtcclxuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdERhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChyaWdodERhdGEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikgJiYgaXNEZWZpbmVkKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNEZWZpbmVkKHJpZ2h0RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQodGhpcy5kYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAtMTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRMZWFmTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0UmlnaHRQZWVyKHJpZ2h0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHREYXRhLmxlbmd0aCA8IGxlZnREYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5jb25jYXQocmlnaHREYXRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcclxuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGVmdERhdGEuY29uY2F0KHRoaXMuZGF0YSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRMZWFmTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGF0YS5sZW5ndGggJiYgZWxlbWVudC5rZXkgPT09IGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIHZhciByYW5nZSA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChpc0RlZmluZWQobm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBub2RlLmZpbmRJbmRleChzdGFydCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG5vZGUuZmluZEluZGV4KGVuZCk7XHJcbiAgICAgICAgICAgIHZhciBub2RlRGF0YSA9IG5vZGUuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IG5vZGVEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaChub2RlRGF0YVtpXS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZEluZGV4ID09IG5vZGVEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UmlnaHRQZWVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIExlYWZOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcclxuICAgICAgICByZXR1cm4gaW5kZW50ICsgXCJbXCIgKyB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5rZXk7XHJcbiAgICAgICAgICAgIH0pLnRvU3RyaW5nKCkgKyBcIl1cIjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFRyZWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMub3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8IDEwMDtcclxuICAgICAgICB0aGlzLm1lcmdlVGhyZXNob2xkID0gb3B0aW9ucy5tZXJnZVRocmVzaG9sZCB8fCA0MDtcclxuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTGVhZk5vZGUoe1xyXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgIGRhdGE6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QudG9TdHJpbmcoXCJcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XHJcbiAgICAgICAgdmFyIG5ld05vZGVzID0gdGhpcy5yb290Lmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcclxuICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IEludGVybmFsTm9kZSh7XHJcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2Rlc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHJldHZhbCA9IHRoaXMucm9vdC5yZW1vdmUoa2V5KTtcclxuICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJldHZhbFsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbFswXTtcclxuICAgIH07XHJcblxyXG4gICAgVHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmZpbmQoa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgVHJlZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmFuZ2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4cG9zZSBhbGwgdHlwZXMgb24gdG9wXHJcbiAgICBUcmVlLk5vZGUgPSBOb2RlO1xyXG4gICAgVHJlZS5JbnRlcm5hbE5vZGUgPSBJbnRlcm5hbE5vZGU7XHJcbiAgICBUcmVlLkxlYWZOb2RlID0gTGVhZk5vZGU7XHJcblxyXG4gICAgLy8gRW5hYmxlIG1vZHVsZSBsb2FkaW5nIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSkgeyAvLyBDb21tb25KU1xyXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBUcmVlO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9ICd1bmRlZmluZWQnICYmIGRlZmluZVtcImFtZFwiXSkgeyAvLyBBTURcclxuICAgICAgICBkZWZpbmUoXCJCUGx1c1RyZWVcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJlZTsgfSk7XHJcbiAgICB9IGVsc2UgeyAvLyBTaGltXHJcbiAgICAgICAgaWYgKCFnbG9iYWxbXCJkY29kZUlPXCJdKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJQbHVzVHJlZVwiXSA9IFRyZWU7XHJcbiAgICB9XHJcblxyXG59KSh0aGlzKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0JQbHVzVHJlZS5qc1xuICoqLyIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBidHJlZS5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vZGNvZGVJTy9idHJlZS5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uIChtb2R1bGUsIGNvbnNvbGUpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyBtdWx0aXBsZSBhcnJheXMgaW50byBhIG5ldyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gey4uLltBcnJheV19IHZhcl9hcmdzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb25jYXQodmFyX2FyZ3MpIHtcclxuICAgICAgICAvLyBBcnJheSNjb25jYXQgYmVoYXZlcyBzdHJhbmdlbHkgZm9yIGVtcHR5IGFycmF5cywgc28uLi5cclxuICAgICAgICB2YXIgYSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGEsIGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoZXMgYW4gYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0geyp9IHZcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9yIC0xIGlmIG5vdCBmb3VuZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNlYXJjaChhLCB2KSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBmYXN0ZXIgdGhhbiBBcnJheSNpbmRleE9mIGJlY2F1c2UgaXQncyByYXcuIEhvd2V2ZXIsIHdlXHJcbiAgICAgICAgLy8gY2Fubm90IHVzZSBiaW5hcnkgc2VhcmNoIGJlY2F1c2Ugbm9kZXMgZG8gbm90IGhhdmUgYSBjb21wYXJhYmxlXHJcbiAgICAgICAgLy8ga2V5LiBJZiB0aGUgY29tcGlsZXIgaXMgc21hcnQsIGl0IHdpbGwgaW5saW5lIHRoaXMuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldID09PSB2KSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC1pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYnRyZWUgbmFtZXNwYWNlLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICovXHJcbiAgICB2YXIgYnRyZWUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmljdGx5IGNvbXBhcmVzIHR3byBzdHJpbmdzLCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyLiBObyBsb2NhbGVzLCBubyBudW1iZXIgZXh0ZW5zaW9uLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgYnRyZWUuc3RyY21wID0gZnVuY3Rpb24gc3RyY21wKGEsIGIpIHtcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB2YXIgYWM7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdmFyIGJjO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChhYyA9IGEuY2hhckNvZGVBdChpKSkgPCAoYmMgPSBiLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWMgPiBiYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgc2FtZSwgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoID8gMCA6IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHR3byBudW1iZXJzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgYnRyZWUubnVtY21wID0gZnVuY3Rpb24gaW50Y21wKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IChhID4gYiA/IDEgOiAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQlRyZWUgY2xhc3MgdXNpbmcgdGhlIGdpdmVuIG9yZGVyLlxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgYSBjbGFzcywgbm90IGFuIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcmRlciBEZWZhdWx0cyB0byAyXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8sID8pOm51bWJlcj19IGNvbXBhcmUgQ29tcGFyZSBpbXBsZW1lbnRhdGlvbiB0byB1c2Ugb24ga2V5c1xyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBidHJlZS5jcmVhdGUgPSBmdW5jdGlvbiAob3JkZXIsIGNvbXBhcmUpIHtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgb3JkZXJcclxuICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIG9yZGVyID0gNTI7IC8vIEJlbmNobWFya3MgcHJvb2ZlZCB0aGF0IHRoaXMgaXMgY2xvc2UgdG8gdGhlIG9wdGltdW1cclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBvcmRlciA9IE1hdGguZmxvb3Iob3JkZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9yZGVyID0gcGFyc2VJbnQob3JkZXIsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yZGVyIDwgMSkgb3JkZXIgPSAxO1xyXG4gICAgICAgIHZhciBtaW5PcmRlciA9IG9yZGVyID4gMSA/IE1hdGguZmxvb3Iob3JkZXIgLyAyKSA6IDE7XHJcblxyXG4gICAgICAgIC8vIFVzZSBudW1jbXAgYnkgZGVmYXVsdFxyXG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZSAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbXBhcmUgPSBidHJlZS5udW1jbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWYWxpZGF0ZXMgYSBub2RlIGFuZCBwcmludHMgZGVidWdnaW5nIGluZm8gaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV8IVRyZWV9IG5vZGVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUpIHsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHN0cmlwcGVkIGJ5IHRoZSBjb21waWxlclxyXG4gICAgICAgICAgICBpZiAoKG5vZGUgaW5zdGFuY2VvZiBUcmVlKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWF2ZXMubGVuZ3RoICsgMSAhPSBub2RlLm5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogSWxsZWdhbCBsZWFmL25vZGUgY291bnQgaW4gXCIgKyBub2RlICsgXCI6IFwiICsgbm9kZS5sZWF2ZXMubGVuZ3RoICsgXCIvXCIgKyBub2RlLm5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlYXZlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbGVhZiBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogXCIgKyBub2RlLmxlYXZlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5ub2Rlc1tpXSA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbm9kZSBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRyZWVOb2RlLlxyXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWVOb2RlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IShUcmVlTm9kZXxUcmVlKX0gcGFyZW50IFBhcmVudCBub2RlXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48IUxlYWY+PX0gbGVhdmVzIExlYWYgbm9kZXNcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxUcmVlTm9kZT49fSBub2RlcyBDaGlsZCBub2Rlc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmVlTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGxlYXZlcywgbm9kZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgbm9kZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFUcmVlTm9kZXwhVHJlZX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExlYWYgbm9kZXMgKG1heC4gb3JkZXIpLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhTGVhZj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmxlYXZlcyA9IGxlYXZlcyB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAobGVhZikge1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGlsZCBub2RlcyAobWF4LiBvcmRlcisxKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48VHJlZU5vZGU+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzIHx8IFtudWxsXTtcclxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkgbm9kZS5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZWFyY2hlcyBmb3IgdGhlIG5vZGUgdGhhdCB3b3VsZCBjb250YWluIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt7bGVhZjogIUxlYWYsIGluZGV4OiBudW1iZXJ9fHtub2RlOiAhVHJlZU5vZGUsIGluZGV4OiBudW1iZXJ9fSBMZWFmIGlmIHRoZSBrZXkgZXhpc3RzLCBlbHNlIHRoZSBpbnNlcnRpb24gbm9kZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMubGVhdmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYS5rZXksIGtleSkgPT0gMCkgcmV0dXJuIHtsZWFmOiBhLCBpbmRleDogMH07XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIGEua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5zZWFyY2goa2V5KTsgLy8gTGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge25vZGU6IHRoaXMsIGluZGV4OiAwfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5sZWF2ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYi5rZXksIGtleSkgPT0gMCkgcmV0dXJuIHtsZWFmOiBiLCBpbmRleDogaX07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBiLmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tpXS5zZWFyY2goa2V5KTsgLy8gSW5uZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge25vZGU6IHRoaXMsIGluZGV4OiBpfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBSaWdodFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogaX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogMH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgdW5kZWZpbmVkIGlzIHJldHVybmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoKGtleSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikgcmV0dXJuIHJlc3VsdC5sZWFmLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYSBrZXkvdmFsdWUgcGFpciBpbnRvIHRoaXMgbm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gb3ZlcndyaXRlIFdoZXRoZXIgdG8gb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlcywgZGVmYXVsdHMgdG8gYHRydWVgXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3VjY2Vzc2Z1bGx5IHNldCwgZmFsc2UgaWYgYWxyZWFkeSBwcmVzZW50IGFuZCBvdmVyd3JpdGUgaXMgYGZhbHNlYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcndyaXRlICE9PSAndW5kZWZpbmVkJyAmJiAhb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmxlYWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IC8vIEtleSBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHJlc3VsdC5ub2RlLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXg7XHJcbiAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMCwgbmV3IExlYWYobm9kZSwga2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICBub2RlLm5vZGVzLnNwbGljZShpbmRleCArIDEsIDAsIG51bGwpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWF2ZXMubGVuZ3RoID4gb3JkZXIpIHsgLy8gUmViYWxhbmNlXHJcbiAgICAgICAgICAgICAgICBub2RlLnNwbGl0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoaXMgbm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5IGhhcyBiZWVuIGRlbGV0ZWQsIGZhbHNlIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2goa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQubGVhZikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgbGVhZiA9IHJlc3VsdC5sZWFmLFxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGxlYWYucGFyZW50LFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbm9kZS5ub2Rlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlYXZlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5ub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5iYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gbGVmdC5sZWF2ZXNbbGVmdC5sZWF2ZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBsZWZ0LmRlbChtYXgua2V5KTtcclxuICAgICAgICAgICAgICAgIG1heC5wYXJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxLCBtYXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhbGFuY2VzIHRoaXMgbm9kZSB0byBmdWxmaWxsIGFsbCBjb25kaXRpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IFJvb3QgaGFzIGp1c3QgYSBzaW5nbGUgY2hpbGQgYW5kIG5vIGxlYXZlc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA9PSAwICYmIHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yb290ID0gdGhpcy5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yb290LnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPj0gbWluT3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBhc2VhcmNoKHRoaXMucGFyZW50Lm5vZGVzLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBpbmRleCA+IDAgPyB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCAtIDFdIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJlbnQubm9kZXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggKyAxXSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBzZXAsIGxlYWYsIHJlc3Q7XHJcbiAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCAmJiByaWdodC5sZWF2ZXMubGVuZ3RoID4gbWluT3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc2VwZXJhdG9yIGZyb20gcGFyZW50IHRvIHRoaXNcclxuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBzZXAucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnB1c2goc2VwKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGJsYW5rIHdpdGggdGhlIGZpcnN0IHJpZ2h0IGxlYWZcclxuICAgICAgICAgICAgICAgIGxlYWYgPSByaWdodC5sZWF2ZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmlnaHQgcmVzdCB0byB0aGlzXHJcbiAgICAgICAgICAgICAgICByZXN0ID0gcmlnaHQubm9kZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gbnVsbCAmJiBsZWZ0LmxlYXZlcy5sZW5ndGggPiBtaW5PcmRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgc2VwZXJhdG9yIGZyb20gcGFyZW50IHRvIHRoaXNcclxuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgc2VwLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy51bnNoaWZ0KHNlcCk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBibGFuayB3aXRoIHRoZSBsYXN0IGxlZnQgbGVhZlxyXG4gICAgICAgICAgICAgICAgbGVhZiA9IGxlZnQubGVhdmVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlc1tpbmRleCAtIDFdID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgdGhlIGxlZnQgcmVzdCB0byB0aGlzXHJcbiAgICAgICAgICAgICAgICByZXN0ID0gbGVmdC5ub2Rlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnVuc2hpZnQocmVzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoaXMgKyBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50ICsgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0ID0gbmV3IFRyZWVOb2RlKHRoaXMucGFyZW50LCBjb25jYXQodGhpcy5sZWF2ZXMsIFtzZXBdLCByaWdodC5sZWF2ZXMpLCBjb25jYXQodGhpcy5ub2RlcywgcmlnaHQubm9kZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVwbGFjZSB0aGUgbm9kZXMgaXQgc2VwZXJhdGVkIHdpdGggc3Vic3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXgsIDIsIHN1YnN0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgbGVmdCArIHNlcGVyYXRvciBmcm9tIHBhcmVudCArIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdCA9IG5ldyBUcmVlTm9kZSh0aGlzLnBhcmVudCwgY29uY2F0KGxlZnQubGVhdmVzLCBbc2VwXSwgdGhpcy5sZWF2ZXMpLCBjb25jYXQobGVmdC5ub2RlcywgdGhpcy5ub2RlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VwZXJhdG9yIGZyb20gdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlcy5zcGxpY2UoaW5kZXggLSAxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVwbGFjZSB0aGUgbm9kZXMgaXQgc2VwZXJhdGVkIHdpdGggc3Vic3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXggLSAxLCAyLCBzdWJzdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBcIiArIHRoaXMudG9TdHJpbmcodHJ1ZSkgKyBcIiBoYXMgbmVpdGhlciBhIGxlZnQgbm9yIGEgcmlnaHQgc2libGluZ1wiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5iYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdmFsaWRhdGUodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlKHRoaXMucGFyZW50KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnNwbGl0cyBhIGNoaWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IUxlYWZ9IGxlYWZcclxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZX0gcmVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS51bnNwbGl0ID0gZnVuY3Rpb24gKGxlYWYsIHJlc3QpIHtcclxuICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXN0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5sZWF2ZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGxlYWYua2V5LCBhLmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy51bnNoaWZ0KGxlYWYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zcGxpY2UoMSwgMCwgcmVzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmxlYXZlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShsZWFmLmtleSwgYi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5zcGxpY2UoaSwgMCwgbGVhZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuc3BsaWNlKGkgKyAxLCAwLCByZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5sZWF2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMucHVzaChsZWFmKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA+IG9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpdHMgdGhpcyBub2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmxlYXZlcy5sZW5ndGggLyAyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoMCwgaW5kZXgpLCB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUcmVlTm9kZSh0aGlzLCB0aGlzLmxlYXZlcy5zbGljZShpbmRleCArIDEpLCB0aGlzLm5vZGVzLnNsaWNlKGluZGV4ICsgMSkpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBbdGhpcy5sZWF2ZXNbaW5kZXhdXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZWFmID0gdGhpcy5sZWF2ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIHRoaXMubGVhdmVzLnNsaWNlKGluZGV4ICsgMSksIHRoaXMubm9kZXMuc2xpY2UoaW5kZXggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcyA9IHRoaXMubGVhdmVzLnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC51bnNwbGl0KGxlYWYsIHJlc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZU5vZGVzIFdoZXRoZXIgdG8gaW5jbHVkZSBzdWItbm9kZXMgb3Igbm90XHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5jbHVkZU5vZGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsLnB1c2godGhpcy5sZWF2ZXNbaV0ua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcyA9IFwiW1wiICsgdmFsLnRvU3RyaW5nKCkgKyBcIl1cIiArICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUgPyBcIjoqXCIgOiBcIjpcIiArIHRoaXMucGFyZW50KTtcclxuICAgICAgICAgICAgaWYgKGluY2x1ZGVOb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IFwiIC0+IFwiICsgdGhpcy5ub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcmludHMgb3V0IHRoZSBub2RlcyBsZWF2ZXMgYW5kIG5vZGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAoaW5kZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZW50OyBpKyspIHNwYWNlICs9IFwiIFwiO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLmxlYXZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaSArIDFdICE9PSBudWxsKSB0aGlzLm5vZGVzW2kgKyAxXS5wcmludChpbmRlbnQgKyAyKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwYWNlICsgdGhpcy5sZWF2ZXNbaV0ua2V5ICsgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSA/IFwiKlwiIDogXCJcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzWzBdICE9PSBudWxsKSB0aGlzLm5vZGVzWzBdLnByaW50KGluZGVudCArIDIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTGVhZiBjb250YWluaW5nIGEgdmFsdWUuXHJcbiAgICAgICAgICogQGNsYXNzIEEgTGVhZi5cclxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZX0gcGFyZW50XHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBMZWFmID0gZnVuY3Rpb24gKHBhcmVudCwga2V5LCB2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcmVudCBub2RlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVRyZWVOb2RlfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2V5LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7ISp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBWYWx1ZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGVhZi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5rZXk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlLlxyXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWUuXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVHJlZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IFRyZWVOb2RlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0cyBhIGtleS92YWx1ZSBwYWlyIGludG8gdGhlIHRyZWUuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHNldCwgZmFsc2UgaWYgYWxyZWFkeSBwcmVzZW50IGFuZCBvdmVyd3JpdGUgaXMgYGZhbHNlYFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUga2V5IGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB0aHJvdyhuZXcgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIiArIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QucHV0KGtleSwgdmFsdWUsIG92ZXJ3cml0ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgdW5kZWZpbmVkIGlzIHJldHVybmVkXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0KGtleSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoZSB0cmVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXkgaGFzIGJlZW4gZGVsZXRlZCwgZmFsc2UgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpICB0aHJvdyhuZXcgRXJyb3IoXCJJbGxlZ2FsIGtleTogXCIgKyBrZXkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5kZWwoa2V5KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCBrZXlzIFttaW5LZXksIC4uLiwgbWF4S2V5XSBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCl9IG1pbktleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nXHJcbiAgICAgICAgICogQHBhcmFtIHsoKnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpKT19IG1heEtleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHdhbGtzIHRpbGwgdGhlIGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcclxuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0FzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5sZWF2ZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1pbktleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1pbktleTtcclxuICAgICAgICAgICAgICAgIG1pbktleSA9IG1heEtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1heEtleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1heEtleTtcclxuICAgICAgICAgICAgICAgIG1heEtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWluS2V5ID0gdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGw7XHJcbiAgICAgICAgICAgIG1heEtleSA9IHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgcHRyLCBpbmRleDtcclxuICAgICAgICAgICAgaWYgKG1pbktleSA9PT0gbnVsbCkgeyAvLyBJZiB0aGVyZSBpcyBubyBtaW5pbXVtIGxpbWl0XHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJvb3Q7IC8vIHNldCBwdHIgdG8gdGhlIG91dGVyIGxlZnQgbm9kZVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1swXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMDsgLy8gYW5kIHN0YXJ0IGF0IGl0cyBmaXJzdCBsZWFmXHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIEVsc2UgbG9va3VwXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtaW5LZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7IC8vIElmIHRoZSBtaW5pbXVtIGtleSBpdHNlbGYgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0LmxlYWYucGFyZW50OyAvLyBzZXQgcHRyIHRvIHRoZSBjb250YWluaW5nIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0Lm5vZGU7IC8vIHNldCBwdHIgdG8gdGhlIGluc2VydGlvbiBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXg7IC8vIGFuZCBzdGFydCBhdCB0aGUgaW5zZXJ0aW9uIGluZGV4IChrZXkgPiBtaW5LZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHB0ci5sZWF2ZXMubGVuZ3RoKSB7IC8vIG9uIG92ZXJydW4sIGJlZ2luIGF0IHRoZSBzZXBhcmF0b3IgaW4gdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHB0ci5wYXJlbnQubGVhdmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB0ci9pbmRleCBub3cgcG9pbnRzIGF0IG91ciBmaXJzdCByZXN1bHRcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhLZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1heEtleSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGtleXMgbGVzcyB0aGFuIG1heEtleVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgcHRyLmxlYXZlc1tpbmRleF0udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgYnJlYWtzIHRoZSBsb29wIGJ5IHJldHVybmluZyB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHRyLm5vZGVzW2luZGV4ICsgMV0gIT09IG51bGwpIHsgLy8gRGVzY2VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1tpbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzWzBdICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHB0ci5sZWF2ZXMubGVuZ3RoID4gaW5kZXggKyAxKSB7IC8vIE5leHRcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXNjZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHB0ci5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4ID49IHB0ci5sZWF2ZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsaWFzIG9mIHtAbGluayBUcmVlI3dhbGtBc2N9LlxyXG4gICAgICAgICAqIEBwYXJhbSB7KnxmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpfSBtaW5LZXkgSWYgb21pdHRlZCBvciBOVUxMLCBzdGFydHMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7KCp8KGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCkpKT19IG1heEtleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHdhbGtzIHRpbGwgdGhlIGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcclxuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2FsayA9IFRyZWUucHJvdG90eXBlLndhbGtBc2M7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdhbGtzIHRocm91Z2ggYWxsIGtleXMgW21pbktleSwgLi4uLCBtYXhLZXldIGluIGRlc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCl9IG1pbktleSBJZiBvbWl0dGVkIG9yIG51bGwsIHdhbGtzIHRpbGwgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBudWxsLCBzdGFydHMgYXQgdGhlIGVuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcclxuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0Rlc2MgPSBmdW5jdGlvbiAobWluS2V5LCBtYXhLZXksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWluS2V5ID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWluS2V5O1xyXG4gICAgICAgICAgICAgICAgbWluS2V5ID0gbWF4S2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4S2V5ID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWF4S2V5O1xyXG4gICAgICAgICAgICAgICAgbWF4S2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaW5LZXkgPSB0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbDtcclxuICAgICAgICAgICAgbWF4S2V5ID0gdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBwdHIsIGluZGV4O1xyXG4gICAgICAgICAgICBpZiAobWF4S2V5ID09PSBudWxsKSB7IC8vIElmIHRoZXJlIGlzIG5vIG1heGltdW0gbGltaXRcclxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucm9vdDsgLy8gc2V0IHB0ciB0byB0aGUgb3V0ZXIgcmlnaHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBwdHIubGVhdmVzLmxlbmd0aCAtIDE7IC8vIGFuZCBzdGFydCBhdCBpdHMgbGFzdCBsZWFmXHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIEVsc2UgbG9va3VwXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtYXhLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7IC8vIElmIHRoZSBtYXhpbXVtIGtleSBpdHNlbGYgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0LmxlYWYucGFyZW50OyAvLyBzZXQgcHRyIHRvIHRoZSBjb250YWluaW5nIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcmVzdWx0Lm5vZGU7IC8vIHNldCBwdHIgdG8gdGhlIGluc2VydGlvbiBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXggLSAxOyAvLyBhbmQgc3RhcnQgYXQgdGhlIGluc2VydGlvbiBpbmRleC0xIChrZXkgPCBtYXhLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgMCkgeyAvLyBvbiB1bmRlcnJ1biwgYmVnaW4gYXQgdGhlIHNlcGFyYXRvciBpbiB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB0ci9pbmRleCBub3cgcG9pbnRzIGF0IG91ciBmaXJzdCByZXN1bHRcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW5LZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1pbktleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGtleXMgYmlnZ2VyIHRoYW4gbWluS2V5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socHRyLmxlYXZlc1tpbmRleF0ua2V5LCBwdHIubGVhdmVzW2luZGV4XS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBicmVha3MgdGhlIGxvb3AgYnkgcmV0dXJuaW5nIHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwdHIubm9kZXNbaW5kZXhdICE9PSBudWxsKSB7IC8vIERlc2NlbmRcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwdHIubm9kZXNbcHRyLm5vZGVzLmxlbmd0aCAtIDFdICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcHRyLmxlYXZlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHsgLy8gTmV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBBc2NlbmRcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5wYXJlbnQubm9kZXMsIHB0cikgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4IDwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBrZXlzIGJldHdlZW4gbWluS2V5IGFuZCBtYXhLZXkgKGJvdGggaW5jbHVzaXZlKS5cclxuICAgICAgICAgKiBAcGFyYW0geyo9fSBtaW5LZXkgSWYgb21pdHRlZCwgY291bnRzIGZyb20gdGhlIHN0YXJ0XHJcbiAgICAgICAgICogQHBhcmFtIHsqPX0gbWF4S2V5IElmIG9taXR0ZWQsIGNvdW50cyB0aWxsIHRoZSBlbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMud2FsayhcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtaW5LZXkgIT0gJ3VuZGVmaW5lZCcgPyBtaW5LZXkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyBuKys7IH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpbnRzIG91dCBhbGwgbm9kZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QucHJpbnQoMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlRyZWUoXCIgKyBvcmRlciArIFwiKSBcIiArIHRoaXMucm9vdC50b1N0cmluZygpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBUcmVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJ0cmVlO1xyXG5cclxufSkobW9kdWxlLCBjb25zb2xlKTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0JUcmVlLmpzXG4gKiovIiwiLypcclxuIOaKmOWNiuafpeaJvihCaW5hcnkgU2VhcmNoKVxyXG5cclxuIOaKmOWNiuafpeaJvuWPiOensOS4uuS6jOWIhuafpeaJvu+8jOaYr+S4gOenjeaViOeOh+i+g+mrmOeahOafpeaJvuaWueazleOAglxyXG4g5YmN5o+Q5p2h5Lu277ya5p+l5om+6KGo5Lit55qE5omA5pyJ6K6w5b2V5piv5oyJ5YWz6ZSu5a2X5pyJ5bqPKOWNh+W6j+aIlumZjeW6jykg44CCXHJcbiDmn6Xmib7ov4fnqIvkuK3vvIzlhYjnoa7lrprlvoXmn6Xmib7orrDlvZXlnKjooajkuK3nmoTojIPlm7TvvIznhLblkI7pgJDmraXnvKnlsI/ojIPlm7Qo5q+P5qyh5bCG5b6F5p+l6K6w5b2V5omA5Zyo5Yy66Ze057yp5bCP5LiA5Y2KKe+8jOebtOWIsOaJvuWIsOaIluaJvuS4jeWIsOiusOW9leS4uuatouOAglxyXG5cclxuIDEgIOafpeaJvuaAneaDs1xyXG4g55SoTG9344CBSGlnaOWSjE1pZOihqOekuuW+heafpeaJvuWMuumXtOeahOS4i+eVjOOAgeS4iueVjOWSjOS4remXtOS9jee9ruaMh+mSiO+8jOWIneWAvOS4ukxvdz0w77yMSGlnaD1uIC0gMeOAglxyXG4g4pG0ICDlj5bkuK3pl7TkvY3nva5NaWTvvJpNaWQ9TWF0aC5mbG9vcigoTG93K0hpZ2gpLzIp77ybXHJcbiDikbUgIOavlOi+g+S4remXtOS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcclxuIOKRoCAg55u4562J77yaIOafpeaJvuaIkOWKn++8m1xyXG4g4pGhICDlpKfkuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTliY3ljYrmrrXvvIzkv67mlLnkuIrnlYzmjIfpkojvvJogSGlnaD1NaWQtMe+8jOi9rOKRtCDvvJtcclxuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q6177yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m1xyXG4g55u05Yiw6LaK55WMKExvdz5IaWdoKe+8jOafpeaJvuWksei0peOAglxyXG5cclxuIDIgIOeul+azleWIhuaekFxyXG4g4pGgICDmn6Xmib7ml7bmr4/nu4/ov4fkuIDmrKHmr5TovoPvvIzmn6Xmib7ojIPlm7TlsLHnvKnlsI/kuIDljYrvvIzor6Xov4fnqIvlj6/nlKjkuIDmo7Xkuozlj4nmoJHooajnpLrvvJpcclxuIOKXhiDmoLnnu5PngrnlsLHmmK/nrKzkuIDmrKHov5vooYzmr5TovoPnmoTkuK3pl7TkvY3nva7nmoTorrDlvZXvvJtcclxuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7liY3pnaLnmoTkvZzkuLrlt6blrZDmoJHnmoTnu5PngrnvvJtcclxuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7lkI7pnaLnmoTkvZzkuLrlj7PlrZDmoJHnmoTnu5PngrnvvJtcclxuIOWvueWQhOWtkOagkeadpeivtOmDveaYr+ebuOWQjOeahOOAgui/meagt+aJgOW+l+WIsOeahOS6jOWPieagkeensOS4uuWIpOWumuagkShEZWNpc2lvbiBUcmVlKeOAglxyXG4g4pGhICDlsIbkuozlj4nliKTlrprmoJHnmoTnrKxNYXRoLmZsb29yKE1hdGgubG9nKDIsIG4pKSsx5bGC5LiK55qE57uT54K56KGl6b2Q5bCx5oiQ5Li65LiA5qO15ruh5LqM5Y+J5qCR77yM5rex5bqm5LiN5Y+Y77yMaD0gTWF0aC5mbG9vcihNYXRoLmxvZygyLCBuICsgMSkpIOOAglxyXG4g4pGiICDnlLHmu6Hkuozlj4nmoJHmgKfotKjnn6XvvIznrKxpIOWxguS4iueahOe7k+eCueaVsOS4uk1hdGgucG93KDIsIGktMSkoaTw9aCkg77yM6K6+6KGo5Lit5q+P5Liq6K6w5b2V55qE5p+l5om+5qaC546H55u4562J77yM5Y2zUGk9MS9u77yM5p+l5om+5oiQ5Yqf5pe255qE5bmz5Z2H5p+l5om+6ZW/5bqmQVNM77yaXHJcbiAobisxKS9uKk1hdGgubG9nKDIsbisxKS0xXHJcbiDlvZNu5b6I5aSnIChuPjUwKeaXtu+8jCBBU0ziiYggTWF0aC5sb2coMixuKzEpLTHjgIJcclxuXHJcblxyXG4g5pe26Ze05aSN5p2C5bqmTyhsb2duKVxyXG4gKi9cclxuXHJcbi8vIOmdnumAkuW9kuW8j1xyXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goc1RhYmxlLCBrZXkpIHtcclxuICAgIGxldCBsb3cgPSAwO1xyXG4gICAgbGV0IGhpZ2ggPSBzVGFibGUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICB3aGlsZShsb3cgPD0gaGlnaCl7XHJcbiAgICAgICAgbGV0ICBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcclxuICAgICAgICBsZXQgZWxlbSA9IHNUYWJsZVttaWRdO1xyXG5cclxuICAgICAgICBpZihlbGVtID09PSBrZXkpIHJldHVybiBtaWQ7XHJcbiAgICAgICAgZWxzZSBpZihlbGVtIDwga2V5KSBsb3cgPSBtaWQgKyAxO1xyXG4gICAgICAgIGVsc2UgaGlnaCA9IG1pZCAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygnYmluYXJ5U2VhcmNoOiAnKTtcclxuY29uc29sZS5sb2coYmluYXJ5U2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgMSkpOyAgLy8gMFxyXG5cclxuLy8g6YCS5b2S5byPXHJcbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShzVGFibGUsIGtleSwgbG93ID0gMCwgaGlnaCA9IHNUYWJsZS5sZW5ndGggLSAxKSB7XHJcbiAgICBpZihsb3cgPiBoaWdoKSByZXR1cm4gLTE7XHJcblxyXG4gICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xyXG4gICAgbGV0IGVsZW0gPSBzVGFibGVbbWlkXTtcclxuXHJcbiAgICBpZihlbGVtID09PSBrZXkpIHJldHVybiBtaWQ7XHJcbiAgICBlbHNlIGlmKGVsZW0gPCBrZXkpIHJldHVybiBiaW5hcnlTZWFyY2hSZWN1cnNpdmUoc1RhYmxlLCBrZXksIG1pZCArIDEsIGhpZ2gpO1xyXG4gICAgZWxzZSByZXR1cm4gYmluYXJ5U2VhcmNoUmVjdXJzaXZlKHNUYWJsZSwga2V5LCBsb3csIG1pZCAtIDEpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygnYmluYXJ5U2VhcmNoUmVjdXJzaXZlOiAnKTtcclxuY29uc29sZS5sb2coYmluYXJ5U2VhcmNoUmVjdXJzaXZlKFsxLCAyLCAzLCA0LCA1XSwgMSkpOyAvLyAwXHJcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL0JpbmFyeVNlYXJjaC5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8xLzExLlxyXG4gKi9cclxuXHJcbi8qXHJcblxyXG4g5aaC5p6c5LiA5Liq5YWz6ZSu5a2X5Y+v5Lul6KGo56S65oiQ5a2X56ym55qE5bqP5Y+377yM5Y2z5a2X56ym5Liy77yM6YKj5LmI5Y+v5Lul55So6ZSu5qCR77yIa2V5d29yZCB0cmVl77yJ77yM5Y+I56ew5pWw5a2X5pCc57Si5qCR77yIZGlnaXRhbCBzZWFyY2ggdHJlZe+8ieaIluWtl+espuagke+8jOS5n+WPq+Wtl+WFuOagke+8jOadpeihqOekuui/meagt+eahOWtl+espuS4sueahOmbhuWQiOOAglxyXG5cclxuIOamguW/tVxyXG5cclxuIOWmguaenOS4gOS4quWFs+mUruWtl+WPr+S7peihqOekuuaIkOWtl+espueahOW6j+WPt++8jOWNs+Wtl+espuS4su+8jOmCo+S5iOWPr+S7peeUqOmUruagke+8iGtleXdvcmQgdHJlZe+8ie+8jOWPiOensOaVsOWtl+aQnOe0ouagke+8iGRpZ2l0YWwgc2VhcmNoIHRyZWXvvInmiJblrZfnrKbmoJHvvIzmnaXooajnpLrov5nmoLfnmoTlrZfnrKbkuLLnmoTpm4blkIjjgILplK7moJHlj4jnp7DkuLrmlbDlrZfmn6Xmib7moJHvvIhEaWdpdGFsIFNlYXJjaCBUcmVlKeaIllRyaWXmoJEodHJpZeS4unJldHJpZXZl5Lit6Ze0NOS4quWtl+espinvvIzlhbbnu5PmnoTlj5flkK/lj5Hkuo7kuIDpg6jlpKflnovlrZflhbjnmoTigJzkuabovrnmoIfnm67igJ3jgILlrZflhbjkuK3moIflh7rpppblrZfmr43mmK8gQSxCLEMsLi4uLlrnmoTljZXor43miYDlnKjpobUs5YaN5a+55ZCE6YOo5YiG5qCH5Ye656ys5LqM5a2X5q+N5Li6QSxCLEMsLi4uWueahOWNleivjeaJgOWcqOeahOmhtSwgLi4uLuetieetieOAglxyXG5cclxuIOmUruagkeaYr+S4gOenjeeJueauiueahOafpeaJvuagke+8jOWug+eahOafkOS4quiKgueCueS4jeaYr+WMheWQq+S4gOS4quaIluWkmuS4quWFs+mUruWtl++8jOiAjOaYr+WPquWMheWQq+e7hOaIkOWFs+mUruWtl+eahOS4gOmDqOWIhu+8iOWtl+espuaIluaVsOWtl++8ie+8jOavlOWmgu+8muWmguaenOWFs+mUruWtl+aYr+aVsOWAvO+8jOWImeiKgueCueS4reWPquWMheWQq+S4gOS4quaVsOS9je+8m+WmguaenOWFs+mUruWtl+aYr+WNleivje+8jOWImeiKgueCueS4reWPquWMheWQq+S4gOS4quWtl+avjeWtl+espuOAglxyXG5cclxuIOaguee7k+eCueS4jeS7o+ihqOS7u+S9leWtl+espu+8jOagueS7peS4i+esrOS4gOWxgueahOe7k+eCueWvueW6lOS6juWtl+espuS4sueahOesrOS4gOS4quWtl+espu+8jOesrOS6jOWxgueahOe7k+eCueWvueW6lOS6juWtl+espuS4sueahOesrOS6jOS4quWtl+espuKApuKApuavj+S4quWtl+espuS4suWPr+eUseS4gOS4queJueauiueahOWtl+espuWmguKAnCTigJ3nrYnkvZzkuLrlrZfnrKbkuLLnmoTnu5PmnZ/nrKbvvIznlKjkuIDkuKrlj7blrZDnu5PngrnmnaXooajnpLror6XnibnmrorlrZfnrKbjgILmiorku47moLnliLDlj7blrZDnmoTot6/lvoTkuIrvvIzmiYDmnInnu5PngrnvvIjpmaTmoLnku6XlpJbvvInlr7nlupTnmoTlrZfnrKbov57mjqXotbfmnaXvvIzlsLHlvpfliLDkuIDkuKrlrZfnrKbkuLLjgILlm6DmraTvvIzmr4/kuKrlj7blrZDnu5Pngrnlr7nlupTkuIDkuKrlhbPplK7lrZfjgILlnKjlj7blrZDnu5Pngrnov5jlj6/ku6XljIXlkKvkuIDkuKrmjIfpkojvvIzmjIflkJHor6XlhbPplK7lrZfmiYDlr7nlupTnmoTlhYPntKDjgILmlbTkuKrlrZfnrKbkuLLpm4blkIjkuK3nmoTlrZfnrKbkuLLnmoTmlbDnm67nrYnkuo7lj7blrZDnu5PngrnnmoTmlbDnm67jgILlpoLmnpzkuIDkuKrpm4blkIjkuK3nmoTlhbPplK7lrZfpg73lhbfmnInov5nmoLfnmoTlrZfnrKbkuLLnibnmgKfvvIzpgqPkuYjvvIzor6XlhbPplK7lrZfpm4blkIjlsLHlj6/ph4fnlKjov5nmoLfkuIDmo7XplK7moJHmnaXooajnpLrjgILkuovlrp7kuIrvvIzov5jlj6/ku6XotYvkuojigJzlrZfnrKbkuLLigJ3mm7Tlub/ms5vnmoTlkKvkuYnvvIzlroPlj6/ku6XmmK/ku7vkvZXnsbvlnovnmoTlr7nosaHnu4TmiJDnmoTkuLLjgIJcclxuXHJcblxyXG4g6ZSu5qCR55qE5a2Y5YKoXHJcbiAx77yJ5Y+M6ZO+5qCR6KGo56S6XHJcbiAyKSDlpJrph43pk77ooajooajnpLpcclxuXHJcblxyXG4g6ZSu5qCR55qE5bqU55So5Zy65pmvXHJcblxyXG4gVHJpZeaYr+S4gOenjemdnuW4uOeugOWNlemrmOaViOeahOaVsOaNrue7k+aehO+8jOS9huacieWkp+mHj+eahOW6lOeUqOWunuS+i+OAglxyXG4g77yIMe+8iSDlrZfnrKbkuLLmo4DntKJcclxuIOS6i+WFiOWwhuW3suefpeeahOS4gOS6m+Wtl+espuS4su+8iOWtl+WFuO+8ieeahOacieWFs+S/oeaBr+S/neWtmOWIsHRyaWXmoJHph4zvvIzmn6Xmib7lj6blpJbkuIDkupvmnKrnn6XlrZfnrKbkuLLmmK/lkKblh7rnjrDov4fmiJbogIXlh7rnjrDpopHnjofjgIJcclxuIOS4vuS+i++8mlxyXG4gQCAg57uZ5Ye6TiDkuKrljZXor43nu4TmiJDnmoTnhp/or43ooajvvIzku6Xlj4rkuIDnr4flhajnlKjlsI/lhpnoi7HmlofkuablhpnnmoTmlofnq6DvvIzor7fkvaDmjInmnIDml6nlh7rnjrDnmoTpobrluo/lhpnlh7rmiYDmnInkuI3lnKjnhp/or43ooajkuK3nmoTnlJ/or43jgIJcclxuIEAgIOe7meWHuuS4gOS4quivjeWFuO+8jOWFtuS4reeahOWNleivjeS4uuS4jeiJr+WNleivjeOAguWNleivjeWdh+S4uuWwj+WGmeWtl+avjeOAguWGjee7meWHuuS4gOauteaWh+acrO+8jOaWh+acrOeahOavj+S4gOihjOS5n+eUseWwj+WGmeWtl+avjeaehOaIkOOAguWIpOaWreaWh+acrOS4reaYr+WQpuWQq+acieS7u+S9leS4jeiJr+WNleivjeOAguS+i+Wmgu+8jOiLpXJvYuaYr+S4jeiJr+WNleivje+8jOmCo+S5iOaWh+acrHByb2JsZW3lkKvmnInkuI3oia/ljZXor43jgIJcclxuXHJcbiDvvIgy77yJ5a2X56ym5Liy5pyA6ZW/5YWs5YWx5YmN57yAXHJcbiBUcmll5qCR5Yip55So5aSa5Liq5a2X56ym5Liy55qE5YWs5YWx5YmN57yA5p2l6IqC55yB5a2Y5YKo56m66Ze077yM5Y+N5LmL77yM5b2T5oiR5Lus5oqK5aSn6YeP5a2X56ym5Liy5a2Y5YKo5Yiw5LiA5qO1dHJpZeagkeS4iuaXtu+8jOaIkeS7rOWPr+S7peW/q+mAn+W+l+WIsOafkOS6m+Wtl+espuS4sueahOWFrOWFseWJjee8gOOAglxyXG4g5Li+5L6L77yaXHJcbiBAIOe7meWHuk4g5Liq5bCP5YaZ6Iux5paH5a2X5q+N5Liy77yM5Lul5Y+KUSDkuKror6Lpl67vvIzljbPor6Lpl67mn5DkuKTkuKrkuLLnmoTmnIDplb/lhazlhbHliY3nvIDnmoTplb/luqbmmK/lpJrlsJHvvJ9cclxuIOino+WGs+aWueahiO+8mummluWFiOWvueaJgOacieeahOS4suW7uueri+WFtuWvueW6lOeahOWtl+avjeagkeOAguatpOaXtuWPkeeOsO+8jOWvueS6juS4pOS4quS4sueahOacgOmVv+WFrOWFseWJjee8gOeahOmVv+W6puWNs+Wug+S7rOaJgOWcqOe7k+eCueeahOWFrOWFseelluWFiOS4quaVsO+8jOS6juaYr++8jOmXrumimOWwsei9rOWMluS4uuS6huemu+e6v++8iE9mZmxpbmXvvInnmoTmnIDov5HlhazlhbHnpZblhYjvvIhMZWFzdCBDb21tb24gQW5jZXN0b3LvvIznroDnp7BMQ0HvvInpl67popjjgIJcclxuIOiAjOacgOi/keWFrOWFseelluWFiOmXrumimOWQjOagt+aYr+S4gOS4que7j+WFuOmXrumimO+8jOWPr+S7peeUqOS4i+mdouWHoOenjeaWueazle+8mlxyXG4gMS4g5Yip55So5bm25p+l6ZuG77yIRGlzam9pbnQgU2V077yJ77yM5Y+v5Lul6YeH55So6YeH55So57uP5YW455qEVGFyamFuIOeul+azle+8m1xyXG4gMi4g5rGC5Ye65a2X5q+N5qCR55qE5qyn5ouJ5bqP5YiX77yIRXVsZXIgU2VxdWVuY2Ug77yJ5ZCO77yM5bCx5Y+v5Lul6L2s5Li657uP5YW455qE5pyA5bCP5YC85p+l6K+i77yIUmFuZ2UgTWluaW11bSBRdWVyee+8jOeugOensFJNUe+8iemXrumimOS6hu+8m1xyXG4g77yI5YWz5LqO5bm25p+l6ZuG77yMVGFyamFu566X5rOV77yMUk1R6Zeu6aKY77yM572R5LiK5pyJ5b6I5aSa6LWE5paZ44CC77yJXHJcblxyXG4g77yIM++8ieaOkuW6j1xyXG4gVHJpZeagkeaYr+S4gOajteWkmuWPieagke+8jOWPquimgeWFiOW6j+mBjeWOhuaVtOajteagke+8jOi+k+WHuuebuOW6lOeahOWtl+espuS4suS+v+aYr+aMieWtl+WFuOW6j+aOkuW6j+eahOe7k+aenOOAglxyXG4g5Li+5L6L77yaXHJcbiBAIOe7meS9oE4g5Liq5LqS5LiN55u45ZCM55qE5LuF55Sx5LiA5Liq5Y2V6K+N5p6E5oiQ55qE6Iux5paH5ZCN77yM6K6p5L2g5bCG5a6D5Lus5oyJ5a2X5YW45bqP5LuO5bCP5Yiw5aSn5o6S5bqP6L6T5Ye644CCXHJcblxyXG4g77yINO+8iSDkvZzkuLrlhbbku5bmlbDmja7nu5PmnoTlkoznrpfms5XnmoTovoXliqnnu5PmnoRcclxuIOWmguWQjue8gOagke+8jEFD6Ieq5Yqo5py6562JXHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiDlj4zpk77moJHooajnpLpcclxuXHJcbiDku6XmoJHnmoTlranlrZDlhYTlvJ/pk77ooajmnaXooajnpLrplK7moJHvvIzliJnmr4/kuKrliIbmlK/nu5PngrnljIXmi6zkuInkuKrln5/vvJpcclxuIHN5bWJvbOWfn++8muWtmOWCqOWFs+mUruWtl+eahOS4gOS4quWtl+espu+8m1xyXG4gZmlyc3Tln5/vvJrlrZjlgqjmjIflkJHnrKzkuIDmo7XlrZDmoJHmoLnnmoTmjIfpkojvvJtcclxuIG5leHTln5/vvJrlrZjlgqjmjIflkJHlj7PlhYTlvJ/nmoTmjIfpkojjgIJcclxuXHJcbiDlkIzml7bvvIzlj7blrZDnu5PngrnkuI3lkKtmaXJzdOWfn++8jOWug+eahGluZm9wdHLln5/lrZjlgqjmjIflkJHor6XlhbPplK7lrZforrDlvZXnmoTmjIfpkojjgIJcclxuIOatpOaXtueahOmUruagkeWPiOensOWPjOmTvuagkeOAglxyXG4g5Zyo5Y+M6ZO+5qCR5Lit5o+S5YWl5oiW5Yig6Zmk5LiA5Liq5YWz6ZSu5a2X77yM55u45b2T5LqO5Zyo5qCR5Lit5p+Q5Liq57uT54K55LiK5o+S5YWl5oiW5Yig6Zmk5LiA5qO15a2Q5qCR44CCXHJcbiDnu5PngrnnmoTnu5PmnoTkuK3lj6/ku6Xorr7nva7kuIDkuKrmnprkuL7lj5jph4/ooajnpLrnu5PngrnnmoTnsbvlnovvvIzlj7blrZDnu5PngrnlkozliIbmlK/nu5PngrnjgIJcclxuIOWPtuWtkOe7k+eCueWSjOWIhuaUr+e7k+eCuemDveaciXN5bWJvbOWfn+WSjG5leHTln5/jgILkuI3lkIznmoTkuIDkuKrln5/lj6/ku6XnlKjogZTlkIjooajnpLrvvIzlj7blrZDnu5PngrnljIXlkKtpbmZvcHRy5oyH5ZCR6K6w5b2V77yM6ICM5YiG5pSv57uT54K55pivZmlyc3Tln5/mjIflkJHlhbbnrKzkuIDmo7XlrZDmoJHjgIJcclxuXHJcblxyXG4g5Y+M6ZO+5qCR55qE5p+l5om+XHJcblxyXG4g5YGH6K6+57uZ5a6a5YC85Li6Sy5jaCgwLi5udW0tMSksIOWFtuS4rUsuY2hbMF3oh7MgSy5jaFtudW0tMl3ooajnpLrlvoXmn6XlhbPplK7lrZfkuK1udW0tMeS4quWtl+espu+8jCBLLmNoW251bS0xXeS4uue7k+adn+espiTjgIJcclxuIOS7juWPjOmTvuagkeeahOagueaMh+mSiOWHuuWPke+8jOmhumZpcnN05oyH6ZKI5om+5Yiw56ys5LiA5qO15a2Q5qCR55qE5qC557uT54K577yM5LulSy5jaFswXeWSjOatpOe7k+eCueeahHN5bWJvbOWfn+avlOi+g++8jOiLpeebuOetie+8jOWImemhumZpcnN05Z+f5YaN5q+U6L6D5LiL5LiA5a2X56ym77yM5ZCm5YiZ5rK/bmV4dOWfn+mhuuW6j+afpeaJvuOAglxyXG4g6Iul55u06Iez56m65LuN5q+U6L6D5LiN562J77yM5YiZ5p+l5om+5LiN5oiQ5Yqf44CCXHJcblxyXG4gLy8g55u45YWz6LWE5paZXHJcbiBodHRwOi8vd3d3LmNuYmxvZ3MuY29tL3JvbGxlbmhvbHQvYXJjaGl2ZS8yMDEyLzA0LzI0LzI0Njg5MzIuaHRtbFxyXG4gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzY4OTcwOTdcclxuIGh0dHA6Ly93d3cucmF5Y2hhc2UubmV0LzE3ODNcclxuICovXHJcblxyXG5jb25zdCBMRUFGID0gJ2xlYWYnO1xyXG5jb25zdCBCUkFOQ0ggPSAnYnJhbmNoJztcclxuY29uc3QgVEVSTUlOQUwgPSBuZXcgU3RyaW5nKCckJyk7XHJcblxyXG5leHBvcnQgY2xhc3MgRG91YmxlTGlua2VkVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wgPSAncm9vdCcsIGtpbmQgPSBCUkFOQ0gsIGluZm8gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XHJcbiAgICAgICAgdGhpcy5maXJzdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc3lub1NlYXJjaCAoa2V5KSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmZpcnN0O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgcCAmJiBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChwICYmIHAua2luZCA9PT0gTEVBRikgYnJlYWs7XHJcbiAgICAgICAgICAgIHdoaWxlIChwICYmIHAuc3ltYm9sIDwga2V5W2ldKSBwID0gcC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSlcclxuICAgICAgICAgICAgICAgIHAgPSBwLmZpcnN0O1xyXG4gICAgICAgICAgICBlbHNlIHAgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHAgJiYgcC5raW5kID09PSBMRUFGID8gcC5pbmZvIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2ggKGtleSkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IHAgJiYgaSA8IGtleS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmIChwICYmIHAuc3ltYm9sID09PSBrZXlbaV0pXHJcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcclxuICAgICAgICAgICAgZWxzZSBwID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwICYmIHAua2luZCA9PT0gTEVBRiA/IHAuaW5mbyA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBrZXkgKz0gJyc7XHJcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBjID0ga2V5W2ldO1xyXG4gICAgICAgICAgICBsZXQgcCA9IGN1cjtcclxuICAgICAgICAgICAgY3VyID0gY3VyLmZpcnN0O1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKGMsIEJSQU5DSCk7XHJcblxyXG4gICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInlrZDnu5PngrnliJnlsIbmlrDnu5PngrnkvZzkuLrlrZDnu5PngrlcclxuICAgICAgICAgICAgaWYgKCFjdXIpIHtcclxuICAgICAgICAgICAgICAgIHAuZmlyc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOWcqOWFhOW8n+e7k+eCueS4reaJvuWIsOWvueW6lOe7k+eCuVxyXG4gICAgICAgICAgICAgICAgaWYoYyA8IGN1ci5zeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uZXh0ID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmZpcnN0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGMgPiBjdXIuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznm7jnrYnvvIzpgIDlh7ror6Xlvqrnjq/mn6Xmib7kuIvkuIDlrZfnrKZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGN1ci5zeW1ib2wpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzlsI/kuo7lvZPliY3lrZfnrKbvvIzliJnmj5LlhaXliLDlvZPliY3nu5PngrnliY3pnaJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjIDwgY3VyLnN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uZXh0ID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5rKh5pyJ5YWE5byf57uT54K55YiZ5o+S5YWl5Yiw5YWE5byf57uT54K5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWN1cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IGIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g55Sf5oiQ5Y+25a2Q57uT54K5XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICBpZiAoY3VyLmtpbmQgPT09IEJSQU5DSCkge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjdXIuZmlyc3Q7XHJcblxyXG4gICAgICAgICAgICAvLyDlpoLmnpzkuI3lrZjlnKjlhbPplK7lrZfliJnor7TmmI7mj5LlhaXmiJDlip/vvIzlkKbliJnmj5LlhaXlpLHotKVcclxuICAgICAgICAgICAgaWYoIShjaGlsZCAmJiBjaGlsZC5zeW1ib2wgPT09IFRFUk1JTkFMKSkge1xyXG4gICAgICAgICAgICAgICAgY3VyLmZpcnN0ID0gbmV3IERvdWJsZUxpbmtlZFRyZWUoVEVSTUlOQUwsIExFQUYsIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGtleSk7XHJcbiAgICAgICAgICAgICAgICBjdXIuZmlyc3QucGFyZW50ID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgY3VyLmZpcnN0Lm5leHQgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3VjY2VzcztcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmUgKGtleSkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChwICYmIGkgPCBrZXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChwICYmIHAuc3ltYm9sIDwga2V5W2ldKSBwID0gcC5uZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSkge1xyXG4gICAgICAgICAgICAgICAgcCA9IHAuZmlyc3Q7XHJcbiAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGF0YSA9IHAuaW5mbztcclxuICAgICAgICB3aGlsZSAoIXAubmV4dCAmJiBwLnBhcmVudCkgcCA9IHAucGFyZW50O1xyXG4gICAgICAgIGxldCB0b3AgPSBwO1xyXG5cclxuICAgICAgICBpZiAodG9wID09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5maXJzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcCA9IHRvcC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgcCA9IHAuZmlyc3Q7XHJcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAgPT0gdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6Zmk5ZyoZmlyc3Tln5/kuIrnmoTlrZDmoJHnu5PngrlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZSkgdG9wLnBhcmVudC5maXJzdCA9IHRvcC5wYXJlbnQuZmlyc3QubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDliKDpmaTlnKhuZXh05Z+f55qE5YWE5byf57uT54K5XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBwcmUubmV4dCA9IHByZS5uZXh0Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmUgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHRlc3QgPSBuZXcgRG91YmxlTGlua2VkVHJlZSgpO1xyXG50ZXN0Lmluc2VydCgnQ0FJJyk7XHJcbnRlc3QuaW5zZXJ0KCdMQU4nKTtcclxudGVzdC5pbnNlcnQoJ0NBTycpO1xyXG50ZXN0Lmluc2VydCgnQ0hBJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEFORycpO1xyXG50ZXN0Lmluc2VydCgnQ0hBTycpO1xyXG50ZXN0Lmluc2VydCgnQ0hFTicpO1xyXG50ZXN0Lmluc2VydCgnTEknKTtcclxudGVzdC5pbnNlcnQoJ0xJVScpO1xyXG50ZXN0Lmluc2VydCgnWkhBTycpO1xyXG50ZXN0Lmluc2VydCgnWkhBTycpO1xyXG5cclxuY29uc29sZS5sb2coJ1xcbnNlYXJjaDogJyk7XHJcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdDQUknKSk7XHJcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdDSEEnKSk7XHJcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdDSEFORycpKTtcclxuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ1pIQU94JykpO1xyXG5cclxuY29uc29sZS5sb2coJ1xcbnJlbW92ZTonKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NBSScpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NBSScpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0xBTicpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NBTycpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQScpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU5HJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hBTycpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIRU4nKSk7XHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSScpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0xJVScpKTtcclxuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ1pIQU8nKSk7XHJcblxyXG5cclxuLypcclxuIOWkmumHjemTvuihqOihqOekulxyXG5cclxuIOiLpeS7peagkeeahOWkmumHjemTvuihqOihqOekuumUruagke+8jOWImeagkeeahOavj+S4que7k+eCueS4reW6lOWQq+aciWTkuKrmjIfpkojln5/vvIzmraTml7bnmoTplK7moJHlj4jnp7BUcmll5qCR44CCXHJcbiDvvIhUcmll5piv5LuO5qOA57SicmV0cmlldmXkuK3lj5bkuK3pl7Tlm5vkuKrlrZfnrKbnmoTvvIzor7vpn7PlkIx0cnnvvInjgIJcclxuIOiLpeS7jumUruagkeS4reafkOS4que7k+eCueWIsOWPtuWtkOe7k+eCueeahOi3r+W+hOS4iuavj+S4que7k+eCuemDveWPquacieS4gOS4quWtqeWtkO+8jOWImeWPr+Wwhuivpei3r+W+hOS4iuaJgOaciee7k+eCueWOi+e8qeaIkOS4gOS4quKAnOWPtuWtkOe7k+eCueKAne+8jOS4lOWcqOivpeWPtuWtkOe7k+eCueS4reWtmOWCqOWFs+mUruWtl+WPiuaMh+WQkeiusOW9leeahOaMh+mSiOetieS/oeaBr+OAglxyXG4g5ZyoVHJpZeagkeS4reacieS4pOenjee7k+eCue+8mlxyXG4g5YiG5pSv57uT54K577ya5ZCr5pyJZOS4quaMh+mSiOWfn+WSjOS4gOS4quaMh+ekuuivpee7k+eCueS4remdnuepuuaMh+mSiOWfn+eahOS4quaVsOeahOaVtOaVsOWfn+OAguWcqOWIhuaUr+e7k+eCueS4reS4jeiuvuaVsOaNruWfn++8jOavj+S4quWIhuaUr+e7k+eCueaJgOihqOekuueahOWtl+espuWdh+acieWFtueItue7k+eCueS4reaMh+WQkeivpee7k+eCueeahOaMh+mSiOaJgOWcqOS9jee9ruWGs+WumuOAglxyXG4g5Y+25a2Q57uT54K577ya5ZCr5pyJ5YWz6ZSu5a2X5Z+f5ZKM5oyH5ZCR6K6w5b2V55qE5oyH6ZKI5Z+f44CCXHJcblxyXG5cclxuIOWcqFRyaWXmoJHkuIrov5vooYzmn6Xmib5cclxuXHJcbiDku47moLnnu5Pngrnlh7rlj5HvvIzmsr/lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojpgJDlsYLlkJHkuIvvvIznm7Toh7Plj7blrZDnu5PngrnvvIzoi6Xlj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLznm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvIzoi6XliIbmlK/nu5PngrnkuK3lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojkuLrnqbrvvIzmiJblj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLzkuI3nm7jnrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcclxuXHJcblxyXG4g5LyY5YyWVHJpZeagkeeahOa3seW6plxyXG5cclxuIOaIkeS7rOWPr+WvueWFs+mUruWtl+mbhumAieaLqeS4gOenjeWQiOmAgueahOWIhuWJsuOAguWFiOaMiemmluWtl+espuS4jemAmuWIhuaIkOWkmuS4quWtkOmbhuS5i+WQju+8jOeEtuWQjuaMieacgOWQjuS4gOS4quWtl+espuS4jeWQjOWIhuWJsuavj+S4quWtkOmbhu+8jOWGjeaMieesrOS6jOS4quWtl+espuOAguOAguOAguWJjeWQjuS6pOWPieWIhuWJsuOAguS4gOe8qeWHj1RyaWXmoJHnmoTmt7HluqZcclxuICovXHJcbi8vIOaxguWtl+espuWcqOWtl+avjeihqOS4reeahOW6j+WPt1xyXG5mdW5jdGlvbiBvcmRlcihjKSB7XHJcbiAgICByZXR1cm4gYyA/IGMudG9Mb3dlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gJ2EnLmNoYXJDb2RlQXQoMCkgKyAxIDogMDtcclxufVxyXG5cclxuLy8g6YCa6L+H5Zue5rqv5rOV5riF55CGVHJpZeagkeeahOWHveaVsFxyXG5mdW5jdGlvbiByZW1vdmVOb2RlKHRyaWVOb2RlLCBvcmRlciwgY2xlYXIpIHtcclxuICAgIHRyaWVOb2RlLmJyYW5jaC5ub2Rlc1tvcmRlcl0gPSBudWxsO1xyXG4gICAgLS10cmllTm9kZS5icmFuY2gubnVtO1xyXG5cclxuICAgIGlmICghY2xlYXIpIHJldHVybjtcclxuXHJcbiAgICBsZXQgbm9kZXMgPSB0cmllTm9kZS5icmFuY2gubm9kZXM7XHJcbiAgICBsZXQgcGFyZW50ID0gdHJpZU5vZGUucGFyZW50O1xyXG4gICAgbGV0IHByZSA9IHRyaWVOb2RlO1xyXG5cclxuICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICBmb3IgKGxldCBpIGluIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBub2Rlc1tpXSkgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGluZGV4O1xyXG4gICAgICAgIGxldCBwYXJlbnROb2RlcyA9IHBhcmVudC5icmFuY2gubm9kZXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSBpbiBwYXJlbnROb2Rlcykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgcGFyZW50Tm9kZXNbaV0gJiYgcGFyZW50Tm9kZXNbaV0gPT0gcHJlKVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnQuYnJhbmNoLm5vZGVzW2luZGV4XSA9IG51bGw7XHJcbiAgICAgICAgLS1wYXJlbnQuYnJhbmNoLm51bTtcclxuXHJcbiAgICAgICAgcHJlID0gcGFyZW50O1xyXG4gICAgICAgIG5vZGVzID0gcGFyZW50LmJyYW5jaC5ub2RlcztcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHJpZVRyZWUge1xyXG4gICAgY29uc3RydWN0b3Ioa2luZCkge1xyXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQgfHwgQlJBTkNIO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGtpbmQgPT09IExFQUYpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWFmID0ge1xyXG4gICAgICAgICAgICAgICAga2V5OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaW5mbzogbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJhbmNoID0ge1xyXG4gICAgICAgICAgICAgICAgLy8g4oCcJOKAneS4uuesrOS4gOS4quWtl+espu+8jOWQjue7reS4ujI25Liq5a2X5q+NXHJcbiAgICAgICAgICAgICAgICBub2RlczogbmV3IEFycmF5KDI3KSxcclxuICAgICAgICAgICAgICAgIG51bTogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2ggKGtleSkge1xyXG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XHJcbiAgICAgICAgZm9yICg7XHJcbiAgICAgICAgICAgICBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpO1xyXG5cclxuICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICBpZiAocC5raW5kID09PSBMRUFGICYmIHAubGVhZi5rZXkgPT09IGtleSkgcmV0dXJuIHAubGVhZi5pbmZvO1xyXG4gICAgICAgICAgICAvLyDlkIzkuYnor41cclxuICAgICAgICAgICAgZWxzZSBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkgcmV0dXJuIHAubGVhZi5pbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnQgKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAvLyDlu7rlj7blrZDnu5PngrlcclxuICAgICAgICBsZXQgcSA9IG5ldyBUcmllVHJlZShMRUFGKTtcclxuICAgICAgICBxLmxlYWYua2V5ID0ga2V5O1xyXG4gICAgICAgIHEubGVhZi5pbmZvID0gdmFsdWU7XHJcblxyXG4gICAgICAgIC8vIOiHquS4iuiAjOS4i+afpeaJvlxyXG4gICAgICAgIGxldCBsYXN0O1xyXG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XHJcbiAgICAgICAgZm9yICg7XHJcbiAgICAgICAgICAgICBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoICYmIHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldO1xyXG4gICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpIGxhc3QgPSBwO1xyXG5cclxuICAgICAgICAvLyDlpoLmnpzmnIDlkI7okL3liLDliIbmlK/nu5PngrnvvIjml6DlkIzkuYnor43vvIlcclxuICAgICAgICAvLyDnm7TmjqXov57kuIrlj7blrZBcclxuICAgICAgICBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcclxuICAgICAgICAgICAgcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0gPSBxO1xyXG4gICAgICAgICAgICBxLnBhcmVudCA9IHA7XHJcbiAgICAgICAgICAgICsrcC5icmFuY2gubnVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlpoLmnpzmnIDlkI7okL3liLDlj7blrZDnu5PngrnvvIjmnInlkIzkuYnor43vvIlcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHAubGVhZi5rZXkgPT09IGtleSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8g5bu656uL5paw55qE5YiG5pSv57uT54K5XHJcbiAgICAgICAgICAgIGxldCByID0gbmV3IFRyaWVUcmVlKEJSQU5DSCk7XHJcbiAgICAgICAgICAgIC8vIOeUqOaWsOeahOWIhuaUr+e7k+eCueWPluS7o+iAgeWPtuWtkOe7k+eCueWSjOS4iuS4gOWxgueahOiBlOezu1xyXG4gICAgICAgICAgICBsYXN0LmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaSAtIDFdKV0gPSByO1xyXG4gICAgICAgICAgICByLnBhcmVudCA9IGxhc3Q7XHJcbiAgICAgICAgICAgIHIuYnJhbmNoLm51bSA9IDI7XHJcbiAgICAgICAgICAgIHIuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldID0gcTtcclxuICAgICAgICAgICAgcS5wYXJlbnQgPSByO1xyXG4gICAgICAgICAgICAvLyDmlrDliIbmlK/nu5PngrnkuI7mlrDogIHkuKTkuKrlj7blrZDnu5Pngrnnm7jov55cclxuICAgICAgICAgICAgci5icmFuY2gubm9kZXNbb3JkZXIocC5sZWFmLmtleVtpXSldID0gcDtcclxuICAgICAgICAgICAgcC5wYXJlbnQgPSByO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbGVhciDmmK/lkKbpnIDopoHmuIXnkIbnu5PngrlcclxuICAgICAqIEByZXR1cm5zIHsqfSDlpoLmnpzliKDpmaTmiJDlip/ov5Tlm55pbmZv5pWw5o2u5ZCm5YiZ6L+U5ZueZmFsc2VcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlIChrZXksIGNsZWFyKSB7XHJcbiAgICAgICAgbGV0IGxhc3Q7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLCBpID0gMDtcclxuICAgICAgICAvLyDmn6Xmib7lvoXliKDpmaTlhYPntKBcclxuICAgICAgICBmb3IgKDtcclxuICAgICAgICAgICAgIHAgJiYgcC5raW5kID09PSBCUkFOQ0ggJiYgaSA8IGtleS5sZW5ndGg7XHJcbiAgICAgICAgICAgICBwID0gcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0sICsraSkgbGFzdCA9IHA7XHJcblxyXG4gICAgICAgIGlmICghcCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBjbGVhciA9IHR5cGVvZiBjbGVhciAhPT0gJ3VuZGVmaW5lZCcgPyBjbGVhciA6IHRydWU7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAocC5raW5kID09PSBMRUFGICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xyXG4gICAgICAgICAgICBkYXRhID0gcC5sZWFmLmluZm87XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUobGFzdCwgb3JkZXIoa2V5W2kgLSAxXSksIGNsZWFyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwLmtpbmQgPT09IEJSQU5DSCkge1xyXG4gICAgICAgICAgICBwID0gcC5icmFuY2gubm9kZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHAubGVhZi5pbmZvO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShwLnBhcmVudCwgMCwgY2xlYXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHRlc3QgPSBuZXcgVHJpZVRyZWUoKTtcclxuXHJcbnRlc3QuaW5zZXJ0KCdDSEEnKTtcclxudGVzdC5pbnNlcnQoJ0NIQScpO1xyXG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcclxudGVzdC5pbnNlcnQoJ0NBSScpO1xyXG50ZXN0Lmluc2VydCgnQ0hFTicpO1xyXG50ZXN0Lmluc2VydCgnQ0FPJyk7XHJcbnRlc3QuaW5zZXJ0KCdDSEFPJyk7XHJcbnRlc3QuaW5zZXJ0KCdMT05HJyk7XHJcbnRlc3QuaW5zZXJ0KCdMSScpO1xyXG50ZXN0Lmluc2VydCgnTEFOJyk7XHJcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcclxudGVzdC5pbnNlcnQoJ1dBTkcnKTtcclxudGVzdC5pbnNlcnQoJ1dFTicpO1xyXG50ZXN0Lmluc2VydCgnV1UnKTtcclxudGVzdC5pbnNlcnQoJ1lBTkcnKTtcclxudGVzdC5pbnNlcnQoJ1lVTicpO1xyXG50ZXN0Lmluc2VydCgnWkhBTycpO1xyXG5cclxuY29uc29sZS5sb2coJ1xcbnNlYXJjaDogJyk7XHJcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdZVU4nKSk7XHJcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPJykpO1xyXG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0hBJykpO1xyXG5cclxudGVzdC5yZW1vdmUoJ0xBTicpO1xyXG50ZXN0LnJlbW92ZSgnTElVJyk7XHJcbnRlc3QucmVtb3ZlKCdXQU5HJyk7XHJcbnRlc3QucmVtb3ZlKCdXRU4nKTtcclxudGVzdC5yZW1vdmUoJ1dVJyk7XHJcbnRlc3QucmVtb3ZlKCdZQU5HJyk7XHJcbnRlc3QucmVtb3ZlKCdZVU4nKTtcclxudGVzdC5yZW1vdmUoJ1pIQU8nKTtcclxudGVzdC5yZW1vdmUoJ0NIQScpO1xyXG50ZXN0LnJlbW92ZSgnQ0hBTkcnKTtcclxudGVzdC5yZW1vdmUoJ0NBSScpO1xyXG50ZXN0LnJlbW92ZSgnQ0hFTicpO1xyXG50ZXN0LnJlbW92ZSgnQ0FPJyk7XHJcbnRlc3QucmVtb3ZlKCdDSEFPJyk7XHJcbnRlc3QucmVtb3ZlKCdMT05HJyk7XHJcbnRlc3QucmVtb3ZlKCdMSScpO1xyXG5cclxudGVzdC5pbnNlcnQoJ0xJJyk7XHJcbnRlc3QuaW5zZXJ0KCdMQU4nKTtcclxudGVzdC5pbnNlcnQoJ0xJVScpO1xyXG5cclxuXHJcbi8qXHJcbiDlhbPkuo7lrZflhbjmoJHnmoTkvJjljJbnmoTmlbDmja7nu5PmnoTmnIlQYXRyaWNpYSBUcmVl77yMU3VmZml4IFRyZWVcclxuIHRvZG8g5pyJ56m65YaN5a6e546wXHJcblxyXG4g55u45YWz6LWE5paZ77yaXHJcbiBodHRwOi8vYmxvZy5jc2RuLm5ldC9sanNzcGFjZS9hcnRpY2xlL2RldGFpbHMvNjU3MTQxNFxyXG4gKi9cclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9EaWdpdGFsU2VhcmNoVHJlZS5qc1xuICoqLyIsIi8qKlxyXG4gKiBIYXNoVGFibGVcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTQvMTIvMzAuXHJcbiAqL1xyXG5cclxuLyoqXHJcbuWTiOW4jCjmlaPliJcp5p+l5om+XHJcblxyXG7ln7rmnKzmgJ3mg7PvvJrlnKjorrDlvZXnmoTlrZjlgqjlnLDlnYDlkozlroPnmoTlhbPplK7lrZfkuYvpl7Tlu7rnq4vkuIDkuKrnoa7lrprnmoTlr7nlupTlhbPns7vvvJvov5nmoLfvvIzkuI3nu4/ov4fmr5TovoPvvIzkuIDmrKHlrZjlj5blsLHog73lvpfliLDmiYDmn6XlhYPntKDnmoTmn6Xmib7mlrnms5XjgIJcclxuXHJcbuWfuuacrOamguW/tVxyXG5cclxu5ZOI5biM5Ye95pWw77ya5Zyo6K6w5b2V55qE5YWz6ZSu5a2X5LiO6K6w5b2V55qE5a2Y5YKo5Zyw5Z2A5LmL6Ze05bu656uL55qE5LiA56eN5a+55bqU5YWz57O75Y+r5ZOI5biM5Ye95pWw44CCXHJcbuWTiOW4jOWHveaVsOaYr+S4gOenjeaYoOixoe+8jOaYr+S7juWFs+mUruWtl+epuumXtOWIsOWtmOWCqOWcsOWdgOepuumXtOeahOS4gOenjeaYoOixoeOAguWPr+WGmeaIkO+8mmFkZHIoYWkpPUgoa2kpIO+8jOWFtuS4rWnmmK/ooajkuK3kuIDkuKrlhYPntKDvvIxhZGRyKGFpKeaYr2Fp55qE5Zyw5Z2A77yMIGtp5pivYWnnmoTlhbPplK7lrZfjgIJcclxuXHJcbuWTiOW4jOihqO+8muW6lOeUqOWTiOW4jOWHveaVsO+8jOeUseiusOW9leeahOWFs+mUruWtl+ehruWumuiusOW9leWcqOihqOS4reeahOWcsOWdgO+8jOW5tuWwhuiusOW9leaUvuWFpeatpOWcsOWdgO+8jOi/meagt+aehOaIkOeahOihqOWPq+WTiOW4jOihqOOAglxyXG5cclxu5ZOI5biM5p+l5om+KOWPiOWPq+aVo+WIl+afpeaJvinvvJrliKnnlKjlk4jluIzlh73mlbDov5vooYzmn6Xmib7nmoTov4fnqIvlj6vlk4jluIzmn6Xmib7jgIJcclxuXHJcbuWGsueqge+8muWvueS6juS4jeWQjOeahOWFs+mUruWtl2tp44CBa2rvvIzoi6Vrae+CuWtq77yM5L2GSChraSk9SChrainnmoTnjrDosaHlj6vlhrLnqoEoY29sbGlzaW9uKSDjgIJcclxuXHJcbuWQjOS5ieivje+8muWFt+acieebuOWQjOWHveaVsOWAvOeahOS4pOS4quS4jeWQjOeahOWFs+mUruWtl++8jOensOS4uuivpeWTiOW4jOWHveaVsOeahOWQjOS5ieivjeOAglxyXG7lk4jluIzlh73mlbDpgJrluLjmmK/kuIDnp43ljovnvKnmmKDosaHvvIzmiYDku6XlhrLnqoHkuI3lj6/pgb/lhY3vvIzlj6rog73lsL3ph4/lh4/lsJHvvJvlvZPlhrLnqoHlj5HnlJ/ml7bvvIzlupTor6XmnInlpITnkIblhrLnqoHnmoTmlrnms5XjgILorr7orqHkuIDkuKrmlaPliJfooajlupTljIXmi6zvvJpcclxu4pGgICDmlaPliJfooajnmoTnqbrpl7TojIPlm7TvvIzljbPnoa7lrprmlaPliJflh73mlbDnmoTlgLzln5/vvJtcclxu4pGhICDmnoTpgKDlkIjpgILnmoTmlaPliJflh73mlbDvvIzkvb/lvpflr7nkuo7miYDmnInlj6/og73nmoTlhYPntKAo6K6w5b2V55qE5YWz6ZSu5a2XKe+8jOWHveaVsOWAvOWdh+WcqOaVo+WIl+ihqOeahOWcsOWdgOepuumXtOiMg+WbtOWGhe+8jOS4lOWHuueOsOWGsueqgeeahOWPr+iDveWwvemHj+Wwj++8m1xyXG7ikaIgIOWkhOeQhuWGsueqgeeahOaWueazleOAguWNs+W9k+WGsueqgeWHuueOsOaXtuWmguS9leino+WGs+OAglxyXG5cclxuXHJcbuWTiOW4jOWHveaVsOeahOaehOmAoFxyXG5cclxu5ZOI5biM5Ye95pWw5piv5LiA56eN5pig6LGh77yM5YW26K6+5a6a5b6I54G15rS777yM5Y+q6KaB5L2/5Lu75L2V5YWz6ZSu5a2X55qE5ZOI5biM5Ye95pWw5YC86YO96JC95Zyo6KGo6ZW/5YWB6K6455qE6IyD5Zu05LmL5YaF5Y2z5Y+v44CC5ZOI5biM5Ye95pWw4oCc5aW95Z2P4oCd55qE5Li76KaB6K+E5Lu35Zug57Sg5pyJ77yaXHJcbuKXhiDmlaPliJflh73mlbDnmoTmnoTpgKDnroDljZXvvJtcclxu4peGIOiDveKAnOWdh+WMgOKAneWcsOWwhuaVo+WIl+ihqOS4reeahOWFs+mUruWtl+aYoOWwhOWIsOWcsOWdgOepuumXtOOAguaJgOiwk+KAnOWdh+WMgOKAnSh1bmlmb3JtKeaYr+aMh+WPkeeUn+WGsueqgeeahOWPr+iDveaAp+WwveWPr+iDveacgOWwkeOAglxyXG5cclxuMSAg55u05o6l5a6a5Z2A5rOVXHJcbuWPluWFs+mUruWtl+aIluWFs+mUruWtl+eahOafkOS4que6v+aAp+WHveaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgICAg5oiWICAgSChrZXkpPWHCt2tleStiKGEsYuS4uuW4uOaVsClcclxu54m554K577ya55u05o6l5a6a5Z2A5rOV5omA5b6X5Zyw5Z2A6ZuG5ZCI5LiO5YWz6ZSu5a2X6ZuG5ZCI5aSn5bCP55u4562J77yM5LiN5Lya5Y+R55Sf5Yay56qB77yM5L2G5a6e6ZmF5Lit5b6I5bCR5L2/55So44CCXHJcblxyXG4yICDmlbDlrZfliIbmnpDms5Vcclxu5a+55YWz6ZSu5a2X6L+b6KGM5YiG5p6Q77yM5Y+W5YWz6ZSu5a2X55qE6Iul5bmy5L2N5oiW57uE5ZCI5L2c5Li65ZOI5biM5Zyw5Z2A44CCXHJcbumAgueUqOS6juWFs+mUruWtl+S9jeaVsOavlOWTiOW4jOWcsOWdgOS9jeaVsOWkp++8jOS4lOWPr+iDveWHuueOsOeahOWFs+mUruWtl+S6i+WFiOefpemBk+eahOaDheWGteOAglxyXG7kvovvvJog6K6+5pyJODDkuKrorrDlvZXvvIzlhbPplK7lrZfkuLo45L2N5Y2B6L+b5Yi25pWw77yM5ZOI5biM5Zyw5Z2A5Li6MuS9jeWNgei/m+WItuaVsOOAglxyXG7vgoEgIO+CgiDvgoMgIO+ChCDvgoUgIO+ChiDvgocgIO+CiFxyXG44ICAxICAzICA0ICA2ICA1ICAzICAyXHJcbjggIDEgIDMgIDcgIDIgIDIgIDQgIDJcclxuOCAgMSAgMyAgOCAgNyAgNCAgMiAgMlxyXG44ICAxICAzICAwICAxICAzICA2ICA3XHJcbjggIDEgIDMgIDIgIDIgIDggIDEgIDdcclxuOCAgMSAgMyAgMyAgOCAgOSAgNiAgN1xyXG44ICAxICAzICA2ICA4ICA1ICAzICA3XHJcbjggIDEgIDQgIDEgIDkgIDMgIDUgIDVcclxu5YiG5p6Q77yaIO+CgSDlj6rlj5Y4XHJcbiAgICAgIO+CgiDlj6rlj5YxXHJcbiAgICAgIO+CgyDlj6rlj5Yz44CBNFxyXG4gICAgICDvgogg5Y+q5Y+WMuOAgTfjgIE1XHJcbiAgICAgIO+ChO+Che+Chu+Ch+aVsOWtl+WIhuW4g+i/keS5jumaj+aculxyXG7miYDku6XvvJrlj5bvgoTvgoXvgobvgofku7vmhI/kuKTkvY3miJbkuKTkvY3kuI7lj6bkuKTkvY3nmoTlj6DliqDkvZzlk4jluIzlnLDlnYBcclxuXHJcbjMgIOW5s+aWueWPluS4reazlVxyXG7lsIblhbPplK7lrZflubPmlrnlkI7lj5bkuK3pl7Tlh6DkvY3kvZzkuLrlk4jluIzlnLDlnYDjgIJcclxu5LiA5Liq5pWw5bmz5pa55ZCO5Lit6Ze05Yeg5L2N5ZKM5pWw55qE5q+P5LiA5L2N6YO95pyJ5YWz77yM5YiZ55Sx6ZqP5py65YiG5biD55qE5YWz6ZSu5a2X5b6X5Yiw55qE5pWj5YiX5Zyw5Z2A5Lmf5piv6ZqP5py655qE44CC5pWj5YiX5Ye95pWw5omA5Y+W55qE5L2N5pWw55Sx5pWj5YiX6KGo55qE6ZW/5bqm5Yaz5a6a44CC6L+Z56eN5pa55rOV6YCC5LqO5LiN55+l6YGT5YWo6YOo5YWz6ZSu5a2X5oOF5Ya177yM5piv5LiA56eN6L6D5Li65bi455So55qE5pa55rOV44CCXHJcblxyXG40ICDmipjlj6Dms5Vcclxu5bCG5YWz6ZSu5a2X5YiG5Ymy5oiQ5L2N5pWw55u45ZCM55qE5Yeg6YOo5YiGKOacgOWQjuS4gOmDqOWIhuWPr+S7peS4jeWQjCnvvIznhLblkI7lj5bov5nlh6Dpg6jliIbnmoTlj6DliqDlkozkvZzkuLrlk4jluIzlnLDlnYDjgIJcclxu5pWw5L2N5Y+g5Yqg5pyJ56e75L2N5Y+g5Yqg5ZKM6Ze055WM5Y+g5Yqg5Lik56eN44CCXHJcbuKXhiDnp7vkvY3lj6DliqDvvJrlsIbliIblibLlkI7nmoTlh6Dpg6jliIbkvY7kvY3lr7npvZDnm7jliqDjgIJcclxu4peGIOmXtOeVjOWPoOWKoO+8muS7juS4gOerr+WIsOWPpuS4gOerr+ayv+WIhuWJsueVjOadpeWbnuaKmOi/re+8jOeEtuWQjuWvuem9kOebuOWKoOOAglxyXG7pgILkuo7lhbPplK7lrZfkvY3mlbDlvojlpJrvvIzkuJTmr4/kuIDkvY3kuIrmlbDlrZfliIbluIPlpKfoh7TlnYfljIDmg4XlhrXjgIJcclxu5L6L77yaIOiuvuWFs+mUruWtl+S4ujA0NDIyMDU4NjTvvIzlk4jluIzlnLDlnYDkvY3mlbDkuLo0IOOAguS4pOenjeS4jeWQjOeahOWcsOWdgOiuoeeul+aWueazleWmguS4i++8mlxyXG4gICAgNTg2NCAgICAgICAgICAgICAgICAgICAgICAgIDU4NjRcclxuICAgIDQyMjAgICAgICAgICAgICAgICAgICAgICAgICAwMjI0XHJcbiAgICAgIDA0ICAgICAgIOenu+S9jeWPoOWKoCAgICAgICAgICAgIDA0ICAgICAgICAgICDpl7TnlYzlj6DliqBcclxuIC0tLS0tLS0tLSAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS1cclxuICAgMTAwODggICAgICAgICAgICAgICAgICAgICAgICA2MDkxXHJcblxyXG41ICDpmaTnlZnkvZnmlbDms5Vcclxu5Y+W5YWz6ZSu5a2X6KKr5p+Q5Liq5LiN5aSn5LqO5ZOI5biM6KGo6KGo6ZW/beeahOaVsHDpmaTlkI7miYDlvpfkvZnmlbDkvZzlk4jluIzlnLDlnYDvvIzljbNIKGtleSk9a2V5IE1PRCBwICAgICAocDw9bSlcclxu5piv5LiA56eN566A5Y2V44CB5bi455So55qE5ZOI5biM5Ye95pWw5p6E6YCg5pa55rOV44CCXHJcbuWIqeeUqOi/meenjeaWueazleeahOWFs+mUruaYr3DnmoTpgInlj5bvvIxw6YCJ55qE5LiN5aW977yM5a655piT5Lqn55Sf5ZCM5LmJ6K+N44CCcOeahOmAieWPlueahOWIhuaekO+8mlxyXG7il4YgIOmAieWPlnA9MmkocDw9bSnvvJrov5Dnrpfkvr/kuo7nlKjnp7vkvY3mnaXlrp7njrDvvIzkvYbnrYnkuo7lsIblhbPplK7lrZfnmoTpq5jkvY3lv73nlaXogIzku4XnlZnkuIvkvY7kvY3kuozov5vliLbmlbDjgILpq5jkvY3kuI3lkIzogIzkvY7kvY3nm7jlkIznmoTlhbPplK7lrZfmmK/lkIzkuYnor43jgIJcclxu4peGIOmAieWPlnA9cSpmKHHjgIFm6YO95piv6LSo5Zug5pWw77yMcDw9bSnvvJrliJnmiYDmnInlkKvmnIlx5oiWZuWboOWtkOeahOWFs+mUruWtl+eahOaVo+WIl+WcsOWdgOWdh+aYr3HmiJZm55qE5YCN5pWw44CCXHJcbuKXhiDpgInlj5Zw5Li657Sg5pWw5oiWcD1xKmYoceOAgWbmmK/otKjmlbDkuJTlnYflpKfkuo4yMO+8jHA8PW0p77ya5bi455So55qE6YCJ5Y+W5pa55rOV77yM6IO95YeP5bCR5Yay56qB5Ye6546w55qE5Y+v6IO95oCn44CCXHJcblxyXG42ICDpmo/mnLrmlbDms5Vcclxu5Y+W5YWz6ZSu5a2X55qE6ZqP5py65Ye95pWw5YC85L2c5ZOI5biM5Zyw5Z2A77yM5Y2zSChrZXkpPXJhbmRvbShrZXkpXHJcbuW9k+aVo+WIl+ihqOS4reWFs+mUruWtl+mVv+W6puS4jeetieaXtu+8jOivpeaWueazleavlOi+g+WQiOmAguOAglxyXG5cclxuXHJcblxyXG7pgInlj5blk4jluIzlh73mlbDvvIzogIPomZHku6XkuIvlm6DntKBcclxu4peGIOiuoeeul+WTiOW4jOWHveaVsOaJgOmcgOaXtumXtO+8m1xyXG7il4Yg5YWz6ZSu5a2X55qE6ZW/5bqm77ybXHJcbuKXhiDlk4jluIzooajplb/luqbvvIjlk4jluIzlnLDlnYDojIPlm7TvvInvvJtcclxu4peGIOWFs+mUruWtl+WIhuW4g+aDheWGte+8m1xyXG7il4Yg6K6w5b2V55qE5p+l5om+6aKR546H44CCXHJcblxyXG5cclxuXHJcbuWGsueqgeWkhOeQhueahOaWueazlVxyXG7lhrLnqoHlpITnkIbvvJrlvZPlh7rnjrDlhrLnqoHml7bvvIzkuLrlhrLnqoHlhYPntKDmib7liLDlj6bkuIDkuKrlrZjlgqjkvY3nva7jgIJcclxuXHJcbjEgIOW8gOaUvuWumuWdgOazlVxyXG7ln7rmnKzmlrnms5XvvJrlvZPlhrLnqoHlj5HnlJ/ml7bvvIzlvaLmiJDmn5DkuKrmjqLmtYvluo/liJfvvJvmjInmraTluo/liJfpgJDkuKrmjqLmtYvmlaPliJfooajkuK3nmoTlhbbku5blnLDlnYDvvIznm7TliLDmib7liLDnu5nlrprnmoTlhbPplK7lrZfmiJbkuIDkuKrnqbrlnLDlnYAo5byA5pS+55qE5Zyw5Z2AKeS4uuatou+8jOWwhuWPkeeUn+WGsueqgeeahOiusOW9leaUvuWIsOivpeWcsOWdgOS4reOAguaVo+WIl+WcsOWdgOeahOiuoeeul+WFrOW8j+aYr++8mlxyXG5IaShrZXkpPShIKGtleSkrZGkpICBNT0Qgbe+8jGk9MSwgMiwg4oCmLCBrKGs8PW0tMSlcclxuXHJcbuWFtuS4re+8mkgoa2V5Ke+8muWTiOW4jOWHveaVsO+8m23vvJrmlaPliJfooajplb/luqbvvJtcclxuZGnvvJrnrKxp5qyh5o6i5rWL5pe255qE5aKe6YeP5bqP5YiX77ybXHJcbkhpKGtleSkg77ya57uP56ysaeasoeaOoua1i+WQjuW+l+WIsOeahOaVo+WIl+WcsOWdgOOAglxyXG5cclxu4pG0ICDnur/mgKfmjqLmtYvms5Vcclxu5bCG5pWj5YiX6KGoVFswIOKApm0tMV3nnIvmiJDlvqrnjq/lkJHph4/jgILlvZPlj5HnlJ/lhrLnqoHml7bvvIzku47liJ3mrKHlj5HnlJ/lhrLnqoHnmoTkvY3nva7kvp3mrKHlkJHlkI7mjqLmtYvlhbbku5bnmoTlnLDlnYDjgIJcclxu5aKe6YeP5bqP5YiX5Li677yaZGk9MSwgMiwgMywg4oCmLCBtLTFcclxu6K6+5Yid5qyh5Y+R55Sf5Yay56qB55qE5Zyw5Z2A5pivaO+8jOWImeS+neasoeaOoua1i1RbaCsxXe+8jFRbaCsyXeKApu+8jOebtOWIsFRbbS0xXeaXtuWPiOW+queOr+WIsOihqOWktO+8jOWGjeasoeaOoua1i1RbMF3vvIxUWzFd4oCm77yM55u05YiwVFtoLTFd44CC5o6i5rWL6L+H56iL57uI5q2i55qE5oOF5Ya15piv77yaXHJcbuKXhiDmjqLmtYvliLDnmoTlnLDlnYDkuLrnqbrvvJrooajkuK3msqHmnInorrDlvZXjgILoi6XmmK/mn6Xmib7liJnlpLHotKXvvJvoi6XmmK/mj5LlhaXliJnlsIborrDlvZXlhpnlhaXliLDor6XlnLDlnYDvvJtcclxu4peGIOaOoua1i+WIsOeahOWcsOWdgOaciee7meWumueahOWFs+mUruWtl++8muiLpeaYr+afpeaJvuWImeaIkOWKn++8m+iLpeaYr+aPkuWFpeWImeWksei0pe+8m1xyXG7il4Yg55u05YiwVFtoXe+8muS7jeacquaOoua1i+WIsOepuuWcsOWdgOaIlue7meWumueahOWFs+mUruWtl++8jOaVo+WIl+ihqOa7oeOAglxyXG5cclxu5L6LMSDvvJrorr7mlaPliJfooajplb/kuLo377yM6K6w5b2V5YWz6ZSu5a2X57uE5Li677yaMTUsIDE0LCAyOCwgMjYsIDU2LCAyM++8jOaVo+WIl+WHveaVsO+8mkgoa2V5KT1rZXkgICBNT0QgIDfvvIzlhrLnqoHlpITnkIbph4fnlKjnur/mgKfmjqLmtYvms5XjgIJcclxuSCgxNSk9MTUgIE1PRCA3PTFcclxuSCgxNCk9MTQgIE1PRCA3PTBcclxuSCgyOCk9MjggIE1PRCA3PTAgIOWGsueqgSAgIEgxKDI4KT0xICDlj4jlhrLnqoFcclxuSDIoMjgpPTIgICAgICAgICAgIEgoMjYpPTI2ICBNT0QgNz01XHJcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXHJcbkgyKDU2KT0yICAg5Y+I5Yay56qBICAgIEgzKDU2KT0zXHJcbkgoMjMpPTIzICBNT0QgNz0yICAgICDlhrLnqoEgICAgICBIMSgyMyk9MyAgICAg5Y+I5Yay56qBXHJcbkgzKDIzKT00XHJcblxyXG4wICAgICAxICAgICAgMiAgICAgIDMgICAgICA0ICAgICAgIDUgICAgIDZcclxuMTQgICAgMTUgICAgIDI4ICAgICA1NiAgICAgMjMgICAgICAyNlxyXG5cclxu57q/5oCn5o6i5rWL5rOV55qE54m554K5XHJcbuKXhiDkvJjngrnvvJrlj6ropoHmlaPliJfooajmnKrmu6HvvIzmgLvog73mib7liLDkuIDkuKrkuI3lhrLnqoHnmoTmlaPliJflnLDlnYDvvJtcclxu4peGIOe8uueCue+8muavj+S4quS6p+eUn+WGsueqgeeahOiusOW9leiiq+aVo+WIl+WIsOemu+WGsueqgeacgOi/keeahOepuuWcsOWdgOS4iu+8jOS7juiAjOWPiOWinuWKoOS6huabtOWkmueahOWGsueqgeacuuS8mijov5nnp43njrDosaHnp7DkuLrlhrLnqoHnmoTigJzogZrpm4bigJ0p44CCXHJcblxyXG7ikbUgIOS6jOasoeaOoua1i+azlVxyXG7lop7ph4/luo/liJfkuLrvvJpkaT0xwrIsLTHCsiwywrIsLTLCsiwzwrIs4oCm4oCmwrFrwrIgIChrPD3ijIptLzLijIspXHJcblxyXG7kuIrov7Dkvovpopjoi6Xph4fnlKjkuozmrKHmjqLmtYvms5Xov5vooYzlhrLnqoHlpITnkIbvvIzliJnvvJpcclxuSCgxNSk9MTUgIE1PRCA3PTEgICAgICAgICBIKDE0KT0xNCAgTU9EIDc9MFxyXG5IKDI4KT0yOCAgTU9EIDc9MCAgICAg5Yay56qBICAgICAgSDEoMjgpPTEgICAgIOWPiOWGsueqgVxyXG5IMigyOCk9NFxyXG5IKDI2KT0yNiAgTU9EIDc9NVxyXG5IKDU2KT01NiAgTU9EIDc9MCAgICAg5Yay56qBICAgICAgSDEoNTYpPTEgICAgIOWPiOWGsueqgVxyXG5IMig1Nik9MCAgIOWPiOWGsueqgSAgICBIMyg1Nik9NCAgICDlj4jlhrLnqoFcclxuSDQoNTYpPTJcclxuSCgyMyk9MjMgIE1PRCA3PTIgICAgICDlhrLnqoFcclxuSDEoMjMpPTNcclxuXHJcbuS6jOasoeaOoua1i+azleeahOeJueeCuVxyXG7il4Yg5LyY54K577ya5o6i5rWL5bqP5YiX6Lez6LeD5byP5Zyw5pWj5YiX5Yiw5pW05Liq6KGo5Lit77yM5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd546w6LGh77ybXHJcbuKXhiDnvLrngrnvvJrkuI3og73kv53or4HmjqLmtYvliLDmlaPliJfooajnmoTmiYDmnInlnLDlnYDjgIJcclxuXHJcbuKRtiAgIOS8qumaj+acuuaOoua1i+azlVxyXG7lop7ph4/luo/liJfkvb/nlKjkuIDkuKrkvKrpmo/mnLrlh73mlbDmnaXkuqfnlJ/kuIDkuKrokL3lnKjpl63ljLrpl7RbMe+8jG0tMV3nmoTpmo/mnLrluo/liJfjgIJcclxuXHJcbuS+izIg77yaIOihqOmVv+S4ujEx55qE5ZOI5biM6KGo5Lit5bey5aGr5pyJ5YWz6ZSu5a2X5Li6MTfvvIw2MO+8jDI555qE6K6w5b2V77yM5pWj5YiX5Ye95pWw5Li6SChrZXkpPWtleSAgTU9EICAxMSDjgIIg546w5pyJ56ysNOS4quiusOW9le+8jOWFtuWFs+mUruWtl+S4ujM477yM5oyJ5LiJ56eN5aSE55CG5Yay56qB55qE5pa55rOV77yM5bCG5a6D5aGr5YWl6KGo5Lit44CCXHJcblxyXG4oMSkgIEgoMzgpPTM4IE1PRCAxMT01ICAgIOWGsueqgVxyXG4gICAgIEgxPSg1KzEpIE1PRCAxMT02ICAgIOWGsueqgVxyXG4gICAgIEgyPSg1KzIpIE1PRCAxMT03ICAgIOWGsueqgVxyXG4gICAgIEgzPSg1KzMpIE1PRCAxMT04ICAgIOS4jeWGsueqgVxyXG4oMikgIEgoMzgpPTM4IE1PRCAxMT01ICAgICAg5Yay56qBXHJcbiAgICAgSDE9KDUrMcKyKSBNT0QgMTE9NiAgICDlhrLnqoFcclxuICAgICBIMj0oNS0xwrIpIE1PRCAxMT00ICAgICDkuI3lhrLnqoFcclxuKDMpICBIKDM4KT0zOCBNT0QgMTE9NSAgICDlhrLnqoFcclxuICAgICDorr7kvKrpmo/mnLrmlbDluo/liJfkuLo577yM5YiZSDE9KDUrOSkgTU9EIDExPTMg5LiN5Yay56qBXHJcblxyXG5cclxuMiAg5YaN5ZOI5biM5rOVXHJcbuaehOmAoOiLpeW5suS4quWTiOW4jOWHveaVsO+8jOW9k+WPkeeUn+WGsueqgeaXtu+8jOWIqeeUqOS4jeWQjOeahOWTiOW4jOWHveaVsOWGjeiuoeeul+S4i+S4gOS4quaWsOWTiOW4jOWcsOWdgO+8jOebtOWIsOS4jeWPkeeUn+WGsueqgeS4uuatouOAguWNs++8mkhpPVJIaShrZXkpICAgICBpPTEsIDIsIOKApiwga1xyXG5SSGkg77ya5LiA57uE5LiN5ZCM55qE5ZOI5biM5Ye95pWw44CC56ys5LiA5qyh5Y+R55Sf5Yay56qB5pe277yM55SoUkgx6K6h566X77yM56ys5LqM5qyh5Y+R55Sf5Yay56qB5pe277yM55SoUkgy6K6h566X4oCm5L6d5q2k57G75o6o55+l6YGT5b6X5Yiw5p+Q5LiqSGnkuI3lho3lhrLnqoHkuLrmraLjgIJcclxu4peGICDkvJjngrnvvJrkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3njrDosaHvvJtcclxu4peGICDnvLrngrnvvJrorqHnrpfml7bpl7Tlop7liqDjgIJcclxuXHJcblxyXG4zICDpk77lnLDlnYDms5Vcclxu5pa55rOV77ya5bCG5omA5pyJ5YWz6ZSu5a2X5Li65ZCM5LmJ6K+NKOaVo+WIl+WcsOWdgOebuOWQjCnnmoTorrDlvZXlrZjlgqjlnKjkuIDkuKrljZXpk77ooajkuK3vvIzlubbnlKjkuIDnu7TmlbDnu4TlrZjmlL7pk77ooajnmoTlpLTmjIfpkojjgIJcclxu6K6+5pWj5YiX6KGo6ZW/5Li6be+8jOWumuS5ieS4gOS4quS4gOe7tOaMh+mSiOaVsOe7hO+8mlxyXG5SZWNOb2RlICpsaW5raGFzaFttXe+8jOWFtuS4rVJlY05vZGXmmK/nu5PngrnnsbvlnovvvIzmr4/kuKrliIbph4/nmoTliJ3lgLzkuLrnqbrjgILlh6HmlaPliJflnLDlnYDkuLpr55qE6K6w5b2V6YO95o+S5YWl5Yiw5LulbGlua2hhc2hba13kuLrlpLTmjIfpkojnmoTpk77ooajkuK3vvIzmj5LlhaXkvY3nva7lj6/ku6XlnKjooajlpLTmiJbooajlsL7miJbmjInlhbPplK7lrZfmjpLluo/mj5LlhaXjgIJcclxuXHJcbuS+i++8miDlt7Lnn6XkuIDnu4TlhbPplK7lrZcoMTksIDE0LCAyMywgMSwgNjgsIDIwLCA4NCwgMjcsIDU1LCAxMSwgMTAsIDc5KSDvvIzlk4jluIzlh73mlbDkuLrvvJpIKGtleSk9a2V5IE1PRCAxM++8jOeUqOmTvuWcsOWdgOazleWkhOeQhuWGsueqgTpcclxuXHJcbiAwXHJcbiAxICAtLT4gMTQgLT4gMSAtPiAyNyAtPiA3OVxyXG4gMlxyXG4gMyAgLS0+IDY4IC0+IDU1XHJcbiA0XHJcbiA1XHJcbiA2ICAtLT4gMTkgLT4gODRcclxuIDcgIC0tPiAyMFxyXG4gOFxyXG4gOVxyXG4gMTAgLS0+IDIzIC0+IDEwXHJcbiAxMSAtLT4gMTFcclxuIDEyXHJcblxyXG4g5LyY54K577ya5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd77yb5Yig6Zmk6K6w5b2V5Lmf5b6I566A5Y2V44CCXHJcblxyXG5cclxuIDQgIOW7uueri+WFrOWFsea6ouWHuuWMulxyXG4g5pa55rOV77ya5Zyo5Z+65pys5pWj5YiX6KGo5LmL5aSW77yM5Y+m5aSW6K6+56uL5LiA5Liq5rqi5Ye66KGo5L+d5a2Y5LiO5Z+65pys6KGo5Lit6K6w5b2V5Yay56qB55qE5omA5pyJ6K6w5b2V44CCXHJcbiDorr7mlaPliJfooajplb/kuLpt77yM6K6+56uL5Z+65pys5pWj5YiX6KGoaGFzaHRhYmxlW21d77yM5q+P5Liq5YiG6YeP5L+d5a2Y5LiA5Liq6K6w5b2V77yb5rqi5Ye66KGob3ZlcnRhYmxlW21d77yM5LiA5pem5p+Q5Liq6K6w5b2V55qE5pWj5YiX5Zyw5Z2A5Y+R55Sf5Yay56qB77yM6YO95aGr5YWl5rqi5Ye66KGo5Lit44CCXHJcblxyXG4g5L6L77yaIOW3suefpeS4gOe7hOWFs+mUruWtlygxNSwgNCwgMTgsIDcsIDM3LCA0Nykg77yM5pWj5YiX6KGo6ZW/5bqm5Li6NyDvvIzlk4jluIzlh73mlbDkuLrvvJpIKGtleSk9a2V5IE1PRCA377yM55So5bu656uL5YWs5YWx5rqi5Ye65Yy65rOV5aSE55CG5Yay56qB44CC5b6X5Yiw55qE5Z+65pys6KGo5ZKM5rqi5Ye66KGo5aaC5LiL77yaXHJcbiAgICAgICAgICAgICAgICAgICAg5pWj5YiX5Zyw5Z2AICAgIDAgICAgIDEgICAgIDIgICAgIDMgICAgIDQgICAgIDUgICAgIDZcclxuIEhhc2h0YWJsZeihqO+8mlxyXG4gICAgICAgICAgICAgICAgICAgIOWFs+mUruWtlyAgICAgNyAgICAgMTUgICAgMzcgICAgICAgICAgNCAgICAgNDdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAg5rqi5Ye65Zyw5Z2AICAgIDAgICAgIDEgICAgIDIgICAgIDMgICAgIDQgICAgIDUgICAgIDZcclxuIG92ZXJ0YWJsZeihqO+8mlxyXG4gICAgICAgICAgICAgICAgICAgICDlhbPplK7lrZcgICAgMThcclxuXHJcblxyXG5cclxuXHJcbiDlk4jluIzmn6Xmib7ov4fnqIvlj4rliIbmnpBcclxuXHJcbiAxICAg5ZOI5biM5p+l5om+6L+H56iLXHJcbiDlk4jluIzooajnmoTkuLvopoHnm67nmoTmmK/nlKjkuo7lv6vpgJ/mn6Xmib7vvIzkuJTmj5LlhaXlkozliKDpmaTmk43kvZzpg73opoHnlKjliLDmn6Xmib7jgILnlLHkuo7mlaPliJfooajnmoTnibnmrornu4Tnu4flvaLlvI/vvIzlhbbmn6Xmib7mnInnibnmrornmoTmlrnms5XjgIJcclxuXHJcbiDnu5nlrppL5YC877yM5qC55o2u6YCg6KGo5pe26K6+5a6a55qE5ZOI5biM5Ye95pWw5rGC5b6X5ZOI5biM5Zyw5Z2A77yM6Iul6KGo5Lit5q2k5L2N572u5LiK5rKh5pyJ6K6w5b2V77yM5YiZ5p+l5om+5LiN5oiQ5Yqf77yb5ZCm5YiZ5q+U6L6D5YWz6ZSu5a2X77yM6Iul5ZKM57uZ5a6a5YWz6ZSu5a2X55u4562J77yM5YiZ5p+l5om+5oiQ5Yqf77yb5ZCm5YiZ5qC55o2u6YCg6KGo5pe26K6+5a6a55qE5aSE55CG5Yay56qB55qE5pa55rOV5om+4oCc5LiL5LiA5Zyw5Z2A4oCd77yM55u05Yiw5ZOI5biM6KGo5Lit5p+Q5Liq5L2N572u5Li656m65oiW6ICF6KGo5Lit5omA5aGr6K6w5b2V55qE5YWz6ZSu5a2X562J5LqO57uZ5a6a5YC85pe25Li65q2i44CCXHJcblxyXG5cclxuXHJcbiDlk4jluIzmn6Xmib7liIbmnpBcclxuXHJcbiDku47lk4jluIzmn6Xmib7ov4fnqIvlj6/op4HvvJrlsL3nrqHmlaPliJfooajlnKjlhbPplK7lrZfkuI7orrDlvZXnmoTlrZjlgqjlnLDlnYDkuYvpl7Tlu7rnq4vkuobnm7TmjqXmmKDosaHvvIzkvYbnlLHkuo7igJzlhrLnqoHigJ3vvIzmn6Xmib7ov4fnqIvku43mmK/kuIDkuKrnu5nlrprlgLzkuI7lhbPplK7lrZfov5vooYzmr5TovoPnmoTov4fnqIvvvIzor4Tku7flk4jluIzmn6Xmib7mlYjnjofku43opoHnlKhBU0zjgIJcclxuIOWTiOW4jOafpeaJvuaXtuWFs+mUruWtl+S4jue7meWumuWAvOavlOi+g+eahOasoeaVsOWPluWGs+S6ju+8mlxyXG4g4peGIOWTiOW4jOWHveaVsO+8m1xyXG4g4peGIOWkhOeQhuWGsueqgeeahOaWueazle+8m1xyXG4g4peGIOWTiOW4jOihqOeahOWhq+a7oeWboOWtkM6xIOOAguWhq+a7oeWboOWtkM6x55qE5a6a5LmJ5piv77yaXHJcblxyXG4gzrEgPSDooajkuK3loavlhaXnmoTorrDlvZXmlbAgLyDlk4jluIzooajplb/luqZcclxuXHJcblxyXG4g5ZCE56eN5pWj5YiX5Ye95pWw5omA5p6E6YCg55qE5pWj5YiX6KGo55qEQVNM5aaC5LiL77yaXHJcblxyXG4g4pG0ICAg57q/5oCn5o6i5rWL5rOV55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXHJcbiBT5oiQ5YqfIOe6puetieS6jiAxIC8gMiAqICgxICsgMSAvICgxIC0gzrEpKVxyXG4gU+Wksei0pSDnuqbnrYnkuo4gMSAvIDIgKiAoMSArIDEgLyAoMSAtIM6xKSAqICgxIC0gzrEpKVxyXG5cclxuIOKRtSAgIOS6jOasoeaOoua1i+OAgeS8qumaj+acuuaOoua1i+OAgeWGjeWTiOW4jOazleeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxyXG4gU+aIkOWKnyDnuqbnrYnkuo4gLTEgLyDOsSAqIGxuKDEgLSDOsSlcclxuIFPlpLHotKUg57qm562J5LqOIDEgLyAoMSAtIM6xKVxyXG5cclxuIOKRtiAgIOeUqOmTvuWcsOWdgOazleino+WGs+WGsueqgeeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxyXG4gU+aIkOWKnyDnuqbnrYnkuo4gMSArIM6xIC8gMlxyXG4gU+Wksei0pSDnuqbnrYnkuo4gzrEgKyBl55qELc6x5qyh5bmCXHJcblxyXG5cclxuICovXHJcblxyXG5pbXBvcnQgTGlua2VkTGlzdCBmcm9tICcuLi9MaXN0L0xpbmtlZExpc3QnO1xyXG5cclxuXHJcbmxldCBoYXNoU2l6ZSA9IGJ1aWxkSGFzaFNpemUoOTc3LCAyMCk7XHJcblxyXG5leHBvcnQgY2xhc3MgSGFzaFRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgIC8vIOW9k+WJjeaVsOaNruWFg+e0oOS4quaVsDtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAvLyDlvZPliY3lrrnph49cclxuICAgICAgICB0aGlzLnNpemVJbmRleCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5L2/55So57q/5oCn5o6i5rWL5rOV6Kej5Yaz5Yay56qBXHJcbiAgICBzZWFyY2goa2V5KSB7XHJcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcclxuICAgICAgICBsZXQgcCA9IGhhc2goa2V5LCBtYXgpO1xyXG4gICAgICAgIGxldCBjID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHAgPCBtYXggJiYgdGhpcy5kYXRhW3BdICE9IG51bGwgJiYga2V5ICE9PSB0aGlzLmRhdGFbcF0pIHtcclxuICAgICAgICAgICAgcCA9IGNvbGxpc2lvbihrZXksICsrYywgbWF4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGtleSA9PT0gdGhpcy5kYXRhW3BdLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25UaW1lczogYyxcclxuICAgICAgICAgICAgaW5kZXg6IHBcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydChrZXkpIHtcclxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xyXG4gICAgICAgIGlmICh0aGlzLmNvdW50ID49IG1heCkgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9ybXNnOiAndGFibGUgb3ZlcmZsb3dlZCcgfTtcclxuXHJcbiAgICAgICAgbGV0IHJldCA9IHRoaXMuc2VhcmNoKGtleSk7XHJcbiAgICAgICAgbGV0IHAgPSByZXQuaW5kZXg7XHJcbiAgICAgICAgbGV0IGMgPSByZXQuY29sbGlzaW9uVGltZXM7XHJcblxyXG4gICAgICAgIGlmIChyZXQuc3VjY2VzcykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF0gLyAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwXSA9IGtleTtcclxuICAgICAgICAgICAgKyt0aGlzLmNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlY3JlYXRlSGFzaFRhYmxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb3VudCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xyXG4gICAgICAgIGxldCBwID0gaGFzaChrZXksIG1heCk7XHJcbiAgICAgICAgbGV0IGMgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoa2V5ICE9PSB0aGlzLmRhdGFbcF0pXHJcbiAgICAgICAgICAgIHAgPSBjb2xsaXNpb24oa2V5LCArK2MsIG1heCk7XHJcblxyXG5cclxuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLmRhdGFbcF0pIHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFbcF07XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UocCwgMSk7XHJcbiAgICAgICAgICAgIC0tdGhpcy5jb3VudDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlY3JlYXRlSGFzaFRhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiArK3RoaXMuc2l6ZUluZGV4IDwgaGFzaFNpemUubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIEVMRmhhc2jlrZfnrKbkuLLmlaPliJflh73mlbBcclxuZnVuY3Rpb24gaGFzaChzdHIsIG1heCkge1xyXG4gICAgbGV0IGhhc2ggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgKyBoYXNoICsgc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcclxuICAgICAgICBoYXNoID0gTWF0aC5hYnMoaGFzaCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaCAlIG1heDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGlzaW9uKGtleSwgdGltZXMsIG1heCkge1xyXG4gICAgLy8g57q/5oCn5o6i5rWL5rOVXHJcbiAgICByZXR1cm4gKGhhc2goa2V5LCBtYXgpICsgdGltZXMpICUgbWF4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ByaW1lKG4pIHtcclxuICAgIGlmIChuIDw9IDMpIHJldHVybiBuID4gMTtcclxuICAgIGlmIChuICUgMiA9PT0gMCB8fCBuICUgMyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yIChsZXQgaSA9IDU7IGkgKiBpIDw9IG47IGkgKz0gNikge1xyXG4gICAgICAgIGlmIChuICUgaSA9PT0gMCB8fCBuICUgKGkgKyAyKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZEhhc2hTaXplKGJlZ2luLCBsZW5ndGgpIHtcclxuICAgIGxldCBoYXNoU2l6ZSA9IFtdO1xyXG5cclxuICAgIHdoaWxlICgxKSB7XHJcbiAgICAgICAgaWYgKGhhc2hTaXplLmxlbmd0aCA+PSBsZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIGlmIChpc1ByaW1lKGJlZ2luKSkgaGFzaFNpemUucHVzaChiZWdpbik7XHJcbiAgICAgICAgKytiZWdpbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGFzaFNpemU7XHJcbn1cclxuXHJcbi8vIOW8gOaUvuWumuWdgOazlVxyXG4vL2hhc2hTaXplID0gWzUsIDddOyAvLyBmb3IgdGVzdC4gd2lsbCBiZSBkZWxldGVkXHJcbmxldCB0ZXN0ID0gbmV3IEhhc2hUYWJsZSgpO1xyXG50ZXN0Lmluc2VydCgnMTcnKTtcclxudGVzdC5pbnNlcnQoJzYwJyk7XHJcbnRlc3QuaW5zZXJ0KCcyOScpO1xyXG50ZXN0Lmluc2VydCgnMzgnKTtcclxudGVzdC5pbnNlcnQoJzM5Jyk7XHJcbnRlc3QuaW5zZXJ0KCc0MCcpO1xyXG5cclxudGVzdC5yZW1vdmUoJzE3Jyk7XHJcbnRlc3QucmVtb3ZlKCc2MCcpO1xyXG50ZXN0LnJlbW92ZSgnMjknKTtcclxudGVzdC5yZW1vdmUoJzM4Jyk7XHJcbnRlc3QucmVtb3ZlKCczOScpO1xyXG50ZXN0LnJlbW92ZSgnNDAnKTtcclxuXHJcblxyXG4vLyDkvb/nlKjpk77lnLDlnYDms5Xop6PlhrPlhrLnqoHnmoTlk4jluIzooahcclxuXHJcbmV4cG9ydCBjbGFzcyBMaW5rZWRMaXN0SGFzaFRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIOW9k+WJjeaVsOaNruWFg+e0oOS4quaVsDtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAvLyDlvZPliY3lrrnph49cclxuICAgICAgICB0aGlzLnNpemVJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5oTm9kZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2goa2V5KSB7XHJcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcclxuICAgICAgICBsZXQgaSA9IGhhc2goa2V5LCBtYXgpO1xyXG4gICAgICAgIGxldCB0ID0gdGhpcy5oTm9kZXM7XHJcblxyXG4gICAgICAgIGlmICh0W2ldID09IG51bGwpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBpbmRleDogaSB9O1xyXG5cclxuICAgICAgICBsZXQgcCA9IHRbaV07XHJcbiAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xyXG5cclxuICAgICAgICBwLmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZGF0YSA9PT0ga2V5LCBpbmRleDogaSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydChrZXkpIHtcclxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xyXG4gICAgICAgIGlmICh0aGlzLmNvdW50ID49IG1heCkgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9ybXNnOiAndGFibGUgb3ZlcmZsb3dlZCcgfTtcclxuXHJcbiAgICAgICAgbGV0IHJldCA9IHRoaXMuc2VhcmNoKGtleSk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gcmV0LmluZGV4O1xyXG5cclxuICAgICAgICBpZiAocmV0LnN1Y2Nlc3MpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhOb2Rlc1tpbmRleF0pIHRoaXMuaE5vZGVzW2luZGV4XSA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhOb2Rlc1tpbmRleF0uc2l6ZSgpIDwgaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdIC8gMikge1xyXG4gICAgICAgICAgICB0aGlzLmhOb2Rlc1tpbmRleF0ub3JkZXJJbnNlcnQoa2V5KTtcclxuICAgICAgICAgICAgKyt0aGlzLmNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlY3JlYXRlSGFzaFRhYmxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb3VudCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgcmV0ID0gdGhpcy5zZWFyY2goa2V5KTtcclxuXHJcbiAgICAgICAgaWYgKHJldC5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHJldC5pbmRleDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXQuZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5oTm9kZXNbaW5kZXhdWydyZW1vdmUnXShrZXkpO1xyXG4gICAgICAgICAgICAtLXRoaXMuY291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlY3JlYXRlSGFzaFRhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiArK3RoaXMuc2l6ZUluZGV4IDwgaGFzaFNpemUubGVuZ3RoO1xyXG4gICAgfVxyXG59O1xyXG5cclxubGV0IHRlc3QyID0gbmV3IExpbmtlZExpc3RIYXNoVGFibGUoKTtcclxudGVzdDIuaW5zZXJ0KCcxNycpO1xyXG50ZXN0Mi5pbnNlcnQoJzYwJyk7XHJcbnRlc3QyLmluc2VydCgnMjknKTtcclxudGVzdDIuaW5zZXJ0KCczOCcpO1xyXG50ZXN0Mi5pbnNlcnQoJzM5Jyk7XHJcbnRlc3QyLmluc2VydCgnNDAnKTtcclxuXHJcbnRlc3QyLnJlbW92ZSgnMTcnKTtcclxudGVzdDIucmVtb3ZlKCc2MCcpO1xyXG50ZXN0Mi5yZW1vdmUoJzI5Jyk7XHJcbnRlc3QyLnJlbW92ZSgnMzgnKTtcclxudGVzdDIucmVtb3ZlKCczOScpO1xyXG50ZXN0Mi5yZW1vdmUoJzQwJyk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NlYXJjaC9IYXNoVGFibGUuanNcbiAqKi8iLCIvKipcclxuICogUmVkIEJsYWNrIFRyZWVcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTQvMTIvMzAuXHJcbiAqL1xyXG4vKlxyXG4gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzYxMDU2MzBcclxuXHJcbiDnuqLpu5HmoJHvvIzkuIDnp43kuozlj4nmn6Xmib7moJHvvIzkvYblnKjmr4/kuKrnu5PngrnkuIrlop7liqDkuIDkuKrlrZjlgqjkvY3ooajnpLrnu5PngrnnmoTpopzoibLvvIzlj6/ku6XmmK9SZWTmiJZCbGFja+OAglxyXG4g6YCa6L+H5a+55Lu75L2V5LiA5p2h5LuO5qC55Yiw5Y+25a2Q55qE6Lev5b6E5LiK5ZCE5Liq57uT54K5552A6Imy5pa55byP55qE6ZmQ5Yi277yM57qi6buR5qCR56Gu5L+d5rKh5pyJ5LiA5p2h6Lev5b6E5Lya5q+U5YW25LuW6Lev5b6E6ZW/5Ye65L+p5YCN77yM5Zug6ICM5piv5o6l6L+R5bmz6KGh55qE44CCXHJcblxyXG4g57qi6buR5qCR6Jm954S25pys6LSo5LiK5piv5LiA5qO15LqM5Y+J5p+l5om+5qCR77yM5L2G5a6D5Zyo5LqM5Y+J5p+l5om+5qCR55qE5Z+656GA5LiK5aKe5Yqg5LqG552A6Imy5ZKM55u45YWz55qE5oCn6LSo5L2/5b6X57qi6buR5qCR55u45a+55bmz6KGh77yM5LuO6ICM5L+d6K+B5LqG57qi6buR5qCR55qE5p+l5om+44CB5o+S5YWl44CB5Yig6Zmk55qE5pe26Ze05aSN5p2C5bqm5pyA5Z2P5Li6Tyhsb2cgbinjgIJcclxuXHJcbiDnuqLpu5HmoJHnmoQ15Liq5oCn6LSo77yaXHJcbiAxLuavj+S4que7k+eCueimgeS5iOaYr+e6oueahOimgeS5iOaYr+m7keeahOOAglxyXG4gMi7moLnnu5PngrnmmK/pu5HnmoTjgIJcclxuIDMu5q+P5Liq5Y+257uT54K577yI5Y+257uT54K55Y2z5oyH5qCR5bC+56uvTklM5oyH6ZKI5oiWTlVMTOe7k+eCue+8iemDveaYr+m7keeahOOAglxyXG4gNC7lpoLmnpzkuIDkuKrnu5PngrnmmK/nuqLnmoTvvIzpgqPkuYjlroPnmoTkuKTkuKrlhL/lrZDpg73mmK/pu5HnmoTjgIJcclxuIDUu5a+55LqO5Lu75oSP57uT54K56ICM6KiA77yM5YW25Yiw5Y+257uT54K55qCR5bC+56uvTklM5oyH6ZKI55qE5q+P5p2h6Lev5b6E6YO95YyF5ZCr55u45ZCM5pWw55uu55qE6buR57uT54K544CCXHJcblxyXG4g5q2j5piv57qi6buR5qCR55qE6L+ZNeadoeaAp+i0qO+8jOS9v+S4gOajtW7kuKrnu5PngrnnmoTnuqLpu5HmoJHlp4vnu4jkv53mjIHkuoZsb2du55qE6auY5bqm77yM5LuO6ICM5Lmf5bCx6Kej6YeK5LqG5LiK6Z2i5omA6K+055qE4oCc57qi6buR5qCR55qE5p+l5om+44CB5o+S5YWl44CB5Yig6Zmk55qE5pe26Ze05aSN5p2C5bqm5pyA5Z2P5Li6Tyhsb2cgbinigJ3ov5nkuIDnu5PorrrmiJDnq4vnmoTljp/lm6DjgIJcclxuXHJcblxyXG4g5qCR55qE5peL6L2sXHJcblxyXG7lvZPlnKjlr7nnuqLpu5HmoJHov5vooYzmj5LlhaXlkozliKDpmaTnrYnmk43kvZzml7bvvIzlr7nmoJHlgZrkuobkv67mlLnlj6/og73kvJrnoLTlnY/nuqLpu5HmoJHnmoTmgKfotKjjgILkuLrkuobnu6fnu63kv53mjIHnuqLpu5HmoJHnmoTmgKfotKjvvIzlj6/ku6XpgJrov4flr7nnu5Pngrnov5vooYzph43mlrDnnYDoibLvvIzku6Xlj4rlr7nmoJHov5vooYznm7jlhbPnmoTml4vovazmk43kvZzvvIzljbPpgJrov4fkv67mlLnmoJHkuK3mn5Dkupvnu5PngrnnmoTpopzoibLlj4rmjIfpkojnu5PmnoTvvIzmnaXovr7liLDlr7nnuqLpu5HmoJHov5vooYzmj5LlhaXmiJbliKDpmaTnu5PngrnnrYnmk43kvZzlkI7nu6fnu63kv53mjIHlroPnmoTmgKfotKjmiJblubPooaHnmoTnm67nmoTjgIJcclxuXHJcbuagkeeahOaXi+i9rOWIhuS4uuW3puaXi+WSjOWPs+aXi1xyXG5cclxu5qCR5Zyo57uP6L+H5bem5peL5Y+z5peL5LmL5ZCO77yM5qCR55qE5pCc57Si5oCn6LSo5L+d5oyB5LiN5Y+Y77yM5L2G5qCR55qE57qi6buR5oCn6LSo5YiZ6KKr56C05Z2P5LqG77yM5omA5Lul77yM57qi6buR5qCR5o+S5YWl5ZKM5Yig6Zmk5pWw5o2u5ZCO77yM6ZyA6KaB5Yip55So5peL6L2s5LiO6aKc6Imy6YeN5raC5p2l6YeN5paw5oGi5aSN5qCR55qE57qi6buR5oCn6LSo44CCXHJcblxyXG5cclxu57qi6buR5qCR55qE5o+S5YWlXHJcblxyXG7lpoLmnpzmj5LlhaXnmoTmmK/moLnnu5PngrnvvIznlLHkuo7ljp/moJHmmK/nqbrmoJHvvIzmraTmg4XlhrXlj6rkvJrov53lj43mgKfotKgy77yM5Zug5q2k55u05o6l5oqK5q2k57uT54K55raC5Li66buR6Imy77yb5aaC5p6c5o+S5YWl55qE57uT54K555qE54i257uT54K55piv6buR6Imy77yM55Sx5LqO5q2k5LiN5Lya6L+d5Y+N5oCn6LSoMuWSjOaAp+i0qDTvvIznuqLpu5HmoJHmsqHmnInooqvnoLTlnY/vvIzmiYDku6XmraTml7bku4DkuYjkuZ/kuI3lgZrjgIJcclxu5L2G5b2T6YGH5Yiw5LiL6L+wM+enjeaDheWGteaXtuWPiOivpeWmguS9leiwg+aVtOWRou+8n1xyXG7il48g5o+S5YWl5L+u5aSN5oOF5Ya1Me+8muWmguaenOW9k+WJjee7k+eCueeahOeItue7k+eCueaYr+e6ouiJsuS4lOellueItue7k+eCueeahOWPpuS4gOS4quWtkOe7k+eCue+8iOWPlOe7k+eCue+8ieaYr+e6ouiJslxyXG7mraTml7bniLbnu5PngrnnmoTniLbnu5PngrnkuIDlrprlrZjlnKjvvIzlkKbliJnmj5LlhaXliY3lsLHlt7LkuI3mmK/nuqLpu5HmoJHjgILkuI7mraTlkIzml7bvvIzlj4jliIbkuLrniLbnu5PngrnmmK/npZbniLbnu5PngrnnmoTlt6blranlrZDov5jmmK/lj7PlranlrZDvvIzmoLnmja7lr7nnp7DmgKfvvIzmiJHku6zlj6ropoHop6PlvIDkuIDkuKrmlrnlkJHlsLHlj6/ku6XkuobjgILov5nph4zlj6rogIPomZHniLbnu5PngrnkuLrnpZbniLblt6blranlrZDnmoTmg4XlhrVcclxu5a+55q2k77yM5oiR5Lus55qE6Kej5Yaz562W55Wl5piv77ya5bCG5b2T5YmN6IqC54K555qE54i26IqC54K55ZKM5Y+U5Y+U6IqC54K55raC6buR77yM56WW54i257uT54K55raC57qi77yM5oqK5b2T5YmN57uT54K55oyH5ZCR56WW54i26IqC54K577yM5LuO5paw55qE5b2T5YmN6IqC54K56YeN5paw5byA5aeL566X5rOV44CCXHJcbuS6juaYr++8jOaPkuWFpeS/ruWkjeaDheWGtTHovazmjaLmiJDkuobmj5LlhaXkv67lpI3mg4XlhrUyXHJcblxyXG7il48g5o+S5YWl5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueeahOeItuiKgueCueaYr+e6ouiJsizlj5ToioLngrnmmK/pu5HoibLvvIzlvZPliY3oioLngrnmmK/lhbbniLboioLngrnnmoTlj7PlrZBcclxu5q2k5pe277yM6Kej5Yaz5a+5562W5piv77ya5b2T5YmN6IqC54K555qE54i26IqC54K55YGa5Li65paw55qE5b2T5YmN6IqC54K577yM5Lul5paw5b2T5YmN6IqC54K55Li65pSv54K55bem5peL44CCXHJcbuS7juiAjOaPkuWFpeS/ruWkjeaDheWGtTLovazmjaLmiJDkuobmj5LlhaXkv67lpI3mg4XlhrUz44CCXHJcblxyXG7il48g5o+S5YWl5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueeahOeItuiKgueCueaYr+e6ouiJsizlj5ToioLngrnmmK/pu5HoibLvvIzlvZPliY3oioLngrnmmK/lhbbniLboioLngrnnmoTlt6blrZBcclxu6Kej5Yaz5a+5562W5piv77ya54i26IqC54K55Y+Y5Li66buR6Imy77yM56WW54i26IqC54K55Y+Y5Li657qi6Imy77yM5Zyo56WW54i26IqC54K55Li65pSv54K55Y+z5peL77yMXHJcbuacgOWQju+8jOaKiuaguee7k+eCuea2guS4uum7keiJsu+8jOaVtOajtee6oum7keagkeS+v+mHjeaWsOaBouWkjeS6huW5s+ihoeOAglxyXG5cclxu57uP6L+H5LiK6Z2i5oOF5Ya1M+OAgeaDheWGtTTjgIHmg4XlhrU1562JM+enjeaPkuWFpeS/ruWkjeaDheWGteeahOaTjeS9nOekuuaEj+Wbvu+8jOivu+iAheiHquS8muWPkeeOsO+8jOWQjumdoueahOaDheWGtTTjgIHmg4XlhrU16YO95piv6ZKI5a+55oOF5Ya1M+aPkuWFpeiKgueCuTTku6XlkI7vvIzov5vooYznmoTkuIDns7vliJfmj5LlhaXkv67lpI3mg4XlhrXmk43kvZzvvIzkuI3ov4fvvIzmjIflkJHlvZPliY3oioLngrlO5oyH6ZKI5LiA55u05Zyo5Y+Y5YyW44CC5omA5Lul77yM5L2g5Y+v5Lul5oOz5b2T54S255qE6K6k5Li677ya5pW05Liq5LiL5p2l77yM5oOF5Ya1M+OAgTTjgIE15bCx5piv5LiA5Liq5a6M5pW055qE5o+S5YWl5L+u5aSN5oOF5Ya155qE5pON5L2c5rWB56iLXHJcblxyXG5cclxu57qi6buR5qCR55qE5Yig6ZmkXHJcblxyXG7lnKjliKDpmaToioLngrnlkI7vvIzljp/nuqLpu5HmoJHnmoTmgKfotKjlj6/og73ooqvmlLnlj5jvvIzlpoLmnpzliKDpmaTnmoTmmK/nuqLoibLoioLngrnvvIzpgqPkuYjljp/nuqLpu5HmoJHnmoTmgKfotKjkvp3ml6fkv53mjIHvvIzmraTml7bkuI3nlKjlgZrkv67mraPmk43kvZzvvIzlpoLmnpzliKDpmaTnmoToioLngrnmmK/pu5HoibLoioLngrnvvIzljp/nuqLpu5HmoJHnmoTmgKfotKjlj6/og73kvJrooqvmlLnlj5jvvIzmiJHku6zopoHlr7nlhbblgZrkv67mraPmk43kvZzjgILpgqPkuYjlk6rkupvmoJHnmoTmgKfotKjkvJrlj5HnlJ/lj5jljJblkaLvvIzlpoLmnpzliKDpmaToioLngrnkuI3mmK/moJHllK/kuIDoioLngrnvvIzpgqPkuYjliKDpmaToioLngrnnmoTpgqPkuIDkuKrmlK/nmoTliLDlkITlj7boioLngrnnmoTpu5HoibLoioLngrnmlbDkvJrlj5HnlJ/lj5jljJbvvIzmraTml7bmgKfotKg16KKr56C05Z2P44CC5aaC5p6c6KKr5Yig6IqC54K555qE5ZSv5LiA6Z2e56m65a2Q6IqC54K55piv57qi6Imy77yM6ICM6KKr5Yig6IqC54K555qE54i26IqC54K55Lmf5piv57qi6Imy77yM6YKj5LmI5oCn6LSoNOiiq+egtOWdj+OAguWmguaenOiiq+WIoOiKgueCueaYr+agueiKgueCue+8jOiAjOWug+eahOWUr+S4gOmdnuepuuWtkOiKgueCueaYr+e6ouiJsu+8jOWImeWIoOmZpOWQjuaWsOagueiKgueCueWwhuWPmOaIkOe6ouiJsu+8jOi/neiDjOaAp+i0qDLjgIJcclxuXHJcbuS4iumdoueahOS/ruWkjeaDheWGteeci+i1t+adpeacieS6m+Wkjeadgu+8jOS4i+mdouaIkeS7rOeUqOS4gOS4quWIhuaekOaKgOW3p++8muaIkeS7rOS7juiiq+WIoOiKgueCueWQjuadpemhtuabv+Wug+eahOmCo+S4quiKgueCueW8gOWni+iwg+aVtO+8jOW5tuiupOS4uuWug+aciemineWklueahOS4gOmHjem7keiJsuOAgui/memHjOmineWkluS4gOmHjem7keiJsuaYr+S7gOS5iOaEj+aAneWRou+8jOaIkeS7rOS4jeaYr+aKiue6oum7keagkeeahOiKgueCueWKoOS4iumZpOe6ouS4jum7keeahOWPpuS4gOenjeminOiJsu+8jOi/memHjOWPquaYr+S4gOenjeWBh+iuvu+8jOaIkeS7rOiupOS4uuaIkeS7rOW9k+WJjeaMh+WQkeWug++8jOWboOatpOepuuaciemineWkluS4gOenjem7keiJsu+8jOWPr+S7peiupOS4uuWug+eahOm7keiJsuaYr+S7juWug+eahOeItuiKgueCueiiq+WIoOmZpOWQjue7p+aJv+e7meWug+eahO+8jOWug+eOsOWcqOWPr+S7peWuuee6s+S4pOenjeminOiJsu+8jOWmguaenOWug+WOn+adpeaYr+e6ouiJsu+8jOmCo+S5iOeOsOWcqOaYr+e6oivpu5HvvIzlpoLmnpzljp/mnaXmmK/pu5HoibLvvIzpgqPkuYjlroPnjrDlnKjnmoTpopzoibLmmK/pu5Er6buR44CC5pyJ5LqG6L+Z6YeN6aKd5aSW55qE6buR6Imy77yM5Y6f57qi6buR5qCR5oCn6LSoNeWwseiDveS/neaMgeS4jeWPmOOAgueOsOWcqOWPquimgeaBouWkjeWFtuWug+aAp+i0qOWwseWPr+S7peS6hu+8jOWBmuazlei/mOaYr+WwvemHj+WQkeagueenu+WKqOWSjOept+S4vuaJgOacieWPr+iDveaAp+OAglxyXG5cclxuIOWmguaenOaYr+S7peS4i+aDheWGte+8jOaBouWkjeavlOi+g+eugOWNle+8mlxyXG4gYSnlvZPliY3oioLngrnmmK/nuqIr6buR6ImyXHJcbiDop6Pms5XvvIznm7TmjqXmiorlvZPliY3oioLngrnmn5PmiJDpu5HoibLvvIznu5PmnZ/mraTml7bnuqLpu5HmoJHmgKfotKjlhajpg6jmgaLlpI3jgIJcclxuIGIp5b2T5YmN6IqC54K55piv6buRK+m7keS4lOaYr+agueiKgueCue+8jCDop6Pms5XvvJrku4DkuYjpg73kuI3lgZrvvIznu5PmnZ/jgIJcclxuXHJcbiDkvYblpoLmnpzmmK/ku6XkuIvmg4XlhrXlkaLvvJ/vvJpcclxuIOWIoOmZpOS/ruWkjeaDheWGtTHvvJrlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5YWE5byf6IqC54K55Li657qi6ImyKOatpOaXtueItuiKgueCueWSjOWFhOW8n+iKgueCueeahOWtkOiKgueCueWIhuS4uum7kSlcclxuIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibJcclxuIOWIoOmZpOS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Er6buR77yM5YWE5byf6IqC54K55piv6buR6Imy77yM5YWE5byf55qE5bem5a2Q5piv57qi6Imy77yM5Y+z5a2Q5piv6buR6ImyXHJcbiDliKDpmaTkv67lpI3mg4XlhrU077ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRLem7keiJsu+8jOWug+eahOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOS9huaYr+WFhOW8n+iKgueCueeahOWPs+WtkOaYr+e6ouiJsu+8jOWFhOW8n+iKgueCueW3puWtkOeahOminOiJsuS7u+aEj1xyXG4g5q2k5pe277yM5oiR5Lus6ZyA6KaB6LCD55SoUkItREVMRVRFLUZJWFVQKFQsIHgp77yM5p2l5oGi5aSN5LiO5L+d5oyB57qi6buR5oCn6LSo55qE5bel5L2c44CCXHJcblxyXG4g5LiL6Z2i77yM5ZKx5Lus5L6/5p2l5YiG5Yir5aSE55CG6L+ZNOenjeWIoOmZpOS/ruWkjeaDheWGteOAglxyXG5cclxuIOWIoOmZpOS/ruWkjeaDheWGtTHvvJrlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5YWE5byf6IqC54K55Li657qi6ImyKOatpOaXtueItuiKgueCueWSjOWFhOW8n+iKgueCueeahOWtkOiKgueCueWIhuS4uum7kSnjgIJcclxuIOino+azle+8muaKiueItuiKgueCueafk+aIkOe6ouiJsu+8jOaKiuWFhOW8n+e7k+eCueafk+aIkOm7keiJsu+8jOS5i+WQjumHjeaWsOi/m+WFpeeul+azle+8iOaIkeS7rOWPquiuqOiuuuW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueW3puWtqeWtkOaXtueahOaDheWGte+8ieOAguatpOWPmOaNouWQjuWOn+e6oum7keagkeaAp+i0qDXkuI3lj5jvvIzogIzmiorpl67popjovazljJbkuLrlhYTlvJ/oioLngrnkuLrpu5HoibLnmoTmg4XlhrUo5rOo77ya5Y+Y5YyW5YmN77yM5Y6f5pys5bCx5pyq6L+d5Y+N5oCn6LSoNe+8jOWPquaYr+S4uuS6huaKiumXrumimOi9rOWMluS4uuWFhOW8n+iKgueCueS4uum7keiJsueahOaDheWGtSnjgIJcclxuXHJcbiDliKDpmaTkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K55piv6buR5Yqg6buR5LiU5YWE5byf5piv6buR6Imy5LiU5YWE5byf6IqC54K555qE5Lik5Liq5a2Q6IqC54K55YWo5Li66buR6Imy44CCXHJcbiDop6Pms5XvvJrmiorlvZPliY3oioLngrnlkozlhYTlvJ/oioLngrnkuK3mir3lj5bkuIDph43pu5HoibLov73liqDliLDniLboioLngrnkuIrvvIzmiorniLboioLngrnlvZPmiJDmlrDnmoTlvZPliY3oioLngrnvvIzph43mlrDov5vlhaXnrpfms5XjgILvvIjmraTlj5jmjaLlkI7mgKfotKg15LiN5Y+Y77yJXHJcblxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1M++8muW9k+WJjeiKgueCueminOiJsuaYr+m7kSvpu5HvvIzlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzlhYTlvJ/nmoTlt6blrZDmmK/nuqLoibLvvIzlj7PlrZDmmK/pu5HoibLjgIJcclxuIOino+azle+8muaKiuWFhOW8n+e7k+eCueafk+e6ou+8jOWFhOW8n+W3puWtkOiKgueCueafk+m7ke+8jOS5i+WQjuWGjeWcqOWFhOW8n+iKgueCueS4uuaUr+eCueino+WPs+aXi++8jOS5i+WQjumHjeaWsOi/m+WFpeeul+azleOAguatpOaYr+aKiuW9k+WJjeeahOaDheWGtei9rOWMluS4uuaDheWGtTTvvIzogIzmgKfotKg15b6X5Lul5L+d5oyBXHJcblxyXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1NO+8muW9k+WJjeiKgueCueminOiJsuaYr+m7kS3pu5HoibLvvIzlroPnmoTlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzkvYbmmK/lhYTlvJ/oioLngrnnmoTlj7PlrZDmmK/nuqLoibLvvIzlhYTlvJ/oioLngrnlt6blrZDnmoTpopzoibLku7vmhI/jgIJcclxuIOino+azle+8muaKiuWFhOW8n+iKgueCueafk+aIkOW9k+WJjeiKgueCueeItuiKgueCueeahOminOiJsu+8jOaKiuW9k+WJjeiKgueCueeItuiKgueCueafk+aIkOm7keiJsu+8jOWFhOW8n+iKgueCueWPs+WtkOafk+aIkOm7keiJsu+8jOS5i+WQjuS7peW9k+WJjeiKgueCueeahOeItuiKgueCueS4uuaUr+eCuei/m+ihjOW3puaXi++8jOatpOaXtueul+azlee7k+adn++8jOe6oum7keagkeaJgOacieaAp+i0qOiwg+aVtOato+ehrlxyXG5cclxuXHJcbiDmnIDlkI7lgLzlvpfkuIDmj5DnmoTmmK/kuIrov7DliKDpmaTkv67lpI3nmoTmg4XlhrUxfjTpg73lj6rmmK/moJHnmoTlsYDpg6jvvIzlubbpnZ7moJHnmoTmlbTkvZPlhajpg6jvvIzkuJTliKDpmaTkv67lpI3mg4XlhrUz44CBNOWcqOe7j+i/h+S4iumdoueahOiwg+aVtOWQju+8jOiwg+aVtOi/mOayoee7k+adnyzov5jlvpfnu6fnu63osIPmlbTnm7Toh7Pph43mlrDmgaLlpI3lubPooaFcclxuKi9cclxuaW1wb3J0IEJTVE5vZGUgZnJvbSAnLi9CaW5hcnlTb3J0ZWRUcmVlJztcclxuXHJcbmNvbnN0IFJFRCA9ICdyZWQnO1xyXG5jb25zdCBCTEFDSyA9ICdibGFjayc7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVkQmxhY2tOb2RlIGV4dGVuZHMgQlNUTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgLi4ucmVzdCl7XHJcbiAgICAgICAgc3VwZXIoZGF0YSwgLi4ucmVzdCk7XHJcblxyXG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IFJFRDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBSZWRCbGFja0xlYWYge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgdGhpcy5sZWZ0Q2hpbGQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmlnaHRDaGlsZCA9IHRoaXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFJlZEJsYWNrVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIC8vIOWTqOWFtVxyXG4gICAgICAgIHRoaXMubmlsID0gbmV3IFJlZEJsYWNrTGVhZigpO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMubmlsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57qi6buR5qCR55qE6YCS5b2S5p+l5om+566X5rOVXHJcbiAgICAgKiBAcGFyYW0gZGF0YVxyXG4gICAgICovXHJcbiAgICBmaW5kKGRhdGEpe1xyXG4gICAgICAgIGxldCB6ID0gdGhpcy5yb290O1xyXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gZmluZCh6LCBkYXRhKXtcclxuICAgICAgICAgICAgaWYoeiA9PSBtZS5uaWwgfHwgZGF0YSA9PT0gei5kYXRhKSByZXR1cm4gejtcclxuXHJcbiAgICAgICAgICAgIGlmKGRhdGEgPCB6LmRhdGEpIHJldHVybiBmaW5kKHoubGVmdENoaWxkLCBkYXRhKTtcclxuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmluZCh6LnJpZ2h0Q2hpbGQsIGRhdGEpO1xyXG4gICAgICAgIH0pKHosIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57qi6buR5qCR55qE5o+S5YWlXHJcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcclxuICAgICAqL1xyXG4gICAgYWRkKGRhdGEpe1xyXG4gICAgICAgIGxldCB6ID0gbmV3IFJlZEJsYWNrTm9kZShkYXRhKTtcclxuICAgICAgICB6LmxlZnRDaGlsZCA9IHRoaXMubmlsO1xyXG4gICAgICAgIHoucmlnaHRDaGlsZCA9IHRoaXMubmlsO1xyXG4gICAgICAgIGxldCB5ID0gdGhpcy5uaWw7XHJcbiAgICAgICAgbGV0IHggPSB0aGlzLnJvb3Q7XHJcblxyXG4gICAgICAgIC8vIOaJvuWIsOimgeaPkuWFpeS9jee9rueahOe7k+eCuXlcclxuICAgICAgICB3aGlsZSh4ICE9IHRoaXMubmlsKXtcclxuICAgICAgICAgICAgeSA9IHg7XHJcblxyXG4gICAgICAgICAgICBpZih6LmRhdGEgPCB4LmRhdGEpIHggPSB4LmxlZnRDaGlsZDtcclxuICAgICAgICAgICAgZWxzZSB4ID0geC5yaWdodENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgei5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICAvLyDlpoLmnpx55LiN5piv5qC557uT54K577yM5qC55o2u5aSn5bCP5o+S5YWl5Yiw5bem5oiW5Y+z5a2Q5qCRXHJcbiAgICAgICAgaWYoeSAhPSB0aGlzLm5pbCkge1xyXG4gICAgICAgICAgICBpZih6LmRhdGEgPCB5LmRhdGEpIHkubGVmdENoaWxkID0gejtcclxuICAgICAgICAgICAgZWxzZSB5LnJpZ2h0Q2hpbGQgPSB6O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlkKbliJnmj5LlhaXliLDmoLnnu5PngrlcclxuICAgICAgICBlbHNlIHRoaXMucm9vdCA9IHogPT0gdGhpcy5uaWwgPyBudWxsIDogejtcclxuXHJcbiAgICAgICAgLy8g5o+S5YWl5L+u5aSN5pON5L2cXHJcbiAgICAgICAgdGhpcy5fYWRkRml4dXAoeik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmj5LlhaXnrpfms5Xkv67lpI1cclxuICAgICAqIEBwYXJhbSB7UmVkQmxhY2tOb2RlfSB6IOW+heaPkuWFpeeahOe7k+eCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2FkZEZpeHVwKHope1xyXG5cclxuICAgICAgICB3aGlsZSh6ICE9IHRoaXMucm9vdCAmJiB6LnBhcmVudC5jb2xvciA9PT0gUkVEKXtcclxuICAgICAgICAgICAgaWYoei5wYXJlbnQgPT0gei5wYXJlbnQucGFyZW50LmxlZnRDaGlsZClcclxuICAgICAgICAgICAgICAgIGxlZnRBZGRGaXh1cCh0aGlzLCB6KTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmlnaHRBZGRGaXh1cCh0aGlzLCB6KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOacgOWQju+8jOaKiuaguee7k+eCuea2guS4uum7keiJsu+8jOaVtOajtee6oum7keagkeS+v+mHjeaWsOaBouWkjeS6huW5s+ihoVxyXG4gICAgICAgIHRoaXMucm9vdC5jb2xvciA9IEJMQUNLO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57qi6buR5qCR55qE5Yig6Zmk566X5rOVXHJcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0geiDlvoXliKDpmaTnu5PngrlcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTm9kZSh6KXtcclxuICAgICAgICBsZXQgeCwgeTtcclxuXHJcbiAgICAgICAgLy8g5om+5Yiw5b6F5Yig6Zmk57uT54K555qE54i257uT54K55oiW55u46YK75b6F5pu/5o2i57uT54K5XHJcbiAgICAgICAgaWYoei5sZWZ0Q2hpbGQgPT0gdGhpcy5uaWwgfHwgei5yaWdodENoaWxkID09IHRoaXMubmlsKVxyXG4gICAgICAgICAgICB5ID0gejtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHkgPSB0aGlzLnN1Y2Nlc3Nvcih6KTtcclxuXHJcbiAgICAgICAgaWYoeS5sZWZ0Q2hpbGQgIT0gdGhpcy5uaWwpIHggPSB5LmxlZnRDaGlsZDtcclxuICAgICAgICBlbHNlIHggPSB5LnJpZ2h0Q2hpbGQ7XHJcblxyXG4gICAgICAgIHgucGFyZW50ID0geS5wYXJlbnQ7XHJcblxyXG4gICAgICAgIC8vIOWIoOmZpOaTjeS9nFxyXG4gICAgICAgIGlmKHkucGFyZW50ID09IHRoaXMubmlsKSB0aGlzLnJvb3QgPSB4O1xyXG4gICAgICAgIGVsc2UgaWYoeSA9PSB5LnBhcmVudC5sZWZ0Q2hpbGQpIHkucGFyZW50LmxlZnRDaGlsZCA9IHg7XHJcbiAgICAgICAgZWxzZSB5LnBhcmVudC5yaWdodENoaWxkID0geDtcclxuXHJcbiAgICAgICAgaWYoeSAhPSB6KSB6LmRhdGEgPSB5LmRhdGE7XHJcblxyXG4gICAgICAgIC8vIOWIoOmZpOS/ruWkjVxyXG4gICAgICAgIGlmKHkuY29sb3IgPT09IEJMQUNLKSB0aGlzLl9yZW1vdmVGaXh1cCh4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDnrpfms5Xlr7zorrrkuIrnmoTliKDpmaTnu5PngrlcclxuICAgIHJlbW92ZU5vZGUyKHope1xyXG4gICAgICAgIGxldCB5ID0gejtcclxuICAgICAgICBsZXQgb3JpZ2luYWxZQ29sb3IgPSB5LmNvbG9yO1xyXG4gICAgICAgIGxldCB4O1xyXG5cclxuICAgICAgICBpZih6LmxlZnRDaGlsZCA9PSB0aGlzLm5pbCkge1xyXG4gICAgICAgICAgICB4ID0gei5yaWdodENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc3BsYW50KHosIHoucmlnaHRDaGlsZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHoucmlnaHRDaGlsZCA9PSB0aGlzLm5pbCkge1xyXG4gICAgICAgICAgICB4ID0gei5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeiwgei5sZWZ0Q2hpbGQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLm1pbih6LnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgICAgICBvcmlnaW5hbFlDb2xvciA9IHkuY29sb3I7XHJcbiAgICAgICAgICAgIHggPSB5LnJpZ2h0Q2hpbGQ7XHJcblxyXG4gICAgICAgICAgICBpZih5LnBhcmVudCA9PSB6KSB4LnBhcmVudCA9IHk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwbGFudCh5LCB5LnJpZ2h0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgeS5yaWdodENoaWxkID0gei5yaWdodENoaWxkO1xyXG4gICAgICAgICAgICAgICAgeS5yaWdodENoaWxkLnBhcmVudCA9IHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeiwgeSk7XHJcbiAgICAgICAgICAgIHkubGVmdENoaWxkID0gei5sZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIHkubGVmdENoaWxkLnBhcmVudCA9IHk7XHJcbiAgICAgICAgICAgIHkuY29sb3IgPSB6LmNvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYob3JpZ2luYWxZQ29sb3IgPT09IEJMQUNLKSB0aGlzLl9yZW1vdmVGaXh1cCh4KTtcclxuICAgIH1cclxuXHJcbiAgICBfdHJhbnNwbGFudCh1LCB2KXtcclxuICAgICAgICBpZih1LnBhcmVudCA9PSB0aGlzLm5pbCkgdGhpcy5yb290ID0gdjtcclxuICAgICAgICBlbHNlIGlmKHUgPT0gdS5wYXJlbnQubGVmdENoaWxkKSB1LnBhcmVudC5sZWZ0Q2hpbGQgPSB2O1xyXG4gICAgICAgIGVsc2UgdS5wYXJlbnQucmlnaHRDaGlsZCA9IHY7XHJcblxyXG4gICAgICAgIHYucGFyZW50ID0gdS5wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTkv67lpI1cclxuICAgICAqIEBwYXJhbSB7UmVkQmxhY2tOb2RlfSB6XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlRml4dXAoeil7XHJcbiAgICAgICAgd2hpbGUoeiAhPT0gdGhpcy5yb290ICYmIHouY29sb3IgPT09IEJMQUNLKXtcclxuICAgICAgICAgICAgaWYoeiA9PSB6LnBhcmVudC5sZWZ0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICBsZWZ0UmVtb3ZlRml4dXAodGhpcywgeik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJpZ2h0UmVtb3ZlRml4dXAodGhpcywgeik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6LmNvbG9yID0gQkxBQ0s7XHJcbiAgICB9XHJcblxyXG4gICAgc3VjY2Vzc29yKHope1xyXG4gICAgICAgIGlmKHoucmlnaHRDaGlsZCAhPSB0aGlzLm5pbCkgcmV0dXJuIHRoaXMubWluKHoucmlnaHRDaGlsZCk7XHJcblxyXG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQ7XHJcblxyXG4gICAgICAgIHdoaWxlKHkgIT0gdGhpcy5uaWwgJiYgeiA9PSB5LnJpZ2h0Q2hpbGQpe1xyXG4gICAgICAgICAgICB6ID0geTtcclxuICAgICAgICAgICAgeSA9IHkucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgbWluKHope1xyXG4gICAgICAgIHdoaWxlKHoubGVmdENoaWxkICE9IHRoaXMubmlsKXtcclxuICAgICAgICAgICAgeiA9IHoubGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHo7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5rZXnlgLzliKDpmaTnu5PngrlcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSl7XHJcbiAgICAgICAgbGV0IHogPSB0aGlzLmZpbmQoa2V5KTtcclxuXHJcbiAgICAgICAgaWYoeiA9PSB0aGlzLm5pbCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVOb2RlKHopO1xyXG4gICAgfVxyXG59XHJcblxyXG5SZWRCbGFja1RyZWUucHJvdG90eXBlLl9yb3RhdGVMZWZ0ID0gcm90YXRlKCdsZWZ0Jyk7XHJcblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gcm90YXRlKCdyaWdodCcpO1xyXG5cclxuZnVuY3Rpb24gcm90YXRlKGRpcil7XHJcbiAgICBsZXQgYzEsIGMyO1xyXG4gICAgaWYoIGRpciA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgYzEgPSAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYzEgPSAnbGVmdENoaWxkJztcclxuICAgICAgICBjMiA9ICdyaWdodENoaWxkJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oeCl7XHJcbiAgICAgICAgbGV0IHkgPSB4W2MxXTtcclxuICAgICAgICB4W2MxXSA9IHlbYzJdO1xyXG5cclxuICAgICAgICBpZih5W2MyXSAhPSB0aGlzLm5pbCkgeVtjMl0ucGFyZW50ID0geDtcclxuICAgICAgICB5LnBhcmVudCA9IHgucGFyZW50O1xyXG5cclxuICAgICAgICBpZih4LnBhcmVudCA9PSB0aGlzLm5pbCkgdGhpcy5yb290ID0geTtcclxuICAgICAgICBlbHNlIGlmKHggPT0geC5wYXJlbnRbYzJdKSB4LnBhcmVudFtjMl0gPSB5O1xyXG4gICAgICAgIGVsc2UgeC5wYXJlbnRbYzFdID0geTtcclxuXHJcbiAgICAgICAgeVtjMl0gPSB4O1xyXG4gICAgICAgIHgucGFyZW50ID0geTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEZpeHVwKGRpcil7XHJcbiAgICBsZXQgYzEsIGMyLCByb3RhdGUxLCByb3RhdGUyO1xyXG4gICAgaWYoIGRpciA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgYzEgPSAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcclxuICAgICAgICByb3RhdGUxID0gJ19yb3RhdGVMZWZ0JztcclxuICAgICAgICByb3RhdGUyID0gJ19yb3RhdGVSaWdodCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XHJcbiAgICAgICAgYzIgPSAncmlnaHRDaGlsZCc7XHJcbiAgICAgICAgcm90YXRlMSA9ICdfcm90YXRlUmlnaHQnO1xyXG4gICAgICAgIHJvdGF0ZTIgPSAnX3JvdGF0ZUxlZnQnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbih0cmVlLCB6KXtcclxuICAgICAgICAvLyBub3RlOiDms6jph4rku6Xlt6bovrnkuLrmg4XlhrVcclxuXHJcbiAgICAgICAgLy8g5Y+U57uT54K5XHJcbiAgICAgICAgbGV0IHkgPSB6LnBhcmVudC5wYXJlbnRbYzFdO1xyXG5cclxuICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUx77ya5aaC5p6c5b2T5YmN57uT54K555qE54i257uT54K55piv57qi6Imy5LiU56WW54i257uT54K555qE5Y+m5LiA5Liq5a2Q57uT54K577yI5Y+U57uT54K577yJ5piv57qi6ImyXHJcbiAgICAgICAgLy8g5bCG5b2T5YmN6IqC54K555qE54i26IqC54K55ZKM5Y+U5Y+U6IqC54K55raC6buR77yM56WW54i257uT54K55raC57qi77yM5oqK5b2T5YmN57uT54K55oyH5ZCR56WW54i26IqC54K577yM5LuO5paw55qE5b2T5YmN6IqC54K56YeN5paw5byA5aeL566X5rOV44CCXHJcbiAgICAgICAgaWYoeS5jb2xvciA9PT0gUkVEKSB7XHJcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHkuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgei5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICB6ID0gei5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOaPkuWFpeS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnnmoTniLboioLngrnmmK/nuqLoibIs5Y+U6IqC54K55piv6buR6Imy77yM5b2T5YmN6IqC54K55piv5YW254i26IqC54K555qE5Y+z5a2QXHJcbiAgICAgICAgICAgIC8vIOino+WGs+WvueetluaYr++8muW9k+WJjeiKgueCueeahOeItuiKgueCueWBmuS4uuaWsOeahOW9k+WJjeiKgueCue+8jOS7peaWsOW9k+WJjeiKgueCueS4uuaUr+eCueW3puaXi+OAglxyXG4gICAgICAgICAgICAvLyDku47ogIzmj5LlhaXkv67lpI3mg4XlhrUy6L2s5o2i5oiQ5LqG5o+S5YWl5L+u5aSN5oOF5Ya1M+OAglxyXG4gICAgICAgICAgICBpZih6ID09PSB6LnBhcmVudFtjMV0pIHtcclxuICAgICAgICAgICAgICAgIHogPSB6LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRyZWVbcm90YXRlMV0oeik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOaPkuWFpeS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnnmoTniLboioLngrnmmK/nuqLoibIs5Y+U6IqC54K55piv6buR6Imy77yM5b2T5YmN6IqC54K55piv5YW254i26IqC54K555qE5bem5a2QXHJcbiAgICAgICAgICAgIC8vIOino+WGs+WvueetluaYr++8mueItuiKgueCueWPmOS4uum7keiJsu+8jOellueItuiKgueCueWPmOS4uue6ouiJsu+8jOWcqOellueItuiKgueCueS4uuaUr+eCueWPs+aXi++8jFxyXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICB6LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgIHRyZWVbcm90YXRlMl0oei5wYXJlbnQucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5sZXQgbGVmdEFkZEZpeHVwID0gYWRkRml4dXAoJ2xlZnQnKTtcclxubGV0IHJpZ2h0QWRkRml4dXAgPSBhZGRGaXh1cCgncmlnaHQnKTtcclxubGV0IGxlZnRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdsZWZ0Jyk7XHJcbmxldCByaWdodFJlbW92ZUZpeHVwID0gcmVtb3ZlRml4dXAoJ3JpZ2h0Jyk7XHJcblxyXG5mdW5jdGlvbiByZW1vdmVGaXh1cChkaXIpe1xyXG4gICAgbGV0IGMxLCBjMiwgcjEsIHIyO1xyXG4gICAgaWYoZGlyID09PSAnbGVmdCcpIHtcclxuICAgICAgICBjMSA9ICdyaWdodENoaWxkJztcclxuICAgICAgICBjMiA9ICdsZWZ0Q2hpbGQnO1xyXG4gICAgICAgIHIxID0gJ19yb3RhdGVMZWZ0JztcclxuICAgICAgICByMiA9ICdfcm90YXRlUmlnaHQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjMSA9ICdsZWZ0Q2hpbGQnO1xyXG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xyXG4gICAgICAgIHIxID0gJ19yb3RhdGVSaWdodCc7XHJcbiAgICAgICAgcjIgPSAnX3JvdGF0ZUxlZnQnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbih0cmVlLCB6KXtcclxuICAgICAgICAvLyBub3RlOiDms6jph4rku6Xlt6bovrnkuLrmg4XlhrVcclxuXHJcbiAgICAgICAgLy8g5Y+U57uT54K5XHJcbiAgICAgICAgbGV0IHcgPSB6LnBhcmVudFtjMV07XHJcblxyXG4gICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTHvvJrlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5YWE5byf6IqC54K55Li657qi6ImyKOatpOaXtueItuiKgueCueWSjOWFhOW8n+iKgueCueeahOWtkOiKgueCueWIhuS4uum7kSnjgIJcclxuICAgICAgICAvLyDop6Pms5XvvJrmiorniLboioLngrnmn5PmiJDnuqLoibLvvIzmiorlhYTlvJ/nu5Pngrnmn5PmiJDpu5HoibLvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5VcclxuICAgICAgICBpZih3LmNvbG9yID09PSBSRUQpe1xyXG4gICAgICAgICAgICB3LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICB0cmVlW3IxXSh6LnBhcmVudCk7XHJcbiAgICAgICAgICAgIHcgPSB6LnBhcmVudFtjMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrUy77ya5b2T5YmN6IqC54K55piv6buR5Yqg6buR5LiU5YWE5byf5piv6buR6Imy5LiU5YWE5byf6IqC54K555qE5Lik5Liq5a2Q6IqC54K55YWo5Li66buR6Imy44CCXHJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK5b2T5YmN6IqC54K55ZKM5YWE5byf6IqC54K55Lit5oq95Y+W5LiA6YeN6buR6Imy6L+95Yqg5Yiw54i26IqC54K55LiK77yM5oqK54i26IqC54K55b2T5oiQ5paw55qE5b2T5YmN6IqC54K577yM6YeN5paw6L+b5YWl566X5rOV44CCXHJcbiAgICAgICAgaWYod1tjMl0uY29sb3IgPT09IEJMQUNLICYmIHdbYzFdLmNvbG9yID09PSBCTEFDSyl7XHJcbiAgICAgICAgICAgIHcuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgIHogPSB6LnBhcmVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRK+m7ke+8jOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOWFhOW8n+eahOW3puWtkOaYr+e6ouiJsu+8jOWPs+WtkOaYr+m7keiJsuOAglxyXG4gICAgICAgICAgICAvLyDop6Pms5XvvJrmiorlhYTlvJ/nu5Pngrnmn5PnuqLvvIzlhYTlvJ/lt6blrZDoioLngrnmn5Ppu5HvvIzkuYvlkI7lho3lnKjlhYTlvJ/oioLngrnkuLrmlK/ngrnop6Plj7Pml4vvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5XjgIJcclxuICAgICAgICAgICAgaWYod1tjMV0uY29sb3IgPT09IEJMQUNLKSB7XHJcbiAgICAgICAgICAgICAgICB3W2MyXS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgdy5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgIHRyZWVbcjJdKHcpO1xyXG4gICAgICAgICAgICAgICAgdyA9IHoucGFyZW50W2MxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1NO+8muW9k+WJjeiKgueCueminOiJsuaYr+m7kS3pu5HoibLvvIzlroPnmoTlhYTlvJ/oioLngrnmmK/pu5HoibLvvIzkvYbmmK/lhYTlvJ/oioLngrnnmoTlj7PlrZDmmK/nuqLoibLvvIzlhYTlvJ/oioLngrnlt6blrZDnmoTpopzoibLku7vmhI/jgIJcclxuICAgICAgICAgICAgLy8g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXHJcbiAgICAgICAgICAgIHcuY29sb3IgPSB6LnBhcmVudC5jb2xvcjtcclxuICAgICAgICAgICAgei5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgd1tjMV0uY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgdHJlZVtyMV0oei5wYXJlbnQpO1xyXG4gICAgICAgICAgICB6ID0gdHJlZS5yb290O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5sZXQgdGVzdCA9IG5ldyBSZWRCbGFja1RyZWUoKTtcclxudGVzdC5hZGQoMTMpO1xyXG50ZXN0LmFkZCg4KTtcclxudGVzdC5hZGQoMTcpO1xyXG50ZXN0LmFkZCgxKTtcclxudGVzdC5hZGQoNik7XHJcbnRlc3QuYWRkKDExKTtcclxudGVzdC5hZGQoMTUpO1xyXG50ZXN0LmFkZCgyMik7XHJcbnRlc3QuYWRkKDI1KTtcclxudGVzdC5hZGQoMjcpO1xyXG5cclxudGVzdC5yZW1vdmUoMTMpO1xyXG50ZXN0LnJlbW92ZSg4KTtcclxudGVzdC5yZW1vdmUoMTcpO1xyXG50ZXN0LnJlbW92ZSgxKTtcclxudGVzdC5yZW1vdmUoNik7XHJcbnRlc3QucmVtb3ZlKDExKTtcclxudGVzdC5yZW1vdmUoMTUpO1xyXG50ZXN0LnJlbW92ZSgyMik7XHJcbnRlc3QucmVtb3ZlKDI1KTtcclxudGVzdC5yZW1vdmUoMjcpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TZWFyY2gvUmVkQmxhY2tUcmVlLmpzXG4gKiovIiwiLypcclxuIOmdmeaAgeasoeS8mOafpeaJvuagkVxyXG5cclxuIOmAguWQiOWQhOiusOW9leeahOafpeaJvuamgueOh+S4jeetieeahOaDheWGtVxyXG5cclxuIOafpeaJvuaViOeOh+acgOmrmOWNs+W5s+Wdh+afpeaJvumVv+W6puacgOWwj++8jOaIkeS7rOWPr+S7pee7meWHuuacieW6j+ihqOWcqOmdnuetieamgueOh+aDheWGteS4i+W6lOmBteW+queahOS4pOS4quWOn+WIme+8mlxyXG4gMeOAgeacgOWFiOiuv+mXrueahOe7k+eCueW6lOaYr+iuv+mXruamgueOh+acgOWkp+eahOe7k+eCue+8m1xyXG4gMuOAgeavj+asoeiuv+mXruW6lOS9v+e7k+eCueS4pOi+ueWwmuacquiuv+mXrueahOe7k+eCueeahOiiq+iuv+amgueOh+S5i+WSjOWwveWPr+iDveebuOetieOAglxyXG5cclxuXHJcbiDov5nkuKTkuKrljp/liJnlj6/nlKjkuIDlj6Xor53mnaXooajnpLrvvIzljbPliKTlrprmoJHkuLrluKbmnYPlhoXot6/lvoTplb/luqbkuYvlkozmnIDlsI/nmoTkuozlj4nmoJHvvIzkuqbljbPvvJpQSCA9IOKIkXdpaGkgIOacgOWwj++8jOWFtuS4rSBuIOS4uuacieW6j+ihqOmVv+W6pu+8jGhpIOS4uuesrCBpIOS4que7k+eCueWcqOWIpOWumuagkeS4iueahOWxguasoeaVsO+8jHdpID0gY3Bp77yMYyDkuLrmn5DkuKrluLjmlbDvvIxwaSDkuLrnrKwgaSDkuKrnu5PngrnnmoTmn6Xmib7mpoLnjofjgIJcclxuXHJcblxyXG4g6L+Z5qC355qE5qCR56ew5Li66Z2Z5oCB5pyA5LyY5p+l5om+5qCR77yIc3RhdGljIG9wdGltYWwgc2VhcmNoIHRyZWXvvInvvIzmnoTpgKDov5nmoLfkuIDmo7XmoJHnmoTml7bpl7Tku6Pku7flpKrlpKfvvIzkuqbljbPml7bpl7TlpI3mnYLluqblvojlpKfvvIzlm6DmraTmiJHku6zpgJrluLjmmK/mnoTpgKDmrKHkvJjmn6Xmib7moJHvvIhuZWFybHkgb3B0aW1hbCBzZWFyY2ggdHJlZe+8ie+8jOaehOmAoOWug+eahOaXtumXtOS7o+S7t+i/nOi/nOS9juS6juaehOmAoOacgOS8mOafpeaJvuagke+8jOS9huafpeaJvuaAp+iDveWPquavlOacgOS8mOafpeaJvuagkeW3rjElfjIl77yM5b6I5bCR5beuMyXku6XkuIrjgIJcclxuXHJcbiDmrKHkvJjmn6Xmib7moJHnmoTmnoTpgKDvvJpcclxuXHJcbiDorr7mnInluo/ooajmr4/kuKrorrDlvZXnmoTmnYPlgLzkuLogd2wsd2wrMSzigKYsd2jvvIznrKzkuIDkuKrlupTorr/pl67nmoTnu5Pngrnlj7fkuLogaSDvvIzliJnmnInvvJpcclxuIM6UcGkgPSAgIOKIkXdqIC0g4oiRd2ogICDmnIDlsI/vvIzljbMgzpRwaSA9IE1pbiB7zpRwaiB9XHJcbiDlho3liIbliKvlr7kge3JsLHJsKzEs4oCmLHJpLTF9IOWSjCB7cmkrMSxyaSsyLOKApixyaH0g5YiG5Yir5p6E6YCg5qyh5LyY5p+l5om+5qCRXHJcbiAqL1xyXG5pbXBvcnQgeyBCaW5hcnlUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcclxuXHJcbi8qKlxyXG4gKiDnlLHmnInluo/ooahzVGFibGVbbG93Li5oaWdoXeWPiuWFtue0r+iuoeadg+WAvOihqHdlaWdodHPpgJLlvZLmnoTpgKDmrKHkvJjmn6Xmib7moJFcclxuICogQHBhcmFtIHtCaW5hcnlUcmVlfSB0cmVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNUYWJsZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzV2VpZ2h0c1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWNvbmRPcHRpbWFsKHRyZWUsIHNUYWJsZSwgc1dlaWdodHMsIGxvdywgaGlnaCkge1xyXG4gICAgbGV0IGkgPSBsb3c7XHJcbiAgICBsZXQgbWluID0gTWF0aC5hYnMoc1dlaWdodHNbaGlnaF0gLSBzV2VpZ2h0c1tsb3ddKTtcclxuICAgIGxldCBkdyA9IHNXZWlnaHRzW2hpZ2hdICsgKHNXZWlnaHRzW2xvdyAtIDFdIHx8IDApO1xyXG5cclxuICAgIC8vIOmAieaLqeacgOWwj+eahOKWs1Bp5YC8XHJcbiAgICBmb3IgKGxldCBqID0gbG93ICsgMTsgaiA8PSBoaWdoOyArK2opIHtcclxuICAgICAgICBsZXQgdCA9IE1hdGguYWJzKGR3IC0gc1dlaWdodHNbal0gLSBzV2VpZ2h0c1tqIC0gMV0pO1xyXG4gICAgICAgIGlmICh0IDwgbWluKSB7XHJcbiAgICAgICAgICAgIGkgPSBqO1xyXG4gICAgICAgICAgICBtaW4gPSB0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDosIPmlbTmoJHmoLnmnYPvvIzpgInmi6npgrvov5HmnYPlgLzovoPlpKfnmoTlhbPplK7lrZdcclxuICAgIGxldCBhID0gMCwgYiwgYyA9IDA7XHJcbiAgICBpZiAoaSAtIDEgPj0gbG93KSAgYiA9IHNXZWlnaHRzW2ldIC0gc1dlaWdodHNbaSAtIDFdO1xyXG4gICAgaWYgKGkgLSAyID49IGxvdykgYSA9IHNXZWlnaHRzW2kgLSAxXSAtIHNXZWlnaHRzW2kgLSAyXTtcclxuICAgIGlmIChpICsgMSA8IGhpZ2gpIGMgPSBzV2VpZ2h0c1tpICsgMV0gLSBzV2VpZ2h0c1tpXTtcclxuICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAoYSA+IGMgJiYgYSA+IGIpIC0taTtcclxuICAgICAgICBlbHNlIGlmIChhIDwgYyAmJiBjID4gYikgICsraTtcclxuICAgIH1cclxuXHJcbiAgICB0cmVlLmRhdGEgPSBzVGFibGVbaV07XHJcbiAgICAvL+W3puWtkOagkVxyXG4gICAgaWYgKGkgPT09IGxvdykgdHJlZS5sZWZ0Q2hpbGQgPSBudWxsO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJlZS5sZWZ0Q2hpbGQgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgIHNlY29uZE9wdGltYWwodHJlZS5sZWZ0Q2hpbGQsIHNUYWJsZSwgc1dlaWdodHMsIGxvdywgaSAtIDEpO1xyXG4gICAgfVxyXG4gICAgLy8g5Y+z5a2Q5qCRXHJcbiAgICBpZiAoaSA9PT0gaGlnaCkgdHJlZS5yaWdodENoaWxkID0gbnVsbDtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRyZWUucmlnaHRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XHJcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLnJpZ2h0Q2hpbGQsIHNUYWJsZSwgc1dlaWdodHMsIGkgKyAxLCBoaWdoKTtcclxuICAgIH1cclxufVxyXG5cclxubGV0IHRyZWUgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG5zZWNvbmRPcHRpbWFsKHRyZWUsIFsnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knXSwgWzEsIDIsIDQsIDksIDEyLCAxNiwgMjAsIDIzLCAyOF0sIDAsIDgpO1xyXG5jb25zb2xlLmxvZyh0cmVlKTtcclxuXHJcblxyXG4vKipcclxuICog55Sx5pyJ5bqP6KGo5p6E6YCg5LiA5qO15qyh5LyY5p+l5om+5qCRXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmog5pyJ5bqP6KGo77yM5pWw5o2u5YWD57Sg5ZCr5pyJ5p2D5Z+fd2VpZ2h0XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTT1NUcmVlKG9iaikge1xyXG4gICAgbGV0IHRyZWU7XHJcbiAgICBpZiAob2JqLmVsZW1zLmxlbmd0aCA9PT0gMCkgdHJlZSA9IG51bGw7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyDmsYLntK/orqHmnYPlgLzooahcclxuICAgICAgICBsZXQgc3cgPSBmaW5kU1cob2JqLndlaWdodHMpO1xyXG4gICAgICAgIHRyZWUgPSBuZXcgQmluYXJ5VHJlZSgpO1xyXG4gICAgICAgIHNlY29uZE9wdGltYWwodHJlZSwgb2JqLmVsZW1zLCBzdywgMCwgb2JqLmVsZW1zLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kU1coc1RhYmxlKSB7XHJcbiAgICBsZXQgc3cgPSBbc1RhYmxlWzBdXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNUYWJsZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHN3W2ldID0gc3dbaSAtIDFdICsgc1RhYmxlW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdztcclxufVxyXG5cclxubGV0IHNvc1RyZWUgPSBjcmVhdGVTT1NUcmVlKHtcclxuICAgIGVsZW1zOiBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRSddLFxyXG4gICAgd2VpZ2h0czogWzEsIDMwLCAyLCAyOSwgM11cclxufSk7XHJcbnNvc1RyZWUuaW5PcmRlclJlY3Vyc2l2ZShmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGNvbnNvbGUubG9nKCdpbk9yZGVyOiAnICsgdmFsdWUpO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL1NPU1RyZWUuanNcbiAqKi8iLCIvKlxyXG4gRmlib25hY2Np5p+l5om+XHJcblxyXG4gRmlib25hY2Np5p+l5om+5pa55rOV5piv5qC55o2uRmlib25hY2Np5pWw5YiX55qE54m554K55a+55p+l5om+6KGo6L+b6KGM5YiG5Ymy44CCRmlib25hY2Np5pWw5YiX55qE5a6a5LmJ5piv77yaXHJcbiBGKDApPTDvvIxGKDEpPTHvvIxGKGopPUYoai0xKStGKGotMikg44CCXHJcblxyXG4gMSAg5p+l5om+5oCd5oOzXHJcbiDorr7mn6Xmib7ooajkuK3nmoTorrDlvZXmlbDmr5Tmn5DkuKpGaWJvbmFjY2nmlbDlsI8x77yM5Y2z6K6+bj1GKGopLTHjgILnlKhMb3fjgIFIaWdo5ZKMTWlk6KGo56S65b6F5p+l5om+5Yy66Ze055qE5LiL55WM44CB5LiK55WM5ZKM5YiG5Ymy5L2N572u77yM5Yid5YC85Li6TG93PTDvvIxIaWdoPW4gLSAx44CCXHJcbiDikbQgICDlj5bliIblibLkvY3nva5NaWTvvJpNaWQ9RihqLTEpIO+8m1xyXG4g4pG1ICAg5q+U6L6D5YiG5Ymy5L2N572u6K6w5b2V55qE5YWz6ZSu5a2X5LiO57uZ5a6a55qES+WAvO+8mlxyXG4g4pGgIOebuOetie+8miDmn6Xmib7miJDlip/vvJtcclxuIOKRoSAg5aSn5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5YmN5Y2K5q61KOWMuumXtOmVv+W6puS4ukYoai0xKS0xKe+8jOS/ruaUueS4iueVjOaMh+mSiO+8miBIaWdoPU1pZC0x77yM6L2s4pG0IO+8m1xyXG4g4pGiICDlsI/kuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTlkI7ljYrmrrUo5Yy66Ze06ZW/5bqm5Li6RihqLTIpLTEp77yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m+ebtOWIsOi2iueVjChMb3c+SGlnaCnvvIzmn6Xmib7lpLHotKXjgIJcclxuXHJcbiAyICDnrpfms5Xlrp7njrBcclxuIOWcqOeul+azleWunueOsOaXtu+8jOS4uuS6humBv+WFjemikee5geiuoeeul0ZpYm9uYWNjaeaVsO+8jOWPr+eUqOS4pOS4quWPmOmHj2Yx5ZKMZjLkv53lrZjlvZPliY3nm7jpgrvnmoTkuKTkuKpGaWJvbmFjY2nmlbDvvIzov5nmoLflnKjku6XlkI7nmoTorqHnrpfkuK3lj6/ku6Xkvp3mrKHpgJLmjqjorqHnrpflh7rjgIJcclxuXHJcbiAzICDnrpfms5XliIbmnpBcclxuIOeUseeul+azleefpe+8jEZpYm9uYWNjaeafpeaJvuWcqOacgOWdj+aDheWGteS4i+aAp+iDveavlOaKmOWNiuafpeaJvuW3ru+8jOS9huW5s+Wdh+aQnOe0ouasoeaVsOWwkeS6juaKmOWNiuafpeaJvu+8jOiAjOS4lOaKmOWNiuafpeaJvuimgeaxguiusOW9leaMieWFs+mUruWtl+acieW6j++8m0ZpYm9uYWNjaeafpeaJvueahOS8mOeCueaYr+WIhuWJsuaXtuWPqumcgOi/m+ihjOWKoOOAgeWHj+i/kOeul+OAglxyXG5cclxuICovXHJcblxyXG5mdW5jdGlvbiBmaWIobikge1xyXG4gICAgaWYgKG4gPT09IDApIHJldHVybiAwO1xyXG4gICAgaWYgKG4gPT09IDEpIHJldHVybiAxO1xyXG4gICAgbGV0IGY7XHJcbiAgICBsZXQgZjAgPSAwO1xyXG4gICAgbGV0IGYxID0gMTtcclxuICAgIGZvciAobGV0IGkgPSAyOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgIGYgPSBmMCArIGYxO1xyXG4gICAgICAgIGYwID0gZjE7XHJcbiAgICAgICAgZjEgPSBmO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGY7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlnKjmnInluo/ooahTVOS4reeUqEZpYm9uYWNjaeaWueazleafpeaJvuWFs+mUruWtl+S4umtleeeahOiusOW9lVxyXG4gKiBAcGFyYW0gc1RhYmxlXHJcbiAqIEBwYXJhbSBrZXlcclxuICogQHBhcmFtIG5cclxuICovXHJcbmZ1bmN0aW9uIGZpYm9uYWNjaVNlYXJjaChzVGFibGUsIGtleSwgbiA9IHNUYWJsZS5sZW5ndGgpIHtcclxuICAgIGxldCBsb3cgPSAwO1xyXG4gICAgbGV0IGhpZ2ggPSBuIC0gMTtcclxuICAgIGxldCBmMSA9IGZpYihuKTtcclxuICAgIGxldCBmMiA9IGZpYihuIC0gMSk7XHJcblxyXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcbiAgICAgICAgbGV0IG1pZCA9IGxvdyArIGYxIC0gMTtcclxuICAgICAgICBpZiAoc1RhYmxlW21pZF0gPT09IGtleSkgcmV0dXJuIG1pZDtcclxuICAgICAgICBlbHNlIGlmIChrZXkgPCBzVGFibGVbbWlkXSkge1xyXG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcclxuICAgICAgICAgICAgZjIgPSBmMSAtIGYyO1xyXG4gICAgICAgICAgICBmMSA9IGYxIC0gZjI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgICAgICAgZjEgPSBmMSAtIGYyO1xyXG4gICAgICAgICAgICBmMiA9IGYyIC0gZjE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZygnZmlib25hY2NpU2VhcmNoOiAnKTtcclxuY29uc29sZS5sb2coZmlib25hY2NpU2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgNSkpOyAvLyA0XHJcbmNvbnNvbGUubG9nKGZpYm9uYWNjaVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaC5qc1xuICoqLyIsIi8qXHJcbiDpnZnmgIHmn6Xmib5cclxuXHJcbiDnur/mgKfooajmmK/mn6Xmib7ooajmnIDnroDljZXnmoTkuIDnp43nu4Tnu4fmlrnlvI9cclxuXHJcbiDpobrluo/mn6Xmib4oU2VxdWVudGlhbCBTZWFyY2gpXHJcbiAxICDmn6Xmib7mgJ3mg7NcclxuIOS7juihqOeahOS4gOerr+W8gOWni+mAkOS4quWwhuiusOW9leeahOWFs+mUruWtl+WSjOe7meWumkvlgLzov5vooYzmr5TovoPvvIzoi6Xmn5DkuKrorrDlvZXnmoTlhbPplK7lrZflkoznu5nlrppL5YC855u4562J77yM5p+l5om+5oiQ5Yqf77yb5ZCm5YiZ77yM6Iul5omr5o+P5a6M5pW05Liq6KGo77yM5LuN54S25rKh5pyJ5om+5Yiw55u45bqU55qE6K6w5b2V77yM5YiZ5p+l5om+5aSx6LSl44CCXHJcblxyXG4gMiAg566X5rOV5YiG5p6QXHJcbiDkuI3lpLHkuIDoiKzmgKfvvIzorr7mn6Xmib7mr4/kuKrorrDlvZXmiJDlip/nmoTmpoLnjofnm7jnrYnvvIzljbNQaT0xL27vvJvmn6Xmib7nrKxp5Liq5YWD57Sg5oiQ5Yqf55qE5q+U6L6D5qyh5pWwQ2k9bi1p77ybXHJcbiDil4Yg5p+l5om+5oiQ5Yqf5pe255qE5bmz5Z2H5p+l5om+6ZW/5bqmQVNM77yaKG4rMSkvMlxyXG4g4peGIOWMheWQq+afpeaJvuS4jeaIkOWKn+aXtu+8muafpeaJvuWksei0peeahOavlOi+g+asoeaVsOS4um7vvIzoi6XmiJDlip/kuI7kuI3miJDlip/nmoTmpoLnjofnm7jnrYnvvIzlr7nmr4/kuKrorrDlvZXnmoTmn6Xmib7mpoLnjofkuLpQaT0xLygybinvvIzliJnlubPlnYfmn6Xmib7plb/luqZBU0zvvJoz77yIbisx77yJLzRcclxuICovXHJcblxyXG5mdW5jdGlvbiBzZXF1ZW50aWFsU2VhcmNoKHNUYWJsZSwga2V5KSB7XHJcbiAgICBmb3IgKHZhciBpID0gc1RhYmxlLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiBzVGFibGVbaV0gIT09IGtleTsgLS1pKTtcclxuICAgIHJldHVybiBpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhzZXF1ZW50aWFsU2VhcmNoKFsxLCAyLCAzLCA0LCA1XSwgNikpOyAgLy8gLTFcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU2VhcmNoL3NlcXVlbnRpYWxTZWFyY2guanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS8yLzE4LlxyXG4gKi9cclxuXHJcbi8qXHJcbiDorqHmlbDmjpLluo9cclxuXHJcbiDorqHmlbDmjpLluo/vvIhDb3VudGluZyBzb3J077yJ5piv5LiA56eN56iz5a6a55qE57q/5oCn5pe26Ze05o6S5bqP566X5rOV44CC6K6h5pWw5o6S5bqP5L2/55So5LiA5Liq6aKd5aSW55qE5pWw57uEQ++8jOWFtuS4reesrGnkuKrlhYPntKDmmK/lvoXmjpLluo/mlbDnu4RB5Lit5YC8562J5LqOaeeahOWFg+e0oOeahOS4quaVsOOAgueEtuWQjuagueaNruaVsOe7hEPmnaXlsIZB5Lit55qE5YWD57Sg5o6S5Yiw5q2j56Gu55qE5L2N572u44CCXHJcblxyXG4g6K6h5pWw5o6S5bqP55qE54m55b6BXHJcblxyXG4g5b2T6L6T5YWl55qE5YWD57Sg5pivbuS4qjDliLBr5LmL6Ze055qE5pW05pWw5pe277yM5a6D55qE6L+Q6KGM5pe26Ze05pivzpgobiArIGsp44CC6K6h5pWw5o6S5bqP5LiN5piv5q+U6L6D5o6S5bqP77yM5o6S5bqP55qE6YCf5bqm5b+r5LqO5Lu75L2V5q+U6L6D5o6S5bqP566X5rOV44CCXHJcbiDnlLHkuo7nlKjmnaXorqHmlbDnmoTmlbDnu4RD55qE6ZW/5bqm5Y+W5Yaz5LqO5b6F5o6S5bqP5pWw57uE5Lit5pWw5o2u55qE6IyD5Zu077yI562J5LqO5b6F5o6S5bqP5pWw57uE55qE5pyA5aSn5YC85LiO5pyA5bCP5YC855qE5beu5Yqg5LiKMe+8ie+8jOi/meS9v+W+l+iuoeaVsOaOkuW6j+WvueS6juaVsOaNruiMg+WbtOW+iOWkp+eahOaVsOe7hO+8jOmcgOimgeWkp+mHj+aXtumXtOWSjOWGheWtmOOAguS+i+Wmgu+8muiuoeaVsOaOkuW6j+aYr+eUqOadpeaOkuW6jzDliLAxMDDkuYvpl7TnmoTmlbDlrZfnmoTmnIDlpb3nmoTnrpfms5XvvIzkvYbmmK/lroPkuI3pgILlkIjmjInlrZfmr43pobrluo/mjpLluo/kurrlkI3jgILkvYbmmK/vvIzorqHmlbDmjpLluo/lj6/ku6XnlKjlnKjln7rmlbDmjpLluo/kuK3nmoTnrpfms5XmnaXmjpLluo/mlbDmja7ojIPlm7TlvojlpKfnmoTmlbDnu4TjgIJcclxuIOmAmuS/l+WcsOeQhuino++8jOS+i+WmguaciTEw5Liq5bm06b6E5LiN5ZCM55qE5Lq677yM57uf6K6h5Ye65pyJOOS4quS6uueahOW5tOm+hOavlEHlsI/vvIzpgqNB55qE5bm06b6E5bCx5o6S5Zyo56ysOeS9je+8jOeUqOi/meS4quaWueazleWPr+S7peW+l+WIsOWFtuS7luavj+S4quS6uueahOS9jee9ru+8jOS5n+WwseaOkuWlveS6huW6j+OAguW9k+eEtu+8jOW5tOm+hOaciemHjeWkjeaXtumcgOimgeeJueauiuWkhOeQhu+8iOS/neivgeeos+WumuaAp++8ie+8jOi/meWwseaYr+S4uuS7gOS5iOacgOWQjuimgeWPjeWQkeWhq+WFheebruagh+aVsOe7hO+8jOS7peWPiuWwhuavj+S4quaVsOWtl+eahOe7n+iuoeWHj+WOuzHnmoTljp/lm6DjgILnrpfms5XnmoTmraXpqqTlpoLkuIvvvJpcclxuIDEu5om+5Ye65b6F5o6S5bqP55qE5pWw57uE5Lit5pyA5aSn5ZKM5pyA5bCP55qE5YWD57SgXHJcbiAyLue7n+iuoeaVsOe7hOS4reavj+S4quWAvOS4umnnmoTlhYPntKDlh7rnjrDnmoTmrKHmlbDvvIzlrZjlhaXmlbDnu4RD55qE56ysaemhuVxyXG4gMy7lr7nmiYDmnInnmoTorqHmlbDntK/liqDvvIjku45D5Lit55qE56ys5LiA5Liq5YWD57Sg5byA5aeL77yM5q+P5LiA6aG55ZKM5YmN5LiA6aG555u45Yqg77yJXHJcbiA0LuWPjeWQkeWhq+WFheebruagh+aVsOe7hO+8muWwhuavj+S4quWFg+e0oGnmlL7lnKjmlrDmlbDnu4TnmoTnrKxDKGkp6aG577yM5q+P5pS+5LiA5Liq5YWD57Sg5bCx5bCGQyhpKeWHj+WOuzFcclxuIFxyXG4g566A6KaB5YiG5p6Q77yaXHJcbiAxLuiuoeaVsOaOkuW6j+S7hemAguWQiOS6juWwj+iMg+WbtOeahOaVsOaNrui/m+ihjOaOkuW6j1xyXG4gMi7kuI3og73lr7nmta7ngrnmlbDov5vooYzmjpLluo9cclxuIDMu5pe26Ze05aSN5p2C5bqm5Li6IE8obilcclxuIDQu6K6h5pWw5o6S5bqP5piv56iz5a6a55qE77yI5o6S5bqP5ZCO5YC855u45ZCM55qE5YWD57Sg55u45a+55LqO5Y6f5YWI55qE5L2N572u5piv5LiN5Lya5Y+R55Sf5Y+Y5YyW55qE77yJXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWF4RWxlbShhcnIpe1xyXG4gICAgdmFyIG1heCA9IGFyclswXTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAxLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpXHJcbiAgICAgICAgaWYobWF4IDwgYXJyW2ldKSBtYXggPSBhcnJbaV07XHJcblxyXG4gICAgcmV0dXJuIG1heDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNxTGlzdCDopoHmjpLluo/nmoTmlbDnu4RcclxuICogQHBhcmFtIHtOdW1iZXJ9IGsg5pWw57uE5Lit5pyA5aSn55qE5YWD57Sg5YC8XHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIGNvdW50U29ydChzcUxpc3QsIGspe1xyXG4gICAgaWYoayA9PSBudWxsKSBrID0gbWF4RWxlbShzcUxpc3QpO1xyXG4gICAgdmFyIGxlbiA9IHNxTGlzdC5sZW5ndGg7XHJcbiAgICB2YXIgYyA9IFtdO1xyXG4gICAgdmFyIGIgPSBbXTtcclxuXHJcbiAgICAvLyDliJ3lp4vljJbovoXliqnmlbDnu4RcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPD0gazsgKytpKSBjW2ldID0gMDtcclxuICAgIC8vIOiuoeaVsOaVsOe7hEHkuK3lgLznrYnkuo5D5pWw57uE5LiL5qCH55qE5Liq5pWwXHJcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW47ICsraSkgY1tzcUxpc3RbaV1dKys7XHJcbiAgICAvLyDorqHmlbDmlbDnu4RB5Lit5YC85bCP5LqO562J5LqOQ+aVsOe7hOS4i+agh+eahOS4quaVsFxyXG4gICAgZm9yKGkgPSAxOyBpIDw9IGs7ICsraSkgY1tpXSArPSBjW2kgLSAxXTtcclxuICAgIGZvcihpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBiW2Nbc3FMaXN0W2ldXSAtIDFdID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIC0tY1tzcUxpc3RbaV1dO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcihpID0gMDsgaSA8IGxlbjsgKytpKSBzcUxpc3RbaV0gPSBiW2ldO1xyXG59XHJcbmV4cG9ydHMuY291bnRTb3J0ID0gY291bnRTb3J0O1xyXG5cclxudmFyIGFyciA9IFsxMDAsIDkzLCA5NywgOTIsIDk2LCA5OSwgOTIsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIsIDk1XTtcclxuY291bnRTb3J0KGFyciwgMTAwKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbiDln7rmlbDmjpLluo9cclxuXHJcbiDln7rmlbDmjpLluo/vvIjoi7Hor63vvJpSYWRpeCBzb3J077yJ5piv5LiA56eN6Z2e5q+U6L6D5Z6L5pW05pWw5o6S5bqP566X5rOV77yM5YW25Y6f55CG5piv5bCG5pW05pWw5oyJ5L2N5pWw5YiH5Ymy5oiQ5LiN5ZCM55qE5pWw5a2X77yM54S25ZCO5oyJ5q+P5Liq5L2N5pWw5YiG5Yir5q+U6L6D44CC55Sx5LqO5pW05pWw5Lmf5Y+v5Lul6KGo6L6+5a2X56ym5Liy77yI5q+U5aaC5ZCN5a2X5oiW5pel5pyf77yJ5ZKM54m55a6a5qC85byP55qE5rWu54K55pWw77yM5omA5Lul5Z+65pWw5o6S5bqP5Lmf5LiN5piv5Y+q6IO95L2/55So5LqO5pW05pWw44CC5Z+65pWw5o6S5bqP55qE5Y+R5piO5Y+v5Lul6L+95rqv5YiwMTg4N+W5tOi1q+WwlOabvMK35L2V5LmQ56S85Zyo5omT5a2U5Y2h54mH5Yi26KGo5py677yIVGFidWxhdGlvbiBNYWNoaW5l77yJ5LiK55qE6LSh54yu44CCXHJcbiDlroPmmK/ov5nmoLflrp7njrDnmoTvvJrlsIbmiYDmnInlvoXmr5TovoPmlbDlgLzvvIjmraPmlbTmlbDvvInnu5/kuIDkuLrlkIzmoLfnmoTmlbDkvY3plb/luqbvvIzmlbDkvY3ovoPnn63nmoTmlbDliY3pnaLooaXpm7bjgILnhLblkI7vvIzku47mnIDkvY7kvY3lvIDlp4vvvIzkvp3mrKHov5vooYzkuIDmrKHmjpLluo/jgILov5nmoLfku47mnIDkvY7kvY3mjpLluo/kuIDnm7TliLDmnIDpq5jkvY3mjpLluo/lrozmiJDku6XlkI7vvIzmlbDliJflsLHlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcclxuIOWfuuaVsOaOkuW6j+eahOaWueW8j+WPr+S7pemHh+eUqExTRO+8iExlYXN0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInmiJZNU0TvvIhNb3N0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInvvIxMU0TnmoTmjpLluo/mlrnlvI/nlLHplK7lgLznmoTmnIDlj7PovrnlvIDlp4vvvIzogIxNU0TliJnnm7jlj43vvIznlLHplK7lgLznmoTmnIDlt6bovrnlvIDlp4vjgIJcclxuXHJcbiDmlYjnjodcclxuXHJcbiDln7rmlbDmjpLluo/nmoTml7bpl7TlpI3mnYLluqbmmK9PKGvCt24p77yM5YW25LitbuaYr+aOkuW6j+WFg+e0oOS4quaVsO+8jGvmmK/mlbDlrZfkvY3mlbDjgILms6jmhI/ov5nkuI3mmK/or7Tov5nkuKrml7bpl7TlpI3mnYLluqbkuIDlrprkvJjkuo5PKG7Ct2xvZyhuKSnvvIxr55qE5aSn5bCP5Y+W5Yaz5LqO5pWw5a2X5L2N55qE6YCJ5oup77yI5q+U5aaC5q+U54m55L2N5pWw77yJ77yM5ZKM5b6F5o6S5bqP5pWw5o2u5omA5bGe5pWw5o2u57G75Z6L55qE5YWo6ZuG55qE5aSn5bCP77yba+WGs+WumuS6hui/m+ihjOWkmuWwkei9ruWkhOeQhu+8jOiAjG7mmK/mr4/ova7lpITnkIbnmoTmk43kvZzmlbDnm67jgIJcclxuIOS7peaOkuW6j27kuKrkuI3lkIzmlbTmlbDmnaXkuL7kvovvvIzlgYflrprov5nkupvmlbTmlbDku6VC5Li65bqV77yM6L+Z5qC35q+P5L2N5pWw6YO95pyJQuS4quS4jeWQjOeahOaVsOWtl++8jGsgPSBsb2dCKE4p77yMTuaYr+W+heaOkuW6j+aVsOaNruexu+Wei+WFqOmbhueahOWKv+OAguiZveeEtuaciULkuKrkuI3lkIznmoTmlbDlrZfvvIzpnIDopoFC5Liq5LiN5ZCM55qE5qG277yM5L2G5Zyo5q+P5LiA6L2u5aSE55CG5Lit77yM5Yik5pat5q+P5Liq5b6F5o6S5bqP5pWw5o2u6aG55Y+q6ZyA6KaB5LiA5qyh6K6h566X56Gu5a6a5a+55bqU5pWw5L2N55qE5YC877yM5Zug5q2k5Zyo5q+P5LiA6L2u5aSE55CG55qE5pe25YCZ6YO96ZyA6KaB5bmz5Z2HbuasoeaTjeS9nOadpeaKiuaVtOaVsOaUvuWIsOWQiOmAgueahOahtuS4reWOu++8jOaJgOS7peWwseacie+8mlxyXG4ga+e6puetieS6jmxvZ0IoTilcclxuIOaJgOS7pe+8jOWfuuaVsOaOkuW6j+eahOW5s+Wdh+aXtumXtFTlsLHmmK/vvJpcclxuIFTvvZ49IGxvZ0IoTinCt25cclxuIOWFtuS4reWJjeS4gOmhueaYr+S4gOS4quS4jui+k+WFpeaVsOaNruaXoOWFs+eahOW4uOaVsO+8jOW9k+eEtuivpemhueS4jeS4gOWumuWwj+S6jmxvZ25cclxuIOWmguaenOiAg+iZkeWSjOavlOi+g+aOkuW6j+i/m+ihjOWvueeFp++8jOWfuuaVsOaOkuW6j+eahOW9ouW8j+WkjeadguW6puiZveeEtuS4jeS4gOWumuabtOWwj++8jOS9hueUseS6juS4jei/m+ihjOavlOi+g++8jOWboOatpOWFtuWfuuacrOaTjeS9nOeahOS7o+S7t+i+g+Wwj++8jOiAjOS4lOWcqOmAguW9k+mAieaLqeeahELkuYvkuIvvvIxr5LiA6Iis5LiN5aSn5LqObG9nbu+8jOaJgOS7peWfuuaVsOaOkuW6j+S4gOiIrOimgeW/q+i/h+WfuuS6juavlOi+g+eahOaOkuW6j++8jOavlOWmguW/q+mAn+aOkuW6j+OAglxyXG5cclxuIOWBh+iuvuaIkeS7rOacieS4gOS6m+S6jOWFg+e7hChhLGIp77yM6KaB5a+55a6D5Lus6L+b6KGM5LulYeS4uummluimgeWFs+mUruWtl++8jGLnmoTmrKHopoHlhbPplK7lrZfnmoTmjpLluo/jgILmiJHku6zlj6/ku6XlhYjmiorlroPku6zlhYjmjInnhafpppbopoHlhbPplK7lrZfmjpLluo/vvIzliIbmiJDpppbopoHlhbPplK7lrZfnm7jlkIznmoToi6XlubLloIbjgILnhLblkI7vvIzlnKjmjInnhafmrKHopoHlhbPplK7lgLzliIbliKvlr7nmr4/kuIDloIbov5vooYzljZXni6zmjpLluo/jgILmnIDlkI7lho3miorov5nkupvloIbkuLLov57liLDkuIDotbfvvIzkvb/pppbopoHlhbPplK7lrZfovoPlsI/nmoTkuIDloIbmjpLlnKjkuIrpnaLjgILmjInov5nnp43mlrnlvI/nmoTln7rmlbDmjpLluo/np7DkuLpNU0QoTW9zdCBTaWduaWZpY2FudCBEaWdodCnmjpLluo/jgILnrKzkuoznp43mlrnlvI/mmK/ku47mnIDkvY7mnInmlYjlhbPplK7lrZflvIDlp4vmjpLluo/vvIznp7DkuLpMU0QoTGVhc3QgU2lnbmlmaWNhbnQgRGlnaHQp5o6S5bqP44CC6aaW5YWI5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn5qyh6KaB5YWz6ZSu5a2X5o6S5bqP77yM54S25ZCO5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn6aaW6KaB5YWz6ZSu5a2X5o6S5bqP44CC6KaB5rOo5oSP55qE5piv77yM5L2/55So55qE5o6S5bqP566X5rOV5b+F6aG75piv56iz5a6a55qE77yM5ZCm5YiZ5bCx5Lya5Y+W5raI5YmN5LiA5qyh5o6S5bqP55qE57uT5p6c44CC55Sx5LqO5LiN6ZyA6KaB5YiG5aCG5a+55q+P5aCG5Y2V54us5o6S5bqP77yMTFNE5pa55rOV5b6A5b6A5q+UTVNE566A5Y2V6ICM5byA6ZSA5bCP44CC5LiL5paH5LuL57uN55qE5pa55rOV5YWo6YOo5piv5Z+65LqOTFNE55qE44CCXHJcblxyXG4g5Z+65pWw5o6S5bqP55qE566A5Y2V5o+P6L+w5bCx5piv5bCG5pWw5a2X5ouG5YiG5Li65Liq5L2N5Y2B5L2N55m+5L2N77yM5q+P5Liq5L2N5L6d5qyh5o6S5bqP44CC5Zug5Li66L+Z5a+5566X5rOV56iz5a6a6KaB5rGC6auY77yM5omA5Lul5oiR5Lus5a+55pWw5L2N5o6S5bqP55So5Yiw5LiK5LiA5Liq5o6S5bqP5pa55rOV6K6h5pWw5o6S5bqP44CC5Zug5Li65Z+65pWw5o6S5bqP6KaB57uP6L+HZCAo5pWw5o2u6ZW/5bqmKeasoeaOkuW6j++8jCDmr4/mrKHkvb/nlKjorqHmlbDmjpLluo/vvIwg6K6h5pWw5o6S5bqP55qE5aSN5p2C5bqm5Li6IE9uKSwgIGQg55u45b2T5LqO5bi46YeP5ZKMTuaXoOWFs++8jOaJgOS7peWfuuaVsOaOkuW6j+S5n+aYryBPKG4p44CC5Z+65pWw5o6S5bqP6Jm954S25piv57q/5oCn5aSN5p2C5bqm77yMIOWNs+WvuW7kuKrmlbDlrZflpITnkIbkuoZu5qyh77yM5L2G5piv5q+P5LiA5qyh5Luj5Lu36YO95q+U6L6D6auY77yMIOiAjOS4lOS9v+eUqOiuoeaVsOaOkuW6j+eahOWfuuaVsOaOkuW6j+S4jeiDvei/m+ihjOWOn+WcsOaOkuW6j++8jOmcgOimgeabtOWkmueahOWGheWtmO+8jCDlubbkuJTlv6vpgJ/mjpLluo/lj6/og73mm7Tlpb3lnLDliKnnlKjnoazku7bnmoTnvJPlrZjvvIwg5omA5Lul5q+U6L6D6LW35p2l77yM5YOP5b+r6YCf5o6S5bqP6L+Z5Lqb5Y6f5Zyw5o6S5bqP566X5rOV5pu05Y+v5Y+W44CC5a+55LqO5LiA5Liq5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw77yM5oiR5Lus5Y+v5Lul5oqK5a6D55yL5L2c5LiA5Liq5aSa5YWD57uE77yM5LuO6auY5L2N5Yiw5L2O5L2N5YWz6ZSu5a2X6YeN6KaB56iL5bqm5L6d5qyh6YCS5YeP44CC5Y+v5Lul5L2/55So5Z+65pWw5o6S5bqP5a+55LiA5Lqb5L2N5pWw5pyJ6ZmQ55qE5Y2B6L+b5Yi25pWw5o6S5bqP44CCXHJcbiAqL1xyXG5cclxuLy8g5rGC5pWw5o2u55qE5pyA5aSn5L2N5pWwXHJcbmZ1bmN0aW9uIG1heEJpdChhcnIpe1xyXG4gICAgdmFyIGQgPSAxO1xyXG4gICAgdmFyIHAgPSAxMDtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAwLCBuID0gYXJyLmxlbmd0aDsgaSA8IG47ICsraSl7XHJcbiAgICAgICAgd2hpbGUoYXJyW2ldID49IHApe1xyXG4gICAgICAgICAgICBwICo9IDEwO1xyXG4gICAgICAgICAgICArK2Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkO1xyXG59XHJcblxyXG5mdW5jdGlvbiByYWRpeFNvcnQoYXJyLCBkKXtcclxuICAgIGQgPSBkIHx8IG1heEJpdChhcnIpO1xyXG4gICAgdmFyIG4gPSBhcnIubGVuZ3RoO1xyXG4gICAgdmFyIHRlbXAgPSBbXTtcclxuICAgIC8vIOiuoeaVsOWZqFxyXG4gICAgdmFyIGNvdW50ID0gW107XHJcbiAgICB2YXIgcmFkaXggPSAxO1xyXG5cclxuICAgIC8vIOi/m+ihjGTmrKHmjpLluo9cclxuICAgIGZvcih2YXIgaSA9IDE7IGkgPD0gZDsgKytpKXtcclxuICAgICAgICAvLyDmr4/mrKHliIbphY3liY3muIXnqbrorqHmlbDlmahcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgMTA7ICsrailcclxuICAgICAgICAgICAgY291bnRbal0gPSAwO1xyXG4gICAgICAgIC8vIOe7n+iuoeavj+S4quahtuS4reeahOiusOW9leaVsFxyXG4gICAgICAgIGZvcihqID0gMDsgaiA8IG47ICsrail7XHJcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcihhcnJbal0gLyByYWRpeCkgJSAxMDtcclxuICAgICAgICAgICAgKytjb3VudFtrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGogPSAxOyBqIDwgMTA7ICsrailcclxuICAgICAgICAgICAgY291bnRbal0gKz0gY291bnRbaiAtIDFdO1xyXG4gICAgICAgIC8vIOWwhuaJgOacieahtuS4reiusOW9leS+neasoeaUtumbhuWIsHRtcOS4rVxyXG4gICAgICAgIGZvcihqID0gbiAtIDE7IGogPj0gMDsgLS1qKXtcclxuICAgICAgICAgICAgayA9IE1hdGguZmxvb3IoYXJyW2pdIC8gcmFkaXgpICUgMTA7XHJcbiAgICAgICAgICAgIHRlbXBbLS1jb3VudFtrXV0gPSBhcnJbal07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5bCG5Li05pe25pWw57uE55qE5YaF5a655aSN5Yi25YiwYXJy5LitXHJcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgbjsgKytqKVxyXG4gICAgICAgICAgICBhcnJbal0gPSB0ZW1wW2pdO1xyXG5cclxuICAgICAgICByYWRpeCAqPSAxMDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnJhZGl4U29ydCA9IHJhZGl4U29ydDtcclxuXHJcbnZhciBhcnIgPSBbMTAwLCA5MywgOTcsIDkyLCA5NiwgOTksIDkyLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLCA5NV07XHJcbnJhZGl4U29ydChhcnIsIDEwMCk7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG5cclxuLypcclxuIOahtuaOkuW6j1xyXG5cclxuIOahtuaOkuW6j++8iEJ1Y2tldCBzb3J077yJ5oiW5omA6LCT55qE566x5o6S5bqP77yM5piv5LiA5Liq5o6S5bqP566X5rOV77yM5bel5L2c55qE5Y6f55CG5piv5bCG5pWw57uE5YiG5Yiw5pyJ6ZmQ5pWw6YeP55qE5qG25a2Q6YeM44CC5q+P5Liq5qG25a2Q5YaN5Liq5Yir5o6S5bqP77yI5pyJ5Y+v6IO95YaN5L2/55So5Yir55qE5o6S5bqP566X5rOV5oiW5piv5Lul6YCS5b2S5pa55byP57un57ut5L2/55So5qG25o6S5bqP6L+b6KGM5o6S5bqP77yJ44CC5qG25o6S5bqP5piv6bi95bei5o6S5bqP55qE5LiA56eN5b2S57qz57uT5p6c44CC5b2T6KaB6KKr5o6S5bqP55qE5pWw57uE5YaF55qE5pWw5YC85piv5Z2H5YyA5YiG6YWN55qE5pe25YCZ77yM5qG25o6S5bqP5L2/55So57q/5oCn5pe26Ze077yIzpgobinvvInjgILkvYbmobbmjpLluo/lubbkuI3mmK/mr5TovoPmjpLluo/vvIzku5bkuI3lj5fliLBPKG4gbG9nIG4p5LiL6ZmQ55qE5b2x5ZON44CCXHJcblxyXG4g5Z+65pys5oCd5oOzXHJcblxyXG4g5YGH6K6+5pyJ5LiA57uE6ZW/5bqm5Li6TueahOW+heaOkuWFs+mUruWtl+W6j+WIl0tbMS4uLi5uXeOAgummluWFiOWwhui/meS4quW6j+WIl+WIkuWIhuaIkE3kuKrnmoTlrZDljLrpl7Qo5qG2KSDjgILnhLblkI7ln7rkuo7mn5Dnp43mmKDlsITlh73mlbAg77yM5bCG5b6F5o6S5bqP5YiX55qE5YWz6ZSu5a2Xa+aYoOWwhOWIsOesrGnkuKrmobbkuK0o5Y2z5qG25pWw57uEQueahOS4i+aghyBpKSDvvIzpgqPkuYjor6XlhbPplK7lrZdr5bCx5L2c5Li6QltpXeS4reeahOWFg+e0oCjmr4/kuKrmobZCW2ld6YO95piv5LiA57uE5aSn5bCP5Li6Ti9N55qE5bqP5YiXKeOAguaOpeedgOWvueavj+S4quahtkJbaV3kuK3nmoTmiYDmnInlhYPntKDov5vooYzmr5TovoPmjpLluo8o5Y+v5Lul5L2/55So5b+r5o6SKeOAgueEtuWQjuS+neasoeaemuS4vui+k+WHukJbMF0uLi4uQltNXeS4reeahOWFqOmDqOWGheWuueWNs+aYr+S4gOS4quacieW6j+W6j+WIl+OAglxyXG4g5YGH5aaC5b6F5o6S5bqP5YiXSz0gezQ544CBIDM4IOOAgSAzNeOAgSA5NyDjgIEgNzbjgIEgNzMg44CBIDI344CBIDQ5IH3jgILov5nkupvmlbDmja7lhajpg6jlnKgx4oCUMTAw5LmL6Ze044CC5Zug5q2k5oiR5Lus5a6a5Yi2MTDkuKrmobbvvIznhLblkI7noa7lrprmmKDlsITlh73mlbBmKGspPWsvMTDjgILliJnnrKzkuIDkuKrlhbPplK7lrZc0OeWwhuWumuS9jeWIsOesrDTkuKrmobbkuK0oNDkvMTA9NCnjgILkvp3mrKHlsIbmiYDmnInlhbPplK7lrZflhajpg6jloIblhaXmobbkuK3vvIzlubblnKjmr4/kuKrpnZ7nqbrnmoTmobbkuK3ov5vooYzlv6vpgJ/mjpLluo/jgIJcclxuXHJcbiDliIbmnpBcclxuXHJcbiDmobbmjpLluo/liKnnlKjlh73mlbDnmoTmmKDlsITlhbPns7vvvIzlh4/lsJHkuoblh6DkuY7miYDmnInnmoTmr5TovoPlt6XkvZzjgILlrp7pmYXkuIrvvIzmobbmjpLluo/nmoRmKGsp5YC855qE6K6h566X77yM5YW25L2c55So5bCx55u45b2T5LqO5b+r5o6S5Lit5YiS5YiG77yM5bey57uP5oqK5aSn6YeP5pWw5o2u5YiG5Ymy5oiQ5LqG5Z+65pys5pyJ5bqP55qE5pWw5o2u5Z2XKOahtinjgILnhLblkI7lj6rpnIDopoHlr7nmobbkuK3nmoTlsJHph4/mlbDmja7lgZrlhYjov5vnmoTmr5TovoPmjpLluo/ljbPlj6/jgIJcclxuIOWvuU7kuKrlhbPplK7lrZfov5vooYzmobbmjpLluo/nmoTml7bpl7TlpI3mnYLluqbliIbkuLrkuKTkuKrpg6jliIbvvJpcclxuICAgICAoMSkg5b6q546v6K6h566X5q+P5Liq5YWz6ZSu5a2X55qE5qG25pig5bCE5Ye95pWw77yM6L+Z5Liq5pe26Ze05aSN5p2C5bqm5pivTyhOKeOAglxyXG4gICAgICgyKSDliKnnlKjlhYjov5vnmoTmr5TovoPmjpLluo/nrpfms5Xlr7nmr4/kuKrmobblhoXnmoTmiYDmnInmlbDmja7ov5vooYzmjpLluo/vvIzlhbbml7bpl7TlpI3mnYLluqbkuLog4oiRIE8oTmkqbG9nTmkpIOOAguWFtuS4rU5pIOS4uuesrGnkuKrmobbnmoTmlbDmja7ph4/jgIJcclxuIOW+iOaYvueEtu+8jOesrCgyKemDqOWIhuaYr+ahtuaOkuW6j+aAp+iDveWlveWdj+eahOWGs+WumuWboOe0oOOAguWwvemHj+WHj+WwkeahtuWGheaVsOaNrueahOaVsOmHj+aYr+aPkOmrmOaViOeOh+eahOWUr+S4gOWKnuazlSjlm6DkuLrln7rkuo7mr5TovoPmjpLluo/nmoTmnIDlpb3lubPlnYfml7bpl7TlpI3mnYLluqblj6rog73ovr7liLBPKE4qbG9nTinkuoYp44CC5Zug5q2k77yM5oiR5Lus6ZyA6KaB5bC96YeP5YGa5Yiw5LiL6Z2i5Lik54K577yaXHJcbiAgICAgKDEpIOaYoOWwhOWHveaVsGYoaynog73lpJ/lsIZO5Liq5pWw5o2u5bmz5Z2H55qE5YiG6YWN5YiwTeS4quahtuS4re+8jOi/meagt+avj+S4quahtuWwseaciVtOL01d5Liq5pWw5o2u6YeP44CCXHJcbiAgICAgKDIpIOWwvemHj+eahOWinuWkp+ahtueahOaVsOmHj+OAguaegemZkOaDheWGteS4i+avj+S4quahtuWPquiDveW+l+WIsOS4gOS4quaVsOaNru+8jOi/meagt+WwseWujOWFqOmBv+W8gOS6huahtuWGheaVsOaNrueahOKAnOavlOi+g+KAneaOkuW6j+aTjeS9nOOAgiDlvZPnhLbvvIzlgZrliLDov5nkuIDngrnlvojkuI3lrrnmmJPvvIzmlbDmja7ph4/lt6jlpKfnmoTmg4XlhrXkuIvvvIxmKGsp5Ye95pWw5Lya5L2/5b6X5qG26ZuG5ZCI55qE5pWw6YeP5beo5aSn77yM56m66Ze05rWq6LS55Lil6YeN44CC6L+Z5bCx5piv5LiA5Liq5pe26Ze05Luj5Lu35ZKM56m66Ze05Luj5Lu355qE5p2D6KGh6Zeu6aKY5LqG44CCXHJcblxyXG4g5a+55LqOTuS4quW+heaOkuaVsOaNru+8jE3kuKrmobbvvIzlubPlnYfmr4/kuKrmobZbTi9NXeS4quaVsOaNrueahOahtuaOkuW6j+W5s+Wdh+aXtumXtOWkjeadguW6puS4uu+8mlxyXG4gTyhOKStPKE0qKE4vTSkqbG9nKE4vTSkpPU8oTitOKihsb2dOLWxvZ00pKT1PKE4rTipsb2dOLU4qbG9nTSlcclxuIOW9k049TeaXtu+8jOWNs+aegemZkOaDheWGteS4i+avj+S4quahtuWPquacieS4gOS4quaVsOaNruaXtuOAguahtuaOkuW6j+eahOacgOWlveaViOeOh+iDveWkn+i+vuWIsE8oTinjgIJcclxuXHJcbiDmgLvnu5PvvJog5qG25o6S5bqP55qE5bmz5Z2H5pe26Ze05aSN5p2C5bqm5Li657q/5oCn55qETyhOK0Mp77yM5YW25LitQz1OKihsb2dOLWxvZ00p44CC5aaC5p6c55u45a+55LqO5ZCM5qC355qETu+8jOahtuaVsOmHj03otorlpKfvvIzlhbbmlYjnjofotorpq5jvvIzmnIDlpb3nmoTml7bpl7TlpI3mnYLluqbovr7liLBPKE4p44CCIOW9k+eEtuahtuaOkuW6j+eahOepuumXtOWkjeadguW6piDkuLpPKE4rTSnvvIzlpoLmnpzovpPlhaXmlbDmja7pnZ7luLjlup7lpKfvvIzogIzmobbnmoTmlbDph4/kuZ/pnZ7luLjlpJrvvIzliJnnqbrpl7Tku6Pku7fml6DnlpHmmK/mmILotLXnmoTjgILmraTlpJbvvIzmobbmjpLluo/mmK/nqLPlrprnmoTjgIJcclxuICovXHJcblxyXG52YXIgQlVDS0VUU05VTSA9IDEwO1xyXG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi4vZXhjaGFuZ2UvaW5kZXgnKS5xdWlja1NvcnQ7XHJcblxyXG5mdW5jdGlvbiBidWNrZXRTb3J0KHNxTGlzdCl7XHJcbiAgICB2YXIgIG4gPSBzcUxpc3QubGVuZ3RoO1xyXG4gICAgdmFyIGJ1Y2tldEEgPSBbXTtcclxuICAgIHZhciBiID0gW107XHJcblxyXG4gICAgLy8g5Yid5aeL5YyW5qG2XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgQlVDS0VUU05VTTsgKytpKXtcclxuICAgICAgICBiW2ldID0gW107XHJcbiAgICAgICAgYnVja2V0QVtpXSA9IDA7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBuOyArK2opXHJcbiAgICAgICAgICAgIGJbaV1bal0gPSBJbmZpbml0eTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDnu5nmobbloavoo4XmlbDmja5cclxuICAgIGZvcihpID0gMDsgaSA8IG47ICsraSl7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgLy8gbm90bzog6L+Z6YeM55qE5pig5bCE5Ye95pWw5piv6ZKI5a+5MS0xMDDkuYvpl7TnmoTlrp7mlbBcclxuICAgICAgICB2YXIgYnVja2V0ID0gTWF0aC5mbG9vcihkYXRhIC8gQlVDS0VUU05VTSk7XHJcbiAgICAgICAgYltidWNrZXRdW2J1Y2tldEFbYnVja2V0XV0gPSBkYXRhO1xyXG4gICAgICAgICsrYnVja2V0QVtidWNrZXRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOmSiOWvueavj+S4quahtui/m+ihjOW/q+mAn+aOkuW6j1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgQlVDS0VUU05VTTsgKytpKXtcclxuICAgICAgICBpZihidWNrZXRBW2ldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHF1aWNrU29ydChiW2ldLCAwLCBidWNrZXRBW2ldIC0gMSk7XHJcbiAgICAgICAgICAgIC8vZm9yKGogPSAxOyBqIDwgYnVja2V0QVtpXTsgKytqKXtcclxuICAgICAgICAgICAgLy8gICAgdmFyIHAgPSBiW2ldW2pdO1xyXG4gICAgICAgICAgICAvLyAgICBmb3IodmFyIGsgPSBqIC0gMTsgayA+PSAwICYmIHAgPCBiW2ldW2tdOyAtLWspe1xyXG4gICAgICAgICAgICAvLyAgICAgICAgYltpXVtrICsgMV0gPSBiW2ldW2tdO1xyXG4gICAgICAgICAgICAvLyAgICB9XHJcbiAgICAgICAgICAgIC8vICAgIGJbaV1bayArIDFdID0gcDtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vY29uc29sZS5sb2coYik7XHJcbiAgICAvL2NvbnNvbGUubG9nKGJ1Y2tldEEpO1xyXG5cclxuICAgIC8vIOWkjeWItuWbnuWOu1xyXG4gICAgdmFyIG51bSA9IDA7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBCVUNLRVRTTlVNOyArK2kpe1xyXG4gICAgICAgIGlmKGJ1Y2tldEFbaV0gIT09IDApIHtcclxuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgYnVja2V0QVtpXTsgKytqKXtcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtudW0rK10gPSBiW2ldW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYnVja2V0U29ydCA9IGJ1Y2tldFNvcnQ7XHJcblxyXG52YXIgYXJyID0gWzUxLjIsIDkzLCAxLCA5Mi4yLCA4LCA5OS41LCA5Mi4wLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLjEsIDk1XTtcclxuYnVja2V0U29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxyXG52YXIgYXJyID0gWzUxLjIsIDkzLCAxLCA5Mi4yLCA4LCA5OS41LCA5Mi4wLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLjEsIDk1LCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcclxucXVpY2tTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vKlxyXG4g5oCn6IO95YiG5p6QXHJcbiDlvojmmI7mmL7vvIzln7rmlbDmjpLluo/nmoTmgKfog73mr5TmobbmjpLluo/opoHnlaXlt67jgILmr4/kuIDmrKHlhbPplK7lrZfnmoTmobbliIbphY3pg73pnIDopoFPKE4p55qE5pe26Ze05aSN5p2C5bqm77yM6ICM5LiU5YiG6YWN5LmL5ZCO5b6X5Yiw5paw55qE5YWz6ZSu5a2X5bqP5YiX5Y+I6ZyA6KaBTyhOKeeahOaXtumXtOWkjeadguW6puOAguWBh+WmguW+heaOkuaVsOaNruWPr+S7peWIhuS4umTkuKrlhbPplK7lrZfvvIzliJnln7rmlbDmjpLluo/nmoTml7bpl7TlpI3mnYLluqblsIbmmK9PKGQqMk4pIO+8jOW9k+eEtmTopoHov5zov5zlsI/kuo5O77yM5Zug5q2k5Z+65pys5LiK6L+Y5piv57q/5oCn57qn5Yir55qE44CC5Z+65pWw5o6S5bqP55qE56m66Ze05aSN5p2C5bqm5Li6TyhOK00p77yM5YW25LitTeS4uuahtueahOaVsOmHj+OAguS4gOiIrOadpeivtE4+Pk3vvIzlm6DmraTpop3lpJbnqbrpl7TpnIDopoHlpKfmpoJO5Liq5bem5Y+z44CCXHJcbiDkvYbmmK/vvIzlr7nmr5TmobbmjpLluo/vvIzln7rmlbDmjpLluo/mr4/mrKHpnIDopoHnmoTmobbnmoTmlbDph4/lubbkuI3lpJrjgILogIzkuJTln7rmlbDmjpLluo/lh6DkuY7kuI3pnIDopoHku7vkvZXigJzmr5TovoPigJ3mk43kvZzvvIzogIzmobbmjpLluo/lnKjmobbnm7jlr7novoPlsJHnmoTmg4XlhrXkuIvvvIzmobblhoXlpJrkuKrmlbDmja7lv4Xpobvov5vooYzln7rkuo7mr5TovoPmk43kvZznmoTmjpLluo/jgILlm6DmraTvvIzlnKjlrp7pmYXlupTnlKjkuK3vvIzln7rmlbDmjpLluo/nmoTlupTnlKjojIPlm7Tmm7TliqDlub/ms5vjgIJcclxuICovXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvU29ydC9kaXN0cmlidXRpb24vaW5kZXguanNcbiAqKi8iLCIvKipcclxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTUvMi8yLlxyXG4gKi9cclxuXHJcbmltcG9ydCBTdGF0aWNMaW5rZWRMaXN0IGZyb20gJy4uLy4uL0xpc3QvU3RhdGljTGlua2VkTGlzdCc7XHJcbnZhciBkZWZhdWx0Q29tcGFyZSA9IHJlcXVpcmUoJy4uL2RlZmF1bHRDb21wYXJpc2lvbicpO1xyXG5cclxuLypcclxuIOaPkuWFpeaOkuW6j1xyXG5cclxuIOmHh+eUqOeahOaYr+S7pSDigJznjqnmoaXniYzogIXigJ3nmoTmlrnms5XkuLrln7rnoYDnmoTjgILljbPlnKjogIPlr5/orrDlvZVSaeS5i+WJje+8jOiuvuS7peWJjeeahOaJgOacieiusOW9lVIxLCBSMiAs4oCmLiwgUmktMeW3suaOkuWlveW6j++8jOeEtuWQjuWwhlJp5o+S5YWl5Yiw5bey5o6S5aW95bqP55qE6K+46K6w5b2V55qE6YCC5b2T5L2N572uXHJcblxyXG4g5pyA5Z+65pys55qE5o+S5YWl5o6S5bqP5piv55u05o6l5o+S5YWl5o6S5bqPKFN0cmFpZ2h0IEluc2VydGlvbiBTb3J0KSDjgIJcclxuXHJcblxyXG4g55u05o6l5o+S5YWl5o6S5bqPXHJcblxyXG4gMSAg5o6S5bqP5oCd5oOzXHJcbiDlsIblvoXmjpLluo/nmoTorrDlvZVSae+8jOaPkuWFpeWIsOW3suaOkuWlveW6j+eahOiusOW9leihqFIxLCBSMiAs4oCmLiwgUmktMeS4re+8jOW+l+WIsOS4gOS4quaWsOeahOOAgeiusOW9leaVsOWinuWKoDHnmoTmnInluo/ooajjgIIg55u05Yiw5omA5pyJ55qE6K6w5b2V6YO95o+S5YWl5a6M5Li65q2i44CCXHJcbiDorr7lvoXmjpLluo/nmoTorrDlvZXpobrluo/lrZjmlL7lnKjmlbDnu4RSWzHigKZuXeS4re+8jOWcqOaOkuW6j+eahOafkOS4gOaXtuWIu++8jOWwhuiusOW9leW6j+WIl+WIhuaIkOS4pOmDqOWIhu+8mlxyXG4g4peGIFJbMeKApmktMV3vvJrlt7LmjpLlpb3luo/nmoTmnInluo/pg6jliIbvvJtcclxuIOKXhiBSW2nigKZuXe+8muacquaOkuWlveW6j+eahOaXoOW6j+mDqOWIhuOAglxyXG4g5pi+54S277yM5Zyo5Yia5byA5aeL5o6S5bqP5pe277yMUlsxXeaYr+W3sue7j+aOkuWlveW6j+eahOOAglxyXG5cclxuIDIu566X5rOV5a6e546wXHJcblxyXG4gMy7nrpfms5XliIbmnpBcclxuIOKRtCDmnIDlpb3mg4XlhrXvvJroi6XlvoXmjpLluo/orrDlvZXmjInlhbPplK7lrZfku47lsI/liLDlpKfmjpLliJco5q2j5bqPKe+8jOeul+azleS4reeahOWGheW+queOr+aXoOmhu+aJp+ihjO+8jOWImeS4gOi2n+aOkuW6j+aXtu+8muWFs+mUruWtl+avlOi+g+asoeaVsDHmrKHvvIzorrDlvZXnp7vliqjmrKHmlbAy5qyhKFJbaV3ihpJSWzBdLCBSWzBd4oaSUltqKzFdKeOAglxyXG4g5YiZ5pW05Liq5o6S5bqP55qE5YWz6ZSu5a2X5q+U6L6D5qyh5pWw5ZKM6K6w5b2V56e75Yqo5qyh5pWw5YiG5Yir5piv77yaXHJcbiDmr5TovoPmrKHmlbDvvJpuIC0gMSAgICAgICAgICDnp7vliqjmrKHmlbDvvJogMiAqIChuIC0gMSlcclxuXHJcbiDikbUg5pyA5Z2P5oOF5Ya177ya6Iul5b6F5o6S5bqP6K6w5b2V5oyJ5YWz6ZSu5a2X5LuO5aSn5Yiw5bCP5o6S5YiXKOmAhuW6jynvvIzliJnkuIDotp/mjpLluo/ml7bvvJrnrpfms5XkuK3nmoTlhoXlvqrnjq/kvZPmiafooYxpLTHvvIzlhbPplK7lrZfmr5TovoPmrKHmlbBp5qyh77yM6K6w5b2V56e75Yqo5qyh5pWwaSsx44CCXHJcbiDliJnlsLHmlbTkuKrmjpLluo/ogIzoqIDvvJpcclxuIOavlOi+g+asoeaVsO+8miAobiAtIDEpICogKG4gKyAxKSAvIDIgICAgIOenu+WKqOasoeaVsDogKG4gLSAxKSAqIChuICsgNCkgLyAyXHJcblxyXG4g5LiA6Iis5Zyw77yM6K6k5Li65b6F5o6S5bqP55qE6K6w5b2V5Y+v6IO95Ye6546w55qE5ZCE56eN5o6S5YiX55qE5qaC546H55u45ZCM77yM5YiZ5Y+W5Lul5LiK5Lik56eN5oOF5Ya155qE5bmz5Z2H5YC877yM5L2c5Li65o6S5bqP55qE5YWz6ZSu5a2X5q+U6L6D5qyh5pWw5ZKM6K6w5b2V56e75Yqo5qyh5pWw77yM57qm5Li6bjIvNO+8jOWImeWkjeadguW6puS4uk8objIpIOOAglxyXG5cclxuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc3RyYWlnaHRJbnNlcnRTb3J0KHNxTGlzdCwgY29tcCkge1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIC8vIOiuvue9ruWTqOWFtSwg5b2T6K6+572uc3FMaXN0Wy0xXSA9IHNxTGlzdFtpXeaXtu+8jOe7j+a1i+ivleaViOeOh+abtOaFolxyXG4gICAgICAgIC8vIOWboOS4umpz6YeM6Z2i55qE5Y+Y6YeP5L2c55So5Z+f5Zyo5Ye95pWw5YaF55qEXHJcbiAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgLy8g5p+l5om+5o+S5YWl5L2N572u77yM5bm25bCG6K6w5b2V5ZCO56e7XHJcbiAgICAgICAgZm9yKHZhciBqID0gaSAtIDE7IGogPj0gMCAmJiBjb21wKHRlbXAsIHNxTGlzdFtqXSkgPCAwOyAtLWopXHJcbiAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSBzcUxpc3Rbal07XHJcblxyXG4gICAgICAgIC8vIOaPkuWFpeWIsOato+ehruS9jee9rlxyXG4gICAgICAgIHNxTGlzdFtqICsgMV0gPSB0ZW1wO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc3RyYWlnaHRJbnNlcnRTb3J0ID0gc3RyYWlnaHRJbnNlcnRTb3J0O1xyXG5cclxudmFyIGEgPSBbNywgNCwgLTIsIDE5LCAxMywgNl07XHJcbnN0cmFpZ2h0SW5zZXJ0U29ydChhKTtcclxuY29uc29sZS5sb2coYSArICcnKTtcclxuXHJcblxyXG4vKlxyXG4g5YW25a6D5o+S5YWl5o6S5bqPXHJcblxyXG4gMSAg5oqY5Y2K5o+S5YWl5o6S5bqPXHJcbiDlvZPlsIblvoXmjpLluo/nmoTorrDlvZVSW2ldIOaPkuWFpeWIsOW3suaOkuWlveW6j+eahOiusOW9leWtkOihqFJbMeKApmktMV3kuK3ml7bvvIznlLHkuo5SMSwgUjIgLOKApiwgUmktMeW3suaOkuWlveW6j++8jOWImeafpeaJvuaPkuWFpeS9jee9ruWPr+S7peeUqOKAnOaKmOWNiuafpeaJvuKAneWunueOsO+8jOWImeebtOaOpeaPkuWFpeaOkuW6j+WwseWPmOaIkOS4uuaKmOWNiuaPkuWFpeaOkuW6j+OAglxyXG5cclxuIOS7juaXtumXtOS4iuavlOi+g++8jOaKmOWNiuaPkuWFpeaOkuW6j+S7heS7heWHj+WwkeS6huWFs+mUruWtl+eahOavlOi+g+asoeaVsO+8jOWNtOayoeacieWHj+WwkeiusOW9leeahOenu+WKqOasoeaVsO+8jOaVheaXtumXtOWkjeadguW6puS7jeeEtuS4uk8objIpIOOAglxyXG5cclxuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYmluYXJ5SW5zZXJ0U29ydChzcUxpc3QsIGNvbXApIHtcclxuICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICB2YXIgdGVtcCA9IHNxTGlzdFtpXTtcclxuICAgICAgICB2YXIgbG93ID0gMDtcclxuICAgICAgICB2YXIgaGlnaCA9IGkgLSAxO1xyXG5cclxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcclxuICAgICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbXAodGVtcCwgc3FMaXN0W21pZF0pIDwgMCkgaGlnaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgICAgIGVsc2UgbG93ID0gbWlkICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSBoaWdoICsgMTsgLS1qKSB7XHJcbiAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSBzcUxpc3Rbal07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcUxpc3RbaGlnaCArIDFdID0gdGVtcDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmJpbmFyeUluc2VydFNvcnQgPSBiaW5hcnlJbnNlcnRTb3J0O1xyXG5cclxudmFyIGIgPSBbMzAsIDEzLCA3MCwgODUsIDM5LCA0MiwgNiwgMjBdO1xyXG5iaW5hcnlJbnNlcnRTb3J0KGIpO1xyXG5jb25zb2xlLmxvZyhiICsgJycpO1xyXG5cclxuXHJcbi8qXHJcbiAyLei3r+aPkuWFpeaOkuW6j1xyXG5cclxuIOaYr+WvueaKmOWNiuaPkuWFpeaOkuW6j+eahOaUuei/m++8jOS7peWHj+WwkeaOkuW6j+i/h+eoi+S4reenu+WKqOiusOW9leeahOasoeaVsOOAgumZhOWKoG7kuKrorrDlvZXnmoTovoXliqnnqbrpl7TvvIzmlrnms5XmmK/vvJpcclxuIOKRoCAg5Y+m6K6+5LiA5Liq5pWw57uEZO+8jExbMV3otYvnu5lkWzFd77yM5bCGZFsxXeeci+aIkOaYr+aOkuWlveW6j+eahOW6j+WIl+S4reS4remXtOS9jee9rueahOiusOW9le+8m1xyXG4g4pGhICDliIbliKvlsIZMWyBd5Lit55qE56ysaeS4quiusOW9leS+neasoeaPkuWFpeWIsGRbMV3kuYvliY3miJbkuYvlkI7nmoTmnInluo/luo/liJfkuK3vvIzlhbfkvZPmlrnms5XvvJpcclxuIOKXhiAgTFtpXS5rZXk8ZFsxXS5rZXnvvJogTFtpXeaPkuWFpeWIsGRbMV3kuYvliY3nmoTmnInluo/ooajkuK3vvJtcclxuIOKXhiBMW2ldLmtleeKJpWRbMV0ua2V577yaIExbaV3mj5LlhaXliLBkWzFd5LmL5ZCO55qE5pyJ5bqP6KGo5Lit77ybXHJcbiDlhbPplK7ngrnvvJrlrp7njrDml7blsIblkJHph49k55yL5oiQ5piv5b6q546v5ZCR6YeP77yM5bm26K6+5Lik5Liq5oyH6ZKIZmlyc3TlkoxmaW5hbOWIhuWIq+aMh+ekuuaOkuW6j+i/h+eoi+S4reW+l+WIsOeahOacieW6j+W6j+WIl+S4reeahOesrOS4gOS4quWSjOacgOWQjuS4gOS4quiusOW9leOAglxyXG5cclxuIOWcqDIt6Lev5o+S5YWl5o6S5bqP5Lit77yM56e75Yqo6K6w5b2V55qE5qyh5pWw57qm5Li6bjIvOCDjgILkvYblvZNMWzFd5piv5b6F5o6S5bqP6K6w5b2V5Lit5YWz6ZSu5a2X5pyA5aSn5oiW5pyA5bCP55qE6K6w5b2V5pe277yMMi3ot6/mj5LlhaXmjpLluo/lsLHlrozlhajlpLHljrvkuobkvJjotormgKfjgIJcclxuICovXHJcblxyXG5mdW5jdGlvbiBwYXRoMkluc2VydFNvcnQoc3FMaXN0LCBjb21wKSB7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICB2YXIgZCA9IFtzcUxpc3RbMF1dO1xyXG4gICAgLy8gZmlyc3TjgIFmaW5hbOWIhuWIq+aMh+ekumTkuK3mjpLlpb3luo/nmoTorrDlvZXnmoTnrKwx5Liq5ZKM5pyA5ZCOMeS4quiusOW9leeahOS9jee9ruOAglxyXG4gICAgdmFyIGZpcnN0ID0gMDtcclxuICAgIHZhciBmaW5hbCA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIHZhciBpdGVtID0gc3FMaXN0W2ldO1xyXG5cclxuICAgICAgICAvLyDlvoXmj5LlhaXorrDlvZXlsI/kuo5k5Lit5pyA5bCP5YC877yM5o+S5YWl5YiwZFtmaXJzdF3kuYvliY3vvIjkuI3pnIDnp7vliqhk5pWw57uE55qE5YWD57Sg77yJ44CCXHJcbiAgICAgICAgaWYgKGNvbXAoaXRlbSwgZFtmaXJzdF0pIDwgMCkge1xyXG4gICAgICAgICAgICBmaXJzdCA9IChmaXJzdCAtIDEpICUgbGVuO1xyXG4gICAgICAgICAgICBkW2ZpcnN0XSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW+heaPkuWFpeiusOW9leWkp+S6jmTkuK3mnIDlsI/lgLzvvIzmj5LlhaXliLBkW2ZpbmFsXeS5i+WQju+8iOS4jemcgOenu+WKqGTmlbDnu4TnmoTlhYPntKDvvInjgIJcclxuICAgICAgICBlbHNlIGlmIChjb21wKGl0ZW0sIGRbZmluYWxdKSA+IDApIHtcclxuICAgICAgICAgICAgZFsrK2ZpbmFsXSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW+heaPkuWFpeiusOW9leWkp+S6jmTkuK3mnIDlsI/lgLzvvIzlsI/kuo5k5Lit5pyA5aSn5YC877yM5o+S5YWl5YiwZOeahOS4remXtO+8iOmcgOimgeenu+WKqGTmlbDnu4TnmoTlhYPntKDvvInjgIJcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g56e75YqoZOWwvumDqOWFg+e0oOS7peS+v+aMieW6j+aPkuWFpeiusOW9leOAglxyXG4gICAgICAgICAgICB2YXIgaiA9IGZpbmFsKys7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb21wKGl0ZW0sIGRbal0pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZFsoaiArIDEpICUgbGVuXSA9IGRbal07XHJcbiAgICAgICAgICAgICAgICBqID0gKGogLSAxKSAlIGxlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkWyhqICsgMSkgJSBsZW5dID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g5b6q546v5oqKZOi1i+e7mXNxTGlzdFxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgc3FMaXN0W2ldID0gZFsoaSArIGZpcnN0KSAlIGxlbl07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5wYXRoMkluc2VydFNvcnQgPSBwYXRoMkluc2VydFNvcnQ7XHJcblxyXG52YXIgYyA9IFs0OSwgMzgsIDY1LCAxMywgOTcsIDI3LCA3NiwgNSwgMTAwLCA3OCwgMTUsIDE1LCAyMF07XHJcbnBhdGgySW5zZXJ0U29ydChjKTtcclxuY29uc29sZS5sb2coYyArICcnKTtcclxuXHJcblxyXG4vKlxyXG7ooajmj5LlhaXmjpLluo9cclxuXHJcbuWJjemdoueahOaPkuWFpeaOkuW6j+S4jeWPr+mBv+WFjeWcsOimgeenu+WKqOiusOW9le+8jOiLpeS4jeenu+WKqOiusOW9leWwsemcgOimgeaUueWPmOaVsOaNrue7k+aehOOAglxyXG7liJ3lp4vljJbvvJrkuIvmoIflgLzkuLow55qE5YiG6YeP5L2c5Li66KGo5aS057uT54K577yM5YWz6ZSu5a2X5Y+W5Li65pyA5aSn5YC877yM5ZCE5YiG6YeP55qE5oyH6ZKI5YC85Li656m677ybXHJcbuKRoCAg5bCG6Z2Z5oCB6ZO+6KGo5Lit5pWw57uE5LiL5qCH5YC85Li6MeeahOWIhumHjyjnu5Pngrkp5LiO6KGo5aS057uT54K55p6E5oiQ5LiA5Liq5b6q546v6ZO+6KGo77ybXHJcbuKRoSBpPTIg77yM5bCG5YiG6YePUltpXeaMieWFs+mUruWtl+mAkuWHj+aPkuWFpeWIsOW+queOr+mTvuihqO+8m1xyXG7ikaIgIOWinuWKoGkg77yM6YeN5aSN4pGh77yM55u05Yiw5YWo6YOo5YiG6YeP5o+S5YWl5Yiw5b6q546v6ZO+6KGo44CCXHJcblxyXG7lkoznm7TmjqXmj5LlhaXmjpLluo/nm7jmr5TvvIzkuI3lkIznmoTmmK/kv67mlLkybuasoeaMh+mSiOWAvOS7peS7o+abv+enu+WKqOiusOW9le+8jOiAjOWFs+mUruWtl+eahOavlOi+g+asoeaVsOebuOWQjO+8jOaVheaXtumXtOWkjeadguW6puS4uk8objIp44CCXHJcblxyXG7ooajmj5LlhaXmjpLluo/lvpfliLDkuIDkuKrmnInluo/pk77ooajvvIzlr7nlhbblj6/ku6Xmlrnkvr/lnLDov5vooYzpobrluo/mn6Xmib7vvIzkvYbkuI3og73lrp7njrDpmo/mnLrmn6Xmib7jgILkuLrkuobog73lrp7njrDmnInluo/ooajnmoTmipjljYrmn6Xmib7moLnmja7pnIDopoHvvIzlj6/ku6Xlr7norrDlvZXov5vooYzph43mjpIuXHJcblxyXG7ph43mjpLorrDlvZXnmoTlgZrms5XmmK/vvJrpobrluo/miavmj4/mnInluo/pk77ooajvvIzlsIbpk77ooajkuK3nrKxp5Liq57uT54K556e75Yqo6Iez5pWw57uE55qE56ysaeS4quWIhumHj+S4reOAglxyXG5cclxu5L6L5a2Q5Lit77yM6ZO+6KGo5Lit56ys5LiA5Liq57uT54K577yM5Y2z5YWz6ZSu5a2X5pyA5bCP55qE57uT54K55piv5pWw57uE5Lit5LiL5qCH5Li6NueahOWIhumHj++8jOWFtuS4reiusOW9leW6lOenu+iHs+aVsOe7hOeahOesrOS4gOS4quWIhumHj++8jOWImeWwhmxpc3RbMV3lkoxsaXN0WzZd5LqS5o2i77yM5bm25Li65LqG5LiN5Lit5pat6Z2Z5oCB6ZO+6KGo5Lit55qE6ZO+77yM5Y2z5Zyo57un57ut6aG66ZO+6KGo5omr5o+P5pe25LuN6IO95om+5Yiw5LqS5o2i5LmL5YmN5ZyobGlzdFsxXeS4reeahOe7k+eCue+8jOS7pOS6kuaNouS5i+WQjueahGxpc3RbMV3kuK3nmoTmuLjmoIfmlLnkuLo2XHJcblxyXG7mjqjlub/oh7PkuIDoiKzmg4XlhrXvvIzoi6XnrKxp5Liq5pyA5bCP5YWz6ZSu5a2X55qE57uT54K55piv5pWw57uE5Lit5LiL5qCH5Li6cOS4lHAgPiBp55qE5YiG6YeP77yM5YiZ5LqS5o2ibGlzdFtpXeWSjGxpc3RbcF3vvIzkuJTku6RsaXN0W2ld5Lit55qE5ri45qCH5pS55Li6cO+8m1xyXG7nlLHkuo7mraTml7bmlbDnu4TkuK3miYDmnInlsI/kuo5p55qE5YiG6YeP5Lit5bey5piv5Yiw5L2N6K6w5b2V77yM5YiZ5b2TcDxp5pe277yM5bqU6aG66ZO+57un57ut5p+l5om+55u05YiwcD49aeS4uuatouOAglxyXG4gKi9cclxuXHJcblxyXG4vLyDooajmj5LlhaXmjpLluo9cclxuZnVuY3Rpb24gc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQoc2xsaXN0LCBjb21wKSB7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICAvLyDmnoTmiJDlvqrnjq/pk77ooahcclxuICAgIHNsbGlzdFswXS5jdXIgPSAxO1xyXG4gICAgc2xsaXN0WzFdLmN1ciA9IDA7XHJcblxyXG4gICAgdmFyIHAsIHE7XHJcbiAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gc2xsaXN0Lmxlbmd0aDsgaSA8PSBsZW47ICsraSkge1xyXG4gICAgICAgIHAgPSAwO1xyXG4gICAgICAgIHZhciB4ID0gc2xsaXN0W2ldLmRhdGE7XHJcblxyXG4gICAgICAgIHdoaWxlIChzbGxpc3RbcF0uY3VyICYmIGNvbXAoc2xsaXN0W3NsbGlzdFtwXS5jdXJdLmRhdGEsIHgpIDwgMClcclxuICAgICAgICAgICAgcCA9IHNsbGlzdFtwXS5jdXI7XHJcblxyXG4gICAgICAgIC8vIOW9k+mBh+WIsOWkp+S6juW9k+WJjeWFs+mUruWtl+eahOS4i+agh+aXtu+8jOaPkuWFpeWIsOWFtuWJjempseWSjOWQjue7p+eahOS4remXtFxyXG4gICAgICAgIHEgPSBzbGxpc3RbcF0uY3VyO1xyXG4gICAgICAgIHNsbGlzdFtwXS5jdXIgPSBpO1xyXG4gICAgICAgIHNsbGlzdFtpXS5jdXIgPSBxO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQgPSBzdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydDtcclxuXHJcbi8vIOmHjeaOkumdmeaAgemTvuihqO+8jOmdmeaAgemTvuihqOS4i+agh+W3suaOkuWlveW6j1xyXG5mdW5jdGlvbiBhcnJhbmdlKHNsbGlzdCkge1xyXG4gICAgdmFyIHAgPSBzbGxpc3RbMF0uY3VyO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzbGxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAvLyDnrKxp5Liq6K6w5b2V5ZyobGlzdOS4reeahOW9k+WJjeS9jee9ruW6lOS4jeWwj+S6jmlcclxuICAgICAgICAvLyDmib7liLDnrKxp5Liq6K6w5b2V77yM5bm255SocOaMh+ekuuWFtuWcqGxpc3TkuK3lvZPliY3kvY3nva5cclxuICAgICAgICB3aGlsZSAocCA8IGkpIHAgPSBzbGxpc3RbcF0uY3VyO1xyXG4gICAgICAgIC8vIHHmjIflkJHlsJrmnKrosIPmlbTnmoTooajlsL5cclxuICAgICAgICB2YXIgcSA9IHNsbGlzdFtwXS5jdXI7XHJcblxyXG4gICAgICAgIGlmIChwICE9PSBpKSB7XHJcbiAgICAgICAgICAgIC8vIOS6pOaNouiusOW9le+8jOS9v+esrGnkuKrorrDlvZXliLDkvY1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBzbGxpc3RbcF07XHJcbiAgICAgICAgICAgIHNsbGlzdFtwXSA9IHNsbGlzdFtpXTtcclxuICAgICAgICAgICAgc2xsaXN0W2ldID0gdGVtcDtcclxuICAgICAgICAgICAgLy8g5oyH5ZCR6KKr56e76LWw55qE6K6w5b2V77yM5L2/5b6X5Lul5ZCO5Y+v5pyJd2hpbGXlvqrnjq/mib7liLBcclxuICAgICAgICAgICAgc2xsaXN0W2ldLmN1ciA9IHA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBw5oyH5ZCR5bCa5pyq6LCD5pW055qE6KGo5bC+XHJcbiAgICAgICAgcCA9IHE7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA1Ml07XHJcbnZhciBkID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoKTtcclxuZC5jcmVhdGUoYXJyKTtcclxuc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQoZCk7XHJcbmNvbnNvbGUubG9nKGQpO1xyXG5hcnJhbmdlKGQpO1xyXG5jb25zb2xlLmxvZyhkKTtcclxuXHJcblxyXG4vKlxyXG7luIzlsJTmjpLluo9cclxuXHJcbuW4jOWwlOaOkuW6jyhTaGVsbCBTb3J077yM5Y+I56ew57yp5bCP5aKe6YeP5rOVKeaYr+S4gOenjeWIhue7hOaPkuWFpeaOkuW6j+aWueazleOAglxyXG5cclxuMSAg5o6S5bqP5oCd5oOzXHJcbuKRoCAgIOWFiOWPluS4gOS4quato+aVtOaVsGQxKGQxPG4p5L2c5Li656ys5LiA5Liq5aKe6YeP77yM5bCG5YWo6YOobuS4quiusOW9leWIhuaIkGQx57uE77yM5oqK5omA5pyJ55u46ZqUZDHnmoTorrDlvZXmlL7lnKjkuIDnu4TkuK3vvIzljbPlr7nkuo7mr4/kuKprKGs9MSwgMiwgIOKApiBkMSnvvIxSW2tdLCBSW2QxK2tdLCBSWzJkMStrXSAsIOKApuWIhuWcqOWQjOS4gOe7hOS4re+8jOWcqOWQhOe7hOWGhei/m+ihjOebtOaOpeaPkuWFpeaOkuW6j+OAgui/meagt+S4gOasoeWIhue7hOWSjOaOkuW6j+i/h+eoi+ensOS4uuS4gOi2n+W4jOWwlOaOkuW6j++8m1xyXG7ikaEgICDlj5bmlrDnmoTlop7ph49kMjxkMe+8jOmHjeWkjeKRoOeahOWIhue7hOWSjOaOkuW6j+aTjeS9nO+8m+ebtOiHs+aJgOWPlueahOWinumHj2RpPTHkuLrmraLvvIzljbPmiYDmnInorrDlvZXmlL7ov5vkuIDkuKrnu4TkuK3mjpLluo/kuLrmraLjgIJcclxuXHJcbjIgIOaOkuW6j+ekuuS+i1xyXG7orr7mnIkxMOS4quW+heaOkuW6j+eahOiusOW9le+8jOWFs+mUruWtl+WIhuWIq+S4ujksIDEzLCA4LCAyLCA1LCAxMywgNywgMSwgMTUsIDEx77yM5aKe6YeP5bqP5YiX5pivNSwgMywgMe+8jOW4jOWwlOaOkuW6j+eahOi/h+eoizpcclxu5Yid5aeL5YWz6ZSu5a2X5bqP5YiXOiAgICA5ICAgICAxMyAgICAgOCAgICAgIDIgICAgICA1ICAgICAgMTMgICAgICA3ICAgICAgMSAgICAgIDE1ICAgICAgMTFcclxu56ys5LiA6Laf5o6S5bqP5ZCOOiAgICAgIDkgICAgIDcgICAgICAxICAgICAgMiAgICAgIDUgICAgICAxMyAgICAgIDEzICAgICA4ICAgICAgMTUgICAgICAxMVxyXG7nrKzkuozotp/mjpLluo/lkI46ICAgICAgMiAgICAgNSAgICAgIDEgICAgICA5ICAgICAgNyAgICAgIDEzICAgICAgMTEgICAgIDggICAgICAxNSAgICAgIDEzXHJcbuesrOS4iei2n+aOkuW6j+WQjjogICAgICAxICAgICAyICAgICAgNSAgICAgIDcgICAgICA4ICAgICAgOSAgICAgIDExICAgICAxMyAgICAgIDEzICAgICAgMTVcclxuXHJcblxyXG7luIzlsJTmjpLluo/nmoTliIbmnpDmr5TovoPlpI3mnYLvvIzmtonlj4rkuIDkupvmlbDlrabkuIrnmoTpl67popjvvIzlhbbml7bpl7TmmK/miYDlj5bnmoTigJzlop7ph4/igJ3luo/liJfnmoTlh73mlbDjgIJcclxuXHJcbuW4jOWwlOaOkuW6j+eJueeCuVxyXG7lrZDluo/liJfnmoTmnoTmiJDkuI3mmK/nroDljZXnmoTigJzpgJDmrrXliIblibLigJ3vvIzogIzmmK/lsIbnm7jpmpTmn5DkuKrlop7ph4/nmoTorrDlvZXnu4TmiJDkuIDkuKrlrZDluo/liJfjgIJcclxu5biM5bCU5o6S5bqP5Y+v5o+Q6auY5o6S5bqP6YCf5bqm77yM5Y6f5Zug5piv77yaXHJcbuKXhiDliIbnu4TlkI5u5YC85YeP5bCP77yMbsKy5pu05bCP77yM6ICMVChuKT1PKG7Csiks5omA5LulVChuKeS7juaAu+S9k+S4iueci+aYr+WHj+Wwj+S6hu+8m1xyXG7il4Yg5YWz6ZSu5a2X6L6D5bCP55qE6K6w5b2V6Lez6LeD5byP5YmN56e777yM5Zyo6L+b6KGM5pyA5ZCO5LiA6Laf5aKe6YeP5Li6MeeahOaPkuWFpeaOkuW6j+aXtu+8jOW6j+WIl+W3suWfuuacrOacieW6j+OAglxyXG5cclxu5aKe6YeP5bqP5YiX5Y+W5rOVXHJcbuKXhiDml6DpmaQx5Lul5aSW55qE5YWs5Zug5a2Q77ybXHJcbuKXhiDmnIDlkI7kuIDkuKrlop7ph4/lgLzlv4XpobvkuLox44CCXHJcblxyXG7nm7jlhbPotYTmlpnvvJogaHR0cDovL3dlbmt1LmJhaWR1LmNvbS9saW5rP3VybD1xN2t6T3hYcWMwQkxhR1VWRFk0M0ZRT2gyYVgxVXFCSGtrWWQzVk13SmhKbzZydjRTaVU2ODZSVzNrUUNTcUdFS3l0bDEyUzhmQk9wd2hxLXJ1bmhYX3BiWmNnNkJlRC1taVlNUGdEaFh4S1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNoZWxsSW5zZXJ0KHNxTGlzdCwgZGssIGNvbXApIHtcclxuICAgIGZvciAodmFyIGkgPSBkaywgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBzcUxpc3RbaV07XHJcbiAgICAgICAgaWYgKGNvbXAodGVtcCwgc3FMaXN0W2kgLSBka10pIDwgMCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIGRrOyBqID49IDAgJiYgY29tcCh0ZW1wLCBzcUxpc3Rbal0pIDwgMDsgaiAtPSBkaylcclxuICAgICAgICAgICAgICAgIHNxTGlzdFtqICsgZGtdID0gc3FMaXN0W2pdO1xyXG5cclxuICAgICAgICAgICAgc3FMaXN0W2ogKyBka10gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2hlbGxTb3J0KHNxTGlzdCwgY29tcCkge1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgdmFyIGRlbHRhID0gY3JlYXRlRGVsdGEoc3FMaXN0Lmxlbmd0aCk7XHJcbiAgICAvL2NvbnNvbGUubG9nKGRlbHRhKTtcclxuICAgIGZvciAodmFyIGsgPSAwLCB0ID0gZGVsdGEubGVuZ3RoOyBrIDwgdDsgKytrKSB7XHJcbiAgICAgICAgc2hlbGxJbnNlcnQoc3FMaXN0LCBkZWx0YVtrXSwgY29tcCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zaGVsbFNvcnQgPSBzaGVsbFNvcnQ7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEZWx0YShuKSB7XHJcbiAgICB2YXIgYXJyID0gW107XHJcbiAgICB2YXIgdCA9IChNYXRoLmxvZyhuIC0gMSkgLyBNYXRoLmxvZygyKSkgfCAwOyAgLy8gTWF0aC5sb2cobiAtIDEpIC8gTWF0aC5sb2coMiksIE1hdGgubG9nKG4gKyAxKSAvIE1hdGgubG9nKDIpXHJcbiAgICBmb3IodmFyIGsgPSAwOyBrIDw9IHQ7ICsraylcclxuICAgICAgICBhcnJba10gPSBNYXRoLnBvdygyLCB0IC0gaykgKyAxOyAgICAvLyBNYXRoLnBvdygyLCB0IC0gaSArIDEpIC0gMSwgTWF0aC5wb3coMiwgdCAtIGkpICsgMVxyXG5cclxuICAgIGFyclthcnIubGVuZ3RoXSA9IDE7XHJcblxyXG4gICAgcmV0dXJuIGFycjtcclxufVxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCdcXG5cXG5TaGVsbCBTb3J0OicpO1xyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG5zaGVsbFNvcnQoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvaW5zZXJ0aW9uL2luZGV4LmpzXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMi83LlxyXG4gKi9cclxuaW1wb3J0IExpbmtlZExpc3QgZnJvbSAnLi4vLi4vTGlzdC9MaW5rZWRMaXN0JztcclxuaW1wb3J0IFF1ZXVlIGZyb20gJy4uLy4uL1F1ZXVlL1F1ZXVlJztcclxudmFyIGRlZmF1bHRDb21wYXJlID0gcmVxdWlyZSgnLi4vZGVmYXVsdENvbXBhcmlzaW9uJyk7XHJcblxyXG4vKlxyXG4g5b2S5bm25o6S5bqPXHJcblxyXG4g5b2S5bm2KE1lcmdpbmcpIO+8muaYr+aMh+WwhuS4pOS4quaIluS4pOS4quS7peS4iueahOacieW6j+W6j+WIl+WQiOW5tuaIkOS4gOS4quacieW6j+W6j+WIl+OAguiLpemHh+eUqOe6v+aAp+ihqCjml6DorrrmmK/pgqPnp43lrZjlgqjnu5PmnoQp5piT5LqO5a6e546w77yM5YW25pe26Ze05aSN5p2C5bqm5Li6TyhtK24pIOOAglxyXG4g5b2S5bm25oCd5oOz5a6e5L6L77ya5Lik5aCG5omR5YWL54mM77yM6YO95bey5LuO5bCP5Yiw5aSn5o6S5aW95bqP77yM6KaB5bCG5Lik5aCG5ZCI5bm25Li65LiA5aCG5LiU6KaB5rGC5LuO5bCP5Yiw5aSn5o6S5bqP44CCXHJcbiDil4YgIOWwhuS4pOWghuacgOS4iumdoueahOaKveWHuijorr7kuLpDMe+8jEMyKeavlOi+g+Wkp+Wwj++8jOWwhuWwj+iAhee9ruS6juS4gOi+ueS9nOS4uuaWsOeahOS4gOWghijkuI3lpqjorr5DMTxDMinvvJvlho3ku47nrKzkuIDloIbkuK3mir3lh7rkuIDlvKDnu6fnu63kuI5DMui/m+ihjOavlOi+g++8jOWwhui+g+Wwj+eahOaUvue9ruWcqOaWsOWghueahOacgOS4i+mdou+8m1xyXG4g4peGIOmHjeWkjeS4iui/sOi/h+eoi++8jOebtOWIsOafkOS4gOWghuW3suaKveWujO+8jOeEtuWQjuWwhuWJqeS4i+S4gOWghuS4reeahOaJgOacieeJjOi9rOenu+WIsOaWsOWghuS4reOAglxyXG5cclxuIDEgICDmjpLluo/mgJ3mg7NcclxuIOKRoCAg5Yid5aeL5pe277yM5bCG5q+P5Liq6K6w5b2V55yL5oiQ5LiA5Liq5Y2V54us55qE5pyJ5bqP5bqP5YiX77yM5YiZbuS4quW+heaOkuW6j+iusOW9leWwseaYr27kuKrplb/luqbkuLox55qE5pyJ5bqP5a2Q5bqP5YiX77ybXHJcbiDikaEgIOWvueaJgOacieacieW6j+WtkOW6j+WIl+i/m+ihjOS4pOS4pOW9kuW5tu+8jOW+l+WIsO+DqW4vMu+DueS4qumVv+W6puS4ujLmiJYx55qE5pyJ5bqP5a2Q5bqP5YiX4oCU4oCU5LiA6Laf5b2S5bm277ybXHJcbiDikaIgIOmHjeWkjeKRoSDvvIznm7TliLDlvpfliLDplb/luqbkuLpu55qE5pyJ5bqP5bqP5YiX5Li65q2i44CCXHJcblxyXG4g5LiK6L+w5o6S5bqP6L+H56iL5Lit77yM5a2Q5bqP5YiX5oC75piv5Lik5Lik5b2S5bm277yM56ew5Li6Mi3ot6/lvZLlubbmjpLluo/jgILlhbbmoLjlv4PmmK/lpoLkvZXlsIbnm7jpgrvnmoTkuKTkuKrlrZDluo/liJflvZLlubbmiJDkuIDkuKrlrZDluo/liJfjgILorr7nm7jpgrvnmoTkuKTkuKrlrZDluo/liJfliIbliKvkuLrvvJpcclxuIHtSW2tdLCBSW2srMV0sIOKApiwgUlttXX3lkox7UlttKzFdLCBSW20rMl0s4oCmLCBSW2hdfe+8jOWwhuWug+S7rOW9kuW5tuS4uuS4gOS4quacieW6j+eahOWtkOW6j+WIl++8mlxyXG4ge0RSW2xdLCBEUltsKzFdLCDigKYsIERSW21dLCBEUlttKzFdLCDigKYsIERSW2hdIH1cclxuXHJcbiDkvovvvJrorr7mnIk55Liq5b6F5o6S5bqP55qE6K6w5b2V77yM5YWz6ZSu5a2X5YiG5Yir5Li6MjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0Me+8jOW9kuW5tuaOkuW6j+eahOi/h+eoi+OAglxyXG4g5Yid5aeL5YWz6ZSu5a2XOiBbMjNdICAgWzM4XSAgIFsyMl0gICBbNDVdICAgWzIzXSAgIFs2N10gICBbMzFdICAgWzE1XSAgIFs0MV1cclxuICAgICAgICAgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfFxyXG4gICAgICAgICAgICAgIC0tLS0tLS0tICAgICAgLS0tLS0tLS0gICAgICAtLS0tLS0tLSAgICAgIC0tLS0tLS0tXHJcbiDkuIDotp/lvZLlubblkI46IFsyMyAgICAzOF0gICAgWzIyICAgICA0NV0gICAgWzIzICAgICA2N10gICAgWzE1ICAgICAzMV0gICBbNDFdXHJcbiAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tXHJcbiDkuozotp/lvZLlubblkI46IFsyMiAgICAgMjMgICAgICAzOCAgICAgNDVdICAgIFsxNSAgICAgMjMgICAgIDMxICAgICA2N10gICAgWzQxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4g5LiJ6Laf5b2S5bm25ZCOOiBbMTUgICAgIDIyICAgICAgMjMgICAgIDIzICAgICAzMSAgICAgMzggICAgIDQ1ICAgICA2N10gICAgWzQxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuIOWbm+i2n+W9kuW5tuWQjjogWzE1ICAgICAyMiAgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgIDY3XHJcblxyXG5cclxuIDIgIOS4gOi2n+W9kuW5tuaOkuW6j1xyXG4g5LiA6Laf5b2S5bm25o6S5bqP6YO95piv5LuO5YmN5Yiw5ZCO77yM5L6d5qyh5bCG55u46YK755qE5Lik5Liq5pyJ5bqP5a2Q5bqP5YiX5b2S5bm25Li65LiA5Liq77yM5LiU6Zmk5pyA5ZCO5LiA5Liq5a2Q5bqP5YiX5aSW77yM5YW25L2Z5q+P5Liq5a2Q5bqP5YiX55qE6ZW/5bqm6YO955u45ZCM44CC6K6+6L+Z5Lqb5a2Q5bqP5YiX55qE6ZW/5bqm5Li6ZO+8jOWImeS4gOi2n+W9kuW5tuaOkuW6j+eahOi/h+eoi+aYr++8mlxyXG4g5LuOaj0w5byA5aeL77yM5L6d5qyh5bCG55u46YK755qE5Lik5Liq5pyJ5bqP5a2Q5bqP5YiXXHJcbiBSW2rigKZqK2QtMV3lkoxSW2orZOKApmorMmQtMV3ov5vooYzlvZLlubbvvJvmr4/mrKHlvZLlubbkuKTkuKrlrZDluo/liJflkI7vvIxq5ZCO56e75YqoMmTkuKrkvY3nva7vvIzljbNcclxuIGo9aisyZO+8m+iLpeWJqeS4i+eahOWFg+e0oOS4jei2s+S4pOS4quWtkOW6j+WIl+aXtu+8jOWIhuS7peS4i+S4pOenjeaDheWGteWkhOeQhu+8mlxyXG4g4pGgICDliankuIvnmoTlhYPntKDkuKrmlbA+ZO+8muWGjeiwg+eUqOS4gOasoeS4iui/sOi/h+eoi++8jOWwhuS4gOS4qumVv+W6puS4umTnmoTlrZDluo/liJflkozkuI3otrNk55qE5a2Q5bqP5YiX6L+b6KGM5b2S5bm277ybXHJcbiDikaEgIOWJqeS4i+eahOWFg+e0oOS4quaVsOKJpGTvvJrlsIbliankuIvnmoTlhYPntKDkvp3mrKHlpI3liLbliLDlvZLlubblkI7nmoTluo/liJfkuK3jgIJcclxuXHJcblxyXG4gMy7nrpfms5XliIbmnpBcclxu5YW35pyJbuS4quW+heaOkuW6j+iusOW9leeahOW9kuW5tuasoeaVsOaYr+OPkjJu77yM6ICM5LiA6Laf5b2S5bm255qE5pe26Ze05aSN5p2C5bqm5Li6TyhuKe+8jOWImeaVtOS4quW9kuW5tuaOkuW6j+eahOaXtumXtOWkjeadguW6puaXoOiuuuaYr+acgOWlvei/mOaYr+acgOWdj+aDheWGteWdh+S4uk8obuOPkjJuKeOAguWcqOaOkuW6j+i/h+eoi+S4re+8jOS9v+eUqOS6hui+heWKqeWQkemHj0RS77yM5aSn5bCP5LiO5b6F5o6S5bqP6K6w5b2V56m66Ze055u45ZCM77yM5YiZ56m66Ze05aSN5p2C5bqm5Li6TyhuKeOAguW9kuW5tuaOkuW6j+aYr+eos+WumueahOOAglxyXG5cclxuICovXHJcblxyXG52YXIgbkNvdW50ID0gMDtcclxudmFyIG5vblJlY3Vyc2l2ZUNvdW50ID0gMDtcclxudmFyIHJlY3Vyc2l2ZUNvdW50ID0gMDtcclxuXHJcbi8qKlxyXG4gKiDlsIbmnInluo/nmoRzcltzMS4uZTFd5ZKMc3JbczIuLmUyXeW9kuW5tuS4uuacieW6j+eahHRyW3MxLi5lMl1cclxuICogQHBhcmFtIHNyXHJcbiAqIEBwYXJhbSBzMVxyXG4gKiBAcGFyYW0gZTFcclxuICogQHBhcmFtIGUyXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZShzciwgczEsIGUxLCBlMiwgY29tcCl7XHJcbiAgICB2YXIgdGVtcCA9IFtdO1xyXG4gICAgdmFyIGkgPSBzMTtcclxuICAgIHZhciBqID0gZTEgKyAxO1xyXG4gICAgdmFyIGsgPSAwO1xyXG5cclxuICAgIHdoaWxlKGkgPD0gZTEgJiYgaiA8PSBlMil7XHJcbiAgICAgICAgaWYoY29tcChzcltpXSwgc3Jbal0pIDwgMCkgdGVtcFtrKytdID0gc3JbaSsrXTtcclxuICAgICAgICBlbHNlIHRlbXBbaysrXSA9IHNyW2orK107XHJcbiAgICB9XHJcbiAgICB3aGlsZShpIDw9IGUxKSB0ZW1wW2srK10gPSBzcltpKytdO1xyXG4gICAgd2hpbGUoaiA8PSBlMikgdGVtcFtrKytdID0gc3JbaisrXTtcclxuXHJcbiAgICAvLyDlpI3liLblm57ljrtcclxuICAgIGZvcihpID0gczEsIGsgPSAwOyBpIDw9IGUyOyArK2ksICsraykgc3JbaV0gPSB0ZW1wW2tdO1xyXG59XHJcblxyXG4vKipcclxuICogMi3ot6/lvZLlubbmjpLluo/pgJLlvZLnrpfms5VcclxuICogQHBhcmFtIHtBcnJheX0gc3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlU29ydFJlY3Vyc2l2ZShzciwgcywgdCwgY29tcCl7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICBpZihzID09IG51bGwpIHMgPSAwO1xyXG4gICAgaWYodCA9PSBudWxsKSB0ID0gc3IubGVuZ3RoIC0gMTtcclxuXHJcbiAgICBpZihzID49IHQpIHJldHVybjtcclxuXHJcbiAgICAvLyDlsIZzcltzLi50XeW5s+WIhuS4unNyW3MuLm1d5ZKMc3JbbSsxLi50XVxyXG4gICAgdmFyIG0gPSAocyArIHQpID4+IDE7XHJcbiAgICAvLyDpgJLlvZLlnLDlsIZzcltzLi5tXeW9kuW5tuS4uuacieW6j+eahHNyW3MuLm1dXHJcbiAgICBtZXJnZVNvcnRSZWN1cnNpdmUoc3IsIHMsIG0sIGNvbXApO1xyXG4gICAgLy8g6YCS5b2S5Zyw5bCGc3JbbSsxLi50XeW9kuW5tuS4uuacieW6j+eahHNyW20rMS4udF1cclxuICAgIG1lcmdlU29ydFJlY3Vyc2l2ZShzciwgbSArIDEsIHQsIGNvbXApO1xyXG4gICAgLy8g5bCGc3Jbcy4ubV3lkoxzclttKzEuLnRd5b2S5bm25Yiwc3Jbcy4udF07XHJcbiAgICBtZXJnZShzciwgcywgbSwgdCwgY29tcCk7XHJcbn1cclxuZXhwb3J0cy5tZXJnZVNvcnRSZWN1cnNpdmUgPSBtZXJnZVNvcnRSZWN1cnNpdmU7XHJcblxyXG5cclxuY29uc29sZS5sb2coJ1xcblxcbm1lcmdlU29ydFJlY3Vyc2l2ZTonKTtcclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxubWVyZ2VTb3J0UmVjdXJzaXZlKGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gbWVyZ2VTb3J0Tm9uUmVjdXJzaXZlKHNyLCBjb21wKXtcclxuICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIHZhciBqLCBrO1xyXG4gICAgZm9yKHZhciBkID0gMSwgbiA9IHNyLmxlbmd0aCAtIDE7IGQgPCBuOyBkICo9IDIpIHtcclxuICAgICAgICAvLyDkuIDotp/lvZLlubbmjpLluo/nrpfms5VcclxuICAgICAgICBqID0gMDtcclxuXHJcbiAgICAgICAgLy8g5a2Q5bqP5YiX5Lik5Lik5b2S5bm2XHJcbiAgICAgICAgd2hpbGUoKGsgPSAoaiArIDIgKiBkIC0gMSkpIDwgbil7XHJcbiAgICAgICAgICAgIG1lcmdlKHNyLCBqLCAgaiArIGQgLSAxLCBrLCBjb21wKTtcclxuICAgICAgICAgICAgaiA9IGsgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Ymp5L2Z5YWD57Sg5Liq5pWw6LaF6L+H5LiA5Liq5a2Q5bqP5YiX6ZW/5bqmXHJcbiAgICAgICAgaWYoaiArIGQgLSAxIDwgbikgbWVyZ2Uoc3IsIGosIGogKyBkIC0gMSwgbiwgY29tcCk7XHJcbiAgICAgICAgLy8g5Ymp5L2Z5a2Q5bqP5YiX5aSN5Yi2XHJcbiAgICAgICAgZWxzZSBtZXJnZShzciwgaiwgbiwgbiwgY29tcCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5tZXJnZVNvcnROb25SZWN1cnNpdmUgPSBtZXJnZVNvcnROb25SZWN1cnNpdmU7XHJcblxyXG5jb25zb2xlLmxvZygnXFxubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlOicpO1xyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG5tZXJnZVNvcnROb25SZWN1cnNpdmUoYXJyKTtcclxuY29uc29sZS5sb2coYXJyICsgJycpO1xyXG5cclxuXHJcbi8vIOiHqueEtuWQiOW5tuaOkuW6j1xyXG4vLyBodHRwOi8vd3d3LmNuYmxvZ3MuY29tL2xpdXNoYW5nMDQxOS9hcmNoaXZlLzIwMTEvMDkvMTkvMjE4MTQ3Ni5odG1sXHJcbi8vIGh0dHA6Ly93d3cuY25ibG9ncy5jb20vbGFua2UvYXJjaGl2ZS8yMDEzLzAxLzE1LzI4NjA0ODcuaHRtbFxyXG4vKlxyXG7oh6rnhLblvZLlubbmmK/lvZLlubbmjpLluo/nmoTkuIDkuKrlj5jlvaLvvIzmlYjnjofmm7Tpq5jkuIDkupvvvIzlj6/ku6XlnKjlvZLlubbmjpLluo/pnZ7pgJLlvZLlrp7njrDnmoTln7rnoYDkuIrov5vooYzkv67mlLku5a+55LqO5bey57uP5LiA5Liq5bey57uP57uZ5a6a5pWw57uEYSzpgJrluLjlrZjlnKjlpJrkuKrplb/luqblpKfkuo4x55qE5bey57uP6Ieq54S25o6S5aW955qE5a2Q5pWw57uE5q61LOWboOatpOeUqOS4gOasoeWvueaVsOe7hGHnmoTnur/mgKfmiavmj4/lsLHlj6/ku6Xmib7lh7rmiYDmnInov5nkupvmjpLlpb3luo/nmoTlrZDmlbDnu4TmrrUs54S25ZCO5YaN5a+56L+Z5Lqb5a2Q5pWw57uE5q615L+p5L+p5ZCI5bm2LlxyXG4gKi9cclxuXHJcblxyXG4vLyDmiavmj4/lvpfliLDlrZDkuLLnmoTlh73mlbBcclxuZnVuY3Rpb24gcGFzcyhzcUxpc3QsIHJlYywgY29tcCl7XHJcbiAgICB2YXIgbnVtID0gMDtcclxuICAgIHJlY1tudW0rK10gPSAwO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSl7XHJcbiAgICAgICAgaWYoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkgcmVjW251bSsrXSA9IGkgKyAxO1xyXG4gICAgfVxyXG4gICAgcmVjW251bSsrXSA9IGxlbjtcclxuXHJcbiAgICByZXR1cm4gbnVtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBuYXR1cmVNZXJnZVNvcnQoc3FMaXN0LCBjb21wKXtcclxuICAgIGlmIChjb21wID09IG51bGwpIGNvbXAgPSBkZWZhdWx0Q29tcGFyZTtcclxuICAgIHZhciByZWMgPSBbXTtcclxuXHJcbiAgICAvL251bT0y6K+05piO5bey57uP5o6S5aW95bqP5LqGXHJcbiAgICAvL+avj+W+queOr+S4gOasoe+8jOi/m+ihjOS4gOasoXBhc3MoKeaTjeS9nFxyXG4gICAgZm9yKHZhciBudW0gPSBwYXNzKHNxTGlzdCwgcmVjLCBjb21wKTsgbnVtICE9PSAyOyBudW0gPSBwYXNzKHNxTGlzdCwgcmVjLCBjb21wKSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSArIDIgPCBudW07IGkgKz0gMikge1xyXG4gICAgICAgICAgICBtZXJnZShzcUxpc3QsIHJlY1tpXSwgcmVjW2kgKyAxXSAtIDEsIHJlY1tpICsgMl0gLSAxLCBjb21wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMubmF0dXJlTWVyZ2VTb3J0ID0gbmF0dXJlTWVyZ2VTb3J0O1xyXG5cclxuY29uc29sZS5sb2coJ1xcbm5hdHVyZU1lcmdlU29ydDonKTtcclxudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcclxubmF0dXJlTWVyZ2VTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG5jb25zb2xlLmxvZyhyZWN1cnNpdmVDb3VudCk7XHJcbmNvbnNvbGUubG9nKG5vblJlY3Vyc2l2ZUNvdW50KTtcclxuY29uc29sZS5sb2cobkNvdW50KTtcclxuXHJcbi8vIOWPjOWQkeiHqueEtuWQiOW5tuaOkuW6j+eul+azlVxyXG4vKlxyXG7lj4zlkJHoh6rnhLblkIjlubbmjpLluo/mmK/moLnmja7mrLLmjpLluo/mlbDmja7lsYDpg6jkuI3mmK/ljYfluo/lsLHmmK/pmY3luo/nmoToh6rnhLbmnInluo/nibnngrks5YWI57q/5oCn5omr5o+P5Ye66Ieq54S25pyJ5bqP55qE5a2Q5pWw57uE5q61LOWGjei/m+ihjOWQiOW5tuaOkuW6jy7miavmj4/ml7bnmoTmnInluo/mlbDmrrXplb/luqbotorplb8s5q615pWw6LaK5bCRLOWvueW6lOWQiOW5tuagkeeahOWxguaVsOWwseS8mui2iuWwkSznrpfms5XnmoTmlYjnjofotorpq5guXHJcbiAqL1xyXG52YXIgbmF0dXJhbE1lcmdlU29ydCA9IChmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG5hdHVyYWxNZXJnZVNvcnQ7XHJcblxyXG4gICAgZnVuY3Rpb24gbmF0dXJhbE1lcmdlU29ydChhLCBjb21wKXtcclxuICAgICAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICAgICAgdmFyIGIgPSBbXTtcclxuICAgICAgICB2YXIgbiA9IGEubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKCFtZXJnZVJ1bnMoYSwgYiwgbiwgY29tcCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlUnVucyhhLCBiLCBuLCBjb21wKXtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgIHZhciBhc2MgPSB0cnVlO1xyXG4gICAgICAgIHZhciB4O1xyXG5cclxuICAgICAgICB3aGlsZShpIDwgbil7XHJcbiAgICAgICAgICAgIGsgPSBpO1xyXG4gICAgICAgICAgICAvLyDmib7liLDmnIDlkI7kuIDkuKrpgJLlop7luo/liJflhYPntKBcclxuICAgICAgICAgICAgZG8geCA9IGFbaSsrXTsgd2hpbGUoaSA8IG4gJiYgY29tcCh4LCBhW2ldKSA8PSAwKTtcclxuICAgICAgICAgICAgLy8g5om+5Yiw5pyA5ZCO5LiA5Liq6YCS5YeP5bqP5YiX5YWD57SgXHJcbiAgICAgICAgICAgIHdoaWxlKGkgPCBuICYmIGNvbXAoeCwgYVtpXSkgPj0gMCkgeCA9IGFbaSsrXTtcclxuICAgICAgICAgICAgLy8g5b2S5bm26YCS5aKe5bqP5YiX5ZKM6YCS5YeP5bqP5YiX77yM57uT5p6c5Y+v6IO96YCS5aKe5oiW6YCS5YePXHJcbiAgICAgICAgICAgIG1lcmdlKGEsIGIsIGssIGkgLSAxLCBhc2MsIGNvbXApO1xyXG4gICAgICAgICAgICBhc2MgPSAhYXNjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5b2Ta+etieS6jjDml7bku6Pooahh5bey57uP5o6S5aW95bqP5LqGXHJcbiAgICAgICAgcmV0dXJuIGsgPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyZ2UoYSwgYiwgbG93LCBoaWdoLCBhc2MsIGNvbXApe1xyXG4gICAgICAgIHZhciBrID0gYXNjID8gbG93IDogaGlnaDtcclxuICAgICAgICB2YXIgYyA9IGFzYyA/IDEgOiAtMTtcclxuICAgICAgICB2YXIgaSA9IGxvdztcclxuICAgICAgICB2YXIgaiA9IGhpZ2g7XHJcblxyXG4gICAgICAgIHdoaWxlKGkgPD0gail7XHJcbiAgICAgICAgICAgIGlmKGNvbXAoYVtpXSwgYVtqXSkgPD0gMCkgYltrXSA9IGFbaSsrXTtcclxuICAgICAgICAgICAgZWxzZSBiW2tdID0gYVtqLS1dO1xyXG4gICAgICAgICAgICBrICs9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihpID0gayA9IGxvdywgaiA9IGhpZ2g7IGkgPD0gajsgKytpLCArK2spIGFbaV0gPSBiW2tdO1xyXG4gICAgfVxyXG59KSgpO1xyXG5cclxuZXhwb3J0cy5uYXR1cmFsTWVyZ2VTb3J0ID0gbmF0dXJhbE1lcmdlU29ydDtcclxuXHJcbmNvbnNvbGUubG9nKCdcXG5uYXR1cmFsTWVyZ2VTb3J0OicpO1xyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG5uYXR1cmFsTWVyZ2VTb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vLyDpk77ooajlrZjlgqjnu5PmnoTnmoToh6rnhLblkIjlubbmjpLluo9cclxudmFyIGxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0ID0gKGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gbWVyZ2VTb3J0O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChsaW5rZWRsaXN0LCBuZWVkUmVwbGFjZSwgY29tcCl7XHJcbiAgICAgICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgICAgIGlmKCFsaW5rZWRsaXN0KSByZXR1cm4gbGlua2VkbGlzdDtcclxuXHJcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBsaW5rZWRsaXN0LmhlYWQ7XHJcblxyXG4gICAgICAgIGlmKCFsaXN0IHx8ICFsaXN0Lm5leHQpIHJldHVybiBsaW5rZWRsaXN0O1xyXG5cclxuICAgICAgICBuZWVkUmVwbGFjZSA9IG5lZWRSZXBsYWNlID09IG51bGwgPyB0cnVlIDogbmVlZFJlcGxhY2U7XHJcbiAgICAgICAgdmFyIHUgPSBsaXN0O1xyXG4gICAgICAgIHZhciB0ID0gbGlzdDtcclxuICAgICAgICB2YXIgdjtcclxuICAgICAgICAvLyDlsIbpgJLlop7nmoTnu5PngrnmlL7lhaXliLDpmJ/liJfkuK3vvIjkvJrooqvliIfmlq3vvIlcclxuICAgICAgICBmb3IoOyB0OyB0ID0gdSl7XHJcbiAgICAgICAgICAgIHdoaWxlKHUgJiYgdS5uZXh0ICYmIGNvbXAodS5kYXRhLCB1Lm5leHQuZGF0YSkgPD0gMClcclxuICAgICAgICAgICAgICAgIHUgPSB1Lm5leHQ7XHJcbiAgICAgICAgICAgIHYgPSB1O1xyXG4gICAgICAgICAgICB1ID0gdS5uZXh0O1xyXG4gICAgICAgICAgICB2Lm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdCA9IHF1ZXVlLmRlUXVldWUoKTtcclxuICAgICAgICAvLyDlkIjlubbnu5PngrlcclxuICAgICAgICB3aGlsZShxdWV1ZS5zaXplKXtcclxuICAgICAgICAgICAgcXVldWUuZW5RdWV1ZSh0KTtcclxuICAgICAgICAgICAgdmFyIGEgPSBxdWV1ZS5kZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHZhciBiID0gcXVldWUuZGVRdWV1ZSgpO1xyXG4gICAgICAgICAgICB0ID0gbWVyZ2UoYSwgYiwgY29tcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihuZWVkUmVwbGFjZSkgbGlua2VkbGlzdC5oZWFkID0gdDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyZ2UoYSwgYiwgY29tcCl7XHJcbiAgICAgICAgdmFyIGMgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG4gICAgICAgIHZhciBoZWFkID0ge2RhdGE6IG51bGwsIG5leHQ6IG51bGx9O1xyXG4gICAgICAgIGMuaGVhZCA9IGhlYWQ7XHJcbiAgICAgICAgYyA9IGMuaGVhZDtcclxuXHJcbiAgICAgICAgd2hpbGUoYSAmJiBiKXtcclxuICAgICAgICAgICAgaWYoY29tcChhLmRhdGEsIGIuZGF0YSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjLm5leHQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYyA9IGE7XHJcbiAgICAgICAgICAgICAgICBhID0gYS5uZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5uZXh0ID0gYjtcclxuICAgICAgICAgICAgICAgIGMgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IGIubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYy5uZXh0ID0gYSA/IGEgOiBiO1xyXG5cclxuICAgICAgICByZXR1cm4gaGVhZC5uZXh0O1xyXG4gICAgfVxyXG59KSgpO1xyXG5leHBvcnRzLmxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0ID0gbGlua2VkTGlzdE5hdHVyYWxNZXJnZVNvcnQ7XHJcblxyXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xyXG52YXIgbGlua2VkTGlzdCA9IG5ldyBMaW5rZWRMaXN0KGFycik7XHJcbmxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0KGxpbmtlZExpc3QpO1xyXG5jb25zb2xlLmxvZyhsaW5rZWRMaXN0ICsgJycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvbWVyZ2luZy9pbmRleC5qc1xuICoqLyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGx1a2Ugb24gMjAxNS8yLzIuXHJcbiAqL1xyXG5cclxudmFyIGRlZmF1bHRDb21wYXJlID0gcmVxdWlyZSgnLi4vZGVmYXVsdENvbXBhcmlzaW9uJyk7XHJcblxyXG4vKlxyXG7pgInmi6nmjpLluo9cclxuXHJcbumAieaLqeaOkuW6jyhTZWxlY3Rpb24gU29ydCnnmoTln7rmnKzmgJ3mg7PmmK/vvJrmr4/mrKHku47lvZPliY3lvoXmjpLluo/nmoTorrDlvZXkuK3pgInlj5blhbPplK7lrZfmnIDlsI/nmoTorrDlvZXooajvvIznhLblkI7kuI7lvoXmjpLluo/nmoTorrDlvZXluo/liJfkuK3nmoTnrKzkuIDkuKrorrDlvZXov5vooYzkuqTmjaLvvIznm7TliLDmlbTkuKrorrDlvZXluo/liJfmnInluo/kuLrmraLjgIJcclxuXHJcblxyXG7nroDljZXpgInmi6nmjpLluo9cclxuXHJcbueugOWNlemAieaLqeaOkuW6jyhTaW1wbGUgU2VsZWN0aW9uIFNvcnQg77yM5Y+I56ew5Li655u05o6l6YCJ5oup5o6S5bqPKeeahOWfuuacrOaTjeS9nOaYr++8mumAmui/h24taeasoeWFs+mUruWtl+mXtOeahOavlOi+g++8jOS7jm4taSsx5Liq6K6w5b2V5Lit6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V77yM54S25ZCO5ZKM56ysaeS4quiusOW9lei/m+ihjOS6pOaNou+8jGk9MSwgMiwg4oCmIG4tMSDjgIJcclxuMSAg5o6S5bqP56S65L6LXHJcbuS+i++8muiuvuacieWFs+mUruWtl+W6j+WIl+S4uu+8mjcsIDQsIC0yLCAxOSwgMTMsIDbvvIznm7TmjqXpgInmi6nmjpLluo/nmoTov4fnqIvvvJpcclxu5Yid5aeL6K6w5b2V55qE5YWz6ZSu5a2X77yaICA3ICAgICA0ICAgIC0yICAgICAxOSAgICAxMyAgICA2XHJcbiAgICDnrKzkuIDotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA3ICAgICAxOSAgICAxMyAgICA2XHJcbiAgICDnrKzkuozotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA3ICAgICAxOSAgICAxMyAgICA2XHJcbiAgICDnrKzkuInotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICAxOSAgICAxMyAgICA3XHJcbiAgICDnrKzlm5votp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICA3ICAgICAxMyAgICAxOVxyXG4gICAg56ys5LqU6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgNyAgICAgMTMgICAgMTlcclxuICAgIOesrOWFrei2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDcgICAgIDEzICAgIDE5XHJcblxyXG4yLueul+azleWIhuaekFxyXG7mlbTkuKrnrpfms5XmmK/kuozph43lvqrnjq/vvJrlpJblvqrnjq/mjqfliLbmjpLluo/nmoTotp/mlbDvvIzlr7lu5Liq6K6w5b2V6L+b6KGM5o6S5bqP55qE6Laf5pWw5Li6bi0x6Laf77yb5YaF5b6q546v5o6n5Yi25q+P5LiA6Laf55qE5o6S5bqP44CCXHJcbui/m+ihjOesrGnotp/mjpLluo/ml7bvvIzlhbPplK7lrZfnmoTmr5TovoPmrKHmlbDkuLpuLWnvvIzliJnvvJpcclxu5q+U6L6D5qyh5pWw77yaIG4qKG4gLSAxKSAvIDJcclxu5pe26Ze05aSN5p2C5bqm5piv77yaVChuKT1PKG4yKVxyXG7nqbrpl7TlpI3mnYLluqbmmK/vvJpTKG4pPU8oMSlcclxu5LuO5o6S5bqP55qE56iz5a6a5oCn5p2l55yL77yM55u05o6l6YCJ5oup5o6S5bqP5piv5LiN56iz5a6a55qE44CCXHJcblxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb25Tb3J0KHNxTGlzdCwgY29tcCkge1xyXG4gICAgaWYgKGNvbXAgPT0gbnVsbCkgY29tcCA9IGRlZmF1bHRDb21wYXJlO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIGZvciAodmFyIGsgPSBpLCBqID0gayArIDE7IGogPCBsZW47ICsrailcclxuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2pdLCBzcUxpc3Rba10pIDwgMCkgayA9IGo7XHJcblxyXG4gICAgICAgIGlmIChrICE9PSBpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2tdO1xyXG4gICAgICAgICAgICBzcUxpc3Rba10gPSBzcUxpc3RbaV07XHJcbiAgICAgICAgICAgIHNxTGlzdFtpXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc2ltcGxlU2VsZWN0aW9uU29ydCA9IHNpbXBsZVNlbGVjdGlvblNvcnQ7XHJcblxyXG52YXIgYXJyID0gWzcsIDQsIC0yLCAxOSwgMTMsIDZdO1xyXG5zaW1wbGVTZWxlY3Rpb25Tb3J0KGFycik7XHJcbmNvbnNvbGUubG9nKGFyciArICcnKTtcclxuXHJcblxyXG4vKlxyXG7moJHlvaLpgInmi6nmjpLluo9cclxuXHJcbummluWFiOWvuW7kuKrorrDlvZXnmoTlhbPplK7lrZfkuKTkuKTov5vooYzmr5TovoPvvIzpgInlj5bvg6luLzLvg7nkuKrovoPlsI/ogIXvvJvnhLblkI7ov5nvg6luLzLvg7nkuKrovoPlsI/ogIXkuKTkuKTov5vooYzmr5TovoPvvIzpgInlj5bvg6luLzTvg7nkuKrovoPlsI/ogIXigKYg5aaC5q2k6YeN5aSN77yM55u05Yiw5Y+q5YmpMeS4quWFs+mUruWtl+S4uuatouOAglxyXG7or6Xov4fnqIvlj6/nlKjkuIDmo7XmnIlu5Liq5Y+25a2Q57uT54K555qE5a6M5YWo5LqM5Y+J5qCR6KGo56S677yM5q+P5Liq5p6d57uT54K555qE5YWz6ZSu5a2X6YO9562J5LqO5YW25bem44CB5Y+z5a2p5a2Q57uT54K55Lit6L6D5bCP55qE5YWz6ZSu5a2X77yM5qC557uT54K555qE5YWz6ZSu5a2X5bCx5piv5pyA5bCP55qE5YWz6ZSu5a2X44CCXHJcbui+k+WHuuacgOWwj+WFs+mUruWtl+WQju+8jOagueaNruWFs+ezu+eahOWPr+S8oOmAkuaAp++8jOassumAieWPluasoeWwj+WFs+mUruWtl++8jOWPqumcgOWwhuWPtuWtkOe7k+eCueS4reeahOacgOWwj+WFs+mUruWtl+aUueS4uuKAnOacgOWkp+WAvOKAnSDvvIznhLblkI7ph43lpI3kuIrov7DmraXpqqTljbPlj6/jgIJcclxu5ZCr5pyJbuS4quWPtuWtkOe7k+eCueeahOWujOWFqOS6jOWPieagkeeahOa3seW6puS4uu+DqeOPkjJu74O5KzHvvIzliJnmgLvnmoTml7bpl7TlpI3mnYLluqbkuLpPKG7jj5Iybikg44CCXHJcblxyXG7kvYbov5nnp43mjpLluo/mlrnms5XlsJrmnInovoXliqnlrZjlgqjnqbrpl7TovoPlpJos5ZKM5pyA5aSn5YC86L+b6KGM5aSa5L2Z5q+U6L6D562J57y654K544CC5Li65LqG5byl6KGl6L+Z5Lqb57y66Zm377yM5Ye6546w5LqG5Y+m5LiA56eN6YCJ5oup5o6S5bqPLS0t5aCG5o6S5bqPXHJcbiAqL1xyXG5cclxuXHJcblxyXG4vKlxyXG7loIbmjpLluo9cclxuXHJcbjEgIOWghueahOWumuS5iVxyXG7mmK9u5Liq5YWD57Sg55qE5bqP5YiXSD17azEsIGsyICwg4oCmIGtufSDvvIzmu6HotrPvvJpcclxuICAgIGtp4omkazJpICAgICAgIOW9kzJp4omkbuaXtlxyXG4gICAga2niiaRrMmkrMSAgIOW9kzJpKzHiiaRu5pe2XHJcblxyXG7nlLHloIbnmoTlrprkuYnnn6XvvIzloIbmmK/kuIDmo7Xku6VrMeS4uuagueeahOWujOWFqOS6jOWPieagkeOAguiLpeWvueivpeS6jOWPieagkeeahOe7k+eCuei/m+ihjOe8luWPtyjku47kuIrliLDkuIvvvIzku47lt6bliLDlj7Mp77yM5b6X5Yiw55qE5bqP5YiX5bCx5piv5bCG5LqM5Y+J5qCR55qE57uT54K55Lul6aG65bqP57uT5p6E5a2Y5pS+77yM5aCG55qE57uT5p6E5q2j5aW95ZKM6K+l5bqP5YiX57uT5p6E5a6M5YWo5LiA6Ie044CCXHJcblxyXG4yICDloIbnmoTmgKfotKhcclxuICAgIDEpICDloIbmmK/kuIDmo7Xph4fnlKjpobrluo/lrZjlgqjnu5PmnoTnmoTlrozlhajkuozlj4nmoJHvvIwgazHmmK/moLnnu5PngrnvvJtcclxuICAgIDIpICDloIbnmoTmoLnnu5PngrnmmK/lhbPplK7lrZfluo/liJfkuK3nmoTmnIDlsI8o5oiW5pyA5aSnKeWAvO+8jOWIhuWIq+ensOS4uuWwjyjmiJblpKcp5qC55aCG77ybXHJcbiAgICAzKSAg5LuO5qC557uT54K55Yiw5q+P5LiA5Y+25a2Q57uT54K56Lev5b6E5LiK55qE5YWD57Sg57uE5oiQ55qE5bqP5YiX6YO95piv5oyJ5YWD57Sg5YC8KOaIluWFs+mUruWtl+WAvCnpnZ7pgJLlh48o5oiW6Z2e6YCS5aKeKeeahO+8m1xyXG4gICAgNCkgIOWghuS4reeahOS7u+S4gOWtkOagkeS5n+aYr+WghuOAglxyXG5cclxu5Yip55So5aCG6aG26K6w5b2V55qE5YWz6ZSu5a2X5YC85pyA5bCPKOaIluacgOWkpynnmoTmgKfotKjvvIzku47lvZPliY3lvoXmjpLluo/nmoTorrDlvZXkuK3kvp3mrKHpgInlj5blhbPplK7lrZfmnIDlsI8o5oiW5pyA5aSnKeeahOiusOW9le+8jOWwseWPr+S7peWunueOsOWvueaVsOaNruiusOW9leeahOaOkuW6j++8jOi/meenjeaOkuW6j+aWueazleensOS4uuWghuaOkuW6j+OAglxyXG5cclxuMyAg5aCG5o6S5bqP5oCd5oOzXHJcblxyXG7ikaAgIOWvueS4gOe7hOW+heaOkuW6j+eahOiusOW9le+8jOaMieWghueahOWumuS5ieW7uueri+Wghu+8m1xyXG7ikaEgIOWwhuWghumhtuiusOW9leWSjOacgOWQjuS4gOS4quiusOW9leS6pOaNouS9jee9ru+8jOWImeWJjW4tMeS4quiusOW9leaYr+aXoOW6j+eahO+8jOiAjOacgOWQjuS4gOS4quiusOW9leaYr+acieW6j+eahO+8m1xyXG7ikaIgIOWghumhtuiusOW9leiiq+S6pOaNouWQju+8jOWJjW4tMeS4quiusOW9leS4jeWGjeaYr+Wghu+8jOmcgOWwhuWJjW4tMeS4quW+heaOkuW6j+iusOW9lemHjeaWsOe7hOe7h+aIkOS4uuS4gOS4quWghu+8jOeEtuWQjuWwhuWghumhtuiusOW9leWSjOWAkuaVsOesrOS6jOS4quiusOW9leS6pOaNouS9jee9ru+8jOWNs+WwhuaVtOS4quW6j+WIl+S4reasoeWwj+WFs+mUruWtl+WAvOeahOiusOW9leiwg+aVtCjmjpLpmaQp5Ye65peg5bqP5Yy677ybXHJcbuKRoyAg6YeN5aSN5LiK6L+w5q2l6aqk77yM55u05Yiw5YWo6YOo6K6w5b2V5o6S5aW95bqP5Li65q2i44CCXHJcblxyXG7nu5PorrrvvJrmjpLluo/ov4fnqIvkuK3vvIzoi6Xph4fnlKjlsI/moLnloIbvvIzmjpLluo/lkI7lvpfliLDnmoTmmK/pnZ7pgJLlh4/luo/liJfvvJvoi6Xph4fnlKjlpKfmoLnloIbvvIzmjpLluo/lkI7lvpfliLDnmoTmmK/pnZ7pgJLlop7luo/liJfjgIJcclxuXHJcbuWghuaOkuW6j+eahOWFs+mUrlxyXG7ikaAgIOWmguS9leeUseS4gOS4quaXoOW6j+W6j+WIl+W7uuaIkOS4gOS4quWghu+8n1xyXG7ikaEgIOWmguS9leWcqOi+k+WHuuWghumhtuWFg+e0oOS5i+WQju+8jOiwg+aVtOWJqeS9meWFg+e0oO+8jOS9v+S5i+aIkOS4uuS4gOS4quaWsOeahOWghu+8n1xyXG5cclxuNCAg5aCG55qE6LCD5pW04oCU4oCU562b6YCJXHJcbuKRtCDloIbnmoTosIPmlbTmgJ3mg7Ncclxu6L6T5Ye65aCG6aG25YWD57Sg5LmL5ZCO77yM5Lul5aCG5Lit5pyA5ZCO5LiA5Liq5YWD57Sg5pu/5Luj5LmL77yb54S25ZCO5bCG5qC557uT54K55YC85LiO5bem44CB5Y+z5a2Q5qCR55qE5qC557uT54K55YC86L+b6KGM5q+U6L6D77yM5bm25LiO5YW25Lit5bCP6ICF6L+b6KGM5Lqk5o2i77yb6YeN5aSN5LiK6L+w5pON5L2c77yM55u05Yiw5piv5Y+25a2Q57uT54K55oiW5YW25YWz6ZSu5a2X5YC85bCP5LqO562J5LqO5bem44CB5Y+z5a2Q5qCR55qE5YWz6ZSu5a2X55qE5YC877yM5bCG5b6X5Yiw5paw55qE5aCG44CC56ew6L+Z5Liq5LuO5aCG6aG26Iez5Y+25a2Q55qE6LCD5pW06L+H56iL5Li64oCc562b6YCJ4oCd44CCXHJcblxyXG7ms6jmhI/vvJrnrZvpgInov4fnqIvkuK3vvIzmoLnnu5PngrnnmoTlt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzlm6DmraTvvIznrZvpgInmmK/ku47moLnnu5PngrnliLDmn5DkuKrlj7blrZDnu5PngrnnmoTkuIDmrKHosIPmlbTov4fnqIvjgIJcclxuXHJcbjUgIOWghueahOW7uueri1xyXG7liKnnlKjnrZvpgInnrpfms5XvvIzlj6/ku6XlsIbku7vmhI/ml6Dluo/nmoTorrDlvZXluo/liJflu7rmiJDkuIDkuKrloIbvvIzorr5SWzFdLFJbMl0sIOKApixSW25d5piv5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX44CCXHJcbuWwhuS6jOWPieagkeeahOavj+ajteWtkOagkemDveetm+mAieaIkOS4uuWghuOAguWPquacieaguee7k+eCueeahOagkeaYr+WghuOAguesrOKMim4vMuKMi+S4que7k+eCueS5i+WQjueahOaJgOaciee7k+eCuemDveayoeacieWtkOagke+8jOWNs+S7peesrOKMim4vMuKMi+S4que7k+eCueS5i+WQjueahOe7k+eCueS4uuagueeahOWtkOagkemDveaYr+WghuOAguWboOatpO+8jOS7pei/meS6m+e7k+eCueS4uuW3puOAgeWPs+WtqeWtkOeahOe7k+eCue+8jOWFtuW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWImei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuOAguWQjOeQhu+8jOWPquimgeWwhui/meS6m+e7k+eCueeahOebtOaOpeeItue7k+eCuei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuKApuOAglxyXG7lj6rpnIDku47nrKzijIpuLzLijIvkuKrorrDlvZXliLDnrKwx5Liq6K6w5b2V5L6d5qyh6L+b6KGM562b6YCJ5bCx5Y+v5Lul5bu656uL5aCG44CCXHJcblxyXG42ICAg5aCG5o6S5bqP566X5rOV5a6e546wXHJcbuWghueahOaguee7k+eCueaYr+WFs+mUruWtl+acgOWwj+eahOiusOW9le+8jOi+k+WHuuaguee7k+eCueWQju+8jOaYr+S7peW6j+WIl+eahOacgOWQjuS4gOS4quiusOW9leS9nOS4uuaguee7k+eCue+8jOiAjOWOn+adpeWghueahOW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWImei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuOAglxyXG5cclxuNyAg566X5rOV5YiG5p6QXHJcbuS4u+imgei/h+eoi++8muWIneWni+W7uuWghuWSjOmHjeaWsOiwg+aVtOaIkOWghuOAguiuvuiusOW9leaVsOS4um7vvIzmiYDlr7nlupTnmoTlrozlhajkuozlj4nmoJHmt7HluqbkuLpoIOOAglxyXG7il4YgIOWIneWni+W7uuWghu+8muavj+S4qumdnuWPtuWtkOe7k+eCuemDveimgeS7juS4iuWIsOS4i+WBmuKAnOetm+mAieKAnSDjgILnrKxp5bGC57uT54K55pWw4omkMmktMe+8jOe7k+eCueS4i+enu+eahOacgOWkp+a3seW6puaYr2gtae+8jOiAjOavj+S4i+enu+S4gOWxguimgeavlOi+gzLmrKHvvIzliJnmr5TovoPmrKHmlbBDMShuKeS4uu+8mlxyXG5DMShuKeKJpDQobi3jj5Iybi0xKVxyXG7il4YgIOetm+mAieiwg+aVtO+8muavj+asoeetm+mAieimgeWwhuaguee7k+eCueKAnOS4i+ayieKAneWIsOS4gOS4quWQiOmAguS9jee9ruOAguesrGnmrKHnrZvpgInml7bvvJrloIbkuK3lhYPntKDkuKrmlbDkuLpuLWkrMe+8m+WghueahOa3seW6puaYr++Dq+OPkjIobi1pKzEp74O7KzHvvIzliJnov5vooYxuLTHmrKHigJznrZvpgInigJ3nmoTmr5TovoPmrKHmlbBDMihuKeS4uu+8mlxyXG5DMihuKTwybuOPkjJuXHJcbuWghuaOkuW6j+eahOavlOi+g+asoeaVsOeahOaVsOmHj+e6p+S4uu+8miBUKG4pPU8obuOPkjJuKe+8m+iAjOmZhOWKoOepuumXtOWwseaYr+S6pOaNouaXtuaJgOeUqOeahOS4tOaXtuepuumXtO+8jOaVheepuumXtOWkjeadguW6puS4uu+8miBTKG4pPU8oMSkg44CCXHJcblxyXG7loIbmjpLluo/pgILlkIjorrDlvZXmlbDovoPlpKfnmoTmg4XlhrVcclxuXHJcblxyXG5odHRwOi8vYmxvZy5jc2RuLm5ldC96ejE5ODgwOC9hcnRpY2xlL2RldGFpbHMvNzY3ODA1NVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiDlt7Lnn6VzcUxpc3Rbcy4ubV3kuK3orrDlvZXnmoTlhbPplK7lrZfpmaRzcUxpc3Rbc13kuYvlpJblnYfmu6HotrPloIbnmoTlrprkuYnvvIxcclxuICog5pys5Ye95pWw6LCD5pW0c3FMaXN0W3Nd55qE5YWz6ZSu5a2X77yM5L2/c3FMaXN0W3MuLm1d5oiQ5Li65LiA5Liq5aSn5aCG6aG277yI5a+55YW25Lit5YWz6ZSu5a2X6ICM6KiA77yJXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNxTGlzdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbVxyXG4gKi9cclxuZnVuY3Rpb24gaGVhcEFkanVzdChzcUxpc3QsIHMsIG0sIGNvbXApIHtcclxuICAgIHZhciByYyA9IHNxTGlzdFtzXTtcclxuXHJcbiAgICAvLyDmsr/lhbPplK7lrZfovoPlpKfnmoTlranlrZDnu5PngrnlkJHkuIvnrZvpgIlcclxuICAgIGZvciAodmFyIGogPSAyICogcyArIDE7IGogPD0gbTsgaiA9IGogKiAyICsgMSkge1xyXG4gICAgICAgIC8vIGrkuLrlhbPplK7lrZfovoPlpKfnmoTorrDlvZXkuIvmoIdcclxuICAgICAgICBpZiAoaiA8IG0gJiYgY29tcChzcUxpc3Rbal0sIHNxTGlzdFtqICsgMV0pIDwgMCkgKytqO1xyXG4gICAgICAgIC8vIHJj5bqU5o+S5YWl5Zyo5L2N572uc+S4ilxyXG4gICAgICAgIGlmIChjb21wKHJjLCBzcUxpc3Rbal0pID49IDApIGJyZWFrO1xyXG4gICAgICAgIHNxTGlzdFtzXSA9IHNxTGlzdFtqXTtcclxuICAgICAgICBzID0gajtcclxuICAgIH1cclxuXHJcbiAgICBzcUxpc3Rbc10gPSByYztcclxufVxyXG5cclxuZnVuY3Rpb24gaGVhcFNvcnQoc3FMaXN0LCBjb21wKSB7XHJcbiAgICBpZiAoY29tcCA9PSBudWxsKSBjb21wID0gZGVmYXVsdENvbXBhcmU7XHJcbiAgICB2YXIgbGVuID0gc3FMaXN0Lmxlbmd0aDtcclxuICAgIC8vIOW7uueri+Wkp+WghumhtlxyXG4gICAgZm9yICh2YXIgaSA9IChsZW4gPj4gMSkgLSAxOyBpID49IDA7IC0taSlcclxuICAgICAgICBoZWFwQWRqdXN0KHNxTGlzdCwgaSwgbGVuIC0gMSwgY29tcCk7XHJcblxyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+IDA7IC0taSkge1xyXG4gICAgICAgIC8vIOWwhuWghumhtuiusOW9leWSjOW9k+WJjeacque7j+aOkuW6j+WtkOW6j+WIl3NxTGlzdFswLi5pXeS4rVxyXG4gICAgICAgIC8vIOacgOWQjuS4gOS4quiusOW9leebuOS6kuS6pOaNolxyXG4gICAgICAgIHZhciB0ZW1wID0gc3FMaXN0W2ldO1xyXG4gICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFswXTtcclxuICAgICAgICBzcUxpc3RbMF0gPSB0ZW1wO1xyXG5cclxuICAgICAgICAvLyDlsIZzcUxpc3RbMC4uaSAtIDFd6YeN5paw6LCD5pW05Li65aSn5aCG6aG2XHJcbiAgICAgICAgaGVhcEFkanVzdChzcUxpc3QsIDAsIGkgLSAxLCBjb21wKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmhlYXBTb3J0ID0gaGVhcFNvcnQ7XHJcblxyXG52YXIgYXJyID0gWzEsIDMsIDQsIDUsIDcsIDIsIDYsIDgsIDBdO1xyXG5oZWFwU29ydChhcnIpO1xyXG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1NvcnQvc2VsZWN0aW9uL2luZGV4LmpzXG4gKiovIiwiLyoqXHJcbiAqIOWghuWIhumFjeWtmOWCqOihqOekulxyXG4gKlxyXG4gKiDov5nnp43lrZjlgqjooajnpLrnmoTnibnngrnmmK/vvIzku43ku6XkuIDnu4TlnLDlnYDov57nu63nmoTlrZjlgqjljZXlhYPlrZjmlL7kuLLlgLzlrZfnrKbluo/liJfvvIzkvYblroPku6znmoTlrZjlgqjnqbrpl7TmmK/lnKjnqIvluo/miafooYzov4fnqIvkuK3liqjmgIHliIbphY3ogIzlvpfjgILlnKhj6K+t6KiA5Lit77yM5a2Y5Zyo5LiA5Liq56ew5LmL5Li64oCc5aCG4oCd55qE6Ieq55Sx5a2Y5YKo5Yy677yM5bm255SxY+ivreiogOeahOWKqOaAgeWIhumFjeWHveaVsG1hbGxvYygp5ZKMZnJlZSgp5p2l566h55CG44CC5Yip55So5Ye95pWwbWFsbG9jKCnkuLrmr4/kuKrmlrDkuqfnlJ/nmoTkuLLliIbphY3kuIDlnZflrp7pmYXkuLLplb/miYDpnIDnmoTlrZjlgqjnqbrpl7TjgIJcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIU3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5jaCA9IHt9O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAxIDw9IHBvc2l0aW9uIDw9IHRoaXMubGVuZ3RoLuWcqOS4sueahOesrHBvc2l0aW9u5Liq5a2X56ym5LmL5YmN5o+S5YWl5LiydEhTdHJpbmdcclxuICAgIHN0ckluc2VydCAocG9zaXRpb24sIHRIU3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMSB8fCBwb3NpdGlvbiA+IHRoaXMubGVuZ3RoICsgMSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBvc2l0aW9uJyk7XHJcblxyXG4gICAgICAgIGlmICh0SFN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8g5Li65o+S5YWldOiAjOiFvuWHuuS9jee9rlxyXG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gcG9zaXRpb24gLSAxOyBpID49IGxlbjsgLS1pKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaFtpICsgdEhTdHJpbmcubGVuZ3RoXSA9IHRoaXMuY2hbaV07XHJcblxyXG4gICAgICAgICAgICBzdHJpbmdDb3B5KHRoaXMuY2gsIHRIU3RyaW5nLmNoLCBwb3NpdGlvbiAtIDEsIHRIU3RyaW5nLmxlbmd0aCAtIDEsIDApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gdEhTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0ckFzc2lnbiAoY2hhcnMpIHtcclxuICAgICAgICBzdHJpbmdDb3B5KHRoaXMuY2gsIGNoYXJzLCAwLCBjaGFycy5sZW5ndGggLSAxLCAwKTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIHN0ckxlbmd0aCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgc3RyQ29tcGFyZSAodEhTdHJpbmcpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW4gJiYgaSA8IHRIU3RyaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaFtpXSAhPT0gdEhTdHJpbmcuY2hbaV0pIHJldHVybiB0aGlzLmNoW2ldIC0gdEhTdHJpbmcuY2hbaV07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRIU3RyaW5nLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGNsZWFyU3RyaW5nICgpIHtcclxuICAgICAgICB0aGlzLmNoID0ge307XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgY29uY2F0IChzKSB7XHJcbiAgICAgICAgbGV0IHQgPSBuZXcgSFN0cmluZygpO1xyXG5cclxuICAgICAgICAvLyB0LmNoWzAuLnRoaXMubGVuZ3RoIC0gMV0gPSB0aGlzLmNoWzAuLnRoaXMubGVuZ3RoIC0gMV1cclxuICAgICAgICBzdHJpbmdDb3B5KHQuY2gsIHRoaXMuY2gsIDAsIHRoaXMubGVuZ3RoIC0gMSwgMCk7XHJcbiAgICAgICAgdC5sZW5ndGggPSB0aGlzLmxlbmd0aCArIHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIHQuY2hbdGhpcy5sZW5ndGguLnQubGVuZ3RoIC0gMV0gPSBzLmNoWzAuLnMubGVuZ3RoIC0gMV1cclxuICAgICAgICBzdHJpbmdDb3B5KHQuY2gsIHMuY2gsIHRoaXMubGVuZ3RoLCBzLmxlbmd0aCAtIDEsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHN1YnN0cmluZyAocG9zaXRpb24sIGxlbikge1xyXG4gICAgICAgIHBvc2l0aW9uID0gfn5wb3NpdGlvbiB8fCAwO1xyXG4gICAgICAgIGxlbiA9IH5+bGVuIHx8IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzLmxlbmd0aCAtIDEgfHwgbGVuIDwgMCB8fCBsZW4gPiB0aGlzLmxlbmd0aCAtIHBvc2l0aW9uKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XHJcblxyXG4gICAgICAgIGxldCBzdWIgPSBuZXcgSFN0cmluZygpO1xyXG4gICAgICAgIHN0cmluZ0NvcHkoc3ViLmNoLCB0aGlzLmNoLCAwLCBsZW4gLSAxLCBwb3NpdGlvbik7XHJcbiAgICAgICAgc3ViLmxlbmd0aCA9IGxlbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YjtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBsZXQgcyA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgKz0gdGhpcy5jaFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ0NvcHkoZGVzdGluYXRpb24sIHRhcmdldCwgZGVzdFN0YXJ0LCBsZW5ndGgsIHRhcmdldFN0YXJ0KSB7XHJcbiAgICBkZXN0U3RhcnQgPSBkZXN0U3RhcnQgfHwgMDtcclxuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCB0YXJnZXQubGVuZ3RoO1xyXG4gICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXRTdGFydCB8fCAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGVzdGluYXRpb25bZGVzdFN0YXJ0ICsgaV0gPSB0YXJnZXRbdGFyZ2V0U3RhcnQgKyBpXTtcclxuICAgIH1cclxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1N0cmluZy9IU3RyaW5nLmpzXG4gKiovIiwiLyoqXHJcbiAqIOS4sueahOWdl+mTvuWtmOWCqOihqOekulxyXG4gKlxyXG4gKiDlkoznur/mgKfooajnmoTpk77lvI/lrZjlgqjnu5PmnoTnm7jnsbvkvLzvvIzkuZ/lj6/ph4fnlKjpk77lvI/mlrnlvI/lrZjlgqjkuLLlgLzjgILnlLHkuo7kuLLnu5PmnoTnmoTnibnmrormgKctLee7k+aehOS4reeahOavj+S4quaVsOaNruWFg+e0oOaYr+S4gOS4quWtl+espu+8jOWImeeUqOmTvuihqOWtmOWCqOS4suWAvOaXtu+8jOWtmOWcqOS4gOS4quKAnOe7k+eCueWkp+Wwj+KAneeahOmXrumimO+8jOWNs+avj+S4que7k+eCueWPr+S7peWtmOaUvuS4gOS4quWtl+espu+8jOS5n+WPr+S7peWtmOaUvuWkmuS4quWtl+espuOAglxyXG4gKiDkuIvpnaLmmK/nu5PngrnlpKflsI/kuLo077yI5Y2z5q+P5Liq57uT54K55a2Y5pS+NOS4quWtl+espu+8ieeahOmTvuihqFxyXG4gKiBoZWFkIC0tPiAoYSxiLGMsZCkgLS0+IChlLGYsZyxoKSAtLT4gKGkjIyMpXHJcbiAqIOS4i+mdouaYr+e7k+eCueWkp+Wwj+S4ujHnmoTpk77ooahcclxuICogaGVhZCAtLT4gKGEpIC0tPiAoYikgLS0+IChjKSAtLT4gLi4uIC0tPiAoaSlcclxuICpcclxuICog5b2T57uT54K55aSn5bCP5aSn5LqOMeaXtu+8jOeUseS6juS4sumVv+S4jeS4gOWumuaYr+e7k+eCueWkp+Wwj+eahOaVtOWAjeaVsO+8jOWImemTvuihqOS4reeahOacgOWQjuS4gOS4que7k+eCueS4jeS4gOWumuWFqOiiq+S4suWAvOWNoOa7oe+8jOatpOaXtumAmuW4uOihpeS4iuKAnCPigJ3miJblhbblroPpnZ7kuLLlgLzlrZfnrKbjgIJcclxuICog5Li65LqG5L6/5LqO6L+b6KGM5Liy55qE5pON5L2c77yM5b2T5Lul6ZO+6KGo5a2Y5YKo5Liy5YC85pe277yM6Zmk5aS05oyH6ZKI5aSW6L+Y5Y+v6ZmE6K6+5LiA5Liq5bC+5oyH6ZKI5oyH56S66ZO+6KGo5Lit55qE5pyA5ZCO5LiA5Liq57uT54K577yM5bm257uZ5Ye65b2T5YmN5Liy55qE6ZW/5bqm77yM56ew5aaC5q2k5a6a5LmJ55qE5Liy5a2Y5YKo57uT5p6E5Li65Z2X6ZO+57uT5p6E44CCXHJcbiAqXHJcbiAqIOeUseS6juS4gOiIrOaDheWGteS4i++8jOWvueS4sui/m+ihjOaTjeS9nOaXtu+8jOWPqumcgOimgeS7juWktOWQkeWwvumhuuW6j+aJq+aPj+WNs+WPr++8jOWImeWvueS4suWAvOS4jeW/heW7uueri+WPjOWQkemTvuihqOOAguiuvuWwvuaMh+mSiOeahOebrueahOaYr+S4uuS6huS+v+S6jui/m+ihjOi/nuaOpeaTjeS9nO+8jOS9huW6lOazqOaEj+i/nuaOpeaXtumcgOWkhOeQhuesrOS4gOS4quS4suWwvueahOaXoOaViOWtl+espuOAglxyXG4gKiDlnKjpk77lvI/lrZjlgqjmlrnlvI/kuK3vvIznu5PngrnlpKflsI/nmoTpgInmi6nlkozpobrluo/lrZjlgqjmlrnlvI/nmoTmoLzlvI/pgInmi6nkuIDmoLfpg73lvojph43opoHvvIzlroPnm7TmjqXlvbHlk43liLDkuLLlpITnkIbnmoTmlYjnjofjgILlpoLmnpzkuLLlvojplb/vvIzov5nopoHmsYLmiJHku6zogIPomZHkuLLlgLznmoTlrZjlgqjlr4bluqbvvJpcclxuICog5a2Y5YKo5a+G5bqmID0g5Liy5YC85omA5Y2g55qE5a2Y5YKo5L2NIC8g5a6e6ZmF5YiG6YWN55qE5a2Y5YKo5L2NXHJcbiAqXHJcbiAqIOS4suWAvOeahOmTvuW8j+WtmOWCqOe7k+aehOWvueafkOS6m+S4suaTjeS9nO+8jOWmgui/nuaOpeaTjeS9nOetieacieS4gOWumuaWueS+v+S5i+WkhO+8jOS9huaAu+eahOadpeivtOS4jeWmguWPpuWkluS4pOenjeWtmOWCqOe7k+aehOeBtea0u++8jOWug+WNoOeUqOWtmOWCqOmHj+Wkp+S4lOaTjeS9nOWkjeadguOAglxyXG4gKi9cclxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcclxuXHJcbmNsYXNzIENodW5rIHtcclxuICAgIGNvbnN0cnVjdG9yKGNodW5rU2l6ZSA9IDQpIHtcclxuICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZTtcclxuICAgICAgICB0aGlzLmNoID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hbaV0gPSAnIyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHR5cGU6IENodW5rXHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaHVua1NpemUgPSA0KSB7XHJcbiAgICAgICAgLy8gdHlwZSBDaHVua1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgLy8gdHlwZTogY2h1bmtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIC8vIOS4sueahOW9k+WJjemVv+W6plxyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDlsIblrZfnrKbkuLLovazmjaLmiJBMU3RyaW5n57G75Z6LXHJcbiAgICBzdHJBc3NpZ24gKGNoYXJzKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuY2hbaSAlIHRoaXMuY2h1bmtTaXplXSA9IGNoYXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4gJiYgKGkgKyAxKSAlIHRoaXMuY2h1bmtTaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQgPSBuZXcgQ2h1bmsoKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGFpbCA9IGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICAvLyDlrZfnrKbkuLLlr7nmr5RcclxuICAgIC8vIFRPRE8g5piv5ZCm5Y675o6JY2h1bmtTaXpl55qE5a+55q+UXHJcbiAgICBzdHJDb21wYXJlICh0TFN0cmluZykge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBjdXJUID0gdExTdHJpbmcuaGVhZDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB0TFN0cmluZy5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5jaFtpXSAhPT0gY3VyVC5jaFtpXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICBjdXJUID0gY3VyVC5uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjbGVhclN0cmluZyAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBjb25jYXQgKHRMU3RpbmcpIHtcclxuICAgICAgICBpZiAoIXRMU3RpbmcubGVuZ3RoKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCByZXQgPSBuZXcgTFN0cmluZyh0aGlzLmNodW5rU2l6ZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldC5oZWFkID0gcmV0LnRhaWwgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xyXG4gICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSByZXQudGFpbC5jaC5pbmRleE9mKCcjJyk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0TFN0aW5nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0TFN0aW5nLCByZXQudGFpbCwgdExTdGluZy5oZWFkLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBzdWJzdHJpbmcgKHBvcywgbGVuKSB7XHJcbiAgICAgICAgcG9zID0gfn5wb3MgfHwgMDtcclxuICAgICAgICBsZW4gPSB+fmxlbiB8fCB0aGlzLmxlbmd0aDtcclxuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPiB0aGlzLmxlbmd0aCAtIDEgfHwgbGVuIDwgMCB8fCBsZW4gPiB0aGlzLmxlbmd0aCAtIHBvcylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBhcmFtZXRlcicpO1xyXG5cclxuICAgICAgICBsZXQgc3ViID0gbmV3IExTdHJpbmcodGhpcy5jaHVua1NpemUpO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gZmluZFBvc0NodW5rKHRoaXMsIHBvcyk7XHJcbiAgICAgICAgbGV0IGN1clMgPSBzdWIuaGVhZCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHN1Yi5sZW5ndGggPSBsZW47XHJcblxyXG4gICAgICAgIG91dGVybG9vcDogd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHNpemUgPSB0aGlzLmNodW5rU2l6ZTsgaiA8IHNpemU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVybG9vcDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyUy5jaFtqXSA9IGN1cnJlbnQuY2hbKGkgKyBwb3MpICUgdGhpcy5jaHVua1NpemVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyBwb3MpICUgdGhpcy5jaHVua1NpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCAmJiAoY3VycmVudC5jaFtpXSB8fCBjdXJyZW50Lm5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clMubmV4dCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clMgPSBjdXJTLm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3ViO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcgKCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuICcnO1xyXG5cclxuICAgICAgICBsZXQgc3RyID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY2h1bmtTaXplOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaCA9IGN1cnJlbnQuY2hbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBjdXJyZW50LmNoW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kUG9zQ2h1bmsobFN0cmluZywgcG9zKSB7XHJcbiAgICBsZXQgY3VycmVudCA9IGxTdHJpbmcuaGVhZDtcclxuICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxTdHJpbmcuY2h1bmtTaXplOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHBvcy0tID09PSAwKSByZXR1cm4gY3VycmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29weVN0cmluZyhkZXN0aW5hdGlvbiwgdGFyZ2V0LCBjdXJELCBjdXJyVCwgb2Zmc2V0KSB7XHJcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcclxuICAgIGN1cnJUID0gY3VyclQgfHwgdGFyZ2V0LmhlYWQ7XHJcbiAgICBjdXJEID0gY3VyRCB8fCBkZXN0aW5hdGlvbi5oZWFkO1xyXG4gICAgbGV0IGsgPSAwO1xyXG5cclxuICAgIHdoaWxlIChjdXJyVCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0YXJnZXQuY2h1bmtTaXplOyBpIDwgbGVuOyBpKyssIGsrKykge1xyXG4gICAgICAgICAgICBsZXQgaiA9IGsgJSBjdXJELmNodW5rU2l6ZSArIG9mZnNldDtcclxuICAgICAgICAgICAgY3VyRC5jaFtqICUgY3VyRC5jaHVua1NpemVdID0gY3VyclQuY2hbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoKGogKyAxKSAlIGN1ckQuY2h1bmtTaXplID09PSAwICYmIChjdXJyVC5jaFtpICsgMV0gfHwgY3VyclQubmV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGN1ckQubmV4dCA9IG5ldyBDaHVuayhkZXN0aW5hdGlvbi5jaHVua1NpemUpO1xyXG4gICAgICAgICAgICAgICAgY3VyRCA9IGN1ckQubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VyclQgPSBjdXJyVC5uZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGRlc3RpbmF0aW9uLnRhaWwgPSBjdXJEO1xyXG4gICAgZGVzdGluYXRpb24ubGVuZ3RoICs9IHRhcmdldC5sZW5ndGg7XHJcbn1cclxuXHJcbmxldCBhID0gbmV3IExTdHJpbmcoKTtcclxubGV0IGIgPSBuZXcgTFN0cmluZygpO1xyXG5sZXQgYyA9IG5ldyBMU3RyaW5nKCk7XHJcblxyXG5hLnN0ckFzc2lnbignYWJjZGVmZycpO1xyXG5jb25zb2xlLmxvZyhhICsgJycpO1xyXG5iLnN0ckFzc2lnbignaGlqa2xtbm8nKTtcclxuY29uc29sZS5sb2coYiArICcnKTtcclxuYy5zdHJBc3NpZ24oJ2FiY2RlZmcnKTtcclxuY29uc29sZS5sb2coYS5zdHJDb21wYXJlKGIpKTtcclxuY29uc29sZS5sb2coYS5zdHJDb21wYXJlKGMpKTtcclxubGV0IHQgPSBhLmNvbmNhdChiKTtcclxuY29uc29sZS5sb2codCArICcnKTtcclxudCA9IHQuc3Vic3RyaW5nKDIsIDUpO1xyXG5jb25zb2xlLmxvZyh0ICsgJycpO1xyXG5cclxuXHJcbi8vIOWIpOaWreaYr+WQpuS4uuWbnuaWh+Wtl+espuS4slxyXG5mdW5jdGlvbiBwYWxpbmRyb21lKGxTdHIpIHtcclxuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgbGV0IHAgPSBsU3RyLmhlYWQ7XHJcbiAgICBsZXQgaSA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgayA9IDE7IGsgPD0gbFN0ci5sZW5ndGg7ICsraykge1xyXG4gICAgICAgIGlmIChrIDw9IGxTdHIubGVuZ3RoIC8gMikgc3RhY2sucHVzaChwLmNoW2ldKTtcclxuICAgICAgICBlbHNlIGlmIChrID4gKGxTdHIubGVuZ3RoICsgMSkgLyAyKSB7XHJcbiAgICAgICAgICAgIGxldCBjID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIGlmIChwLmNoW2ldICE9PSBjKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKytpID09PSBsU3RyLmNodW5rU2l6ZSkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9TdHJpbmcvTFN0cmluZy5qc1xuICoqLyIsIi8qKlxyXG4gKiDkuLLvvIhzdHJpbmfvvInvvIjmiJblrZfnrKbkuLLvvInmmK/nlLHpm7bkuKrmiJblpJrkuKrlrZfnrKbnu4TmiJDnmoTmnInpmZDluo/liJfjgILkuLLkuK3lrZfnrKbnmoTmlbDnm67np7DkuLrkuLLnmoTplb/luqbjgILpm7bkuKrlrZfnrKbnmoTkuLLnp7DkuLrnqbrkuLLvvIhudWxsIHN0cmluZ++8ie+8jOWug+eahOmVv+W6puS4uumbtuOAglxyXG4gKiDkuLLkuK3ku7vmhI/kuKrov57nu63nmoTlrZfnrKbnu4TmiJDnmoTlrZDluo/liJfnp7DkuLror6XkuLLnmoTlrZDkuLLjgILljIXlkKvlrZDkuLLnmoTkuLLnm7jlupTlnLDnp7DkuLrkuLvkuLLjgILpgJrluLjnp7DlrZfnrKblnKjluo/liJfkuK3nmoTluo/lj7fkuLror6XlrZfnrKblnKjkuLLkuK3nmoTkvY3nva7jgILlrZDkuLLlnKjkuLvkuLLkuK3nmoTkvY3nva7liJnku6XlrZDkuLLnmoTnrKzkuIDkuKrlrZfnrKblnKjkuLvkuLLkuK3nmoTkvY3nva7mnaXooajnpLrjgIJcclxuICog5Y+q5pyJ5b2T5Lik5Liq5Liy55qE6ZW/5bqm55u4562J77yM5bm25LiU5ZCE5Liq5a+55bqU5L2N572u55qE5a2X56ym6YO955u4562J5pe25omN55u4562J44CCXHJcbiAqXHJcbiAqIOS4suaciTPnp43mnLrlhoXooajnpLrmlrnms5XvvJpcclxuICogMS7lrprplb/pobrluo/lrZjlgqjooajnpLpcclxuICogMi7loIbliIbphY3lrZjlgqjooajnpLpcclxuICogMy7kuLLnmoTlnZfpk77lrZjlgqjooajnpLpcclxuICovXHJcblxyXG4vKipcclxuICog5a6a6ZW/6aG65bqP5a2Y5YKo6KGo56S6XHJcbiAqIOexu+S8vOS6jue6v+aAp+ihqOeahOmhuuW6j+WtmOWCqOe7k+aehO+8jOeUqOS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+WtmOWCqOS4suWAvOW+l+Wtl+espuW6j+WIl+OAguWcqOS4sueahOWumumVv+mhuuW6j+WtmOWCqOe7k+aehOS4re+8jOaMieeFp+mihOWumuS5ieeahOWkp+Wwj++8jOS4uuavj+S4quWumuS5ieeahOS4suWPmOmHj+WIhumFjeS4gOS4quWbuuWumumVv+W6pueahOWtmOWCqOWMuu+8jOWImeWPr+eUqOWumumVv+aVsOe7hOadpeaPj+i/sOOAglxyXG4gKiDku6XkuIvmoIfkuLow55qE5pWw57uE5YiG6YeP5a2Y5pS+5Liy55qE5a6e6ZmF6ZW/5bqm44CCXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1N0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdHIpe1xyXG4gICAgICAgIHRoaXMuTUFYU1RSTEVOID0gMTA7XHJcbiAgICAgICAgaWYgKHN0cikge1xyXG4gICAgICAgICAgICB0aGlzWzBdID0gc3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc3RyLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gc3RyW2kgLSAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDov5Tlm57nlLFzMeWSjHMy6L+e5o6l6ICM5oiQ55qE5paw5LiyXHJcbiAgICBjb25jYXQgKHMyKSB7XHJcbiAgICAgICAgbGV0IHQgPSBuZXcgU1N0cmluZygpO1xyXG4gICAgICAgIC8vIOacquaIquaWrVxyXG4gICAgICAgIGlmICh0aGlzWzBdICsgczJbMF0gPD0gdGhpcy5NQVhTVFJMRU4pIHtcclxuICAgICAgICAgICAgY29weVN0cjJUKHRoaXMpO1xyXG4gICAgICAgICAgICBjb3B5U3RyMlQoczIsIHRoaXNbMF0pO1xyXG4gICAgICAgICAgICB0WzBdID0gdGhpc1swXSArIHMyWzBdO1xyXG5cclxuICAgICAgICAgICAgLy8g5oiq5patXHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzWzBdIDwgdGhpcy5NQVhTVFJMRU4pIHtcclxuICAgICAgICAgICAgY29weVN0cjJUKHRoaXMpO1xyXG4gICAgICAgICAgICBjb3B5U3RyMlQoczIsIHRoaXNbMF0sIHRoaXMuTUFYU1RSTEVOIC0gdGhpc1swXSk7XHJcbiAgICAgICAgICAgIHRbMF0gPSB0aGlzLk1BWFNUUkxFTjtcclxuXHJcbiAgICAgICAgICAgIC8vIOaIquaWre+8iOS7heWPlnMx77yJXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29weVN0cjJUKHRoaXMsIDAsIHRoaXMuTUFYU1RSTEVOKTtcclxuICAgICAgICAgICAgdFswXSA9IHRoaXNbMF0gPSB0aGlzLk1BWFNUUkxFTjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjb3B5U3RyMlQoc3RyLCBzdGFydCA9IDAsIGVuZCA9IHN0clswXSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gZW5kIHx8IHN0clswXTsgaSA8PSBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdFtzdGFydCArIGldID0gc3RyW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3Vic3RyaW5nIChwb3NpdGlvbiA9IDAsIGxlbiA9IHRoaXNbMF0pIHtcclxuICAgICAgICBwb3NpdGlvbiA9IH5+cG9zaXRpb247XHJcbiAgICAgICAgbGVuID0gfn5sZW47XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXNbMF0gLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpc1swXSAtIHBvc2l0aW9uKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XHJcblxyXG4gICAgICAgIGxldCBzdWIgPSBuZXcgU1N0cmluZygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1YltpXSA9IHRoaXNbcG9zaXRpb24gKyBpIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YlswXSA9IGxlbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWwhuS4snPkuK3nmoTlrZDkuLJ05pu/5o2i5Li6du+8jOi/lOWbnuabv+aNouasoeaVsFxyXG4gICAgICogdG9kbyB0byBiZSB0ZXN0ZWRcclxuICAgICAqIEBwYXJhbSB7U1N0cmluZ30gdFxyXG4gICAgICogQHBhcmFtIHtTU3RyaW5nfSB2XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmm7/mjaLmrKHmlbBcclxuICAgICAqL1xyXG4gICAgcmVwbGFjZSAodCwgdikge1xyXG4gICAgICAgIGZvciAobGV0IG4gPSAwLCBpID0gMTsgaSA8PSB0aGlzWzBdIC0gdFswXSArIDE7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSwgayA9IDE7IHRba10gJiYgdGhpc1tqXSA9PT0gdFtrXTsgKytqLCArK2spO1xyXG5cclxuICAgICAgICAgICAgLy8g5om+5Yiw5LqG5LiOdOWMuemFjeeahOWtl+S4su+8muWIhuS4ieenjeaDheWGteWkhOeQhlxyXG4gICAgICAgICAgICBpZiAoayA+IHRbMF0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBsO1xyXG4gICAgICAgICAgICAgICAgLy8g5paw5a2X5Liy55qE6ZW/5bqm5LiO5Y6f5a2Q5Liy55u45ZCM5pe277yM55u05o6l5pu/5o2iXHJcbiAgICAgICAgICAgICAgICBpZiAodFswXSA9PT0gdlswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDE7IGwgPD0gdFswXTsgKytsKSB0aGlzW2kgKyBsIC0gMV0gPSB2W2xdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g5paw5a2Q5Liy6ZW/5bqm5aSn5LqO5Y6f5a2Q5Liy5pe277yM5YWI5bCG5ZCO6YOo5Y+z56e7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0WzBdIDwgdlswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IHRoaXNbMF07IGwgPj0gaSArIHRbMF07IC0tbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tsICsgdlswXSAtIHRbMF1dID0gdGhpc1tsXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMTsgbCA8PSB2WzBdOyArK2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaSArIGwgLSAxXSA9IHZbbF07XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g5paw5a2Q5Liy6ZW/5bqm5bCP5LqO5Y6f5a2Q5Liy5pe277yM5YWI5bCG5ZCO6YOo5bem56e7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSBpICsgdlswXTsgbCA8PSB0aGlzWzBdICsgdlswXSAtIHRbMF07ICsrbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tsXSA9IHRoaXNbbCAtIHZbMF0gKyB0WzBdXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMTsgbCA8PSB2WzBdOyArK2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaSArIGwgLSAxXSA9IHZbbF07XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXNbMF0gPSB0aGlzWzBdIC0gdFswXSArIHZbMF07XHJcbiAgICAgICAgICAgICAgICBpICs9IHZbMF07XHJcbiAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nICgpIHtcclxuICAgICAgICBsZXQgc3RyID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IHRoaXNbaV07IGkrKykge1xyXG4gICAgICAgICAgICBzdHIgKz0gdGhpc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIC8vIOi/lOWbnuWtkOS4snNzdHJpbmflnKjkuLvkuLLkuK3nmoTnrKxwb3NpdGlvbuS4quWtl+espuS5i+WQjueahOS9jee9rlxyXG4gICAgaW5kZXggKHNzdHJpbmcsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgbGV0IGkgPSBwb3NpdGlvbiB8fCAxO1xyXG4gICAgICAgIGxldCBqID0gMTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gdGhpc1swXSAmJiBqIDw9IHNzdHJpbmdbMF0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHNzdHJpbmdbal0pIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkgPSBpIC0gaiArIDI7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGogPiBzc3RyaW5nWzBdID8gaSAtIHNzdHJpbmdbMF0gOiAtMTtcclxuICAgIH1cclxuICAgIGttcEluZGV4IChzc3RyaW5nLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGxldCBpID0gcG9zaXRpb24gfHwgMTtcclxuICAgICAgICBsZXQgaiA9IDE7XHJcbiAgICAgICAgbGV0IG5leHQgPSBnZXROZXh0KHNzdHJpbmcpO1xyXG5cclxuICAgICAgICB3aGlsZSAoaSA8PSB0aGlzWzBdICYmIGogPD0gc3N0cmluZ1swXSkge1xyXG4gICAgICAgICAgICBpZiAoaiA9PT0gMCB8fCB0aGlzW2ldID09PSBzc3RyaW5nW2pdKSB7XHJcbiAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICArK2o7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBqID0gbmV4dFtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGogPiBzc3RyaW5nWzBdID8gaSAtIHNzdHJpbmdbMF0gOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmsYLljIXlkKvlnKjlrZfnrKbkuLLkuK3ogIxzdHLmsqHmnInnmoTlrZfnrKbkuLJcclxuICAgIHN1YnRyYWN0IChzdHIpIHtcclxuICAgICAgICBsZXQgciA9IG5ldyBTU3RyaW5nKCk7XHJcbiAgICAgICAgclswXSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXNbMF07ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgYyA9IHRoaXNbaV07XHJcbiAgICAgICAgICAgIC8vIOWIpOaWreW9k+WJjeWtl+espmPmmK/lkKbnrKzkuIDmrKHlh7rnjrBcclxuICAgICAgICAgICAgbGV0IGogPSAxO1xyXG4gICAgICAgICAgICBmb3IgKDsgaiA8IGkgJiYgdGhpc1tqXSAhPT0gYzsgKytqKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGopIHtcclxuICAgICAgICAgICAgICAgIC8vIOWIpOaWreW9k+WJjeWtl+espuaYr+WQpuWMheWQq+WcqHN0cuS4rVxyXG4gICAgICAgICAgICAgICAgbGV0IGsgPSAxXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgayA8PSBzdHJbMF0gJiYgc3RyW2tdICE9PSBjOyArK2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPiBzdHJbMF0pIHJbKytyWzBdXSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvZG8gYnVnIGV4aXN0c1xyXG4gICAgZGVsZXRlX3N1YnN0cmluZyAoc3RyKSB7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXNbMF0gLSBzdHJbMF0gKyAxOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IGogPSAxO1xyXG4gICAgICAgICAgICBmb3IgKDsgaiA8PSBzdHJbMF0gJiYgdGhpc1tpICsgaiAtIDFdID09PSBzdHJbal07ICsraik7XHJcbiAgICAgICAgICAgIGlmIChqID4gc3RyWzBdIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IGk7IGsgPD0gdGhpc1swXSAtIHN0clswXTsgKytrKSB0aGlzW2tdID0gdGhpc1trICsgc3RyWzBdXTtcclxuICAgICAgICAgICAgICAgIHRoaXNbMF0gLT0gc3RyWzBdO1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TmV4dChzc3RyaW5nKSB7XHJcbiAgICBsZXQgaSA9IDE7XHJcbiAgICBsZXQgbmV4dCA9IHsxOiAwfTtcclxuICAgIGxldCBqID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IHNzdHJpbmdbMF0pIHtcclxuICAgICAgICBpZiAoaiA9PT0gMCB8fCBzc3RyaW5nW2ldID09PSBzc3RyaW5nW2pdKSB7XHJcbiAgICAgICAgICAgIGlmIChzc3RyaW5nWysraV0gIT09IHNzdHJpbmdbKytqXSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dFtpXSA9IGo7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0W2ldID0gbmV4dFtqXTtcclxuICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICBuZXh0WysraV0gPSArK2o7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaiA9IG5leHRbal07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0O1xyXG59XHJcblxyXG5sZXQgYSA9IG5ldyBTU3RyaW5nKCk7XHJcbmxldCBiID0gbmV3IFNTdHJpbmcoKTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgIGFbaSArIDFdID0gaSArICcnO1xyXG4gICAgYltpICsgMV0gPSBpICsgJyc7XHJcbn1cclxuYVswXSA9IGJbMF0gPSA0O1xyXG5sZXQgdCA9IGEuY29uY2F0KGIpO1xyXG5jb25zb2xlLmxvZyh0ICsgJycpOyAgICAgICAvLyAwMTIzMDEyM1xyXG5cclxubGV0IGQgPSBuZXcgU1N0cmluZygnYWNhYmFhYmFhYmNhY2FhYmMnKTtcclxubGV0IGMgPSBuZXcgU1N0cmluZygnYWJhYWJjJyk7XHJcblxyXG5jb25zb2xlLmxvZygnaW5kZXg6ICcgKyBkLmluZGV4KGMpKTtcclxuY29uc29sZS5sb2coJ2ttcEluZGV4OiAnICsgZC5rbXBJbmRleChjKSk7XHJcblxyXG5hID0gbmV3IFNTdHJpbmcoJ2FiY2RlZmcnKTtcclxuYiA9IG5ldyBTU3RyaW5nKCdhc2RmZycpO1xyXG5jb25zb2xlLmxvZyhhLnN1YnRyYWN0KGIpICsgJycpO1xyXG5cclxuYSA9IG5ldyBTU3RyaW5nKCdhYmNkZWZnaCcpO1xyXG5iID0gbmV3IFNTdHJpbmcoJ2NkZWYnKTtcclxuY29uc29sZS5sb2coYS5kZWxldGVfc3Vic3RyaW5nKGIpICsgJycpO1xyXG5jb25zb2xlLmxvZyhhICsgJycpO1xyXG5cclxuLypcclxuIOWcqOmhuuW6j+WtmOWCqOe7k+aehOS4re+8jOWunueOsOS4suaTjeS9nOeahOWOn+aTjeS9nOS4uuKAnOWtl+espuS4suW6j+WIl+eahOWkjeWItuKAne+8jOaTjeS9nOaXtumXtOWkjeadguW6puWfuuS6juWkjeWItueahOWtl+espuS4suW6j+WIl+eahOmVv+W6puOAglxyXG4g5Y+m5LiA5pON5L2c54m554K55piv77yM5aaC5p6c5Zyo5pON5L2c5Lit5Ye6546w5Liy5YC85bqP5YiX55qE6ZW/5bqm6LaF6L+HTUFYU1RSTEVO5pe277yM57qm5a6a55So5oiq5bC+5rOV5aSE55CG77yM6L+Z56eN5oOF5Ya15LiN5LuF5Zyo5rGC6L+e5o6l5Liy5pe25Y+v6IO95Y+R55Sf77yM5Zyo5Liy55qE5YW25LuW5pON5L2c5Lit77yM5aaC5o+S5YWl77yM572u5o2i562J5Lmf5Y+v6IO95Y+R55Sf77yM5YWL5pyN6L+Z5Liq5byK55eF5ZSv5pyJ5LiN6ZmQ5a6a5Liy6ZW/55qE5pyA5aSn6ZW/5bqm77yM5Y2z5Yqo5oCB5YiG6YWN5Liy5YC855qE5a2Y5YKo56m66Ze044CCXHJcbiAqL1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL1N0cmluZy9TU3RyaW5nLmpzXG4gKiovIiwiLyppc3RhbmJ1bCBpZ25vcmUgbmV4dCovXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBuZXh0Ki9tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyAvLyByZXF1aXJlZCB0byBzYWZlbHkgdXNlIGJhYmVsL3JlZ2lzdGVyIHdpdGhpbiBhIGJyb3dzZXJpZnkgY29kZWJhc2VcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1yZWdpc3Rlci9saWIvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNJdGVyYWJsZTIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpXG4gICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcclxuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xyXG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcclxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICwgaSA9IDBcclxuICAgICwgUDtcclxuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xyXG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxyXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=