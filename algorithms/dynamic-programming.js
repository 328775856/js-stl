/**
 * Created by Luke on 2015/3/17.
 */

/*
 动态规划法

 动态规划过程是：根据当前（阶段）状态，采取相应的决策，引起状态的转移。如下图，一个决策序列就是在变化的状态中产生出来的，这种多阶段最优化决策解决问题的过程就称为动态规划。

 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
 图1 动态规划决策过程示意图

 动态规划算法与分治法类似，其思想也是将待求解问题分解成若干个子问题（一般每个问题对应一个阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。
 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
 典型例子：最长公共子序列； 最大连续子序列和（最大m子段和）。
 */

// unoptimized version
// 两矩阵相乘
function matrixMultiply(a, b){
    var c = [];
    var ra = a[0].length;
    var ca = a.length;
    var rb = b[0].length;
    var cb = b.length;

    if(ca !== rb) throw new Error('matrix can\'t be multiplied!');

    for(var i = 0; i < ra; ++i){
        if(!c[i]) c[i] = [];
        for(var j = 0; j < cb; ++j){
            var sum = a[i][0] * b[0][j];

            for(var k = 1; k < ca; ++k)
                sum += a[i][k] * b[k][j];

            c[i][j] = sum;
        }
    }

    return c;
}


var m1 = [
    [0, 0, 0, 0],
    [0, 3, 0, 5],
    [0, 0, -1, 0],
    [0, 2, 0, 0]
];
var m2 = [
    [0, 0, 0, 0],
    [0, 0, 2, 0],
    [0, 1, 0, 0],
    [0, -2, 4, 0]
];
console.log(matrixMultiply(m2, m1));

/*
[ [ 0, 0, 0, 0 ],
  [ 0, 0, -2, 0 ],
  [ 0, 3, 0, 5 ],
  [ 0, -6, -4, -10 ] ]
 */